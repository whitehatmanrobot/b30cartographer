ne JET_ColInfo					0U
#define JET_ColInfoList 			1U
	/* CONSIDER: Info level 2 is valid */
#define JET_ColInfoSysTabCursor 	3U
#define JET_ColInfoBase 			4U
#define JET_ColInfoListCompact 		5U


	/* Attribute types for query definitions */

#define JET_qoaBeginDef 		0
#define JET_qoaOperation		1
#define JET_qoaParameter		2
#define JET_qoaOptions			3
#define JET_qoaDatabase 		4
#define JET_qoaInputTable		5
#define JET_qoaOutput			6
#define JET_qoaJoin				7
#define JET_qoaRestriction		8
#define JET_qoaGroup			9
#define JET_qoaGroupRstr		10
#define JET_qoaOrdering 		11
#define JET_qoaEndDef			255
#define JET_qoaValidLeast		JET_qoaOperation
#define JET_qoaValidMost		JET_qoaOrdering


	/* Query object options */

#define JET_bitFqoOutputAllCols 	0x0001
#define JET_bitFqoRemoveDups		0x0002
#define JET_bitFqoOwnerAccess		0x0004
#define JET_bitFqoDistinctRow		0x0008
#define JET_bitFqoTop				0x0010
#define JET_bitFqoPercent			0x0020
#define JET_bitFqoCorresponding		0x0040 /* JET_qopSetOperation */

	/* Query object join type */

#define JET_fjoinInner			1
#define JET_fjoinLeftOuter		2
#define JET_fjoinRightOuter		3

	/* Query object operations */

#define JET_qopSelect			1
#define JET_qopSelectInto		2
#define JET_qopInsertSelection	3
#define JET_qopUpdate			4
#define JET_qopDelete			5
#define JET_qopTransform		6
#define JET_qopDDL				7
#define JET_qopSqlPassThrough	8
#define JET_qopSetOperation		9
#define JET_qopSPTBulk			10

#define JET_bitqopSelect			0x0000
#define JET_bitqopTransform			0x0010
#define JET_bitqopDelete			0x0020
#define JET_bitqopUpdate			0x0030
#define JET_bitqopInsertSelection	0x0040
#define JET_bitqopSelectInto		0x0050
#define JET_bitqopDDL				0x0060
#define JET_bitqopSqlPassThrough	0x0070
#define JET_bitqopSetOperation		0x0080
#define JET_bitqopSPTBulk			0x0090

	/* Engine Object Types */

#define JET_objtypNil				0
#define JET_objtypTable 			1
#define JET_objtypDb				2
#define JET_objtypContainer			3
#define JET_objtypSQLLink			4
#define JET_objtypQuery 			5
#define JET_objtypLink				6
#define JET_objtypTemplate			7
#define JET_objtypRelationship		8

	/* All types less than JET_objtypClientMin are reserved by JET */

#define JET_objtypClientMin			0x8000

	/* Security Constant Values */

#define JET_cchUserNameMax		20
#define JET_cchPasswordMax		14

	/* Security Access Masks */

#define JET_acmNoAccess 		0x00000000L
#define JET_acmFullAccess		0x000FFFFFL

#define JET_acmSpecificMask		0x0000FFFFL
#define JET_acmSpecific_1		0x00000001L
#define JET_acmSpecific_2		0x00000002L
#define JET_acmSpecific_3		0x00000004L
#define JET_acmSpecific_4		0x00000008L
#define JET_acmSpecific_5		0x00000010L
#define JET_acmSpecific_6		0x00000020L
#define JET_acmSpecific_7		0x00000040L
#define JET_acmSpecific_8		0x00000080L
#define JET_acmSpecific_9		0x00000100L
#define JET_acmSpecific_10		0x00000200L
#define JET_acmSpecific_11		0x00000400L
#define JET_acmSpecific_12		0x00000800L
#define JET_acmSpecific_13		0x00001000L
#define JET_acmSpecific_14		0x00002000L
#define JET_acmSpecific_15		0x00004000L
#define JET_acmSpecific_16		0x00008000L

#define JET_acmStandardMask		0x00FF0000L
#define JET_acmDelete			0x00010000L
#define JET_acmReadControl		0x00020000L
#define JET_acmWriteDac 		0x00040000L
#define JET_acmWriteOwner		0x00080000L

#define JET_acmTblCreate			(JET_acmSpecific_1)
#define JET_acmTblAccessRcols		(JET_acmSpecific_2)
#define JET_acmTblReadDef			(JET_acmSpecific_3)
#define JET_acmTblWriteDef			(JET_acmSpecific_4)
#define JET_acmTblRetrieveData		(JET_acmSpecific_5)
#define JET_acmTblInsertData		(JET_acmSpecific_6)
#define JET_acmTblReplaceData		(JET_acmSpecific_7)
#define JET_acmTblDeleteData		(JET_acmSpecific_8)

#define JET_acmDbCreate 			(JET_acmSpecific_1)
#define JET_acmDbOpen				(JET_acmSpecific_2)

	/* Compact Options */

#define JET_bitCompactDontCopyLocale	0x00000004	/* Don't copy locale from source to dest */
#define JET_bitCompactVersion10			0x00000008	/* Destination is version 1.0 format */
#define JET_bitCompactVersion1x			0x00000010	/* Destination is version 1.x format */
#define JET_bitCompactStats				0x00000020	/* Dump off-line compaction stats (only when progress meter also specified) */

	/* On-line Compact Options */

#define JET_bitCompactOn	 			0x00000001	/* enable on-line compaction */

	/* Repair Notification Types */

#define JET_rntSelfContained		0
#define JET_rntDeletedIndex			1
#define JET_rntDeletedRec			2
#define JET_rntDeletedLv			3
#define JET_rntTruncated			4

	/* Status Notification Processes */

#define JET_snpIndex				0
#define JET_snpQuery				1
#define JET_snpRepair				2
#define JET_snpImex					3
#define JET_snpCompact				4
#define JET_snpFastFind 			5
#define JET_snpODBCNotReady			6
#define JET_snpQuerySort	   		7
#define JET_snpRestore				8
#define JET_snpBackup				9
#define JET_snpUpgrade				10

	/* Status Notification Types */

#define JET_sntProgress 		0	/* callback for progress */
#define JET_sntMessage			1
#define JET_sntBulkRecords		2	/* callback for # rec for bulk op */
#define JET_sntFail				3	/* callback for failure during progress */
#define JET_sntErrCount 		4	/* callback for err count */
#define JET_sntBegin			5	/* callback for beginning of operation */
#define JET_sntComplete 		6	/* callback for completion of operation */
#define JET_sntCantRollback		7	/* callback for no rollback */
#define JET_sntRestoreMap		8	/* callback for restore map */

	/* Message codes for JET_snpCompact */

#define JET_sncCopyObject		0	/* Starting to copy object */
#define JET_sncCopyFailed		1	/* Copy of this object failed */
#define JET_sncYield			2	/* Client can yield/check for user interrupt */
#define JET_sncTransactionFull	3	/* Client can yield/check for user interrupt */
#define JET_sncAboutToWrap		4	/* Find find is about to wrap */

	/* Message codes for JET_snpODBCNotReady */

#define JET_sncODBCNotReady		0	/* Waiting for results from ODBC */


	/* Constants for the [ODBC] section of JET.INI */

#define JET_SQLTraceCanonical	0x0001	/* Output ODBC Generic SQL */

	/* Constants for the [Debug] section of JET.INI */

	/* APITrace */

#define JET_APITraceEnter		0x0001
#define JET_APITraceExit		0x0002
#define JET_APITraceExitError	0x0004
#define JET_APIBreakOnError		0x0008
#define JET_APITraceCount		0x0010
#define JET_APITraceNoIdle		0x0020
#define JET_APITraceParameters	0x0040

	/* IdleTrace */

#define JET_IdleTraceCursor		0x0001
#define JET_IdleTraceBuffer		0x0002
#define JET_IdleTraceFlush		0x0004

	/* AssertAction */

#define JET_AssertExit			0x0000		/* Exit the application */
#define JET_AssertBreak 		0x0001		/* Break to debugger */
#define JET_AssertMsgBox		0x0002		/* Display message box */
#define JET_AssertStop			0x0004		/* Alert and stop */

	/* IOTrace */

#define JET_IOTraceAlloc		0x0001		/* DB Page Allocation */
#define JET_IOTraceFree 		0x0002		/* DB Page Free */
#define JET_IOTraceRead 		0x0004		/* DB Page Read */
#define JET_IOTraceWrite		0x0008		/* DB Page Write */
#define JET_IOTraceError		0x0010		/* DB Page I/O Error */

	/* MemTrace */

#define JET_MemTraceAlloc		0x0001		/* Memory allocation */
#define JET_MemTraceRealloc		0x0002		/* Memory reallocation */
#define JET_MemTraceFree		0x0004		/* Memory free */

	/* RmtTrace */

#define JET_RmtTraceError		0x0001	/* Remote server error message */
#define JET_RmtTraceSql			0x0002	/* Remote SQL Prepares & Exec's */
#define JET_RmtTraceAPI			0x0004	/* Remote ODBC API calls */
#define JET_RmtTraceODBC		0x0008
#define JET_RmtSyncODBC			0x0010	/* Turn on ODBC Sync mode */
	
/**********************************************************************/
/***********************     ERROR CODES     **************************/
/**********************************************************************/

/* SUCCESS */

#define JET_errSuccess						 0    /* Successful Operation */

/* ERRORS */

#define JET_wrnNyi							-1    /* Function Not Yet Implemented */

/*	SYSTEM errors
/**/
#define JET_errRfsFailure			   		-100  /* JET_errRfsFailure */
#define JET_errRfsNotArmed					-101  /* JET_errRfsFailure */
#define JET_errFileClose					-102  /* Could not close DOS file */
#define JET_errOutOfThreads					-103  /* Could not start thread */
#define JET_errTooManyIO		  			-105  /* System busy due to too many IOs */
#define JET_errDatabase200Format			-106  /* 200 format database */
#define JET_errDatabase400Format			-107  /* 400 format database */

/*	BUFFER MANAGER errors
/**/
#define wrnBFNotSynchronous					200	  /* Buffer page evicted */
#define wrnBFPageNotFound		  			201	  /* Page not found */
#define errBFInUse				  			-202  /* Cannot abandon buffer */
#define wrnBFNewIO							203	  /* Buffer access caused a new IO (cache miss) */
#define wrnBFCacheMiss						204	  /* Buffer access was a cache miss but didn't cause a new IO */
#define	wrnBFNoBufAvailable					205	  /* Need to allocate new buffer for read (used in Async IO ) */

/*	DIRECTORY MANAGER errors
/**/
#define errPMOutOfPageSpace					-300  /* Out of page space */
#define errPMItagTooBig 		  			-301  /* Itag too big */
#define errPMRecDeleted 		  			-302  /* Record deleted */
#define errPMTagsUsedUp 		  			-303  /* Tags used up */
#define wrnBMConflict			  			304   /* conflict in BM Clean up */
#define errDIRNoShortCircuit	  			-305  /* No Short Circuit Avail */
#define errDIRCannotSplit		  			-306  /* Cannot horizontally split FDP */
#define errDIRTop				  			-307  /* Cannot go up */
#define errDIRFDP							308	  /* On an FDP Node */
#define errDIRNotSynchronous				-309  /* May have left critical section */
#define wrnDIREmptyPage						310	  /* Moved through empty page */
#define errSPConflict						-311  /* Device extent being extended */
#define wrnNDFoundLess						312	  /* Found Less */
#define wrnNDFoundGreater					313	  /* Found Greater */
#define errNDOutSonRange					-314  /* Son out of range */
#define errNDOutItemRange					-315  /* Item out of range */
#define errNDGreaterThanAllItems 			-316  /* Greater than all items */
#define errNDLastItemNode					-317  /* Last node of item list */
#define errNDFirstItemNode					-318  /* First node of item list */
#define wrnNDDuplicateItem					319	  /* Duplicated Item */
#define errNDNoItem							-320  /* Item not there */
#define JET_wrnRemainingVersions 			321	  /* Some versions couldn't be cleaned */
#define JET_wrnPreviousVersion				322	  /* Version already existed */
#define JET_errPageBoundary					-323  /* Reached Page Boundary */
#define JET_errKeyBoundary		  			-324  /* Reached Key Boundary */
#define errDIRInPageFather  				-325  /* sridFather in page to free */
#define	errBMMaxKeyInPage					-326  /* used by OLC to avoid cleanup of parent pages */
#define	JET_errBadPageLink					-327  /* next/previous page link page does not point back to source */
#define	JET_errBadBookmark					-328  /* bookmark has no corresponding address in database */
#define wrnBMCleanNullOp					329	  /* BMClean returns this on encountering a page
												  /* deleted MaxKeyInPage [but there was no conflict]
												
/*	RECORD MANAGER errors
/**/
#define wrnFLDKeyTooBig 					400	  /* Key too big (truncated it) */
#define errFLDTooManySegments				-401  /* Too many key segments */
#define wrnFLDNullKey						402	  /* Key is entirely NULL */
#define wrnFLDOutOfKeys 					403	  /* No more keys to extract */
#define wrnFLDNullSeg						404	  /* Null segment in key */
#define wrnRECLongField 					405	  /* Separated long value */
#define JET_wrnSeparateLongValue			406	  /* Separated long value */
#define JET_wrnRecordFoundGreater			JET_wrnSeekNotEqual
#define JET_wrnRecordFoundLess    			JET_wrnSeekNotEqual
#define JET_errColumnIllegalNull  			JET_errNullInvalid
#define wrnFLDNullFirstSeg		   			407	  /* Null first segment in key */
#define JET_errKeyTooBig					-408  /* Key with column truncation still truncated */

/*	LOGGING/RECOVERY errors
/**/
#define JET_errInvalidLoggedOperation		-500  /* Logged operation cannot be redone */
#define JET_errLogFileCorrupt		  		-501  /* Log file is corrupt */
#define errLGNoMoreRecords					-502  /* Last log record read */
#define JET_errNoBackupDirectory 			-503  /* No backup directory given */
#define JET_errBackupDirectoryNotEmpty 		-504  /* The backup directory is not emtpy */
#define JET_errBackupInProgress 			-505  /* Backup is active already */
#define JET_errMissingPreviousLogFile		-509  /* Missing the log file for check point */
#define JET_errLogWriteFail					-510  /* Fail when writing to log file */
#define JET_errBadLogVersion  	  			-514  /* Version of log file is not compatible with Jet version */
#define JET_errInvalidLogSequence  			-515  /* Timestamp in next log does not match expected */
#define JET_errLoggingDisabled 				-516  /* Log is not active */
#define JET_errLogBufferTooSmall			-517  /* Log buffer is too small for recovery */
#define errLGNotSynchronous					-518  /* retry to LGLogRec */
#define JET_errLogSequenceEnd				-519  /* Exceed maximum log file number */
#define JET_errNoBackup						-520  /* No backup in progress */
#define	JET_errInvalidBackupSequence		-521  /* Backup call out of sequence */
#define JET_errBackupNotAllowedYet			-523  /* Can not do backup now */
#define JET_errDeleteBackupFileFail	   		-524  /* Could not delete backup file */
#define JET_errMakeBackupDirectoryFail 		-525  /* Could not make backup temp directory */
#define JET_errInvalidBackup		 		-526  /* Cannot incremental backup when circular logging enabled */
#define JET_errRecoveredWithErrors			-527  /* For repair, restored with errors */
#define JET_errMissingLogFile				-528  /* current log file missing */
#define JET_errLogDiskFull					-529  /* log disk full */
#define JET_errBadLogSignature				-530  /* bad signature for a log file */
#define JET_errBadDbSignature				-531  /* bad signature for a db file */
#define JET_errBadCheckpointSignature		-532  /* bad signature for a checkpoint file */
#define	JET_errCheckpointCorrupt			-533  /* checkpoint file not found or corrupt */
#define	JET_errMissingPatchPage				-534  /* patch file page not found during recovery */


#define JET_errDatabaseInconsistent			-550  /* database is in inconsistent state */
#define JET_errConsistentTimeMismatch		-551  /* database last consistent time unmatched */
#define JET_errDatabasePatchFileMismatch	-552  /* patch file is not generated from this backup */
#define JET_errEndingRestoreLogTooLow		-553  /* the starting log number too low for the restore */
#define JET_errStartingRestoreLogTooHigh	-554  /* the starting log number too high for the restore */
#define JET_errGivenLogFileHasBadSignature	-555  /* Restore log file has bad signature */
#define JET_errGivenLogFileIsNotContiguous	-556  /* Restore log file is not contiguous */
#define JET_errMissingRestoreLogFiles		-557  /* Some restore log files are missing */
#define JET_wrnExistingLogFileHasBadSignature	558  /* Existing log file has bad signature */
#define JET_wrnExistingLogFileIsNotContiguous	559  /* Existing log file is not contiguous */
#define JET_errMissingFullBackup			-560  /* The database miss a previous full backup befor incremental backup */
#define JET_errBadBackupDatabaseSize		-561  /* The backup database size is not in 4k */
#define JET_errDatabaseAlreadyUpgraded		-562  /* Attempted to upgrade a database that is already current */

#define JET_errTermInProgress		  		-1000 /* Termination in progress */
#define JET_errFeatureNotAvailable			-1001 /* API not supported */
#define JET_errInvalidName					-1002 /* Invalid name */
#define JET_errInvalidParameter 			-1003 /* Invalid API parameter */
#define JET_wrnColumnNull					 1004 /* Column is NULL-valued */
#define JET_wrnBufferTruncated				 1006 /* Buffer too small for data */
#define JET_wrnDatabaseAttached 			 1007 /* Database is already attached */
#define JET_errDatabaseFileReadOnly			-1008 /* Attach a readonly database file for read/write operations */
#define JET_wrnSortOverflow					 1009 /* Sort does not fit in memory */
#define JET_errInvalidDatabaseId			-1010 /* Invalid database id */
#define JET_errOutOfMemory					-1011 /* Out of Memory */
#define JET_errOutOfDatabaseSpace 			-1012 /* Maximum database size reached */
#define JET_errOutOfCursors					-1013 /* Out of table cursors */
#define JET_errOutOfBuffers					-1014 /* Out of database page buffers */
#define JET_errTooManyIndexes				-1015 /* Too many indexes */
#define JET_errTooManyKeys					-1016 /* Too many columns in an index */
#define JET_errRecordDeleted				-1017 /* Record has been deleted */
#define JET_errReadVerifyFailure			-1018 /* Read verification error */
#define JET_errOutOfFileHandles	 			-1020 /* Out of file handles */
#define JET_errDiskIO						-1022 /* Disk IO error */
#define JET_errInvalidPath					-1023 /* Invalid file path */
#define JET_errRecordTooBig					-1026 /* Record larger than maximum size */
#define JET_errTooManyOpenDatabases			-1027 /* Too many open databases */
#define JET_errInvalidDatabase				-1028 /* Not a database file */
#define JET_errNotInitialized				-1029 /* JetInit not yet called */
#define JET_errAlreadyInitialized			-1030 /* JetInit already called */
#define JET_errFileAccessDenied 			-1032 /* Cannot access file */
#define JET_errQueryNotSupported			-1034 /* Query support unavailable */
#define JET_errSQLLinkNotSupported			-1035 /* SQL Link support unavailable */
#define JET_errBufferTooSmall				-1038 /* Buffer is too small */
#define JET_wrnSeekNotEqual					 1039 /* SeekLE or SeekGE didn't find exact match */
#define JET_errTooManyColumns				-1040 /* Too many columns defined */
#define JET_errContainerNotEmpty			-1043 /* Container is not empty */
#define JET_errInvalidFilename				-1044 /* Filename is invalid */
#define JET_errInvalidBookmark				-1045 /* Invalid bookmark */
#define JET_errColumnInUse					-1046 /* Column used in an index */
#define JET_errInvalidBufferSize			-1047 /* Data buffer doesn't match column size */
#define JET_errColumnNotUpdatable			-1048 /* Cannot set column value */
#define JET_errIndexInUse					-1051 /* Index is in use */
#define JET_errLinkNotSupported 			-1052 /* Link support unavailable */
#define JET_errNullKeyDisallowed			-1053 /* Null keys are disallowed on index */
#define JET_errNotInTransaction 			-1054 /* Operation must be within a transaction */
#define JET_wrnNoErrorInfo					1055  /* No extended error information */
#define JET_wrnNoIdleActivity		 		1058  /* No idle activity occured */
#define JET_errTooManyActiveUsers			-1059 /* Too many active database users */
#define JET_errInvalidAppend				-1060 /* Cannot append long value */
#define JET_errInvalidCountry				-1061 /* Invalid or unknown country code */
#define JET_errInvalidLanguageId			-1062 /* Invalid or unknown language id */
#define JET_errInvalidCodePage				-1063 /* Invalid or unknown code page */
#define JET_wrnNoWriteLock					1067  /* No write lock at transaction level 0 */
#define JET_wrnColumnSetNull		   		 1068 /* Column set to NULL-value */
#define JET_errVersionStoreOutOfMemory		-1069 /* lMaxVerPages exceeded (XJET only) */
#define JET_errCurrencyStackOutOfMemory		-1070 /* lCSRPerfFUCB * lMaxCursors exceeded (XJET only) */
#define JET_errOutOfSessions  				-1101 /* Out of sessions */
#define JET_errWriteConflict				-1102 /* Write lock failed due to outstanding write lock */
#define JET_errTransTooDeep					-1103 /* Xactions nested too deeply */
#define JET_errInvalidSesid					-1104 /* Invalid session handle */
#define JET_errSessionWriteConflict			-1107 /* Another session has private version of page */
#define JET_errInTransaction				-1108 /* Operation not allowed within a transaction */
#define JET_errDatabaseDuplicate			-1201 /* Database already exists */
#define JET_errDatabaseInUse				-1202 /* Database in use */
#define JET_errDatabaseNotFound 			-1203 /* No such database */
#define JET_errDatabaseInvalidName			-1204 /* Invalid database name */
#define JET_errDatabaseInvalidPages			-1205 /* Invalid number of pages */
#define JET_errDatabaseCorrupted			-1206 /* non-db file or corrupted db */
#define JET_errDatabaseLocked				-1207 /* Database exclusively locked */
#define	JET_errCannotDisableVersioning		-1208 /* Cannot disable versioning for this database */
#define JET_wrnTableEmpty			 		1301  /* Open an empty table */
#define JET_errTableLocked					-1302 /* Table is exclusively locked */
#define JET_errTableDuplicate				-1303 /* Table already exists */
#define JET_errTableInUse					-1304 /* Table is in use, cannot lock */
#define JET_errObjectNotFound				-1305 /* No such table or object */
#define JET_errDensityInvalid				-1307 /* Bad file/index density */
#define JET_errTableNotEmpty				-1308 /* Cannot define clustered index */
#define JET_errInvalidTableId				-1310 /* Invalid table id */
#define JET_errTooManyOpenTables			-1311 /* Cannot open any more tables */
#define JET_errIllegalOperation 			-1312 /* Oper. not supported on table */
#define JET_errObjectDuplicate				-1314 /* Table or object name in use */
#define JET_errInvalidObject				-1316 /* object is invalid for operation */
#define JET_errIndexCantBuild				-1401 /* Cannot build clustered index */
#define JET_errIndexHasPrimary				-1402 /* Primary index already defined */
#define JET_errIndexDuplicate				-1403 /* Index is already defined */
#define JET_errIndexNotFound				-1404 /* No such index */
#define JET_errIndexMustStay				-1405 /* Cannot delete clustered index */
#define JET_errIndexInvalidDef				-1406 /* Illegal index definition */
#define JET_errIndexHasClustered			-1408 /* Clustered index already defined */
#define JET_errInvalidCreateIndex	 		-1409 /* Invali create index description */
#define JET_errTooManyOpenIndexes			-1410 /* Out of index description blocks */
#define JET_errColumnLong					-1501 /* Column value is long */
#define JET_errColumnNoChunk				-1502 /* no such chunk in long value */
#define JET_errColumnDoesNotFit 			-1503 /* Field will not fit in record */
#define JET_errNullInvalid					-1504 /* Null not valid */
#define JET_errColumnIndexed				-1505 /* Column indexed, cannot delete */
#define JET_errColumnTooBig					-1506 /* Field length is > maximum */
#define JET_errColumnNotFound				-1507 /* No such column */
#define JET_errColumnDuplicate				-1508 /* Field is already defined */
#define JET_errColumn2ndSysMaint			-1510 /* Second autoinc or version column */
#define JET_errInvalidColumnType			-1511 /* Invalid column data type */
#define JET_wrnColumnMaxTruncated	 		1512  /* Max length too big, truncated */
#define JET_errColumnCannotIndex			-1513 /* Cannot index Bit,LongText,LongBinary */
#define JET_errTaggedNotNULL				-1514 /* No non-NULL tagged columns */
#define JET_errNoCurrentIndex				-1515 /* Invalid w/o a current index */
#define JET_errKeyIsMade					-1516 /* The key is completely made */
#define JET_errBadColumnId					-1517 /* Column Id Incorrect */
#define JET_errBadItagSequence				-1518 /* Bad itagSequence for tagged column */
#define JET_errColumnInRelationship			-1519 /* Cannot delete, column participates in relationship */
#define JET_wrnCopyLongValue				1520  /* Single instance column bursted */
#define JET_errCannotBeTagged				-1521 /* AutoIncrement and Version cannot be tagged */
#define JET_errRecordNotFound				-1601 /* The key was not found */
#define JET_errRecordNoCopy					-1602 /* No working buffer */
#define JET_errNoCurrentRecord				-1603 /* Currency not on a record */
#define JET_errRecordClusteredChanged		-1604 /* Clustered key may not change */
#define JET_errKeyDuplicate					-1605 /* Illegal duplicate key */
#define JET_errAlreadyPrepared				-1607 /* Already copy/clear current */
#define JET_errKeyNotMade					-1608 /* No call to JetMakeKey */
#define JET_errUpdateNotPrepared			-1609 /* No call to JetPrepareUpdate */
#define JET_wrnDataHasChanged		 		1610  /* Data has changed */
#define JET_errDataHasChanged				-1611 /* Data has changed, operation aborted */
#define JET_wrnKeyChanged			 		1618  /* Moved to new key */
#define JET_errTooManySorts					-1701 /* Too many sort processes */
#define JET_errInvalidOnSort				-1702 /* Invalid operation on Sort */
#define JET_errTempFileOpenError			-1803 /* Temp file could not be opened */
#define JET_errTooManyAttachedDatabases 	-1805 /* Too many open databases */
#define JET_errDiskFull 					-1808 /* No space left on disk */
#define JET_errPermissionDenied 			-1809 /* Permission denied */
#define JET_errFileNotFound					-1811 /* File not found */
#define JET_wrnFileOpenReadOnly				1813  /* Database file is read only */
#define JET_errAfterInitialization			-1850 /* Cannot Restore after init. */
#define JET_errLogCorrupted					-1852 /* Logs could not be interpreted */
#define JET_errInvalidOperation 			-1906 /* invalid operation */
#define JET_errAccessDenied					-1907 /* access denied */
#define JET_wrnIdleFull						 1908 /* ilde registry full */


/**********************************************************************/
/***********************     PROTOTYPES      **************************/
/**********************************************************************/

#if !defined(_JET_NOPROTOTYPES)

JET_ERR JET_API JetInit(JET_INSTANCE *pinstance);

JET_ERR JET_API JetTerm(JET_INSTANCE instance);

JET_ERR JET_API JetTerm2( JET_INSTANCE instance, JET_GRBIT grbit );

JET_ERR JET_API JetSetSystemParameter(JET_INSTANCE *pinstance, JET_SESID sesid, unsigned long paramid,
	ULONG_PTR lParam, const char *sz);

JET_ERR JET_API JetGetSystemParameter(JET_INSTANCE instance, JET_SESID sesid, unsigned long paramid,
	ULONG_PTR *plParam, char *sz, unsigned long cbMax);

#define ctAccessPage			1
#define ctLatchConflict			2
#define ctSplitRetry			3
#define ctNeighborPageScanned	4
#define ctSplits				5
JET_ERR JET_API JetResetCounter( JET_SESID sesid, long CounterType );
JET_ERR JET_API JetGetCounter( JET_SESID sesid, long CounterType, long *plValue );

JET_ERR JET_API JetBeginSession(JET_INSTANCE instance, JET_SESID *psesid,
	const char *szUserName, const char *szPassword);

JET_ERR JET_API JetDupSession(JET_SESID sesid, JET_SESID *psesid);

JET_ERR JET_API JetEndSession(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetGetVersion(JET_SESID sesid, unsigned long *pwVersion);

JET_ERR JET_API JetIdle(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetCreateDatabase(JET_SESID sesid,
	const char *szFilename, const char *szConnect,
	JET_DBID *pdbid, JET_GRBIT grbit);

JET_ERR JET_API JetAttachDatabase(JET_SESID sesid, const char *szFilename, JET_GRBIT grbit );

JET_ERR JET_API JetDetachDatabase(JET_SESID sesid, const char *szFilename);

JET_ERR JET_API JetCreateTable(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName, unsigned long lPages, unsigned long lDensity,
	JET_TABLEID *ptableid);

JET_ERR JET_API JetCreateTableColumnIndex( JET_SESID sesid, JET_DBID dbid,
	JET_TABLECREATE *ptablecreate );

JET_ERR JET_API JetDeleteTable(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName);

JET_ERR JET_API JetGetTableColumnInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char *szColumnName, void *pvResult, unsigned long cbMax,
	unsigned long InfoLevel);

JET_ERR JET_API JetGetColumnInfo(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName, const char *szColumnName,
	void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetAddColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char *szColumn, const JET_COLUMNDEF *pcolumndef,
	const void *pvDefault, unsigned long cbDefault,
	JET_COLUMNID *pcolumnid);

JET_ERR JET_API JetDeleteColumn(JET_SESID sesid, JET_TABLEID tableid,
	const char *szColumn);

JET_ERR JET_API JetGetTableIndexInfo(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName, void *pvResult, unsigned long cbResult,
	unsigned long InfoLevel);

JET_ERR JET_API JetGetTableInfo(JET_SESID sesid, JET_TABLEID tableid,
	void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetGetIndexInfo(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName, const char *szIndexName,
	void *pvResult, unsigned long cbResult, unsigned long InfoLevel);

JET_ERR JET_API JetCreateIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName, JET_GRBIT grbit,
	const char *szKey, unsigned long cbKey, unsigned long lDensity);

JET_ERR JET_API JetDeleteIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName);

JET_ERR JET_API JetGetObjectInfo(JET_SESID sesid, JET_DBID dbid,
	JET_OBJTYP objtyp, const char *szContainerName,
	const char *szObjectName, void *pvResult, unsigned long cbMax,
	unsigned long InfoLevel);

JET_ERR JET_API JetBeginTransaction(JET_SESID sesid);

JET_ERR JET_API JetCommitTransaction(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetRollback(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API JetGetDatabaseInfo(JET_SESID sesid, JET_DBID dbid,
	void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetCloseDatabase(JET_SESID sesid, JET_DBID dbid,
	JET_GRBIT grbit);

JET_ERR JET_API JetCloseTable(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetOpenDatabase(JET_SESID sesid, const char *szFilename,
	const char *szConnect, JET_DBID *pdbid, JET_GRBIT grbit);

JET_ERR JET_API JetOpenTable(JET_SESID sesid, JET_DBID dbid,
	const char *szTableName, const void *pvParameters,
	unsigned long cbParameters, JET_GRBIT grbit, JET_TABLEID *ptableid);

JET_ERR JET_API JetDelete(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API JetUpdate(JET_SESID sesid, JET_TABLEID tableid,
	void *pvBookmark, unsigned long cbBookmark,
	unsigned long *pcbActual);

JET_ERR JET_API JetRetrieveColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, void *pvData, unsigned long cbData,
	unsigned long *pcbActual, JET_GRBIT grbit, JET_RETINFO *pretinfo);

JET_ERR JET_API JetRetrieveColumns( JET_SESID sesid, JET_TABLEID tableid,
	JET_RETRIEVECOLUMN *pretrievecolumn, unsigned long cretrievecolumn );

JET_ERR JET_API JetSetColumn(JET_SESID sesid, JET_TABLEID tableid,
	JET_COLUMNID columnid, const void *pvData, unsigned long cbData,
	JET_GRBIT grbit, JET_SETINFO *psetinfo);

JET_ERR JET_API JetSetColumns(JET_SESID sesid, JET_TABLEID tableid,
	JET_SETCOLUMN *psetcolumn, unsigned long csetcolumn );

JET_ERR JET_API JetPrepareUpdate(JET_SESID sesid, JET_TABLEID tableid,
	unsigned long prep);

JET_ERR JET_API JetGetRecordPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS *precpos, unsigned long cbRecpos);

JET_ERR JET_API JetGotoPosition(JET_SESID sesid, JET_TABLEID tableid,
	JET_RECPOS *precpos );

JET_ERR JET_API JetGetCursorInfo(JET_SESID sesid, JET_TABLEID tableid,
	void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API JetDupCursor(JET_SESID sesid, JET_TABLEID tableid,
	JET_TABLEID *ptableid, JET_GRBIT grbit);

JET_ERR JET_API JetGetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	char *szIndexName, unsigned long cchIndexName);

JET_ERR JET_API JetSetCurrentIndex(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName);

JET_ERR JET_API JetSetCurrentIndex2(JET_SESID sesid, JET_TABLEID tableid,
	const char *szIndexName, JET_GRBIT grbit );

JET_ERR JET_API JetMove(JET_SESID sesid, JET_TABLEID tableid,
	long cRow, JET_GRBIT grbit);

JET_ERR JET_API JetMakeKey(JET_SESID sesid, JET_TABLEID tableid,
	const void *pvData, unsigned long cbData, JET_GRBIT grbit);

JET_ERR JET_API JetSeek(JET_SESID sesid, JET_TABLEID tableid,
	JET_GRBIT grbit);

JET_ERR JET_API JetGetBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void *pvBookmark, unsigned long cbMax,
	unsigned long *pcbActual);
	
JET_ERR JET_API JetCompact(JET_SESID sesid, const char *szDatabaseSrc,
	const char *szDatabaseDest, JET_PFNSTATUS pfnStatus, JET_CONVERT *pconvert,
	JET_GRBIT grbit);

JET_ERR JET_API JetDBUtilities( JET_DBUTIL *pdbutil );	

JET_ERR JET_API JetGotoBookmark(JET_SESID sesid, JET_TABLEID tableid,
	void *pvBookmark, unsigned long cbBookmark);

JET_ERR JET_API JetComputeStats(JET_SESID sesid, JET_TABLEID tableid);

typedef ULONG_PTR JET_VSESID;          /* Received from dispatcher */

struct tagVDBFNDEF;

typedef ULONG_PTR JET_VDBID;           /* Received from dispatcher */

struct tagVTFNDEF;

typedef ULONG_PTR JET_VTID;            /* Received from dispatcher */

JET_ERR JET_API JetOpenTempTable(JET_SESID sesid,
	const JET_COLUMNDEF *prgcolumndef, unsigned long ccolumn,
	JET_GRBIT grbit, JET_TABLEID *ptableid,
	JET_COLUMNID *prgcolumnid);

JET_ERR JET_API JetOpenTempTable2( JET_SESID sesid,
	const JET_COLUMNDEF *prgcolumndef,
	unsigned long ccolumn,
	unsigned long langid,
	JET_GRBIT grbit,
	JET_TABLEID *ptableid,
	JET_COLUMNID *prgcolumnid );

JET_ERR JET_API JetBackup( const char *szBackupPath, JET_GRBIT grbit, JET_PFNSTATUS pfnStatus );

JET_ERR JET_API JetRestore(const char *sz, JET_PFNSTATUS pfn );
JET_ERR JET_API JetRestore2(const char *sz, const char *szDest, JET_PFNSTATUS pfn );

JET_ERR JET_API JetSetIndexRange(JET_SESID sesid,
	JET_TABLEID tableidSrc, JET_GRBIT grbit);

JET_ERR JET_API JetIndexRecordCount(JET_SESID sesid,
	JET_TABLEID tableid, unsigned long *pcrec, unsigned long crecMax );

JET_ERR JET_API JetRetrieveKey(JET_SESID sesid,
	JET_TABLEID tableid, void *pvData, unsigned long cbMax,
	unsigned long *pcbActual, JET_GRBIT grbit );

JET_ERR JET_API JetBeginExternalBackup( JET_GRBIT grbit );

JET_ERR JET_API JetGetAttachInfo( void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual );

JET_ERR JET_API JetOpenFile( const char *szFileName,
	JET_HANDLE	*phfFile,
	unsigned long *pulFileSizeLow,
	unsigned long *pulFileSizeHigh );

JET_ERR JET_API JetReadFile( JET_HANDLE hfFile,
	void *pv,
	unsigned long cb,
	unsigned long *pcb );

JET_ERR JET_API JetCloseFile( JET_HANDLE hfFile );

JET_ERR JET_API JetGetLogInfo( void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual );

JET_ERR JET_API JetTruncateLog( void );

JET_ERR JET_API JetEndExternalBackup( void );

JET_ERR JET_API JetExternalRestore( char *szCheckpointFilePath, char *szLogPath, JET_RSTMAP *rgstmap, long crstfilemap, char *szBackupLogPath, long genLow, long genHigh, JET_PFNSTATUS pfn );

#endif	/* _JET_NOPROTOTYPES */

#pragma pack()

#ifdef	__cplusplus
}
#endif

#endif	/* _JET_INCLUDED */




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\keymgr.h ===
#ifndef _KEYMGR_H_
#define _KEYMGR_H_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    KEYMGR.H

Abstract:

    KeyMgr application public API definitions
     
Author:

    990917  johnhaw Created. 
    georgema        000310  updated

Environment:
    Win98, Win2000

Revision History:

--*/
#ifdef __cplusplus
extern "C" {
#endif
BOOL WINAPI DllMain(HINSTANCE,DWORD,LPVOID);
LONG WINAPI CPlApplet(HWND hwndCPl,UINT uMsg,LPARAM lParam1,LPARAM lParam2);
void APIENTRY KRShowKeyMgr(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowSaveWizardW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowSaveWizardExW(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowSaveFromMsginaW(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowRestoreWizardW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowRestoreWizardExW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowRestoreFromMsginaW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
#ifdef __cplusplus
}
#endif
#endif  //  _KEYMGR_H_

//
///// End of file: KeyMgr.h ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\lsaimp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsaimp.h

Abstract:

    Local Security Authority Protected Subsystem - Private Includes

Author:

    Scott Birrell       (ScottBi)       April 24, 1991

Environment:

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windef.h>
#include <winbase.h>
#include <lsass.h>
#include <lsaicli.h>
#include <wincred.h>
#include <credp.h>
#include <adtgen.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\llsapi.h ===
/*++

Copyright (c) 1994-95  Microsoft Corporation

Module Name:

   llsapi.h

Abstract:

   License logging server's RPC API's.

Author:

   Arthur Hanson (arth) 21-Mar-1995

Environment:

   User Mode - Win32

Revision History:

   Jeff Parham (jeffparh) 04-Dec-1995
      o  Added type definitions, macros, and prototypes for extended RPC APIs
         and license certificate APIs (available only post-3.51).
      o  Corrected prototypes for LlsServerEnumW(), LlsServerEnumA(),
         LlsLocalProductInfoGetW(), and LlsLocalProductInfoGetA().

--*/

#ifndef _LLSAPI_H
#define _LLSAPI_H

#ifdef __cplusplus
extern "C" {
#endif


#define LLS_FLAG_LICENSED           0x0001
#define LLS_FLAG_UPDATE             0x0002
#define LLS_FLAG_SUITE_USE          0x0004
#define LLS_FLAG_SUITE_AUTO         0x0008

#define LLS_FLAG_PRODUCT_PERSEAT    0x0010
#define LLS_FLAG_PRODUCT_SWITCH     0x0020

#define LLS_FLAG_DELETED            0x1000


typedef PVOID LLS_HANDLE, *PLLS_HANDLE;
typedef PVOID LLS_REPL_HANDLE, *PLLS_REPL_HANDLE;

#define LLS_INVALID_LICENSE_HANDLE  ( 0xFFFFFFFF )

#define LLS_NUM_SECRETS             ( 4 )

typedef struct _LLS_LICENSE_INFO_0 {
   LPTSTR Product;
   LONG   Quantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
} LLS_LICENSE_INFO_0, *PLLS_LICENSE_INFO_0;

typedef struct _LLS_LICENSE_INFO_1 {
   LPTSTR Product;
   LPTSTR Vendor;
   LONG   Quantity;
   DWORD  MaxQuantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
   DWORD  AllowedModes;
   DWORD  CertificateID;
   LPTSTR Source;
   DWORD  ExpirationDate;
   DWORD  Secrets[ LLS_NUM_SECRETS ];
} LLS_LICENSE_INFO_1, *PLLS_LICENSE_INFO_1;

typedef struct _LLS_PRODUCT_INFO_0 {
   LPTSTR Product;
} LLS_PRODUCT_INFO_0, *PLLS_PRODUCT_INFO_0;

typedef struct _LLS_PRODUCT_INFO_1 {
   LPTSTR Product;
   ULONG  Purchased;
   ULONG  InUse;
   ULONG  ConcurrentTotal;
   ULONG  HighMark;
} LLS_PRODUCT_INFO_1, *PLLS_PRODUCT_INFO_1;

typedef struct _LLS_PRODUCT_USER_INFO_0 {
   LPTSTR User;
} LLS_PRODUCT_USER_INFO_0, *PLLS_PRODUCT_USER_INFO_0;

typedef struct _LLS_PRODUCT_USER_INFO_1 {
   LPTSTR User;
   DWORD  Flags;
   DWORD  LastUsed;
   ULONG  UsageCount;
} LLS_PRODUCT_USER_INFO_1, *PLLS_PRODUCT_USER_INFO_1;


typedef struct _LLS_PRODUCT_LICENSE_INFO_0 {
   LONG   Quantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
} LLS_PRODUCT_LICENSE_INFO_0, *PLLS_PRODUCT_LICENSE_INFO_0;

typedef struct _LLS_PRODUCT_LICENSE_INFO_1 {
   LONG   Quantity;
   DWORD  MaxQuantity;
   DWORD  Date;
   LPTSTR Admin;
   LPTSTR Comment;
   DWORD  AllowedModes;
   DWORD  CertificateID;
   LPTSTR Source;
   DWORD  ExpirationDate;
   DWORD  Secrets[ LLS_NUM_SECRETS ];
} LLS_PRODUCT_LICENSE_INFO_1, *PLLS_PRODUCT_LICENSE_INFO_1;

typedef struct _LLS_USER_INFO_0 {
   LPTSTR Name;
} LLS_USER_INFO_0, *PLLS_USER_INFO_0;

typedef struct _LLS_USER_INFO_1 {
   LPTSTR Name;
   DWORD  Flags;
   LPTSTR Group;
   ULONG  Licensed;
   ULONG  UnLicensed;
} LLS_USER_INFO_1, *PLLS_USER_INFO_1;

typedef struct _LLS_USER_INFO_2 {
   LPTSTR Name;
   DWORD  Flags;
   LPTSTR Group;
   ULONG  Licensed;
   ULONG  UnLicensed;
   LPTSTR Products;
} LLS_USER_INFO_2, *PLLS_USER_INFO_2;

typedef struct _LLS_USER_PRODUCT_INFO_0 {
   LPTSTR Product;
} LLS_USER_PRODUCT_INFO_0, *PLLS_USER_PRODUCT_INFO_0;

typedef struct _LLS_USER_PRODUCT_INFO_1 {
   LPTSTR Product;
   DWORD  Flags;
   DWORD  LastUsed;
   ULONG  UsageCount;
} LLS_USER_PRODUCT_INFO_1, *PLLS_USER_PRODUCT_INFO_1;

typedef struct _LLS_GROUP_INFO_0 {
   LPTSTR Name;
} LLS_GROUP_INFO_0, *PLLS_GROUP_INFO_0;

typedef struct _LLS_GROUP_INFO_1 {
   LPTSTR Name;
   LPTSTR Comment;
   ULONG  Licenses;
} LLS_GROUP_INFO_1, *PLLS_GROUP_INFO_1;


#define LLS_REPLICATION_TYPE_DELTA  0
#define LLS_REPLICATION_TYPE_TIME   1

#define LLS_MODE_LICENSE_SERVER     0
#define LLS_MODE_PDC                1
#define LLS_MODE_ENTERPRISE_SERVER  2

typedef struct _LLS_SERVICE_INFO_0 {
   DWORD Version;
   DWORD TimeStarted;
   DWORD Mode;
   LPTSTR ReplicateTo;
   LPTSTR EnterpriseServer;
   DWORD ReplicationType;
   DWORD ReplicationTime;
   DWORD UseEnterprise;
   DWORD LastReplicated;
} LLS_SERVICE_INFO_0, *PLLS_SERVICE_INFO_0;

typedef struct _LLS_CONNECT_INFO_0 {
   LPTSTR Domain;
   LPTSTR EnterpriseServer;
} LLS_CONNECT_INFO_0, *PLLS_CONNECT_INFO_0;


typedef struct _LLS_SERVER_PRODUCT_INFO_0 {
   LPTSTR Name;
} LLS_SERVER_PRODUCT_INFO_0, *PLLS_SERVER_PRODUCT_INFO_0;

typedef struct _LLS_SERVER_PRODUCT_INFO_1 {
   LPTSTR Name;
   DWORD Flags;
   ULONG MaxUses;
   ULONG MaxSetUses;
   ULONG HighMark;
} LLS_SERVER_PRODUCT_INFO_1, *PLLS_SERVER_PRODUCT_INFO_1;


typedef struct _LLS_SERVER_INFO_0 {
   LPTSTR Name;
} LLS_SERVER_INFO_0, *PLLS_SERVER_INFO_0;

typedef struct _LLS_CERTIFICATE_CLAIM_INFO_0
{
   TCHAR    ServerName[ 1 + MAX_COMPUTERNAME_LENGTH ];
   LONG     Quantity;
} LLS_CERTIFICATE_CLAIM_INFO_0, *PLLS_CERTIFICATE_CLAIM_INFO_0;

typedef struct _LLS_LOCAL_SERVICE_INFO_0
{
   LPTSTR   KeyName;
   LPTSTR   DisplayName;
   LPTSTR   FamilyDisplayName;
   DWORD    Mode;
   DWORD    FlipAllow;
   DWORD    ConcurrentLimit;
   DWORD    HighMark;
} LLS_LOCAL_SERVICE_INFO_0, *PLLS_LOCAL_SERVICE_INFO_0;

#define LLS_LICENSE_MODE_PER_SEAT            ( 0 )
#define LLS_LICENSE_MODE_PER_SERVER          ( 1 )

#define LLS_LICENSE_MODE_ALLOW_PER_SEAT      ( 1 )
#define LLS_LICENSE_MODE_ALLOW_PER_SERVER    ( 2 )

#define LLS_LICENSE_FLIP_ALLOW_PER_SEAT      ( 1 )
#define LLS_LICENSE_FLIP_ALLOW_PER_SERVER    ( 2 )


// capability flags; query with LlsCapabilityIsSupported
#define LLS_CAPABILITY_SECURE_CERTIFICATES         (  0 )
#define LLS_CAPABILITY_REPLICATE_CERT_DB           (  1 )
#define LLS_CAPABILITY_REPLICATE_PRODUCT_SECURITY  (  2 )
#define LLS_CAPABILITY_REPLICATE_USERS_EX          (  3 )
#define LLS_CAPABILITY_SERVICE_INFO_GETW           (  4 )
#define LLS_CAPABILITY_LOCAL_SERVICE_API           (  5 )
#define LLS_CAPABILITY_MAX                         ( 32 )


//***************************************************
//* Nt LS API data constants
//* (for use with LlsLicenseRequest() API)
//***************************************************

#define NT_LS_USER_NAME               ((ULONG) 0)  // username only
#define NT_LS_USER_SID                ((ULONG) 1)  // SID only


#ifndef NO_LLS_APIS
//
// Connection control API's
//

NTSTATUS
NTAPI
LlsConnectW(
   IN  LPWSTR Server,
   OUT PLLS_HANDLE Handle
   );

NTSTATUS
NTAPI
LlsConnectA(
   IN  LPSTR Server,
   OUT PLLS_HANDLE Handle
   );
#ifdef UNICODE
#  define LlsConnect LlsConnectW
#else
#  define LlsConnect LlsConnectA
#endif

typedef NTSTATUS (NTAPI *PLLS_CONNECT_W)( LPWSTR, PLLS_HANDLE );
typedef NTSTATUS (NTAPI *PLLS_CONNECT_A)( LPSTR,  PLLS_HANDLE );

NTSTATUS
NTAPI
LlsConnectEnterpriseW(
   IN  LPWSTR Focus,
   OUT PLLS_HANDLE Handle,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );

NTSTATUS
NTAPI
LlsConnectEnterpriseA(
   IN  LPSTR Focus,
   OUT PLLS_HANDLE Handle,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );
#ifdef UNICODE
#define LlsConnectEnterprise LlsConnectEnterpriseW
#else
#define LlsConnectEnterprise LlsConnectEnterpriseA
#endif

typedef NTSTATUS (NTAPI *PLLS_CONNECT_ENTERPRISE_W)( LPWSTR, PLLS_HANDLE, DWORD, LPBYTE * );
typedef NTSTATUS (NTAPI *PLLS_CONNECT_ENTERPRISE_A)( LPSTR,  PLLS_HANDLE, DWORD, LPBYTE * );

NTSTATUS 
NTAPI
LlsClose(        
   IN LLS_HANDLE Handle
   );

typedef NTSTATUS (NTAPI *PLLS_CLOSE)( LLS_HANDLE );

NTSTATUS 
NTAPI
LlsFreeMemory(
    IN PVOID bufptr
    );

typedef NTSTATUS (NTAPI *PLLS_FREE_MEMORY)( PVOID );

NTSTATUS
NTAPI
LlsEnterpriseServerFindW(
   IN  LPWSTR Focus,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );

NTSTATUS
NTAPI
LlsEnterpriseServerFindA(
   IN  LPSTR Focus,
   IN  DWORD Level,
   OUT LPBYTE *bufptr
   );
#ifdef UNICODE
#define LlsEnterpriseServerFind LlsEnterpriseServerFindW
#else
#define LlsEnterpriseServerFind LlsEnterpriseServerFindA
#endif

//
// License control API's
//

// Enum purchase history of licenses for all products.
NTSTATUS
NTAPI
LlsLicenseEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,    
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsLicenseEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,    
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsLicenseEnum LlsLicenseEnumW
#else
#define LlsLicenseEnum LlsLicenseEnumA
#endif

// Add purchase of license for a product.
NTSTATUS
NTAPI
LlsLicenseAddW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,         // Level 0 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsLicenseAddA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,         // Level 0 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsLicenseAdd LlsLicenseAddW
#else
#define LlsLicenseAdd LlsLicenseAddA
#endif

typedef NTSTATUS (NTAPI *PLLS_LICENSE_ADD_W)( LLS_HANDLE, DWORD, LPBYTE );
typedef NTSTATUS (NTAPI *PLLS_LICENSE_ADD_A)( LLS_HANDLE, DWORD, LPBYTE );

//
// Product control API's
//
// Product is SQL, BackOffice, Exchange, Etc. (Even though BackOffice isn't
// a product - we count it like one to keep things simplistic.
//

// Enum all products with purchase and InUse info.
NTSTATUS
NTAPI
LlsProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductEnum LlsProductEnumW
#else
#define LlsProductEnum LlsProductEnumA
#endif

// Add purchase of license for a product.
NTSTATUS
NTAPI
LlsProductAddW(
   IN LLS_HANDLE Handle,
   IN LPWSTR ProductFamily,
   IN LPWSTR Product,
   IN LPWSTR Version
   );

NTSTATUS
NTAPI
LlsProductAddA(
   IN LLS_HANDLE Handle,
   IN LPSTR ProductFamily,
   IN LPSTR Product,
   IN LPSTR Version
   );
#ifdef UNICODE
#define LlsProductAdd LlsProductAddW
#else
#define LlsProductAdd LlsProductAddA
#endif

// For a particular product enum all users.
NTSTATUS
NTAPI
LlsProductUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsProductUserEnum LlsProductUserEnumW
#else
#define LlsProductUserEnum LlsProductUserEnumA
#endif

// For a particular product enum all license purchases.
NTSTATUS
NTAPI
LlsProductLicenseEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,   
   IN     DWORD      prefmaxlen, 
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductLicenseEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Level 0 supported
   OUT    LPBYTE*    bufptr,   
   IN     DWORD      prefmaxlen, 
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

#ifdef UNICODE
#define LlsProductLicenseEnum LlsProductLicenseEnumW
#else
#define LlsProductLicenseEnum LlsProductLicenseEnumA
#endif


// For given product enum all servers with concurrent limits
NTSTATUS
NTAPI
LlsProductServerEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsProductServerEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Product,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );


#ifdef UNICODE
#define LlsProductServerEnum LlsProductServerEnumW
#else
#define LlsProductServerEnum LlsProductServerEnumA
#endif

//
//  User control API's
//  A user can be a mapped user or a normal user
//

// Enums all users
NTSTATUS
NTAPI
LlsUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsUserEnum LlsUserEnumW
#else
#define LlsUserEnum LlsUserEnumA
#endif

// Info is Group and whether to force back-office license
NTSTATUS
NTAPI
LlsUserInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  LPWSTR     User,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsUserInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  LPSTR      User,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsUserInfoGet LlsUserInfoGetW
#else
#define LlsUserInfoGet LlsUserInfoGetA
#endif

NTSTATUS
NTAPI
LlsUserInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User,
   IN DWORD      Level,
   IN LPBYTE     bufptr     // Level 1 supported
   );

NTSTATUS
NTAPI
LlsUserInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      User,
   IN DWORD      Level,
   IN LPBYTE     bufptr     // Level 1 supported
   );
#ifdef UNICODE
#define LlsUserInfoSet LlsUserInfoSetW
#else
#define LlsUserInfoSet LlsUserInfoSetA
#endif

NTSTATUS
NTAPI
LlsUserDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsUserDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR     User
   );
#ifdef UNICODE
#define LlsUserDelete LlsUserDeleteW
#else
#define LlsUserDelete LlsUserDeleteA
#endif

// For a given user enums all license useages
NTSTATUS
NTAPI
LlsUserProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     User,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsUserProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      User,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsUserProductEnum LlsUserProductEnumW
#else
#define LlsUserProductEnum LlsUserProductEnumA
#endif

// For a given user deletes a license useage
NTSTATUS
NTAPI
LlsUserProductDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     User,
   IN LPWSTR     Product
   );

NTSTATUS
NTAPI
LlsUserProductDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      User,
   IN LPSTR      Product
   );
#ifdef UNICODE
#define LlsUserProductDelete LlsUserProductDeleteW
#else
#define LlsUserProductDelete LlsUserProductDeleteA
#endif

//
// Group control API's
//

// Enums all user Groups
NTSTATUS
NTAPI
LlsGroupEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsGroupEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,
   IN     DWORD      prefmaxlen,
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsGroupEnum LlsGroupEnumW
#else
#define LlsGroupEnum LlsGroupEnumA
#endif

// For given Group gets info, info is name, comment and # licenses used
NTSTATUS
NTAPI
LlsGroupInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  LPWSTR     Group,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsGroupInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  LPSTR      Group,
   IN  DWORD      Level,    // Level 1 supported
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsGroupInfoGet LlsGroupInfoGetW
#else
#define LlsGroupInfoGet LlsGroupInfoGetA
#endif

NTSTATUS
NTAPI
LlsGroupInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN DWORD      Level,     // Level 1 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsGroupInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN DWORD      Level,     // Level 1 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsGroupInfoSet LlsGroupInfoSetW
#else
#define LlsGroupInfoSet LlsGroupInfoSetA
#endif

// For given Group enum all users
NTSTATUS
NTAPI
LlsGroupUserEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Group,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsGroupUserEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Group,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsGroupUserEnum LlsGroupUserEnumW
#else
#define LlsGroupUserEnum LlsGroupUserEnumA
#endif

// Add user to given Group
NTSTATUS
NTAPI
LlsGroupUserAddW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsGroupUserAddA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN LPSTR      User
   );
#ifdef UNICODE
#define LlsGroupUserAdd LlsGroupUserAddW
#else
#define LlsGroupUserAdd LlsGroupUserAddA
#endif

// Delete user from given Group
NTSTATUS
NTAPI
LlsGroupUserDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group,
   IN LPWSTR     User
   );

NTSTATUS
NTAPI
LlsGroupUserDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group,
   IN LPSTR      User
   );
#ifdef UNICODE
#define LlsGroupUserDelete LlsGroupUserDeleteW
#else
#define LlsGroupUserDelete LlsGroupUserDeleteA
#endif

// Add a given Group
NTSTATUS
NTAPI
LlsGroupAddW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,    // Level 1 supported
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsGroupAddA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,    // Level 1 supported
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsGroupAdd LlsGroupAddW
#else
#define LlsGroupAdd LlsGroupAddA
#endif

NTSTATUS
NTAPI
LlsGroupDeleteW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Group
   );

NTSTATUS
NTAPI
LlsGroupDeleteA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Group
   );
#ifdef UNICODE
#define LlsGroupDelete LlsGroupDeleteW
#else
#define LlsGroupDelete LlsGroupDeleteA
#endif


//
// Service control API's
//

NTSTATUS
NTAPI
LlsServiceInfoGetW(
   IN  LLS_HANDLE Handle,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   );

NTSTATUS
NTAPI
LlsServiceInfoGetA(
   IN  LLS_HANDLE Handle,
   IN  DWORD      Level,
   OUT LPBYTE*    bufptr
   );
#ifdef UNICODE
#define LlsServiceInfoGet LlsServiceInfoGetW
#else
#define LlsServiceInfoGet LlsServiceInfoGetA
#endif

NTSTATUS
NTAPI
LlsServiceInfoSetW(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsServiceInfoSetA(
   IN LLS_HANDLE Handle,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsServiceInfoSet LlsServiceInfoSetW
#else
#define LlsServiceInfoSet LlsServiceInfoSetA
#endif


//
// Server Table Stuff (Replicated Server / Product Tree)
//
NTSTATUS
NTAPI
LlsServerEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsServerEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

#ifdef UNICODE
#define LlsServerEnum LlsServerEnumW
#else
#define LlsServerEnum LlsServerEnumA
#endif


#ifdef OBSOLETE

NTSTATUS
NTAPI
LlsServerProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     LPWSTR     Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsServerProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     LPSTR      Server,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

#endif // OBSOLETE

#ifdef UNICODE
#define LlsServerUserEnum LlsServerUserEnumW
#else
#define LlsServerUserEnum LlsServerUserEnumA
#endif


#ifdef OBSOLETE

//
// Concurrent (Per-Server) mode API's (these will interact with the registry
// on the remote system).
//
NTSTATUS
NTAPI
LlsLocalProductEnumW(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );

NTSTATUS
NTAPI
LlsLocalProductEnumA(
   IN     LLS_HANDLE Handle,
   IN     DWORD      Level,     // Levels 0,1 supported
   OUT    LPBYTE*    bufptr,      
   IN     DWORD      prefmaxlen,  
   OUT    LPDWORD    EntriesRead,
   OUT    LPDWORD    TotalEntries,
   IN OUT LPDWORD    ResumeHandle
   );
#ifdef UNICODE
#define LlsLocalProductEnum LlsLocalProductEnumW
#else
#define LlsLocalProductEnum LlsLocalProductEnumA
#endif

NTSTATUS
NTAPI
LlsLocalProductInfoGetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Product,
   IN DWORD      Level,
   OUT LPBYTE*   bufptr
   );

NTSTATUS
NTAPI
LlsLocalProductInfoGetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Product,
   IN DWORD      Level,
   OUT LPBYTE*   bufptr
   );
#ifdef UNICODE
#define LlsLocalProductInfoGet LlsLocalProductInfoGetW
#else
#define LlsLocalProductInfoGet LlsLocalProductInfoGetA
#endif

NTSTATUS
NTAPI
LlsLocalProductInfoSetW(
   IN LLS_HANDLE Handle,
   IN LPWSTR     Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );

NTSTATUS
NTAPI
LlsLocalProductInfoSetA(
   IN LLS_HANDLE Handle,
   IN LPSTR      Product,
   IN DWORD      Level,
   IN LPBYTE     bufptr
   );
#ifdef UNICODE
#define LlsLocalProductInfoSet LlsLocalProductInfoSetW
#else
#define LlsLocalProductInfoSet LlsLocalProductInfoSetA
#endif

#endif // OBSOLETE

//////////////////////////////////////////////////////////////////////////////
//  LLS EXTENDED API  //
////////////////////////

BOOL
NTAPI
LlsCapabilityIsSupported(
   LLS_HANDLE  Handle,
   DWORD       Capability );

typedef BOOL (NTAPI *PLLS_CAPABILITY_IS_SUPPORTED)( LLS_HANDLE, DWORD );

NTSTATUS
NTAPI
LlsProductSecurityGetW(
   IN LLS_HANDLE  Handle,
   IN LPWSTR      Product,
   OUT LPBOOL     pSecurity
   );

NTSTATUS
NTAPI
LlsProductSecurityGetA(
   IN LLS_HANDLE  Handle,
   IN LPSTR       Product,
   OUT LPBOOL     pSecurity
   );

typedef NTSTATUS (NTAPI *PLLS_PRODUCT_SECURITY_GET_W)( LLS_HANDLE, LPWSTR, LPBOOL );
typedef NTSTATUS (NTAPI *PLLS_PRODUCT_SECURITY_GET_A)( LLS_HANDLE, LPSTR,  LPBOOL );

#ifdef UNICODE
#  define LlsProductSecurityGet LlsProductSecurityGetW
#else
#  define LlsProductSecurityGet LlsProductSecurityGetA
#endif

NTSTATUS
NTAPI
LlsProductSecuritySetW(
   IN LLS_HANDLE  Handle,
   IN LPWSTR      Product
   );

NTSTATUS
NTAPI
LlsProductSecuritySetA(
   IN LLS_HANDLE  Handle,
   IN LPSTR       Product
   );

typedef NTSTATUS (NTAPI *PLLS_PRODUCT_SECURITY_SET_W)( LLS_HANDLE, LPWSTR );
typedef NTSTATUS (NTAPI *PLLS_PRODUCT_SECURITY_SET_A)( LLS_HANDLE, LPSTR  );

#ifdef UNICODE
#  define LlsProductSecuritySet LlsProductSecuritySetW
#else
#  define LlsProductSecuritySet LlsProductSecuritySetA
#endif

NTSTATUS
NTAPI
LlsProductLicensesGetW(
   IN LLS_HANDLE         Handle,
   IN LPWSTR             DisplayName,
   IN DWORD              Mode,
   OUT LPDWORD           pQuantity );

NTSTATUS
NTAPI
LlsProductLicensesGetA(
   IN LLS_HANDLE         Handle,
   IN LPSTR              DisplayName,
   IN DWORD              Mode,
   OUT LPDWORD           pQuantity );

typedef NTSTATUS (NTAPI *PLLS_PRODUCT_LICENSES_GET_W)( LLS_HANDLE, LPWSTR, DWORD, LPDWORD );
typedef NTSTATUS (NTAPI *PLLS_PRODUCT_LICENSES_GET_A)( LLS_HANDLE, LPSTR,  DWORD, LPDWORD );

#ifdef UNICODE
#  define LlsProductLicensesGet LlsProductLicensesGetW
#else
#  define LlsProductLicensesGet LlsProductLicensesGetA
#endif

#ifdef OBSOLETE

NTSTATUS
NTAPI
LlsCertificateClaimEnumW(
   IN LLS_HANDLE        Handle,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo,
   IN DWORD             TargetLevel,
   OUT LPBYTE *         ppTargets,
   OUT LPDWORD          pNumTargets );

NTSTATUS
NTAPI
LlsCertificateClaimEnumA(
   IN LLS_HANDLE        Handle,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo,
   IN DWORD             TargetLevel,
   OUT LPBYTE *         ppTargets,
   OUT LPDWORD          pNumTargets );

typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ENUM_W)( LLS_HANDLE, DWORD, LPBYTE, DWORD, LPBYTE *, LPDWORD );
typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ENUM_A)( LLS_HANDLE, DWORD, LPBYTE, DWORD, LPBYTE *, LPDWORD );

#ifdef UNICODE
#  define LlsCertificateClaimEnum LlsCertificateClaimEnumW
#else
#  define LlsCertificateClaimEnum LlsCertificateClaimEnumA
#endif

#endif // OBSOLETE

NTSTATUS
NTAPI
LlsCertificateClaimAddCheckW(
   IN LLS_HANDLE        Handle,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo,
   OUT LPBOOL           pMayInstall );

NTSTATUS
NTAPI
LlsCertificateClaimAddCheckA(
   IN LLS_HANDLE        Handle,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo,
   OUT LPBOOL           pMayInstall );

typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ADD_CHECK_W)( LLS_HANDLE, DWORD, LPBYTE, LPBOOL );
typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ADD_CHECK_A)( LLS_HANDLE, DWORD, LPBYTE, LPBOOL );

#ifdef UNICODE
#  define LlsCertificateClaimAddCheck LlsCertificateClaimAddCheckW
#else
#  define LlsCertificateClaimAddCheck LlsCertificateClaimAddCheckA
#endif

NTSTATUS
NTAPI
LlsCertificateClaimAddW(
   IN LLS_HANDLE        Handle,
   IN LPWSTR            ServerName,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo );

NTSTATUS
NTAPI
LlsCertificateClaimAddA(
   IN LLS_HANDLE        Handle,
   IN LPSTR             ServerName,
   IN DWORD             LicenseLevel,
   IN LPBYTE            pLicenseInfo );

typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ADD_W)( LLS_HANDLE, LPWSTR, DWORD, LPBYTE );
typedef NTSTATUS (NTAPI *PLLS_CERTIFICATE_CLAIM_ADD_A)( LLS_HANDLE, LPSTR,  DWORD, LPBYTE );

#ifdef UNICODE
#  define LlsCertificateClaimAdd LlsCertificateClaimAddW
#else
#  define LlsCertificateClaimAdd LlsCertificateClaimAddA
#endif

typedef NTSTATUS (NTAPI *PLLS_REPL_CONNECT_W)( LPWSTR, LLS_REPL_HANDLE * );
typedef NTSTATUS (NTAPI *PLLS_REPL_CONNECT_A)( LPSTR, LLS_REPL_HANDLE * );

typedef NTSTATUS (NTAPI *PLLS_REPL_CLOSE)( PLLS_REPL_HANDLE );

typedef NTSTATUS (NTAPI *PLLS_FREE_MEMORY)( PVOID );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_REQUEST_W)( LLS_REPL_HANDLE, DWORD, LPVOID );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_SERVER_ADD_W)( LLS_REPL_HANDLE, ULONG, LPVOID );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_SERVER_SERVICE_ADD_W)( LLS_REPL_HANDLE, ULONG, LPVOID );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_SERVICE_ADD_W)( LLS_REPL_HANDLE, ULONG, LPVOID );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_USER_ADD_W)( LLS_REPL_HANDLE, ULONG, LPVOID );

NTSTATUS
NTAPI
LlsReplicationCertDbAddW(
   LLS_REPL_HANDLE            ReplHandle,
   DWORD                      Level,
   LPVOID                     Certificates );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_CERT_DB_ADD_W)( LLS_REPL_HANDLE, DWORD, LPVOID );


NTSTATUS
NTAPI
LlsReplicationProductSecurityAddW(
   LLS_REPL_HANDLE            ReplHandle,
   DWORD                      Level,
   LPVOID                     SecureProducts );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_PRODUCT_SECURITY_ADD_W)( LLS_REPL_HANDLE, DWORD, LPVOID );


NTSTATUS
NTAPI
LlsReplicationUserAddExW(
   LLS_REPL_HANDLE            ReplHandle,
   DWORD                      Level,
   LPVOID                     Users );

typedef NTSTATUS (NTAPI *PLLS_REPLICATION_USER_ADD_EX_W)( LLS_REPL_HANDLE, DWORD, LPVOID );


NTSTATUS
NTAPI
LlsLocalServiceEnumW(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle );

NTSTATUS
NTAPI
LlsLocalServiceEnumA(
   LLS_HANDLE Handle,
   DWORD      Level,
   LPBYTE*    bufptr,
   DWORD      PrefMaxLen,
   LPDWORD    EntriesRead,
   LPDWORD    TotalEntries,
   LPDWORD    ResumeHandle );

#ifdef UNICODE
#  define LlsLocalServiceEnum LlsLocalServiceEnumW
#else
#  define LlsLocalServiceEnum LlsLocalServiceEnumA
#endif

#ifdef OBSOLETE

NTSTATUS
NTAPI
LlsLocalServiceAddW(
   LLS_HANDLE  Handle,
   DWORD       Level,
   LPBYTE      bufptr );

NTSTATUS
NTAPI
LlsLocalServiceAddA(
   LLS_HANDLE  Handle,
   DWORD       Level,
   LPBYTE      bufptr );

#ifdef UNICODE
#  define LlsLocalServiceAdd LlsLocalServiceAddW
#else
#  define LlsLocalServiceAdd LlsLocalServiceAddA
#endif

#endif // OBSOLETE

NTSTATUS
NTAPI
LlsLocalServiceInfoSetW(
   LLS_HANDLE Handle,
   LPWSTR     KeyName,
   DWORD      Level,
   LPBYTE     bufptr );

NTSTATUS
NTAPI
LlsLocalServiceInfoSetA(
   LLS_HANDLE  Handle,
   LPSTR       KeyName,
   DWORD       Level,
   LPBYTE      bufptr );

#ifdef UNICODE
#  define LlsLocalServiceInfoSet LlsLocalServiceInfoSetW
#else
#  define LlsLocalServiceInfoSet LlsLocalServiceInfoSetA
#endif

NTSTATUS
NTAPI
LlsLocalServiceInfoGetW(
   LLS_HANDLE  Handle,
   LPWSTR      KeyName,
   DWORD       Level,
   LPBYTE *    pbufptr );

NTSTATUS
NTAPI
LlsLocalServiceInfoGetA(
   LLS_HANDLE  Handle,
   DWORD       Level,
   LPSTR       KeyName,
   LPBYTE *    pbufptr );

#ifdef UNICODE
#  define LlsLocalServiceInfoGet LlsLocalServiceInfoGetW
#else
#  define LlsLocalServiceInfoGet LlsLocalServiceInfoGetA
#endif

NTSTATUS
NTAPI
LlsLicenseRequestW(
   LLS_HANDLE  Handle,
   LPWSTR      Product,
   ULONG       VersionIndex,
   BOOLEAN     IsAdmin,
   ULONG       DataType,
   ULONG       DataSize,
   PBYTE       Data,
   LPDWORD     pLicenseHandle );

NTSTATUS
NTAPI
LlsLicenseRequestA(
   LLS_HANDLE  Handle,
   LPSTR       Product,
   ULONG       VersionIndex,
   BOOLEAN     IsAdmin,
   ULONG       DataType,
   ULONG       DataSize,
   PBYTE       Data,
   LPDWORD     pLicenseHandle );

#ifdef UNICODE
#  define LlsLicenseRequest LlsLicenseRequestW
#else
#  define LlsLicenseRequest LlsLicenseRequestA
#endif

NTSTATUS
NTAPI
LlsLicenseFree(
   LLS_HANDLE  Handle,
   DWORD       LicenseHandle );

NTSTATUS
NTAPI
LlsLicenseRequest2W(
   LLS_HANDLE  Handle,
   LPWSTR      Product,
   ULONG       VersionIndex,
   BOOLEAN     IsAdmin,
   ULONG       DataType,
   ULONG       DataSize,
   PBYTE       Data,
   PHANDLE     pLicenseHandle );

NTSTATUS
NTAPI
LlsLicenseRequest2A(
   LLS_HANDLE  Handle,
   LPSTR       Product,
   ULONG       VersionIndex,
   BOOLEAN     IsAdmin,
   ULONG       DataType,
   ULONG       DataSize,
   PBYTE       Data,
   PHANDLE     pLicenseHandle );

#ifdef UNICODE
#  define LlsLicenseRequest2 LlsLicenseRequest2W
#else
#  define LlsLicenseRequest2 LlsLicenseRequest2A
#endif

NTSTATUS
NTAPI
LlsLicenseFree2(
   LLS_HANDLE  Handle,
   HANDLE      LicenseHandle );

//////////////////////////////////////////////////////////////////////////////
//  CCF API  //
///////////////

#define CCF_ENTER_FLAG_PER_SEAT_ONLY         ( 1 )
#define CCF_ENTER_FLAG_PER_SERVER_ONLY       ( 2 )
#define CCF_ENTER_FLAG_SERVER_IS_ES          ( 4 )

// prototype for certificate source enter API
typedef DWORD (APIENTRY *PCCF_ENTER_API)(    HWND     hWndParent,
                                             LPCSTR   pszServerName,
                                             LPCSTR   pszProductName,
                                             LPCSTR   pszVendor,
                                             DWORD    dwFlags );

DWORD APIENTRY CCFCertificateEnterUI(        HWND     hWndParent,
                                             LPCSTR   pszServerName,
                                             LPCSTR   pszProductName,
                                             LPCSTR   pszVendor,
                                             DWORD    dwFlags,
                                             LPCSTR   pszSourceToUse );

// prototype for certificate source remove API
typedef DWORD (APIENTRY *PCCF_REMOVE_API)(   HWND     hWndParent,
                                             LPCSTR   pszServerName,
                                             DWORD    dwFlags,
                                             DWORD    dwLicenseLevel,
                                             LPVOID   lpvLicenseInfo );

DWORD APIENTRY CCFCertificateRemoveUI(       HWND     hWndParent,
                                             LPCSTR   pszServerName,
                                             LPCSTR   pszProductName,
                                             LPCSTR   pszVendor,
                                             DWORD    dwFlags,
                                             LPCSTR   pszSourceToUse );

#endif

//
// Registry values
//

#define REG_KEY_LICENSE  TEXT("SYSTEM\\CurrentControlSet\\Services\\LicenseInfo")
#define REG_KEY_CONFIG   TEXT("SYSTEM\\CurrentControlSet\\Services\\LicenseService\\Parameters")

#define REG_VALUE_NAME     TEXT("DisplayName")
#define REG_VALUE_FAMILY   TEXT("FamilyDisplayName")
#define REG_VALUE_MODE     TEXT("Mode")
#define REG_VALUE_FLIP     TEXT("FlipAllow")
#define REG_VALUE_LIMIT    TEXT("ConcurrentLimit")
#define REG_VALUE_HIGHMARK TEXT("LocalKey")

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\loghours.h ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    loghours.h

Abstract:

    Private routines to support rotation of logon hours between local time
    and GMT time.

Author:

    Cliff Van Dyke (cliffv) 16-Mar-93

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/



//
// Procedure forwards from loghours.c
//

BOOLEAN
NetpRotateLogonHoursPhase1(
    IN BOOL  ConvertToGmt,
    OUT PULONG RotateCount
    );

BOOLEAN
NetpRotateLogonHoursPhase2(
    IN PBYTE LogonHours,
    IN DWORD UnitsPerWeek,
    IN LONG  RotateCount
    );

BOOLEAN
NetpRotateLogonHours(
    IN PBYTE LogonHours,
    IN DWORD UnitsPerWeek,
    IN BOOL  ConvertToGmt
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\logonmsv.h ===
/*++

Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    logonmsv.h

Abstract:

    Definition of API's to the Netlogon service which are callable
    by the MSV1_0 authentication package.

Author:

    Cliff Van Dyke (cliffv) 23-Jun-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#ifndef __LOGONMSV_H__
#define __LOGONMSV_H__
#include <lsass.h>  // OLD_LARGE_INTEGER

//
// Name of secret in LSA secret storage where account passwords are kept.
//

#define SSI_SECRET_PREFIX L"$"
#define SSI_SECRET_PREFIX_LENGTH 1
#define SSI_SECRET_POSTFIX L"MACHINE.ACC"
#define SSI_SECRET_NAME L"$MACHINE.ACC"

//
// Name of the event used to synchronize between the security process and
// the service controller.
//

#define SECURITY_SERVICES_STARTED L"SECURITY_SERVICES_STARTED"


//
// The structures supporting remote logon APIs
//

typedef CYPHER_BLOCK NETLOGON_CREDENTIAL, *PNETLOGON_CREDENTIAL ;

typedef struct _NETLOGON_AUTHENTICATOR {
    NETLOGON_CREDENTIAL Credential;
    DWORD timestamp;
} NETLOGON_AUTHENTICATOR, *PNETLOGON_AUTHENTICATOR ;

typedef struct _NETLOGON_SESSION_KEY {
    BYTE Key[CRYPT_TXT_LEN * 2];
} NETLOGON_SESSION_KEY, *PNETLOGON_SESSION_KEY;

typedef enum _NETLOGON_SECURE_CHANNEL_TYPE {
    NullSecureChannel = 0,
    MsvApSecureChannel,
    WorkstationSecureChannel,
    TrustedDnsDomainSecureChannel,
    TrustedDomainSecureChannel,
    UasServerSecureChannel,
    ServerSecureChannel
} NETLOGON_SECURE_CHANNEL_TYPE;

#define IsDomainSecureChannelType( _T ) \
        ( (_T) == TrustedDnsDomainSecureChannel || \
          (_T) == TrustedDomainSecureChannel )


//
// Input information to NetLogonSamLogon.
//
// begin_ntsubauth

typedef enum _NETLOGON_LOGON_INFO_CLASS {
    NetlogonInteractiveInformation = 1,
    NetlogonNetworkInformation,
    NetlogonServiceInformation,
    NetlogonGenericInformation,
    NetlogonInteractiveTransitiveInformation,
    NetlogonNetworkTransitiveInformation,
    NetlogonServiceTransitiveInformation
} NETLOGON_LOGON_INFO_CLASS;

typedef struct _NETLOGON_LOGON_IDENTITY_INFO {
    UNICODE_STRING LogonDomainName;
    ULONG ParameterControl;
    OLD_LARGE_INTEGER  LogonId;
    UNICODE_STRING UserName;
    UNICODE_STRING Workstation;
} NETLOGON_LOGON_IDENTITY_INFO,
 *PNETLOGON_LOGON_IDENTITY_INFO;

typedef struct _NETLOGON_INTERACTIVE_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    LM_OWF_PASSWORD LmOwfPassword;
    NT_OWF_PASSWORD NtOwfPassword;
} NETLOGON_INTERACTIVE_INFO,
 *PNETLOGON_INTERACTIVE_INFO;

typedef struct _NETLOGON_SERVICE_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    LM_OWF_PASSWORD LmOwfPassword;
    NT_OWF_PASSWORD NtOwfPassword;
} NETLOGON_SERVICE_INFO, *PNETLOGON_SERVICE_INFO;

typedef struct _NETLOGON_NETWORK_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    LM_CHALLENGE LmChallenge;
    STRING NtChallengeResponse;
    STRING LmChallengeResponse;
} NETLOGON_NETWORK_INFO, *PNETLOGON_NETWORK_INFO;

typedef struct _NETLOGON_GENERIC_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    UNICODE_STRING PackageName;
    ULONG DataLength;
#ifdef MIDL_PASS
    [size_is(DataLength)]
#endif
    PUCHAR LogonData;
} NETLOGON_GENERIC_INFO, *PNETLOGON_GENERIC_INFO;

// end_ntsubauth

//
// Structure to pass a SID_AND_ATTRIBUTES over the network.
//

typedef struct _NETLOGON_SID_AND_ATTRIBUTES {
#if defined(MIDL_PASS) || defined(RPC_SERVER)
    PISID Sid;
#else
    PSID Sid;
#endif
    ULONG Attributes;
} NETLOGON_SID_AND_ATTRIBUTES, *PNETLOGON_SID_AND_ATTRIBUTES;

//
// Values of ParameterControl
//
// (Obsolete: Use the ParameterControl values from ntmsv1_0.h)

#define CLEARTEXT_PASSWORD_ALLOWED 0x02     // Challenge response fields may
                                            // actually be clear text passwords.


//
// Output information to NetLogonSamLogon.
//

typedef enum _NETLOGON_VALIDATION_INFO_CLASS {
     NetlogonValidationUasInfo = 1,
     NetlogonValidationSamInfo,
     NetlogonValidationSamInfo2,
     NetlogonValidationGenericInfo,
     NetlogonValidationGenericInfo2,
     NetlogonValidationSamInfo4
} NETLOGON_VALIDATION_INFO_CLASS;

typedef struct _NETLOGON_VALIDATION_SAM_INFO {
    //
    // Information retrieved from SAM.
    //
    OLD_LARGE_INTEGER LogonTime;            // 0 for Network logon
    OLD_LARGE_INTEGER LogoffTime;
    OLD_LARGE_INTEGER KickOffTime;
    OLD_LARGE_INTEGER PasswordLastSet;      // 0 for Network logon
    OLD_LARGE_INTEGER PasswordCanChange;    // 0 for Network logon
    OLD_LARGE_INTEGER PasswordMustChange;   // 0 for Network logon
    UNICODE_STRING EffectiveName;       // 0 for Network logon
    UNICODE_STRING FullName;            // 0 for Network logon
    UNICODE_STRING LogonScript;         // 0 for Network logon
    UNICODE_STRING ProfilePath;         // 0 for Network logon
    UNICODE_STRING HomeDirectory;       // 0 for Network logon
    UNICODE_STRING HomeDirectoryDrive;  // 0 for Network logon
    USHORT LogonCount;                  // 0 for Network logon
    USHORT BadPasswordCount;            // 0 for Network logon
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG GroupCount;
#ifdef MIDL_PASS
    [size_is(GroupCount)]
#endif // MIDL_PASS
    PGROUP_MEMBERSHIP GroupIds;

    //
    // Information supplied by the MSV AP/Netlogon service.
    //
    ULONG UserFlags;
    USER_SESSION_KEY UserSessionKey;
    UNICODE_STRING LogonServer;
    UNICODE_STRING LogonDomainName;
#if defined(MIDL_PASS) || defined(RPC_SERVER)
    PISID LogonDomainId;
#else
    PSID LogonDomainId;
#endif

    ULONG    ExpansionRoom[10];        // Put new fields here
} NETLOGON_VALIDATION_SAM_INFO, *PNETLOGON_VALIDATION_SAM_INFO ;

//
// New output information for NetLogonSamLogon. This structure is identical
// to the above structure with some new fields added at the end.
//

typedef struct _NETLOGON_VALIDATION_SAM_INFO2 {
    //
    // Information retrieved from SAM.
    //
    OLD_LARGE_INTEGER LogonTime;            // 0 for Network logon
    OLD_LARGE_INTEGER LogoffTime;
    OLD_LARGE_INTEGER KickOffTime;
    OLD_LARGE_INTEGER PasswordLastSet;      // 0 for Network logon
    OLD_LARGE_INTEGER PasswordCanChange;    // 0 for Network logon
    OLD_LARGE_INTEGER PasswordMustChange;   // 0 for Network logon
    UNICODE_STRING EffectiveName;       // 0 for Network logon
    UNICODE_STRING FullName;            // 0 for Network logon
    UNICODE_STRING LogonScript;         // 0 for Network logon
    UNICODE_STRING ProfilePath;         // 0 for Network logon
    UNICODE_STRING HomeDirectory;       // 0 for Network logon
    UNICODE_STRING HomeDirectoryDrive;  // 0 for Network logon
    USHORT LogonCount;                  // 0 for Network logon
    USHORT BadPasswordCount;            // 0 for Network logon
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG GroupCount;
#ifdef MIDL_PASS
    [size_is(GroupCount)]
#endif // MIDL_PASS
    PGROUP_MEMBERSHIP GroupIds;

    //
    // Information supplied by the MSV AP/Netlogon service.
    //
    ULONG UserFlags;
    USER_SESSION_KEY UserSessionKey;
    UNICODE_STRING LogonServer;
    UNICODE_STRING LogonDomainName;
#if defined(MIDL_PASS) || defined(RPC_SERVER)
    PISID LogonDomainId;
#else
    PSID LogonDomainId;
#endif

    ULONG    ExpansionRoom[10];        // Put new fields here

    //
    // The new fields in this structure are a count and a pointer to
    // an array of SIDs and attributes.
    //

    ULONG SidCount;

#ifdef MIDL_PASS
    [size_is(SidCount)]
#endif // MIDL_PASS
    PNETLOGON_SID_AND_ATTRIBUTES ExtraSids;

} NETLOGON_VALIDATION_SAM_INFO2, *PNETLOGON_VALIDATION_SAM_INFO2 ;


//
// Info level 3 is a version used internally by kerberos.  It never appears on the wire.
//
typedef struct _NETLOGON_VALIDATION_SAM_INFO3 {
    //
    // Information retrieved from SAM.
    //
    OLD_LARGE_INTEGER LogonTime;            // 0 for Network logon
    OLD_LARGE_INTEGER LogoffTime;
    OLD_LARGE_INTEGER KickOffTime;
    OLD_LARGE_INTEGER PasswordLastSet;      // 0 for Network logon
    OLD_LARGE_INTEGER PasswordCanChange;    // 0 for Network logon
    OLD_LARGE_INTEGER PasswordMustChange;   // 0 for Network logon
    UNICODE_STRING EffectiveName;       // 0 for Network logon
    UNICODE_STRING FullName;            // 0 for Network logon
    UNICODE_STRING LogonScript;         // 0 for Network logon
    UNICODE_STRING ProfilePath;         // 0 for Network logon
    UNICODE_STRING HomeDirectory;       // 0 for Network logon
    UNICODE_STRING HomeDirectoryDrive;  // 0 for Network logon
    USHORT LogonCount;                  // 0 for Network logon
    USHORT BadPasswordCount;            // 0 for Network logon
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG GroupCount;
#ifdef MIDL_PASS
    [size_is(GroupCount)]
#endif // MIDL_PASS
    PGROUP_MEMBERSHIP GroupIds;

    //
    // Information supplied by the MSV AP/Netlogon service.
    //
    ULONG UserFlags;
    USER_SESSION_KEY UserSessionKey;
    UNICODE_STRING LogonServer;
    UNICODE_STRING LogonDomainName;
#if defined(MIDL_PASS) || defined(RPC_SERVER)
    PISID LogonDomainId;
#else
    PSID LogonDomainId;
#endif

    ULONG    ExpansionRoom[10];        // Put new fields here

    //
    // The new fields in this structure are a count and a pointer to
    // an array of SIDs and attributes.
    //

    ULONG SidCount;

#ifdef MIDL_PASS
    [size_is(SidCount)]
#endif // MIDL_PASS

    PNETLOGON_SID_AND_ATTRIBUTES ExtraSids;

    //
    // Resource groups. These are present if LOGON_RESOURCE_GROUPS bit is
    // set in the user flags
    //

#if defined(MIDL_PASS) || defined(RPC_SERVER)
    PISID ResourceGroupDomainSid;
#else
    PSID ResourceGroupDomainSid;
#endif
    ULONG ResourceGroupCount;
#ifdef MIDL_PASS
    [size_is(ResourceGroupCount)]
#endif // MIDL_PASS
    PGROUP_MEMBERSHIP ResourceGroupIds;

} NETLOGON_VALIDATION_SAM_INFO3, *PNETLOGON_VALIDATION_SAM_INFO3 ;

//
// New output information for NetLogonSamLogon. This structure is identical
// to the NETLOGON_VALIDATION_SAM_INFO2 with some new fields added at the end.
//
// This version was introduced in Whistler.
//

typedef struct _NETLOGON_VALIDATION_SAM_INFO4 {
    //
    // Information retrieved from SAM.
    //
    OLD_LARGE_INTEGER LogonTime;            // 0 for Network logon
    OLD_LARGE_INTEGER LogoffTime;
    OLD_LARGE_INTEGER KickOffTime;
    OLD_LARGE_INTEGER PasswordLastSet;      // 0 for Network logon
    OLD_LARGE_INTEGER PasswordCanChange;    // 0 for Network logon
    OLD_LARGE_INTEGER PasswordMustChange;   // 0 for Network logon
    UNICODE_STRING EffectiveName;       // 0 for Network logon
    UNICODE_STRING FullName;            // 0 for Network logon
    UNICODE_STRING LogonScript;         // 0 for Network logon
    UNICODE_STRING ProfilePath;         // 0 for Network logon
    UNICODE_STRING HomeDirectory;       // 0 for Network logon
    UNICODE_STRING HomeDirectoryDrive;  // 0 for Network logon
    USHORT LogonCount;                  // 0 for Network logon
    USHORT BadPasswordCount;            // 0 for Network logon
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG GroupCount;
#ifdef MIDL_PASS
    [size_is(GroupCount)]
#endif // MIDL_PASS
    PGROUP_MEMBERSHIP GroupIds;

    //
    // Information supplied by the MSV AP/Netlogon service.
    //
    ULONG UserFlags;
    USER_SESSION_KEY UserSessionKey;
    UNICODE_STRING LogonServer;
    UNICODE_STRING LogonDomainName;
#if defined(MIDL_PASS) || defined(RPC_SERVER)
    PISID LogonDomainId;
#else
    PSID LogonDomainId;
#endif
    //
    // The First two longwords (8 bytes) of ExpansionRoom are reserved for the
    // LanManSession Key.
    //
#define SAMINFO_LM_SESSION_KEY 0
#define SAMINFO_LM_SESSION_KEY_EXT 1
#define SAMINFO_LM_SESSION_KEY_SIZE (2*sizeof(ULONG))

    //
    // The third longword (4 bytes) of ExpansionRoom is the user account
    // control flag from the account.
    //

#define SAMINFO_USER_ACCOUNT_CONTROL 2
#define SAMINFO_USER_ACCOUNT_CONTROL_SIZE sizeof(ULONG)

    //
    // The fourth longword (4 bytes) of ExpansionRoom is for the status
    // returned for subauth users, not from subauth packages (NT5 onwards)
    //

#define SAMINFO_SUBAUTH_STATUS 3
#define SAMINFO_SUBAUTH_STATUS_SIZE sizeof(ULONG)

    ULONG    ExpansionRoom[10];        // Put new fields here

    //
    // The new fields in this structure are a count and a pointer to
    // an array of SIDs and attributes.
    //

    ULONG SidCount;

#ifdef MIDL_PASS
    [size_is(SidCount)]
#endif // MIDL_PASS
    PNETLOGON_SID_AND_ATTRIBUTES ExtraSids;

    //
    // New fields added for version 4 of the structure
    //

    UNICODE_STRING DnsLogonDomainName;  // Dns version of LogonDomainName

    UNICODE_STRING Upn;                 // UPN of the user account

    UNICODE_STRING ExpansionString1;    // Put new strings here
    UNICODE_STRING ExpansionString2;    // Put new strings here
    UNICODE_STRING ExpansionString3;    // Put new strings here
    UNICODE_STRING ExpansionString4;    // Put new strings here
    UNICODE_STRING ExpansionString5;    // Put new strings here
    UNICODE_STRING ExpansionString6;    // Put new strings here
    UNICODE_STRING ExpansionString7;    // Put new strings here
    UNICODE_STRING ExpansionString8;    // Put new strings here
    UNICODE_STRING ExpansionString9;    // Put new strings here
    UNICODE_STRING ExpansionString10;   // Put new strings here

} NETLOGON_VALIDATION_SAM_INFO4, *PNETLOGON_VALIDATION_SAM_INFO4 ;

// This structure is bogus since it doesn't have a size_is
// Everyone should use the generic info2 structure
typedef struct _NETLOGON_VALIDATION_GENERIC_INFO {
    ULONG DataLength;
    PUCHAR ValidationData;
} NETLOGON_VALIDATION_GENERIC_INFO, *PNETLOGON_VALIDATION_GENERIC_INFO;

typedef struct _NETLOGON_VALIDATION_GENERIC_INFO2 {
    ULONG DataLength;
#ifdef MIDL_PASS
    [size_is(DataLength)]
#endif // MIDL_PASS
    PUCHAR ValidationData;
} NETLOGON_VALIDATION_GENERIC_INFO2, *PNETLOGON_VALIDATION_GENERIC_INFO2;



//
// Status codes that indicate the password is bad and the call should
// be passed through to the PDC of the domain.
//

#define BAD_PASSWORD( _x ) \
    ((_x) == STATUS_WRONG_PASSWORD || \
     (_x) == STATUS_PASSWORD_EXPIRED || \
     (_x) == STATUS_PASSWORD_MUST_CHANGE || \
     (_x) == STATUS_ACCOUNT_LOCKED_OUT )

//
// The actual logon and logoff routines.
//

// The following 2 procedure definitions must match
NTSTATUS
I_NetLogonSamLogon(
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT LPBYTE * ValidationInformation,
    OUT PBOOLEAN Authoritative
    );

typedef NTSTATUS
(*PNETLOGON_SAM_LOGON_PROCEDURE)(
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT LPBYTE * ValidationInformation,
    OUT PBOOLEAN Authoritative
    );

//
// Values of ExtraFlags
//
// For OS earlier that WIN 2K.  This field didn't exist.
//
// A WIN 2K client always passes zero and ignores the return.
// A WIN 2K server always returns what it is passed.
//
// A whistler client can pass the NETLOGON_SUPPORTS_CROSS_FOREST bits and ignores the return.
// A whistler server always returns what it is passed.
//
// In all cases, the flags correspond to the hop at hand.  Each hop computes which flags it
//      want to pass to the next hop.  It will only set bits that it understands.
//

// Flags introduced with NETLOGON_SUPPORTS_CROSS_FOREST
#define NL_EXFLAGS_EXPEDITE_TO_ROOT 0x0001      // Pass this request to DC at root of forest
#define NL_EXFLAGS_CROSS_FOREST_HOP 0x0002      // Request is first hop over cross forest trust TDO

NTSTATUS
I_NetLogonSamLogonEx (
    IN PVOID ContextHandle,
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT LPBYTE * ValidationInformation,
    OUT PBOOLEAN Authoritative,
    IN OUT PULONG ExtraFlags,
    OUT PBOOLEAN RpcFailed
    );

NTSTATUS
I_NetLogonSamLogonWithFlags (
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT LPBYTE * ValidationInformation,
    OUT PBOOLEAN Authoritative,
    IN OUT PULONG ExtraFlags
    );


// The following 2 procedure definitions must match
NTSTATUS
I_NetLogonSamLogoff (
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation
);

typedef NTSTATUS
(*PNETLOGON_SAM_LOGOFF_PROCEDURE) (
    IN LPWSTR LogonServer OPTIONAL,
    IN LPWSTR ComputerName OPTIONAL,
    IN PNETLOGON_AUTHENTICATOR Authenticator OPTIONAL,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator OPTIONAL,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation
);

//
// Actual logon/logoff routines for Cairo
//

NET_API_STATUS
NetlogonInitialize(
    PVOID Context
    );

NTSTATUS
NetlogonSamLogon (
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN LPBYTE LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT LPBYTE *ValidationInformation,
    OUT PBOOLEAN Authoritative
    );

//
// Routine to get a list of NT DC's in the specified domain.
//
NET_API_STATUS NET_API_FUNCTION
I_NetGetDCList (
    IN  LPWSTR ServerName OPTIONAL,
    IN  LPWSTR TrustedDomainName,
    OUT PULONG DCCount,
    OUT PUNICODE_STRING * DCNames
    );

//
// Validation routine which lives in msv1_0.dll
//
NTSTATUS
MsvSamValidate (
    IN SAM_HANDLE DomainHandle,
    IN BOOLEAN UasCompatibilityRequired,
    IN NETLOGON_SECURE_CHANNEL_TYPE SecureChannelType,
    IN PUNICODE_STRING LogonServer,
    IN PUNICODE_STRING LogonDomainName,
    IN PSID LogonDomainId,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN NETLOGON_VALIDATION_INFO_CLASS ValidationLevel,
    OUT PVOID * ValidationInformation,
    OUT PBOOLEAN Authoritative,
    OUT PBOOLEAN BadPasswordCountZeroed,
    IN DWORD AccountsToTry
);

//
// Routine to get running number of logon attempts which lives in msv1_0.dll
//
ULONG
MsvGetLogonAttemptCount (
    VOID
);

// Values for AccountsToTry
#define MSVSAM_SPECIFIED 0x01        // Try specified account
#define MSVSAM_GUEST     0x02        // Try guest account

NTSTATUS
MsvSamLogoff (
    IN SAM_HANDLE DomainHandle,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation
);

// begin_ntsubauth

// Values for Flags
#define MSV1_0_PASSTHRU     0x01
#define MSV1_0_GUEST_LOGON  0x02

NTSTATUS NTAPI
Msv1_0SubAuthenticationRoutine(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
);

typedef struct _MSV1_0_VALIDATION_INFO {
    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER KickoffTime;
    UNICODE_STRING LogonServer;
    UNICODE_STRING LogonDomainName;
    USER_SESSION_KEY SessionKey;
    BOOLEAN Authoritative;
    ULONG UserFlags;
    ULONG WhichFields;
    ULONG UserId;
} MSV1_0_VALIDATION_INFO, *PMSV1_0_VALIDATION_INFO;

// values for WhichFields

#define MSV1_0_VALIDATION_LOGOFF_TIME          0x00000001
#define MSV1_0_VALIDATION_KICKOFF_TIME         0x00000002
#define MSV1_0_VALIDATION_LOGON_SERVER         0x00000004
#define MSV1_0_VALIDATION_LOGON_DOMAIN         0x00000008
#define MSV1_0_VALIDATION_SESSION_KEY          0x00000010
#define MSV1_0_VALIDATION_USER_FLAGS           0x00000020
#define MSV1_0_VALIDATION_USER_ID              0x00000040

// legal values for ActionsPerformed
#define MSV1_0_SUBAUTH_ACCOUNT_DISABLED        0x00000001
#define MSV1_0_SUBAUTH_PASSWORD                0x00000002
#define MSV1_0_SUBAUTH_WORKSTATIONS            0x00000004
#define MSV1_0_SUBAUTH_LOGON_HOURS             0x00000008
#define MSV1_0_SUBAUTH_ACCOUNT_EXPIRY          0x00000010
#define MSV1_0_SUBAUTH_PASSWORD_EXPIRY         0x00000020
#define MSV1_0_SUBAUTH_ACCOUNT_TYPE            0x00000040
#define MSV1_0_SUBAUTH_LOCKOUT                 0x00000080

NTSTATUS NTAPI
Msv1_0SubAuthenticationRoutineEx(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    IN SAM_HANDLE UserHandle,
    IN OUT PMSV1_0_VALIDATION_INFO ValidationInfo,
    OUT PULONG ActionsPerformed
);

NTSTATUS NTAPI
Msv1_0SubAuthenticationRoutineGeneric(
    IN PVOID SubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PULONG ReturnBufferLength,
    OUT PVOID *ReturnBuffer
);

NTSTATUS NTAPI
Msv1_0SubAuthenticationFilter(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
);

// end_ntsubauth

#endif // __LOGONMSV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\lsaisrv.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    lsaisrv.h

Abstract:

    This file contains interfaces to internal routines in the Lsa
    Server that provide additional functionality not contained in
    the Lsar routines.  These routines are only used by LSA clients which
    live in the same process as the LSA server.


Author:

    Scott Birrell (ScottBi) April 8, 1992

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _LSAISRV_
#define _LSAISRV_

#ifdef __cplusplus
extern "C" {
#endif

//
// The following constants are defined for callers of the LsaIHealthCheckRoutine
//
// 1. LSAI_SAM_STATE_SESS_KEY is used to convey the syskey by SAM to LSA.
//    This is used in upgrade cases from NT4 and win2k B3 and RC1.
//    SAM in these cases knows the syskey
//
// 2. LSAI_SAM_STATE_UNROLL_SP4_ENCRYPTION is used to convey SAM's password
//    encryption key to LSA. This is used to unroll encryption used in NT4 SP4
//    ( incorrectly ) using SAM's password encryption key
//
// 3. LSAI_SAM_STATE_RETRIEVE_SESS_KEY is used by SAM/DS to retrieve the
//    from LSA to decrypt their respective password encryption keys
//
// 4. LSAI_SAM_GENERATE_SESS_KEY is used by SAM to tell the LSA to generate
//     a new Password Encryption key in the case where we are upgrading
//    from a NT4 or Win2k B3 or RC1 Machine and the machine is not syskey'd
//
// 5. LSAI_SAM_STATE_CLEAR_SESS_KEY is used by SAM or DS to clear the syskey
//    after it has been used for decrypting their respective password
//    encryption keys.
//
// 6. LSAI_SAM_STATE_OLD_SESS_KEY This is used to retrieve the old syskey in
//    to implement error recovery during syskey change cases.
//


#define LSAI_SAM_STATE_SESS_KEY              0x1
#define LSAI_SAM_STATE_UNROLL_SP4_ENCRYPTION 0x2
#define LSAI_SAM_STATE_RETRIEVE_SESS_KEY     0x3
#define LSAI_SAM_STATE_CLEAR_SESS_KEY        0x4
#define LSAI_SAM_GENERATE_SESS_KEY           0x5
#define LSAI_SAM_STATE_OLD_SESS_KEY          0x6


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// The following prototypes are usable throughout the process that the       //
// LSA server resides in.                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS NTAPI
LsaIHealthCheck(
    IN LSAPR_HANDLE DomainHandle OPTIONAL,
    IN ULONG StateChange,
    IN OUT PVOID StateChangeData,
    IN OUT PULONG StateChangeDataLength
    );

NTSTATUS NTAPI
LsaIOpenPolicyTrusted(
    OUT PLSAPR_HANDLE PolicyHandle
    );

NTSTATUS NTAPI
LsaIQueryInformationPolicyTrusted(
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *Buffer
    );

NTSTATUS NTAPI
LsaIGetSerialNumberPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    OUT PLARGE_INTEGER ModifiedCount,
    OUT PLARGE_INTEGER CreationTime
    );

NTSTATUS NTAPI
LsaISetSerialNumberPolicy(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLARGE_INTEGER ModifiedCount,
    IN PLARGE_INTEGER CreationTime,
    IN BOOLEAN StartOfFullSync
    );

NTSTATUS NTAPI
LsaIGetSerialNumberPolicy2(
    IN LSAPR_HANDLE PolicyHandle,
    OUT PLARGE_INTEGER ModifiedCount,
    OUT PLARGE_INTEGER ModifiedCountAtLastPromotion,
    OUT PLARGE_INTEGER CreationTime
    );

NTSTATUS NTAPI
LsaISetSerialNumberPolicy2(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLARGE_INTEGER ModifiedCount,
    IN PLARGE_INTEGER ModifiedCountAtLastPromotion OPTIONAL,
    IN PLARGE_INTEGER CreationTime,
    IN BOOLEAN StartOfFullSync
    );

NTSTATUS NTAPI
LsaIGetPrivateData(
    IN LSAPR_HANDLE PolicyHandle,
    OUT PULONG DataLength,
    OUT PVOID *Data
    );

NTSTATUS NTAPI
LsaISetPrivateData(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG DataLength,
    IN PVOID Data
    );

NTSTATUS NTAPI
LsaIEnumerateSecrets(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PVOID *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    );

NTSTATUS NTAPI
LsaISetTimesSecret(
    IN LSAPR_HANDLE SecretHandle,
    IN PLARGE_INTEGER CurrentValueSetTime,
    IN PLARGE_INTEGER OldValueSetTime
    );

#ifdef __LOGONMSV_H__ // This API is only of interest to users of logonmsv.h

NTSTATUS NTAPI
LsaIFilterSids(
    IN PUNICODE_STRING TrustedDomainName,
    IN ULONG TrustDirection,
    IN ULONG TrustType,
    IN ULONG TrustAttributes,
    IN PSID Sid,
    IN NETLOGON_VALIDATION_INFO_CLASS InfoClass,
    IN OUT PVOID SamInfo
    );

#endif

typedef enum {

    RoutingMatchDomainSid,
    RoutingMatchDomainName,
    RoutingMatchUpn,
    RoutingMatchSpn,

} LSA_ROUTING_MATCH_TYPE;

NTSTATUS NTAPI
LsaIForestTrustFindMatch(
    IN LSA_ROUTING_MATCH_TYPE Type,
    IN PVOID Data,
    OUT PLSA_UNICODE_STRING Match
    );

VOID
LsaIFree_LSA_FOREST_TRUST_INFORMATION(
    IN PLSA_FOREST_TRUST_INFORMATION * ForestTrustInfo
    );

VOID
LsaIFree_LSA_FOREST_TRUST_COLLISION_INFORMATION(
    IN PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo
    );

BOOLEAN NTAPI
LsaISetupWasRun(
    );

BOOLEAN NTAPI
LsaISafeMode(
    VOID
    );

BOOLEAN NTAPI
LsaILookupWellKnownName(
    IN PUNICODE_STRING WellKnownName
    );

VOID NTAPI
LsaIFree_LSAPR_ACCOUNT_ENUM_BUFFER (
    IN PLSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer
    );

VOID NTAPI
LsaIFree_LSAPR_TRANSLATED_SIDS (
    IN PLSAPR_TRANSLATED_SIDS TranslatedSids
    );

VOID NTAPI
LsaIFree_LSAPR_TRANSLATED_NAMES (
    IN PLSAPR_TRANSLATED_NAMES TranslatedNames
    );

VOID NTAPI
LsaIFree_LSAPR_POLICY_INFORMATION (
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation
    );

VOID NTAPI
LsaIFree_LSAPR_POLICY_DOMAIN_INFORMATION (
    IN POLICY_DOMAIN_INFORMATION_CLASS DomainInformationClass,
    IN PLSAPR_POLICY_DOMAIN_INFORMATION PolicyDomainInformation
    );

VOID NTAPI
LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO (
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation
    );

VOID NTAPI
LsaIFree_LSAPR_REFERENCED_DOMAIN_LIST (
    IN PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains
    );

VOID NTAPI
LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER (
    IN PLSAPR_TRUSTED_ENUM_BUFFER EnumerationBuffer
    );

VOID NTAPI
LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER_EX (
    PLSAPR_TRUSTED_ENUM_BUFFER_EX EnumerationBuffer
    );

VOID NTAPI
LsaIFree_LSAPR_TRUST_INFORMATION (
    IN PLSAPR_TRUST_INFORMATION TrustInformation
    );

VOID NTAPI
LsaIFree_LSAP_SECRET_ENUM_BUFFER (
    IN PVOID Buffer,
    IN ULONG Count
    );

VOID NTAPI
LsaIFree_LSAPR_PRIVILEGE_ENUM_BUFFER (
    PLSAPR_PRIVILEGE_ENUM_BUFFER EnumerationBuffer
    );

VOID NTAPI
LsaIFree_LSAPR_SR_SECURITY_DESCRIPTOR (
    IN PLSAPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor
    );

VOID
LsaIFree_LSAI_SECRET_ENUM_BUFFER (
    IN PVOID Buffer,
    IN ULONG Count
    );

VOID NTAPI
LsaIFree_LSAI_PRIVATE_DATA (
    IN PVOID Data
    );

VOID NTAPI
LsaIFree_LSAPR_UNICODE_STRING (
    IN PLSAPR_UNICODE_STRING UnicodeName
    );

VOID NTAPI
LsaIFree_LSAPR_UNICODE_STRING_BUFFER (
    IN PLSAPR_UNICODE_STRING UnicodeName
    );

VOID NTAPI
LsaIFree_LSAPR_PRIVILEGE_SET (
    IN PLSAPR_PRIVILEGE_SET PrivilegeSet
    );

VOID NTAPI
LsaIFree_LSAPR_CR_CIPHER_VALUE (
    IN PLSAPR_CR_CIPHER_VALUE CipherValue
    );


NTSTATUS NTAPI
LsaIAuditSamEvent(
    IN NTSTATUS             Status,
    IN ULONG                AuditId,
    IN PSID                 DomainSid,
    IN PUNICODE_STRING      AdditionalInfo    OPTIONAL,
    IN PULONG               MemberRid         OPTIONAL,
    IN PSID                 MemberSid         OPTIONAL,
    IN PUNICODE_STRING      AccountName       OPTIONAL,
    IN PUNICODE_STRING      DomainName,
    IN PULONG               AccountRid        OPTIONAL,
    IN PPRIVILEGE_SET       Privileges        OPTIONAL
    );

VOID NTAPI
LsaIAuditNotifyPackageLoad(
    PUNICODE_STRING PackageFileName
    );

NTSTATUS NTAPI
LsaIAuditKdcEvent(
    IN ULONG                AuditId,
    IN PUNICODE_STRING      ClientName,
    IN PUNICODE_STRING      ClientDomain,
    IN PSID                 ClientSid,
    IN PUNICODE_STRING      ServiceName,
    IN PSID                 ServiceSid,
    IN PULONG               KdcOptions,
    IN PULONG               KerbStatus,
    IN PULONG               EncryptionType,
    IN PULONG               PreAuthType,
    IN PBYTE                ClientAddress,
    IN LPGUID               UniqueId        OPTIONAL
    );

NTSTATUS
LsaIGetLogonGuid(
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pUserDomain,
    IN PBYTE pBuffer,
    IN UINT BufferSize,
    OUT LPGUID pLogonGuid
    );

NTSTATUS
LsaISetLogonGuidInLogonSession(
    IN  PLUID           LogonId,
    IN  LPGUID          LogonGuid           OPTIONAL
    );

VOID
LsaIAuditKerberosLogon(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN PSID UserSid,                            OPTIONAL
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId,
    IN LPGUID LogonGuid
    );

NTSTATUS
LsaIAuditLogonUsingExplicitCreds(
    IN USHORT          AuditEventType,
    IN PSID            pUser1Sid,
    IN PUNICODE_STRING pUser1Name,
    IN PUNICODE_STRING pUser1Domain,
    IN PLUID           pUser1LogonId,          
    IN LPGUID          pUser1LogonGuid,         OPTIONAL
    IN PUNICODE_STRING pUser2Name,
    IN PUNICODE_STRING pUser2Domain,
    IN LPGUID          pUser2LogonGuid
    );
    
NTSTATUS
LsaIAuditAccountLogon(
    IN ULONG                AuditId,
    IN BOOLEAN              Successful,
    IN PUNICODE_STRING      Source, 
    IN PUNICODE_STRING      ClientName,
    IN PUNICODE_STRING      MappedName,
    IN NTSTATUS             Status          OPTIONAL
    );

NTSTATUS NTAPI
LsaIAuditDPAPIEvent(
    IN ULONG                AuditId,
    IN PSID                 UserSid,
    IN PUNICODE_STRING      MasterKeyID,
    IN PUNICODE_STRING      RecoveryServer,
    IN PULONG               Reason,
    IN PUNICODE_STRING      RecoverykeyID,
    IN PULONG               FailureReason
    );


#define LSA_AUDIT_PARAMETERS_ABSOLUTE 1

NTSTATUS NTAPI
LsaIWriteAuditEvent(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters,
    IN ULONG Options
    );


NTSTATUS
LsaIAuditPasswordAccessEvent(
    IN USHORT EventType,
    IN PCWSTR pszTargetUserName,
    IN PCWSTR pszTargetUserDomain
    );
    

NTSTATUS NTAPI
LsaICallPackage(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

VOID NTAPI
LsaIFreeReturnBuffer(
    IN PVOID Buffer
    );



//
// NT5 routines for using the Ds for Lsa store
//

#define LSAI_FOREST_ROOT_TRUST              0x00000001
#define LSAI_FOREST_DOMAIN_GUID_PRESENT     0x00000002

//
// These structures correspond to the private interface Kerberos uses
// to build a tree of the domains in an organization.
//

typedef struct _LSAPR_TREE_TRUST_INFO {

    UNICODE_STRING DnsDomainName;
    UNICODE_STRING FlatName;
    GUID DomainGuid;
    PSID DomainSid;
    ULONG Flags;
    ULONG Children;
    struct _LSAPR_TREE_TRUST_INFO *ChildDomains;
} LSAPR_TREE_TRUST_INFO, *PLSAPR_TREE_TRUST_INFO;

typedef struct _LSAPR_FOREST_TRUST_INFO {

    LSAPR_TREE_TRUST_INFO RootTrust;
    PLSAPR_TREE_TRUST_INFO ParentDomainReference;

} LSAPR_FOREST_TRUST_INFO, *PLSAPR_FOREST_TRUST_INFO;

VOID
LsaIFreeForestTrustInfo(
    IN PLSAPR_FOREST_TRUST_INFO ForestTrustInfo
    );

NTSTATUS
NTAPI
LsaIQueryForestTrustInfo(
    IN LSAPR_HANDLE PolicyHandle,
    OUT PLSAPR_FOREST_TRUST_INFO *ForestTrustInfo
    );



NTSTATUS NTAPI
LsaISetTrustedDomainAuthInfoBlobs(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING TrustedDomainName,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_BLOB IncomingBlob,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_BLOB OutgoingBlob);


NTSTATUS NTAPI
LsaIUpgradeRegistryToDs(
    IN BOOLEAN DeleteOnly
    );

NTSTATUS NTAPI
LsaIGetTrustedDomainAuthInfoBlobs(
    IN  LSAPR_HANDLE PolicyHandle,
    IN  PLSAPR_UNICODE_STRING TrustedDomainName,
    OUT PLSAPR_TRUSTED_DOMAIN_AUTH_BLOB IncomingBlob,
    OUT PLSAPR_TRUSTED_DOMAIN_AUTH_BLOB OutgoingBlob
    );

NTSTATUS NTAPI
LsaISetServerRoleForNextBoot(
    IN  LSAPR_HANDLE PolicyHandle,
    IN POLICY_LSA_SERVER_ROLE ServerRole
    );


BOOLEAN NTAPI
LsaIIsClassIdLsaClass(
    IN ULONG ClassId,
    OUT PULONG LsaClass
    );


NTSTATUS NTAPI
LsaIDsNotifiedObjectChange(
    IN ULONG Class,
    IN PVOID ObjectPath,   // This is a DSNAME
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN PSID UserSid,
    IN LUID AuthenticationId,
    IN BOOLEAN fReplicatedIn,
    IN BOOLEAN ChangeOriginatedInLSA
    );

typedef NTSTATUS (NTAPI *pfLsaIDsNotifiedObjectChange )(
        ULONG, PVOID, SECURITY_DB_DELTA_TYPE, PSID, LUID, BOOLEAN, BOOLEAN );

//
// NT5 routines for moving some SAM domain object properties to the Lsa Ds objects
//
#define LSAI_SAM_NONE                   0x00000000
#define LSAI_SAM_TRANSACTION_ACTIVE     0x00000001

#define LSAI_SAM_ADD                    0x1
#define LSAI_SAM_REMOVE                 0x2

NTSTATUS NTAPI
LsaISamSetDomainObjectProperties(
    IN DOMAIN_INFORMATION_CLASS SamInfoClass,
    IN PVOID Buffer,
    IN ULONG Options
    );

NTSTATUS NTAPI
LsaISamSetDomainBuiltinGroupMembership(
    IN PSID GroupSid,
    IN ULONG Operation,
    IN ULONG Users,
    IN PVOID UserList,          // This is a list of DSNAME pointers
    IN ULONG Options
    );

NTSTATUS NTAPI
LsaISamIndicatedDsStarted(
    IN BOOLEAN PerformDomainRenameCheck
    );


//
// Netlogon routines for enumerating subnets
//

typedef struct _LSAP_SUBNET_INFO_ENTRY {
    UNICODE_STRING SubnetName;
    UNICODE_STRING SiteName;
} LSAP_SUBNET_INFO_ENTRY, *PLSAP_SUBNET_INFO_ENTRY;

typedef struct _LSAP_SUBNET_INFO {
    ULONG SiteCount;
    ULONG SubnetCount;
    LSAP_SUBNET_INFO_ENTRY Subnets[1];
} LSAP_SUBNET_INFO, *PLSAP_SUBNET_INFO;

NTSTATUS NTAPI
LsaIQuerySubnetInfo(
    OUT PLSAP_SUBNET_INFO *SubnetInformation
    );

VOID NTAPI
LsaIFree_LSAP_SUBNET_INFO(
    IN PLSAP_SUBNET_INFO SubnetInfo
    );


//
// Netlogon routines for UPN/SPN suffixes
//

typedef struct _LSAP_UPN_SUFFIXES {
    ULONG SuffixCount;
    UNICODE_STRING Suffixes[1];
} LSAP_UPN_SUFFIXES, *PLSAP_UPN_SUFFIXES;

NTSTATUS
LsaIQueryUpnSuffixes(
    OUT PLSAP_UPN_SUFFIXES *UpnSuffixes
    );

VOID
LsaIFree_LSAP_UPN_SUFFIXES(
    IN PLSAP_UPN_SUFFIXES UpnSuffixes
    );

NTSTATUS
LsaIGetForestTrustInformation(
    OUT PLSA_FOREST_TRUST_INFORMATION *ForestTrustInfo
    );

NTSTATUS
LsaIUpdateForestTrustInformation(
    IN LSAPR_HANDLE PolicyHandle,
    IN UNICODE_STRING * TrustedDomainName,
    IN PLSA_FOREST_TRUST_INFORMATION NewForestTrustInfo
    );

//
// Netlogon routines for enumerating sites
//

typedef struct _LSAP_SITE_INFO_ENTRY {
    UNICODE_STRING SiteName;
} LSAP_SITE_INFO_ENTRY, *PLSAP_SITE_INFO_ENTRY;

typedef struct _LSAP_SITE_INFO {
    ULONG SiteCount;
    LSAP_SITE_INFO_ENTRY Sites[1];
} LSAP_SITE_INFO, *PLSAP_SITE_INFO;

NTSTATUS NTAPI
LsaIQuerySiteInfo(
    OUT PLSAP_SITE_INFO *SiteInformation
    );

VOID NTAPI
LsaIFree_LSAP_SITE_INFO(
    IN PLSAP_SITE_INFO SubnetInfo
    );

//
// Netlogon routines for getting the name of the site we're in.
//

typedef struct _LSAP_SITENAME_INFO {
    UNICODE_STRING SiteName;
    GUID DsaGuid;
    ULONG DsaOptions;
} LSAP_SITENAME_INFO, *PLSAP_SITENAME_INFO;

NTSTATUS NTAPI
LsaIGetSiteName(
    OUT PLSAP_SITENAME_INFO *SiteNameInformation
    );

VOID NTAPI
LsaIFree_LSAP_SITENAME_INFO(
    IN PLSAP_SITENAME_INFO SiteNameInfo
    );

BOOLEAN NTAPI
LsaIIsDsPaused(
    VOID
    );



//
// Lsa notification routine definitions
//

//
// Notification callback routine prototype
//
typedef VOID ( NTAPI fLsaPolicyChangeNotificationCallback) (
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    );

typedef fLsaPolicyChangeNotificationCallback *pfLsaPolicyChangeNotificationCallback;

NTSTATUS NTAPI
LsaIRegisterPolicyChangeNotificationCallback(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    );

NTSTATUS NTAPI
LsaIUnregisterPolicyChangeNotificationCallback(
    IN pfLsaPolicyChangeNotificationCallback Callback,
    IN POLICY_NOTIFICATION_INFORMATION_CLASS MonitorInfoClass
    );

NTSTATUS NTAPI
LsaIUnregisterAllPolicyChangeNotificationCallback(
    IN pfLsaPolicyChangeNotificationCallback Callback
    );


HANDLE NTAPI
LsaIRegisterNotification(
    IN PTHREAD_START_ROUTINE StartFunction,
    IN PVOID Parameter,
    IN ULONG NotificationType,
    IN ULONG NotificationClass,
    IN ULONG NotificationFlags,
    IN ULONG IntervalMinutes,
    IN OPTIONAL HANDLE WaitEvent
    );


NTSTATUS NTAPI
LsaICancelNotification(
    IN HANDLE NotifyHandle
    );

BOOLEAN
NTAPI
LsaIEventNotify(
    ULONG       Class,
    ULONG       Flags,
    ULONG       EventSize,
    PVOID       EventData);

VOID
LsaIAddTouchAddress(
    PVOID   Address,
    SIZE_T  Range
    );

VOID
LsaIRemoveTouchAddress(
    PVOID   Address
    );

//
// This is the notification Kerberos registers to receive updates on changing trusts
//
typedef VOID (fLsaTrustChangeNotificationCallback) (
    IN SECURITY_DB_DELTA_TYPE DeltaType
    );

typedef fLsaTrustChangeNotificationCallback *pfLsaTrustChangeNotificationCallback;

typedef enum LSAP_REGISTER {

    LsaRegister = 0,
    LsaUnregister

} LSAP_REGISTER, *PLSAP_REGISTER;

NTSTATUS NTAPI
LsaIKerberosRegisterTrustNotification(
    IN pfLsaTrustChangeNotificationCallback Callback,
    IN LSAP_REGISTER Register
    );

//
// See secpkg.h : LsaGetCallInfo and SECPKG_CALL_INFO
//
BOOLEAN
NTAPI
LsaIGetCallInfo(
    PVOID
    );

BOOLEAN
LsaIGetThreadHeap(
    VOID
    );

VOID
LsaITossThreadHeap(
    VOID
    );

PVOID
LsaIThreadAlloc(
    IN SIZE_T Size
    );

VOID
LsaIThreadFree(
    IN PVOID Memory
    );


NTSTATUS
LsaISetClientDnsHostName(
    IN PWSTR ClientName,
    IN PWSTR ClientDnsHostName OPTIONAL,
    IN POSVERSIONINFOEXW OsVersionInfo OPTIONAL,
    IN PWSTR OsName OPTIONAL,
    OUT PWSTR *OldDnsHostName OPTIONAL
    );

VOID
LsaIManageReplicationSyncLock(
    IN BOOLEAN TakeLock
    );

NTSTATUS
LsaICallPackageEx(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ClientBufferBase,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID * ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
LsaICallPackagePassthrough(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ClientBufferBase,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID * ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
LsaISetBootOption(
   IN ULONG BootOption,
   IN PVOID OldKey,
   IN ULONG OldKeyLength,
   IN PVOID NewKey,
   IN ULONG NewKeyLength
    );

NTSTATUS
LsaIGetBootOption(
   OUT PULONG BootOption
   );

VOID
LsaINotifyPasswordChanged(
    IN PUNICODE_STRING NetbiosDomainName OPTIONAL,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DnsDomainName OPTIONAL,
    IN PUNICODE_STRING Upn OPTIONAL,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword,
    IN BOOLEAN Impersonating
    );

NTSTATUS
LsaINotifyChangeNotification(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS InfoClass
    );

NTSTATUS
LsaIGetNbAndDnsDomainNames(
    IN PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING DnsDomainName,
    OUT PUNICODE_STRING NetbiosDomainName
    );



//
// This flag indicates the the protected blob is a system blob, and cannot
// be decrypted by the user-space.
//
#define CRYPTPROTECT_SYSTEM  0x20000000


//
// Local Free should be used to free the returned buffer
//
BOOLEAN
LsaICryptProtectData(
        IN PVOID          DataIn,
        IN ULONG         DataInLength,
        IN PUNICODE_STRING        szDataDescr,
        IN PVOID          OptionalEntropy,
        IN ULONG          OptionalEntropyLength,
        IN PVOID          Reserved,
        IN PVOID          Reserved2,
        IN ULONG          Flags,
        OUT PVOID  *      DataOut,
        OUT PULONG        DataOutLength);


//
// Local Free should be used to free the returned buffer
//
BOOLEAN
LsaICryptUnprotectData(
        IN PVOID          DataIn,
        IN ULONG          DataInLength,
        IN PVOID          OptionalEntropy,
        IN ULONG          OptionalEntropyLength,
        IN PVOID          Reserved,
        IN PVOID          Reserved2,
        IN ULONG          Flags,
        OUT PUNICODE_STRING        szDataDescr,
        OUT PVOID  *      DataOut,
        OUT PULONG        DataOutLength);

//
// Heap allocator for the LSA process
//

PVOID
NTAPI
LsaIAllocateHeapZero(
    IN SIZE_T Length
    );

PVOID
NTAPI
LsaIAllocateHeap(
    IN SIZE_T cbMemory
    );

VOID
NTAPI
LsaIFreeHeap(
    IN PVOID Base
    );

typedef enum LSAP_NETLOGON_PARAMETER {

   LsaEmulateNT4,

} LSAP_NETLOGON_PARAMETER;

VOID
NTAPI
LsaINotifyNetlogonParametersChangeW(
    IN LSAP_NETLOGON_PARAMETER Parameter,
    IN DWORD dwType,
    IN PWSTR lpData,
    IN DWORD cbData
    );

NTSTATUS
NTAPI
LsaIChangeSecretCipherKey(
    IN PVOID NewSysKey
    );

#ifdef __cplusplus
}
#endif

#endif // _LSAISRV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\lsarpc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for lsarpc.idl, lsasrv.acf:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __lsarpc_h__
#define __lsarpc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "lsaimp.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __lsarpc_INTERFACE_DEFINED__
#define __lsarpc_INTERFACE_DEFINED__

/* interface lsarpc */
/* [implicit_handle][strict_context_handle][unique][ms_union][version][uuid] */ 

#define LSA_LOOKUP_REVISION_1 0x1
#define LSA_LOOKUP_REVISION_2 0x2
#define LSA_LOOKUP_REVISION_LATEST  LSA_LOOKUP_REVISION_2
#define LSA_CLIENT_PRE_NT5 0x1
#define LSA_CLIENT_NT5     0x2
#define LSA_CLIENT_LATEST  0x2
typedef /* [handle] */ LPWSTR PLSAPR_SERVER_NAME;

typedef /* [handle] */ LPWSTR *PPLSAPR_SERVER_NAME;

typedef /* [context_handle] */ PVOID LSAPR_HANDLE;

typedef LSAPR_HANDLE *PLSAPR_HANDLE;

#pragma warning(disable:4200)
typedef struct _LSAPR_SID
    {
    UCHAR Revision;
    UCHAR SubAuthorityCount;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    /* [size_is] */ ULONG SubAuthority[ 1 ];
    } 	LSAPR_SID;

typedef struct _LSAPR_SID *PLSAPR_SID;

typedef struct _LSAPR_SID **PPLSAPR_SID;

#pragma warning(default:4200)
typedef struct _LSAPR_SID_INFORMATION
    {
    PLSAPR_SID Sid;
    } 	LSAPR_SID_INFORMATION;

typedef struct _LSAPR_SID_INFORMATION *PLSAPR_SID_INFORMATION;

typedef struct _LSAPR_SID_ENUM_BUFFER
    {
    ULONG Entries;
    /* [size_is] */ PLSAPR_SID_INFORMATION SidInfo;
    } 	LSAPR_SID_ENUM_BUFFER;

typedef struct _LSAPR_SID_ENUM_BUFFER *PLSAPR_SID_ENUM_BUFFER;

typedef struct _LSAPR_ACCOUNT_INFORMATION
    {
    PLSAPR_SID Sid;
    } 	LSAPR_ACCOUNT_INFORMATION;

typedef struct _LSAPR_ACCOUNT_INFORMATION *PLSAPR_ACCOUNT_INFORMATION;

typedef struct _LSAPR_ACCOUNT_ENUM_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PLSAPR_ACCOUNT_INFORMATION Information;
    } 	LSAPR_ACCOUNT_ENUM_BUFFER;

typedef struct _LSAPR_ACCOUNT_ENUM_BUFFER *PLSAPR_ACCOUNT_ENUM_BUFFER;

typedef struct _LSAPR_UNICODE_STRING
    {
    USHORT Length;
    USHORT MaximumLength;
    /* [length_is][size_is] */ PWSTR Buffer;
    } 	LSAPR_UNICODE_STRING;

typedef struct _LSAPR_UNICODE_STRING *PLSAPR_UNICODE_STRING;

typedef struct _LSAPR_STRING
    {
    USHORT Length;
    USHORT MaximumLength;
    /* [size_is] */ PCHAR Buffer;
    } 	LSAPR_STRING;

typedef struct _LSAPR_STRING *PLSAPR_STRING;

typedef struct _LSAPR_STRING LSAPR_ANSI_STRING;

typedef struct _LSAPR_STRING *PLSAPR_ANSI_STRING;

#pragma warning(disable:4200)
typedef struct _LSAPR_ACL
    {
    UCHAR AclRevision;
    UCHAR Sbz1;
    USHORT AclSize;
    /* [size_is] */ UCHAR Dummy1[ 1 ];
    } 	LSAPR_ACL;

typedef struct _LSAPR_ACL *PLSAPR_ACL;

#pragma warning(default:4200)
typedef struct _LSAPR_SECURITY_DESCRIPTOR
    {
    UCHAR Revision;
    UCHAR Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    PLSAPR_SID Owner;
    PLSAPR_SID Group;
    PLSAPR_ACL Sacl;
    PLSAPR_ACL Dacl;
    } 	LSAPR_SECURITY_DESCRIPTOR;

typedef struct _LSAPR_SECURITY_DESCRIPTOR *PLSAPR_SECURITY_DESCRIPTOR;

typedef struct _LSAPR_SR_SECURITY_DESCRIPTOR
    {
    ULONG Length;
    /* [size_is] */ PUCHAR SecurityDescriptor;
    } 	LSAPR_SR_SECURITY_DESCRIPTOR;

typedef struct _LSAPR_SR_SECURITY_DESCRIPTOR *PLSAPR_SR_SECURITY_DESCRIPTOR;

typedef struct _LSAPR_LUID_AND_ATTRIBUTES
    {
    OLD_LARGE_INTEGER Luid;
    ULONG Attributes;
    } 	LSAPR_LUID_AND_ATTRIBUTES;

typedef struct _LSAPR_LUID_AND_ATTRIBUTES *PLSAPR_LUID_AND_ATTRIBUTES;

#pragma warning(disable:4200)
typedef struct _LSAPR_PRIVILEGE_SET
    {
    ULONG PrivilegeCount;
    ULONG Control;
    /* [size_is] */ LSAPR_LUID_AND_ATTRIBUTES Privilege[ 1 ];
    } 	LSAPR_PRIVILEGE_SET;

typedef struct _LSAPR_PRIVILEGE_SET *PLSAPR_PRIVILEGE_SET;

typedef struct _LSAPR_PRIVILEGE_SET **PPLSAPR_PRIVILEGE_SET;

#pragma warning(default:4200)
typedef struct _LSAPR_POLICY_PRIVILEGE_DEF
    {
    LSAPR_UNICODE_STRING Name;
    LUID LocalValue;
    } 	LSAPR_POLICY_PRIVILEGE_DEF;

typedef struct _LSAPR_POLICY_PRIVILEGE_DEF *PLSAPR_POLICY_PRIVILEGE_DEF;

typedef struct _LSAPR_PRIVILEGE_ENUM_BUFFER
    {
    ULONG Entries;
    /* [size_is] */ PLSAPR_POLICY_PRIVILEGE_DEF Privileges;
    } 	LSAPR_PRIVILEGE_ENUM_BUFFER;

typedef struct _LSAPR_PRIVILEGE_ENUM_BUFFER *PLSAPR_PRIVILEGE_ENUM_BUFFER;

typedef struct _LSAPR_OBJECT_ATTRIBUTES
    {
    ULONG Length;
    PUCHAR RootDirectory;
    PSTRING ObjectName;
    ULONG Attributes;
    PLSAPR_SECURITY_DESCRIPTOR SecurityDescriptor;
    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    } 	LSAPR_OBJECT_ATTRIBUTES;

typedef struct _LSAPR_OBJECT_ATTRIBUTES *PLSAPR_OBJECT_ATTRIBUTES;

typedef struct _LSAPR_CR_CLEAR_VALUE
    {
    ULONG Length;
    ULONG MaximumLength;
    /* [length_is][size_is] */ PUCHAR Buffer;
    } 	LSAPR_CR_CLEAR_VALUE;

typedef struct _LSAPR_CR_CLEAR_VALUE *PLSAPR_CR_CLEAR_VALUE;

typedef struct _LSAPR_CR_CIPHER_VALUE
    {
    ULONG Length;
    ULONG MaximumLength;
    /* [length_is][size_is] */ PUCHAR Buffer;
    } 	LSAPR_CR_CIPHER_VALUE;

typedef /* [allocate] */ struct _LSAPR_CR_CIPHER_VALUE *PLSAPR_CR_CIPHER_VALUE;

typedef struct _LSAPR_TRUST_INFORMATION
    {
    LSAPR_UNICODE_STRING Name;
    PLSAPR_SID Sid;
    } 	LSAPR_TRUST_INFORMATION;

typedef struct _LSAPR_TRUST_INFORMATION *PLSAPR_TRUST_INFORMATION;

typedef struct _LSAPR_TRUST_INFORMATION_EX
    {
    LSAPR_UNICODE_STRING DomainName;
    LSAPR_UNICODE_STRING FlatName;
    PLSAPR_SID Sid;
    BOOLEAN DomainNamesDiffer;
    ULONG TrustAttributes;
    } 	LSAPR_TRUST_INFORMATION_EX;

typedef struct _LSAPR_TRUST_INFORMATION_EX *PLSAPR_TRUST_INFORMATION_EX;

typedef struct _LSAPR_TRUSTED_ENUM_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PLSAPR_TRUST_INFORMATION Information;
    } 	LSAPR_TRUSTED_ENUM_BUFFER;

typedef struct _LSAPR_TRUSTED_ENUM_BUFFER *PLSAPR_TRUSTED_ENUM_BUFFER;

typedef struct _LSAPR_REFERENCED_DOMAIN_LIST
    {
    ULONG Entries;
    /* [size_is] */ PLSAPR_TRUST_INFORMATION Domains;
    ULONG MaxEntries;
    } 	LSAPR_REFERENCED_DOMAIN_LIST;

typedef struct _LSAPR_REFERENCED_DOMAIN_LIST *PLSAPR_REFERENCED_DOMAIN_LIST;

#define LSA_LOOKUP_SID_FOUND_BY_HISTORY 0x00000001
#define LSA_LOOKUP_SID_XFOREST_REF      0x00000002
typedef struct _LSAPR_TRANSLATED_SID_EX
    {
    SID_NAME_USE Use;
    ULONG RelativeId;
    LONG DomainIndex;
    ULONG Flags;
    } 	LSAPR_TRANSLATED_SID_EX;

typedef struct _LSAPR_TRANSLATED_SID_EX *PLSAPR_TRANSLATED_SID_EX;

typedef struct _LSAPR_TRANSLATED_SID_EX2
    {
    SID_NAME_USE Use;
    PLSAPR_SID Sid;
    LONG DomainIndex;
    ULONG Flags;
    } 	LSAPR_TRANSLATED_SID_EX2;

typedef struct _LSAPR_TRANSLATED_SID_EX2 *PLSAPR_TRANSLATED_SID_EX2;

typedef struct _LSAPR_TRANSLATED_SIDS
    {
    ULONG Entries;
    /* [size_is] */ PLSA_TRANSLATED_SID Sids;
    } 	LSAPR_TRANSLATED_SIDS;

typedef struct _LSAPR_TRANSLATED_SIDS *PLSAPR_TRANSLATED_SIDS;

typedef struct _LSAPR_TRANSLATED_SIDS_EX
    {
    ULONG Entries;
    /* [size_is] */ PLSAPR_TRANSLATED_SID_EX Sids;
    } 	LSAPR_TRANSLATED_SIDS_EX;

typedef struct _LSAPR_TRANSLATED_SIDS_EX *PLSAPR_TRANSLATED_SIDS_EX;

typedef struct _LSAPR_TRANSLATED_SIDS_EX2
    {
    ULONG Entries;
    /* [size_is] */ PLSAPR_TRANSLATED_SID_EX2 Sids;
    } 	LSAPR_TRANSLATED_SIDS_EX2;

typedef struct _LSAPR_TRANSLATED_SIDS_EX2 *PLSAPR_TRANSLATED_SIDS_EX2;

typedef struct _LSAPR_TRANSLATED_NAME
    {
    SID_NAME_USE Use;
    LSAPR_UNICODE_STRING Name;
    LONG DomainIndex;
    } 	LSAPR_TRANSLATED_NAME;

typedef struct _LSAPR_TRANSLATED_NAME *PLSAPR_TRANSLATED_NAME;

#define LSA_LOOKUP_NAME_NOT_SAM_ACCOUNT_NAME  0x00000001
#define LSA_LOOKUP_NAME_XFOREST_REF  0x00000002
typedef struct _LSAPR_TRANSLATED_NAME_EX
    {
    SID_NAME_USE Use;
    LSAPR_UNICODE_STRING Name;
    LONG DomainIndex;
    ULONG Flags;
    } 	LSAPR_TRANSLATED_NAME_EX;

typedef struct _LSAPR_TRANSLATED_NAME_EX *PLSAPR_TRANSLATED_NAME_EX;

typedef struct _LSAPR_TRANSLATED_NAMES
    {
    ULONG Entries;
    /* [size_is] */ PLSAPR_TRANSLATED_NAME Names;
    } 	LSAPR_TRANSLATED_NAMES;

typedef struct _LSAPR_TRANSLATED_NAMES *PLSAPR_TRANSLATED_NAMES;

typedef struct _LSAPR_TRANSLATED_NAMES_EX
    {
    ULONG Entries;
    /* [size_is] */ PLSAPR_TRANSLATED_NAME_EX Names;
    } 	LSAPR_TRANSLATED_NAMES_EX;

typedef struct _LSAPR_TRANSLATED_NAMES_EX *PLSAPR_TRANSLATED_NAMES_EX;

typedef struct _LSAPR_POLICY_ACCOUNT_DOM_INFO
    {
    LSAPR_UNICODE_STRING DomainName;
    PLSAPR_SID DomainSid;
    } 	LSAPR_POLICY_ACCOUNT_DOM_INFO;

typedef struct _LSAPR_POLICY_ACCOUNT_DOM_INFO *PLSAPR_POLICY_ACCOUNT_DOM_INFO;

typedef struct _LSAPR_POLICY_PRIMARY_DOM_INFO
    {
    LSAPR_UNICODE_STRING Name;
    PLSAPR_SID Sid;
    } 	LSAPR_POLICY_PRIMARY_DOM_INFO;

typedef struct _LSAPR_POLICY_PRIMARY_DOM_INFO *PLSAPR_POLICY_PRIMARY_DOM_INFO;

typedef struct _LSAPR_POLICY_DNS_DOMAIN_INFO
    {
    LSAPR_UNICODE_STRING Name;
    LSAPR_UNICODE_STRING DnsDomainName;
    LSAPR_UNICODE_STRING DnsForestName;
    GUID DomainGuid;
    PLSAPR_SID Sid;
    } 	LSAPR_POLICY_DNS_DOMAIN_INFO;

typedef struct _LSAPR_POLICY_DNS_DOMAIN_INFO *PLSAPR_POLICY_DNS_DOMAIN_INFO;

typedef struct _LSAPR_POLICY_PD_ACCOUNT_INFO
    {
    LSAPR_UNICODE_STRING Name;
    } 	LSAPR_POLICY_PD_ACCOUNT_INFO;

typedef struct _LSAPR_POLICY_PD_ACCOUNT_INFO *PLSAPR_POLICY_PD_ACCOUNT_INFO;

typedef struct _LSAPR_POLICY_REPLICA_SRCE_INFO
    {
    LSAPR_UNICODE_STRING ReplicaSource;
    LSAPR_UNICODE_STRING ReplicaAccountName;
    } 	LSAPR_POLICY_REPLICA_SRCE_INFO;

typedef struct _LSAPR_POLICY_REPLICA_SRCE_INFO *PLSAPR_POLICY_REPLICA_SRCE_INFO;

typedef struct _LSAPR_POLICY_AUDIT_EVENTS_INFO
    {
    BOOLEAN AuditingMode;
    /* [size_is] */ PPOLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;
    ULONG MaximumAuditEventCount;
    } 	LSAPR_POLICY_AUDIT_EVENTS_INFO;

typedef struct _LSAPR_POLICY_AUDIT_EVENTS_INFO *PLSAPR_POLICY_AUDIT_EVENTS_INFO;

typedef /* [switch_type] */ union _LSAPR_POLICY_INFORMATION
    {
    /* [case()] */ POLICY_AUDIT_LOG_INFO PolicyAuditLogInfo;
    /* [case()] */ LSAPR_POLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo;
    /* [case()] */ LSAPR_POLICY_PRIMARY_DOM_INFO PolicyPrimaryDomainInfo;
    /* [case()] */ LSAPR_POLICY_ACCOUNT_DOM_INFO PolicyAccountDomainInfo;
    /* [case()] */ LSAPR_POLICY_PD_ACCOUNT_INFO PolicyPdAccountInfo;
    /* [case()] */ POLICY_LSA_SERVER_ROLE_INFO PolicyServerRoleInfo;
    /* [case()] */ LSAPR_POLICY_REPLICA_SRCE_INFO PolicyReplicaSourceInfo;
    /* [case()] */ POLICY_DEFAULT_QUOTA_INFO PolicyDefaultQuotaInfo;
    /* [case()] */ POLICY_MODIFICATION_INFO PolicyModificationInfo;
    /* [case()] */ POLICY_AUDIT_FULL_SET_INFO PolicyAuditFullSetInfo;
    /* [case()] */ POLICY_AUDIT_FULL_QUERY_INFO PolicyAuditFullQueryInfo;
    /* [case()] */ LSAPR_POLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfo;
    /* [case()] */ LSAPR_POLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfoInt;
    } 	LSAPR_POLICY_INFORMATION;

typedef LSAPR_POLICY_INFORMATION *PLSAPR_POLICY_INFORMATION;

typedef struct _LSAPR_POLICY_DOMAIN_EFS_INFO
    {
    ULONG InfoLength;
    /* [size_is] */ PUCHAR EfsBlob;
    } 	LSAPR_POLICY_DOMAIN_EFS_INFO;

typedef struct _LSAPR_POLICY_DOMAIN_EFS_INFO *PLSAPR_POLICY_DOMAIN_EFS_INFO;

typedef /* [switch_type] */ union _LSAPR_POLICY_DOMAIN_INFORMATION
    {
    /* [case()] */ LSAPR_POLICY_DOMAIN_EFS_INFO PolicyDomainEfsInfo;
    /* [case()] */ POLICY_DOMAIN_KERBEROS_TICKET_INFO PolicyDomainKerbTicketInfo;
    } 	LSAPR_POLICY_DOMAIN_INFORMATION;

typedef LSAPR_POLICY_DOMAIN_INFORMATION *PLSAPR_POLICY_DOMAIN_INFORMATION;

typedef struct _LSAPR_TRUSTED_DOMAIN_NAME_INFO
    {
    LSAPR_UNICODE_STRING Name;
    } 	LSAPR_TRUSTED_DOMAIN_NAME_INFO;

typedef struct _LSAPR_TRUSTED_DOMAIN_NAME_INFO *PLSAPR_TRUSTED_DOMAIN_NAME_INFO;

typedef struct _LSAPR_TRUSTED_CONTROLLERS_INFO
    {
    ULONG Entries;
    /* [size_is] */ PLSAPR_UNICODE_STRING Names;
    } 	LSAPR_TRUSTED_CONTROLLERS_INFO;

typedef struct _LSAPR_TRUSTED_CONTROLLERS_INFO *PLSAPR_TRUSTED_CONTROLLERS_INFO;

typedef struct _LSAPR_TRUSTED_PASSWORD_INFO
    {
    PLSAPR_CR_CIPHER_VALUE Password;
    PLSAPR_CR_CIPHER_VALUE OldPassword;
    } 	LSAPR_TRUSTED_PASSWORD_INFO;

typedef struct _LSAPR_TRUSTED_PASSWORD_INFO *PLSAPR_TRUSTED_PASSWORD_INFO;

typedef struct _LSAPR_TRUSTED_DOMAIN_INFORMATION_EX
    {
    LSAPR_UNICODE_STRING Name;
    LSAPR_UNICODE_STRING FlatName;
    PLSAPR_SID Sid;
    ULONG TrustDirection;
    ULONG TrustType;
    ULONG TrustAttributes;
    } 	LSAPR_TRUSTED_DOMAIN_INFORMATION_EX;

typedef struct _LSAPR_TRUSTED_DOMAIN_INFORMATION_EX *PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX;

typedef struct _LSAPR_AUTH_INFORMATION
    {
    LARGE_INTEGER LastUpdateTime;
    ULONG AuthType;
    ULONG AuthInfoLength;
    /* [size_is] */ PUCHAR AuthInfo;
    } 	LSAPR_AUTH_INFORMATION;

typedef struct _LSAPR_AUTH_INFORMATION *PLSAPR_AUTH_INFORMATION;

typedef struct _LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION
    {
    ULONG IncomingAuthInfos;
    PLSAPR_AUTH_INFORMATION IncomingAuthenticationInformation;
    PLSAPR_AUTH_INFORMATION IncomingPreviousAuthenticationInformation;
    ULONG OutgoingAuthInfos;
    PLSAPR_AUTH_INFORMATION OutgoingAuthenticationInformation;
    PLSAPR_AUTH_INFORMATION OutgoingPreviousAuthenticationInformation;
    } 	LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION;

typedef struct _LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION *PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION;

typedef struct _LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION
    {
    LSAPR_TRUSTED_DOMAIN_INFORMATION_EX Information;
    TRUSTED_POSIX_OFFSET_INFO PosixOffset;
    LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthInformation;
    } 	LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION;

typedef struct _LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION *PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION;

typedef LSAPR_TRUST_INFORMATION LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC;

typedef PLSAPR_TRUST_INFORMATION PLSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC;

typedef struct _LSAPR_TRUSTED_DOMAIN_AUTH_BLOB
    {
    ULONG AuthSize;
    /* [size_is] */ PUCHAR AuthBlob;
    } 	LSAPR_TRUSTED_DOMAIN_AUTH_BLOB;

typedef struct _LSAPR_TRUSTED_DOMAIN_AUTH_BLOB *PLSAPR_TRUSTED_DOMAIN_AUTH_BLOB;

typedef struct _LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL
    {
    LSAPR_TRUSTED_DOMAIN_AUTH_BLOB AuthBlob;
    } 	LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL;

typedef struct _LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL *PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL;

typedef struct _LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL
    {
    LSAPR_TRUSTED_DOMAIN_INFORMATION_EX Information;
    TRUSTED_POSIX_OFFSET_INFO PosixOffset;
    LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL AuthInformation;
    } 	LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL;

typedef struct _LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL *PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL;

typedef struct _LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2
    {
    LSAPR_UNICODE_STRING Name;
    LSAPR_UNICODE_STRING FlatName;
    PLSAPR_SID Sid;
    ULONG TrustDirection;
    ULONG TrustType;
    ULONG TrustAttributes;
    ULONG ForestTrustLength;
    /* [size_is] */ PUCHAR ForestTrustInfo;
    } 	LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2;

typedef struct _LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 *PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2;

typedef struct _LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2
    {
    LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 Information;
    TRUSTED_POSIX_OFFSET_INFO PosixOffset;
    LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthInformation;
    } 	LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2;

typedef struct _LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 *PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2;

typedef /* [switch_type] */ union _LSAPR_TRUSTED_DOMAIN_INFO
    {
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_NAME_INFO TrustedDomainNameInfo;
    /* [case()] */ LSAPR_TRUSTED_CONTROLLERS_INFO TrustedControllersInfo;
    /* [case()] */ TRUSTED_POSIX_OFFSET_INFO TrustedPosixOffsetInfo;
    /* [case()] */ LSAPR_TRUSTED_PASSWORD_INFO TrustedPasswordInfo;
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC TrustedDomainInfoBasic;
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInfoEx;
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION TrustedAuthInfo;
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION TrustedFullInfo;
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL TrustedAuthInfoInternal;
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL TrustedFullInfoInternal;
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 TrustedDomainInfoEx2;
    /* [case()] */ LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 TrustedFullInfo2;
    } 	LSAPR_TRUSTED_DOMAIN_INFO;

typedef LSAPR_TRUSTED_DOMAIN_INFO *PLSAPR_TRUSTED_DOMAIN_INFO;

typedef PLSAPR_UNICODE_STRING PLSAPR_UNICODE_STRING_ARRAY;

typedef struct _LSAPR_USER_RIGHT_SET
    {
    ULONG Entries;
    /* [size_is] */ PLSAPR_UNICODE_STRING_ARRAY UserRights;
    } 	LSAPR_USER_RIGHT_SET;

typedef struct _LSAPR_USER_RIGHT_SET *PLSAPR_USER_RIGHT_SET;

typedef struct _LSAPR_TRUSTED_ENUM_BUFFER_EX
    {
    ULONG EntriesRead;
    /* [size_is] */ PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX EnumerationBuffer;
    } 	LSAPR_TRUSTED_ENUM_BUFFER_EX;

typedef struct _LSAPR_TRUSTED_ENUM_BUFFER_EX *PLSAPR_TRUSTED_ENUM_BUFFER_EX;

typedef struct _LSAPR_TEST_INTERNAL_PARAMETER_BLOB
    {
    ULONG Size;
    /* [size_is] */ PUCHAR Argument;
    } 	LSAPR_TEST_INTERNAL_PARAMETER_BLOB;

typedef struct _LSAPR_TEST_INTERNAL_PARAMETER_BLOB *PLSAPR_TEST_INTERNAL_PARAMETER_BLOB;

typedef struct _LSAPR_TEST_INTERNAL_ARG_LIST
    {
    ULONG Items;
    /* [size_is] */ PLSAPR_TEST_INTERNAL_PARAMETER_BLOB Arg;
    } 	LSAPR_TEST_INTERNAL_ARG_LIST;

typedef struct _LSAPR_TEST_INTERNAL_ARG_LIST *PLSAPR_TEST_INTERNAL_ARG_LIST;

typedef 
enum _LSAPR_TEST_INTERNAL_ROUTINES
    {	LsaTest_IEnumerateSecrets	= 0,
	LsaTest_IQueryDomainOrgInfo	= LsaTest_IEnumerateSecrets + 1,
	LsaTest_ISetTrustedDomainAuthBlobs	= LsaTest_IQueryDomainOrgInfo + 1,
	LsaTest_IUpgradeRegistryToDs	= LsaTest_ISetTrustedDomainAuthBlobs + 1,
	LsaTest_ISamSetDomainObjectProperties	= LsaTest_IUpgradeRegistryToDs + 1,
	LsaTest_ISamSetDomainBuiltinGroupMembership	= LsaTest_ISamSetDomainObjectProperties + 1,
	LsaTest_ISamSetInterdomainTrustPassword	= LsaTest_ISamSetDomainBuiltinGroupMembership + 1,
	LsaTest_IRegisterPolicyChangeNotificationCallback	= LsaTest_ISamSetInterdomainTrustPassword + 1,
	LsaTest_IUnregisterPolicyChangeNotificationCallback	= LsaTest_IRegisterPolicyChangeNotificationCallback + 1,
	LsaTest_IUnregisterAllPolicyChangeNotificationCallback	= LsaTest_IUnregisterPolicyChangeNotificationCallback + 1,
	LsaTest_IStartTransaction	= LsaTest_IUnregisterAllPolicyChangeNotificationCallback + 1,
	LsaTest_IApplyTransaction	= LsaTest_IStartTransaction + 1,
	LsaTest_ITrustDomFixup	= LsaTest_IApplyTransaction + 1,
	LsaTest_ISetServerRoleForBoot	= LsaTest_ITrustDomFixup + 1,
	LsaTest_IQueryForestTrustInfo	= LsaTest_ISetServerRoleForBoot + 1,
	LsaTest_IBreak	= LsaTest_IQueryForestTrustInfo + 1,
	LsaTest_IQueryTrustedDomainAuthBlobs	= LsaTest_IBreak + 1,
	LsaTest_IQueryNt4Owf	= LsaTest_IQueryTrustedDomainAuthBlobs + 1
    } 	LSAPR_TEST_INTERNAL_ROUTINES;

/* [notify] */ NTSTATUS LsarClose( 
    /* [out][in] */ LSAPR_HANDLE *ObjectHandle);

/* [notify] */ NTSTATUS LsarDelete( 
    /* [in] */ LSAPR_HANDLE ObjectHandle);

/* [notify] */ NTSTATUS LsarEnumeratePrivileges( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [out][in] */ PLSA_ENUMERATION_HANDLE EnumerationContext,
    /* [out] */ PLSAPR_PRIVILEGE_ENUM_BUFFER EnumerationBuffer,
    /* [in] */ ULONG PreferedMaximumLength);

/* [notify] */ NTSTATUS LsarQuerySecurityObject( 
    /* [in] */ LSAPR_HANDLE ObjectHandle,
    /* [in] */ SECURITY_INFORMATION SecurityInformation,
    /* [out] */ PLSAPR_SR_SECURITY_DESCRIPTOR *SecurityDescriptor);

/* [notify] */ NTSTATUS LsarSetSecurityObject( 
    /* [in] */ LSAPR_HANDLE ObjectHandle,
    /* [in] */ SECURITY_INFORMATION SecurityInformation,
    /* [in] */ PLSAPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor);

/* [notify] */ NTSTATUS LsarChangePassword( 
    /* [in] */ PLSAPR_UNICODE_STRING ServerName,
    /* [in] */ PLSAPR_UNICODE_STRING DomainName,
    /* [in] */ PLSAPR_UNICODE_STRING AccountName,
    /* [in] */ PLSAPR_UNICODE_STRING OldPassword,
    /* [in] */ PLSAPR_UNICODE_STRING NewPassword);

/* [notify] */ NTSTATUS LsarOpenPolicy( 
    /* [unique][in] */ PLSAPR_SERVER_NAME SystemName,
    /* [in] */ PLSAPR_OBJECT_ATTRIBUTES ObjectAttributes,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *PolicyHandle);

/* [notify] */ NTSTATUS LsarQueryInformationPolicy( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ POLICY_INFORMATION_CLASS InformationClass,
    /* [switch_is][out] */ PLSAPR_POLICY_INFORMATION *PolicyInformation);

/* [notify] */ NTSTATUS LsarSetInformationPolicy( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ POLICY_INFORMATION_CLASS InformationClass,
    /* [switch_is][in] */ PLSAPR_POLICY_INFORMATION PolicyInformation);

/* [notify] */ NTSTATUS LsarClearAuditLog( 
    /* [in] */ LSAPR_HANDLE PolicyHandle);

/* [notify] */ NTSTATUS LsarCreateAccount( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID AccountSid,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *AccountHandle);

/* [notify] */ NTSTATUS LsarEnumerateAccounts( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [out][in] */ PLSA_ENUMERATION_HANDLE EnumerationContext,
    /* [out] */ PLSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer,
    /* [in] */ ULONG PreferedMaximumLength);

/* [notify] */ NTSTATUS LsarCreateTrustedDomain( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_TRUST_INFORMATION TrustedDomainInformation,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *TrustedDomainHandle);

/* [notify] */ NTSTATUS LsarEnumerateTrustedDomains( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [out][in] */ PLSA_ENUMERATION_HANDLE EnumerationContext,
    /* [out] */ PLSAPR_TRUSTED_ENUM_BUFFER EnumerationBuffer,
    /* [in] */ ULONG PreferedMaximumLength);

/* [notify] */ NTSTATUS LsarLookupNames( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ ULONG Count,
    /* [size_is][in] */ PLSAPR_UNICODE_STRING Names,
    /* [out] */ PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    /* [out][in] */ PLSAPR_TRANSLATED_SIDS TranslatedSids,
    /* [in] */ LSAP_LOOKUP_LEVEL LookupLevel,
    /* [out][in] */ PULONG MappedCount);

/* [notify] */ NTSTATUS LsarLookupSids( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID_ENUM_BUFFER SidEnumBuffer,
    /* [out] */ PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    /* [out][in] */ PLSAPR_TRANSLATED_NAMES TranslatedNames,
    /* [in] */ LSAP_LOOKUP_LEVEL LookupLevel,
    /* [out][in] */ PULONG MappedCount);

/* [notify] */ NTSTATUS LsarCreateSecret( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING SecretName,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *SecretHandle);

/* [notify] */ NTSTATUS LsarOpenAccount( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID AccountSid,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *AccountHandle);

/* [notify] */ NTSTATUS LsarEnumeratePrivilegesAccount( 
    /* [in] */ LSAPR_HANDLE AccountHandle,
    /* [out] */ PLSAPR_PRIVILEGE_SET *Privileges);

/* [notify] */ NTSTATUS LsarAddPrivilegesToAccount( 
    /* [in] */ LSAPR_HANDLE AccountHandle,
    /* [in] */ PLSAPR_PRIVILEGE_SET Privileges);

/* [notify] */ NTSTATUS LsarRemovePrivilegesFromAccount( 
    /* [in] */ LSAPR_HANDLE AccountHandle,
    /* [in] */ BOOLEAN AllPrivileges,
    /* [unique][in] */ PLSAPR_PRIVILEGE_SET Privileges);

/* [notify] */ NTSTATUS LsarGetQuotasForAccount( 
    /* [in] */ LSAPR_HANDLE AccountHandle,
    /* [out] */ PQUOTA_LIMITS QuotaLimits);

/* [notify] */ NTSTATUS LsarSetQuotasForAccount( 
    /* [in] */ LSAPR_HANDLE AccountHandle,
    /* [in] */ PQUOTA_LIMITS QuotaLimits);

/* [notify] */ NTSTATUS LsarGetSystemAccessAccount( 
    /* [in] */ LSAPR_HANDLE AccountHandle,
    /* [out] */ PULONG SystemAccess);

/* [notify] */ NTSTATUS LsarSetSystemAccessAccount( 
    /* [in] */ LSAPR_HANDLE AccountHandle,
    /* [in] */ ULONG SystemAccess);

/* [notify] */ NTSTATUS LsarOpenTrustedDomain( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID TrustedDomainSid,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *TrustedDomainHandle);

/* [notify] */ NTSTATUS LsarQueryInfoTrustedDomain( 
    /* [in] */ LSAPR_HANDLE TrustedDomainHandle,
    /* [in] */ TRUSTED_INFORMATION_CLASS InformationClass,
    /* [switch_is][out] */ PLSAPR_TRUSTED_DOMAIN_INFO *TrustedDomainInformation);

/* [notify] */ NTSTATUS LsarSetInformationTrustedDomain( 
    /* [in] */ LSAPR_HANDLE TrustedDomainHandle,
    /* [in] */ TRUSTED_INFORMATION_CLASS InformationClass,
    /* [switch_is][in] */ PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation);

/* [notify] */ NTSTATUS LsarOpenSecret( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING SecretName,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *SecretHandle);

/* [notify] */ NTSTATUS LsarSetSecret( 
    /* [in] */ LSAPR_HANDLE SecretHandle,
    /* [unique][in] */ PLSAPR_CR_CIPHER_VALUE EncryptedCurrentValue,
    /* [unique][in] */ PLSAPR_CR_CIPHER_VALUE EncryptedOldValue);

/* [notify] */ NTSTATUS LsarQuerySecret( 
    /* [in] */ LSAPR_HANDLE SecretHandle,
    /* [unique][out][in] */ PLSAPR_CR_CIPHER_VALUE *EncryptedCurrentValue,
    /* [unique][out][in] */ PLARGE_INTEGER CurrentValueSetTime,
    /* [unique][out][in] */ PLSAPR_CR_CIPHER_VALUE *EncryptedOldValue,
    /* [unique][out][in] */ PLARGE_INTEGER OldValueSetTime);

/* [notify] */ NTSTATUS LsarLookupPrivilegeValue( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING Name,
    /* [out] */ PLUID Value);

/* [notify] */ NTSTATUS LsarLookupPrivilegeName( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLUID Value,
    /* [out] */ PLSAPR_UNICODE_STRING *Name);

/* [notify] */ NTSTATUS LsarLookupPrivilegeDisplayName( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING Name,
    /* [in] */ SHORT ClientLanguage,
    /* [in] */ SHORT ClientSystemDefaultLanguage,
    /* [out] */ PLSAPR_UNICODE_STRING *DisplayName,
    /* [out] */ PWORD LanguageReturned);

/* [notify] */ NTSTATUS LsarDeleteObject( 
    /* [out][in] */ LSAPR_HANDLE *ObjectHandle);

/* [notify] */ NTSTATUS LsarEnumerateAccountsWithUserRight( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [unique][in] */ PLSAPR_UNICODE_STRING UserRight,
    /* [out] */ PLSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer);

/* [notify] */ NTSTATUS LsarEnumerateAccountRights( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID AccountSid,
    /* [out] */ PLSAPR_USER_RIGHT_SET UserRights);

/* [notify] */ NTSTATUS LsarAddAccountRights( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID AccountSid,
    /* [in] */ PLSAPR_USER_RIGHT_SET UserRights);

/* [notify] */ NTSTATUS LsarRemoveAccountRights( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID AccountSid,
    /* [in] */ BOOLEAN AllRights,
    /* [in] */ PLSAPR_USER_RIGHT_SET UserRights);

/* [notify] */ NTSTATUS LsarQueryTrustedDomainInfo( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID TrustedDomainSid,
    /* [in] */ TRUSTED_INFORMATION_CLASS InformationClass,
    /* [switch_is][out] */ PLSAPR_TRUSTED_DOMAIN_INFO *TrustedDomainInformation);

/* [notify] */ NTSTATUS LsarSetTrustedDomainInfo( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID TrustedDomainSid,
    /* [in] */ TRUSTED_INFORMATION_CLASS InformationClass,
    /* [switch_is][in] */ PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation);

/* [notify] */ NTSTATUS LsarDeleteTrustedDomain( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID TrustedDomainSid);

/* [notify] */ NTSTATUS LsarStorePrivateData( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING KeyName,
    /* [unique][in] */ PLSAPR_CR_CIPHER_VALUE EncryptedData);

/* [notify] */ NTSTATUS LsarRetrievePrivateData( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING KeyName,
    /* [out][in] */ PLSAPR_CR_CIPHER_VALUE *EncryptedData);

/* [notify] */ NTSTATUS LsarOpenPolicy2( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME SystemName,
    /* [in] */ PLSAPR_OBJECT_ATTRIBUTES ObjectAttributes,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *PolicyHandle);

/* [notify] */ NTSTATUS LsarGetUserName( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME SystemName,
    /* [out][in] */ PLSAPR_UNICODE_STRING *UserName,
    /* [unique][out][in] */ PLSAPR_UNICODE_STRING *DomainName);

/* [notify] */ NTSTATUS LsarQueryInformationPolicy2( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ POLICY_INFORMATION_CLASS InformationClass,
    /* [switch_is][out] */ PLSAPR_POLICY_INFORMATION *PolicyInformation);

/* [notify] */ NTSTATUS LsarSetInformationPolicy2( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ POLICY_INFORMATION_CLASS InformationClass,
    /* [switch_is][in] */ PLSAPR_POLICY_INFORMATION PolicyInformation);

/* [notify] */ NTSTATUS LsarQueryTrustedDomainInfoByName( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING TrustedDomainName,
    /* [in] */ TRUSTED_INFORMATION_CLASS InformationClass,
    /* [switch_is][out] */ PLSAPR_TRUSTED_DOMAIN_INFO *TrustedDomainInformation);

/* [notify] */ NTSTATUS LsarSetTrustedDomainInfoByName( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING TrustedDomainName,
    /* [in] */ TRUSTED_INFORMATION_CLASS InformationClass,
    /* [switch_is][in] */ PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation);

/* [notify] */ NTSTATUS LsarEnumerateTrustedDomainsEx( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [out][in] */ PLSA_ENUMERATION_HANDLE EnumerationContext,
    /* [out] */ PLSAPR_TRUSTED_ENUM_BUFFER_EX EnumerationBuffer,
    /* [in] */ ULONG PreferedMaximumLength);

/* [notify] */ NTSTATUS LsarCreateTrustedDomainEx( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    /* [in] */ PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *TrustedDomainHandle);

/* [notify] */ NTSTATUS LsarSetPolicyReplicationHandle( 
    /* [out][in] */ PLSAPR_HANDLE PolicyHandle);

/* [notify] */ NTSTATUS LsarQueryDomainInformationPolicy( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    /* [switch_is][out] */ PLSAPR_POLICY_DOMAIN_INFORMATION *PolicyDomainInformation);

/* [notify] */ NTSTATUS LsarSetDomainInformationPolicy( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    /* [switch_is][unique][in] */ PLSAPR_POLICY_DOMAIN_INFORMATION PolicyDomainInformation);

/* [notify] */ NTSTATUS LsarOpenTrustedDomainByName( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_UNICODE_STRING TrustedDomainName,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *TrustedDomainHandle);

NTSTATUS LsaITestCall( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ LSAPR_TEST_INTERNAL_ROUTINES Call,
    /* [in] */ PLSAPR_TEST_INTERNAL_ARG_LIST InputArgs,
    /* [out] */ PLSAPR_TEST_INTERNAL_ARG_LIST *OuputArgs);

NTSTATUS LsarLookupSids2( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_SID_ENUM_BUFFER SidEnumBuffer,
    /* [out] */ PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    /* [out][in] */ PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    /* [in] */ LSAP_LOOKUP_LEVEL LookupLevel,
    /* [out][in] */ PULONG MappedCount,
    /* [in] */ ULONG LookupOptions,
    /* [in] */ ULONG ClientRevision);

NTSTATUS LsarLookupNames2( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ ULONG Count,
    /* [size_is][in] */ PLSAPR_UNICODE_STRING Names,
    /* [out] */ PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    /* [out][in] */ PLSAPR_TRANSLATED_SIDS_EX TranslatedSids,
    /* [in] */ LSAP_LOOKUP_LEVEL LookupLevel,
    /* [out][in] */ PULONG MappedCount,
    /* [in] */ ULONG LookupOptions,
    /* [in] */ ULONG ClientRevision);

NTSTATUS LsarCreateTrustedDomainEx2( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    /* [in] */ PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL AuthenticationInformation,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *TrustedDomainHandle);

NTSTATUS CredrWrite( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [in] */ PENCRYPTED_CREDENTIALW Credential,
    /* [in] */ ULONG Flags);

NTSTATUS CredrRead( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [string][in] */ wchar_t *TargetName,
    /* [in] */ ULONG Type,
    /* [in] */ ULONG Flags,
    /* [out] */ PENCRYPTED_CREDENTIALW *Credential);

typedef PENCRYPTED_CREDENTIALW *PPENCRYPTED_CREDENTIALW;

typedef struct _CREDENTIAL_ARRAY
    {
    ULONG CredentialCount;
    /* [size_is][unique] */ PPENCRYPTED_CREDENTIALW Credentials;
    } 	CREDENTIAL_ARRAY;

typedef struct _CREDENTIAL_ARRAY *PCREDENTIAL_ARRAY;

NTSTATUS CredrEnumerate( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [string][unique][in] */ wchar_t *Filter,
    /* [in] */ ULONG Flags,
    /* [out] */ PCREDENTIAL_ARRAY CredentialArray);

NTSTATUS CredrWriteDomainCredentials( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [in] */ PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    /* [in] */ PENCRYPTED_CREDENTIALW Credential,
    /* [in] */ ULONG Flags);

NTSTATUS CredrReadDomainCredentials( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [in] */ PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    /* [in] */ ULONG Flags,
    /* [out] */ PCREDENTIAL_ARRAY CredentialArray);

NTSTATUS CredrDelete( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [string][in] */ wchar_t *TargetName,
    /* [in] */ ULONG Type,
    /* [in] */ ULONG Flags);

NTSTATUS CredrGetTargetInfo( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [string][in] */ wchar_t *TargetName,
    /* [in] */ ULONG Flags,
    /* [out] */ PCREDENTIAL_TARGET_INFORMATIONW *TargetInfo);

NTSTATUS CredrProfileLoaded( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName);

NTSTATUS LsarLookupNames3( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ ULONG Count,
    /* [size_is][in] */ PLSAPR_UNICODE_STRING Names,
    /* [out] */ PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    /* [out][in] */ PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    /* [in] */ LSAP_LOOKUP_LEVEL LookupLevel,
    /* [out][in] */ PULONG MappedCount,
    /* [in] */ ULONG LookupOptions,
    /* [in] */ ULONG ClientRevision);

NTSTATUS CredrGetSessionTypes( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [in] */ ULONG MaximumPersistCount,
    /* [size_is][out] */ ULONG *MaximumPersist);

NTSTATUS LsarRegisterAuditEvent( 
    /* [in] */ PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType,
    /* [out] */ AUDIT_HANDLE *phAuditContext);

NTSTATUS LsarGenAuditEvent( 
    /* [in] */ AUDIT_HANDLE hAuditContext,
    /* [in] */ DWORD Flags,
    /* [in] */ AUDIT_PARAMS *pAuditParams);

NTSTATUS LsarUnregisterAuditEvent( 
    /* [out][in] */ AUDIT_HANDLE *phAuditContext);

NTSTATUS LsarQueryForestTrustInformation( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSA_UNICODE_STRING TrustedDomainName,
    /* [in] */ LSA_FOREST_TRUST_RECORD_TYPE HighestRecordType,
    /* [out] */ PLSA_FOREST_TRUST_INFORMATION *ForestTrustInfo);

NTSTATUS LsarSetForestTrustInformation( 
    /* [in] */ LSAPR_HANDLE PolicyHandle,
    /* [in] */ PLSA_UNICODE_STRING TrustedDomainName,
    /* [in] */ LSA_FOREST_TRUST_RECORD_TYPE HighestRecordType,
    /* [in] */ PLSA_FOREST_TRUST_INFORMATION ForestTrustInfo,
    /* [in] */ BOOLEAN CheckOnly,
    /* [out] */ PLSA_FOREST_TRUST_COLLISION_INFORMATION *CollisionInfo);

NTSTATUS CredrRename( 
    /* [string][unique][in] */ PLSAPR_SERVER_NAME ServerName,
    /* [string][in] */ wchar_t *OldTargetName,
    /* [string][in] */ wchar_t *NewTargetName,
    /* [in] */ ULONG Type,
    /* [in] */ ULONG Flags);

NTSTATUS LsarLookupSids3( 
    /* [in] */ handle_t RpcHandle,
    /* [in] */ PLSAPR_SID_ENUM_BUFFER SidEnumBuffer,
    /* [out] */ PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    /* [out][in] */ PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    /* [in] */ LSAP_LOOKUP_LEVEL LookupLevel,
    /* [out][in] */ PULONG MappedCount,
    /* [in] */ ULONG LookupOptions,
    /* [in] */ ULONG ClientRevision);

NTSTATUS LsarLookupNames4( 
    /* [in] */ handle_t RpcHandle,
    /* [in] */ ULONG Count,
    /* [size_is][in] */ PLSAPR_UNICODE_STRING Names,
    /* [out] */ PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    /* [out][in] */ PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    /* [in] */ LSAP_LOOKUP_LEVEL LookupLevel,
    /* [out][in] */ PULONG MappedCount,
    /* [in] */ ULONG LookupOptions,
    /* [in] */ ULONG ClientRevision);

NTSTATUS LsarOpenPolicySce( 
    /* [unique][in] */ PLSAPR_SERVER_NAME SystemName,
    /* [in] */ PLSAPR_OBJECT_ATTRIBUTES ObjectAttributes,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ LSAPR_HANDLE *PolicyHandle);


extern handle_t IgnoreThisHandle;


extern RPC_IF_HANDLE lsarpc_ClientIfHandle;
extern RPC_IF_HANDLE lsarpc_ServerIfHandle;
#endif /* __lsarpc_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

handle_t __RPC_USER PAUTHZ_AUDIT_EVENT_TYPE_OLD_bind  ( PAUTHZ_AUDIT_EVENT_TYPE_OLD );
void     __RPC_USER PAUTHZ_AUDIT_EVENT_TYPE_OLD_unbind( PAUTHZ_AUDIT_EVENT_TYPE_OLD, handle_t );
handle_t __RPC_USER PLSAPR_SERVER_NAME_bind  ( PLSAPR_SERVER_NAME );
void     __RPC_USER PLSAPR_SERVER_NAME_unbind( PLSAPR_SERVER_NAME, handle_t );

void __RPC_USER AUDIT_HANDLE_rundown( AUDIT_HANDLE );
void __RPC_USER LSAPR_HANDLE_rundown( LSAPR_HANDLE );

void LsarClose_notify( void);

void LsarDelete_notify( void);

void LsarEnumeratePrivileges_notify( void);

void LsarQuerySecurityObject_notify( void);

void LsarSetSecurityObject_notify( void);

void LsarChangePassword_notify( void);

void LsarOpenPolicy_notify( void);

void LsarQueryInformationPolicy_notify( void);

void LsarSetInformationPolicy_notify( void);

void LsarClearAuditLog_notify( void);

void LsarCreateAccount_notify( void);

void LsarEnumerateAccounts_notify( void);

void LsarCreateTrustedDomain_notify( void);

void LsarEnumerateTrustedDomains_notify( void);

void LsarLookupNames_notify( void);

void LsarLookupSids_notify( void);

void LsarCreateSecret_notify( void);

void LsarOpenAccount_notify( void);

void LsarEnumeratePrivilegesAccount_notify( void);

void LsarAddPrivilegesToAccount_notify( void);

void LsarRemovePrivilegesFromAccount_notify( void);

void LsarGetQuotasForAccount_notify( void);

void LsarSetQuotasForAccount_notify( void);

void LsarGetSystemAccessAccount_notify( void);

void LsarSetSystemAccessAccount_notify( void);

void LsarOpenTrustedDomain_notify( void);

void LsarQueryInfoTrustedDomain_notify( void);

void LsarSetInformationTrustedDomain_notify( void);

void LsarOpenSecret_notify( void);

void LsarSetSecret_notify( void);

void LsarQuerySecret_notify( void);

void LsarLookupPrivilegeValue_notify( void);

void LsarLookupPrivilegeName_notify( void);

void LsarLookupPrivilegeDisplayName_notify( void);

void LsarDeleteObject_notify( void);

void LsarEnumerateAccountsWithUserRight_notify( void);

void LsarEnumerateAccountRights_notify( void);

void LsarAddAccountRights_notify( void);

void LsarRemoveAccountRights_notify( void);

void LsarQueryTrustedDomainInfo_notify( void);

void LsarSetTrustedDomainInfo_notify( void);

void LsarDeleteTrustedDomain_notify( void);

void LsarStorePrivateData_notify( void);

void LsarRetrievePrivateData_notify( void);

void LsarOpenPolicy2_notify( void);

void LsarGetUserName_notify( void);

void LsarQueryInformationPolicy2_notify( void);

void LsarSetInformationPolicy2_notify( void);

void LsarQueryTrustedDomainInfoByName_notify( void);

void LsarSetTrustedDomainInfoByName_notify( void);

void LsarEnumerateTrustedDomainsEx_notify( void);

void LsarCreateTrustedDomainEx_notify( void);

void LsarSetPolicyReplicationHandle_notify( void);

void LsarQueryDomainInformationPolicy_notify( void);

void LsarSetDomainInformationPolicy_notify( void);

void LsarOpenTrustedDomainByName_notify( void);


/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\lsaicli.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsaicli.h

Abstract:

    Local Security Authority - Definitions for internal LSA Clients.

    NOTE:  This file is included via lsaclip.h or lsasrvp.h.  It should
           not be included directly.

    This module contains definitions used only when callouts are made
    from one LSA to another, i.e. where the server side of one LSA
    communicates with the client side of another LSA.

Author:

    Scott Birrell       (ScottBi)      April 9, 1992

Environment:

Revision History:

--*/

#ifndef _LSAICLI_
#define _LSAICLI_

//
// The following datatype specifies the Call Level for Sid and Name
// Lookup operations.
//

typedef enum _LSAP_LOOKUP_LEVEL {

    LsapLookupWksta = 1,
    LsapLookupPDC,
    LsapLookupTDL,
    LsapLookupGC,              // valid only on NT5   domain controllers
    LsapLookupXForestReferral, // valid only on NT5.1 domain controllers
    LsapLookupXForestResolve   // valid only on NT5.1 domain controllers

} LSAP_LOOKUP_LEVEL, *PLSAP_LOOKUP_LEVEL;

//
// where the entries have the following meaning:
//
// LsapLookupWksta - First Level Lookup performed on a workstation
//     normally configured for Windows-Nt.   The lookup searches the
//     Well-Known Sids/Names, and the Built-in Domain and Account Domain
//     in the local SAM Database.  If not all Sids or Names are
//     identified, performs a "handoff" of a Second level Lookup to the
//     LSA running on a Controller for the workstation's Primary Domain
//     (if any).
//
// LsapLookupPDC - Second Level Lookup performed on a Primary Domain
//     Controller.  The lookup searches the Account Domain of the
//     SAM Database on the controller.  If not all Sids or Names are
//     found, the Trusted Domain List (TDL) is obtained from the
//     LSA's Policy Database and Third Level lookups are performed
//     via "handoff" to each Trusted Domain in the List.
//
// LsapLookupTDL - Third Level Lookup performed on a controller
//     for a Trusted Domain.  The lookup searches the Account Domain of
//     the SAM Database on the controller only.
//
// LsapLookupGC - This is used by a workstation to perform a lookup at a GC
//     This resolves UPN's, samaccountname's with NetBios and DNS domain names,
//     Sid's and Sid Histories for transitivly trusted domains (within a 
//     forest).  This lookup level is only used when a NT5+ client is in 
//     a mixed domain and its secure channel DC is NT4
//
// LsapLookupXForestReferral -- This is used to pass entries (names and Sids)
//     to the root of the forest via the trust chain.  After a set of entries,
//     comes back from the GC, some may be marked as belonging to a cross
//     forest.  These entries are then passed on to the DC's parent domain until
//     the root of the domain is reached.  The root will then issue a 
//     LsapLookupXForestResolve directed at a DC in the external forest.
//
// LpsaLookupXForestResolve -- This level is used by the root of one forest
//     lookup entries from the DC in another forest.
//

typedef struct _LSA_TRANSLATED_NAME_EX
{
    SID_NAME_USE Use;
    LSA_UNICODE_STRING Name;
    LONG DomainIndex;
    ULONG Flags;

} LSA_TRANSLATED_NAME_EX;

typedef struct _LSA_TRANSLATED_NAME_EX *PLSA_TRANSLATED_NAME_EX;

typedef struct _LSA_TRANSLATED_NAMES
{
    ULONG Entries;
    PLSA_TRANSLATED_NAME_EX Names;

} LSA_TRANSLATED_NAMES_EX;

typedef struct _LSA_TRANSLATED_NAMES *PLSA_TRANSLATED_NAMES_EX;


typedef struct _LSA_TRANSLATED_SID_EX
{
    SID_NAME_USE Use;
    ULONG        RelativeId;
    LONG DomainIndex;
    ULONG Flags;

} LSA_TRANSLATED_SID_EX;

typedef struct _LSA_TRANSLATED_SID_EX *PLSA_TRANSLATED_SID_EX;

typedef struct _LSA_TRANSLATED_SIDS_EX
{
    ULONG Entries;
    PLSA_TRANSLATED_SID_EX Names;

} LSA_TRANSLATED_SIDS_EX;

typedef struct _LSA_TRANSLATED_SIDS_EX *PLSA_TRANSLATED_SIDS_EX;

typedef struct _LSA_TRANSLATED_SID_EX2
{
    SID_NAME_USE Use;
    PSID         Sid;
    LONG         DomainIndex;
    ULONG        Flags;

} LSA_TRANSLATED_SID_EX2;

typedef struct _LSA_TRANSLATED_SID_EX2 *PLSA_TRANSLATED_SID_EX2;

typedef struct _LSA_TRANSLATED_SIDS_EX2
{
    ULONG Entries;
    PLSA_TRANSLATED_SID_EX2 Names;

} LSA_TRANSLATED_SIDS_EX2;

typedef struct _LSA_TRANSLATED_SIDS_EX2 *PLSA_TRANSLATED_SIDS_EX2;

#define LSAIC_NO_LARGE_SID    0x00000001
#define LSAIC_NT4_TARGET      0x00000002
#define LSAIC_WIN2K_TARGET    0x00000004

NTSTATUS
LsaICLookupNames(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG LookupOptions,    
    IN ULONG Count,
    IN PUNICODE_STRING Names,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_SID_EX2 *Sids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN ULONG      Flags,
    IN OUT PULONG MappedCount,
    IN OUT PULONG ServerRevision
    );

/*++

Routine Description:

    This function is the internal client side version of the LsaLookupNames
    API.  It is called both from the client side (as an internal routine)
    and the server side of the LSA.  The function is identical to the
    LsaLookupNames API except that there is an additional parameter, the
    LookupLevel parameter.

    The LsaLookupNames API attempts to translate names of domains, users,
    groups or aliases to Sids.  The caller must have POLICY_LOOKUP_NAMES
    access to the Policy object.

    Names may be either isolated (e.g. JohnH) or composite names containing
    both the domain name and account name.  Composite names must include a
    backslash character separating the domain name from the account name
    (e.g. Acctg\JohnH).  An isolated name may be either an account name
    (user, group, or alias) or a domain name.

    Translation of isolated names introduces the possibility of name
    collisions (since the same name may be used in multiple domains).  An
    isolated name will be translated using the following algorithm:

    If the name is a well-known name (e.g. Local or Interactive), then the
    corresponding well-known Sid is returned.

    If the name is the Built-in Domain's name, then that domain's Sid
    will be returned.

    If the name is the Account Domain's name, then that domain's Sid
    will be returned.

    If the name is the Primary Domain's name, then that domain's Sid will
    be returned.

    If the name is a user, group, or alias in the Built-in Domain, then the
    Sid of that account is returned.

    If the name is a user, group, or alias in the Primary Domain, then the
    Sid of that account is returned.

    Otherwise, the name is not translated.

    NOTE: Proxy, Machine, and Trust user accounts are not referenced
    for name translation.  Only normal user accounts are used for ID
    translation.  If translation of other account types is needed, then
    SAM services should be used directly.

Arguments:

    This function is the LSA server RPC worker routine for the
    LsaLookupNamesInLsa API.

    PolicyHandle -  Handle from an LsaOpenPolicy call.
    
    LookupOptions - values to pass through to LsarLookupNames2 and above.

    Count - Specifies the number of names to be translated.

    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    ReferencedDomains - receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for
        each translated name, this structure will only contain one
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    Sids - Receives a pointer to an array of records describing each
        translated Sid.  The nth entry in this array provides a translation
        for (the nth element in the Names parameter.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

        LsapLookupWksta - First Level Lookup performed on a workstation
            normally configured for Windows-Nt.   The lookup searches the
            Well-Known Sids/Names, and the Built-in Domain and Account Domain
            in the local SAM Database.  If not all Sids or Names are
            identified, performs a "handoff" of a Second level Lookup to the
            LSA running on a Controller for the workstation's Primary Domain
            (if any).

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Sids or Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.
    Flags - flags to control the operation of the function.  Currently defined:
    
            LSAIC_NO_LARGE_SID -- implies only call interfaces that will return
                                  the old style format SID (no more than 
                                  28 bytes)
                        
            LSAIC_NT4_TARGET -- target server is known to be NT4
            
            LSAIC_WIN2K_TARGET -- target server is known to be Win2k
    
Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could
            not be mapped.  This is an informational status only.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.
--*/



NTSTATUS
LsaICLookupSids(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PSID *Sids,
    OUT PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    OUT PLSA_TRANSLATED_NAME_EX *Names,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN ULONG Flags,    
    IN OUT PULONG MappedCount,
    OUT ULONG *ServerRevision OPTIONAL
    );

/*++

Routine Description:

    WARNING! THIS FUNCTION IS NOT COMPLETELY IMPLEMENTED.  ONLY SIDS
    MAPPABLE AT THE LOCAL SYSTEM WILL BE TRANSLATED.

    The LsaLookupSids API attempts to find names corresponding to Sids.
    If a name can not be mapped to a Sid, the Sid is converted to character
    form.  The caller must have POLICY_LOOKUP_NAMES access to the Policy
    object.

    WARNING:  This routine allocates memory for its output.  The caller is
    responsible for freeing this memory after use.  See description of the
    Names parameter.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    Count - Specifies the number of Sids to be translated.

    Sids - Pointer to an array of Count pointers to Sids to be mapped
        to names.  The Sids may be well_known SIDs, SIDs of User accounts
        Group Accounts, Alias accounts, or Domains.

    ReferencedDomains - Receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the strutcure returned via the Names parameter.
        Unlike the Names paraemeter, which contains an array entry
        for (each translated name, this strutcure will only contain
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    Names - Receives a pointer to array records describing each translated
        name.  The nth entry in this array provides a translation for
        the nth entry in the Sids parameter.

        All of the retruned names will be isolated names or NULL strings
        (domain names are returned as NULL strings).  If the caller needs
        composite names, they can be generated by prepending the
        isolated name with the domain name and a backslash.  For example,
        if (the name Sally is returned, and it is from the domain Manufact,
        then the composite name would be "Manufact" + "\" + "Sally" or
        "Manufact\Sally".

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

        If a Sid is not translatable, then the following will occur:

        1) If the SID's domain is known, then a reference domain record
           will be generated with the domain's name.  In this case, the
           name returned via the Names parameter is a Unicode representation
           of the relative ID of the account, such as "(314)" or the null
           string, if the Sid is that of a domain.  So, you might end up
           with a resultant name of "Manufact\(314) for the example with
           Sally above, if Sally's relative id is 314.

        2) If not even the SID's domain could be located, then a full
           Unicode representation of the SID is generated and no domain
           record is referenced.  In this case, the returned string might
           be something like: "(S-1-672194-21-314)".

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

        LsapLookupWksta - First Level Lookup performed on a workstation
            normally configured for Windows-Nt.   The lookup searches the
            Well-Known Sids/Names, and the Built-in Domain and Account Domain
            in the local SAM Database.  If not all Sids or Names are
            identified, performs a "handoff" of a Second level Lookup to the
            LSA running on a Controller for the workstation's Primary Domain
            (if any).

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Sids or Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.
            
    Flags:

            LSAIC_NT4_TARGET -- target server is known to be NT4
            
            LSAIC_WIN2K_TARGET -- target server is known to be Win2k
            
    ServerRevision : the revision of the server that is called            
    
Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_SOME_NOT_MAPPED - Some or all of the names provided could not be
            mapped.  This is a warning only.

        Rest TBS
--*/

#endif // _LSAICLI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\lsass.h ===
/*++

Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    lsass.h

Abstract:

    This is a common header file for all codes that go in lsass.exe (ie
    in security process).

Author:

    Madan Appiah (madana) 23-Mar-1993

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#ifndef _LSASS_
#define _LSASS_

//
// DON'T USE the following LARGE_INTEGER definitions. These definitions
// are used only by few old RPC code for compatibilty reason.
//

typedef struct _OLD_LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} OLD_LARGE_INTEGER, *POLD_LARGE_INTEGER;

#define OLD_TO_NEW_LARGE_INTEGER(Old, New) { \
    (New).LowPart = (Old).LowPart; \
    (New).HighPart = (Old).HighPart; \
    }

#define NEW_TO_OLD_LARGE_INTEGER(New, Old) { \
    (Old).LowPart = (New).LowPart; \
    (Old).HighPart = (New).HighPart; \
    }

#endif // _LSASS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\martaexp.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:        MARTAEXP.HXX
//
//  Contents:    Function definitions for exported helper functions
//
//  History:     06-Sep-96      MacM        Created
//
//--------------------------------------------------------------------
#ifndef __MARTAEXP_HXX__
#define __MARTAEXP_HXX__

extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
}

typedef enum _MARTA_KERNEL_TYPE
{
    MARTA_UNKNOWN = 0,
    MARTA_EVENT,
    MARTA_EVENT_PAIR,
    MARTA_MUTANT,
    MARTA_PROCESS,
    MARTA_SECTION,
    MARTA_SEMAPHORE,
    MARTA_SYMBOLIC_LINK,
    MARTA_THREAD,
    MARTA_TIMER,
    MARTA_JOB,
    MARTA_WMI_GUID

} MARTA_KERNEL_TYPE, *PMARTA_KERNEL_TYPE;


//
// Determines whether a bit flag is turned on or not
//
#define FLAG_ON(flags,bit)        ((flags) & (bit))

//
// This macro will return the size, in bytes, of a buffer needed to hold
// the given string
//
#define SIZE_PWSTR(wsz) (wsz == NULL ? 0 : (wcslen(wsz) + 1) * sizeof(WCHAR))

//
// This macro will copy the specified string to the new destination, after
// allocating a buffer of sufficient size
//
#define ACC_ALLOC_AND_COPY_STRINGW(OldString, NewString, err)           \
NewString = (PWSTR)AccAlloc(SIZE_PWSTR(OldString));                     \
if(NewString == NULL)                                                   \
{                                                                       \
    err = ERROR_NOT_ENOUGH_MEMORY;                                      \
}                                                                       \
else                                                                    \
{                                                                       \
    wcscpy((PWSTR)NewString,                                            \
           OldString);                                                  \
}

//
// Flags to pass in to AccConvertAccessToSD
//
#define ACCCONVERT_SELF_RELATIVE        0x00000001
#define ACCCONVERT_DS_FORMAT            0x00000002


//+-------------------------------------------------------------------------
// helper.cxx
//+-------------------------------------------------------------------------
ULONG
TrusteeAllocationSize(IN PTRUSTEE_W pTrustee);

ULONG
TrusteeAllocationSizeWToA(IN PTRUSTEE_W pTrustee);

ULONG
TrusteeAllocationSizeAToW(IN PTRUSTEE_A pTrustee);

VOID
SpecialCopyTrustee(VOID **pStuffPtr, PTRUSTEE pToTrustee, PTRUSTEE pFromTrustee);

DWORD
CopyTrusteeAToTrusteeW( IN OUT VOID     ** ppStuffPtr,
                        IN     PTRUSTEE_A  pFromTrusteeA,
                        OUT    PTRUSTEE_W  pToTrusteeW );

DWORD
CopyTrusteeWToTrusteeA( IN OUT VOID    ** ppStuffPtr,
                        IN     PTRUSTEE_W pFromTrusteeW,
                        OUT    PTRUSTEE_A pToTrusteeA );

DWORD
ExplicitAccessAToExplicitAccessW( IN  ULONG                cCountAccesses,
                                  IN  PEXPLICIT_ACCESS_A   paAccess,
                                  OUT PEXPLICIT_ACCESS_W * ppwAccess );

DWORD
ExplicitAccessWToExplicitAccessA( IN  ULONG                cCountAccesses,
                                  IN  PEXPLICIT_ACCESS_W   pwAccess,
                                  OUT PEXPLICIT_ACCESS_A * ppaAccess );


DWORD
DoTrusteesMatch(PWSTR       pwszServer,
                PTRUSTEE    pTrustee1,
                PTRUSTEE    pTrustee2,
                PBOOL       pfMatch);


//+-------------------------------------------------------------------------
// aclutil.cxx
//+-------------------------------------------------------------------------
extern "C"
{
DWORD
AccGetSidFromToken(PWSTR                    pwszServer,
                   HANDLE                   hToken,
                   TOKEN_INFORMATION_CLASS  TIC,
                   PSID                    *ppSidFromToken);

DWORD
AccLookupAccountSid(IN  PWSTR          pwszServer,
                    IN  PTRUSTEE        pName,
                    OUT PSID           *ppsid,
                    OUT SID_NAME_USE   *pSidType);

DWORD
AccLookupAccountTrustee(IN  PWSTR          pwszServer,
                        IN  PSID        psid,
                        OUT PTRUSTEE   *ppTrustee);

DWORD
AccLookupAccountName(IN  PWSTR          pwszServer,
                     IN  PSID           pSid,
                     OUT LPWSTR        *ppwszName,
                     OUT LPWSTR        *ppwszDomain,
                     OUT SID_NAME_USE  *pSidType);

DWORD
AccSetEntriesInAList(IN  ULONG                 cEntries,
                     IN  PACTRL_ACCESS_ENTRYW  pAccessEntryList,
                     IN  ACCESS_MODE           AccessMode,
                     IN  SECURITY_INFORMATION  SeInfo,
                     IN  LPCWSTR               lpProperty,
                     IN  BOOL                  fDoOldStyleMerge,
                     IN  PACTRL_AUDITW         pOldList,
                     OUT PACTRL_AUDITW        *ppNewList);

DWORD
AccConvertAccessToSecurityDescriptor(IN  PACTRL_ACCESSW        pAccessList,
                                     IN  PACTRL_AUDITW         pAuditList,
                                     IN  LPCWSTR               lpOwner,
                                     IN  LPCWSTR               lpGroup,
                                     OUT PSECURITY_DESCRIPTOR *ppSecDescriptor);

DWORD
AccConvertSDToAccess(IN  SE_OBJECT_TYPE       ObjectType,
                     IN  PSECURITY_DESCRIPTOR pSecDescriptor,
                     OUT PACTRL_ACCESSW      *ppAccessList,
                     OUT PACTRL_AUDITW       *ppAuditList,
                     OUT LPWSTR              *lppOwner,
                     OUT LPWSTR              *lppGroup);

DWORD
AccConvertAccessToSD(IN  SE_OBJECT_TYPE         ObjectType,
                     IN  SECURITY_INFORMATION   SeInfo,
                     IN  PACTRL_ACCESSW         pAccessList,
                     IN  PACTRL_AUDITW          pAuditList,
                     IN  LPWSTR                 lpOwner,
                     IN  LPWSTR                 lpGroup,
                     IN  ULONG                  fOpts,
                     OUT PSECURITY_DESCRIPTOR  *ppSD,
                     OUT PULONG                 pcSDSize);


DWORD
AccGetAccessForTrustee(IN  PTRUSTEE                 pTrustee,
                       IN  PACL                     pAcl,
                       IN  SECURITY_INFORMATION     SeInfo,
                       IN  PWSTR                    pwszProperty,
                       OUT PACCESS_RIGHTS           pAllowed,
                       OUT PACCESS_RIGHTS           pDenied);

DWORD
AccConvertAclToAccess(IN  SE_OBJECT_TYPE       ObjectType,
                      IN  PACL                 pAcl,
                      OUT PACTRL_ACCESSW      *ppAccessList);

DWORD
AccGetExplicitEntries(IN  PTRUSTEE              pTrustee,
                      IN  SE_OBJECT_TYPE        ObjectType,
                      IN  PACL                  pAcl,
                      IN  PWSTR                 pwszProperty,
                      OUT PULONG                pcEntries,
                      OUT PACTRL_ACCESS_ENTRYW *ppAEList);

VOID
AccConvertAccessMaskToActrlAccess(IN  ACCESS_MASK          Access,
                                  IN  SE_OBJECT_TYPE       ObjType,
                                  IN  MARTA_KERNEL_TYPE    KernelObjectType,
                                  IN  PACTRL_ACCESS_ENTRY  pAE);
}


typedef struct _CSLIST_NODE
{
    PVOID       pvData;
    struct _CSLIST_NODE *pNext;
} CSLIST_NODE, *PCSLIST_NODE;

#define LIST_INLINE
#ifdef LIST_INLINE
#define LINLINE inline
#else
#define LINLINE
#endif

//
// Free function callback typedef.  This function will delete the memory saved
// as the data in a list node on list destruction
//
typedef VOID (*FreeFunc)(PVOID);

//
// This function returns TRUE if the two items are the same, or FALSE if they
// are not
//
typedef BOOL (*CompFunc)(PVOID, PVOID);

//+---------------------------------------------------------------------------
//
// Class:       CSList
//
// Synopsis:    Singly linked list class, single threaded
//
// Methods:     Insert
//              InsertIfUnique
//              Find
//              Reset
//              NextData
//              Remove
//              QueryCount
//
//----------------------------------------------------------------------------
class CSList
{
public:
                    CSList(FreeFunc pfnFree = NULL) :  _pfnFree (pfnFree),
                                                       _pCurrent (NULL),
                                                       _cItems (0)
                    {
                        _pHead = NULL;
                        _pTail = NULL;
                    };

    LINLINE        ~CSList();

    DWORD           QueryCount(void)         { return(_cItems);};

    VOID            Init(FreeFunc pfnFree = NULL)
                    {
                        if(_pHead == NULL)
                        {
                            _pfnFree = pfnFree;
                            _pCurrent = NULL;
                            _cItems = 0;
                        }
                    };

    LINLINE DWORD   Insert(PVOID    pvData);

    LINLINE DWORD   InsertIfUnique(PVOID    pvData,
                                   CompFunc pfnComp);

    LINLINE PVOID   Find(PVOID      pvData,
                         CompFunc   pfnComp);

    LINLINE PVOID   NextData();

    VOID            Reset() {_pCurrent = _pHead;};

    LINLINE DWORD   Remove(PVOID    pData);

    LINLINE VOID    FreeList(FreeFunc pfnFree);
protected:
    PCSLIST_NODE    _pHead;
    PCSLIST_NODE    _pCurrent;
    PCSLIST_NODE    _pTail;
    DWORD           _cItems;
    FreeFunc        _pfnFree;

    LINLINE PCSLIST_NODE FindNode(PVOID      pvData,
                                  CompFunc   pfnComp);

};



//+------------------------------------------------------------------
//
//  Member:     CSList::~CSList
//
//  Synopsis:   Destructor for the CSList class
//
//  Arguments:  None
//
//  Returns:    void
//
//+------------------------------------------------------------------
CSList::~CSList()
{
    while(_pHead != NULL)
    {
        PCSLIST_NODE pNext = _pHead->pNext;

        if(_pfnFree != NULL)
        {
            (*_pfnFree)(_pHead->pvData);
        }

        LocalFree(_pHead);

        _pHead = pNext;

    }
}




//+------------------------------------------------------------------
//
//  Member:     CSList::Insert
//
//  Synopsis:   Creates a new node at the begining of the list and
//              inserts it into the list
//
//
//  Arguments:  [IN pvData]         --      Data to insert
//
//  Returns:    ERROR_SUCCESS       --      Everything worked
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//+------------------------------------------------------------------
DWORD   CSList::Insert(PVOID    pvData)
{
    DWORD dwErr = ERROR_SUCCESS;

    PCSLIST_NODE    pNew = (PCSLIST_NODE)LocalAlloc(LMEM_FIXED, sizeof(CSLIST_NODE));
    if(pNew == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        pNew->pvData = pvData;

        pNew->pNext = NULL;

        if ( _pHead == NULL ) {

            _pHead = _pTail = pNew;

        } else {

            _pTail->pNext = pNew;
            _pTail = pNew;
        }

        _cItems++;
    }

    return(dwErr);
}




//+------------------------------------------------------------------
//
//  Member:     CSList::InsertIfUnique
//
//  Synopsis:   Creates a new node at the begining of the list and
//              inserts it into the list if the data does not already
//              exist in the list.  If the data does exist, nothing
//              is done, but SUCCESS is returned
//
//
//  Arguments:  [IN pvData]         --      Data to insert
//
//  Returns:    ERROR_SUCCESS       --      Everything worked
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//+------------------------------------------------------------------
DWORD   CSList::InsertIfUnique(PVOID    pvData,
                               CompFunc pfnComp)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if(FindNode(pvData, pfnComp) == NULL)
    {
        dwErr = Insert(pvData);
    }

    return(dwErr);
}




//+------------------------------------------------------------------
//
//  Member:     CSList::FindNode
//
//  Synopsis:   Locates the node for the given data in the list, if it exists
//
//  Arguments:  [IN pvData]         --      Data to find
//              [IN pfnComp]        --      Pointer to a comparrison function
//
//  Returns:    ERROR_SUCCESS       --      Everything worked
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//+------------------------------------------------------------------
PCSLIST_NODE   CSList::FindNode(PVOID      pvData,
                                CompFunc   pfnComp)
{
    PCSLIST_NODE pRet = _pHead;

    // for(ULONG i = 0; i < _cItems; i++)
    while (pRet != NULL)
    {
        if((pfnComp)(pvData, pRet->pvData) == TRUE)
        {
            break;
        }

        pRet = pRet->pNext;
    }

    return(pRet);
}



//+------------------------------------------------------------------
//
//  Member:     CSList::Find
//
//  Synopsis:   Locates the given data in the list, if it exists
//
//  Arguments:  [IN pvData]         --      Data to insert
//
//  Returns:    ERROR_SUCCESS       --      Everything worked
//              ERROR_NOT_ENOUGH_MEMORY     A memory allocation failed
//
//+------------------------------------------------------------------
PVOID   CSList::Find(PVOID      pvData,
                     CompFunc   pfnComp)
{
    PCSLIST_NODE pNode = FindNode(pvData, pfnComp);

    return(pNode == NULL ? NULL : pNode->pvData);
}





//+------------------------------------------------------------------
//
//  Member:     CSList::NextData
//
//  Synopsis:   Returns the next data in the list
//
//
//  Arguments:  None
//
//  Returns:    NULL            --      No more items
//              Pointer to next data in list on success
//
//+------------------------------------------------------------------
PVOID   CSList::NextData()
{
    PVOID   pvRet = NULL;
    if(_pCurrent != NULL)
    {
        pvRet = _pCurrent->pvData;
        _pCurrent = _pCurrent->pNext;
    }

    return(pvRet);
}




//+------------------------------------------------------------------
//
//  Member:     CSList::Remove
//
//  Synopsis:   Removes the node that references the indicated data
//
//  Arguments:  pData           --      The data in the node to remove
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_INVALID_PARAMETER Node not found
//
//+------------------------------------------------------------------
DWORD   CSList::Remove(PVOID    pData)
{
    DWORD        dwErr = ERROR_INVALID_PARAMETER;
    PCSLIST_NODE pNode = _pHead, pPrev = NULL;

    for(ULONG i = 0; i  < _cItems; i++)
    {
        if(pNode->pvData == pData)
        {
            //
            // We've got a match...
            //
            if(pPrev == NULL)
            {
                _pHead = _pHead->pNext;
            }
            else
            {
                pPrev->pNext = pNode->pNext;
            }

            if (NULL == pNode->pNext)
            {
                _pTail = pPrev;
            }

            LocalFree(pNode);
            _cItems--;
            break;

        }

        pPrev = pNode;
        pNode = pNode->pNext;

    }

    return(dwErr);
}


//+------------------------------------------------------------------
//
//  Member:     CSList::FreeList
//
//  Synopsis:   Frees the list
//
//  Arguments:  pfnFree -- Optional deletion routine to use for freeing
//              any allocated memory
//
//  Returns:    void
//
//+------------------------------------------------------------------
VOID CSList::FreeList(FreeFunc pfnFree)
{
    while(_pHead != NULL)
    {
        PCSLIST_NODE pNext = _pHead->pNext;

        if(pfnFree != NULL)
        {
            (*pfnFree)(_pHead->pvData);
        }

        LocalFree(_pHead);

        _pHead = pNext;

    }
}



//
// Exported functions pointer definitions
//
typedef DWORD   (*pfNTMartaLookupTrustee) (PWSTR          pwszServer,
                                           PSID        pSid,
                                           PTRUSTEE   *ppTrustee);

typedef DWORD   (*pfNTMartaLookupName)     (PWSTR          pwszServer,
                                            PSID           pSid,
                                            LPWSTR        *ppwszName,
                                            LPWSTR        *ppwszDomain,
                                            SID_NAME_USE  *pSidType);

typedef DWORD   (*pfNTMartaLookupSid)  (PWSTR          pwszServer,
                                        PTRUSTEE        pName,
                                        PSID           *ppsid,
                                        SID_NAME_USE   *pSidType);

typedef DWORD   (*pfNTMartaSetAList) (ULONG                 cEntries,
                                      PACTRL_ACCESS_ENTRYW  pAccessEntryList,
                                      ACCESS_MODE           AccessMode,
                                      SECURITY_INFORMATION  SeInfo,
                                      LPCWSTR               lpProperty,
                                      BOOL                  fDoOldStyleMerge,
                                      PACTRL_AUDITW         pOldList,
                                      PACTRL_AUDITW        *ppNewList);

typedef DWORD   (*pfNTMartaAToSD) (PACTRL_ACCESSW        pAccessList,
                                   PACTRL_AUDITW         pAuditList,
                                   LPCWSTR               lpOwner,
                                   LPCWSTR               lpGroup,
                                   PSECURITY_DESCRIPTOR *ppSecDescriptor);


typedef DWORD   (*pfNTMartaSDToA) (SE_OBJECT_TYPE       ObjectType,
                                   PSECURITY_DESCRIPTOR pSecDescriptor,
                                   PACTRL_ACCESSW      *ppAccessList,
                                   PACTRL_AUDITW       *ppAuditList,
                                   LPWSTR              *lppOwner,
                                   LPWSTR              *lppGroup);

typedef DWORD   (*pfNTMartaAclToA)(SE_OBJECT_TYPE       ObjectType,
                                   PACL                 pAcl,
                                   PACTRL_ACCESSW      *ppAccessList);


typedef DWORD   (*pfNTMartaGetAccess) (PTRUSTEE                 pTrustee,
                                       PACL                     pAcl,
                                       SECURITY_INFORMATION     SeInfo,
                                       PWSTR                    pwszProperty,
                                       PACCESS_RIGHTS           pAllowed,
                                       PACCESS_RIGHTS           pDenied);

typedef DWORD   (*pfNTMartaGetExplicit)(PTRUSTEE              pTrustee,
                                        SE_OBJECT_TYPE        ObjectType,
                                        PACL                  pAcl,
                                        PWSTR                 pwszProperty,
                                        PULONG                pcEntries,
                                        PACTRL_ACCESS_ENTRYW *ppAEList);
typedef VOID (*FN_PROGRESS) (
    IN LPWSTR                   pObjectName,    // name of object just processed
    IN DWORD                    Status,         // status of operation on object
    IN OUT PPROG_INVOKE_SETTING pInvokeSetting, // Never, always,
    IN PVOID                    Args,           // Caller specific data
    IN BOOL                     SecuritySet     // Whether security was set
    );

typedef DWORD   (*pfNTMartaTreeResetNamedSecurityInfo) (
    IN LPWSTR               pObjectName,
    IN SE_OBJECT_TYPE       ObjectType,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSID                 pOwner,
    IN PSID                 pGroup,
    IN PACL                 pDacl,
    IN PACL                 pSacl,
    IN BOOL                 KeepExplicit,
    IN FN_PROGRESS          fnProgress,
    IN PROG_INVOKE_SETTING  ProgressInvokeSetting,
    IN PVOID                Args
    );

// typedef PVOID PFN_OBJECT_MGR_FUNCTS;

typedef DWORD   (*pfNTMartaGetInheritanceSource) (
    IN  LPWSTR                   pObjectName,
    IN  SE_OBJECT_TYPE           ObjectType,
    IN  SECURITY_INFORMATION     SecurityInfo,
    IN  BOOL                     Container,
    IN  GUID                  ** pObjectClassGuids OPTIONAL,
    IN  DWORD                    GuidCount,
    IN  PACL                     pAcl,
    IN  PGENERIC_MAPPING         pGenericMapping,
    IN  PFN_OBJECT_MGR_FUNCTS    pfnArray OPTIONAL,
    OUT PINHERITED_FROMW         pInheritArray
    );

typedef DWORD (*PFN_FREE) (IN PVOID Mem);

typedef DWORD   (*pfNTMartaFreeIndexArray) (
    IN OUT PINHERITED_FROMW pInheritArray,
    IN USHORT AceCnt,
    IN PFN_FREE pfnFree OPTIONAL
    );
    
typedef DWORD   (*pfNTMartaGetNamedRights) (
    IN  LPWSTR                 pObjectName,
    IN  SE_OBJECT_TYPE         ObjectType,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor);

typedef DWORD   (*pfNTMartaSetNamedRights) (
    IN LPWSTR               pObjectName,
    IN SE_OBJECT_TYPE       ObjectType,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN BOOL                 bSkipInheritanceComputation
    );

typedef DWORD   (*pfNTMartaGetHandleRights) (
    IN  HANDLE                 Handle,
    IN  SE_OBJECT_TYPE         ObjectType,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor);

typedef DWORD   (*pfNTMartaSetHandleRights) (
    IN HANDLE               Handle,
    IN SE_OBJECT_TYPE       ObjectType,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

typedef DWORD   (*pfNTMartaSetEntriesInAcl) (
    IN  ULONG                cCountOfExplicitEntries,
    IN  PEXPLICIT_ACCESS_W   pListOfExplicitEntries,
    IN  PACL                 OldAcl,
    OUT PACL               * pNewAcl
    );

typedef DWORD   (*pfNTMartaGetExplicitEntriesFromAcl) (
    IN  PACL                  pacl,
    OUT PULONG                pcCountOfExplicitEntries,
    OUT PEXPLICIT_ACCESS_W  * pListOfExplicitEntries
    );

#endif // ifdef __MARTAEXP_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\marta.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       MARTA.H
//
//  Contents:   Private definitions and function prototypes used by the
//              access control APIs to handle the provider independence
//
//  History:    19-Jun-96       MacM        Created
//
//--------------------------------------------------------------------
#ifndef __MARTA_H__
#define __MARTA_H__

#include <accprov.h>

//
// List of entry points for the provider DLL functions
//
#define ACC_PROV_GET_CAPS       "AccProvGetCapabilities"
#define ACC_PROV_OBJ_ACCESS     "AccProvIsObjectAccessible"
#define ACC_PROV_GRANT_ACCESS   "AccProvGrantAccessRights"
#define ACC_PROV_SET_ACCESS     "AccProvSetAccessRights"
#define ACC_PROV_REVOKE_ACCESS  "AccProvRevokeAccessRights"
#define ACC_PROV_REVOKE_AUDIT   "AccProvRevokeAuditRights"
#define ACC_PROV_GET_ALL        "AccProvGetAllRights"
#define ACC_PROV_ACCESS         "AccProvGetTrusteesAccess"
#define ACC_PROV_AUDIT          "AccProvIsAccessAudited"
#define ACC_PROV_OBJ_INFO       "AccProvGetAccessInfoPerObjectType"
#define ACC_PROV_CANCEL         "AccProvCancelOperation"
#define ACC_PROV_GET_RESULTS    "AccProvGetOperationResults"

#define ACC_PROV_HOBJ_ACCESS    "AccProvHandleIsObjectAccessible"
#define ACC_PROV_HGRANT_ACCESS  "AccProvHandleGrantAccessRights"
#define ACC_PROV_HSET_ACCESS    "AccProvHandleSetAccessRights"
#define ACC_PROV_HREVOKE_ACCESS "AccProvHandleRevokeAccessRights"
#define ACC_PROV_HREVOKE_AUDIT  "AccProvHandleRevokeAuditRights"
#define ACC_PROV_HGET_ALL       "AccProvHandleGetAllRights"
#define ACC_PROV_HACCESS        "AccProvHandleGetTrusteesAccess"
#define ACC_PROV_HAUDIT         "AccProvHandleIsAccessAudited"
#define ACC_PROV_HOBJ_INFO      "AccProvHandleGetAccessInfoPerObjectType"


//
// Registry keys that hold the provider information
//
#define ACC_PROV_REG_ROOT                                                   \
                L"System\\CurrentControlSet\\Control\\LSA\\AccessProviders"
#define ACC_PROV_REG_ORDER  L"ProviderOrder"
#define ACC_PROV_REG_UNIQUE L"RequireUniqueAccessibility"
#define ACC_PROV_REG_PATH   L"ProviderPath"


//
// Flags used to control the provider state
//
#define ACC_PROV_PROV_OK        0x00000001
#define ACC_PROV_PROV_FAILED    0x00000000

//
// Indicates that the RequireUniqueAccessibility flag was present
//
#define ACC_PROV_REQ_UNIQUE         0x00000001

//
// Indicates that the providers have been loaded
//
#define ACC_PROV_PROVIDERS_LOADED   0x00000002

//
// This structure is what contains all of the required information about
// each of the providers
//
typedef struct _ACCPROV_PROV_INFO
{
    PWSTR               pwszProviderName;   // "Friendly" name of the provider
    PWSTR               pwszProviderPath;   // DLL path name.  Null after
                                            // module loaded
    HMODULE             hDll;               // Module handle of the DLL
                                            // after being loaded
    ULONG               fProviderCaps;      // Provider capabilities
    ULONG               fProviderState;     // Current state of the provider

    //
    // The following is the function table used to call the provider
    // functions
    //

    //
    // General functions
    //
    pfAccProvObjAccess          pfObjAccess;    // AccProvIsObjectAccessible
    pfAccProvHandleObjAccess    pfhObjAccess;   // AccProvHandleIsObjectAccessible
    pfAccProvCancelOp           pfCancel;       // AccProvCancelOperation
    pfAccProvGetResults         pfResults;      // AccProvGetOperationResults

    //
    // Required path based functions
    //
    pfAccProvAddRights      pfGrantAccess;  // AccProvGrantAccessRights
    pfAccProvSetRights      pfSetAccess;    // AccProvSetAccessRights
    pfAccProvRevoke         pfRevokeAccess; // AccProvRevokeAccessRights
    pfAccProvRevoke         pfRevokeAudit;  // AccProvRevokeAuditRights
    pfAccProvGetRights      pfGetRights;    // AccProvGetAllRights
    pfAccProvTrusteeAccess  pfTrusteeAccess;// AccProvGetTrusteesAccess
    pfAccProvAccessAudit    pfAudit;        // AccProvIsAccessAudited
    pfAccProvGetObjTypeInfo pfObjInfo;      // AccProvGetAccessInfoPerObjectType

    //
    // Optional, handle based functions
    //
    pfAccProvHandleAddRights      pfhGrantAccess;  // AccProvHandleGrantAccessRights
    pfAccProvHandleSetRights      pfhSetAccess;    // AccProvHandleSetAccessRights
    pfAccProvHandleRevoke         pfhRevokeAccess; // AccProvHandleRevokeAccessRights
    pfAccProvHandleRevoke         pfhRevokeAudit;  // AccProvHandleRevokeAuditRights
    pfAccProvHandleGetRights      pfhGetRights;    // AccProvHandleGetAllRights
    pfAccProvHandleTrusteeAccess  pfhTrusteeAccess;// AccProvHandleGetTrusteesAccess
    pfAccProvHandleAccessAudit    pfhAudit;        // AccProvHandleIsAccessAudited
    pfAccProvHandleGetObjTypeInfo pfhObjInfo;      // AccProvHandleGetAccessInfoPerObjectType
} ACCPROV_PROV_INFO, *PACCPROV_PROV_INFO;


//
// This structure contains all of the information about the availible security
// providers
//
typedef struct _ACCPROV_PROVIDERS
{
    CRITICAL_SECTION    ProviderLoadLock;   // Lock the provider list during load time
    ULONG               fOptions;           // Various provider options
    ULONG               cProviders;         // Number of providers;
    PACCPROV_PROV_INFO  pProvList;          // Actual list of providers
} ACCPROV_PROVIDERS, *PACCPROV_PROVIDERS;


extern ACCPROV_PROVIDERS gAccProviders;

//
// Allocates the provider list
//
DWORD
AccProvpAllocateProviderList(IN OUT PACCPROV_PROVIDERS  pProviders);

//
// Frees a provider list
//
VOID
AccProvpFreeProviderList(IN  PACCPROV_PROVIDERS  pProviders);

//
// Gets the capabilities of the given provider
//
DWORD
AccProvpGetProviderCapabilities(IN  PACCPROV_PROV_INFO  pProvInfo);

//
// Loads a provider definition from the registry
//
DWORD
AccProvpLoadProviderDef(IN  HKEY                hkReg,
                        IN  PWSTR               pwszNextProv,
                        OUT PACCPROV_PROV_INFO  pProvInfo);

//
// Initializes the list of providers
//
DWORD
AccProvpInitProviders(IN OUT PACCPROV_PROVIDERS  pProviders);

//
// Loads the NTMARTA.DLL functions
//
DWORD
AccProvpLoadMartaFunctions();

BOOL
MartaInitialize();

BOOL
MartaDllInitialize(IN   HINSTANCE   hMod,
                   IN   DWORD       dwReason,
                   IN   PVOID       pvReserved);

//
// Unloads any loaded DLLs
//
VOID
AccProvUnload();

//
// Determines the provider for an object
//
DWORD
AccProvpProbeProviderForObject(IN   PWSTR               pwszObject,
                               IN   HANDLE              hObject,
                               IN   SE_OBJECT_TYPE      ObjectType,
                               IN   PACCPROV_PROVIDERS  pProviders,
                               OUT  PACCPROV_PROV_INFO *ppProvider);

//
// Determines which provider should handle a request...
//
DWORD
AccProvpGetProviderForPath(IN  PCWSTR              pcwszObject,
                           IN  SE_OBJECT_TYPE      ObjectType,
                           IN  PCWSTR              pcwszProvider,
                           IN  PACCPROV_PROVIDERS  pProviders,
                           OUT PACCPROV_PROV_INFO *ppProvider);

DWORD
AccProvpGetProviderForHandle(IN  HANDLE              hObject,
                             IN  SE_OBJECT_TYPE      ObjectType,
                             IN  PCWSTR              pcwszProvider,
                             IN  PACCPROV_PROVIDERS  pProviders,
                             OUT PACCPROV_PROV_INFO *ppProvider);


//
// Macro to load a function pointer from a DLL
//
#define LOAD_ENTRYPT(ptr, typ, dll, str)            \
ptr = (typ)GetProcAddress(dll, str);                \
if(ptr == NULL)                                     \
{                                                   \
    goto Error;                                     \
}



#endif // ifndef __MARTA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\msginaexports.h ===
//  --------------------------------------------------------------------------
//  Module Name: MSGinaExports.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Private exported functions (by ordinal) from msgina for personal SKU
//  functionality.
//
//  History:    2000-02-04  vtan        created
//              2000-02-28  vtan        added ShellIsFriendlyUIActive
//              2000-02-29  vtan        added ShellIsSingleUserNoPassword
//              2000-03-02  vtan        added ShellIsMultipleUsersEnabled
//              2000-04-27  vtan        added ShellTurnOffDialog
//              2000-04-27  vtan        added ShellACPIPowerButtonPressed
//              2000-05-03  vtan        added ShellStatusHostBegin
//              2000-05-03  vtan        added ShellStatusHostEnd
//              2000-05-04  vtan        added ShellSwitchWhenInteractiveReady
//              2000-05-18  vtan        added ShellDimScreen
//              2000-06-02  vtan        added ShellInstallAccountFilterData
//              2000-07-14  vtan        added ShellStatusHostShuttingDown
//              2000-07-27  vtan        added ShellIsSuspendAllowed
//              2000-07-31  vtan        added ShellEnableMultipleUsers
//              2000-07-31  vtan        added ShellEnableRemoteConnections
//              2000-08-01  vtan        added ShellEnableFriendlyUI
//              2000-08-01  vtan        added ShellIsRemoteConnectionsEnabled
//              2000-08-03  vtan        added ShellSwitchUser
//              2000-08-09  vtan        added ShellNotifyThemeUserChange
//              2000-08-14  vtan        added ShellIsUserInteractiveLogonAllowed
//              2000-08-15  vtan        moved to internally published header
//              2000-10-13  vtan        added ShellStartThemeServer
//              2000-10-17  vtan        added ShellStopThemeServer
//              2000-11-30  vtan        removed ShellStartThemeServer
//              2000-11-30  vtan        removed ShellStopThemeServer
//              2001-01-11  vtan        added stub functions for imp library
//              2001-01-11  vtan        added ShellReturnToWelcome
//              2001-01-31  vtan        added ShellStatusHostPowerEvent
//              2001-04-03  vtan        added ShellStartCredentialServer
//              2001-04-04  vtan        added ShellAcquireLogonMutex
//              2001-04-04  vtan        added ShellReleaseLogonMutex
//              2001-04-06  vtan        added ShellSignalShutdown
//              2001-04-12  vtan        added ShellStatusHostHide
//              2001-04-12  vtan        added ShellStatusHostShow
//  --------------------------------------------------------------------------

#ifndef     _MSGinaExports_
#define     _MSGinaExports_

#if !defined(_MSGINA_)
#define MSGINAAPI             DECLSPEC_IMPORT
#define GINASTDAPI_(type)     EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#define GINASTDAPI            EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#else
#define MSGINAAPI             
#define GINASTDAPI_(type)     STDAPI_(type)
#define GINASTDAPI            STDAPI
#endif

#include <unknwn.h>

typedef enum _USERLOGTYPE
{
    ULT_LOGON,              //  User log on 
    ULT_LOGOFF,             //  User log off
    ULT_TSRECONNECT,        //  Terminal server reconnect
    ULT_STARTSHELL,         //  About to start the Shell
} USERLOGTYPE;

typedef enum _SWITCHTYPE
{
    SWITCHTYPE_CREATE,      //  Create the switch event and sync event
    SWITCHTYPE_REGISTER,    //  Check the switch event and register wait
    SWITCHTYPE_CANCEL,      //  Cancel the wait and clean up
} SWITCHTYPE;

#define SZ_INTERACTIVE_LOGON_MUTEX_NAME             TEXT("Global\\msgina: InteractiveLogonMutex")
#define SZ_INTERACTIVE_LOGON_REQUEST_MUTEX_NAME     TEXT("Global\\msgina: InteractiveLogonRequestMutex")
#define SZ_INTERACTIVE_LOGON_REPLY_EVENT_NAME       TEXT("Global\\msgina: InteractiveLogonReplyEvent")
#define SZ_SHUT_DOWN_EVENT_NAME                     TEXT("Global\\msgina: ShutdownEvent")

#ifdef      _MSGINA_

//  --------------------------------------------------------------------------
//  This section contains declarations in the DS component of msgina used by
//  the shell component of msgina.
//  --------------------------------------------------------------------------

//  These are GINA internal dialog return codes.

#define MSGINA_DLG_FAILURE                  IDCANCEL
#define MSGINA_DLG_SUCCESS                  IDOK

#define MSGINA_DLG_INTERRUPTED              0x10000000

//  Our own return codes. These should *Not* conflict with the
//  GINA defined ones.

#define MSGINA_DLG_LOCK_WORKSTATION         110
#define MSGINA_DLG_INPUT_TIMEOUT            111
#define MSGINA_DLG_SCREEN_SAVER_TIMEOUT     112
#define MSGINA_DLG_USER_LOGOFF              113
#define MSGINA_DLG_TASKLIST                 114
#define MSGINA_DLG_SHUTDOWN                 115
#define MSGINA_DLG_FORCE_LOGOFF             116
#define MSGINA_DLG_DISCONNECT               117
#define MSGINA_DLG_SWITCH_CONSOLE           118
#define MSGINA_DLG_SWITCH_FAILURE           119
#define MSGINA_DLG_SMARTCARD_INSERTED       120
#define MSGINA_DLG_SMARTCARD_REMOVED        121

//  Additional flags that can be added to the
//  MSGINA_DLG_USER_LOGOFF return code.

#define MSGINA_DLG_SHUTDOWN_FLAG            0x8000
#define MSGINA_DLG_REBOOT_FLAG              0x4000
#define MSGINA_DLG_SYSTEM_FLAG              0x2000  //  System process was initiator
#define MSGINA_DLG_POWEROFF_FLAG            0x1000  //  Poweroff after shutdown
#define MSGINA_DLG_SLEEP_FLAG               0x0800
#define MSGINA_DLG_SLEEP2_FLAG              0x0400
#define MSGINA_DLG_HIBERNATE_FLAG           0x0200
#define MSGINA_DLG_FLAG_MASK                (MSGINA_DLG_SHUTDOWN_FLAG | MSGINA_DLG_REBOOT_FLAG | MSGINA_DLG_SYSTEM_FLAG | MSGINA_DLG_POWEROFF_FLAG | MSGINA_DLG_SLEEP_FLAG | MSGINA_DLG_SLEEP2_FLAG | MSGINA_DLG_HIBERNATE_FLAG)

//  Define the input timeout delay for logon dialogs (seconds)

#define LOGON_TIMEOUT                       120

//  Define an external reference to the HINSTANCE of msgina.dll

EXTERN_C    HINSTANCE       hDllInstance;

//  Functions used (must declare as C and be transparent in functionality).

EXTERN_C    void            _Gina_SasNotify (void *pWlxContext, DWORD dwSASType);
EXTERN_C    BOOL            _Gina_SetTimeout (void *pWlxContext, DWORD dwTimeout);
EXTERN_C    INT_PTR         _Gina_DialogBoxParam (void *pWlxContext, HINSTANCE hInstance, LPCWSTR pszTemplate, HWND hwndParent, DLGPROC pfnDlgProc, LPARAM lParam);
EXTERN_C    INT_PTR         _Gina_MessageBox (void *pWlxContext, HWND hwnd, LPCWSTR pszText, LPCWSTR pszCaption, UINT uiType);
EXTERN_C    int             _Gina_SwitchDesktopToUser (void *pWlxContext);
EXTERN_C    INT_PTR         _Gina_ShutdownDialog (void *pWlxContext, HWND hwndParent, DWORD dwExcludeItems);
EXTERN_C    HANDLE          _Gina_GetUserToken (void *pWlxContext);
EXTERN_C    const WCHAR*    _Gina_GetUsername (void *pWlxContext);
EXTERN_C    const WCHAR*    _Gina_GetDomain (void *pWlxContext);
EXTERN_C    void            _Gina_SetTextFields (HWND hwndDialog, const WCHAR *pwszUsername, const WCHAR *pwszDomain, const WCHAR *pwszPassword);
EXTERN_C    BOOL            _Gina_SetPasswordFocus (HWND hwndDialog);

//  --------------------------------------------------------------------------
//  This section contains declarations in the shell component of msgina used
//  by the DS component of msgina.
//  --------------------------------------------------------------------------

//  These are return results from CW_LogonDialog_Init that inform the caller
//  whether auto logon with no password should be performed, whether the regular
//  Windows 2000 logon dialog should be displayed or whether the consumer windows
//  external UI host will handle the logon information gathering.

#define SHELL_LOGONDIALOG_NONE                      0
#define SHELL_LOGONDIALOG_LOGON                     1
#define SHELL_LOGONDIALOG_EXTERNALHOST              2

#define SHELL_LOGONDIALOG_LOGGEDOFF                 0
#define SHELL_LOGONDIALOG_RETURNTOWELCOME           1
#define SHELL_LOGONDIALOG_RETURNTOWELCOME_UNLOCK    2

#define SHELL_LOGONSTATUS_LOCK_MAGIC_NUMBER         48517

//  Functions used (must declare as C and be transparent in functionality).

EXTERN_C    NTSTATUS    _Shell_DllMain (HINSTANCE hInstance, DWORD dwReason);
EXTERN_C    NTSTATUS    _Shell_Initialize (void *pWlxContext);
EXTERN_C    NTSTATUS    _Shell_Terminate (void);
EXTERN_C    NTSTATUS    _Shell_Reconnect (void);
EXTERN_C    NTSTATUS    _Shell_Disconnect (void);

EXTERN_C    NTSTATUS    _Shell_LogonDialog_StaticInitialize (void);
EXTERN_C    NTSTATUS    _Shell_LogonDialog_StaticTerminate (void);
EXTERN_C    int         _Shell_LogonDialog_Init (HWND hwndDialog, int iDialogType);
EXTERN_C    void        _Shell_LogonDialog_Destroy (void);
EXTERN_C    BOOL        _Shell_LogonDialog_UIHostActive (void);
EXTERN_C    BOOL        _Shell_LogonDialog_Cancel (void);
EXTERN_C    BOOL        _Shell_LogonDialog_LogonDisplayError (NTSTATUS status, NTSTATUS subStatus);
EXTERN_C    void        _Shell_LogonDialog_LogonCompleted (INT_PTR iDialogResult, const WCHAR *pszUsername, const WCHAR *pszDomain);
EXTERN_C    void        _Shell_LogonDialog_ShuttingDown (void);
EXTERN_C    BOOL        _Shell_LogonDialog_DlgProc (HWND hwndDialog, UINT uiMessage, WPARAM wParam, LPARAM lParam);
EXTERN_C    void        _Shell_LogonDialog_ShowUIHost (void);
EXTERN_C    void        _Shell_LogonDialog_HideUIHost (void);

EXTERN_C    NTSTATUS    _Shell_LogonStatus_StaticInitialize (void);
EXTERN_C    NTSTATUS    _Shell_LogonStatus_StaticTerminate (void);
EXTERN_C    void        _Shell_LogonStatus_Init (UINT uiStartType);
EXTERN_C    void        _Shell_LogonStatus_Destroy (UINT uiEndType);
EXTERN_C    BOOL        _Shell_LogonStatus_Exists (void);
EXTERN_C    BOOL        _Shell_LogonStatus_IsStatusWindow (HWND hwnd);
EXTERN_C    BOOL        _Shell_LogonStatus_IsSuspendAllowed (void);
EXTERN_C    BOOL        _Shell_LogonStatus_WaitForUIHost (void);
EXTERN_C    void        _Shell_LogonStatus_ShowStatusMessage (const WCHAR *pszMessage);
EXTERN_C    void        _Shell_LogonStatus_SetStateStatus (int iCode);
EXTERN_C    void        _Shell_LogonStatus_SetStateLogon (int iCode);
EXTERN_C    void        _Shell_LogonStatus_SetStateLoggedOn (void);
EXTERN_C    void        _Shell_LogonStatus_SetStateEnd (void);
EXTERN_C    void        _Shell_LogonStatus_NotifyWait (void);
EXTERN_C    void        _Shell_LogonStatus_NotifyNoAnimations (void);
EXTERN_C    void        _Shell_LogonStatus_SelectUser (const WCHAR *pszUsername, const WCHAR *pszDomain);
EXTERN_C    void        _Shell_LogonStatus_InteractiveLogon (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword);
EXTERN_C    void*       _Shell_LogonStatus_GetUIHost (void);
EXTERN_C    HANDLE      _Shell_LogonStatus_ResetReadyEvent (void);
EXTERN_C    void        _Shell_LogonStatus_Show (void);
EXTERN_C    void        _Shell_LogonStatus_Hide (void);
EXTERN_C    BOOL        _Shell_LogonStatus_IsHidden (void);

//  These are functions that implement exports. Stubs are declared
//  in the DS depot to allow the import lib to built without dependency.

EXTERN_C    LONG        _ShellGetUserList (BOOL fRemoveGuest, DWORD *pdwUserCount, void* *pUserList);
EXTERN_C    BOOL        _ShellIsSingleUserNoPassword (WCHAR *pwszUsername, WCHAR *pwszDomain);
EXTERN_C    BOOL        _ShellIsFriendlyUIActive (void);
EXTERN_C    BOOL        _ShellIsMultipleUsersEnabled (void);
EXTERN_C    BOOL        _ShellIsRemoteConnectionsEnabled (void);
EXTERN_C    BOOL        _ShellEnableFriendlyUI (BOOL fEnable);
EXTERN_C    BOOL        _ShellEnableMultipleUsers (BOOL fEnable);
EXTERN_C    BOOL        _ShellEnableRemoteConnections (BOOL fEnable);
EXTERN_C    DWORD       _ShellTurnOffDialog (HWND hwndParent);
EXTERN_C    int         _ShellACPIPowerButtonPressed (void *pWlxContext, UINT uiEventType, BOOL fLocked);
EXTERN_C    BOOL        _ShellIsSuspendAllowed (void);
EXTERN_C    void        _ShellStatusHostBegin (UINT uiStartType);
EXTERN_C    void        _ShellStatusHostEnd (UINT uiEndType);
EXTERN_C    void        _ShellStatusHostShuttingDown (void);
EXTERN_C    void        _ShellStatusHostPowerEvent (void);
EXTERN_C    BOOL        _ShellSwitchWhenInteractiveReady (SWITCHTYPE eSwitchType, void *pWlxContext);
EXTERN_C    HRESULT     _ShellDimScreen (IUnknown* *ppIUnknown, HWND* phwndDimmed);
EXTERN_C    void        _ShellInstallAccountFilterData (void);
EXTERN_C    DWORD       _ShellSwitchUser (BOOL fWait);
EXTERN_C    int         _ShellIsUserInteractiveLogonAllowed (const WCHAR *pwszUsername);
EXTERN_C    void        _ShellNotifyThemeUserChange (USERLOGTYPE eUserLogType, HANDLE hToken);
EXTERN_C    DWORD       _ShellReturnToWelcome (BOOL fUnlock);
EXTERN_C    DWORD       _ShellStartCredentialServer (const WCHAR *pwszUsername, const WCHAR *pwszDomain, WCHAR *pwszPassword, DWORD dwTimeout);
EXTERN_C    void        _ShellAcquireLogonMutex (void);
EXTERN_C    void        _ShellReleaseLogonMutex (BOOL fSignalEvent);
EXTERN_C    void        _ShellSignalShutdown (void);
EXTERN_C    void        _ShellStatusHostHide (void);
EXTERN_C    void        _ShellStatusHostShow (void);

#endif  /*  _MSGINA_    */

//  --------------------------------------------------------------------------
//  This section contains functions exported by ordinal from the shell
//  component of msgina.
//  --------------------------------------------------------------------------

GINASTDAPI_(LONG)       ShellGetUserList (BOOL fRemoveGuest, DWORD *pdwUserCount, void* *pUserList);
GINASTDAPI_(BOOL)       ShellIsSingleUserNoPassword (WCHAR *pwszUsername, WCHAR *pwszDomain);
GINASTDAPI_(BOOL)       ShellIsFriendlyUIActive (void);
GINASTDAPI_(BOOL)       ShellIsMultipleUsersEnabled (void);
GINASTDAPI_(BOOL)       ShellIsRemoteConnectionsEnabled (void);
GINASTDAPI_(BOOL)       ShellEnableFriendlyUI (BOOL fEnable);
GINASTDAPI_(BOOL)       ShellEnableMultipleUsers (BOOL fEnable);
GINASTDAPI_(BOOL)       ShellEnableRemoteConnections (BOOL fEnable);
GINASTDAPI_(DWORD)      ShellTurnOffDialog (HWND hwndParent);
GINASTDAPI_(int)        ShellACPIPowerButtonPressed (void *pWlxContext, UINT uiEventType, BOOL fLocked);
GINASTDAPI_(BOOL)       ShellIsSuspendAllowed (void);
GINASTDAPI_(void)       ShellStatusHostBegin (UINT uiStartType);
GINASTDAPI_(void)       ShellStatusHostEnd (UINT uiEndType);
GINASTDAPI_(void)       ShellStatusHostShuttingDown (void);
GINASTDAPI_(void)       ShellStatusHostPowerEvent (void);
GINASTDAPI_(BOOL)       ShellSwitchWhenInteractiveReady (SWITCHTYPE eSwitchType, void *pWlxContext);
GINASTDAPI              ShellDimScreen (IUnknown* *ppIUnknown, HWND* phwndDimmed);
GINASTDAPI_(void)       ShellInstallAccountFilterData (void);
GINASTDAPI_(DWORD)      ShellSwitchUser (BOOL fWait);
GINASTDAPI_(int)        ShellIsUserInteractiveLogonAllowed (const WCHAR *pwszUsername);
GINASTDAPI_(void)       ShellNotifyThemeUserChange (USERLOGTYPE eUserLogType, HANDLE hToken);
GINASTDAPI_(DWORD)      ShellReturnToWelcome (BOOL fUnlock);
GINASTDAPI_(DWORD)      ShellStartCredentialServer (const WCHAR *pwszUsername, const WCHAR *pwszDomain, WCHAR *pwszPassword, DWORD dwTimeout);
GINASTDAPI_(void)       ShellAcquireLogonMutex (void);
GINASTDAPI_(void)       ShellReleaseLogonMutex (BOOL fSignalEvent);
GINASTDAPI_(void)       ShellSignalShutdown (void);
GINASTDAPI_(void)       ShellStatusHostHide (void);
GINASTDAPI_(void)       ShellStatusHostShow (void);

#endif  /*  _MSGinaExports_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\netlibnt.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    NetLibNT.h

Abstract:

    This header file declares various common routines for use in the
    NT networking code.

Author:

    John Rogers (JohnRo) 02-Apr-1991

Environment:

    Only runs under NT; has an NT-specific interface (with Win32 types).
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include <nt.h> and <lmcons.h> before this file.

Revision History:

    02-Apr-1991 JohnRo
        Created.
    16-Apr-1991 JohnRo
        Avoid conflicts with MIDL-generated files.
    06-May-1991 JohnRo
        Implement UNICODE.  Avoid NET_API_FUNCTION for non-APIs.
    06-Sep-1991 CliffV
        Added NetpApiStatusToNtStatus.
    27-Nov-1991 JohnRo
        Added NetpAllocTStrFromString() for local NetConfig APIs.
    03-Jan-1992 JohnRo
        Added NetpCopyStringToTStr() for FAKE_PER_PROCESS_RW_CONFIG handling.
    13-Mar-1992 JohnRo
        Added NetpAllocStringFromTStr() for NetpGetDomainId().
    22-Sep-1992 JohnRo
        RAID 6739: Browser too slow when not logged into browsed domain.
    01-Dec-1992 JohnRo
        RAID 3844: remote NetReplSetInfo uses local machine type.  (Added
        NetpGetProductType and NetpIsProductTypeValid.)
    13-Feb-1995 FloydR
        Deleted NetpAllocStringFromTStr() - unused

--*/

#ifndef _NETLIBNT_
#define _NETLIBNT_

#ifdef __cplusplus
extern "C" {
#endif

NET_API_STATUS
NetpNtStatusToApiStatus(
    IN NTSTATUS NtStatus
    );

NTSTATUS
NetpApiStatusToNtStatus(
    NET_API_STATUS NetStatus
    );

NET_API_STATUS
NetpRdrFsControlTree(
    IN LPTSTR TreeName,
    IN LPTSTR TransportName OPTIONAL,
    IN ULONG ConnectionType,
    IN DWORD FsControlCode,
    IN LPVOID SecurityDescriptor OPTIONAL,
    IN LPVOID InputBuffer OPTIONAL,
    IN DWORD InputBufferSize,
    OUT LPVOID OutputBuffer OPTIONAL,
    IN DWORD OutputBufferSize,
    IN BOOL NoPermissionRequired
    );

#ifdef __cplusplus
}
#endif

#endif // ndef _NETLIBNT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\netdebug.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    NetDebug.h

Abstract:

    This header file declares various debug routines for use in the
    networking code.

Author:

    John Rogers (JohnRo) 11-Mar-1991

Environment:

    ifdef'ed for NT, any ANSI C environment, or none of the above (which
    implies nondebug).  The interface is portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    11-Mar-1991 JohnRo
        Created.
    25-Mar-1991 JohnRo
        Added more FORMAT_ strings.  Got rid of tabs in file.
    28-Mar-1991 JohnRo
        Added FORMAT_HEX_ strings.
    08-Apr-1991 JohnRo
        Added temporary versions of wide char stuff (FORMAT_LPTSTR, etc).
    16-Apr-1991 JohnRo
        Added PC-LINT version of NetpAssert(), to avoid occasional constant
        Boolean value messages.  Added wrappers for NT debug code, to avoid
        recompile hits from <nt.h> all over the place.
    25-Apr-1991 JohnRo
        Created procedure version of NetpDbgHexDump().
    13-May-1991 JohnRo
        Added FORMAT_LPVOID to replace FORMAT_POINTER.  Changed nondebug
        definition of NetpDbgHexDump() to avoid evaluating parameters.
    15-May-1991 JohnRo
        FORMAT_HEX_WORD was wrong.
    19-May-1991 JohnRo
        Improve LINT handling of assertions.
    21-May-1991 JohnRo
        Added NetpDbgReasonable() for partial hex dumps.
    13-Jun-1991 JohnRo
        Added NetpDbgDisplay routines.
        Moved DBGSTATIC here from <Rxp.h>.
    02-Jul-1991 JohnRo
        Added display routines for print job, print queue, and print dest.
    05-Jul-1991 JohnRo
        Avoid FORMAT_WORD name (used by MIPS header files).
    22-Jul-1991 JohnRo
        Implement downlevel NetConnectionEnum.
    25-Jul-1991 JohnRo
        Wksta debug support.
    03-Aug-1991 JohnRo
        Rename wksta display routine for consistency.
    20-Aug-1991 JohnRo
        Allow use in nondebug builds.
    20-Aug-1991 JohnRo
        Downlevel NetFile APIs.
    11-Sep-1991 JohnRo
        Downlevel NetService APIs.  Added UNICODE versions of some FORMAT_
        equates.  Added FORMAT_ULONG for NT use.
    13-Sep-1991 JohnRo
        Change "reasonable" debug amount to be an even number of lines.
        Create an equate for it.  Added LPDEBUG_STRING and a FORMAT_ for that.
    15-Oct-1991 JohnRo
        Implement remote NetSession APIs.
    11-Nov-1991 JohnRo
        Implement remote NetWkstaUserEnum().  Added FORMAT_RPC_STATUS.
    26-Dec-1991 JohnRo
        Added stuff for replicator APIs.
    07-Jan-1992 JohnRo
        Added NetpDbgDisplayWStr() for UNICODE strings.
        Added NetpDbgDisplayTStr() to be consistent.
    26-Feb-1992 JohnRo
        Added NetpDbgDisplayTimestamp() (seconds since 1970).
    15-Apr-1992 JohnRo
        Moved FORMAT_ equates into /nt/private/inc/debugfmt.h (so they
        can be used by the service controller as well).
    13-Jun-1992 JohnRo
        RAID 10324: net print vs. UNICODE.
    16-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
    24-Aug-1992 JohnRo
        Fixed free build again (misnamed repl import/export display macros).
    02-Oct-1992 JohnRo
        RAID 3556: DosPrintQGetInfo (from downlevel) level=3 rc=124.
        (Added NetpDbgDisplayPrintQArray.)
    05-Jan-1993 JohnRo
        Repl WAN support (get rid of repl name list limits).
        Made changes suggested by PC-LINT 5.0
    04-Mar-1993 JohnRo
        RAID 12237: replicator tree depth exceeded (add display of FILETIME
        and LARGE_INTEGER time).
    31-Mar-1993 JohnRo
        Allow others to display replicator state too.

--*/

#ifndef _NETDEBUG_
#define _NETDEBUG_

// These must be included first:
#include <windef.h>             // BOOL, DWORD, FALSE, LPBYTE, etc.

// These may be included in any order:
#include <debugfmt.h>           // Most FORMAT_ equates.
#include <stdarg.h>

#if DBG

// Normal netlib debug version.  No extra includes.

#else // not DBG

#ifdef CDEBUG

// ANSI C debug version.
#include <assert.h>             // assert().
#include <stdio.h>              // printf().

#else // ndef CDEBUG

// Nondebug version.

#endif // ndef CDEBUG

#endif // not DBG


#if !DBG || defined(lint) || defined(_lint)
#define DBGSTATIC static        // hidden function
#else
#define DBGSTATIC               // visible for use in debugger.
#endif


//
// printf-style format strings for some possibly nonportable stuff...
// These are passed to NetpDbgPrint(); use with other routines at your
// own risk.
//
// Most FORMAT_ equates now reside in /nt/private/inc/debugfmt.h.
//

typedef LPSTR LPDEBUG_STRING;

#define FORMAT_API_STATUS       "%lu"
#define FORMAT_LPDEBUG_STRING   "%s"

#ifdef __cplusplus
extern "C" {
#endif


// NetpAssert: continue if Predicate is true; otherwise print debug message
// (if possible) and hit a breakpoint (if possible).  Do nothing at all if
// this is a nondebug build.
//
// VOID
// NetpAssert(
//     IN BOOL Predicate
//     );
//

#if DBG

VOID
NetpAssertFailed(
    IN LPDEBUG_STRING FailedAssertion,
    IN LPDEBUG_STRING FileName,
    IN DWORD LineNumber,
    IN LPDEBUG_STRING Message OPTIONAL
    );

// Normal networking debug version.
#define NetpAssert(Predicate) \
    { \
        /*lint -save -e506 */  /* don't complain about constant values here */ \
        if (!(Predicate)) \
            NetpAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
        /*lint -restore */ \
    }

#else // not DBG

#ifdef CDEBUG

// ANSI C debug version.
#define NetpAssert(Predicate)   assert(Predicate)

#else // ndef CDEBUG

// Nondebug version.
#define NetpAssert(Predicate)   /* no output; ignore arguments */

#endif // ndef CDEBUG

#endif // not DBG


// NetpBreakPoint: if this is a debug version of some sort, cause a breakpoint
// somehow.  (This may just be an assertion failure in ANSI C.)  Do nothing at
// all in nondebug builds.
//
// VOID
// NetpBreakPoint(
//     VOID
//     );
//

#if DBG

// NT debug version.  Calls DbgBreakPoint.
VOID
NetpBreakPoint(
    VOID
    );

#else // not DBG

#ifdef CDEBUG

// ANSI C debug version.
#define NetpBreakPoint          NetpAssert(FALSE)

#else // ndef CDEBUG

// Nondebug version.
#define NetpBreakPoint()          /* no effect. */

#endif // ndef CDEBUG

#endif // not DBG


#if DBG
VOID
NetpDbgDisplayDword(
    IN LPDEBUG_STRING Tag,
    IN DWORD Value
    );

VOID
NetpDbgDisplayDwordHex(
    IN LPDEBUG_STRING Tag,
    IN DWORD Value
    );

VOID
NetpDbgDisplayLong(
    IN LPDEBUG_STRING Tag,
    IN LONG Value
    );

VOID
NetpDbgDisplayString(
    IN LPDEBUG_STRING Tag,
    IN LPTSTR Value
    );

VOID
NetpDbgDisplayTag(
    IN LPDEBUG_STRING Tag
    );

VOID
NetpDbgDisplayTimestamp(
    IN LPDEBUG_STRING Tag,
    IN DWORD Time               // Seconds since 1970.
    );

VOID
NetpDbgDisplayTod(
    IN LPDEBUG_STRING Tag,
    IN LPVOID TimePtr           // LPTIME_OF_DAY_INFO.
    );

#else // not DBG

#define NetpDbgDisplayDword(Tag,Value)        /* nothing */
#define NetpDbgDisplayDwordHex(Tag,Value)     /* nothing */
#define NetpDbgDisplayLong(Tag,Value)         /* nothing */
#define NetpDbgDisplayString(Tag,Value)       /* nothing */
#define NetpDbgDisplayTimestamp(Tag,Time)     /* nothing */
#define NetpDbgDisplayTag(Tag)                /* nothing */
#define NetpDbgDisplayTod(Tag,Tod)            /* nothing */

#endif // not DBG

//
//  NetpKdPrint() & NetpDbgPrint() are net equivalents of
//  KdPrint()     & DbgPrint().  Suggested usage:
//
//  NetpKdPrint() & KdPrint()   -   OK
//  NetpDbgPrint()              -   so,so; produces warnings in the free build
//  DbgPrint                    -   bad
//

#if DBG

#define NetpKdPrint(_x_) NetpDbgPrint _x_

VOID
NetpDbgPrint(
    IN LPDEBUG_STRING FORMATSTRING,     // PRINTF()-STYLE FORMAT STRING.
    ...                                 // OTHER ARGUMENTS ARE POSSIBLE.
    );

VOID
NetpHexDump(
    LPBYTE Buffer,
    DWORD BufferSize
    );

#else // not DBG

#ifdef CDEBUG

//  ANSI C debug version.

#define NetpKdPrint(_x_)        NetpDbgPrint _x_
#define NetpDbgPrint            (void) printf

#else // ndef CDEBUG

//  Nondebug version.  Note that NetpKdPrint() eliminates all its
//  arguments.

#define NetpKdPrint(_x_)

#endif // ndef CDEBUG
#endif // not DBG


// NetpDbgHexDump: do a hex dump of some number of bytes to the debug
// terminal or whatever.  This is a no-op in a nondebug build.

#if DBG || defined(CDEBUG)

VOID
NetpDbgHexDump(
    IN LPBYTE StartAddr,
    IN DWORD Length
    );

#else

#define NetpDbgHexDump(StartAddr,Length)     // no output; ignore arguments

#endif

//
// Define a number of bytes to dump for partial dumps.  Each line dumps
// 16 bytes, so do an even number of lines.
//
#define REASONABLE_DUMP_SIZE  (6*16)

// NetpDbgReasonable: pick a number for partial hex dumps.
//
// DWORD
// NetpDbgReasonable(
//     IN DWORD MaxSize
//     );
#define NetpDbgReasonable(MaxSize) \
    /*lint -save -e506 */  /* don't complain about constant values here */ \
    ( ((MaxSize) < REASONABLE_DUMP_SIZE) ? (MaxSize) : REASONABLE_DUMP_SIZE ) \
    /*lint -restore */

#ifdef __cplusplus
}
#endif

//
// Generic log managment funtions.  Present in debug and free builds.
// All logs are relative to %WINDIR%\\debug\\.  DebugLog will automatically
// have a .LOG appended
//

VOID
NetpInitializeLogFile(
    VOID
    );

VOID
NetpShutdownLogFile(
    VOID
    );

HANDLE
NetpOpenDebugFile(
    IN LPWSTR DebugLog,
    IN BOOLEAN ReopenFlag
    );

VOID
NetpCloseDebugFile(
    IN HANDLE LogHandle
    );

VOID
NetpLogPrintRoutine(
    IN HANDLE LogHandle,
    IN LPSTR Format,
    ...
    );

VOID
NetpLogPrintRoutineVEx(
    IN HANDLE LogHandle,
    IN PDWORD OpenLogThreadId OPTIONAL,
    IN LPSTR Format,
    IN va_list arglist
    );

VOID
NetpLogPrintRoutineV(
    IN HANDLE LogHandle,
    IN LPSTR Format,
    IN va_list arglist
    );

VOID
NetpResetLog(
    IN HANDLE LogHandle
    );


#endif // ndef _NETDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\netlogon.h ===
/*++

Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    netlogon.h

Abstract:

    Definition of mailslot messages and Internal APIs to the Netlogon service.

    This file is shared by the Netlogon service, the Workstation service,
    the XACT server, and the MSV1_0 authentication package.

Author:

    Cliff Van Dyke (cliffv) 16-May-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    16-May-1991 (cliffv)
        Ported from LanMan 2.1.

    02-Jan-1992 (madana)
        added support for builtin/multidomain replication.

--*/

#ifndef _NETLOGON_H_
#define _NETLOGON_H_

#include <smbtypes.h>    // need by smbgtpt.h
#include <smbgtpt.h>    // SmbPutUlong

//
// define version bit
//
// All netlogon messages that are compatible to NT VERSION 1 will
// have the following bit set in the version field of the message
// otherwise the message will not be processed by this version
// of software. In addition to this the message should carry NT
// token in it.
//

#define NETLOGON_NT_VERSION_1   0x00000001

//
// Starting in NT 5.0, some messages became more DS/DNS aware.  Those
//  messages additionally have the following bits set to indicate the
//  presence of the additional fields.

#define NETLOGON_NT_VERSION_5   0x00000002

//
// Starting in NT 5.0, some client can handle the _EX version of
// logon responses.

#define NETLOGON_NT_VERSION_5EX 0x00000004

//
// 5EX responses in mailslot messages will also include the IP address of
//  the responding DC.
//

#define NETLOGON_NT_VERSION_5EX_WITH_IP 0x00000008

//
// Set on Logon requests to indicate caller is querying for a PDC.
#define NETLOGON_NT_VERSION_PDC     0x10000000

//
// Set on Logon requests to indicate caller is querying for a DC running IP
#define NETLOGON_NT_VERSION_IP      0x20000000

//
// Set on Logon requests to indicate caller is local machine
#define NETLOGON_NT_VERSION_LOCAL   0x40000000

//
// Set on Logon requests to indicate caller is querying for a GC.
#define NETLOGON_NT_VERSION_GC      0x80000000

//
// Set on Logon requests to indicate caller wants to avoid NT4.0 emulation.
#define NETLOGON_NT_VERSION_AVOID_NT4EMUL  0x01000000

//
//

//
// Name of the mailslot the Netlogon service listens to.
//

#define NETLOGON_LM_MAILSLOT_W      L"\\MAILSLOT\\NET\\NETLOGON"
#define NETLOGON_LM_MAILSLOT_A      "\\MAILSLOT\\NET\\NETLOGON"
#define NETLOGON_LM_MAILSLOT_LEN    22  // Length in characters (w/o NULL)

#define NETLOGON_NT_MAILSLOT_W      L"\\MAILSLOT\\NET\\NTLOGON"
#define NETLOGON_NT_MAILSLOT_A      "\\MAILSLOT\\NET\\NTLOGON"
#define NETLOGON_NT_MAILSLOT_LEN    21 // Length in characters (w/o NULL)

//
// Opcodes for netlogon mailslot data
//

#define LOGON_REQUEST               0   // LM1.0/2.0 LOGON Request from client
#define LOGON_RESPONSE              1   // LM1.0 Response to LOGON_REQUEST
#define LOGON_CENTRAL_QUERY         2   // LM1.0 QUERY for centralized init
#define LOGON_DISTRIB_QUERY         3   // LM1.0 QUERY for non-centralized init
#define LOGON_CENTRAL_RESPONSE      4   // LM1.0 response to LOGON_CENTRAL_QUERY
#define LOGON_DISTRIB_RESPONSE      5   // LM1.0 resp to LOGON_DISTRIB_QUERY
#define LOGON_RESPONSE2             6   // LM2.0 Response to LOGON_REQUEST
#define LOGON_PRIMARY_QUERY         7   // QUERY for Primary DC
#define LOGON_START_PRIMARY         8   // announce startup of Primary DC
#define LOGON_FAIL_PRIMARY          9   // announce failed  Primary DC
#define LOGON_UAS_CHANGE            10  // announce change to UAS or SAM
#define LOGON_NO_USER               11  // announce no user on machine
#define LOGON_PRIMARY_RESPONSE      12  // response to LOGON_PRIMARY_QUERY
#define LOGON_RELOGON_RESPONSE      13  // LM1.0/2.0 resp to relogn request
#define LOGON_WKSTINFO_RESPONSE     14  // LM1.0/2.0 resp to interrogate request
#define LOGON_PAUSE_RESPONSE        15  // LM2.0 resp when NETLOGON is paused
#define LOGON_USER_UNKNOWN          16  // LM2.0 response when user is unknown
#define LOGON_UPDATE_ACCOUNT        17  // LM2.1 announce account updates

#define LOGON_SAM_LOGON_REQUEST     18  // SAM LOGON request from client
#define LOGON_SAM_LOGON_RESPONSE    19  // SAM Response to SAM logon request
#define LOGON_SAM_PAUSE_RESPONSE    20  // SAM response when NETLOGON is paused
#define LOGON_SAM_USER_UNKNOWN      21  // SAM response when user is unknown

#define LOGON_SAM_LOGON_RESPONSE_EX 23  // SAM Response to SAM logon request
#define LOGON_SAM_PAUSE_RESPONSE_EX 24  // SAM response when NETLOGON is paused
#define LOGON_SAM_USER_UNKNOWN_EX   25  // SAM response when user is unknown


//
// These structures are defined for their maximum case.  In many instances,
// the strings are packed immediately following one another.  In that case
// the comments below indicate that the offset of certain fields should
// not be used.
//

//
// NETLOGON_LOGON_QUERY:
//
// This structure is used for the following Opcodes:
//      LOGON_PRIMARY_QUERY,    (all LanMan versions)
//      LOGON_CENTRAL_QUERY,        (LM 1.0 only)
//      LOGON_CENTRAL_RESPONSE,     (LM 1.0 only)
//      LOGON_DISTRIB_QUERY,        (LM 1.0 only)
//      LOGON_DISTRIB_RESPONSE.     (LM 1.0 only)
//
//

typedef struct _NETLOGON_LOGON_QUERY {
    USHORT Opcode;
    CHAR ComputerName[LM20_CNLEN+1];        // This field is always ASCII.

    CHAR MailslotName[LM20_PATHLEN];        // Do not use offset of this field

                                            //
                                            // This field is always ASCII.
                                            //

    CHAR Pad;                               // Possible pad to WCHAR boundary
    WCHAR UnicodeComputerName[CNLEN+1];     // Do not use offset of this field

                                            //
                                            // This field is only present if
                                            // this is a LOGON_PRIMARY_QUERY
                                            // from an NT system.
                                            //


    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_LOGON_QUERY, * PNETLOGON_LOGON_QUERY;



//
// NETLOGON_LOGON_REQUEST
//
// This structure is used for the following Opcodes:
//      LOGON_REQUEST    (LM 1.0 and LM 2.0 Only)
//

typedef struct _NETLOGON_LOGON_REQUEST {
    USHORT Opcode;
    CHAR ComputerName[LM20_CNLEN+1];
    CHAR UserName[LM20_UNLEN+1];            // Do not use offset of this field

    CHAR MailslotName[LM20_PATHLEN+1];      // Do not use offset of this field

                                            //
                                            // This field is always ASCII.
                                            //

    _USHORT (RequestCount);                 // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_LOGON_REQUEST, * PNETLOGON_LOGON_REQUEST;



//
// NETLOGON_LOGON_RESPONSE:
//
// This structure is used for the following Opcodes:
//      LOGON_RESPONSE (To LM 1.0 clients only).
//

typedef struct _NETLOGON_LOGON_RESPONSE {
    USHORT Opcode;
    CHAR UseName[2 + LM20_CNLEN + 1 + LM20_NNLEN +1];
    CHAR ScriptName[(2*LM20_PATHLEN) + LM20_UNLEN + LM20_CNLEN + LM20_NNLEN + 8];       // Do not use offset of this field
} NETLOGON_LOGON_RESPONSE, *PNETLOGON_LOGON_RESPONSE;


//
// NETLOGON_PRIMARY
//
// This structure is used for the following Opcodes:
//      LOGON_START_PRIMARY
//      LOGON_PRIMARY_RESPONSE
//

typedef struct _NETLOGON_PRIMARY {
    USHORT Opcode;
    CHAR PrimaryDCName[LM20_CNLEN + 1];     // This field is always ASCII.

    //
    // The following fields are only present if this message is from
    // an NT system.
    //

    CHAR Pad;                               // Possible pad to WCHAR boundary
    WCHAR UnicodePrimaryDCName[CNLEN+1];    // Do not use offset of this field
    WCHAR UnicodeDomainName[DNLEN+1];       // Do not use offset of this field

    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_PRIMARY, * PNETLOGON_PRIMARY;


//
// NETLOGON_FAIL_PRIMARY
//
// This structure is used for the following Opcodes:
//      LOGON_FAIL_PRIMARY       (All LanMan versions)
//

typedef struct _NETLOGON_FAIL_PRIMARY {
    USHORT  Opcode;

    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_FAIL_PRIMARY, *PNETLOGON_FAIL_PRIMARY;


//
// NETLOGON_LOGON_RESPONSE2
//
// This structure is used for the following Opcodes:
//      LOGON_RESPONSE2         (LM 2.0 only)
//      LOGON_USER_UNKNOWN      (LM 2.0 only)
//      LOGON_PAUSE_RESPONSE    (LM 2.0 only)
//

typedef struct _NETLOGON_LOGON_RESPONSE2 {
    USHORT Opcode;
    CHAR LogonServer[LM20_UNCLEN+1];
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_LOGON_RESPONSE2, *PNETLOGON_LOGON_RESPONSE2;


//
// The following structures are densely packed to be compatible with LM2.0.
//  Poorly aligned fields should only be accessed using the SmbPut and SmbGet
//  family of macros.
//

//
// Force misalignment of the following structures
//

#ifndef NO_PACKING
#include <packon.h>
#endif // ndef NO_PACKING

//
// NETLOGON_UAS_CHANGE
//
// This structure is used for the following Opcodes:
//      LOGON_UAS_CHANGE
//

//
// DB_CHANGE_INFO structure contains per database change info.
//

typedef struct _DB_CHANGE_INFO {
    DWORD           DBIndex;
    LARGE_INTEGER   LargeSerialNumber;
    LARGE_INTEGER   NtDateAndTime;
} DB_CHANGE_INFO, *PDB_CHANGE_INFO;


//
// NETLOGON_DB_STRUCTURE contains common change info for all databases and
//  array of per database change info. First half of this structure is
//  identical to downlevel NETLOGON_UAS_CHANGE message and contains SAM
//  database change info.
//

typedef struct _NETLOGON_DB_CHANGE {
    USHORT  Opcode;
    _ULONG  (LowSerialNumber);
    _ULONG  (DateAndTime);
    _ULONG  (Pulse);
    _ULONG  (Random);
    CHAR    PrimaryDCName[LM20_CNLEN + 1];
    CHAR    DomainName[LM20_DNLEN + 1];     // Do not use offset of this field

    //
    // The following fields are only present if this message is from
    // an NT system.
    //

    CHAR Pad;                               // Possible pad to WCHAR boundary
    WCHAR   UnicodePrimaryDCName[CNLEN+1];  // Do not use offset of this field
    WCHAR   UnicodeDomainName[DNLEN+1];     // Do not use offset of this field
    DWORD   DBCount;                        // Do not use offset of this field
    DB_CHANGE_INFO DBChangeInfo[1];         // Do not use offset of this field
    DWORD   DomainSidSize;                  // Do not use offset of this field
    CHAR    DomainSid[1];                   // Do not use offset of this field
    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_DB_CHANGE, *PNETLOGON_DB_CHANGE;



//
// Turn structure packing back off
//

#ifndef NO_PACKING
#include <packoff.h>
#endif // ndef NO_PACKING



//
// NETLOGON_SAM_LOGON_REQUEST
//
// This structure is used for the following Opcodes:
//      LOGON_SAM_LOGON_REQUEST  (SAM Only)
//
// This message exceeds the maximum size for broadcast mailslot messages.  In
// practice, this will only be a problem if the UnicodeUserName is over 100
// characters long.
//

typedef struct _NETLOGON_SAM_LOGON_REQUEST {
    USHORT Opcode;
    USHORT RequestCount;

    WCHAR UnicodeComputerName[CNLEN+1];
    WCHAR UnicodeUserName[((64>LM20_UNLEN)?64:LM20_UNLEN)+1]; // Do not use offset of this field
                                            // Note: UNLEN is way too large since
                                            // it makes the message larger than
                                            // 512 bytes.

    CHAR MailslotName[LM20_PATHLEN+1];      // Do not use offset of this field
                                            // This field is always ASCII.
    _ULONG (AllowableAccountControlBits);   // Do not use offset of this field
    DWORD   DomainSidSize;                  // Do not use offset of this field
    CHAR DomainSid[1];                      // Do not use offset of this field


    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field

    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_SAM_LOGON_REQUEST, * PNETLOGON_SAM_LOGON_REQUEST;



//
// NETLOGON_SAM_LOGON_RESPONSE
//
// This structure is used for the following Opcodes:
//      LOGON_SAM_LOGON_RESPONSE    (SAM only)
//      LOGON_SAM_USER_UNKNOWN      (SAM only)
//      LOGON_SAM_PAUSE_RESPONSE    (SAM only)
//

typedef struct _NETLOGON_SAM_LOGON_RESPONSE {
    USHORT Opcode;
    WCHAR UnicodeLogonServer[UNCLEN+1];
    WCHAR UnicodeUserName[((64>LM20_UNLEN)?64:LM20_UNLEN)+1];         // Do not use offset of this field
                                            // Note: UNLEN is way too large since
                                            // it makes the message larger than
                                            // 512 bytes.
    WCHAR UnicodeDomainName[DNLEN+1];       // Do not use offset of this field

    // The following fields are only present for NETLOGON_NT_VERSION_5
    GUID DomainGuid;                        // Do not use offset of this field
    GUID SiteGuid;                          // Do not use offset of this field

    CHAR DnsForestName[256];                  // Do not use offset of this field
                                            // This field counted UTF-8

    CHAR DnsDomainName[sizeof(WORD)];       // Do not use offset of this field
                                            // This field counted UTF-8
                                            // This field compressed ala RFC 1035

    CHAR DnsHostName[sizeof(WORD)];         // Do not use offset of this field
                                            // This field counted UTF-8
                                            // This field compressed ala RFC 1035

    _ULONG (DcIpAddress);                   // Do not use offset of this field
                                            // Host byte order
    _ULONG (Flags);                         // Do not use offset of this field
    // The previous fields are only present for NETLOGON_NT_VERSION_5

    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field
} NETLOGON_SAM_LOGON_RESPONSE, *PNETLOGON_SAM_LOGON_RESPONSE;



//
// NETLOGON_SAM_LOGON_RESPONSE_EX
//
// This structure is used for the following Opcodes:
//      LOGON_SAM_LOGON_RESPONSE_EX    (SAM only)
//      LOGON_SAM_USER_UNKNOWN_EX      (SAM only)
//      LOGON_SAM_PAUSE_RESPONSE_EX    (SAM only)
//
// All character fields are UTF-8 and are compressed ala RFC 1035

typedef struct _NETLOGON_SAM_LOGON_RESPONSE_EX {
    USHORT Opcode;
    USHORT Sbz;
    ULONG Flags;
    GUID DomainGuid;

    CHAR DnsForestName[256];                  // Do not use offset of this field

    CHAR DnsDomainName[sizeof(WORD)];       // Do not use offset of this field

    CHAR DnsHostName[sizeof(WORD)];         // Do not use offset of this field

    CHAR NetbiosDomainName[DNLEN+1];        // Do not use offset of this field

    CHAR NetbiosComputerName[UNCLEN+1];     // Do not use offset of this field

    CHAR UserName[64];                      // Do not use offset of this field
                                            // Note: UNLEN is way too large since
                                            // it makes the message larger than
                                            // 512 bytes.

    CHAR DcSiteName[64];                    // Do not use offset of this field

    CHAR ClientSiteName[64];                // Do not use offset of this field

    // The DcSockAddrSize field is only present for NETLOGON_NT_VERSION_5EX_WITH_IP
    CHAR(DcSockAddrSize);                   // Do not use offset of this field
                                            // The next DcSockAddrSize byte are a
                                            // SOCKADDR structure representing the
                                            // IP address of the DC

    _ULONG (NtVersion);                     // Do not use offset of this field
    _USHORT (LmNtToken);                    // Do not use offset of this field
    _USHORT (Lm20Token);                    // Do not use offset of this field

} NETLOGON_SAM_LOGON_RESPONSE_EX, *PNETLOGON_SAM_LOGON_RESPONSE_EX;

#endif // _NETLOGON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\netlib.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    NetLib.h

Abstract:

    This header file declares various common routines for use in the
    networking code.

Author:

    John Rogers (JohnRo) 14-Mar-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include <windows.h> and <lmcons.h> before this file.

Revision History:

    14-Mar-1991 JohnRo
        Created.
    20-Mar-1991 JohnRo
        Moved NetpPackString here (was NetapipPackString).  Removed tabs.
    21-Mar-1991 RitaW
        Added NetpCopyStringToBuffer.
    02-Apr-1991 JohnRo
        Moved NetpRdrFsControlTree to <netlibnt.h>.
    03-Apr-1991 JohnRo
        Fixed types for NetpCopyStringToBuffer.
    08-Apr-1991 CliffV
        Added NetpCopyDataToBuffer
    10-Apr-1991 JohnRo
        Added NetpSetParmError (descended from CliffV's SetParmError).
    10-Apr-1991 Danl
        Added NetpGetComputerName
    24-Apr-1991 JohnRo
        Avoid conflicts with MIDL-generated files.
        Added NetpAdjustPreferedMaximum().
        NetpCopyStringToBuffer's input string ptr is optional.
    26-Apr-1991 CliffV
        Added NetpAllocateEnumBuffer.
        Added typedefs PTRDIFF_T and BUFFER_DESCRIPTOR.
    16-Apr-1991 JohnRo
        Clarify UNICODE handling of pack and copy routines.
    24-Jul-1991 JohnRo
        Provide NetpIsServiceStarted() for use by <netrpc.h> macros.
    29-Oct-1991 JohnRo
        Added NetpChangeNullCharToNullPtr() macro.
    29-Oct-1991 Danhi
        Add function prototypes for DosxxxMessage Api's
    20-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    09-Jan-1992 JohnRo
        Added NetpGetDomainName().
    23-Jan-1992 JohnRo
        Added IN_RANGE() macro based on MadanA's RANGECHECK().
    25-Mar-1992 RitaW
        Added SET_SERVICE_EXITCODE() macro for setting Win32 vs
        service specific exitcode.
    06-May-1992 JohnRo
        Added NetpGetLocalDomainId() for PortUAS.
        Added NetpTranslateServiceName() for service controller APIs.
    27-Jul-1992 Madana
        Added NetpWriteEventlog function proto type.
    05-Aug-1992 JohnRo
        RAID 3021: NetService APIs don't always translate svc names.
    09-Sep-1992 JohnRo
        RAID 1090: net start/stop "" causes assertion.
    14-Oct-1992 JohnRo
        RAID 9020: setup: PortUas fails ("prompt on conflicts" version).
    02-Nov-1992 JohnRo
        Added NetpIsRemoteServiceStarted().
    15-Feb-1993 JohnRo
        RAID 10685: user name not in repl event log.
    24-Mar-1993 JohnRo
        Repl svc shuold use DBFlag in registry.
    05-Aug-1993 JohnRo
        RAID 17010: Implement per-first-level-directory change notify.
    19-Aug-1993 JohnRo
        RAID 2822: PortUAS maps chars funny.  (Workaround FormatMessageA bug.)
        RAID 3094: PortUAS displays chars incorrectly.

--*/

#ifndef _NETLIB_
#define _NETLIB_

// These may be included in any order:

#include <string.h>             // memcpy().

// Don't complain about "unneeded" includes of this file:
/*lint -efile(764,wchar.h) */
/*lint -efile(766,wchar.h) */
#include <wchar.h>      // iswdigit().

#ifdef CDEBUG                   // Debug in ANSI C environment?

#include <netdebug.h>           // NetpAssert().

#endif // ndef CDEBUG


#ifdef __cplusplus
extern "C" {
#endif

//
// IN_RANGE(): Make sure SomeValue is between SomeMin and SomeMax.
// Beware side-effects (SomeValue is evaluated twice).
// Created by JohnRo from MadanA's RANGECHECK().
//
// BOOL
// IN_RANGE(
//     IN DWORD SomeValue,
//     IN DWORD SomeMin,
//     IN DWORD SomeMax
//     );
//
#define IN_RANGE(SomeValue, SomeMin, SomeMax) \
    ( ((SomeValue) >= (SomeMin)) && ((SomeValue) <= (SomeMax)) )


//
// SET_SERVICE_EXITCODE() sets the SomeApiStatus to NetCodeVariable
// if it is within the NERR_BASE and NERR_MAX range.  Otherwise,
// Win32CodeVariable is set.  This original code came from JohnRo.
//
#define SET_SERVICE_EXITCODE(SomeApiStatus, Win32CodeVariable, NetCodeVariable) \
    {                                                                  \
        if ((SomeApiStatus) == NERR_Success) {                         \
            (Win32CodeVariable) = NO_ERROR;                            \
            (NetCodeVariable) = NERR_Success;                          \
        } else if (! IN_RANGE((SomeApiStatus), MIN_LANMAN_MESSAGE_ID, MAX_LANMAN_MESSAGE_ID)) { \
            (Win32CodeVariable) = (DWORD) (SomeApiStatus);             \
            (NetCodeVariable) = (DWORD) (SomeApiStatus);               \
        } else {                                                       \
            (Win32CodeVariable) = ERROR_SERVICE_SPECIFIC_ERROR;        \
            (NetCodeVariable) = (DWORD) (SomeApiStatus);               \
        }                                                              \
    }


VOID
NetpAdjustPreferedMaximum (
    IN DWORD PreferedMaximum,
    IN DWORD EntrySize,
    IN DWORD Overhead,
    OUT LPDWORD BytesToAllocate OPTIONAL,
    OUT LPDWORD EntriesToAllocate OPTIONAL
    );

// Portable memory move/copy routine:  This is intended to have exactly
// the semantics of ANSI C's memcpy() routine, except that the byte count
// is 32 bits long.
//
// VOID
// NetpMoveMemory(
//     OUT LPBYTE Dest,         // Destination (must not be NULL).
//     IN LPBYTE Src,           // Source
//     IN DWORD Size            // Byte count
//     );

#ifdef CDEBUG

// Note that C6 version doesn't allow 32-bit Size, hence the
// assertion.  Replace this macro with another if this is a problem.

#define NetpMoveMemory(Dest,Src,Size)                                   \
                {                                                       \
                    NetpAssert( (Size) == (DWORD) (size_t) (Size));     \
                    (void) memcpy( (Dest), (Src), (size_t) (Size) );    \
                }

#else // ndef CDEBUG

#define NetpMoveMemory(Dest,Src,Size)                                   \
                (void) memcpy( (Dest), (Src), (size_t) (Size) )

#endif // ndef CDEBUG

DWORD
NetpPackString(
    IN OUT LPWSTR * string,     // pointer by reference: string to be copied.
    IN LPBYTE dataend,          // pointer to end of fixed size data.
    IN OUT LPWSTR * laststring  // pointer by reference: top of string data.
    );

//
// This routine is like NetpPackString, except that it does not expect the
// caller to assign the pointer of the source string to the variable in the
// fixed size structure before the call.  It also takes a string character
// count parameter instead of calling strlen on String.
//

BOOL
NetpCopyStringToBuffer (
    IN LPWSTR String OPTIONAL,
    IN DWORD CharacterCount,
    IN LPBYTE FixedDataEnd,
    IN OUT LPWSTR *EndOfVariableData,
    OUT LPWSTR *VariableDataPointer
    );

//
// This routine is like NetpCopyStringToBuffer except it copies any data
// (not just strings), it does not put a zero byte at the end of the
// data, and it allows the alignment of the resultant copied data to be
// specified.
//

BOOL
NetpCopyDataToBuffer (
    IN LPBYTE Data,
    IN DWORD ByteCount,
    IN LPBYTE FixedDataEnd,
    IN OUT LPBYTE *EndOfVariableData,
    OUT LPBYTE *VariableDataPointer,
    IN DWORD Alignment
    );

//
// Declare a type for the difference between two pointers.
//
// This must be at least as long as a ptrdiff_t but we don't want to
// add a dependency on <stddef.h> here.
//

typedef DWORD_PTR PTRDIFF_T;


//
// Declare a description of an enumeration buffer.
//

typedef struct _BUFFER_DESCRIPTOR {
    LPBYTE Buffer;        // Pointer to the allocated buffer.
    DWORD AllocSize;      // Current size of the allocated buffer.
    DWORD AllocIncrement; // Amount to increment size by on each reallocate.

    LPBYTE EndOfVariableData;// Pointer past last avaliable byte of string space
    LPBYTE FixedDataEnd;  // Pointer past last used byte of fixed data space

} BUFFER_DESCRIPTOR, *PBUFFER_DESCRIPTOR;

//
// This routine handles all the details of allocating and growing a
// buffer returned from an enumeration function.  It takes the users
// prefered maximum size into consideration.
//

#define NETP_ENUM_GUESS 16384 // Initial guess for enumeration buffer size

NET_API_STATUS
NetpAllocateEnumBuffer(
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
        // Caller must deallocate BD->Buffer using MIDL_user_free.

    IN BOOL IsGet,
    IN DWORD PrefMaxSize,
    IN DWORD NeededSize,
    IN VOID (*RelocationRoutine)( IN DWORD RelocationParameter,
                                  IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
                                  IN PTRDIFF_T Offset ),
    IN DWORD RelocationParameter
    );

NET_API_STATUS
NetpAllocateEnumBufferEx(
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN BOOL IsGet,
    IN DWORD PrefMaxSize,
    IN DWORD NeededSize,
    IN VOID (*RelocationRoutine)( IN DWORD RelocationParameter,
                                  IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
                                  IN PTRDIFF_T Offset ),
    IN DWORD RelocationParameter,
    IN DWORD IncrementalSize
    );

BOOL
NetpIsServiceStarted(
    IN LPWSTR ServiceName
    );

//
// Portable memory allocation routines.  Memory is per-process only.
//

// Allocate memory, or return NULL if not available.

LPVOID
NetpMemoryAllocate(
    IN DWORD Size
    );

// Free memory at Address (must have been gotten from NetpMemoryAllocate or
// NetpMemoryReallocate).  (Address may be NULL.)

VOID
NetpMemoryFree(
    IN LPVOID Address OPTIONAL
    );

// Reallocate block (now at OldAddress) to NewSize.  OldAddress may be NULL.
// Contents of block are copied if necessary.  Returns NULL if unable to
// allocate additional storage.

LPVOID
NetpMemoryReallocate(
    IN LPVOID OldAddress OPTIONAL,
    IN DWORD NewSize
    );

//
// Random handy macros:
//
#define NetpPointerPlusSomeBytes(p,n)                                   \
                (LPBYTE)  ( ( (LPBYTE) (p)) + (n) )

#define NetpSetOptionalArg(arg, value) \
    {                         \
        if ((arg) != NULL) {  \
            *(arg) = (value); \
        }                     \
    }

//
// Set the optional ParmError parameter
//

#define NetpSetParmError( _ParmNumValue ) \
    if ( ParmError != NULL ) { \
        *ParmError = (_ParmNumValue); \
    }

#if defined(lint) || defined(_lint)
#define UNUSED(x)               { (x) = (x); }
#else
#define UNUSED(x)               { (void) (x); }
#endif

//
// NetpGetComputerName retrieves the local computername from the local
// configuration database.
//

NET_API_STATUS
NetpGetComputerName (
    IN  LPWSTR   *ComputerNamePtr);

NET_API_STATUS
NetpGetComputerNameEx (
    IN  LPWSTR   *ComputerNamePtr,
    IN  BOOL PhysicalNetbiosName
    );

NET_API_STATUS
NetpGetDomainName (
    OUT LPWSTR *DomainNamePtr  // alloc and set ptr (free with NetApiBufferFree)
    );

NET_API_STATUS
NetpGetDomainNameEx (
    OUT LPWSTR *DomainNamePtr, // alloc and set ptr (free with NetApiBufferFree)
    OUT PBOOLEAN IsWorkgroupName
    );

NET_API_STATUS
NetpGetDomainNameExEx (
    OUT LPWSTR *DomainNamePtr,
    OUT LPWSTR *DnsDomainNamePtr OPTIONAL,
    OUT PBOOLEAN IsWorkgroupName
    );

#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct  _GUID
    {
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
    } GUID;

#endif // !GUID_DEFINED

NET_API_STATUS
NetpGetDomainNameExExEx (
    OUT LPTSTR *DomainNamePtr,
    OUT LPTSTR *DnsDomainNamePtr OPTIONAL,
    OUT LPTSTR *DnsForestNamePtr OPTIONAL,
    OUT GUID **DomainGuidPtr OPTIONAL,
    OUT PBOOLEAN IsWorkgroupName
    );

typedef enum _LOCAL_DOMAIN_TYPE {
    LOCAL_DOMAIN_TYPE_ACCOUNTS,
    LOCAL_DOMAIN_TYPE_BUILTIN,
    LOCAL_DOMAIN_TYPE_PRIMARY
} LOCAL_DOMAIN_TYPE, *PLOCAL_DOMAIN_TYPE, *LPLOCAL_DOMAIN_TYPE;

NET_API_STATUS
NetpGetLocalDomainId (
    IN LOCAL_DOMAIN_TYPE TypeWanted,
    OUT PSID *RetDomainId     // alloc and set ptr (free with LocalFree)
    );

//
// NetService API helpers
//

// BOOL
// NetpIsServiceLevelValid(
//     IN DWORD Level
//     );
//
#define NetpIsServiceLevelValid( Level ) \
     ( ((Level)==0) || ((Level)==1) || ((Level)==2) )

NET_API_STATUS
NetpTranslateNamesInServiceArray(
    IN DWORD Level,
    IN LPVOID ArrayBase,
    IN DWORD EntryCount,
    IN BOOL PreferNewStyle,
    OUT LPVOID * NewArrayBase
    );

NET_API_STATUS
NetpTranslateServiceName(
    IN LPWSTR GivenServiceName,
    IN BOOL PreferNewStyle,
    OUT LPWSTR * TranslatedName
    );

//
// Mapping routines to map DosxxxMessage API's to FormatMessage
//


WORD
DosGetMessage(
    IN LPSTR * InsertionStrings,
    IN WORD NumberofStrings,
    OUT LPBYTE Buffer,
    IN WORD BufferLength,
    IN WORD MessageId,
    IN LPWSTR FileName,
    OUT PWORD pMessageLength
    );

DWORD
NetpGetPrivilege(
    IN  DWORD       numPrivileges,
    IN  PULONG      pulPrivileges
    );

DWORD
NetpReleasePrivilege(
    VOID
    );

DWORD
NetpWriteEventlog(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    LPWSTR *Strings,
    DWORD DataLength,
    LPVOID Data
    );

DWORD
NetpRaiseAlert(
    IN LPWSTR ServiceName,
    IN DWORD alert_no,
    IN LPWSTR *string_array
    );

//
// Special flags to NetpEventlogWrite
//

#define NETP_LAST_MESSAGE_IS_NTSTATUS  0x80000000
#define NETP_LAST_MESSAGE_IS_NETSTATUS 0x40000000
#define NETP_ALLOW_DUPLICATE_EVENTS    0x20000000
#define NETP_RAISE_ALERT_TOO           0x10000000
#define NETP_STRING_COUNT_MASK         0x000FFFFF

HANDLE
NetpEventlogOpen (
    IN LPWSTR Source,
    IN ULONG DuplicateEventlogTimeout
    );

DWORD
NetpEventlogWrite (
    IN HANDLE NetpEventHandle,
    IN DWORD EventId,
    IN DWORD EventType,
    IN LPBYTE RawDataBuffer OPTIONAL,
    IN DWORD RawDataSize,
    IN LPWSTR *StringArray,
    IN DWORD StringCount
    );

//
// extended version with re-arranged parameters + category, to be more
// compatible with ReportEvent().
//

DWORD
NetpEventlogWriteEx (
    IN HANDLE NetpEventHandle,
    IN DWORD EventType,
    IN DWORD EventCategory,
    IN DWORD EventId,
    IN DWORD StringCount,
    IN DWORD RawDataSize,
    IN LPWSTR *StringArray,
    IN LPVOID RawDataBuffer OPTIONAL
    );

VOID
NetpEventlogClearList (
    IN HANDLE NetpEventHandle
    );

VOID
NetpEventlogSetTimeout (
    IN HANDLE NetpEventHandle,
    IN ULONG DuplicateEventlogTimeout
    );

VOID
NetpEventlogClose (
    IN HANDLE NetpEventHandle
    );

#ifdef __cplusplus
}
#endif

#endif // ndef _NETLIB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\nlmon.h ===
/*--

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nlmon.h

Abstract:

    Trusted Domain monitor program.

Author:

    10-May-1993 (madana)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <nt.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>

#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <stdlib.h>

#include <lmcons.h>
#include <lmerr.h>
#include <lmwksta.h>
#include <lmserver.h>
#include <lmaccess.h>
#include <lmapibuf.h>

#include <netlib.h>
#include <netlibnt.h>
#include <icanon.h>
#include <netlogon.h>
#include <netdebug.h>
#include <logonp.h>

#ifdef GLOBAL_DEF
#define EXTERN
#else
#define EXTERN extern
#endif

#ifdef DBG
#define NlMonDbgPrint(_x_) printf _x_
#else
#define NlMonDbgPrint(_x_)
#endif

#define DOMAIN_PARAM    "/DOMAINLIST:"
#define MONTRUST_PARAM  "/MONTRUST:"
#define UPDATE_PARAM    "/UPDATE:"
#define DEBUG_PARAM     "/DEBUG:"

#define YES_PARAM       "YES"
#define NO_PARAM        "NO"

#define DEBUG_MONITOR   0x00000001
#define DEBUG_INIT      0x00000002
#define DEBUG_UPDATE    0x00000004
#define DEBUG_TRUST     0x00000008
#define DEBUG_VERBOSE   0x80000000

#define IF_DEBUG(Function) if (GlobalTrace & DEBUG_ ## Function)

#define INIT_OBJ_ATTR(Obj) \
    InitializeObjectAttributes( &(Obj), NULL, 0, NULL, NULL )

#define SERVERS_GROUP       L"SERVERS"

#define DCSTATE_ONLINE      L"DCOnline"
#define DCSTATE_OFFLINE     L"DCOffLine"
#define TYPE_NTPDC          L"NTPDC"
#define TYPE_NTBDC          L"NTBDC"
#define TYPE_LMBDC          L"LMBDC"
#define REPL_STATE_SYNC     L"InSync"
#define REPL_STATE_REQ      L"ReplRequired"
#define REPL_STATE_PROGRESS L"InProgress"
#define UNKNOWN             L"Unknown"

#define CONST_GLOBALTRACE           0x00000000
#define CONST_GLOBALMONITORTRUST    FALSE
#define CONST_GLOBALUPDATETIME      15

#define RETRY_COUNT                 5
#define UNKNOWN_REPLICATION_STATE   0x80000000

//
// update flags.
//

#define UPDATE_DCS_FROM_SERVER_ENUM         0x00000001
#define UPDATE_DCS_FROM_DATABASE            0x00000002
#define UPDATE_TRUST_DOMAINS_FROM_DATABASE  0x00000004
#define UPDATE_TRUST_DCS_FROM_SERVER_ENUM   0x00000008
#define UPDATE_TRUST_DCS_FROM_DATABASE      0x00000010
#define VALIDATE_DCS                        0x00000020
#define VALIDATE_TRUST_DCS                  0x00000040
#define VALIDATE_TRUST_CONNECTIONS          0x00000080

#define STANDARD_UPDATE \
            UPDATE_DCS_FROM_SERVER_ENUM | \
            VALIDATE_DCS | \
            UPDATE_TRUST_DCS_FROM_SERVER_ENUM | \
            VALIDATE_TRUST_DCS \

#define UPDATE_FROM_DATABASE \
            STANDARD_UPDATE | \
            UPDATE_DCS_FROM_DATABASE | \
            UPDATE_TRUST_DCS_FROM_DATABASE

#define UPDATE_TRUST_CONNECTIONS_STATUS \
            STANDARD_UPDATE | \
            VALIDATE_TRUST_CONNECTIONS

#define UPDATE_ALL \
            STANDARD_UPDATE | \
            UPDATE_FROM_DATABASE | \
            UPDATE_TRUST_CONNECTIONS_STATUS | \
            UPDATE_TRUST_DOMAINS_FROM_DATABASE

#define DOMAINLINE "............................................................................"
#define SESSLINE "****************************************************************************"

#define THREAD_STACKSIZE            1024 * 16   // 16K.
#define MACHINES_PER_PASS           250 // SAM machine acct. query size.

#define THREAD_WAIT_TIME            1 * 60 * 1000 // 1 min.

typedef enum _DC_STATE {
    DCOnLine,               // DC currently on running.
    DCOffLine               // DC currently down.
} DC_STATE;

typedef enum _DC_TYPE {
    NTPDC,                  // NT Primary DC.
    NTBDC,                  // NT Backup DC.
    LMBDC,                  // Downlevel Backup DC.
} DC_TYPE;

typedef enum _DOMAIN_STATE {
    DomainSuccess,
    DomainProblem,
    DomainSick,
    DomainDown,
    DomainUnknown,
} DOMAIN_STATE;

//
// generic entry
//

typedef struct _ENTRY {
    LIST_ENTRY NextEntry;
    UNICODE_STRING Name;
} ENTRY, *PENTRY;

//
// DC entry.
//

typedef struct _DC_ENTRY {
    LIST_ENTRY NextEntry;       // don't move this field
    UNICODE_STRING DCName;      // don't move this field
    DC_STATE State;
    DC_TYPE Type;
    DWORD DCStatus;             // DC Status
    DWORD ReplicationStatus;    // boolean flag bit array.
    DWORD PDCLinkStatus;        // To its PDC link status.
    LIST_ENTRY TrustedDCs;
    BOOL TDCLinkState;          // health of the trust connections.
    DWORD RetryCount;
    BOOL DeleteFlag;
} DC_ENTRY, *PDC_ENTRY;

//
// Trust Link entry.
//

typedef struct _TD_LINK {
    LIST_ENTRY NextEntry;       // don't move this field
    UNICODE_STRING TDName;      // don't move this field
    UNICODE_STRING DCName;
    DWORD SecureChannelStatus;
    BOOL DeleteFlag;
} TD_LINK, *PTD_LINK;

typedef struct _DOMAIN_ENTRY {
    LIST_ENTRY NextEntry;       // don't move this field
    UNICODE_STRING Name;        // don't move this field
    LIST_ENTRY DCList;
    LIST_ENTRY TrustedDomainList;
    DOMAIN_STATE DomainState;
    LONG ReferenceCount;
    BOOL IsMonitoredDomain;
    DWORD UpdateFlags;
    HANDLE ThreadHandle;
    BOOL ThreadTerminateFlag;
    DWORD LastUpdateTime;
} DOMAIN_ENTRY, *PDOMAIN_ENTRY;

typedef struct _DOMAIN_PRIVATE_ENTRY{
    LIST_ENTRY NextEntry;       // don't move this field
    UNICODE_STRING Name;        // don't move this field
    PDOMAIN_ENTRY DomainEntry;
    BOOL DeleteFlag;
} MONITORED_DOMAIN_ENTRY, *PMONITORED_DOMAIN_ENTRY,
  TRUSTED_DOMAIN_ENTRY, *PTRUSTED_DOMAIN_ENTRY;


//
// Global variables
//

EXTERN DWORD GlobalTrace;

EXTERN BOOL GlobalMonitorTrust;
EXTERN DWORD GlobalUpdateTimeMSec;  // UpdateTime in micro secs.

EXTERN LIST_ENTRY GlobalDomains;
EXTERN LIST_ENTRY GlobalDomainsMonitored;

EXTERN CRITICAL_SECTION GlobalListCritSect;
EXTERN CRITICAL_SECTION GlobalDomainUpdateThreadCritSect;
EXTERN HANDLE GlobalWorkerThreadHandle;
EXTERN HANDLE GlobalCmdProcessThreadHandle;
EXTERN HANDLE GlobalTerminateEvent;
EXTERN BOOL GlobalTerminateFlag;

EXTERN HANDLE GlobalUpdateEvent;
EXTERN BOOL GlobalInitialized;

EXTERN HANDLE GlobalRefreshEvent;
EXTERN HANDLE GlobalRefreshDoneEvent;

//
// This lock is a very simple lock. The list is updated (ie,
// add/delete/update an entry) after locking it using this lock.
// The reader of the list may lock the list if they don't want it
// updated while reading.
//

#define LOCK_LISTS()   EnterCriticalSection( &GlobalListCritSect )
#define UNLOCK_LISTS() LeaveCriticalSection( &GlobalListCritSect )


//
// proto types.
//

VOID
DomainUpdateThread(
    PDOMAIN_ENTRY DomainEntry
    );

BOOL
StartDomainUpdateThread(
    PDOMAIN_ENTRY DomainEntry,
    DWORD UpdateFlags
    );

BOOL
IsDomainUpdateThreadRunning(
    HANDLE *ThreadHandle
    );

VOID
StopDomainUpdateThread(
    HANDLE *ThreadHandle,
    BOOL *ThreadTerminateFlag
    );

PMONITORED_DOMAIN_ENTRY
AddToMonitoredDomainList(
    PUNICODE_STRING DomainName
    );

PTRUSTED_DOMAIN_ENTRY
AddToTrustedDomainList(
    PLIST_ENTRY List,
    PUNICODE_STRING DomainName
    );

NTSTATUS
QueryLsaInfo(
    PUNICODE_STRING ServerName,
    ACCESS_MASK DesiredAccess,
    POLICY_INFORMATION_CLASS InformationClass,
    PVOID *Info,
    PLSA_HANDLE ReturnHandle //optional
    );

VOID
CleanupLists(
    VOID
    );

DWORD
InitGlobals(
    VOID
    );

VOID
UpdateAndValidateDomain(
    PDOMAIN_ENTRY DomainEntry,
    DWORD UpdateFlags
    );

VOID
UpdateAndValidateLists(
    DWORD UpdateFlags,
    BOOL ForceFlag
    );

VOID
WorkerThread(
    VOID
    );

DWORD
StartMonitor(
    LPWSTR DomainList,
    DWORD interval,
    BOOL MonitorTD
    );

DOMAIN_STATE
QueryHealth(
    const LPWSTR DomainName
    );

VOID
StopMonitor(
    VOID
    );

LPWSTR
QueryPDC(
    const LPWSTR DomainName
    );

PLIST_ENTRY
QueryTrustedDomain(
    const LPWSTR DomainName
    );

PLIST_ENTRY
QueryDCList(
    const LPWSTR DomainName
    );

PLIST_ENTRY
QueryTDLink(
    const LPWSTR DomainName,
    const LPWSTR DCName
    );

PLIST_ENTRY
QueryTDCList(
    const LPWSTR DomainName,
    const LPWSTR TrustedDomainName);

DWORD
DisConnect(
    const LPWSTR DomainName,
    const LPWSTR DCName,
    const LPWSTR TrustedDomainName
    );

VOID
AddDomainToList(
    const LPWSTR DomainName
    );

VOID
RemoveDomainFromList(
    const LPWSTR DomainName
    );

BOOL
InitDomainListW(
    LPWSTR DomainList
    );

PLIST_ENTRY
FindNamedEntry(
    PLIST_ENTRY List,
    PUNICODE_STRING Name
    );

VOID
CleanupDomainEntry(
    PDOMAIN_ENTRY DomainEntry
    );

VOID
UpdateDomainState(
    PDOMAIN_ENTRY DomainEntry
    );

NET_API_STATUS
IsValidNTDC(
    PUNICODE_STRING ServerName,
    PUNICODE_STRING DomainName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\notifyev.h ===
/*************************************************************************
*
* notifyev.h        !!!! DO NOT EDIT THIS FILE !!!!
*
* Winlogon notification DLL error codes
*
* NOTE: generated from: \nt\private\dllmerge\wlnotify\notifyev.mc
*
*
* Copyright Microsoft Corporation, 1998
*
*************************************************************************/




/*************************************************************************
*
 TSNOTIFY Events:
*
*************************************************************************/


#define CATEGORY_NOTIFY_EVENTS 1
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: 0x00000001L (No symbolic name defined)
//
// MessageText:
//
//  Terminal Server Notify Events
//


//
// MessageId: EVENT_NOTIFY_INIT_FAILED
//
// MessageText:
//
//  TS RDPDR Device Redirection failed to initialize for a single user session %1.  Serial, Parallel, Printer, and File System Redirection will be disabled.  Look in the System event log for other related errors.
//
#define EVENT_NOTIFY_INIT_FAILED         0x0000044CL

//
// MessageId: EVENT_NOTIFY_RDPDR_FAILED
//
// MessageText:
//
//  The RDPDR device manager component could not be opened.  Check the status of the Terminal Service Device Redirector in the Device Manager.
//
#define EVENT_NOTIFY_RDPDR_FAILED        0x0000044DL

//
// MessageId: EVENT_NOTIFY_DRIVER_NOT_FOUND
//
// MessageText:
//
//  Driver %1 required for printer %2 is not installed on the server. Contact the administrator to install the driver before you log in again.
//
#define EVENT_NOTIFY_DRIVER_NOT_FOUND    0x0000044EL

//
// MessageId: EVENT_NOTIFY_PRINTER_REDIRECTION_FAILED
//
// MessageText:
//
//  An internal communication error occurred.  Redirected printing will no longer function for a single user session.  Check the status of the Terminal Services Device Redirector in the System folder of Device Manager.
//
#define EVENT_NOTIFY_PRINTER_REDIRECTION_FAILED 0x0000044FL

//
// MessageId: EVENT_NOTIFY_OPENPRINTER_FAILED
//
// MessageText:
//
//  The printer %1 could not be opened.
//
#define EVENT_NOTIFY_OPENPRINTER_FAILED  0x00000450L

//
// MessageId: EVENT_NOTIFY_SET_PRINTER_ACL_FAILED
//
// MessageText:
//
//  Printer security information for the printer %1 could not be set.
//
#define EVENT_NOTIFY_SET_PRINTER_ACL_FAILED 0x00000451L

//
// MessageId: EVENT_NOTIFY_INSTALL_PRINTER_FAILED
//
// MessageText:
//
//  The printer could not be installed.
//
#define EVENT_NOTIFY_INSTALL_PRINTER_FAILED 0x00000452L

//
// MessageId: EVENT_NOTIFY_DELETE_PRINTER_FAILED
//
// MessageText:
//
//  The printer %1 could not be deleted.
//
#define EVENT_NOTIFY_DELETE_PRINTER_FAILED 0x00000453L

//
// MessageId: EVENT_NOTIFY_RESTORE_PRINTER_CONFIG_FAILED
//
// MessageText:
//
//  Configuration information for the %1 printer could not be restored. 
//
#define EVENT_NOTIFY_RESTORE_PRINTER_CONFIG_FAILED 0x00000454L

//
// MessageId: EVENT_NOTIFY_SETDEFAULTPRINTER_FAILED
//
// MessageText:
//
//  The %1 printer could not be set as the default printer.
//
#define EVENT_NOTIFY_SETDEFAULTPRINTER_FAILED 0x00000455L

//
// MessageId: EVENT_NOTIFY_ERRORPARSINGINF
//
// MessageText:
//
//  An error occurred during processing of %1. The file might be corrupted. Run Setup again to reinstall the file. 
//
#define EVENT_NOTIFY_ERRORPARSINGINF     0x00000456L

//
// MessageId: EVENT_NOTIFY_UNKNOWN_PRINTER_DRIVER
//
// MessageText:
//
//  Driver %1 required for printer %2 is unknown. Contact the administrator to install the driver before you log in again.
//
#define EVENT_NOTIFY_UNKNOWN_PRINTER_DRIVER 0x00000457L

//
// MessageId: EVENT_NOTIFY_FAILEDTOREGFOR_SETTING_NOTIFY
//
// MessageText:
//
//  Failed to register for user printing preferences change notification.  Open the Services snap-in and confirm that the Printer Spooler service is running 
//
#define EVENT_NOTIFY_FAILEDTOREGFOR_SETTING_NOTIFY 0x00000458L

//
// MessageId: EVENT_NOTIFY_INSUFFICIENTRESOURCES
//
// MessageText:
//
//  There is not enough memory to complete the operation. Save your work, close other programs, and then try again.
//
#define EVENT_NOTIFY_INSUFFICIENTRESOURCES 0x00000459L

//
// MessageId: EVENT_NOTIFY_SPOOLERERROR
//
// MessageText:
//
//  Error communicating with the Spooler system service.  Open the Services snap-in and confirm that the Print Spooler service is running.
//
#define EVENT_NOTIFY_SPOOLERERROR        0x0000045AL

//
// MessageId: EVENT_NOTIFY_INTERNALERROR
//
// MessageText:
//
//  Unexpected internal error in TS RDP device redirection.  Contact technical support.
//
#define EVENT_NOTIFY_INTERNALERROR       0x0000045BL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\ntdsapip.h ===
#ifndef _NTDSAPIP_H_
#define _NTDSAPIP_H_

// Private definitions related to sdk\inc\ntdsapi.h.

// The following are DS_NAME_FORMATs which we don't want to publish
// in ntdsapi.h.  Although DS_NAME_FORMAT is an enumerated type, we 
// pass vanilla DWORDs on the wire such that RPC doesn't complain about
// enumerated type values out of range or unknown.  These should be
// defined at the high end of the range so we can extend DS_NAME_FORMAT
// in future versions w/o holes which will leave people wondering and
// experimenting what those "unused" values are used for.

#define DS_LIST_SITES                           0xffffffff
#define DS_LIST_SERVERS_IN_SITE                 0xfffffffe
#define DS_LIST_DOMAINS_IN_SITE                 0xfffffffd
#define DS_LIST_SERVERS_FOR_DOMAIN_IN_SITE      0xfffffffc
#define DS_LIST_INFO_FOR_SERVER                 0xfffffffb
#define DS_LIST_ROLES                           0xfffffffa
#define DS_NT4_ACCOUNT_NAME_SANS_DOMAIN         0xfffffff9
#define DS_MAP_SCHEMA_GUID                      0xfffffff8
#define DS_LIST_DOMAINS                         0xfffffff7
#define DS_LIST_NCS                             0xfffffff6
#define DS_ALT_SECURITY_IDENTITIES_NAME         0xfffffff5
#define DS_STRING_SID_NAME                      0xfffffff4
#define DS_LIST_SERVERS_WITH_DCS_IN_SITE        0xfffffff3
#define DS_USER_PRINCIPAL_NAME_FOR_LOGON        0xfffffff2
#define DS_LIST_GLOBAL_CATALOG_SERVERS          0xfffffff1
#define DS_NT4_ACCOUNT_NAME_SANS_DOMAIN_EX      0xfffffff0

// following should always be equal to lowest private #define
#define DS_NAME_FORMAT_PRIVATE_BEGIN            0xfffffff0

// The following are DS_NAME_ERRORs which we don't want to publish
// in ntdsapi.h.  Same reasoning as above.

#define DS_NAME_ERROR_IS_FPO                    0xffffffff
#define DS_NAME_ERROR_SCHEMA_GUID_NOT_FOUND     0xfffffffe
#define DS_NAME_ERROR_SCHEMA_GUID_ATTR          0xfffffffd
#define DS_NAME_ERROR_SCHEMA_GUID_ATTR_SET      0xfffffffc
#define DS_NAME_ERROR_SCHEMA_GUID_CLASS         0xfffffffb
#define DS_NAME_ERROR_SCHEMA_GUID_CONTROL_RIGHT 0xfffffffa
#define DS_NAME_ERROR_IS_SID_USER               0xfffffff9
#define DS_NAME_ERROR_IS_SID_GROUP              0xfffffff8
#define DS_NAME_ERROR_IS_SID_ALIAS              0xfffffff7
#define DS_NAME_ERROR_IS_SID_UNKNOWN            0xfffffff6
#define DS_NAME_ERROR_IS_SID_HISTORY_USER       0xfffffff5
#define DS_NAME_ERROR_IS_SID_HISTORY_GROUP      0xfffffff4
#define DS_NAME_ERROR_IS_SID_HISTORY_ALIAS      0xfffffff3
#define DS_NAME_ERROR_IS_SID_HISTORY_UNKNOWN    0xfffffff2

// following should always be equal to lowest private #define
#define DS_NAME_ERROR_PRIVATE_BEGIN             0xfffffff2

// The following are DS_NAME_FLAGs which we don't want to publish
// in ntdsapi.h.  Same reasoning as above.  Remember that the flags
// field is a bit map, not an enumeration.

#define DS_NAME_FLAG_PRIVATE_PURE_SYNTACTIC     0x40000000
#define DS_NAME_FLAG_PRIVATE_RESOLVE_FPOS       0x80000000
// following should always be equal to lowest private #define
#define DS_NAME_FLAG_PRIVATE_BEGIN              0x80000000

// The following are DS_ADDSID_FLAGs which we don't want to publish
// in ntdsapi.h.  Same reasoning as above.  Remember that the flags
// field is a bit map, not an enumeration.

#define DS_ADDSID_FLAG_PRIVATE_DEL_SRC_OBJ      0x80000000
#define DS_ADDSID_FLAG_PRIVATE_CHK_SECURE       0x40000000
// following should always be equal to lowest private #define
#define DS_ADDSID_FLAG_PRIVATE_BEGIN            0x40000000

// The following are dc info infolevels that we don't want to publish.
// While the published APIs are used to get information from the set of
// DCs published in a domain, some of these private infolevels are used
// to get information from a single domain controller. These private
// infolevels are intended mostly for debugging and monitoring.

#define DS_DCINFO_LEVEL_FFFFFFFF                0xffffffff

// following should always be equal to lowest private #define
#define DS_DCINFO_LEVEL_PRIVATE_BEGIN           0xffffffff

// For DS_DOMAIN_CONTROLLER_INFO_FFFFFFFF. This retrieves the ldap 
// connection list from a single domain controller.

typedef struct _DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW {

    DWORD   IPAddress;          // IP Address of client
    DWORD   NotificationCount;  // number of outstanding notifications
    DWORD   secTimeConnected;   // total time in seconds connected
    DWORD   Flags;              // Connection properties. defined below.
    DWORD   TotalRequests;      // Total number of requests made
    DWORD   Reserved1;          // Unused
#ifdef MIDL_PASS
    [string,unique] WCHAR   *UserName;
#else
    LPWSTR  UserName;           // the security principal used to bind
#endif

} DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW, *PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW;

typedef struct _DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFA {

    DWORD   IPAddress;          // IP Address of client
    DWORD   NotificationCount;  // number of outstanding notifications
    DWORD   secTimeConnected;   // total time in seconds connected
    DWORD   Flags;              // Connection properties. defined below.
    DWORD   TotalRequests;      // Total number of requests made
    DWORD   Reserved1;          // Unused
#ifdef MIDL_PASS
    [string,unique] CHAR    *UserName;
#else
    LPSTR   UserName;           // the security principal used to bind
#endif

} DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFA, *PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFFA;

//
// connection flags
//

#define LDAP_CONN_FLAG_BOUND    0x00000001      // bound connection
#define LDAP_CONN_FLAG_SSL      0x00000002      // connect using SSL
#define LDAP_CONN_FLAG_UDP      0x00000004      // UDP connection
#define LDAP_CONN_FLAG_GC       0x00000008      // came through the GC port
#define LDAP_CONN_FLAG_GSSAPI   0x00000010      // used gssapi
#define LDAP_CONN_FLAG_SPNEGO   0x00000020      // used spnego
#define LDAP_CONN_FLAG_SIMPLE   0x00000040      // used simple
#define LDAP_CONN_FLAG_DIGEST   0x00000080      // used Digest-MD5
#define LDAP_CONN_FLAG_SIGN     0x00000100      // signing on
#define LDAP_CONN_FLAG_SEAL     0x00000200      // sealing on

#ifdef UNICODE
#define DS_DOMAIN_CONTROLLER_INFO_FFFFFFFF  DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW
#define PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFF  PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW
#else
#define DS_DOMAIN_CONTROLLER_INFO_FFFFFFFF  DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFA
#define PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFF  PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFFA
#endif

// ==========================================================
// DsCrackSpn2() -- parse a counted-length SPN into the ServiceClass,
// ServiceName, and InstanceName (and InstancePort) pieces.
// An SPN is passed in, along with a pointer to the maximum length
// for each piece and a pointer to a buffer where each piece should go.
// On exit, the maximum lengths are updated to the actual length for each piece
// and the buffer contain the appropriate piece. The InstancePort is 0 if not
// present.
//
// DWORD DsCrackSpn(
//      IN LPTSTR pszSPN,               // the SPN to parse
//      IN DWORD cSpn,                // length of pszSPN
//      IN OUT PUSHORT pcServiceClass,  // input -- max length of ServiceClass;
//                                         output -- actual length
//      OUT LPCTSTR ServiceClass,       // the ServiceClass part of the SPN
//      IN OUT PUSHORT pcServiceName,   // input -- max length of ServiceName;
//                                         output -- actual length
//      OUT LPCTSTR ServiceName,        // the ServiceName part of the SPN
//      IN OUT PUSHORT pcInstance,      // input -- max length of ServiceClass;
//                                         output -- actual length
//      OUT LPCTSTR InstanceName,  // the InstanceName part of the SPN
//      OUT PUSHORT InstancePort          // instance port
//
// Note: lengths are in characters; all string lengths include terminators
// All arguments except pszSpn are optional.
//

NTDSAPI
DWORD
WINAPI
DsCrackSpn2A(
    IN LPCSTR pszSpn,
    IN DWORD cSpn,
    IN OUT LPDWORD pcServiceClass,
    OUT LPSTR ServiceClass,
    IN OUT LPDWORD pcServiceName,
    OUT LPSTR ServiceName,
    IN OUT LPDWORD pcInstanceName,
    OUT LPSTR InstanceName,
    OUT USHORT *pInstancePort
    );

NTDSAPI
DWORD
WINAPI
DsCrackSpn2W(
    IN LPCWSTR pszSpn,
    IN DWORD cSpn,
    IN OUT DWORD *pcServiceClass,
    OUT LPWSTR ServiceClass,
    IN OUT DWORD *pcServiceName,
    OUT LPWSTR ServiceName,
    IN OUT DWORD *pcInstanceName,
    OUT LPWSTR InstanceName,
    OUT USHORT *pInstancePort
    );

NTDSAPI
DWORD
WINAPI
DsCrackSpn3W(
    IN LPCWSTR pszSpn,
    IN DWORD cSpn,
    IN OUT DWORD *pcHostName,
    OUT LPWSTR HostName,
    IN OUT DWORD *pcInstanceName,
    OUT LPWSTR InstanceName,
    OUT USHORT *pPortNumber,
    IN OUT DWORD *pcDomainName,
    OUT LPWSTR DomainName,
    IN OUT DWORD *pcRealmName,
    OUT LPWSTR RealmName
    );

#ifdef UNICODE
#define DsCrackSpn2 DsCrackSpn2W
#else
#define DsCrackSpn2 DsCrackSpn2A
#endif

#ifndef MIDL_PASS

DWORD
DsaopExecuteScript (
    IN  PVOID                  phAsync,
    IN  RPC_BINDING_HANDLE     hRpc,
    IN  DWORD                  cbPassword,
    IN  BYTE                  *pbPassword,
    OUT DWORD                 *dwOutVersion,
    OUT PVOID                  reply
    );

DWORD
DsaopPrepareScript ( 
    IN  PVOID                        phAsync,
    IN  RPC_BINDING_HANDLE           hRpc,
    OUT DWORD                        *dwOutVersion,
    OUT PVOID                        reply
    );
    
DWORD
DsaopBind(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  ULONG AuthnSvc,
    IN  ULONG AuthnLevel,
    OUT RPC_BINDING_HANDLE  *phRpc
    );

DWORD
DsaopBindWithCred(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN  ULONG AuthnSvc,
    IN  ULONG AuthnLevel,
    OUT RPC_BINDING_HANDLE  *phRpc
    );

DWORD
DsaopBindWithSpn(
    IN  LPCWSTR DomainControllerName,
    IN  LPCWSTR DnsDomainName,
    IN  RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN  ULONG AuthnSvc,
    IN  ULONG AuthnLevel,
    IN  LPCWSTR ServicePrincipalName,
    OUT RPC_BINDING_HANDLE  *phRpc
    );

DWORD
DsaopUnBind(
    RPC_BINDING_HANDLE  *phRpc
    );
    
#endif 

#endif // _NTDSAPIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\ntdsadef.h ===
/* Definitions from the NTDSA that are exposed to the rest of NT, but not
 * to the public at large.
 */

#define MAX_RDN_SIZE          255   /* The max size of an relative name value,
                                     * in Unicode characters */
#define MAX_RDN_KEY_SIZE      256    /* The max size of a RDN Key eg: "CN=" */
                                     /* or "OID.1.2...=" */
//
// This named event is set when the delayed start up thread is finished 
// successfully or otherwise.  In-proc clients can use 
// DsWaitUntilDelayedStartupIsDone() wait and recieve the ntstatus of the
// delayed thread.  Out of proc clients can wait on this event; there is 
// no mechanism to retrieve the return code.
//
#define NTDS_DELAYED_STARTUP_COMPLETED_EVENT TEXT("NtdsDelayedStartupCompletedEvent")


/*
 * Bit flags for the (read-only) system-Flags attribute.  Note that low order
 * bits are object class specific, and hence can have different meanings on
 * objects of different classes, the high order bits have constant meaning
 * across all object classes.
 */

/* Object Class independent bits */
// NOTE: These flags MAY have different behaviour in different NCs.
// For example, the FLAG_CONFIG_foo flags only have meaning inside the
// configuration NC.  the FLAG_DOMAIN_foo flags have meaning only outside the
// configuration NC.  
#define FLAG_DISALLOW_DELETE           0x80000000
#define FLAG_CONFIG_ALLOW_RENAME       0x40000000 
#define FLAG_CONFIG_ALLOW_MOVE         0x20000000 
#define FLAG_CONFIG_ALLOW_LIMITED_MOVE 0x10000000 
#define FLAG_DOMAIN_DISALLOW_RENAME    0x08000000
#define FLAG_DOMAIN_DISALLOW_MOVE      0x04000000
#define FLAG_DISALLOW_MOVE_ON_DELETE   0x02000000

/* Object Class specific bits, by object class */

/* CrossReference objects */
#define FLAG_CR_NTDS_NC       0x00000001 // NC is in NTDS (not VC or foreign)
#define FLAG_CR_NTDS_DOMAIN   0x00000002 // NC is a domain (not non-domain NC)
#define FLAG_CR_NTDS_NOT_GC_REPLICATED 0x00000004 // NC is not to be replicated to GCs as a read only replica.

/* Attribute-Schema objects */
#define FLAG_ATTR_NOT_REPLICATED         (0x00000001) // Attribute is not replicated
#define FLAG_ATTR_REQ_PARTIAL_SET_MEMBER (0x00000002) // Attribute is required to be
                                                      //   member of the partial set
#define FLAG_ATTR_IS_CONSTRUCTED         (0x00000004) // Attribute is a constructed att
#define FLAG_ATTR_IS_OPERATIONAL         (0x00000008) // Attribute is an operational att

/* Attribute-Schema or Class-Schema objects */
#define FLAG_SCHEMA_BASE_OBJECT          (0x00000010) // Base schema object

/* Attribute-Schema objects */
// A user may set, but not reset, FLAG_ATTR_IS_RDN in attributeSchema
// objects in the SchemaNC. The user sets FLAG_ATTR_IS_RDN to identify
// which of several attributes with the same attributeId should be
// used as the rdnattid of a new class. Once set, the attribute is
// treated as if it were used as the rdnattid of some class; meaning it
// cannot be reused.
#define FLAG_ATTR_IS_RDN                 (0x00000020) // can be used as key in rdn (key=rdn)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\ntrmlsa.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ntrmlsa.h

Abstract:

    Local Security Authority - Reference Monitor Communication Types

Author:

    Scott Birrell       (ScottBi)       March 18, 1991

Environment:

Revision History:

--*/


#include <ntlsa.h>

#ifndef _NTRMLSA_
#define _NTRMLSA_


//
// Memory type.  This defines the type of memory used for a record
// passed between the RM and LSA.
//
// SepRmLsaPortMemory - Memory allocated via RtlAllocateHeap()
//     from the shared memory section associated with the
//     Lsa command Port.
//
// SepRmLsaVirtualMemory - Memory allocated via ZwAllocateVirtualMemory()
//
// SepRmLsaUnreadableMemory - Memory not readable by the LSA.  This
//                            memory must be copied to another format
//                            before passage over the link.
//
// SepRmLsaLPCBufferMemory - Memory contained within the LPC buffer
// itself
//



typedef enum _SEP_RM_LSA_MEMORY_TYPE {

    SepRmNoMemory = 0,
    SepRmImmediateMemory,
    SepRmLsaCommandPortSharedMemory,
    SepRmLsaCustomSharedMemory,
    SepRmPagedPoolMemory,
    SepRmUnspecifiedMemory

} SEP_RM_LSA_MEMORY_TYPE, *PSEP_RM_LSA_MEMORY_TYPE;

//
// Reference Monitor Command Message Structure.  This structure is used
// by the Local Security Authority to send commands to the Reference Monitor
// via the Reference Monitor Server Command LPC Port.
//

#define RmMinimumCommand RmAuditSetCommand
#define RmMaximumCommand RmDeleteLogonSession

//
// Keep this in sync with SEP_RM_COMMAND_WORKER in se\rmmain.c
//

typedef enum _RM_COMMAND_NUMBER {

    RmDummyCommand = 0,
    RmAuditSetCommand,
    RmCreateLogonSession,
    RmDeleteLogonSession

} RM_COMMAND_NUMBER;

#define RM_MAXIMUM_COMMAND_PARAM_SIZE                                \
    ((ULONG) PORT_MAXIMUM_MESSAGE_LENGTH - sizeof(PORT_MESSAGE) -      \
    sizeof(RM_COMMAND_NUMBER))

typedef struct _RM_COMMAND_MESSAGE {

    PORT_MESSAGE MessageHeader;
    RM_COMMAND_NUMBER CommandNumber;
    UCHAR CommandParams[RM_MAXIMUM_COMMAND_PARAM_SIZE];

} RM_COMMAND_MESSAGE, *PRM_COMMAND_MESSAGE;

//
// Reference Monitor Command Reply Message Structure.
//

#define RM_MAXIMUM_REPLY_BUFFER_SIZE                                 \
    ((ULONG) PORT_MAXIMUM_MESSAGE_LENGTH - sizeof(PORT_MESSAGE) -      \
    sizeof(RM_COMMAND_NUMBER))


typedef struct _RM_REPLY_MESSAGE {

    PORT_MESSAGE MessageHeader;
    NTSTATUS ReturnedStatus;
    UCHAR ReplyBuffer[RM_MAXIMUM_REPLY_BUFFER_SIZE];

} RM_REPLY_MESSAGE, *PRM_REPLY_MESSAGE;

#define RM_COMMAND_MESSAGE_HEADER_SIZE                  \
    (sizeof(PORT_MESSAGE) + sizeof(NTSTATUS) + sizeof(RM_COMMAND_NUMBER))

//
// Local Security Authority Command Message Structure.  This structure is
// used by the Reference Monitor to send commands to the Local Security
// Authority via the LSA Server Command LPC Port.
//

#define LsapMinimumCommand LsapWriteAuditMessageCommand
#define LsapMaximumCommand LsapLogonSessionDeletedCommand

typedef enum _LSA_COMMAND_NUMBER {
    LsapDummyCommand = 0,
    LsapWriteAuditMessageCommand,
    LsapComponentTestCommand,
    LsapLogonSessionDeletedCommand
} LSA_COMMAND_NUMBER;

#define LSA_MAXIMUM_COMMAND_PARAM_SIZE                                \
    ((ULONG) PORT_MAXIMUM_MESSAGE_LENGTH - sizeof(PORT_MESSAGE) -     \
    sizeof(LSA_COMMAND_NUMBER) - sizeof(SEP_RM_LSA_MEMORY_TYPE))

typedef struct _LSA_COMMAND_MESSAGE {
    PORT_MESSAGE MessageHeader;
    LSA_COMMAND_NUMBER CommandNumber;
    SEP_RM_LSA_MEMORY_TYPE CommandParamsMemoryType;
    UCHAR CommandParams[LSA_MAXIMUM_COMMAND_PARAM_SIZE];
} LSA_COMMAND_MESSAGE, *PLSA_COMMAND_MESSAGE;

//
// LSA Command Reply Message Structure.
//

#define LSA_MAXIMUM_REPLY_BUFFER_SIZE                                 \
    ((ULONG) PORT_MAXIMUM_MESSAGE_LENGTH - sizeof(PORT_MESSAGE) -      \
    sizeof(LSA_COMMAND_NUMBER))

typedef struct _LSA_REPLY_MESSAGE {
    PORT_MESSAGE MessageHeader;
    NTSTATUS ReturnedStatus;
    UCHAR ReplyBuffer[LSA_MAXIMUM_REPLY_BUFFER_SIZE];
} LSA_REPLY_MESSAGE, *PLSA_REPLY_MESSAGE;

//
// Command Parameter format for the special RmSendCommandToLsaCommand
//

typedef struct _RM_SEND_COMMAND_TO_LSA_PARAMS {
    LSA_COMMAND_NUMBER LsaCommandNumber;
    ULONG LsaCommandParamsLength;
    UCHAR LsaCommandParams[LSA_MAXIMUM_COMMAND_PARAM_SIZE];
} RM_SEND_COMMAND_TO_LSA_PARAMS, *PRM_SEND_COMMAND_TO_LSA_PARAMS;

//
// Command Values for the LSA and RM Component Test Commands
//

#define LSA_CT_COMMAND_PARAM_VALUE 0x00823543
#define RM_CT_COMMAND_PARAM_VALUE 0x33554432


//
// Audit Record Pointer Field Type
//

typedef enum _SE_ADT_POINTER_FIELD_TYPE {

    NullFieldType,
    UnicodeStringType,
    SidType,
    PrivilegeSetType,
    MiscFieldType

} SE_ADT_POINTER_FIELD_TYPE, *PSE_ADT_POINTER_FIELD_TYPE;


//
// Hardwired Audit Event Type counts
//

#define AuditEventMinType   (AuditCategorySystem)
#define AuditEventMaxType   (AuditCategoryAccountLogon)

#define POLICY_AUDIT_EVENT_TYPE_COUNT                                 \
    ((ULONG) AuditEventMaxType - AuditEventMinType + 1)

#define LSARM_AUDIT_EVENT_OPTIONS_SIZE                                    \
    (((ULONG)(POLICY_AUDIT_EVENT_TYPE_COUNT) * sizeof (POLICY_AUDIT_EVENT_OPTIONS)))

//
// Self-Relative form of POLICY_AUDIT_EVENTS_INFO
//

typedef struct _LSARM_POLICY_AUDIT_EVENTS_INFO {

    BOOLEAN AuditingMode;
    POLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions[POLICY_AUDIT_EVENT_TYPE_COUNT];
    ULONG MaximumAuditEventCount;

} LSARM_POLICY_AUDIT_EVENTS_INFO, *PLSARM_POLICY_AUDIT_EVENTS_INFO;

//
// The following symbol defines the value containing whether or not we're supposed
// to crash when an audit fails.  It is used in the se and lsasrv directories.
//

#define CRASH_ON_AUDIT_FAIL_VALUE   L"CrashOnAuditFail"

//
// These are the possible values for the CrashOnAuditFail flag.
//

#define LSAP_CRASH_ON_AUDIT_FAIL 1
#define LSAP_ALLOW_ADIMIN_LOGONS_ONLY 2



#endif // _NTRMLSA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\ntfrsipi.h ===
/*++ BUILD Version: 0001    Increment if a change has global effects

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ntfrsipi.h

Abstract:

    Header file for the internal programmer's interfaces
    to the File Replication Service (NtFrs).

    Functions are in ntfrsapi.dll.

Environment:

    User Mode - Win32

Notes:

--*/
#ifndef _NTFRSIPI_H_
#define _NTFRSIPI_H_

#ifdef __cplusplus
extern "C" {
#endif

DWORD
WINAPI
NtFrsApi_PrepareForPromotionW(
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function prepares the NtFrs service on this machine for
    promotion by stopping the service, deleting old promotion
    state in the registry, and restarting the service.

    This function is not idempotent and isn't MT safe.

Arguments:

    None.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_PrepareForDemotionW(
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function prepares the NtFrs service on this machine for
    demotion by stopping the service, deleting old demotion
    state in the registry, and restarting the service.

    This function is not idempotent and isn't MT safe.

Arguments:

    None.

Return Value:

    Win32 Status
--*/

//
// Replica set types for parameter ReplicaSetType below
//
#define NTFRSAPI_REPLICA_SET_TYPE_ENTERPRISE    L"Enterprise"
#define NTFRSAPI_REPLICA_SET_TYPE_DOMAIN        L"Domain"
#define NTFRSAPI_REPLICA_SET_TYPE_DFS           L"DFS"
#define NTFRSAPI_REPLICA_SET_TYPE_OTHER         L"Other"

#define NTFRSAPI_SERVICE_STATE_IS_UNKNOWN   (00)
#define NTFRSAPI_SERVICE_PROMOTING          (10)
#define NTFRSAPI_SERVICE_DEMOTING           (20)
#define NTFRSAPI_SERVICE_DONE               (99)
DWORD
WINAPI
NtFrsApi_StartPromotionW(
    IN PWCHAR   ParentComputer,                         OPTIONAL
    IN PWCHAR   ParentAccount,                          OPTIONAL
    IN PWCHAR   ParentPassword,                         OPTIONAL
    IN DWORD    DisplayCallBack(IN PWCHAR Display),     OPTIONAL
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG),     OPTIONAL
    IN PWCHAR   ReplicaSetName,
    IN PWCHAR   ReplicaSetType,
    IN DWORD    ReplicaSetPrimary,
    IN PWCHAR   ReplicaSetStage,
    IN PWCHAR   ReplicaSetRoot
    );
/*++
Routine Description:

    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function kicks off a thread that updates the sysvol information
    in the registry and initiates the seeding process. The thread tracks
    the progress of the seeding and periodically informs the caller.

    The threads started by NtFrsApi_StartPromotionW can be forcefully
    terminated with NtFrsApi_AbortPromotionW.

    The threads started by NtFrsApi_StartPromotionW can be waited on
    with NtFrsApi_WaitForPromotionW.

Arguments:

    ParentComputer      - An RPC-bindable name of the computer that is
                          supplying the Directory Service (DS) with its
                          initial state. The files and directories for
                          the system volume are replicated from this
                          parent computer.
    ParentAccount       - A logon account on ParentComputer.
    ParentPassword      - The logon account's password on ParentComputer.
    DisplayCallBack     - Called periodically with a progress display.
    ReplicaSetName      - Name of the replica set.
    ReplicaSetType      - Type of replica set (enterprise or domain)
    ReplicaSetPrimary   - Is this the primary member of the replica set?
                        - 1 = primary; 0 = not.
    ReplicaSetStage     - Staging path.
    ReplicaSetRoot      - Root path.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_StartDemotionW(
    IN PWCHAR   ReplicaSetName,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function kicks off a thread that stops replication of the
    system volume on this machine by telling the NtFrs service on
    this machine to tombstone the system volume's replica set.

    The threads started by NtFrsApi_StartDemotionW can be forcefully
    terminated with NtFrsApi_AbortDemotionW.

    The threads started by NtFrsApi_StartDemotionW can be waited on
    with NtFrsApi_WaitForDemotionW.

Arguments:

    ReplicaSetName      - Name of the replica set.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_WaitForPromotionW(
    IN DWORD    TimeoutInMilliSeconds,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function waits for the seeding to finish or to stop w/error.

Arguments:

    TimeoutInMilliSeconds    - Timeout in milliseconds for waiting for
                               seeding to finish. INFINITE if no timeout.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_WaitForDemotionW(
    IN DWORD    TimeoutInMilliSeconds,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function waits for the tombstoning to finish or to stop w/error.

Arguments:

    TimeoutInMilliSeconds    - Timeout in milliseconds for waiting for
                               seeding to finish. INFINITE if no timeout.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_CommitPromotionW(
    IN DWORD    TimeoutInMilliSeconds,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    WARNING - This function assumes the caller will reboot the system
    soon after this call!

    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function waits for the seeding to finish, stops the service,
    and commits the state in the registry. On reboot, the NtFrs Service
    updates the DS on this machine with the information in the registry.

Arguments:

    TimeoutInMilliSeconds    - Timeout in milliseconds for waiting for
                               seeding to finish. INFINITE if no timeout.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_CommitDemotionW(
    IN DWORD    TimeoutInMilliSeconds,
    IN DWORD    ErrorCallBack(IN PWCHAR, IN ULONG)     OPTIONAL
    );
/*++
Routine Description:

    WARNING - This function assumes the caller will reboot the system
    soon after this call!

    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.
    Replication is stopped by tombstoning the system volume's replica
    set.

    This function waits for the tombstoning to finish, tells the service
    to forcibly delete the system volumes' replica sets, stops the service,
    and commits the state in the registry. On reboot, the NtFrs Service
    updates the DS on this machine with the information in the registry.

Arguments:

    TimeoutInMilliSeconds    - Timeout in milliseconds for waiting for
                               tombstoning to finish. INFINITE if no timeout.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_AbortPromotionW(
    VOID
    );
/*++
Routine Description:

    The NtFrs service seeds the system volume during the promotion
    of a server to a Domain Controller (DC). The files and directories
    for the system volume come from the same machine that is supplying
    the initial Directory Service (DS).

    This function aborts the seeding process by stopping the service,
    deleting the promotion state out of the registry, cleaning up
    the active threads and the active RPC calls, and finally resetting
    the service to its pre-seeding state.

Arguments:

    None.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_AbortDemotionW(
    VOID
    );
/*++
Routine Description:

    The NtFrs service replicates the enterprise system volume to all
    Domain Controllers (DCs) and replicates the domain system volume
    to the DCs in a domain until the DC is demoted to a member server.

    During demotion, NtFrsApi_StartDemotionW stops replication of
    the system volume on this machine by telling the NtFrs service
    on this machine to tombstone the system volume's replica set.

    This function aborts the tombstoning process by stopping the service,
    deleting the demotion state out of the registry, cleaning up
    the active threads and the active RPC calls, and finally resetting
    the service to its pre-tombstoning state.

Arguments:

    None.

Return Value:

    Win32 Status
--*/

#define NTFRSAPI_MAX_INTERVAL           ((((ULONG)0x7FFFFFFF) / 1000) / 60)
#define NTFRSAPI_MIN_INTERVAL           (1)
#define NTFRSAPI_DEFAULT_LONG_INTERVAL  (1 * 60)    // 1 hour
#define NTFRSAPI_DEFAULT_SHORT_INTERVAL (5)         // 5 minutes

DWORD
WINAPI
NtFrsApi_Set_DsPollingIntervalW(
    IN PWCHAR   ComputerName,       OPTIONAL
    IN ULONG    UseShortInterval,
    IN ULONG    LongInterval,
    IN ULONG    ShortInterval
    );
/*++
Routine Description:

    The NtFrs service polls the DS occasionally for configuration changes.
    This API alters the polling interval and, if the service is not
    in the middle of a polling cycle, forces the service to begin a
    polling cycle.

    The service uses the long interval by default. The short interval
    is used after the ds configuration has been successfully
    retrieved and the service is now verifying that the configuration
    is not in flux. This API can be used to force the service to use
    the short interval until a stable configuration has been retrieved.
    After which, the service reverts back to the long interval.

    The default values for ShortInterval and LongInterval can be
    changed by setting the parameters to a non-zero value. If zero,
    the current values remain unchanged and a polling cycle is initiated.

Arguments:

    ComputerName     - Poke the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.

    UseShortInterval - If non-zero, the service switches to the short
                       interval until a stable configuration is retrieved
                       from the DS or another call to this API is made.
                       Otherwise, the service uses the long interval.

    LongInterval     - Minutes between polls of the DS. The value must fall
                       between NTFRSAPI_MIN_INTERVAL and NTFRSAPI_MAX_INTERVAL,
                       inclusive. If 0, the interval is unchanged.

    ShortInterval    - Minutes between polls of the DS. The value must fall
                       between NTFRSAPI_MIN_INTERVAL and NTFRSAPI_MAX_INTERVAL,
                       inclusive. If 0, the interval is unchanged.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_Get_DsPollingIntervalW(
    IN  PWCHAR  ComputerName,       OPTIONAL
    OUT ULONG   *Interval,
    OUT ULONG   *LongInterval,
    OUT ULONG   *ShortInterval
    );
/*++
Routine Description:

    The NtFrs service polls the DS occasionally for configuration changes.
    This API returns the values the service uses for polling intervals.

    The service uses the long interval by default. The short interval
    is used after the ds configuration has been successfully
    retrieved and the service is now verifying that the configuration
    is not in flux. The short interval is also used if the
    NtFrsApi_Set_DsPollingIntervalW() is used to force usage of the short
    interval until a stable configuration has been retrieved. After which,
    the service reverts back to the long interval.

    The value returned in Interval is the polling interval currently in
    use.

Arguments:

    ComputerName     - Poke the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.

    Interval         - The current polling interval in minutes.

    LongInterval     - The long interval in minutes.

    ShortInterval    - The short interval in minutes.

Return Value:

    Win32 Status
--*/

//
// Type of internal information returned by NtFrsApi_InfoW()
//
#define NTFRSAPI_INFO_TYPE_MIN       (0)
#define NTFRSAPI_INFO_TYPE_VERSION   (0)
#define NTFRSAPI_INFO_TYPE_SETS      (1)
#define NTFRSAPI_INFO_TYPE_DS        (2)
#define NTFRSAPI_INFO_TYPE_MEMORY    (3)
#define NTFRSAPI_INFO_TYPE_IDTABLE   (4)
#define NTFRSAPI_INFO_TYPE_OUTLOG    (5)
#define NTFRSAPI_INFO_TYPE_INLOG     (6)
#define NTFRSAPI_INFO_TYPE_MAX       (6)

//
// Internal constants
//
#define NTFRSAPI_DEFAULT_INFO_SIZE  (32 * 1024)
#define NTFRSAPI_MINIMUM_INFO_SIZE  ( 1 * 1024)

//
// Opaque information from NtFrs.
// Parse with NtFrsApi_InfoLineW().
// Free with NtFrsApi_InfoFreeW();
//
typedef struct _NTFRSAPI_INFO {
    ULONG   Major;
    ULONG   Minor;
    ULONG   NtFrsMajor;
    ULONG   NtFrsMinor;
    ULONG   SizeInChars;
    ULONG   Flags;
    ULONG   TypeOfInfo;
    ULONG   TotalChars;
    ULONG   CharsToSkip;
    ULONG   OffsetToLines;
    ULONG   OffsetToFree;
    CHAR    Lines[1];
} NTFRSAPI_INFO, *PNTFRSAPI_INFO;
//
// RPC Blob must be at least this size
//
#define NTFRSAPI_INFO_HEADER_SIZE   (5 * sizeof(ULONG))

//
// NtFrsApi Information Flags
//
#define NTFRSAPI_INFO_FLAGS_VERSION (0x00000001)
#define NTFRSAPI_INFO_FLAGS_FULL    (0x00000002)

DWORD
WINAPI
NtFrsApi_InfoW(
    IN     PWCHAR  ComputerName,       OPTIONAL
    IN     ULONG   TypeOfInfo,
    IN     ULONG   SizeInChars,
    IN OUT PVOID   *NtFrsApiInfo
    );
/*++
Routine Description:
    Return a buffer full of the requested information. The information
    can be extracted from the buffer with NtFrsApi_InfoLineW().

    *NtFrsApiInfo should be NULL on the first call. On subsequent calls,
    *NtFrsApiInfo will be filled in with more data if any is present.
    Otherwise, *NtFrsApiInfo is set to NULL and the memory is freed.

    The SizeInChars is a suggested size; the actual memory usage
    may be different. The function chooses the memory usage if
    SizeInChars is 0.

    The format of the returned information can change without notice.

Arguments:
    ComputerName     - Poke the service on this computer. The computer
                       name can be any RPC-bindable name. Usually, the
                       NetBIOS or DNS name works just fine. The NetBIOS
                       name can be found with GetComputerName() or
                       hostname. The DNS name can be found with
                       gethostbyname() or ipconfig /all. If NULL, the
                       service on this computer is contacted. The service
                       is contacted using Secure RPC.

    TypeOfInfo      - See the constants beginning with NTFRSAPI_INFO_
                      in ntfrsapi.h.

    SizeInChars     - Suggested memory usage; actual may be different.
                      0 == Function chooses memory usage

    NtFrsApiInfo    - Opaque. Parse with NtFrsApi_InfoLineW().
                      Free with NtFrsApi_InfoFreeW();

Return Value:
    Win32 Status
--*/

DWORD
WINAPI
NtFrsApi_InfoLineW(
    IN      PNTFRSAPI_INFO  NtFrsApiInfo,
    IN OUT  PVOID           *InOutLine
    );
/*++
Routine Description:
    Extract the wchar lines of information from NtFrsApiInformation.

    Returns the address of the next L'\0' terminated line of information.
    NULL if none.

Arguments:
    NtFrsApiInfo    - Opaque. Returned by NtFrsApi_InfoW().
                      Parse with NtFrsApi_InfoLineW().
                      Free with NtFrsApi_InfoFreeW().

Return Value:
    Win32 Status
--*/

BOOL
WINAPI
NtFrsApi_InfoMoreW(
    IN  PNTFRSAPI_INFO  NtFrsApiInfo
    );
/*++
Routine Description:
    All of the information may not have fit in the buffer. The additional
    information can be fetched by calling NtFrsApi_InfoW() again with the
    same NtFrsApiInfo struct. NtFrsApi_InfoW() will return NULL in
    NtFrsApiInfo if there is no more information.

    However, the information returned in subsequent calls to _InfoW() may be
    out of sync with the previous information. If the user requires a
    coherent information set, then the information buffer should be freed
    with NtFrsApi_InfoFreeW() and another call made to NtFrsApi_InfoW()
    with an increased SizeInChars. Repeat the procedure until
    NtFrsApi_InfoMoreW() returns FALSE.

Arguments:
    NtFrsApiInfo - Opaque. Returned by NtFrsApi_InfoW().
                   Parse with NtFrsApi_InfoLineW().
                   Free with NtFrsApi_InfoFreeW().

Return Value:
    TRUE    - The information buffer does *NOT* contain all of the info.
    FALSE   - The information buffer does contain all of the info.
--*/

DWORD
WINAPI
NtFrsApi_InfoFreeW(
    IN  PVOID   *NtFrsApiInfo
    );
/*++
Routine Description:
    Free the information buffer allocated by NtFrsApi_InfoW();

Arguments:
    NtFrsApiInfo - Opaque. Returned by NtFrsApi_InfoW().
                   Parse with NtFrsApi_InfoLineW().
                   Free with NtFrsApi_InfoFreeW().

Return Value:
    Win32 Status
--*/

//
// BACKUP/RESTORE API
//
#define NTFRSAPI_BUR_FLAGS_NONE                         (0x00000000)
#define NTFRSAPI_BUR_FLAGS_AUTHORITATIVE                (0x00000001)
#define NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE            (0x00000002)
#define NTFRSAPI_BUR_FLAGS_PRIMARY                      (0x00000004)
#define NTFRSAPI_BUR_FLAGS_SYSTEM                       (0x00000008)
#define NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY             (0x00000010)
#define NTFRSAPI_BUR_FLAGS_NORMAL                       (0x00000020)
#define NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES  (0x00000040)
#define NTFRSAPI_BUR_FLAGS_RESTORE                      (0x00000080)
#define NTFRSAPI_BUR_FLAGS_BACKUP                       (0x00000100)
#define NTFRSAPI_BUR_FLAGS_RESTART                      (0x00000200)

#define NTFRSAPI_BUR_FLAGS_TYPES_OF_RESTORE \
                    (NTFRSAPI_BUR_FLAGS_AUTHORITATIVE       | \
                     NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE   | \
                     NTFRSAPI_BUR_FLAGS_PRIMARY)

#define NTFRSAPI_BUR_FLAGS_MODES_OF_RESTORE \
                    (NTFRSAPI_BUR_FLAGS_SYSTEM           | \
                     NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY | \
                     NTFRSAPI_BUR_FLAGS_NORMAL)

#define NTFRSAPI_BUR_FLAGS_SUPPORTED_RESTORE \
                    (NTFRSAPI_BUR_FLAGS_AUTHORITATIVE        | \
                     NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE    | \
                     NTFRSAPI_BUR_FLAGS_PRIMARY              | \
                     NTFRSAPI_BUR_FLAGS_SYSTEM               | \
                     NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY     | \
                     NTFRSAPI_BUR_FLAGS_NORMAL               | \
                     NTFRSAPI_BUR_FLAGS_RESTORE              | \
                     NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES)

#define NTFRSAPI_BUR_FLAGS_SUPPORTED_BACKUP \
                    (NTFRSAPI_BUR_FLAGS_NORMAL | \
                     NTFRSAPI_BUR_FLAGS_BACKUP)
DWORD
WINAPI
NtFrsApiInitializeBackupRestore(
    IN  DWORD   ErrorCallBack(IN PWCHAR, IN ULONG), OPTIONAL
    IN  DWORD   BurFlags,
    OUT PVOID   *BurContext
    );
/*++
Routine Description:
    Called once in the lifetime of a backup/restore process. Must be
    matched with a subsequent call to NtFrsApiDestroyBackupRestore().

    Prepare the system for the backup or restore specified by BurFlags.
    Currently, the following combinations are supported:
    ASR - Automated System Recovery
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_SYSTEM |
        NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES |
        NTFRSAPI_BUR_FLAGS_PRIMARY or NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE

    DSR - Distributed Services Restore (all sets)
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY |
        NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES |
        NTFRSAPI_BUR_FLAGS_PRIMARY or NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE

    DSR - Distributed Services Restore (just the sysvol)
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY
        (may be followed by subsequent calls to NtFrsApiRestoringDirectory())

    Normal Restore - System is up and running; just restoring files
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_NORMAL |
        NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES |
        NTFRSAPI_BUR_FLAGS_AUTHORITATIVE

    Normal Backup
        NTFRSAPI_BUR_FLAGS_BACKUP |
        NTFRSAPI_BUR_FLAGS_NORMAL

Arguments:
    ErrorCallBack   - Ignored if NULL.
                      Address of function provided by the caller. If
                      not NULL, this function calls back with a formatted
                      error message and the error code that caused the
                      error.
    BurFlags        - See above for the supported combinations
    BurContext      - Opaque context for this process

Return Value:

    Win32 Status

--*/

DWORD
WINAPI
NtFrsApiDestroyBackupRestore(
    IN     PVOID    *BurContext,
    IN     DWORD    BurFlags,
    OUT    HKEY     *HKey,
    IN OUT DWORD    *KeyPathSizeInBytes,
    OUT    PWCHAR   KeyPath
    );
/*++
Routine Description:
    Called once in the lifetime of a backup/restore process. Must be
    matched with a previous call to NtFrsApiInitializeBackupRestore().

    If NtFrsApiInitializeBackupRestore() was called with:
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_SYSTEM or NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY
    then BurFlags may be set to one of:
        NTFRSAPI_BUR_FLAGS_NONE - Do not restart the service. The key
            specified by (HKey, KeyPath) must be moved into the final
            registry.
        NTFRSAPI_BUR_FLAGS_RESTART - Restart the service. HKey,
            KeyPathSizeInBytes, and KeyPath must be NULL.

    If NtFrsApiInitializeBackupRestore() was not called the above flags,
    then BurFlags must be NTFRSAPI_BUR_FLAGS_NONE and HKey, KeyPathSizeInBytes,
    and KeyPath must be NULL.

Arguments:
    BurContext          - Returned by previous call to
                          NtFrsApiInitializeBackupRestore().

    BurFlags            - Backup/Restore Flags. See Routine Description.

    HKey                - Address of a HKEY for that will be set to
                          HKEY_LOCAL_MACHINE, ...
                          NULL if BurContext is not for a System or
                          Active Directory restore or Restart is set.

    KeyPathSizeInBytes  - Address of of a DWORD specifying the size of
                          KeyPath. Set to the actual number of bytes
                          needed by KeyPath. ERROR_INSUFFICIENT_BUFFER
                          is returned if the size of KeyPath is too small.
                          NULL if BurContext is not for a System or
                          Active Directory restore or Restart is set.

    KeyPath             - Buffer to receive the path of the registry key.
                          NULL if BurContext is not for a System or
                          Active Directory restore or Restart is set.

Return Value:

    Win32 Status

--*/

DWORD
WINAPI
NtFrsApiGetBackupRestoreSets(
    IN PVOID BurContext
    );
/*++
Routine Description:
    Cannot be called if BurContext is for a System restore.

    Retrieves information about the current replicated directories
    (AKA replica sets).

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()

Return Value:

    Win32 Status

--*/

DWORD
WINAPI
NtFrsApiEnumBackupRestoreSets(
    IN  PVOID   BurContext,
    IN  DWORD   BurSetIndex,
    OUT PVOID   *BurSet
    );
/*++
Routine Description:
    Returns ERROR_NO_MORE_ITEMS if BurSetIndex exceeds the number of
    sets returned by NtFrsApiGetBackupRestoreSets().

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()
    BurSetIndex - Index of set. Starts at 0.
    BurSet      - Opaque struct representing a replicating directory.

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApiIsBackupRestoreSetASysvol(
    IN PVOID    BurContext,
    IN PVOID    BurSet,
    IN BOOL     *IsSysvol
    );
/*++
Routine Description:
    Does the specified BurSet represent a replicating SYSVOL share?

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()
    BurSet      - Opaque struct representing a replicating directory.
                  Returned by NtFrsApiEnumBackupRestoreSets(). Not
                  valid across calls to NtFrsApiGetBackupRestoreSets().
    IsSysvol    - TRUE : set is a system volume (AKA SYSVOL).
                  FALSE: set is a not a system volume (AKA SYSVOL).

Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApiGetBackupRestoreSetDirectory(
    IN     PVOID    BurContext,
    IN     PVOID    BurSet,
    IN OUT DWORD    *DirectoryPathSizeInBytes,
    OUT    PWCHAR   DirectoryPath
    );
/*++
Routine Description:
    Return the path of the replicating directory represented by BurSet.

Arguments:
    BurContext  - From NtFrsApiInitializeBackupRestore()
    BurSet      - Opaque struct representing a replicating directory.
                  Returned by NtFrsApiEnumBackupRestoreSets(). Not
                  valid across calls to NtFrsApiGetBackupRestoreSets().
    DirectoryPathSizeInBytes    - Address of DWORD giving size of
                                  DirectoryPath. Cannot be NULL.
                                  Set to the number of bytes needed
                                  to return DirectoryPath.
                                  ERROR_INSUFFICIENT_BUFFER is returned if
                                  DirectoryPath is too small.
    DirectoryPath               - Buffer that is *DirectoryPathSizeInBytes
                                  bytes in length. Contains path of replicating
                                  directory.
Return Value:

    Win32 Status
--*/

DWORD
WINAPI
NtFrsApiRestoringDirectory(
    IN  PVOID   BurContext,
    IN  PVOID   BurSet,
    IN  DWORD   BurFlags
    );
/*++
Routine Description:
    The backup/restore application is about to restore the directory
    specified by BurSet (See NtFrsApiEnumBackupRestoreSets()). Matched
    with a later call to NtFrsApiFinishedRestoringDirectory().

    This call is supported only if NtFrsApiInitializeBackupRestore()
    were called with the flags:
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY

    BurFlags can be NTFRSAPI_BUR_FLAGS_PRIMARY or
    NTFRSAPI_BUR_FLAGS_NON_AUTHORITATIVE and overrides any value
    specified in the call to NtFrsApiInitializeBackupRestore().

Arguments:
    BurContext      - Opaque context from NtFrsApiInitializeBackupRestore()
    BurSet          - Opaque set from NtFrsApiEnumBackupRestoreSets();
    BurFlags        - See above for the supported combinations

Return Value:

    Win32 Status

--*/

DWORD
WINAPI
NtFrsApiFinishedRestoringDirectory(
    IN  PVOID   BurContext,
    IN  PVOID   BurSet,
    IN  DWORD   BurFlags
    );
/*++
Routine Description:
    Finished restoring directory for BurSet. Matched by a previous call
    to NtFrsApiRestoringDirectory().

    This call is supported only if NtFrsApiInitializeBackupRestore()
    were called with the flags:
        NTFRSAPI_BUR_FLAGS_RESTORE |
        NTFRSAPI_BUR_FLAGS_ACTIVE_DIRECTORY

    BurFlags must be NTFRSAPI_BUR_FLAGS_NONE.

Arguments:
    BurContext      - Opaque context from NtFrsApiInitializeBackupRestore()
    BurSet          - Opaque set from NtFrsApiEnumBackupRestoreSets();
    BurFlags        - See above for the supported combinations

Return Value:

    Win32 Status

--*/

#ifdef __cplusplus
}
#endif

#endif  _NTFRSIPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\nwapi.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    api.h

Abstract:

    This module contains exposed APIs that is used by the
    NetWare Control Panel Applet.

Author:

    Yi-Hsin Sung   15-Jul-1993

Revision History:

--*/

#ifndef _NWAPI_INCLUDED_
#define _NWAPI_INCLUDED_

#include <nwcons.h>

//
// Bitmask for print options
//

#define NW_PRINT_SUPPRESS_FORMFEED    0x08
#define NW_PRINT_PRINT_BANNER         0x80
#define NW_PRINT_PRINT_NOTIFY         0x10

//
// Flags for logon script support.
//

#define NW_LOGONSCRIPT_DISABLED       0x00000000
#define NW_LOGONSCRIPT_ENABLED        0x00000001
#define NW_LOGONSCRIPT_4X_ENABLED     0x00000002
#define NW_LOGONSCRIPT_DEFAULT        NW_LOGONSCRIPT_DISABLED
#define NW_LOGONSCRIPT_DEBUG          0x00000800

//
// Values for turning on Sync login script flags.
//

#define SYNC_LOGONSCRIPT             0x1
#define RESET_SYNC_LOGONSCRIPT       0x2

//
// Bitmask for gateway redirections
//
#define NW_GW_UPDATE_REGISTRY         0x01
#define NW_GW_CLEANUP_DELETED         0x02

#ifdef __cplusplus
extern "C" {
#endif

DWORD
NwQueryInfo(
    OUT PDWORD pnPrintOption,
    OUT LPWSTR *ppszPreferredSrv
    );

DWORD
NwSetInfoInRegistry(
    IN DWORD  nPrintOption,
    IN LPWSTR pszPreferredSrv
    );

DWORD
NwSetLogonOptionsInRegistry(
    IN DWORD  nLogonScriptOptions
    );

DWORD
NwQueryLogonOptions(
    OUT PDWORD  pnLogonScriptOptions
    );

DWORD
NwSetInfoInWksta(
    IN DWORD  nPrintOption,
    IN LPWSTR pszPreferredSrv
    );

DWORD
NwSetLogonScript(
    IN DWORD  ScriptOptions
    );

DWORD
NwValidateUser(
    IN LPWSTR pszPreferredSrv
);

DWORD
NwEnumGWDevices(
    LPDWORD Index,
    LPBYTE Buffer,
    DWORD BufferSize,
    LPDWORD BytesNeeded,
    LPDWORD EntriesRead
    ) ;

DWORD
NwAddGWDevice(
    LPWSTR DeviceName,
    LPWSTR RemoteName,
    LPWSTR AccountName,
    LPWSTR Password,
    DWORD  Flags
    ) ;

DWORD
NwDeleteGWDevice(
    LPWSTR DeviceName,
    DWORD  Flags
    ) ;

DWORD
NwEnumConnections(
    HANDLE  hEnum,
    LPDWORD lpcCount,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize,
    BOOL    fImplicitConnections
    );

DWORD
NwLibSetEverybodyPermission(
    HKEY   hKey,
    DWORD  dwAccessPermission
    );

DWORD
NwQueryGatewayAccount(
    LPWSTR   AccountName,
    DWORD    AccountNameLen,
    LPDWORD  AccountCharsNeeded,
    LPWSTR   Password,
    DWORD    PasswordLen,
    LPDWORD  PasswordCharsNeeded
    );

DWORD
NwSetGatewayAccount(
    LPWSTR AccountName,
    LPWSTR Password
    );

DWORD
NwLogonGatewayAccount(
    LPWSTR AccountName,
    LPWSTR Password,
    LPWSTR Server
    );

DWORD
NwRegisterGatewayShare(
    IN LPWSTR ShareName,
    IN LPWSTR DriveName
    );

DWORD
NwClearGatewayShare(
    IN LPWSTR ShareName
    );

DWORD
NwCleanupGatewayShares(
    VOID
    );


VOID
MapSpecialJapaneseChars(
    LPSTR       lpszA,
    WORD        length
    );

VOID
UnmapSpecialJapaneseChars(
    LPSTR       lpszA,
    WORD        length
    );

LPSTR
NwDupStringA(
    const LPSTR lpszA,
    WORD        length
    );

#ifdef __cplusplus
} // extern "C"
#endif

#define NwFreeStringA(lp) if((lp) != NULL) { (void)LocalFree((lp)); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\ntsamp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntsamp.h

Abstract:

    This file contains structures that would normally be part of ntsam.h
    but are intended for system use only.

Author:

    David Chalmers (Davidc) 27-Mar-1992

Environment:

    User Mode - Win32

Revision History:


--*/


#ifndef _NTSAMPRIVATE_
#define _NTSAMPRIVATE_



#include <crypt.h>
#include <lsass.h>




//
// Structures usable in SetUserInformation and QueryUserInformation API calls
// by trusted clients only
//


typedef struct _USER_INTERNAL1_INFORMATION {
    NT_OWF_PASSWORD             NtOwfPassword;
    LM_OWF_PASSWORD             LmOwfPassword;
    BOOLEAN                     NtPasswordPresent;
    BOOLEAN                     LmPasswordPresent;
    BOOLEAN                     PasswordExpired; // A 'write-only' flag
} USER_INTERNAL1_INFORMATION, *PUSER_INTERNAL1_INFORMATION;


typedef struct _USER_INTERNAL2_INFORMATION {
    ULONG StatisticsToApply;
    OLD_LARGE_INTEGER LastLogon;
    OLD_LARGE_INTEGER LastLogoff;
    USHORT BadPasswordCount;
    USHORT LogonCount;
} USER_INTERNAL2_INFORMATION;

typedef struct _USER_INTERNAL2A_INFORMATION {
    ULONG StatisticsToApply;
    OLD_LARGE_INTEGER LastLogon;
    OLD_LARGE_INTEGER LastLogoff;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    UNICODE_STRING Workstation;
} USER_INTERNAL2A_INFORMATION, *PUSER_INTERNAL2A_INFORMATION;

//
//
//
// The following flags may be used in the StatisticsToApply field.
//
//   USER_LOGON_STAT_LAST_LOGOFF - Replace the LastLogoff time in the
//      user record.
//
//  USER_LOGON_STATUS_LAST_LOGON - Replace the LastLogon time in the
//      user record.
//
//  USER_LOGON_STATUS_BAD_PWD_COUNT  - Replace the BadPasswordCount
//      field in the user record.
//
//  USER_LOGON_STATUS_LOGON_COUNT - Replace the LogonCount field in the
//      user record.
//
//  USER_LOGON_SUCCESSFUL_LOGON - Change user field values to indicate
//      that a successful logon has occurred.
//
//  USER_LOGON_SUCCESSFUL_LOGOFF - Change user field values to indicate
//      that a successful logoff has occurred.
//
//  USER_LOGON_BAD_PASSWORD - Change user field values to indicate that
//      an attempt was made to logon to the account with a bad password.
//
//  USER_LOGON_BAD_PASSWORD_WKSTA - Change user field values to indicate that
//      an attempt was made to logon to the account with a bad password.
//      The client workstation name is being supplied in the INTERNAL2A
//      structure.
//
//  USER_LOGON_TYPE_KERBEROS - Indicates the authentication type was
//                             KERBEROS.
//
//  USER_LOGON_TYPE_NTLM - Indicates the authentication type was NTLM.
//
//  USER_LOGON_NO_LOGON_SERVERS -- Indicates that no logon servers could be
//                                 found (specifically no GC's could be found)
//                                 (this is a failure case).
//
//  USER_LOGON_NO_WRITE -- Indicates to SAM not to update the logon statistics
//                         This can be useful to notify SAM that a logon 
//                         has completed, but not have the penalty of writing
//                         to the disk
//
//  USER_LOGON_INTER_FAILURE -- this indicates that it was an interactive
//                              logon that failed
//
// NOTE:
//          USER_LOGON_INTER_SUCCESS_LOGOFF
//          USER_LOGON_NET_SUCCESS_LOGOFF
//
// may not be used in conjunction with ANY other flags (including
// each other).  That is, when one of these flags is used, there
// may be NO other flags set in StatisticsToApply.
//
// NOTE2:
//
//          USER_LOGON_BAD_PASSWORD
//          USER_LOGON_INTER_SUCCESS_LOGON
//          USER_LOGON_NET_SUCCESS_LOGON
//
// may be used in conjunction ONLY with ONE of USER_LOGON_TYPE_KERBEROS or
// USER_LOGON_TYPE_NTLM.

#define USER_LOGON_STAT_LAST_LOGOFF      (0x00000001L)
#define USER_LOGON_STAT_LAST_LOGON       (0x00000002L)
#define USER_LOGON_STAT_BAD_PWD_COUNT    (0x00000004L)
#define USER_LOGON_STAT_LOGON_COUNT      (0x00000008L)

#define USER_LOGON_INTER_FAILURE         (0x00200000L)
#define USER_LOGON_NO_WRITE              (0x00400000L)
#define USER_LOGON_NO_LOGON_SERVERS      (0x00800000L)
#define USER_LOGON_TYPE_NTLM             (0x02000000L)
#define USER_LOGON_TYPE_KERBEROS         (0x04000000L)
#define USER_LOGON_BAD_PASSWORD          (0x08000000L)
#define USER_LOGON_INTER_SUCCESS_LOGON   (0x01000000L)
#define USER_LOGON_BAD_PASSWORD_WKSTA    (0x10000000L)
#define USER_LOGON_INTER_SUCCESS_LOGOFF  (0x20000000L)
#define USER_LOGON_NET_SUCCESS_LOGON     (0x40000000L)
#define USER_LOGON_NET_SUCCESS_LOGOFF    (0x80000000L)


typedef struct _USER_INTERNAL3_INFORMATION {
    USER_ALL_INFORMATION I1;
    LARGE_INTEGER       LastBadPasswordTime;
} USER_INTERNAL3_INFORMATION,  *PUSER_INTERNAL3_INFORMATION;


typedef struct _USER_ALLOWED_TO_DELEGATE_TO_LIST {
    ULONG		Size;
    ULONG		NumSPNs;
	UNICODE_STRING SPNList[ANYSIZE_ARRAY];
} USER_ALLOWED_TO_DELEGATE_TO_LIST, *PUSER_ALLOWED_TO_DELEGATE_TO_LIST; 

typedef struct _USER_INTERNAL6_INFORMATION {
	USER_ALL_INFORMATION I1;
	LARGE_INTEGER       LastBadPasswordTime;
	ULONG               ExtendedFields;
	BOOLEAN             UPNDefaulted;
	UNICODE_STRING      UPN;
	PUSER_ALLOWED_TO_DELEGATE_TO_LIST A2D2List;
} USER_INTERNAL6_INFORMATION, *PUSER_INTERNAL6_INFORMATION;

//
// The following fields are to be used in the extended fields
// member of USER_INTERNAL6_INFORMATION
//


#define USER_EXTENDED_FIELD_UPN			(0x00000001L)
#define USER_EXTENDED_FIELD_A2D2		(0x00000002L)

//
// The following is for SamrGetUserDomainPasswordInformation(), which is
// only used in wrappers.c.
//

typedef struct _USER_DOMAIN_PASSWORD_INFORMATION {
    USHORT MinPasswordLength;
    ULONG PasswordProperties;
} USER_DOMAIN_PASSWORD_INFORMATION, *PUSER_DOMAIN_PASSWORD_INFORMATION;


//
// This flag may be or'd with the length field of SAMP_USER_PASSWORD to
// indicate that the password is not case sensitive.
//

#define SAM_PASSWORD_CASE_INSENSITIVE 0x80000000

//
// Structure to pass an encrypted password over the wire.  The Length is the
// length of the password, which should be placed at the end of the buffer.
// The size of the buffer (256) should be kept in sync with
// SAM_MAX_PASSWORD_LENGTH, which is defined in ntsam.h.  Unfortunately,
// MIDL does not let #define'd constants be imported, so we have to
// use 256 instead of the constant here.
//

typedef struct _SAMPR_USER_PASSWORD {
    WCHAR Buffer[SAM_MAX_PASSWORD_LENGTH];
    ULONG Length;
} SAMPR_USER_PASSWORD, *PSAMPR_USER_PASSWORD;

typedef struct _SAMPR_USER_PASSWORD_NEW {
    WCHAR Buffer[SAM_MAX_PASSWORD_LENGTH];
    ULONG Length;
    UCHAR ClearSalt[SAM_PASSWORD_ENCRYPTION_SALT_LEN];
} SAMPR_USER_PASSWORD_NEW, *PSAMPR_USER_PASSWORD_NEW;


//
// Buffer - contains random fill with the password filling up the end
//          of the buffer (the last Length bytes).
// Length - Length, in bytes, of the buffer.
//

//
// This is the encrypted version of the above structure, and is passed
// on the wire.
//

typedef struct _SAMPR_ENCRYPTED_USER_PASSWORD {
    UCHAR Buffer[ (SAM_MAX_PASSWORD_LENGTH * 2) + 4 ];
} SAMPR_ENCRYPTED_USER_PASSWORD, *PSAMPR_ENCRYPTED_USER_PASSWORD;


typedef struct _SAMPR_ENCRYPTED_USER_PASSWORD_NEW {
    UCHAR Buffer[ (SAM_MAX_PASSWORD_LENGTH * 2) + 4 + 16];
} SAMPR_ENCRYPTED_USER_PASSWORD_NEW, *PSAMPR_ENCRYPTED_USER_PASSWORD_NEW;


typedef enum _SAMPR_BOOT_TYPE {
    SamBootKeyNone = 0,
    SamBootKeyStored,
    SamBootKeyPassword,
    SamBootKeyDisk,
    SamBootChangePasswordEncryptionKey
} SAMPR_BOOT_TYPE, *PSAMPR_BOOT_TYPE;


//
// ChangePassword API for One-Way-Function-aware clients
//

NTSTATUS
SamiChangePasswordUser(
    IN SAM_HANDLE UserHandle,
    IN BOOLEAN LmOldPresent,
    IN PLM_OWF_PASSWORD LmOldOwfPassword,
    IN PLM_OWF_PASSWORD LmNewOwfPassword,
    IN BOOLEAN NtPresent,
    IN PNT_OWF_PASSWORD NtOldOwfPassword,
    IN PNT_OWF_PASSWORD NtNewOwfPassword
    );


NTSTATUS
SamiLmChangePasswordUser(
    IN SAM_HANDLE UserHandle,
    IN PENCRYPTED_LM_OWF_PASSWORD LmOldEncryptedWithLmNew,
    IN PENCRYPTED_LM_OWF_PASSWORD LmNewEncryptedWithLmOld
    );

NTSTATUS
SamiEncryptPasswords(
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldNt,
    OUT PENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt,
    OUT PBOOLEAN LmPresent,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    OUT PENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewNt
);

NTSTATUS
SamiChangePasswordUser2(
    PUNICODE_STRING ServerName,
    PUNICODE_STRING UserName,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt,
    PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt,
    BOOLEAN LmPresent,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLmOrNt
    );

NTSTATUS
SamiOemChangePasswordUser2(
    PSTRING ServerName,
    PSTRING UserName,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLm
    );

NTSTATUS
SamiGetBootKeyInformation(
    IN SAM_HANDLE DomainHandle,
    OUT PSAMPR_BOOT_TYPE BootOptions
    );

NTSTATUS
SamiSetBootKeyInformation(
    IN SAM_HANDLE DomainHandle,
    IN SAMPR_BOOT_TYPE BootOptions,
    IN PUNICODE_STRING OldBootKey, OPTIONAL
    IN PUNICODE_STRING NewBootKey OPTIONAL
    );

NTSTATUS
SamiSetDSRMPassword(
    IN PUNICODE_STRING  ServerName,
    IN ULONG            UserId,
    IN PUNICODE_STRING  ClearPassword
    );

NTSTATUS
SamiSetDSRMPasswordOWF(
    IN PUNICODE_STRING  ServerName,
    IN ULONG            UserId,
    IN PNT_OWF_PASSWORD NtPassword
    );

NTSTATUS
SamiChangeKeys();

#endif  // _NTSAMPRIVATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\nwcons.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwcons.h

Abstract:

    This module contains various Netware constants

Author:

    Chuck Y Chan.  Split out from NWAPI.H

Revision History:

--*/

#ifndef _NWCONS_INCLUDED_
#define _NWCONS_INCLUDED_

//
// Maximum length of server, password, username
//

#define NW_MAX_TREE_LEN        32
#define NW_MAX_SERVER_LEN      48
#define NW_MAX_PASSWORD_LEN    256
#define NW_MAX_USERNAME_LEN    256

//
// special char to distinguish nds context: eg. *tree\ou.o (as opposed to
// server\volume.
//
#define TREE_CHAR           L'*'             

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\nwrnames.h ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    nwreg.h

Abstract:

    Header which specifies the registry location and value names
    of the logon credential information written by the provider and
    read by the workstation service.

    Also contains helper routine prototypes.

Author:

    Rita Wong      (ritaw)      22-Mar-1993

Revision History:

--*/

#ifndef _NWRNAMES_INCLUDED_
#define _NWRNAMES_INCLUDED_


#define NW_WORKSTATION_REGKEY              L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters"
#define NW_WORKSTATION_OPTION_REGKEY       L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters\\Option"
#define NW_INTERACTIVE_LOGON_REGKEY        L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters\\InteractiveLogon" //Terminal Server Addition
#define NW_SERVICE_LOGON_REGKEY            L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters\\ServiceLogon"
#define NW_WORKSTATION_GATEWAY_DRIVES      L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Drives"
#define NW_WORKSTATION_GATEWAY_SHARES      L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Shares"
#define NW_WORKSTATION_PROVIDER_PATH       L"System\\CurrentControlSet\\Services\\NWCWorkstation\\networkprovider"

#define NW_PROVIDER_VALUENAME              L"Name"

#define NW_CURRENTUSER_VALUENAME           L"CurrentUser"
#define NW_GATEWAYACCOUNT_VALUENAME        L"GatewayAccount"
#define NW_GATEWAY_ENABLE                  L"GatewayEnabled"

#define NW_SERVER_VALUENAME                L"PreferredServer"
#define NW_NDS_SERVER_VALUENAME            L"NdsPreferredServer"
#define NW_LOGONSCRIPT_VALUENAME           L"LogonScript"
#define NW_WINSTATION_VALUENAME            L"WinStation"          //Terminal Server 
#define NW_SID_VALUENAME                   L"User"                //Terminal Server 
#define NW_LOGONID_VALUENAME               L"LogonID"
#define NW_PRINTOPTION_VALUENAME           L"PrintOption"
#define NW_SYNCLOGONSCRIPT_VALUENAME       L"ResetScriptFlag"
#define NW_DEFAULTSERVER_VALUENAME         L"DefaultLocation"
#define NW_DEFAULTSCRIPTOPTIONS_VALUENAME  L"DefaultScriptOptions"

#define WINLOGON_REGKEY              L"Software\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon"
#define SYNCLOGONSCRIPT_VALUENAME    L"RunLogonScriptSync"


#endif // _NWRNAMES_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\nwsnames.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    nwsnames.h

Abstract:

    Header for NetWare service names.

Author:

    Rita Wong      (ritaw)      26-Feb-1993

Revision History:

--*/

#ifndef _NW_SNAMES_INCLUDED_
#define _NW_SNAMES_INCLUDED_


#define NW_WORKSTATION_SERVICE     L"NWCWorkstation"

#endif // _NW_SNAMES_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\nwapi32.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1993 Microsoft Corporation
//
//  Module Name:
//
//      nwapi32.h
//
//  Abstract:
//
//      This module contains the support for calls into CSNW.
//
//  Author:
//
//      Chris Sandys    (a-chrisa)  09-Sep-1993
//
//  Revision History:
//      Chuck Y Chan    Feb 3, 1994    Make it NT like
//      Chuck Y Chan    Feb 4, 1996    Merged in calls used by DSMN (from
//                                     nwcapi32.h)
//
//////////////////////////////////////////////////////////////////////////////


#ifndef _NWAPI32_H_
#define _NWAPI32_H_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


//
// Order of Funtions
//
//    NWAddTrusteeToDirectory
//    NWAllocTemporaryDirectoryHandle
//    NWAllocPermanentDirectoryHandle
//    NWAttachToFileServer
//    NWCheckConsolePrivileges
//    NWDeallocateDirectoryHandle
//    NWDetachFromFileServer
//    NWGetFileServerVersionInfo
//    NWGetInternetAddress
//    NWGetObjectName
//    NWGetVolumeInfoWithHandle
//    NWGetVolumeInfoWithNumber
//    NWGetVolumeName
//    NWIsObjectInSet
//    NWLoginToFileServer
//    NWLogoutFromFileServer
//    NWReadPropertyValue
//    NWScanObject
//    NWScanProperty


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Manifests and structures                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// Version Structure
//
#include <packon.h>

typedef struct _VERSION_INFO {
    BYTE szName[48];
    BYTE Version;
    BYTE SubVersion;
    WORD ConnsSupported;
    WORD connsInUse;
    WORD maxVolumes;
    BYTE OSRev;
    BYTE SFTLevel;
    BYTE TTSLevel;
    WORD PeakConns;
    BYTE AcctVer;
    BYTE VAPVer;
    BYTE QueueVer;
    BYTE PrintVer;
    BYTE VirtualConsoleVer;
    BYTE SecurityResLevel;
    BYTE InternetworkBVer;
    BYTE Reserved[60];
} VERSION_INFO;

#include <packoff.h>

//
// DLL Defination
//
#define DLLEXPORT

//
// Misc type definitions
//
#define NWCCODE              USHORT
#define NWLOCAL_SCOPE        USHORT
#define NWCONN_HANDLE        HANDLE
#define NWFAR
#define NWAPI                WINAPI
#define NWOBJ_TYPE           USHORT
#define NWOBJ_ID             DWORD
#define NWFLAGS              UCHAR
#define NWVOL_NUM            UCHAR
#define NWDIR_HANDLE         UCHAR
#define NWACCESS_RIGHTS      BYTE
#define NWCONN_NUM           USHORT
#define NWNET_ADDR           UCHAR
#define NWNUMBER             WORD
#define NWVOL_FLAGS          WORD
#define NWSEGMENT_NUM        UCHAR
#define NWSEGMENT_DATA       BYTE
#define NWRIGHTS_MASK        WORD
#define NWSEQUENCE           BYTE
#define NWINDEX_TYPE         USHORT
#define NWDATE_TIME          DWORD
#define NWDIR_TRUSTEE_RIGHTS WORD
#define NWSEQUENCE           BYTE

typedef struct {
   NWOBJ_ID             objectID;
   NWDIR_TRUSTEE_RIGHTS objectRights;
} TRUSTEE_INFO;

//
// Object Types (already in HI-LO format)
//
#define OT_WILD                  0xFFFF
#define OT_UNKNOWN               0x0000
#define OT_USER                  0x0100
#define OT_USER_GROUP            0x0200
#define OT_PRINT_QUEUE           0x0300
#define OT_FILE_SERVER           0x0400
#define OT_JOB_SERVER            0x0500
#define OT_GATEWAY               0x0600
#define OT_PRINT_SERVER          0x0700
#define OT_ARCHIVE_QUEUE         0x0800
#define OT_ARCHIVE_SERVER        0x0900
#define OT_JOB_QUEUE             0x0A00
#define OT_ADMINISTRATION        0x0B00
#define OT_NAS_SNA_GATEWAY       0x2100
#define OT_REMOTE_BRIDGE_SERVER  0x2600
#define OT_TCPIP_GATEWAY         0x2700
#define OT_DIRSERVER             0x7802

//
// Bindery object property flag
//
#define BF_STATIC                0x00
#define BF_DYNAMIC               0x01
#define BF_ITEM                  0x00
#define BF_SET                   0x02

//
// Bindery object security flag
//
#define BS_ANY_READ              0x00
#define BS_LOGGED_READ           0x01
#define BS_OBJECT_READ           0x02
#define BS_SUPER_READ            0x03
#define BS_BINDERY_READ          0x04
#define BS_ANY_WRITE             0x00
#define BS_LOGGED_WRITE          0x10
#define BS_OBJECT_WRITE          0x20
#define BS_SUPER_WRITE           0x30
#define BS_BINDERY_WRITE         0x40

//
// Size Of Things
//
#define OBJ_NAME_SIZE            48            // ScanObject name size
#define VOL_NAME_SIZE            16            // Get Volume Name Size
#define NW_USER_SIZE             50
#define NW_GROUP_SIZE            50
#define NW_PROP_SIZE             50
#define NW_DATA_SIZE             128
#define NW_PROP_SET              0x02

//
// Return Codes
//
#define UNSUCCESSFUL                  -1
#define SUCCESSFUL                    0x0000
#define REQUESTER_ERROR               0x8800

#define ALREADY_ATTACHED              0x8800
#define INVALID_CONNECTION            0x8801
#define NO_CONSOLE_RIGHTS             0x89C6
#define SERVER_OUT_OF_MEMORY          0x8996
#define VOLUME_DOES_NOT_EXIST         0x8998
#define BAD_DIRECTORY_HANDLE          0x899B
#define INVALID_PATH                  0x899C
#define OBJECT_ALREADY_EXISTS         0x89EE
#define NO_OBJECT_READ_PRIVILEGE      0x89FB
#define NO_SUCH_PROPERTY              0x89FB
#define UNKNOWN_FILE_SERVER           0x89FC
#define NO_SUCH_OBJECT                0x89FC
#define NO_FILES_FOUND_ERROR          0x89FF

//
// Swap MACROS
//
#define wSWAP(x) (USHORT)(((((USHORT)x)<<8)&0xFF00) | ((((USHORT)x)>>8)&0x00FF))
#define dwSWAP(x) (DWORD)( ((((DWORD)x)<<24)&0xFF000000) | ((((DWORD)x)<<8)&0x00FF0000) | ((((DWORD)x)>>8)&0x0000FF00) | ((((DWORD)x)>>24)&0x000000FF) )

#define DW_SIZE 4               // used for placing RAW bytes
#define W_SIZE  2


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Original functions from Chris Sandys. Keep for compatibility.             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NWCCODE NWAPI DLLEXPORT
NWAddTrusteeToDirectory(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char      NWFAR   *pszPath,
    NWOBJ_ID                dwTrusteeID,
    NWACCESS_RIGHTS         rightsMask
    );

NWCCODE NWAPI DLLEXPORT
NWAllocPermanentDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char            NWFAR   *pszDirPath,
    NWDIR_HANDLE    NWFAR   *pbNewDirHandle,
    NWACCESS_RIGHTS NWFAR   *pbRightsMask
    );

NWCCODE NWAPI DLLEXPORT
NWAllocTemporaryDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char            NWFAR   *pszDirPath,
    NWDIR_HANDLE    NWFAR   *pbNewDirHandle,
    NWACCESS_RIGHTS NWFAR   *pbRightsMask
    );

NWCCODE NWAPI DLLEXPORT
NWAttachToFileServer(
    const char      NWFAR   *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE   NWFAR   *phNewConn
    );

NWCCODE NWAPI DLLEXPORT
NWAttachToFileServerW(
    const WCHAR     NWFAR   *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE   NWFAR   *phNewConn
    );

NWCCODE NWAPI DLLEXPORT
NWCheckConsolePrivileges(
    NWCONN_HANDLE           hConn
    );

NWCCODE NWAPI DLLEXPORT
NWDeallocateDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle
    );

NWCCODE NWAPI DLLEXPORT
NWDetachFromFileServer(
    NWCONN_HANDLE           hConn
    );

NWCCODE NWAPI DLLEXPORT
NWGetFileServerVersionInfo(
    NWCONN_HANDLE           hConn,
    VERSION_INFO    NWFAR   *lpVerInfo
    );

NWCCODE NWAPI DLLEXPORT
NWGetInternetAddress(
    NWCONN_HANDLE           hConn,
    NWCONN_NUM              nConnNum,
    NWNET_ADDR      NWFAR   *pIntAddr
    );

NWCCODE NWAPI DLLEXPORT
NWGetObjectName(
    NWCONN_HANDLE           hConn,
    NWOBJ_ID                dwObjectID,
    char            NWFAR   *pszObjName,
    NWOBJ_TYPE      NWFAR   *pwObjType
    );

NWCCODE NWAPI DLLEXPORT
NWGetVolumeInfoWithHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            nDirHand,
    char        NWFAR       *pszVolName,
    NWNUMBER    NWFAR       *pwTotalBlocks,
    NWNUMBER    NWFAR       *pwSectors,
    NWNUMBER    NWFAR       *pwAvailBlocks,
    NWNUMBER    NWFAR       *pwTotalDir,
    NWNUMBER    NWFAR       *pwAvailDir,
    NWVOL_FLAGS NWFAR       *pfVolRemovable
    );

NWCCODE NWAPI DLLEXPORT
NWGetVolumeInfoWithNumber(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               nVolNum,
    char        NWFAR       *pszVolName,
    NWNUMBER    NWFAR       *pwTotalBlocks,
    NWNUMBER    NWFAR       *pwSectors,
    NWNUMBER    NWFAR       *pwAvailBlocks,
    NWNUMBER    NWFAR       *pwTotalDir,
    NWNUMBER    NWFAR       *pwAvailDir,
    NWVOL_FLAGS NWFAR       *pfVolRemovable
    );

NWCCODE NWAPI DLLEXPORT
NWGetVolumeName(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               bVolNum,
    char            NWFAR   *pszVolName
    );

NWCCODE NWAPI DLLEXPORT                       /* ??? */
NWLoginToFileServer(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszUserName,
    NWOBJ_TYPE              wObType,
    const char      NWFAR   *pszPassword
    );

NWCCODE NWAPI DLLEXPORT                       /* ??? */
NWLogoutFromFileServer(
    NWCONN_HANDLE           hConn
    );

NWCCODE NWAPI DLLEXPORT                       /* ??? */
NWReadPropertyValue(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszObjName,
    NWOBJ_TYPE              wObjType,
    char            NWFAR   *pszPropName,
    unsigned char           ucSegment,
    char            NWFAR   *pValue,
    NWFLAGS         NWFAR   *pucMoreFlag,
    NWFLAGS         NWFAR   *pucPropFlag
    );


NWCCODE NWAPI DLLEXPORT
NWScanObject(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszSearchName,
    NWOBJ_TYPE              wObjSearchType,
    NWOBJ_ID        NWFAR   *pdwObjectID,
    char            NWFAR   *pszObjectName,
    NWOBJ_TYPE      NWFAR   *pwObjType,
    NWFLAGS         NWFAR   *pucHasProperties,
    NWFLAGS         NWFAR   *pucObjectFlags,
    NWFLAGS         NWFAR   *pucObjSecurity
    );

NWCCODE NWAPI DLLEXPORT
NWScanProperty(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszObjectName,
    NWOBJ_TYPE              wObjType,
    char            NWFAR   *pszSearchName,
    NWOBJ_ID        NWFAR   *pdwSequence,
    char            NWFAR   *pszPropName,
    NWFLAGS         NWFAR   *pucPropFlags,
    NWFLAGS         NWFAR   *pucPropSecurity,
    NWFLAGS         NWFAR   *pucHasValue,
    NWFLAGS         NWFAR   *pucMore
    );

NWCCODE NWAPI DLLEXPORT
NWIsObjectInSet(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *lpszObjectName,
    NWOBJ_TYPE              wObjType,
    const char      NWFAR   *lpszPropertyName,
	const char 		NWFAR	*lpszMemberName,
	NWOBJ_TYPE				wMemberType
    );

NWCCODE NWAPI DLLEXPORT
NWGetFileServerDateAndTime(
    NWCONN_HANDLE           hConn,
    BYTE            NWFAR   *year,
    BYTE            NWFAR   *month,
    BYTE            NWFAR   *day,
    BYTE            NWFAR   *hour,
    BYTE            NWFAR   *minute,
    BYTE            NWFAR   *second,
    BYTE            NWFAR   *dayofweek
    );

NWCCODE NWAPI DLLEXPORT
NWCreateQueue(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char    NWFAR     *pszQueueName,
    NWOBJ_TYPE              wQueueType,
    const char    NWFAR     *pszPathName,
    NWOBJ_ID      NWFAR     *pdwQueueId
    );

NWCCODE NWAPI DLLEXPORT
NWChangePropertySecurity(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszObjName,
    NWOBJ_TYPE              wObjType,
    const char      NWFAR   *pszPropertyName,
    NWFLAGS                 ucObjSecurity
    );

NWCCODE NWAPI DLLEXPORT
NWDestroyQueue(
    NWCONN_HANDLE hConn,
    NWOBJ_ID      dwQueueId
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Newer and more complete NWC functions.                                    //
//                                                                           //
// These functions return NetWare compatible error codes. Win32 error may    //
// be obtained by calling GetLastError().                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NWCCODE
NWCAddTrusteeToDirectory(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWOBJ_ID                dwTrusteeID,
    NWACCESS_RIGHTS         rightsMask
    );

NWCCODE
NWCAllocPermanentDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszDirPath,
    NWDIR_HANDLE            *pbNewDirHandle,
    NWACCESS_RIGHTS         *pbRightsMask
    );

NWCCODE
NWCAllocTemporaryDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszDirPath,
    NWDIR_HANDLE            *pbNewDirHandle,
    NWACCESS_RIGHTS         *pbRightsMask
    );

NWCCODE
NWCAttachToFileServer(
    const char              *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE           *phNewConn
    );

NWCCODE
NWCAttachToFileServerW(
    const WCHAR             *pszServerName,
    NWLOCAL_SCOPE           ScopeFlag,
    NWCONN_HANDLE           *phNewConn
    );

NWCCODE
NWCCheckConsolePrivileges(
    NWCONN_HANDLE           hConn
    );

NWCCODE
NWCDeallocateDirectoryHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle
    );

NWCCODE
NWCDetachFromFileServer(
    NWCONN_HANDLE           hConn
    );

NWCCODE
NWCGetFileServerVersionInfo(
    NWCONN_HANDLE           hConn,
    VERSION_INFO            *lpVerInfo
    );

NWCCODE
NWCGetInternetAddress(
    NWCONN_HANDLE           hConn,
    NWCONN_NUM              nConnNum,
    NWNET_ADDR              *pIntAddr
    );

NWCCODE
NWCGetObjectName(
    NWCONN_HANDLE           hConn,
    NWOBJ_ID                dwObjectID,
    char                    *pszObjName,
    NWOBJ_TYPE              *pwObjType
    );

NWCCODE
NWCGetVolumeInfoWithHandle(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            nDirHand,
    char                    *pszVolName,
    NWNUMBER                *pwTotalBlocks,
    NWNUMBER                *pwSectors,
    NWNUMBER                *pwAvailBlocks,
    NWNUMBER                *pwTotalDir,
    NWNUMBER                *pwAvailDir,
    NWVOL_FLAGS             *pfVolRemovable
    );

NWCCODE
NWCGetVolumeInfoWithNumber(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               nVolNum,
    char                    *pszVolName,
    NWNUMBER                *pwTotalBlocks,
    NWNUMBER                *pwSectors,
    NWNUMBER                *pwAvailBlocks,
    NWNUMBER                *pwTotalDir,
    NWNUMBER                *pwAvailDir,
    NWVOL_FLAGS             *pfVolRemovable
    );

NWCCODE
NWCGetVolumeName(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               bVolNum,
    char                    *pszVolName
    );

NWCCODE
NWCLoginToFileServer(
    NWCONN_HANDLE           hConn,
    const char              *pszUserName,
    NWOBJ_TYPE              wObType,
    const char              *pszPassword
    );

NWCCODE
NWCLogoutFromFileServer(
    NWCONN_HANDLE           hConn
    );

NWCCODE
NWCReadPropertyValue(
    NWCONN_HANDLE           hConn,
    const char              *pszObjName,
    NWOBJ_TYPE              wObjType,
    char                    *pszPropName,
    unsigned char           ucSegment,
    char                    *pValue,
    NWFLAGS                 *pucMoreFlag,
    NWFLAGS                 *pucPropFlag
    );


NWCCODE
NWCScanObject(
    NWCONN_HANDLE           hConn,
    const char              *pszSearchName,
    NWOBJ_TYPE              wObjSearchType,
    NWOBJ_ID                *pdwObjectID,
    char                    *pszObjectName,
    NWOBJ_TYPE              *pwObjType,
    NWFLAGS                 *pucHasProperties,
    NWFLAGS                 *pucObjectFlags,
    NWFLAGS                 *pucObjSecurity
    );

NWCCODE
NWCScanProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    char                    *pszSearchName,
    NWOBJ_ID                *pdwSequence,
    char                    *pszPropName,
    NWFLAGS                 *pucPropFlags,
    NWFLAGS                 *pucPropSecurity,
    NWFLAGS                 *pucHasValue,
    NWFLAGS                 *pucMore
    );

NWCCODE
NWCIsObjectInSet(
    NWCONN_HANDLE           hConn,
    const char              *lpszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *lpszPropertyName,
    const char 		    *lpszMemberName,
    NWOBJ_TYPE              wMemberType
    );

NWCCODE
NWCGetFileServerDateAndTime(
    NWCONN_HANDLE           hConn,
    BYTE                    *year,
    BYTE                    *month,
    BYTE                    *day,
    BYTE                    *hour,
    BYTE                    *minute,
    BYTE                    *second,
    BYTE                    *dayofweek
    );

NWCCODE
NWCAddTrustee(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWOBJ_ID                dwTrusteeID,
    NWRIGHTS_MASK           rightsMask
    );

NWCCODE
NWCDeleteObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType
    );

NWCCODE
NWCCreateObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    NWFLAGS                 ucObjectFlags,
    NWFLAGS                 ucObjSecurity
    );

NWCCODE
NWCCreateProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    NWFLAGS                 ucObjectFlags,
    NWFLAGS                 ucObjSecurity
    );

NWCCODE
NWCDeleteProperty(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName
    );

NWCCODE
NWCWritePropertyValue(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    NWSEGMENT_NUM           segmentNumber,
    NWSEGMENT_DATA          *segmentData,
    NWFLAGS                 moreSegments
    );

NWCCODE
NWCGetObjectID(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    NWOBJ_ID                *objectID
    );

NWCCODE
NWCRenameBinderyObject(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    const char              *pszNewObjectName,
    NWOBJ_TYPE              wObjType
    );

NWCCODE
NWCAddObjectToSet(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    const char              *pszMemberName,
    NWOBJ_TYPE              memberType
    );

NWCCODE
NWCDeleteObjectFromSet(
    NWCONN_HANDLE           hConn,
    const char              *pszObjectName,
    NWOBJ_TYPE              wObjType,
    const char              *pszPropertyName,
    const char              *pszMemberName,
    NWOBJ_TYPE              memberType
    );

NWCCODE
NWCCreateDirectory(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char              *pszPath,
    NWACCESS_RIGHTS         accessMask
    );

NWCCODE
NWCScanForTrustees(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszsearchDirPath,
    NWSEQUENCE              *pucsequenceNumber,
    BYTE                    *numberOfEntries,
    TRUSTEE_INFO            *tl
    );

NWCCODE
NWCScanDirectoryForTrustees2(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    char                    *pszsearchDirPath,
    NWSEQUENCE              *pucsequenceNumber,
    char                    *pszdirName,
    NWDATE_TIME             *dirDateTime,
    NWOBJ_ID                *ownerID,
    TRUSTEE_INFO            *trusteeList
    );

NWCCODE
NWCGetBinderyAccessLevel(
    NWCONN_HANDLE           hConn,
    NWFLAGS                 *accessLevel,
    NWOBJ_ID                *objectID
    );

NWCCODE
NWCGetFileServerDescription(
    NWCONN_HANDLE           hConn,
    char                    *pszCompany,
    char                    *pszVersion,
    char                    *pszRevision
);

NWCCODE
NWCGetVolumeNumber(
    NWCONN_HANDLE           hConn,
    char                    *pszVolume,
    NWVOL_NUM               *VolumeNumber
);

NWCCODE
NWCGetVolumeUsage(
    NWCONN_HANDLE           hConn,
    NWVOL_NUM               VolumeNumber,
    DWORD                   *TotalBlocks,
    DWORD                   *FreeBlocks,
    DWORD                   *PurgeableBlocks,
    DWORD                   *NotYetPurgeableBlocks,
    DWORD                   *TotalDirectoryEntries,
    DWORD                   *AvailableDirectoryEntries,
    BYTE                    *SectorsPerBlock
);

NWCCODE
NWCCreateQueue(
    NWCONN_HANDLE           hConn,
    NWDIR_HANDLE            dirHandle,
    const char    NWFAR     *pszQueueName,
    NWOBJ_TYPE              wQueueType,
    const char    NWFAR     *pszPathName,
    NWOBJ_ID      NWFAR     *pdwQueueId
    );

NWCCODE
NWCChangePropertySecurity(
    NWCONN_HANDLE           hConn,
    const char      NWFAR   *pszObjName,
    NWOBJ_TYPE              wObjType,
    const char      NWFAR   *pszPropertyName,
    NWFLAGS                 ucObjSecurity
    );

NWCCODE
NWCDestroyQueue(
    NWCONN_HANDLE hConn,
    NWOBJ_ID      dwQueueId
    );

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif //_NWAPI32_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\nwevent.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    nwevent.h

Abstract:

    Definitions for NetWare network events.

Author:

    Portable Systems Group 12/22/1992

Revision History:

Notes:

    This file is generated by the MC tool from the netevent.mc file.

--*/

#ifndef _NWEVENT_
#define _NWEVENT_


/////////////////////////////////////////////////////////////////////////
//
// NetWare Redirector Events
//
//
/////////////////////////////////////////////////////////////////////////



// Issued from kernel mode.  Don't use %1 for
// server-supplied insertion strings -- the I/O system provides the
// first string.

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: EVENT_NWRDR_RESOURCE_SHORTAGE
//
// MessageText:
//
//  The Microsoft Client Service for NetWare redirector was unable to allocate memory.
//
#define EVENT_NWRDR_RESOURCE_SHORTAGE    0xC0001F41L

//
// MessageId: EVENT_NWRDR_CANT_CREATE_DEVICE
//
// MessageText:
//
//  The Microsoft Client Service for NetWare redirector could not create its device.  The redirector could not be started.
//
#define EVENT_NWRDR_CANT_CREATE_DEVICE   0xC0001F42L

//
// MessageId: EVENT_NWRDR_INVALID_REPLY
//
// MessageText:
//
//  The Microsoft Client Service for NetWare redirector received an incorrectly formatted response from %2.
//
#define EVENT_NWRDR_INVALID_REPLY        0xC0001F43L

//
// MessageId: EVENT_NWRDR_FAILED_UNLOCK
//
// MessageText:
//
//  The Microsoft Client Service for NetWare redirector failed to unlock part of a file on server %2.
//
#define EVENT_NWRDR_FAILED_UNLOCK        0xC0001F44L

//
// MessageId: EVENT_NWRDR_NETWORK_ERROR
//
// MessageText:
//
//  The Microsoft Client Service for NetWare redirector has encountered a network error.
//
#define EVENT_NWRDR_NETWORK_ERROR        0xC0001F45L

//
// MessageId: EVENT_NWRDR_UNEXPECTED_ERROR
//
// MessageText:
//
//  An unexpected network error has occurred on the connection to %2.
//
#define EVENT_NWRDR_UNEXPECTED_ERROR     0xC0001F46L

//
// MessageId: EVENT_NWRDR_TIMEOUT
//
// MessageText:
//
//  The Microsoft Client Service for NetWare redirector has timed out one or more requests to %2.
//
#define EVENT_NWRDR_TIMEOUT              0x80001F47L

//
// MessageId: EVENT_NWRDR_NO_SERVER_ON_NETWORK
//
// MessageText:
//
//  No NetWare or compatible server exists on this network.
//
#define EVENT_NWRDR_NO_SERVER_ON_NETWORK 0xC0001F48L

/////////////////////////////////////////////////////////////////////////
//
// NetWare Workstation Events
//
//
/////////////////////////////////////////////////////////////////////////
//
// MessageId: EVENT_NWWKSTA_NO_TRANSPORTS
//
// MessageText:
//
//  The Microsoft Client Service for NetWare could not start because it did not bind to any transports.
//
#define EVENT_NWWKSTA_NO_TRANSPORTS      0xC0002329L

//
// MessageId: EVENT_NWWKSTA_CANT_BIND_TO_TRANSPORT
//
// MessageText:
//
//  The Microsoft Client Service for NetWare could not bind to the transport %1.
//
#define EVENT_NWWKSTA_CANT_BIND_TO_TRANSPORT 0xC000232AL

//
// MessageId: EVENT_NWWKSTA_INVALID_REGISTRY_VALUE
//
// MessageText:
//
//  The value named %1 in the Microsoft Client Service for NetWare registry key %2 was invalid.  The value was
//  ignored, and processing continued.
//
#define EVENT_NWWKSTA_INVALID_REGISTRY_VALUE 0x8000232BL

//
// MessageId: EVENT_NWWKSTA_CANT_CREATE_REDIRECTOR
//
// MessageText:
//
//  The Microsoft Client Service for NetWare redirector (%1) could not be started.
//
#define EVENT_NWWKSTA_CANT_CREATE_REDIRECTOR 0xC000232CL

//
// MessageId: EVENT_NWWKSTA_GATEWAY_LOGON_FAILED
//
// MessageText:
//
//  The Gateway Account could not be logged on. The error %1 occurred.
//
#define EVENT_NWWKSTA_GATEWAY_LOGON_FAILED 0xC000232DL

//
// MessageId: EVENT_NWWKSTA_CANNOT_REDIRECT_DEVICES
//
// MessageText:
//
//  Device %1 could not be reconnected to %2. Error %3 occurred.
//
#define EVENT_NWWKSTA_CANNOT_REDIRECT_DEVICES 0xC000232EL

//
// MessageId: EVENT_NWWKSTA_WRONG_NWLINK_VERSION
//
// MessageText:
//
//  The version of the NWLINK transport present does not support all the capabilities required to use the Microsoft Client Service for NetWare properly.
//
#define EVENT_NWWKSTA_WRONG_NWLINK_VERSION 0xC000232FL

/////////////////////////////////////////////////////////////////////////
//
// NetWare Credential Manager Events
//
//
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NW_MESSAGE_TITLE
//
// MessageText:
//
//  Client Service for NetWare%0
//
#define NW_MESSAGE_TITLE                 0x40002711L

//
// MessageId: NW_MESSAGE_FROM_SERVER
//
// MessageText:
//
//  Message from server %1. %n
//
#define NW_MESSAGE_FROM_SERVER           0x40002712L

//
// MessageId: NW_PASSWORD_HAS_EXPIRED
//
// MessageText:
//
//  The password for %1 on %2 has expired, with %3 grace logins left.%n
//
#define NW_PASSWORD_HAS_EXPIRED          0x80002713L

//
// MessageId: NW_LOGIN_DISABLED
//
// MessageText:
//
//  Logins to the server has been disabled.%n
//
#define NW_LOGIN_DISABLED                0xC0002714L

//
// MessageId: NW_PASSWORD_HAS_EXPIRED1
//
// MessageText:
//
//  The password for %1 on %2 has expired.%n
//
#define NW_PASSWORD_HAS_EXPIRED1         0xC0002715L

//
// MessageId: NW_MESSAGE_TITLE_NTAS
//
// MessageText:
//
//  Gateway Service for NetWare%0
//
#define NW_MESSAGE_TITLE_NTAS            0x40002716L


#endif // _NWEVENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\nwsap.h ===
/*++

Copyright (c) 1994  Microsoft Corporation
Copyright (c) 1993  Micro Computer Systems, Inc.

Module Name:

    net\inc\nwsap.h

Abstract:

    This is the public include file for the Nw Sap Agent API.

Author:

    Brian Walker (MCS) 06-30-1993

Revision History:

--*/

#ifndef _NWSAP_
#define _NWSAP_

#ifdef __cplusplus
extern "C" {
#endif

/** Return codes for Advertise API and BindLib API **/

#define SAPRETURN_SUCCESS	    0
#define SAPRETURN_NOMEMORY      1
#define SAPRETURN_EXISTS	    2
#define SAPRETURN_NOTEXIST      3
#define SAPRETURN_NOTINIT       4
#define SAPRETURN_INVALIDNAME   5
#define SAPRETURN_DUPLICATE     6

/** Function Prototypes **/

INT
SapAddAdvertise(
    IN PUCHAR ServerName,
    IN USHORT ServerType,
	IN PUCHAR ServerAddr,
    IN BOOL   RespondNearest);

INT
SapRemoveAdvertise(
    IN PUCHAR ServerName,
    IN USHORT ServerType);

DWORD
SapLibInit(
    VOID);

DWORD
SapLibShutdown(
    VOID);

INT
SapGetObjectID(
    IN PUCHAR ObjectName,
    IN USHORT ObjectType,
	IN PULONG ObjectID);

INT
SapGetObjectName(
    IN ULONG   ObjectID,
    IN PUCHAR  ObjectName,
    IN PUSHORT ObjectType,
    IN PUCHAR  ObjectAddr);

INT
SapScanObject(
    IN PULONG   ObjectID,
    IN PUCHAR   ObjectName,
    IN PUSHORT  ObjectType,
    IN USHORT   ScanType);

#ifdef __cplusplus
}   /* extern "C" */
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\passrec.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    passrec.h

Abstract:

    This module contains prototypes to support local account password recovery.

Author:

    Pete Skelly (petesk)    09-May-00

--*/

#ifndef __PASSREC_H__
#define __PASSREC_H__

#ifdef __cplusplus
extern "C" {
#endif


DWORD 
PRRecoverPassword(
                IN  LPWSTR pszUsername,
                IN  PBYTE pbRecoveryPrivate,
                IN  DWORD cbRecoveryPrivate,
                IN  LPWSTR pszNewPassword);

#define RECOVERY_STATUS_OK                          0
#define RECOVERY_STATUS_NO_PUBLIC_EXISTS            1
#define RECOVERY_STATUS_FILE_NOT_FOUND              2
#define RECOVERY_STATUS_USER_NOT_FOUND              3
#define RECOVERY_STATUS_PUBLIC_SIGNATURE_INVALID    4

DWORD
PRQueryStatus(
                IN OPTIONAL LPWSTR pszDomain,
                IN OPTIONAL LPWSTR pszUsername,
                OUT DWORD *pdwStatus);

DWORD
PRGenerateRecoveryKey(
                IN  LPWSTR pszUsername,
                IN  LPWSTR pszCurrentPassword,
                OUT PBYTE *ppbRecoveryPrivate,
                OUT DWORD *pcbRecoveryPrivate);

DWORD
WINAPI
CryptResetMachineCredentials(
    DWORD dwFlags);

#ifdef __cplusplus
}
#endif

#endif // __PASSREC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\passport.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for passport.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __passport_h__
#define __passport_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDomainMap_FWD_DEFINED__
#define __IDomainMap_FWD_DEFINED__
typedef interface IDomainMap IDomainMap;
#endif 	/* __IDomainMap_FWD_DEFINED__ */


#ifndef __IPassportTicket_FWD_DEFINED__
#define __IPassportTicket_FWD_DEFINED__
typedef interface IPassportTicket IPassportTicket;
#endif 	/* __IPassportTicket_FWD_DEFINED__ */


#ifndef __IPassportTicket2_FWD_DEFINED__
#define __IPassportTicket2_FWD_DEFINED__
typedef interface IPassportTicket2 IPassportTicket2;
#endif 	/* __IPassportTicket2_FWD_DEFINED__ */


#ifndef __IPassportProfile_FWD_DEFINED__
#define __IPassportProfile_FWD_DEFINED__
typedef interface IPassportProfile IPassportProfile;
#endif 	/* __IPassportProfile_FWD_DEFINED__ */


#ifndef __IPassportManager_FWD_DEFINED__
#define __IPassportManager_FWD_DEFINED__
typedef interface IPassportManager IPassportManager;
#endif 	/* __IPassportManager_FWD_DEFINED__ */


#ifndef __IPassportManager2_FWD_DEFINED__
#define __IPassportManager2_FWD_DEFINED__
typedef interface IPassportManager2 IPassportManager2;
#endif 	/* __IPassportManager2_FWD_DEFINED__ */


#ifndef __IPassportManager3_FWD_DEFINED__
#define __IPassportManager3_FWD_DEFINED__
typedef interface IPassportManager3 IPassportManager3;
#endif 	/* __IPassportManager3_FWD_DEFINED__ */


#ifndef __IPassportCrypt_FWD_DEFINED__
#define __IPassportCrypt_FWD_DEFINED__
typedef interface IPassportCrypt IPassportCrypt;
#endif 	/* __IPassportCrypt_FWD_DEFINED__ */


#ifndef __IPassportAdmin_FWD_DEFINED__
#define __IPassportAdmin_FWD_DEFINED__
typedef interface IPassportAdmin IPassportAdmin;
#endif 	/* __IPassportAdmin_FWD_DEFINED__ */


#ifndef __IPassportAdminEx_FWD_DEFINED__
#define __IPassportAdminEx_FWD_DEFINED__
typedef interface IPassportAdminEx IPassportAdminEx;
#endif 	/* __IPassportAdminEx_FWD_DEFINED__ */


#ifndef __IPassportFastAuth_FWD_DEFINED__
#define __IPassportFastAuth_FWD_DEFINED__
typedef interface IPassportFastAuth IPassportFastAuth;
#endif 	/* __IPassportFastAuth_FWD_DEFINED__ */


#ifndef __IPassportFastAuth2_FWD_DEFINED__
#define __IPassportFastAuth2_FWD_DEFINED__
typedef interface IPassportFastAuth2 IPassportFastAuth2;
#endif 	/* __IPassportFastAuth2_FWD_DEFINED__ */


#ifndef __IPassportFactory_FWD_DEFINED__
#define __IPassportFactory_FWD_DEFINED__
typedef interface IPassportFactory IPassportFactory;
#endif 	/* __IPassportFactory_FWD_DEFINED__ */


#ifndef __Manager_FWD_DEFINED__
#define __Manager_FWD_DEFINED__

#ifdef __cplusplus
typedef class Manager Manager;
#else
typedef struct Manager Manager;
#endif /* __cplusplus */

#endif 	/* __Manager_FWD_DEFINED__ */


#ifndef __Ticket_FWD_DEFINED__
#define __Ticket_FWD_DEFINED__

#ifdef __cplusplus
typedef class Ticket Ticket;
#else
typedef struct Ticket Ticket;
#endif /* __cplusplus */

#endif 	/* __Ticket_FWD_DEFINED__ */


#ifndef __Profile_FWD_DEFINED__
#define __Profile_FWD_DEFINED__

#ifdef __cplusplus
typedef class Profile Profile;
#else
typedef struct Profile Profile;
#endif /* __cplusplus */

#endif 	/* __Profile_FWD_DEFINED__ */


#ifndef __Crypt_FWD_DEFINED__
#define __Crypt_FWD_DEFINED__

#ifdef __cplusplus
typedef class Crypt Crypt;
#else
typedef struct Crypt Crypt;
#endif /* __cplusplus */

#endif 	/* __Crypt_FWD_DEFINED__ */


#ifndef __Admin_FWD_DEFINED__
#define __Admin_FWD_DEFINED__

#ifdef __cplusplus
typedef class Admin Admin;
#else
typedef struct Admin Admin;
#endif /* __cplusplus */

#endif 	/* __Admin_FWD_DEFINED__ */


#ifndef __FastAuth_FWD_DEFINED__
#define __FastAuth_FWD_DEFINED__

#ifdef __cplusplus
typedef class FastAuth FastAuth;
#else
typedef struct FastAuth FastAuth;
#endif /* __cplusplus */

#endif 	/* __FastAuth_FWD_DEFINED__ */


#ifndef __PassportFactory_FWD_DEFINED__
#define __PassportFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class PassportFactory PassportFactory;
#else
typedef struct PassportFactory PassportFactory;
#endif /* __cplusplus */

#endif 	/* __PassportFactory_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_passport_0000 */
/* [local] */ 

//  Size definitions
#define	PASSPORT_COOKIES_MAXLEN	( 512 )

#define	PASSPORT_COOKIES_BUFSIZE	( PASSPORT_COOKIES_MAXLEN + 1 )

#define	PASSPORT_EMAIL_MAXLEN	( 64 + 1 + 64 )

#define	PASSPORT_EMAIL_BUFSIZE	( PASSPORT_EMAIL_MAXLEN + 1 )

#define	PASSPORT_NICKNAME_MAXLEN	( 30 )

#define	PASSPORT_NICKNAME_BUFSIZE	( PASSPORT_NICKNAME_MAXLEN + 1 )

#define	MSPP_PROF_MEMBER_NAME	( "membername" )

#define	MSPP_PROF_HI_UID	( "memberidhigh" )

#define	MSPP_PROF_LO_UID	( "memberidlow" )

#define	MSPP_PROF_VERSION	( "profileVersion" )

#define	MSPP_PROF_COUNTRY	( "country" )

#define	MSPP_PROF_POSTALCODE	( "postalCode" )

#define	MSPP_PROF_REGION	( "region" )

#define	MSPP_PROF_CITY	( "city" )

#define	MSPP_PROF_LANGPREF	( "lang_preference" )

#define	MSPP_PROF_BDAYPREC	( "bday_precision" )

#define	MSPP_PROF_BDATE	( "birthdate" )

#define	MSPP_PROF_GENDER	( "gender" )

#define	MSPP_PROF_PREF_EMAIL	( "preferredEmail" )

#define	MSPP_PROF_NICKNAME	( "nickname" )

#define	MSPP_PROF_ACCESS	( "accessibility" )

#define	MSPP_PROF_WALLET	( "wallet" )

#define	MSPP_PROF_DIRECTORY	( "directory" )

#define	MSPP_PROF_MSNIA	( "inetaccess" )

#define	MSPP_PROF_FLAGS	( "flags" )



extern RPC_IF_HANDLE __MIDL_itf_passport_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_passport_0000_v0_0_s_ifspec;

#ifndef __IDomainMap_INTERFACE_DEFINED__
#define __IDomainMap_INTERFACE_DEFINED__

/* interface IDomainMap */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDomainMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ACE1AC86-E14F-4f7b-B89A-805A69959680")
    IDomainMap : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDomainAttribute( 
            /* [in] */ BSTR attributeName,
            /* [optional][in] */ VARIANT lcid,
            /* [optional][in] */ VARIANT domain,
            /* [retval][out] */ BSTR *pAttrVal) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Domains( 
            /* [retval][out] */ VARIANT *pArrayVal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DomainExists( 
            /* [in] */ BSTR domainName,
            /* [retval][out] */ VARIANT_BOOL *pbExists) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDomainMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDomainMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDomainMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDomainMap * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDomainAttribute )( 
            IDomainMap * This,
            /* [in] */ BSTR attributeName,
            /* [optional][in] */ VARIANT lcid,
            /* [optional][in] */ VARIANT domain,
            /* [retval][out] */ BSTR *pAttrVal);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Domains )( 
            IDomainMap * This,
            /* [retval][out] */ VARIANT *pArrayVal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DomainExists )( 
            IDomainMap * This,
            /* [in] */ BSTR domainName,
            /* [retval][out] */ VARIANT_BOOL *pbExists);
        
        END_INTERFACE
    } IDomainMapVtbl;

    interface IDomainMap
    {
        CONST_VTBL struct IDomainMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDomainMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDomainMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDomainMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDomainMap_GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)	\
    (This)->lpVtbl -> GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)

#define IDomainMap_get_Domains(This,pArrayVal)	\
    (This)->lpVtbl -> get_Domains(This,pArrayVal)

#define IDomainMap_DomainExists(This,domainName,pbExists)	\
    (This)->lpVtbl -> DomainExists(This,domainName,pbExists)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDomainMap_GetDomainAttribute_Proxy( 
    IDomainMap * This,
    /* [in] */ BSTR attributeName,
    /* [optional][in] */ VARIANT lcid,
    /* [optional][in] */ VARIANT domain,
    /* [retval][out] */ BSTR *pAttrVal);


void __RPC_STUB IDomainMap_GetDomainAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IDomainMap_get_Domains_Proxy( 
    IDomainMap * This,
    /* [retval][out] */ VARIANT *pArrayVal);


void __RPC_STUB IDomainMap_get_Domains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IDomainMap_DomainExists_Proxy( 
    IDomainMap * This,
    /* [in] */ BSTR domainName,
    /* [retval][out] */ VARIANT_BOOL *pbExists);


void __RPC_STUB IDomainMap_DomainExists_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDomainMap_INTERFACE_DEFINED__ */


#ifndef __IPassportTicket_INTERFACE_DEFINED__
#define __IPassportTicket_INTERFACE_DEFINED__

/* interface IPassportTicket */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportTicket;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41651BF1-A5C8-11D2-95DF-00C04F8E7A70")
    IPassportTicket : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_unencryptedTicket( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_unencryptedTicket( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsAuthenticated( 
            /* [in] */ ULONG TimeWindow,
            /* [in] */ VARIANT_BOOL ForceLogin,
            /* [optional][in] */ VARIANT SecureCheck,
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TicketAge( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TimeSinceSignIn( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MemberId( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MemberIdLow( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MemberIdHigh( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HasSavedPassword( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SignInServer( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TicketTime( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SignInTime( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Error( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DoSecureCheck( 
            /* [in] */ BSTR bstrSec) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportTicketVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportTicket * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportTicket * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportTicket * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportTicket * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportTicket * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportTicket * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportTicket * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_unencryptedTicket )( 
            IPassportTicket * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_unencryptedTicket )( 
            IPassportTicket * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsAuthenticated )( 
            IPassportTicket * This,
            /* [in] */ ULONG TimeWindow,
            /* [in] */ VARIANT_BOOL ForceLogin,
            /* [optional][in] */ VARIANT SecureCheck,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TicketAge )( 
            IPassportTicket * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TimeSinceSignIn )( 
            IPassportTicket * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MemberId )( 
            IPassportTicket * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MemberIdLow )( 
            IPassportTicket * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MemberIdHigh )( 
            IPassportTicket * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasSavedPassword )( 
            IPassportTicket * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignInServer )( 
            IPassportTicket * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TicketTime )( 
            IPassportTicket * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignInTime )( 
            IPassportTicket * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Error )( 
            IPassportTicket * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DoSecureCheck )( 
            IPassportTicket * This,
            /* [in] */ BSTR bstrSec);
        
        END_INTERFACE
    } IPassportTicketVtbl;

    interface IPassportTicket
    {
        CONST_VTBL struct IPassportTicketVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportTicket_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportTicket_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportTicket_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportTicket_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportTicket_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportTicket_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportTicket_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportTicket_get_unencryptedTicket(This,pVal)	\
    (This)->lpVtbl -> get_unencryptedTicket(This,pVal)

#define IPassportTicket_put_unencryptedTicket(This,newVal)	\
    (This)->lpVtbl -> put_unencryptedTicket(This,newVal)

#define IPassportTicket_get_IsAuthenticated(This,TimeWindow,ForceLogin,SecureCheck,pVal)	\
    (This)->lpVtbl -> get_IsAuthenticated(This,TimeWindow,ForceLogin,SecureCheck,pVal)

#define IPassportTicket_get_TicketAge(This,pVal)	\
    (This)->lpVtbl -> get_TicketAge(This,pVal)

#define IPassportTicket_get_TimeSinceSignIn(This,pVal)	\
    (This)->lpVtbl -> get_TimeSinceSignIn(This,pVal)

#define IPassportTicket_get_MemberId(This,pVal)	\
    (This)->lpVtbl -> get_MemberId(This,pVal)

#define IPassportTicket_get_MemberIdLow(This,pVal)	\
    (This)->lpVtbl -> get_MemberIdLow(This,pVal)

#define IPassportTicket_get_MemberIdHigh(This,pVal)	\
    (This)->lpVtbl -> get_MemberIdHigh(This,pVal)

#define IPassportTicket_get_HasSavedPassword(This,pVal)	\
    (This)->lpVtbl -> get_HasSavedPassword(This,pVal)

#define IPassportTicket_get_SignInServer(This,pVal)	\
    (This)->lpVtbl -> get_SignInServer(This,pVal)

#define IPassportTicket_get_TicketTime(This,pVal)	\
    (This)->lpVtbl -> get_TicketTime(This,pVal)

#define IPassportTicket_get_SignInTime(This,pVal)	\
    (This)->lpVtbl -> get_SignInTime(This,pVal)

#define IPassportTicket_get_Error(This,pVal)	\
    (This)->lpVtbl -> get_Error(This,pVal)

#define IPassportTicket_DoSecureCheck(This,bstrSec)	\
    (This)->lpVtbl -> DoSecureCheck(This,bstrSec)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_unencryptedTicket_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportTicket_get_unencryptedTicket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportTicket_put_unencryptedTicket_Proxy( 
    IPassportTicket * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IPassportTicket_put_unencryptedTicket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_IsAuthenticated_Proxy( 
    IPassportTicket * This,
    /* [in] */ ULONG TimeWindow,
    /* [in] */ VARIANT_BOOL ForceLogin,
    /* [optional][in] */ VARIANT SecureCheck,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportTicket_get_IsAuthenticated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_TicketAge_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IPassportTicket_get_TicketAge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_TimeSinceSignIn_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IPassportTicket_get_TimeSinceSignIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_MemberId_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportTicket_get_MemberId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_MemberIdLow_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IPassportTicket_get_MemberIdLow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_MemberIdHigh_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IPassportTicket_get_MemberIdHigh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_HasSavedPassword_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportTicket_get_HasSavedPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_SignInServer_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportTicket_get_SignInServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_TicketTime_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IPassportTicket_get_TicketTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_SignInTime_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IPassportTicket_get_SignInTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportTicket_get_Error_Proxy( 
    IPassportTicket * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IPassportTicket_get_Error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportTicket_DoSecureCheck_Proxy( 
    IPassportTicket * This,
    /* [in] */ BSTR bstrSec);


void __RPC_STUB IPassportTicket_DoSecureCheck_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportTicket_INTERFACE_DEFINED__ */


#ifndef __IPassportTicket2_INTERFACE_DEFINED__
#define __IPassportTicket2_INTERFACE_DEFINED__

/* interface IPassportTicket2 */
/* [unique][helpstring][dual][uuid][object] */ 

typedef /* [public][public] */ 
enum __MIDL_IPassportTicket2_0001
    {	NeedConsent_No	= 0,
	NeedConsent_Yes	= 1,
	NeedConsent_Undefined	= 2
    } 	NeedConsentEnum;


EXTERN_C const IID IID_IPassportTicket2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5992F4F4-05CB-4944-A426-1E1870266F85")
    IPassportTicket2 : public IPassportTicket
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ BSTR propName,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetTertiaryConsent( 
            /* [in] */ BSTR consentCookie) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE needConsent( 
            /* [out] */ ULONG *consentFlags,
            /* [retval][out] */ NeedConsentEnum *pNeedConsent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportTicket2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportTicket2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportTicket2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportTicket2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportTicket2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportTicket2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportTicket2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportTicket2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_unencryptedTicket )( 
            IPassportTicket2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_unencryptedTicket )( 
            IPassportTicket2 * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsAuthenticated )( 
            IPassportTicket2 * This,
            /* [in] */ ULONG TimeWindow,
            /* [in] */ VARIANT_BOOL ForceLogin,
            /* [optional][in] */ VARIANT SecureCheck,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TicketAge )( 
            IPassportTicket2 * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TimeSinceSignIn )( 
            IPassportTicket2 * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MemberId )( 
            IPassportTicket2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MemberIdLow )( 
            IPassportTicket2 * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MemberIdHigh )( 
            IPassportTicket2 * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasSavedPassword )( 
            IPassportTicket2 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignInServer )( 
            IPassportTicket2 * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TicketTime )( 
            IPassportTicket2 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SignInTime )( 
            IPassportTicket2 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Error )( 
            IPassportTicket2 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DoSecureCheck )( 
            IPassportTicket2 * This,
            /* [in] */ BSTR bstrSec);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IPassportTicket2 * This,
            /* [in] */ BSTR propName,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetTertiaryConsent )( 
            IPassportTicket2 * This,
            /* [in] */ BSTR consentCookie);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *needConsent )( 
            IPassportTicket2 * This,
            /* [out] */ ULONG *consentFlags,
            /* [retval][out] */ NeedConsentEnum *pNeedConsent);
        
        END_INTERFACE
    } IPassportTicket2Vtbl;

    interface IPassportTicket2
    {
        CONST_VTBL struct IPassportTicket2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportTicket2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportTicket2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportTicket2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportTicket2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportTicket2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportTicket2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportTicket2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportTicket2_get_unencryptedTicket(This,pVal)	\
    (This)->lpVtbl -> get_unencryptedTicket(This,pVal)

#define IPassportTicket2_put_unencryptedTicket(This,newVal)	\
    (This)->lpVtbl -> put_unencryptedTicket(This,newVal)

#define IPassportTicket2_get_IsAuthenticated(This,TimeWindow,ForceLogin,SecureCheck,pVal)	\
    (This)->lpVtbl -> get_IsAuthenticated(This,TimeWindow,ForceLogin,SecureCheck,pVal)

#define IPassportTicket2_get_TicketAge(This,pVal)	\
    (This)->lpVtbl -> get_TicketAge(This,pVal)

#define IPassportTicket2_get_TimeSinceSignIn(This,pVal)	\
    (This)->lpVtbl -> get_TimeSinceSignIn(This,pVal)

#define IPassportTicket2_get_MemberId(This,pVal)	\
    (This)->lpVtbl -> get_MemberId(This,pVal)

#define IPassportTicket2_get_MemberIdLow(This,pVal)	\
    (This)->lpVtbl -> get_MemberIdLow(This,pVal)

#define IPassportTicket2_get_MemberIdHigh(This,pVal)	\
    (This)->lpVtbl -> get_MemberIdHigh(This,pVal)

#define IPassportTicket2_get_HasSavedPassword(This,pVal)	\
    (This)->lpVtbl -> get_HasSavedPassword(This,pVal)

#define IPassportTicket2_get_SignInServer(This,pVal)	\
    (This)->lpVtbl -> get_SignInServer(This,pVal)

#define IPassportTicket2_get_TicketTime(This,pVal)	\
    (This)->lpVtbl -> get_TicketTime(This,pVal)

#define IPassportTicket2_get_SignInTime(This,pVal)	\
    (This)->lpVtbl -> get_SignInTime(This,pVal)

#define IPassportTicket2_get_Error(This,pVal)	\
    (This)->lpVtbl -> get_Error(This,pVal)

#define IPassportTicket2_DoSecureCheck(This,bstrSec)	\
    (This)->lpVtbl -> DoSecureCheck(This,bstrSec)


#define IPassportTicket2_GetProperty(This,propName,pVal)	\
    (This)->lpVtbl -> GetProperty(This,propName,pVal)

#define IPassportTicket2_SetTertiaryConsent(This,consentCookie)	\
    (This)->lpVtbl -> SetTertiaryConsent(This,consentCookie)

#define IPassportTicket2_needConsent(This,consentFlags,pNeedConsent)	\
    (This)->lpVtbl -> needConsent(This,consentFlags,pNeedConsent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportTicket2_GetProperty_Proxy( 
    IPassportTicket2 * This,
    /* [in] */ BSTR propName,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IPassportTicket2_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportTicket2_SetTertiaryConsent_Proxy( 
    IPassportTicket2 * This,
    /* [in] */ BSTR consentCookie);


void __RPC_STUB IPassportTicket2_SetTertiaryConsent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportTicket2_needConsent_Proxy( 
    IPassportTicket2 * This,
    /* [out] */ ULONG *consentFlags,
    /* [retval][out] */ NeedConsentEnum *pNeedConsent);


void __RPC_STUB IPassportTicket2_needConsent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportTicket2_INTERFACE_DEFINED__ */


#ifndef __IPassportProfile_INTERFACE_DEFINED__
#define __IPassportProfile_INTERFACE_DEFINED__

/* interface IPassportProfile */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41651BF3-A5C8-11D2-95DF-00C04F8E7A70")
    IPassportProfile : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Attribute( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Attribute( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ByIndex( 
            /* [in] */ int index,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ByIndex( 
            /* [in] */ int index,
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsValid( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SchemaName( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SchemaName( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_unencryptedProfile( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_unencryptedProfile( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_updateString( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportProfile * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportProfile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportProfile * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportProfile * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportProfile * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportProfile * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Attribute )( 
            IPassportProfile * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Attribute )( 
            IPassportProfile * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ByIndex )( 
            IPassportProfile * This,
            /* [in] */ int index,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ByIndex )( 
            IPassportProfile * This,
            /* [in] */ int index,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsValid )( 
            IPassportProfile * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SchemaName )( 
            IPassportProfile * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SchemaName )( 
            IPassportProfile * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_unencryptedProfile )( 
            IPassportProfile * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_unencryptedProfile )( 
            IPassportProfile * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_updateString )( 
            IPassportProfile * This,
            /* [retval][out] */ BSTR *pVal);
        
        END_INTERFACE
    } IPassportProfileVtbl;

    interface IPassportProfile
    {
        CONST_VTBL struct IPassportProfileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportProfile_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportProfile_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportProfile_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportProfile_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportProfile_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportProfile_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportProfile_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportProfile_get_Attribute(This,name,pVal)	\
    (This)->lpVtbl -> get_Attribute(This,name,pVal)

#define IPassportProfile_put_Attribute(This,name,newVal)	\
    (This)->lpVtbl -> put_Attribute(This,name,newVal)

#define IPassportProfile_get_ByIndex(This,index,pVal)	\
    (This)->lpVtbl -> get_ByIndex(This,index,pVal)

#define IPassportProfile_put_ByIndex(This,index,newVal)	\
    (This)->lpVtbl -> put_ByIndex(This,index,newVal)

#define IPassportProfile_get_IsValid(This,pVal)	\
    (This)->lpVtbl -> get_IsValid(This,pVal)

#define IPassportProfile_get_SchemaName(This,pVal)	\
    (This)->lpVtbl -> get_SchemaName(This,pVal)

#define IPassportProfile_put_SchemaName(This,newVal)	\
    (This)->lpVtbl -> put_SchemaName(This,newVal)

#define IPassportProfile_get_unencryptedProfile(This,pVal)	\
    (This)->lpVtbl -> get_unencryptedProfile(This,pVal)

#define IPassportProfile_put_unencryptedProfile(This,newVal)	\
    (This)->lpVtbl -> put_unencryptedProfile(This,newVal)

#define IPassportProfile_get_updateString(This,pVal)	\
    (This)->lpVtbl -> get_updateString(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_Attribute_Proxy( 
    IPassportProfile * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IPassportProfile_get_Attribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportProfile_put_Attribute_Proxy( 
    IPassportProfile * This,
    /* [in] */ BSTR name,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IPassportProfile_put_Attribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_ByIndex_Proxy( 
    IPassportProfile * This,
    /* [in] */ int index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IPassportProfile_get_ByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportProfile_put_ByIndex_Proxy( 
    IPassportProfile * This,
    /* [in] */ int index,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IPassportProfile_put_ByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_IsValid_Proxy( 
    IPassportProfile * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportProfile_get_IsValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_SchemaName_Proxy( 
    IPassportProfile * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportProfile_get_SchemaName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportProfile_put_SchemaName_Proxy( 
    IPassportProfile * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IPassportProfile_put_SchemaName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_unencryptedProfile_Proxy( 
    IPassportProfile * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportProfile_get_unencryptedProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportProfile_put_unencryptedProfile_Proxy( 
    IPassportProfile * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IPassportProfile_put_unencryptedProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportProfile_get_updateString_Proxy( 
    IPassportProfile * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportProfile_get_updateString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportProfile_INTERFACE_DEFINED__ */


#ifndef __IPassportManager_INTERFACE_DEFINED__
#define __IPassportManager_INTERFACE_DEFINED__

/* interface IPassportManager */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41651BEF-A5C8-11D2-95DF-00C04F8E7A70")
    IPassportManager : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnStartPage( 
            /* [in] */ IUnknown *piUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnEndPage( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnStartPageECB( 
            /* [in] */ BYTE *pECB,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE _Ticket( 
            /* [out] */ IPassportTicket **piTicket) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE _Profile( 
            /* [out] */ IPassportProfile **piProfile) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AuthURL( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pAuthVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsAuthenticated( 
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT CheckSecure,
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LogoTag( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HasProfile( 
            /* [optional][in] */ VARIANT ProfileName,
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HasTicket( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FromNetworkServer( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HasFlag( 
            /* [optional][in] */ VARIANT flagMask,
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TicketAge( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TimeSinceSignIn( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDomainAttribute( 
            /* [in] */ BSTR attributeName,
            /* [optional][in] */ VARIANT lcid,
            /* [optional][in] */ VARIANT domain,
            /* [retval][out] */ BSTR *pAttrVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DomainFromMemberName( 
            /* [optional][in] */ VARIANT memberName,
            /* [retval][out] */ BSTR *pDomainName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProfileByIndex( 
            /* [in] */ int index,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ProfileByIndex( 
            /* [in] */ int index,
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnStartPageManual( 
            /* [in] */ BSTR queryStringT,
            /* [in] */ BSTR queryStringP,
            /* [in] */ BSTR MSPAuthCookie,
            /* [in] */ BSTR MSPProfCookie,
            /* [in] */ BSTR MSPConsentCookie,
            /* [optional][in] */ VARIANT vMSPSecCookie,
            /* [retval][out] */ VARIANT *pSetCookieArray) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HasSavedPassword( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Commit( 
            /* [retval][out] */ BSTR *pNewProfileCookieHeader) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Profile( 
            /* [in] */ BSTR attributeName,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Profile( 
            /* [in] */ BSTR attributeName,
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_TicketTime( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_SignInTime( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_Domains( 
            /* [retval][out] */ VARIANT *pArrayVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Error( 
            /* [retval][out] */ long *pErrorVal) = 0;
        
        virtual /* [helpstring][hidden] */ HRESULT STDMETHODCALLTYPE OnStartPageFilter( 
            /* [in] */ BYTE *pPFC,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnStartPageASP( 
            /* [in] */ IDispatch *pdispRequest,
            /* [in] */ IDispatch *pdispResponse) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE GetServerInfo( 
            /* [retval][out] */ BSTR *pbstrOut) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HaveConsent( 
            /* [in] */ VARIANT_BOOL bNeedFullConsent,
            /* [in] */ VARIANT_BOOL bNeedBirthdate,
            /* [retval][out] */ VARIANT_BOOL *pbHaveConsent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportManager * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportManager * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartPage )( 
            IPassportManager * This,
            /* [in] */ IUnknown *piUnk);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndPage )( 
            IPassportManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartPageECB )( 
            IPassportManager * This,
            /* [in] */ BYTE *pECB,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE *_Ticket )( 
            IPassportManager * This,
            /* [out] */ IPassportTicket **piTicket);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE *_Profile )( 
            IPassportManager * This,
            /* [out] */ IPassportProfile **piProfile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AuthURL )( 
            IPassportManager * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pAuthVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsAuthenticated )( 
            IPassportManager * This,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT CheckSecure,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoTag )( 
            IPassportManager * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HasProfile )( 
            IPassportManager * This,
            /* [optional][in] */ VARIANT ProfileName,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasTicket )( 
            IPassportManager * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FromNetworkServer )( 
            IPassportManager * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HasFlag )( 
            IPassportManager * This,
            /* [optional][in] */ VARIANT flagMask,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TicketAge )( 
            IPassportManager * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TimeSinceSignIn )( 
            IPassportManager * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDomainAttribute )( 
            IPassportManager * This,
            /* [in] */ BSTR attributeName,
            /* [optional][in] */ VARIANT lcid,
            /* [optional][in] */ VARIANT domain,
            /* [retval][out] */ BSTR *pAttrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DomainFromMemberName )( 
            IPassportManager * This,
            /* [optional][in] */ VARIANT memberName,
            /* [retval][out] */ BSTR *pDomainName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProfileByIndex )( 
            IPassportManager * This,
            /* [in] */ int index,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProfileByIndex )( 
            IPassportManager * This,
            /* [in] */ int index,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageManual )( 
            IPassportManager * This,
            /* [in] */ BSTR queryStringT,
            /* [in] */ BSTR queryStringP,
            /* [in] */ BSTR MSPAuthCookie,
            /* [in] */ BSTR MSPProfCookie,
            /* [in] */ BSTR MSPConsentCookie,
            /* [optional][in] */ VARIANT vMSPSecCookie,
            /* [retval][out] */ VARIANT *pSetCookieArray);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasSavedPassword )( 
            IPassportManager * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IPassportManager * This,
            /* [retval][out] */ BSTR *pNewProfileCookieHeader);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profile )( 
            IPassportManager * This,
            /* [in] */ BSTR attributeName,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Profile )( 
            IPassportManager * This,
            /* [in] */ BSTR attributeName,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_TicketTime )( 
            IPassportManager * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_SignInTime )( 
            IPassportManager * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Domains )( 
            IPassportManager * This,
            /* [retval][out] */ VARIANT *pArrayVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Error )( 
            IPassportManager * This,
            /* [retval][out] */ long *pErrorVal);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageFilter )( 
            IPassportManager * This,
            /* [in] */ BYTE *pPFC,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageASP )( 
            IPassportManager * This,
            /* [in] */ IDispatch *pdispRequest,
            /* [in] */ IDispatch *pdispResponse);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE *GetServerInfo )( 
            IPassportManager * This,
            /* [retval][out] */ BSTR *pbstrOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HaveConsent )( 
            IPassportManager * This,
            /* [in] */ VARIANT_BOOL bNeedFullConsent,
            /* [in] */ VARIANT_BOOL bNeedBirthdate,
            /* [retval][out] */ VARIANT_BOOL *pbHaveConsent);
        
        END_INTERFACE
    } IPassportManagerVtbl;

    interface IPassportManager
    {
        CONST_VTBL struct IPassportManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportManager_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportManager_OnStartPage(This,piUnk)	\
    (This)->lpVtbl -> OnStartPage(This,piUnk)

#define IPassportManager_OnEndPage(This)	\
    (This)->lpVtbl -> OnEndPage(This)

#define IPassportManager_OnStartPageECB(This,pECB,pBufSize,pCookieHeader)	\
    (This)->lpVtbl -> OnStartPageECB(This,pECB,pBufSize,pCookieHeader)

#define IPassportManager__Ticket(This,piTicket)	\
    (This)->lpVtbl -> _Ticket(This,piTicket)

#define IPassportManager__Profile(This,piProfile)	\
    (This)->lpVtbl -> _Profile(This,piProfile)

#define IPassportManager_AuthURL(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)	\
    (This)->lpVtbl -> AuthURL(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)

#define IPassportManager_IsAuthenticated(This,TimeWindow,ForceLogin,CheckSecure,pVal)	\
    (This)->lpVtbl -> IsAuthenticated(This,TimeWindow,ForceLogin,CheckSecure,pVal)

#define IPassportManager_LogoTag(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)	\
    (This)->lpVtbl -> LogoTag(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)

#define IPassportManager_HasProfile(This,ProfileName,pVal)	\
    (This)->lpVtbl -> HasProfile(This,ProfileName,pVal)

#define IPassportManager_get_HasTicket(This,pVal)	\
    (This)->lpVtbl -> get_HasTicket(This,pVal)

#define IPassportManager_get_FromNetworkServer(This,pVal)	\
    (This)->lpVtbl -> get_FromNetworkServer(This,pVal)

#define IPassportManager_HasFlag(This,flagMask,pVal)	\
    (This)->lpVtbl -> HasFlag(This,flagMask,pVal)

#define IPassportManager_get_TicketAge(This,pVal)	\
    (This)->lpVtbl -> get_TicketAge(This,pVal)

#define IPassportManager_get_TimeSinceSignIn(This,pVal)	\
    (This)->lpVtbl -> get_TimeSinceSignIn(This,pVal)

#define IPassportManager_GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)	\
    (This)->lpVtbl -> GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)

#define IPassportManager_DomainFromMemberName(This,memberName,pDomainName)	\
    (This)->lpVtbl -> DomainFromMemberName(This,memberName,pDomainName)

#define IPassportManager_get_ProfileByIndex(This,index,pVal)	\
    (This)->lpVtbl -> get_ProfileByIndex(This,index,pVal)

#define IPassportManager_put_ProfileByIndex(This,index,newVal)	\
    (This)->lpVtbl -> put_ProfileByIndex(This,index,newVal)

#define IPassportManager_OnStartPageManual(This,queryStringT,queryStringP,MSPAuthCookie,MSPProfCookie,MSPConsentCookie,vMSPSecCookie,pSetCookieArray)	\
    (This)->lpVtbl -> OnStartPageManual(This,queryStringT,queryStringP,MSPAuthCookie,MSPProfCookie,MSPConsentCookie,vMSPSecCookie,pSetCookieArray)

#define IPassportManager_get_HasSavedPassword(This,pVal)	\
    (This)->lpVtbl -> get_HasSavedPassword(This,pVal)

#define IPassportManager_Commit(This,pNewProfileCookieHeader)	\
    (This)->lpVtbl -> Commit(This,pNewProfileCookieHeader)

#define IPassportManager_get_Profile(This,attributeName,pVal)	\
    (This)->lpVtbl -> get_Profile(This,attributeName,pVal)

#define IPassportManager_put_Profile(This,attributeName,newVal)	\
    (This)->lpVtbl -> put_Profile(This,attributeName,newVal)

#define IPassportManager_get_TicketTime(This,pVal)	\
    (This)->lpVtbl -> get_TicketTime(This,pVal)

#define IPassportManager_get_SignInTime(This,pVal)	\
    (This)->lpVtbl -> get_SignInTime(This,pVal)

#define IPassportManager_get_Domains(This,pArrayVal)	\
    (This)->lpVtbl -> get_Domains(This,pArrayVal)

#define IPassportManager_get_Error(This,pErrorVal)	\
    (This)->lpVtbl -> get_Error(This,pErrorVal)

#define IPassportManager_OnStartPageFilter(This,pPFC,pBufSize,pCookieHeader)	\
    (This)->lpVtbl -> OnStartPageFilter(This,pPFC,pBufSize,pCookieHeader)

#define IPassportManager_OnStartPageASP(This,pdispRequest,pdispResponse)	\
    (This)->lpVtbl -> OnStartPageASP(This,pdispRequest,pdispResponse)

#define IPassportManager_GetServerInfo(This,pbstrOut)	\
    (This)->lpVtbl -> GetServerInfo(This,pbstrOut)

#define IPassportManager_HaveConsent(This,bNeedFullConsent,bNeedBirthdate,pbHaveConsent)	\
    (This)->lpVtbl -> HaveConsent(This,bNeedFullConsent,bNeedBirthdate,pbHaveConsent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPassportManager_OnStartPage_Proxy( 
    IPassportManager * This,
    /* [in] */ IUnknown *piUnk);


void __RPC_STUB IPassportManager_OnStartPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPassportManager_OnEndPage_Proxy( 
    IPassportManager * This);


void __RPC_STUB IPassportManager_OnEndPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPassportManager_OnStartPageECB_Proxy( 
    IPassportManager * This,
    /* [in] */ BYTE *pECB,
    /* [out][in] */ DWORD *pBufSize,
    /* [size_is][out] */ LPSTR pCookieHeader);


void __RPC_STUB IPassportManager_OnStartPageECB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager__Ticket_Proxy( 
    IPassportManager * This,
    /* [out] */ IPassportTicket **piTicket);


void __RPC_STUB IPassportManager__Ticket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager__Profile_Proxy( 
    IPassportManager * This,
    /* [out] */ IPassportProfile **piProfile);


void __RPC_STUB IPassportManager__Profile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_AuthURL_Proxy( 
    IPassportManager * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT coBrandArgs,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT KPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ BSTR *pAuthVal);


void __RPC_STUB IPassportManager_AuthURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_IsAuthenticated_Proxy( 
    IPassportManager * This,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT CheckSecure,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportManager_IsAuthenticated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_LogoTag_Proxy( 
    IPassportManager * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT coBrandArgs,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT bSecure,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT KPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportManager_LogoTag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_HasProfile_Proxy( 
    IPassportManager * This,
    /* [optional][in] */ VARIANT ProfileName,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportManager_HasProfile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_HasTicket_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportManager_get_HasTicket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_FromNetworkServer_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportManager_get_FromNetworkServer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_HasFlag_Proxy( 
    IPassportManager * This,
    /* [optional][in] */ VARIANT flagMask,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportManager_HasFlag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_TicketAge_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IPassportManager_get_TicketAge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_TimeSinceSignIn_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IPassportManager_get_TimeSinceSignIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_GetDomainAttribute_Proxy( 
    IPassportManager * This,
    /* [in] */ BSTR attributeName,
    /* [optional][in] */ VARIANT lcid,
    /* [optional][in] */ VARIANT domain,
    /* [retval][out] */ BSTR *pAttrVal);


void __RPC_STUB IPassportManager_GetDomainAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_DomainFromMemberName_Proxy( 
    IPassportManager * This,
    /* [optional][in] */ VARIANT memberName,
    /* [retval][out] */ BSTR *pDomainName);


void __RPC_STUB IPassportManager_DomainFromMemberName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_ProfileByIndex_Proxy( 
    IPassportManager * This,
    /* [in] */ int index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IPassportManager_get_ProfileByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportManager_put_ProfileByIndex_Proxy( 
    IPassportManager * This,
    /* [in] */ int index,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IPassportManager_put_ProfileByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_OnStartPageManual_Proxy( 
    IPassportManager * This,
    /* [in] */ BSTR queryStringT,
    /* [in] */ BSTR queryStringP,
    /* [in] */ BSTR MSPAuthCookie,
    /* [in] */ BSTR MSPProfCookie,
    /* [in] */ BSTR MSPConsentCookie,
    /* [optional][in] */ VARIANT vMSPSecCookie,
    /* [retval][out] */ VARIANT *pSetCookieArray);


void __RPC_STUB IPassportManager_OnStartPageManual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_HasSavedPassword_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportManager_get_HasSavedPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_Commit_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ BSTR *pNewProfileCookieHeader);


void __RPC_STUB IPassportManager_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_Profile_Proxy( 
    IPassportManager * This,
    /* [in] */ BSTR attributeName,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IPassportManager_get_Profile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportManager_put_Profile_Proxy( 
    IPassportManager * This,
    /* [in] */ BSTR attributeName,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IPassportManager_put_Profile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_TicketTime_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IPassportManager_get_TicketTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_SignInTime_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB IPassportManager_get_SignInTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_Domains_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ VARIANT *pArrayVal);


void __RPC_STUB IPassportManager_get_Domains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager_get_Error_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ long *pErrorVal);


void __RPC_STUB IPassportManager_get_Error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager_OnStartPageFilter_Proxy( 
    IPassportManager * This,
    /* [in] */ BYTE *pPFC,
    /* [out][in] */ DWORD *pBufSize,
    /* [size_is][out] */ LPSTR pCookieHeader);


void __RPC_STUB IPassportManager_OnStartPageFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_OnStartPageASP_Proxy( 
    IPassportManager * This,
    /* [in] */ IDispatch *pdispRequest,
    /* [in] */ IDispatch *pdispResponse);


void __RPC_STUB IPassportManager_OnStartPageASP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IPassportManager_GetServerInfo_Proxy( 
    IPassportManager * This,
    /* [retval][out] */ BSTR *pbstrOut);


void __RPC_STUB IPassportManager_GetServerInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager_HaveConsent_Proxy( 
    IPassportManager * This,
    /* [in] */ VARIANT_BOOL bNeedFullConsent,
    /* [in] */ VARIANT_BOOL bNeedBirthdate,
    /* [retval][out] */ VARIANT_BOOL *pbHaveConsent);


void __RPC_STUB IPassportManager_HaveConsent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportManager_INTERFACE_DEFINED__ */


#ifndef __IPassportManager2_INTERFACE_DEFINED__
#define __IPassportManager2_INTERFACE_DEFINED__

/* interface IPassportManager2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8ca48d6a-0b51-4f7a-9475-b0a8b59c3999")
    IPassportManager2 : public IPassportManager
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LoginUser( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandTemplate,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT UseSecureAuth,
            /* [optional][in] */ VARIANT ExtraParams) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AuthURL2( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pAuthVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LogoTag2( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportManager2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportManager2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportManager2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportManager2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportManager2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportManager2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportManager2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartPage )( 
            IPassportManager2 * This,
            /* [in] */ IUnknown *piUnk);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndPage )( 
            IPassportManager2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartPageECB )( 
            IPassportManager2 * This,
            /* [in] */ BYTE *pECB,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE *_Ticket )( 
            IPassportManager2 * This,
            /* [out] */ IPassportTicket **piTicket);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE *_Profile )( 
            IPassportManager2 * This,
            /* [out] */ IPassportProfile **piProfile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AuthURL )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pAuthVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsAuthenticated )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT CheckSecure,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoTag )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HasProfile )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT ProfileName,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasTicket )( 
            IPassportManager2 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FromNetworkServer )( 
            IPassportManager2 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HasFlag )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT flagMask,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TicketAge )( 
            IPassportManager2 * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TimeSinceSignIn )( 
            IPassportManager2 * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDomainAttribute )( 
            IPassportManager2 * This,
            /* [in] */ BSTR attributeName,
            /* [optional][in] */ VARIANT lcid,
            /* [optional][in] */ VARIANT domain,
            /* [retval][out] */ BSTR *pAttrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DomainFromMemberName )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT memberName,
            /* [retval][out] */ BSTR *pDomainName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProfileByIndex )( 
            IPassportManager2 * This,
            /* [in] */ int index,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProfileByIndex )( 
            IPassportManager2 * This,
            /* [in] */ int index,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageManual )( 
            IPassportManager2 * This,
            /* [in] */ BSTR queryStringT,
            /* [in] */ BSTR queryStringP,
            /* [in] */ BSTR MSPAuthCookie,
            /* [in] */ BSTR MSPProfCookie,
            /* [in] */ BSTR MSPConsentCookie,
            /* [optional][in] */ VARIANT vMSPSecCookie,
            /* [retval][out] */ VARIANT *pSetCookieArray);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasSavedPassword )( 
            IPassportManager2 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IPassportManager2 * This,
            /* [retval][out] */ BSTR *pNewProfileCookieHeader);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profile )( 
            IPassportManager2 * This,
            /* [in] */ BSTR attributeName,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Profile )( 
            IPassportManager2 * This,
            /* [in] */ BSTR attributeName,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_TicketTime )( 
            IPassportManager2 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_SignInTime )( 
            IPassportManager2 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Domains )( 
            IPassportManager2 * This,
            /* [retval][out] */ VARIANT *pArrayVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Error )( 
            IPassportManager2 * This,
            /* [retval][out] */ long *pErrorVal);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageFilter )( 
            IPassportManager2 * This,
            /* [in] */ BYTE *pPFC,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageASP )( 
            IPassportManager2 * This,
            /* [in] */ IDispatch *pdispRequest,
            /* [in] */ IDispatch *pdispResponse);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE *GetServerInfo )( 
            IPassportManager2 * This,
            /* [retval][out] */ BSTR *pbstrOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HaveConsent )( 
            IPassportManager2 * This,
            /* [in] */ VARIANT_BOOL bNeedFullConsent,
            /* [in] */ VARIANT_BOOL bNeedBirthdate,
            /* [retval][out] */ VARIANT_BOOL *pbHaveConsent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LoginUser )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandTemplate,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT UseSecureAuth,
            /* [optional][in] */ VARIANT ExtraParams);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AuthURL2 )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pAuthVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoTag2 )( 
            IPassportManager2 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pVal);
        
        END_INTERFACE
    } IPassportManager2Vtbl;

    interface IPassportManager2
    {
        CONST_VTBL struct IPassportManager2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportManager2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportManager2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportManager2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportManager2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportManager2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportManager2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportManager2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportManager2_OnStartPage(This,piUnk)	\
    (This)->lpVtbl -> OnStartPage(This,piUnk)

#define IPassportManager2_OnEndPage(This)	\
    (This)->lpVtbl -> OnEndPage(This)

#define IPassportManager2_OnStartPageECB(This,pECB,pBufSize,pCookieHeader)	\
    (This)->lpVtbl -> OnStartPageECB(This,pECB,pBufSize,pCookieHeader)

#define IPassportManager2__Ticket(This,piTicket)	\
    (This)->lpVtbl -> _Ticket(This,piTicket)

#define IPassportManager2__Profile(This,piProfile)	\
    (This)->lpVtbl -> _Profile(This,piProfile)

#define IPassportManager2_AuthURL(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)	\
    (This)->lpVtbl -> AuthURL(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)

#define IPassportManager2_IsAuthenticated(This,TimeWindow,ForceLogin,CheckSecure,pVal)	\
    (This)->lpVtbl -> IsAuthenticated(This,TimeWindow,ForceLogin,CheckSecure,pVal)

#define IPassportManager2_LogoTag(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)	\
    (This)->lpVtbl -> LogoTag(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)

#define IPassportManager2_HasProfile(This,ProfileName,pVal)	\
    (This)->lpVtbl -> HasProfile(This,ProfileName,pVal)

#define IPassportManager2_get_HasTicket(This,pVal)	\
    (This)->lpVtbl -> get_HasTicket(This,pVal)

#define IPassportManager2_get_FromNetworkServer(This,pVal)	\
    (This)->lpVtbl -> get_FromNetworkServer(This,pVal)

#define IPassportManager2_HasFlag(This,flagMask,pVal)	\
    (This)->lpVtbl -> HasFlag(This,flagMask,pVal)

#define IPassportManager2_get_TicketAge(This,pVal)	\
    (This)->lpVtbl -> get_TicketAge(This,pVal)

#define IPassportManager2_get_TimeSinceSignIn(This,pVal)	\
    (This)->lpVtbl -> get_TimeSinceSignIn(This,pVal)

#define IPassportManager2_GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)	\
    (This)->lpVtbl -> GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)

#define IPassportManager2_DomainFromMemberName(This,memberName,pDomainName)	\
    (This)->lpVtbl -> DomainFromMemberName(This,memberName,pDomainName)

#define IPassportManager2_get_ProfileByIndex(This,index,pVal)	\
    (This)->lpVtbl -> get_ProfileByIndex(This,index,pVal)

#define IPassportManager2_put_ProfileByIndex(This,index,newVal)	\
    (This)->lpVtbl -> put_ProfileByIndex(This,index,newVal)

#define IPassportManager2_OnStartPageManual(This,queryStringT,queryStringP,MSPAuthCookie,MSPProfCookie,MSPConsentCookie,vMSPSecCookie,pSetCookieArray)	\
    (This)->lpVtbl -> OnStartPageManual(This,queryStringT,queryStringP,MSPAuthCookie,MSPProfCookie,MSPConsentCookie,vMSPSecCookie,pSetCookieArray)

#define IPassportManager2_get_HasSavedPassword(This,pVal)	\
    (This)->lpVtbl -> get_HasSavedPassword(This,pVal)

#define IPassportManager2_Commit(This,pNewProfileCookieHeader)	\
    (This)->lpVtbl -> Commit(This,pNewProfileCookieHeader)

#define IPassportManager2_get_Profile(This,attributeName,pVal)	\
    (This)->lpVtbl -> get_Profile(This,attributeName,pVal)

#define IPassportManager2_put_Profile(This,attributeName,newVal)	\
    (This)->lpVtbl -> put_Profile(This,attributeName,newVal)

#define IPassportManager2_get_TicketTime(This,pVal)	\
    (This)->lpVtbl -> get_TicketTime(This,pVal)

#define IPassportManager2_get_SignInTime(This,pVal)	\
    (This)->lpVtbl -> get_SignInTime(This,pVal)

#define IPassportManager2_get_Domains(This,pArrayVal)	\
    (This)->lpVtbl -> get_Domains(This,pArrayVal)

#define IPassportManager2_get_Error(This,pErrorVal)	\
    (This)->lpVtbl -> get_Error(This,pErrorVal)

#define IPassportManager2_OnStartPageFilter(This,pPFC,pBufSize,pCookieHeader)	\
    (This)->lpVtbl -> OnStartPageFilter(This,pPFC,pBufSize,pCookieHeader)

#define IPassportManager2_OnStartPageASP(This,pdispRequest,pdispResponse)	\
    (This)->lpVtbl -> OnStartPageASP(This,pdispRequest,pdispResponse)

#define IPassportManager2_GetServerInfo(This,pbstrOut)	\
    (This)->lpVtbl -> GetServerInfo(This,pbstrOut)

#define IPassportManager2_HaveConsent(This,bNeedFullConsent,bNeedBirthdate,pbHaveConsent)	\
    (This)->lpVtbl -> HaveConsent(This,bNeedFullConsent,bNeedBirthdate,pbHaveConsent)


#define IPassportManager2_LoginUser(This,returnUrl,TimeWindow,ForceLogin,coBrandTemplate,lang_id,NameSpace,KPP,UseSecureAuth,ExtraParams)	\
    (This)->lpVtbl -> LoginUser(This,returnUrl,TimeWindow,ForceLogin,coBrandTemplate,lang_id,NameSpace,KPP,UseSecureAuth,ExtraParams)

#define IPassportManager2_AuthURL2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)	\
    (This)->lpVtbl -> AuthURL2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)

#define IPassportManager2_LogoTag2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)	\
    (This)->lpVtbl -> LogoTag2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager2_LoginUser_Proxy( 
    IPassportManager2 * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT coBrandTemplate,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT KPP,
    /* [optional][in] */ VARIANT UseSecureAuth,
    /* [optional][in] */ VARIANT ExtraParams);


void __RPC_STUB IPassportManager2_LoginUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager2_AuthURL2_Proxy( 
    IPassportManager2 * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT coBrandArgs,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT KPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ BSTR *pAuthVal);


void __RPC_STUB IPassportManager2_AuthURL2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager2_LogoTag2_Proxy( 
    IPassportManager2 * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT coBrandArgs,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT bSecure,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT KPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportManager2_LogoTag2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportManager2_INTERFACE_DEFINED__ */


#ifndef __IPassportManager3_INTERFACE_DEFINED__
#define __IPassportManager3_INTERFACE_DEFINED__

/* interface IPassportManager3 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportManager3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1451151f-90a0-491b-b8e1-81a13767ed98")
    IPassportManager3 : public IPassportManager2
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Ticket( 
            /* [in] */ BSTR attributeName,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCurrentConfig( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LogoutURL( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT bSecure,
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLoginChallenge( 
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandTemplate,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT UseSecureAuth,
            /* [optional][in] */ VARIANT ExtraParams,
            /* [optional][out] */ VARIANT *pAuthHeader,
            /* [retval][out] */ BSTR *pAuthVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HexPUID( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportManager3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportManager3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportManager3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportManager3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportManager3 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportManager3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportManager3 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportManager3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartPage )( 
            IPassportManager3 * This,
            /* [in] */ IUnknown *piUnk);
        
        HRESULT ( STDMETHODCALLTYPE *OnEndPage )( 
            IPassportManager3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnStartPageECB )( 
            IPassportManager3 * This,
            /* [in] */ BYTE *pECB,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE *_Ticket )( 
            IPassportManager3 * This,
            /* [out] */ IPassportTicket **piTicket);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE *_Profile )( 
            IPassportManager3 * This,
            /* [out] */ IPassportProfile **piProfile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AuthURL )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pAuthVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsAuthenticated )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT CheckSecure,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoTag )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HasProfile )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT ProfileName,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasTicket )( 
            IPassportManager3 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FromNetworkServer )( 
            IPassportManager3 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HasFlag )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT flagMask,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TicketAge )( 
            IPassportManager3 * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TimeSinceSignIn )( 
            IPassportManager3 * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDomainAttribute )( 
            IPassportManager3 * This,
            /* [in] */ BSTR attributeName,
            /* [optional][in] */ VARIANT lcid,
            /* [optional][in] */ VARIANT domain,
            /* [retval][out] */ BSTR *pAttrVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DomainFromMemberName )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT memberName,
            /* [retval][out] */ BSTR *pDomainName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProfileByIndex )( 
            IPassportManager3 * This,
            /* [in] */ int index,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ProfileByIndex )( 
            IPassportManager3 * This,
            /* [in] */ int index,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageManual )( 
            IPassportManager3 * This,
            /* [in] */ BSTR queryStringT,
            /* [in] */ BSTR queryStringP,
            /* [in] */ BSTR MSPAuthCookie,
            /* [in] */ BSTR MSPProfCookie,
            /* [in] */ BSTR MSPConsentCookie,
            /* [optional][in] */ VARIANT vMSPSecCookie,
            /* [retval][out] */ VARIANT *pSetCookieArray);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HasSavedPassword )( 
            IPassportManager3 * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IPassportManager3 * This,
            /* [retval][out] */ BSTR *pNewProfileCookieHeader);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Profile )( 
            IPassportManager3 * This,
            /* [in] */ BSTR attributeName,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Profile )( 
            IPassportManager3 * This,
            /* [in] */ BSTR attributeName,
            /* [in] */ VARIANT newVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_TicketTime )( 
            IPassportManager3 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_SignInTime )( 
            IPassportManager3 * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_Domains )( 
            IPassportManager3 * This,
            /* [retval][out] */ VARIANT *pArrayVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Error )( 
            IPassportManager3 * This,
            /* [retval][out] */ long *pErrorVal);
        
        /* [helpstring][hidden] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageFilter )( 
            IPassportManager3 * This,
            /* [in] */ BYTE *pPFC,
            /* [out][in] */ DWORD *pBufSize,
            /* [size_is][out] */ LPSTR pCookieHeader);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnStartPageASP )( 
            IPassportManager3 * This,
            /* [in] */ IDispatch *pdispRequest,
            /* [in] */ IDispatch *pdispResponse);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE *GetServerInfo )( 
            IPassportManager3 * This,
            /* [retval][out] */ BSTR *pbstrOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *HaveConsent )( 
            IPassportManager3 * This,
            /* [in] */ VARIANT_BOOL bNeedFullConsent,
            /* [in] */ VARIANT_BOOL bNeedBirthdate,
            /* [retval][out] */ VARIANT_BOOL *pbHaveConsent);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LoginUser )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandTemplate,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT UseSecureAuth,
            /* [optional][in] */ VARIANT ExtraParams);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AuthURL2 )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pAuthVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoTag2 )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT bSecure,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Ticket )( 
            IPassportManager3 * This,
            /* [in] */ BSTR attributeName,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCurrentConfig )( 
            IPassportManager3 * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoutURL )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT coBrandArgs,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT bSecure,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetLoginChallenge )( 
            IPassportManager3 * This,
            /* [optional][in] */ VARIANT returnUrl,
            /* [optional][in] */ VARIANT TimeWindow,
            /* [optional][in] */ VARIANT ForceLogin,
            /* [optional][in] */ VARIANT coBrandTemplate,
            /* [optional][in] */ VARIANT lang_id,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT KPP,
            /* [optional][in] */ VARIANT UseSecureAuth,
            /* [optional][in] */ VARIANT ExtraParams,
            /* [optional][out] */ VARIANT *pAuthHeader,
            /* [retval][out] */ BSTR *pAuthVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HexPUID )( 
            IPassportManager3 * This,
            /* [retval][out] */ BSTR *pVal);
        
        END_INTERFACE
    } IPassportManager3Vtbl;

    interface IPassportManager3
    {
        CONST_VTBL struct IPassportManager3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportManager3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportManager3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportManager3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportManager3_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportManager3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportManager3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportManager3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportManager3_OnStartPage(This,piUnk)	\
    (This)->lpVtbl -> OnStartPage(This,piUnk)

#define IPassportManager3_OnEndPage(This)	\
    (This)->lpVtbl -> OnEndPage(This)

#define IPassportManager3_OnStartPageECB(This,pECB,pBufSize,pCookieHeader)	\
    (This)->lpVtbl -> OnStartPageECB(This,pECB,pBufSize,pCookieHeader)

#define IPassportManager3__Ticket(This,piTicket)	\
    (This)->lpVtbl -> _Ticket(This,piTicket)

#define IPassportManager3__Profile(This,piProfile)	\
    (This)->lpVtbl -> _Profile(This,piProfile)

#define IPassportManager3_AuthURL(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)	\
    (This)->lpVtbl -> AuthURL(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)

#define IPassportManager3_IsAuthenticated(This,TimeWindow,ForceLogin,CheckSecure,pVal)	\
    (This)->lpVtbl -> IsAuthenticated(This,TimeWindow,ForceLogin,CheckSecure,pVal)

#define IPassportManager3_LogoTag(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)	\
    (This)->lpVtbl -> LogoTag(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)

#define IPassportManager3_HasProfile(This,ProfileName,pVal)	\
    (This)->lpVtbl -> HasProfile(This,ProfileName,pVal)

#define IPassportManager3_get_HasTicket(This,pVal)	\
    (This)->lpVtbl -> get_HasTicket(This,pVal)

#define IPassportManager3_get_FromNetworkServer(This,pVal)	\
    (This)->lpVtbl -> get_FromNetworkServer(This,pVal)

#define IPassportManager3_HasFlag(This,flagMask,pVal)	\
    (This)->lpVtbl -> HasFlag(This,flagMask,pVal)

#define IPassportManager3_get_TicketAge(This,pVal)	\
    (This)->lpVtbl -> get_TicketAge(This,pVal)

#define IPassportManager3_get_TimeSinceSignIn(This,pVal)	\
    (This)->lpVtbl -> get_TimeSinceSignIn(This,pVal)

#define IPassportManager3_GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)	\
    (This)->lpVtbl -> GetDomainAttribute(This,attributeName,lcid,domain,pAttrVal)

#define IPassportManager3_DomainFromMemberName(This,memberName,pDomainName)	\
    (This)->lpVtbl -> DomainFromMemberName(This,memberName,pDomainName)

#define IPassportManager3_get_ProfileByIndex(This,index,pVal)	\
    (This)->lpVtbl -> get_ProfileByIndex(This,index,pVal)

#define IPassportManager3_put_ProfileByIndex(This,index,newVal)	\
    (This)->lpVtbl -> put_ProfileByIndex(This,index,newVal)

#define IPassportManager3_OnStartPageManual(This,queryStringT,queryStringP,MSPAuthCookie,MSPProfCookie,MSPConsentCookie,vMSPSecCookie,pSetCookieArray)	\
    (This)->lpVtbl -> OnStartPageManual(This,queryStringT,queryStringP,MSPAuthCookie,MSPProfCookie,MSPConsentCookie,vMSPSecCookie,pSetCookieArray)

#define IPassportManager3_get_HasSavedPassword(This,pVal)	\
    (This)->lpVtbl -> get_HasSavedPassword(This,pVal)

#define IPassportManager3_Commit(This,pNewProfileCookieHeader)	\
    (This)->lpVtbl -> Commit(This,pNewProfileCookieHeader)

#define IPassportManager3_get_Profile(This,attributeName,pVal)	\
    (This)->lpVtbl -> get_Profile(This,attributeName,pVal)

#define IPassportManager3_put_Profile(This,attributeName,newVal)	\
    (This)->lpVtbl -> put_Profile(This,attributeName,newVal)

#define IPassportManager3_get_TicketTime(This,pVal)	\
    (This)->lpVtbl -> get_TicketTime(This,pVal)

#define IPassportManager3_get_SignInTime(This,pVal)	\
    (This)->lpVtbl -> get_SignInTime(This,pVal)

#define IPassportManager3_get_Domains(This,pArrayVal)	\
    (This)->lpVtbl -> get_Domains(This,pArrayVal)

#define IPassportManager3_get_Error(This,pErrorVal)	\
    (This)->lpVtbl -> get_Error(This,pErrorVal)

#define IPassportManager3_OnStartPageFilter(This,pPFC,pBufSize,pCookieHeader)	\
    (This)->lpVtbl -> OnStartPageFilter(This,pPFC,pBufSize,pCookieHeader)

#define IPassportManager3_OnStartPageASP(This,pdispRequest,pdispResponse)	\
    (This)->lpVtbl -> OnStartPageASP(This,pdispRequest,pdispResponse)

#define IPassportManager3_GetServerInfo(This,pbstrOut)	\
    (This)->lpVtbl -> GetServerInfo(This,pbstrOut)

#define IPassportManager3_HaveConsent(This,bNeedFullConsent,bNeedBirthdate,pbHaveConsent)	\
    (This)->lpVtbl -> HaveConsent(This,bNeedFullConsent,bNeedBirthdate,pbHaveConsent)


#define IPassportManager3_LoginUser(This,returnUrl,TimeWindow,ForceLogin,coBrandTemplate,lang_id,NameSpace,KPP,UseSecureAuth,ExtraParams)	\
    (This)->lpVtbl -> LoginUser(This,returnUrl,TimeWindow,ForceLogin,coBrandTemplate,lang_id,NameSpace,KPP,UseSecureAuth,ExtraParams)

#define IPassportManager3_AuthURL2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)	\
    (This)->lpVtbl -> AuthURL2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,NameSpace,KPP,SecureLevel,pAuthVal)

#define IPassportManager3_LogoTag2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)	\
    (This)->lpVtbl -> LogoTag2(This,returnUrl,TimeWindow,ForceLogin,coBrandArgs,lang_id,bSecure,NameSpace,KPP,SecureLevel,pVal)


#define IPassportManager3_get_Ticket(This,attributeName,pVal)	\
    (This)->lpVtbl -> get_Ticket(This,attributeName,pVal)

#define IPassportManager3_GetCurrentConfig(This,name,pVal)	\
    (This)->lpVtbl -> GetCurrentConfig(This,name,pVal)

#define IPassportManager3_LogoutURL(This,returnUrl,coBrandArgs,lang_id,NameSpace,bSecure,pVal)	\
    (This)->lpVtbl -> LogoutURL(This,returnUrl,coBrandArgs,lang_id,NameSpace,bSecure,pVal)

#define IPassportManager3_GetLoginChallenge(This,returnUrl,TimeWindow,ForceLogin,coBrandTemplate,lang_id,NameSpace,KPP,UseSecureAuth,ExtraParams,pAuthHeader,pAuthVal)	\
    (This)->lpVtbl -> GetLoginChallenge(This,returnUrl,TimeWindow,ForceLogin,coBrandTemplate,lang_id,NameSpace,KPP,UseSecureAuth,ExtraParams,pAuthHeader,pAuthVal)

#define IPassportManager3_get_HexPUID(This,pVal)	\
    (This)->lpVtbl -> get_HexPUID(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager3_get_Ticket_Proxy( 
    IPassportManager3 * This,
    /* [in] */ BSTR attributeName,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IPassportManager3_get_Ticket_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager3_GetCurrentConfig_Proxy( 
    IPassportManager3 * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IPassportManager3_GetCurrentConfig_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager3_LogoutURL_Proxy( 
    IPassportManager3 * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT coBrandArgs,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT bSecure,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportManager3_LogoutURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportManager3_GetLoginChallenge_Proxy( 
    IPassportManager3 * This,
    /* [optional][in] */ VARIANT returnUrl,
    /* [optional][in] */ VARIANT TimeWindow,
    /* [optional][in] */ VARIANT ForceLogin,
    /* [optional][in] */ VARIANT coBrandTemplate,
    /* [optional][in] */ VARIANT lang_id,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT KPP,
    /* [optional][in] */ VARIANT UseSecureAuth,
    /* [optional][in] */ VARIANT ExtraParams,
    /* [optional][out] */ VARIANT *pAuthHeader,
    /* [retval][out] */ BSTR *pAuthVal);


void __RPC_STUB IPassportManager3_GetLoginChallenge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportManager3_get_HexPUID_Proxy( 
    IPassportManager3 * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportManager3_get_HexPUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportManager3_INTERFACE_DEFINED__ */


#ifndef __IPassportCrypt_INTERFACE_DEFINED__
#define __IPassportCrypt_INTERFACE_DEFINED__

/* interface IPassportCrypt */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportCrypt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("41651BF9-A5C8-11D2-95DF-00C04F8E7A70")
    IPassportCrypt : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Encrypt( 
            /* [in] */ BSTR rawData,
            /* [retval][out] */ BSTR *pEncrypted) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Decrypt( 
            /* [in] */ BSTR rawData,
            /* [retval][out] */ BSTR *pUnencrypted) = 0;
        
        virtual /* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE get_keyVersion( 
            /* [retval][out] */ int *pVal) = 0;
        
        virtual /* [helpstring][id][propput][hidden] */ HRESULT STDMETHODCALLTYPE put_keyVersion( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsValid( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput][hidden] */ HRESULT STDMETHODCALLTYPE put_keyMaterial( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Compress( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR *pbstrOut) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Decompress( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR *pbstrOut) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_site( 
            /* [in] */ BSTR bstrSiteName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnStartPage( 
            /* [in] */ IUnknown *piUnk) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_host( 
            /* [in] */ BSTR bstrHostName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportCryptVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportCrypt * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportCrypt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportCrypt * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportCrypt * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportCrypt * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportCrypt * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportCrypt * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Encrypt )( 
            IPassportCrypt * This,
            /* [in] */ BSTR rawData,
            /* [retval][out] */ BSTR *pEncrypted);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Decrypt )( 
            IPassportCrypt * This,
            /* [in] */ BSTR rawData,
            /* [retval][out] */ BSTR *pUnencrypted);
        
        /* [helpstring][id][propget][hidden] */ HRESULT ( STDMETHODCALLTYPE *get_keyVersion )( 
            IPassportCrypt * This,
            /* [retval][out] */ int *pVal);
        
        /* [helpstring][id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_keyVersion )( 
            IPassportCrypt * This,
            /* [in] */ int newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsValid )( 
            IPassportCrypt * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput][hidden] */ HRESULT ( STDMETHODCALLTYPE *put_keyMaterial )( 
            IPassportCrypt * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Compress )( 
            IPassportCrypt * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR *pbstrOut);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Decompress )( 
            IPassportCrypt * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR *pbstrOut);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_site )( 
            IPassportCrypt * This,
            /* [in] */ BSTR bstrSiteName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnStartPage )( 
            IPassportCrypt * This,
            /* [in] */ IUnknown *piUnk);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_host )( 
            IPassportCrypt * This,
            /* [in] */ BSTR bstrHostName);
        
        END_INTERFACE
    } IPassportCryptVtbl;

    interface IPassportCrypt
    {
        CONST_VTBL struct IPassportCryptVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportCrypt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportCrypt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportCrypt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportCrypt_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportCrypt_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportCrypt_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportCrypt_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportCrypt_Encrypt(This,rawData,pEncrypted)	\
    (This)->lpVtbl -> Encrypt(This,rawData,pEncrypted)

#define IPassportCrypt_Decrypt(This,rawData,pUnencrypted)	\
    (This)->lpVtbl -> Decrypt(This,rawData,pUnencrypted)

#define IPassportCrypt_get_keyVersion(This,pVal)	\
    (This)->lpVtbl -> get_keyVersion(This,pVal)

#define IPassportCrypt_put_keyVersion(This,newVal)	\
    (This)->lpVtbl -> put_keyVersion(This,newVal)

#define IPassportCrypt_get_IsValid(This,pVal)	\
    (This)->lpVtbl -> get_IsValid(This,pVal)

#define IPassportCrypt_put_keyMaterial(This,newVal)	\
    (This)->lpVtbl -> put_keyMaterial(This,newVal)

#define IPassportCrypt_Compress(This,bstrIn,pbstrOut)	\
    (This)->lpVtbl -> Compress(This,bstrIn,pbstrOut)

#define IPassportCrypt_Decompress(This,bstrIn,pbstrOut)	\
    (This)->lpVtbl -> Decompress(This,bstrIn,pbstrOut)

#define IPassportCrypt_put_site(This,bstrSiteName)	\
    (This)->lpVtbl -> put_site(This,bstrSiteName)

#define IPassportCrypt_OnStartPage(This,piUnk)	\
    (This)->lpVtbl -> OnStartPage(This,piUnk)

#define IPassportCrypt_put_host(This,bstrHostName)	\
    (This)->lpVtbl -> put_host(This,bstrHostName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_Encrypt_Proxy( 
    IPassportCrypt * This,
    /* [in] */ BSTR rawData,
    /* [retval][out] */ BSTR *pEncrypted);


void __RPC_STUB IPassportCrypt_Encrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_Decrypt_Proxy( 
    IPassportCrypt * This,
    /* [in] */ BSTR rawData,
    /* [retval][out] */ BSTR *pUnencrypted);


void __RPC_STUB IPassportCrypt_Decrypt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget][hidden] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_get_keyVersion_Proxy( 
    IPassportCrypt * This,
    /* [retval][out] */ int *pVal);


void __RPC_STUB IPassportCrypt_get_keyVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput][hidden] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_put_keyVersion_Proxy( 
    IPassportCrypt * This,
    /* [in] */ int newVal);


void __RPC_STUB IPassportCrypt_put_keyVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_get_IsValid_Proxy( 
    IPassportCrypt * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportCrypt_get_IsValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput][hidden] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_put_keyMaterial_Proxy( 
    IPassportCrypt * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IPassportCrypt_put_keyMaterial_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_Compress_Proxy( 
    IPassportCrypt * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR *pbstrOut);


void __RPC_STUB IPassportCrypt_Compress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_Decompress_Proxy( 
    IPassportCrypt * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR *pbstrOut);


void __RPC_STUB IPassportCrypt_Decompress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_put_site_Proxy( 
    IPassportCrypt * This,
    /* [in] */ BSTR bstrSiteName);


void __RPC_STUB IPassportCrypt_put_site_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_OnStartPage_Proxy( 
    IPassportCrypt * This,
    /* [in] */ IUnknown *piUnk);


void __RPC_STUB IPassportCrypt_OnStartPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE IPassportCrypt_put_host_Proxy( 
    IPassportCrypt * This,
    /* [in] */ BSTR bstrHostName);


void __RPC_STUB IPassportCrypt_put_host_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportCrypt_INTERFACE_DEFINED__ */


#ifndef __IPassportAdmin_INTERFACE_DEFINED__
#define __IPassportAdmin_INTERFACE_DEFINED__

/* interface IPassportAdmin */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A0082CF5-AFF5-11D2-95E3-00C04F8E7A70")
    IPassportAdmin : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsValid( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorDescription( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addKey( 
            /* [in] */ BSTR keyMaterial,
            /* [in] */ int version,
            /* [in] */ long expires,
            /* [retval][out] */ VARIANT_BOOL *ok) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE deleteKey( 
            /* [in] */ int version) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setKeyTime( 
            /* [in] */ int version,
            /* [in] */ int fromNow) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_currentKeyVersion( 
            /* [retval][out] */ int *pCur) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_currentKeyVersion( 
            /* [in] */ int cur) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE Refresh( 
            /* [in] */ VARIANT_BOOL bWait,
            /* [retval][out] */ VARIANT_BOOL *pbSuccess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportAdmin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportAdmin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportAdmin * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportAdmin * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportAdmin * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportAdmin * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportAdmin * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsValid )( 
            IPassportAdmin * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorDescription )( 
            IPassportAdmin * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addKey )( 
            IPassportAdmin * This,
            /* [in] */ BSTR keyMaterial,
            /* [in] */ int version,
            /* [in] */ long expires,
            /* [retval][out] */ VARIANT_BOOL *ok);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *deleteKey )( 
            IPassportAdmin * This,
            /* [in] */ int version);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setKeyTime )( 
            IPassportAdmin * This,
            /* [in] */ int version,
            /* [in] */ int fromNow);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_currentKeyVersion )( 
            IPassportAdmin * This,
            /* [retval][out] */ int *pCur);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_currentKeyVersion )( 
            IPassportAdmin * This,
            /* [in] */ int cur);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IPassportAdmin * This,
            /* [in] */ VARIANT_BOOL bWait,
            /* [retval][out] */ VARIANT_BOOL *pbSuccess);
        
        END_INTERFACE
    } IPassportAdminVtbl;

    interface IPassportAdmin
    {
        CONST_VTBL struct IPassportAdminVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportAdmin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportAdmin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportAdmin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportAdmin_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportAdmin_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportAdmin_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportAdmin_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportAdmin_get_IsValid(This,pVal)	\
    (This)->lpVtbl -> get_IsValid(This,pVal)

#define IPassportAdmin_get_ErrorDescription(This,pVal)	\
    (This)->lpVtbl -> get_ErrorDescription(This,pVal)

#define IPassportAdmin_addKey(This,keyMaterial,version,expires,ok)	\
    (This)->lpVtbl -> addKey(This,keyMaterial,version,expires,ok)

#define IPassportAdmin_deleteKey(This,version)	\
    (This)->lpVtbl -> deleteKey(This,version)

#define IPassportAdmin_setKeyTime(This,version,fromNow)	\
    (This)->lpVtbl -> setKeyTime(This,version,fromNow)

#define IPassportAdmin_get_currentKeyVersion(This,pCur)	\
    (This)->lpVtbl -> get_currentKeyVersion(This,pCur)

#define IPassportAdmin_put_currentKeyVersion(This,cur)	\
    (This)->lpVtbl -> put_currentKeyVersion(This,cur)

#define IPassportAdmin_Refresh(This,bWait,pbSuccess)	\
    (This)->lpVtbl -> Refresh(This,bWait,pbSuccess)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_get_IsValid_Proxy( 
    IPassportAdmin * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportAdmin_get_IsValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_get_ErrorDescription_Proxy( 
    IPassportAdmin * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportAdmin_get_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_addKey_Proxy( 
    IPassportAdmin * This,
    /* [in] */ BSTR keyMaterial,
    /* [in] */ int version,
    /* [in] */ long expires,
    /* [retval][out] */ VARIANT_BOOL *ok);


void __RPC_STUB IPassportAdmin_addKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_deleteKey_Proxy( 
    IPassportAdmin * This,
    /* [in] */ int version);


void __RPC_STUB IPassportAdmin_deleteKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_setKeyTime_Proxy( 
    IPassportAdmin * This,
    /* [in] */ int version,
    /* [in] */ int fromNow);


void __RPC_STUB IPassportAdmin_setKeyTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_get_currentKeyVersion_Proxy( 
    IPassportAdmin * This,
    /* [retval][out] */ int *pCur);


void __RPC_STUB IPassportAdmin_get_currentKeyVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_put_currentKeyVersion_Proxy( 
    IPassportAdmin * This,
    /* [in] */ int cur);


void __RPC_STUB IPassportAdmin_put_currentKeyVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IPassportAdmin_Refresh_Proxy( 
    IPassportAdmin * This,
    /* [in] */ VARIANT_BOOL bWait,
    /* [retval][out] */ VARIANT_BOOL *pbSuccess);


void __RPC_STUB IPassportAdmin_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportAdmin_INTERFACE_DEFINED__ */


#ifndef __IPassportAdminEx_INTERFACE_DEFINED__
#define __IPassportAdminEx_INTERFACE_DEFINED__

/* interface IPassportAdminEx */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportAdminEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("876181A0-3B05-11d3-9ACD-0080C712D19C")
    IPassportAdminEx : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsValid( 
            /* [retval][out] */ VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorDescription( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addKey( 
            /* [in] */ BSTR keyMaterial,
            /* [in] */ int version,
            /* [in] */ long expires,
            /* [retval][out] */ VARIANT_BOOL *ok) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE deleteKey( 
            /* [in] */ int version) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setKeyTime( 
            /* [in] */ int version,
            /* [in] */ int fromNow) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_currentKeyVersion( 
            /* [retval][out] */ int *pCur) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_currentKeyVersion( 
            /* [in] */ int cur) = 0;
        
        virtual /* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE Refresh( 
            /* [in] */ VARIANT_BOOL bWait,
            /* [retval][out] */ VARIANT_BOOL *pbSuccess) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE addKeyEx( 
            /* [in] */ BSTR keyMaterial,
            /* [in] */ int nVersion,
            /* [in] */ long expires,
            /* [optional][in] */ VARIANT vSiteName,
            /* [retval][out] */ VARIANT_BOOL *ok) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE deleteKeyEx( 
            /* [in] */ int nVersion,
            /* [optional][in] */ VARIANT vSiteName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setKeyTimeEx( 
            /* [in] */ int nVersion,
            /* [in] */ int fromNow,
            /* [optional][in] */ VARIANT vSiteName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE getCurrentKeyVersionEx( 
            /* [optional][in] */ VARIANT vSiteName,
            /* [retval][out] */ int *pCur) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE putCurrentKeyVersionEx( 
            /* [in] */ int cur,
            /* [optional][in] */ VARIANT vSiteName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE setNexusPassword( 
            /* [in] */ BSTR bstrPwd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportAdminExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportAdminEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportAdminEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportAdminEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportAdminEx * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportAdminEx * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportAdminEx * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportAdminEx * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsValid )( 
            IPassportAdminEx * This,
            /* [retval][out] */ VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorDescription )( 
            IPassportAdminEx * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addKey )( 
            IPassportAdminEx * This,
            /* [in] */ BSTR keyMaterial,
            /* [in] */ int version,
            /* [in] */ long expires,
            /* [retval][out] */ VARIANT_BOOL *ok);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *deleteKey )( 
            IPassportAdminEx * This,
            /* [in] */ int version);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setKeyTime )( 
            IPassportAdminEx * This,
            /* [in] */ int version,
            /* [in] */ int fromNow);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_currentKeyVersion )( 
            IPassportAdminEx * This,
            /* [retval][out] */ int *pCur);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_currentKeyVersion )( 
            IPassportAdminEx * This,
            /* [in] */ int cur);
        
        /* [helpstring][id][hidden] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            IPassportAdminEx * This,
            /* [in] */ VARIANT_BOOL bWait,
            /* [retval][out] */ VARIANT_BOOL *pbSuccess);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *addKeyEx )( 
            IPassportAdminEx * This,
            /* [in] */ BSTR keyMaterial,
            /* [in] */ int nVersion,
            /* [in] */ long expires,
            /* [optional][in] */ VARIANT vSiteName,
            /* [retval][out] */ VARIANT_BOOL *ok);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *deleteKeyEx )( 
            IPassportAdminEx * This,
            /* [in] */ int nVersion,
            /* [optional][in] */ VARIANT vSiteName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setKeyTimeEx )( 
            IPassportAdminEx * This,
            /* [in] */ int nVersion,
            /* [in] */ int fromNow,
            /* [optional][in] */ VARIANT vSiteName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *getCurrentKeyVersionEx )( 
            IPassportAdminEx * This,
            /* [optional][in] */ VARIANT vSiteName,
            /* [retval][out] */ int *pCur);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *putCurrentKeyVersionEx )( 
            IPassportAdminEx * This,
            /* [in] */ int cur,
            /* [optional][in] */ VARIANT vSiteName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *setNexusPassword )( 
            IPassportAdminEx * This,
            /* [in] */ BSTR bstrPwd);
        
        END_INTERFACE
    } IPassportAdminExVtbl;

    interface IPassportAdminEx
    {
        CONST_VTBL struct IPassportAdminExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportAdminEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportAdminEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportAdminEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportAdminEx_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportAdminEx_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportAdminEx_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportAdminEx_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportAdminEx_get_IsValid(This,pVal)	\
    (This)->lpVtbl -> get_IsValid(This,pVal)

#define IPassportAdminEx_get_ErrorDescription(This,pVal)	\
    (This)->lpVtbl -> get_ErrorDescription(This,pVal)

#define IPassportAdminEx_addKey(This,keyMaterial,version,expires,ok)	\
    (This)->lpVtbl -> addKey(This,keyMaterial,version,expires,ok)

#define IPassportAdminEx_deleteKey(This,version)	\
    (This)->lpVtbl -> deleteKey(This,version)

#define IPassportAdminEx_setKeyTime(This,version,fromNow)	\
    (This)->lpVtbl -> setKeyTime(This,version,fromNow)

#define IPassportAdminEx_get_currentKeyVersion(This,pCur)	\
    (This)->lpVtbl -> get_currentKeyVersion(This,pCur)

#define IPassportAdminEx_put_currentKeyVersion(This,cur)	\
    (This)->lpVtbl -> put_currentKeyVersion(This,cur)

#define IPassportAdminEx_Refresh(This,bWait,pbSuccess)	\
    (This)->lpVtbl -> Refresh(This,bWait,pbSuccess)

#define IPassportAdminEx_addKeyEx(This,keyMaterial,nVersion,expires,vSiteName,ok)	\
    (This)->lpVtbl -> addKeyEx(This,keyMaterial,nVersion,expires,vSiteName,ok)

#define IPassportAdminEx_deleteKeyEx(This,nVersion,vSiteName)	\
    (This)->lpVtbl -> deleteKeyEx(This,nVersion,vSiteName)

#define IPassportAdminEx_setKeyTimeEx(This,nVersion,fromNow,vSiteName)	\
    (This)->lpVtbl -> setKeyTimeEx(This,nVersion,fromNow,vSiteName)

#define IPassportAdminEx_getCurrentKeyVersionEx(This,vSiteName,pCur)	\
    (This)->lpVtbl -> getCurrentKeyVersionEx(This,vSiteName,pCur)

#define IPassportAdminEx_putCurrentKeyVersionEx(This,cur,vSiteName)	\
    (This)->lpVtbl -> putCurrentKeyVersionEx(This,cur,vSiteName)

#define IPassportAdminEx_setNexusPassword(This,bstrPwd)	\
    (This)->lpVtbl -> setNexusPassword(This,bstrPwd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_get_IsValid_Proxy( 
    IPassportAdminEx * This,
    /* [retval][out] */ VARIANT_BOOL *pVal);


void __RPC_STUB IPassportAdminEx_get_IsValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_get_ErrorDescription_Proxy( 
    IPassportAdminEx * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IPassportAdminEx_get_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_addKey_Proxy( 
    IPassportAdminEx * This,
    /* [in] */ BSTR keyMaterial,
    /* [in] */ int version,
    /* [in] */ long expires,
    /* [retval][out] */ VARIANT_BOOL *ok);


void __RPC_STUB IPassportAdminEx_addKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_deleteKey_Proxy( 
    IPassportAdminEx * This,
    /* [in] */ int version);


void __RPC_STUB IPassportAdminEx_deleteKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_setKeyTime_Proxy( 
    IPassportAdminEx * This,
    /* [in] */ int version,
    /* [in] */ int fromNow);


void __RPC_STUB IPassportAdminEx_setKeyTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_get_currentKeyVersion_Proxy( 
    IPassportAdminEx * This,
    /* [retval][out] */ int *pCur);


void __RPC_STUB IPassportAdminEx_get_currentKeyVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_put_currentKeyVersion_Proxy( 
    IPassportAdminEx * This,
    /* [in] */ int cur);


void __RPC_STUB IPassportAdminEx_put_currentKeyVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][hidden] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_Refresh_Proxy( 
    IPassportAdminEx * This,
    /* [in] */ VARIANT_BOOL bWait,
    /* [retval][out] */ VARIANT_BOOL *pbSuccess);


void __RPC_STUB IPassportAdminEx_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_addKeyEx_Proxy( 
    IPassportAdminEx * This,
    /* [in] */ BSTR keyMaterial,
    /* [in] */ int nVersion,
    /* [in] */ long expires,
    /* [optional][in] */ VARIANT vSiteName,
    /* [retval][out] */ VARIANT_BOOL *ok);


void __RPC_STUB IPassportAdminEx_addKeyEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_deleteKeyEx_Proxy( 
    IPassportAdminEx * This,
    /* [in] */ int nVersion,
    /* [optional][in] */ VARIANT vSiteName);


void __RPC_STUB IPassportAdminEx_deleteKeyEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_setKeyTimeEx_Proxy( 
    IPassportAdminEx * This,
    /* [in] */ int nVersion,
    /* [in] */ int fromNow,
    /* [optional][in] */ VARIANT vSiteName);


void __RPC_STUB IPassportAdminEx_setKeyTimeEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_getCurrentKeyVersionEx_Proxy( 
    IPassportAdminEx * This,
    /* [optional][in] */ VARIANT vSiteName,
    /* [retval][out] */ int *pCur);


void __RPC_STUB IPassportAdminEx_getCurrentKeyVersionEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_putCurrentKeyVersionEx_Proxy( 
    IPassportAdminEx * This,
    /* [in] */ int cur,
    /* [optional][in] */ VARIANT vSiteName);


void __RPC_STUB IPassportAdminEx_putCurrentKeyVersionEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportAdminEx_setNexusPassword_Proxy( 
    IPassportAdminEx * This,
    /* [in] */ BSTR bstrPwd);


void __RPC_STUB IPassportAdminEx_setNexusPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportAdminEx_INTERFACE_DEFINED__ */


#ifndef __IPassportFastAuth_INTERFACE_DEFINED__
#define __IPassportFastAuth_INTERFACE_DEFINED__

/* interface IPassportFastAuth */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportFastAuth;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("74EB2513-E239-11D2-95E9-00C04F8E7A70")
    IPassportFastAuth : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsAuthenticated( 
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT vDoSecureCheck,
            /* [retval][out] */ VARIANT_BOOL *pbIsAuthenticated) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LogoTag( 
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrLogoTag) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AuthURL( 
            /* [optional][in] */ VARIANT vTicket,
            /* [optional][in] */ VARIANT vProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vReserved1,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrAuthURL) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTicketAndProfilePFC( 
            /* [in] */ BYTE *pbPFC,
            /* [in] */ BYTE *pbPPH,
            /* [out] */ BSTR *pbstrTicket,
            /* [out] */ BSTR *pbstrProfile,
            /* [out] */ BSTR *pbstrSecure,
            /* [out] */ BSTR *pbstrSiteName) = 0;
        
        virtual /* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTicketAndProfileECB( 
            /* [in] */ BYTE *pbECB,
            /* [out] */ BSTR *pbstrTicket,
            /* [out] */ BSTR *pbstrProfile,
            /* [out] */ BSTR *pbstrSecure,
            /* [out] */ BSTR *pbstrSiteName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportFastAuthVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportFastAuth * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportFastAuth * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportFastAuth * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportFastAuth * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportFastAuth * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportFastAuth * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportFastAuth * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsAuthenticated )( 
            IPassportFastAuth * This,
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT vDoSecureCheck,
            /* [retval][out] */ VARIANT_BOOL *pbIsAuthenticated);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoTag )( 
            IPassportFastAuth * This,
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrLogoTag);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AuthURL )( 
            IPassportFastAuth * This,
            /* [optional][in] */ VARIANT vTicket,
            /* [optional][in] */ VARIANT vProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vReserved1,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrAuthURL);
        
        /* [hidden][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTicketAndProfilePFC )( 
            IPassportFastAuth * This,
            /* [in] */ BYTE *pbPFC,
            /* [in] */ BYTE *pbPPH,
            /* [out] */ BSTR *pbstrTicket,
            /* [out] */ BSTR *pbstrProfile,
            /* [out] */ BSTR *pbstrSecure,
            /* [out] */ BSTR *pbstrSiteName);
        
        /* [hidden][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTicketAndProfileECB )( 
            IPassportFastAuth * This,
            /* [in] */ BYTE *pbECB,
            /* [out] */ BSTR *pbstrTicket,
            /* [out] */ BSTR *pbstrProfile,
            /* [out] */ BSTR *pbstrSecure,
            /* [out] */ BSTR *pbstrSiteName);
        
        END_INTERFACE
    } IPassportFastAuthVtbl;

    interface IPassportFastAuth
    {
        CONST_VTBL struct IPassportFastAuthVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportFastAuth_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportFastAuth_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportFastAuth_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportFastAuth_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportFastAuth_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportFastAuth_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportFastAuth_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportFastAuth_IsAuthenticated(This,bstrTicket,bstrProfile,vSecure,vTimeWindow,vForceLogin,vSiteName,vDoSecureCheck,pbIsAuthenticated)	\
    (This)->lpVtbl -> IsAuthenticated(This,bstrTicket,bstrProfile,vSecure,vTimeWindow,vForceLogin,vSiteName,vDoSecureCheck,pbIsAuthenticated)

#define IPassportFastAuth_LogoTag(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,SecureLevel,pbstrLogoTag)	\
    (This)->lpVtbl -> LogoTag(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,SecureLevel,pbstrLogoTag)

#define IPassportFastAuth_AuthURL(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,SecureLevel,pbstrAuthURL)	\
    (This)->lpVtbl -> AuthURL(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,SecureLevel,pbstrAuthURL)

#define IPassportFastAuth_GetTicketAndProfilePFC(This,pbPFC,pbPPH,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)	\
    (This)->lpVtbl -> GetTicketAndProfilePFC(This,pbPFC,pbPPH,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)

#define IPassportFastAuth_GetTicketAndProfileECB(This,pbECB,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)	\
    (This)->lpVtbl -> GetTicketAndProfileECB(This,pbECB,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth_IsAuthenticated_Proxy( 
    IPassportFastAuth * This,
    /* [in] */ BSTR bstrTicket,
    /* [in] */ BSTR bstrProfile,
    /* [optional][in] */ VARIANT vSecure,
    /* [optional][in] */ VARIANT vTimeWindow,
    /* [optional][in] */ VARIANT vForceLogin,
    /* [optional][in] */ VARIANT vSiteName,
    /* [optional][in] */ VARIANT vDoSecureCheck,
    /* [retval][out] */ VARIANT_BOOL *pbIsAuthenticated);


void __RPC_STUB IPassportFastAuth_IsAuthenticated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth_LogoTag_Proxy( 
    IPassportFastAuth * This,
    /* [in] */ BSTR bstrTicket,
    /* [in] */ BSTR bstrProfile,
    /* [optional][in] */ VARIANT vRU,
    /* [optional][in] */ VARIANT vTimeWindow,
    /* [optional][in] */ VARIANT vForceLogin,
    /* [optional][in] */ VARIANT vCoBrand,
    /* [optional][in] */ VARIANT vLangId,
    /* [optional][in] */ VARIANT vSecure,
    /* [optional][in] */ VARIANT vLogoutURL,
    /* [optional][in] */ VARIANT vSiteName,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT vKPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ BSTR *pbstrLogoTag);


void __RPC_STUB IPassportFastAuth_LogoTag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth_AuthURL_Proxy( 
    IPassportFastAuth * This,
    /* [optional][in] */ VARIANT vTicket,
    /* [optional][in] */ VARIANT vProfile,
    /* [optional][in] */ VARIANT vRU,
    /* [optional][in] */ VARIANT vTimeWindow,
    /* [optional][in] */ VARIANT vForceLogin,
    /* [optional][in] */ VARIANT vCoBrand,
    /* [optional][in] */ VARIANT vLangId,
    /* [optional][in] */ VARIANT vSecure,
    /* [optional][in] */ VARIANT vLogoutURL,
    /* [optional][in] */ VARIANT vReserved1,
    /* [optional][in] */ VARIANT vSiteName,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT vKPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ BSTR *pbstrAuthURL);


void __RPC_STUB IPassportFastAuth_AuthURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth_GetTicketAndProfilePFC_Proxy( 
    IPassportFastAuth * This,
    /* [in] */ BYTE *pbPFC,
    /* [in] */ BYTE *pbPPH,
    /* [out] */ BSTR *pbstrTicket,
    /* [out] */ BSTR *pbstrProfile,
    /* [out] */ BSTR *pbstrSecure,
    /* [out] */ BSTR *pbstrSiteName);


void __RPC_STUB IPassportFastAuth_GetTicketAndProfilePFC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth_GetTicketAndProfileECB_Proxy( 
    IPassportFastAuth * This,
    /* [in] */ BYTE *pbECB,
    /* [out] */ BSTR *pbstrTicket,
    /* [out] */ BSTR *pbstrProfile,
    /* [out] */ BSTR *pbstrSecure,
    /* [out] */ BSTR *pbstrSiteName);


void __RPC_STUB IPassportFastAuth_GetTicketAndProfileECB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportFastAuth_INTERFACE_DEFINED__ */


#ifndef __IPassportFastAuth2_INTERFACE_DEFINED__
#define __IPassportFastAuth2_INTERFACE_DEFINED__

/* interface IPassportFastAuth2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportFastAuth2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fb41a7d8-3739-4468-bdf1-e5b4b2eaeb4b")
    IPassportFastAuth2 : public IPassportFastAuth
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LogoTag2( 
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrLogoTag) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AuthURL2( 
            /* [optional][in] */ VARIANT vTicket,
            /* [optional][in] */ VARIANT vProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vReserved1,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrAuthURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportFastAuth2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportFastAuth2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportFastAuth2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportFastAuth2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportFastAuth2 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportFastAuth2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportFastAuth2 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportFastAuth2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsAuthenticated )( 
            IPassportFastAuth2 * This,
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT vDoSecureCheck,
            /* [retval][out] */ VARIANT_BOOL *pbIsAuthenticated);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoTag )( 
            IPassportFastAuth2 * This,
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrLogoTag);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AuthURL )( 
            IPassportFastAuth2 * This,
            /* [optional][in] */ VARIANT vTicket,
            /* [optional][in] */ VARIANT vProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vReserved1,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrAuthURL);
        
        /* [hidden][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTicketAndProfilePFC )( 
            IPassportFastAuth2 * This,
            /* [in] */ BYTE *pbPFC,
            /* [in] */ BYTE *pbPPH,
            /* [out] */ BSTR *pbstrTicket,
            /* [out] */ BSTR *pbstrProfile,
            /* [out] */ BSTR *pbstrSecure,
            /* [out] */ BSTR *pbstrSiteName);
        
        /* [hidden][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTicketAndProfileECB )( 
            IPassportFastAuth2 * This,
            /* [in] */ BYTE *pbECB,
            /* [out] */ BSTR *pbstrTicket,
            /* [out] */ BSTR *pbstrProfile,
            /* [out] */ BSTR *pbstrSecure,
            /* [out] */ BSTR *pbstrSiteName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogoTag2 )( 
            IPassportFastAuth2 * This,
            /* [in] */ BSTR bstrTicket,
            /* [in] */ BSTR bstrProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrLogoTag);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AuthURL2 )( 
            IPassportFastAuth2 * This,
            /* [optional][in] */ VARIANT vTicket,
            /* [optional][in] */ VARIANT vProfile,
            /* [optional][in] */ VARIANT vRU,
            /* [optional][in] */ VARIANT vTimeWindow,
            /* [optional][in] */ VARIANT vForceLogin,
            /* [optional][in] */ VARIANT vCoBrand,
            /* [optional][in] */ VARIANT vLangId,
            /* [optional][in] */ VARIANT vSecure,
            /* [optional][in] */ VARIANT vLogoutURL,
            /* [optional][in] */ VARIANT vReserved1,
            /* [optional][in] */ VARIANT vSiteName,
            /* [optional][in] */ VARIANT NameSpace,
            /* [optional][in] */ VARIANT vKPP,
            /* [optional][in] */ VARIANT SecureLevel,
            /* [retval][out] */ BSTR *pbstrAuthURL);
        
        END_INTERFACE
    } IPassportFastAuth2Vtbl;

    interface IPassportFastAuth2
    {
        CONST_VTBL struct IPassportFastAuth2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportFastAuth2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportFastAuth2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportFastAuth2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportFastAuth2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportFastAuth2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportFastAuth2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportFastAuth2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportFastAuth2_IsAuthenticated(This,bstrTicket,bstrProfile,vSecure,vTimeWindow,vForceLogin,vSiteName,vDoSecureCheck,pbIsAuthenticated)	\
    (This)->lpVtbl -> IsAuthenticated(This,bstrTicket,bstrProfile,vSecure,vTimeWindow,vForceLogin,vSiteName,vDoSecureCheck,pbIsAuthenticated)

#define IPassportFastAuth2_LogoTag(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,SecureLevel,pbstrLogoTag)	\
    (This)->lpVtbl -> LogoTag(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,SecureLevel,pbstrLogoTag)

#define IPassportFastAuth2_AuthURL(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,SecureLevel,pbstrAuthURL)	\
    (This)->lpVtbl -> AuthURL(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,SecureLevel,pbstrAuthURL)

#define IPassportFastAuth2_GetTicketAndProfilePFC(This,pbPFC,pbPPH,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)	\
    (This)->lpVtbl -> GetTicketAndProfilePFC(This,pbPFC,pbPPH,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)

#define IPassportFastAuth2_GetTicketAndProfileECB(This,pbECB,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)	\
    (This)->lpVtbl -> GetTicketAndProfileECB(This,pbECB,pbstrTicket,pbstrProfile,pbstrSecure,pbstrSiteName)


#define IPassportFastAuth2_LogoTag2(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,SecureLevel,pbstrLogoTag)	\
    (This)->lpVtbl -> LogoTag2(This,bstrTicket,bstrProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vSiteName,NameSpace,vKPP,SecureLevel,pbstrLogoTag)

#define IPassportFastAuth2_AuthURL2(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,SecureLevel,pbstrAuthURL)	\
    (This)->lpVtbl -> AuthURL2(This,vTicket,vProfile,vRU,vTimeWindow,vForceLogin,vCoBrand,vLangId,vSecure,vLogoutURL,vReserved1,vSiteName,NameSpace,vKPP,SecureLevel,pbstrAuthURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth2_LogoTag2_Proxy( 
    IPassportFastAuth2 * This,
    /* [in] */ BSTR bstrTicket,
    /* [in] */ BSTR bstrProfile,
    /* [optional][in] */ VARIANT vRU,
    /* [optional][in] */ VARIANT vTimeWindow,
    /* [optional][in] */ VARIANT vForceLogin,
    /* [optional][in] */ VARIANT vCoBrand,
    /* [optional][in] */ VARIANT vLangId,
    /* [optional][in] */ VARIANT vSecure,
    /* [optional][in] */ VARIANT vLogoutURL,
    /* [optional][in] */ VARIANT vSiteName,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT vKPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ BSTR *pbstrLogoTag);


void __RPC_STUB IPassportFastAuth2_LogoTag2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IPassportFastAuth2_AuthURL2_Proxy( 
    IPassportFastAuth2 * This,
    /* [optional][in] */ VARIANT vTicket,
    /* [optional][in] */ VARIANT vProfile,
    /* [optional][in] */ VARIANT vRU,
    /* [optional][in] */ VARIANT vTimeWindow,
    /* [optional][in] */ VARIANT vForceLogin,
    /* [optional][in] */ VARIANT vCoBrand,
    /* [optional][in] */ VARIANT vLangId,
    /* [optional][in] */ VARIANT vSecure,
    /* [optional][in] */ VARIANT vLogoutURL,
    /* [optional][in] */ VARIANT vReserved1,
    /* [optional][in] */ VARIANT vSiteName,
    /* [optional][in] */ VARIANT NameSpace,
    /* [optional][in] */ VARIANT vKPP,
    /* [optional][in] */ VARIANT SecureLevel,
    /* [retval][out] */ BSTR *pbstrAuthURL);


void __RPC_STUB IPassportFastAuth2_AuthURL2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportFastAuth2_INTERFACE_DEFINED__ */


#ifndef __IPassportFactory_INTERFACE_DEFINED__
#define __IPassportFactory_INTERFACE_DEFINED__

/* interface IPassportFactory */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IPassportFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5602E147-27F6-11d3-94DD-00C04F72DC08")
    IPassportFactory : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreatePassportManager( 
            /* [retval][out] */ IDispatch **ppdispPassportManager) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPassportFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPassportFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPassportFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPassportFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IPassportFactory * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IPassportFactory * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IPassportFactory * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IPassportFactory * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE *CreatePassportManager )( 
            IPassportFactory * This,
            /* [retval][out] */ IDispatch **ppdispPassportManager);
        
        END_INTERFACE
    } IPassportFactoryVtbl;

    interface IPassportFactory
    {
        CONST_VTBL struct IPassportFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPassportFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPassportFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPassportFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPassportFactory_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IPassportFactory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IPassportFactory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IPassportFactory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IPassportFactory_CreatePassportManager(This,ppdispPassportManager)	\
    (This)->lpVtbl -> CreatePassportManager(This,ppdispPassportManager)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPassportFactory_CreatePassportManager_Proxy( 
    IPassportFactory * This,
    /* [retval][out] */ IDispatch **ppdispPassportManager);


void __RPC_STUB IPassportFactory_CreatePassportManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPassportFactory_INTERFACE_DEFINED__ */



#ifndef __PASSPORTLib_LIBRARY_DEFINED__
#define __PASSPORTLib_LIBRARY_DEFINED__

/* library PASSPORTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_PASSPORTLib;

EXTERN_C const CLSID CLSID_Manager;

#ifdef __cplusplus

class DECLSPEC_UUID("41651BF0-A5C8-11D2-95DF-00C04F8E7A70")
Manager;
#endif

EXTERN_C const CLSID CLSID_Ticket;

#ifdef __cplusplus

class DECLSPEC_UUID("41651BF2-A5C8-11D2-95DF-00C04F8E7A70")
Ticket;
#endif

EXTERN_C const CLSID CLSID_Profile;

#ifdef __cplusplus

class DECLSPEC_UUID("41651BF4-A5C8-11D2-95DF-00C04F8E7A70")
Profile;
#endif

EXTERN_C const CLSID CLSID_Crypt;

#ifdef __cplusplus

class DECLSPEC_UUID("41651BFA-A5C8-11D2-95DF-00C04F8E7A70")
Crypt;
#endif

EXTERN_C const CLSID CLSID_Admin;

#ifdef __cplusplus

class DECLSPEC_UUID("A0082CF6-AFF5-11D2-95E3-00C04F8E7A70")
Admin;
#endif

EXTERN_C const CLSID CLSID_FastAuth;

#ifdef __cplusplus

class DECLSPEC_UUID("5602E146-27F6-11d3-94DD-00C04F72DC08")
FastAuth;
#endif

EXTERN_C const CLSID CLSID_PassportFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("74EB2514-E239-11D2-95E9-00C04F8E7A70")
PassportFactory;
#endif
#endif /* __PASSPORTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\rnraddrs.h ===
/***********************************************************************
* Microsoft RnR Transport location definitions
*
* Microsoft Confidential.  Copyright 1991-1994 Microsoft Corporation.
*
* Component:
*
* File: rnraddrs.h
*
*
* Revision History:
*
*    26-10-94        Created           Arnoldm
*
***********************************************************************/

#ifndef __RNRADDRS_H__
#define __RNRADDRS_H__

//
// Define the IP multicast address and TTL values
//

#define IP_S_MEMBERSHIP  "224.0.1.24"     // the address

//
// Macro to render the string form into an inet_addr form
//

#define INET_ADDR_MEMBERSHIP (inet_addr(IP_S_MEMBERSHIP))

//
// The port we use for locating naming information
//

#define IPMEMBERWKP    445

//
// TTL definitions used for locating names
//

#define TTL_SUBNET_ONLY 1         // no routing
#define TTL_REASONABLE_REACH 2    // across one router
#define TTL_MAX_REACH  6          // Default max diameter. This may
                                  // be overriden via the Registry.

#define TIMEOUT_MAX_MAX  15000    // max wait time for responses. As with
                                  // TTL_MAX_REACH, the registry can supply
                                  // a different value

//
// Definitions for IPX SAP IDs
//

#define RNRCLASSSAPTYPE  0x64F   // official SAP ID
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\permit.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    Permit.h

Abstract:

    Internal UAS constants, data structures.

Author:

    Shanku Niyogi (W-SHANKN)  24-Oct-1991

Revision History:

    24-Oct-1991     w-shankn
        Ported from LM2.0 code, removed unnecessary stuff.
    07-Feb-1992 JohnRo
        Made changes suggested by PC-LINT.
    03-Mar-1992 JohnRo
        Correct handling of byte flags (UAS_REC_DELETE, etc).
    11-Mar-1992 JohnRo
        Include <lmaccess.h> here to get UNITS_PER_WEEK.
    18-Mar-1992 JohnRo
        Include <uascache.h> for UAS_INFO_0.

--*/


#ifndef _PERMIT_
#define _PERMIT_


#include <lmaccess.h>           // UNITS_PER_WEEK.
#include <uascache.h>           // UAS_INFO_0.


#include <packon.h>                     // Suppress natural alignment.

//
// Forward declarations for recursive structures.
//

typedef struct _UAS_AHDR UAS_AHDR, *LPUAS_AHDR;
typedef struct _UAS_GROUP UAS_GROUP, *LPUAS_GROUP;
typedef struct _UAS_GROUPREC UAS_GROUPREC, *LPUAS_GROUPREC;
typedef struct _UAS_USERREC UAS_USERREC, *LPUAS_USERREC;
typedef struct _UAS_USERINFO UAS_USERINFO, *LPUAS_USERINFO;
typedef struct _UAS_DISKUSERHASH UAS_DISKUSERHASH, *LPUAS_DISKUSERHASH;
typedef struct _UAS_PERM UAS_PERM, *LPUAS_PERM;
typedef struct _UAS_ACCESSREC UAS_ACCESSREC, *LPUAS_ACCESSREC;
typedef struct _UAS_ACCESS UAS_ACCESS, *LPUAS_ACCESS;
typedef struct _UAS_VPERM UAS_VPERM, *LPUAS_VPERM;

//
// Constants.
//

#define UAS_MAXGROUP            256     // max number of groups allowed in UAS
#define UAS_MAXACL              8192    // max number of access control list
#define UAS_MAXSEG              8       // max number of segs for perm stuff
#define UAS_ACCESSTBLSIZE       1027    // prime number for less collisions
#define UAS_PSEGSIZE            1024*24 // Initla size of seg holding _pcb
#define UAS_INITSEGSIZE         1024    // Initial size of segs holding perms
#define UAS_URECSEGSIZE         1024*16 // Initial size of UAS logon cache seg
#define UAS_SIZEINC             2048    // Size to grow each time
#define UAS_MINUSER             3       // min number of users in database
#define UAS_MINUREC             128     // cache at least 128 user records
#define UAS_DEFAULT_USERS       128     // default number of records cached
#define UAS_MAXCACHE_LIMIT      1000    // max user records allowed in cache
#define UAS_DBIDINFO_SIZE       50      // database identifier string
#define UAS_INITIALIZE_SEG      1       // manifest for DosSubSet after Alloc
#define UAS_INTRUDER_DELAY      3000L   // 3 sec delay to discourage intruders

#define UAS_MAX_USERS           16000   // Ever, ever, ever
#define UAS_DISK_BLOCK_SIZE     64      // size of block in disk pool

#define UAS_FILE_GROW_INCREMENT 32      // Increment of file grow in disk blocks

#define UAS_USER_HASH_ENTRIES   2048

#define WORDALIGN(a)            (((a)+1) & (~1))

// Temporary definitions. LM20_PATHLEN in LMCONS.H is wrong, and
//     MAXPERMENTRIES may change(?), MAXWORKSTATIONS not in LMCONS.H

#undef LM20_PATHLEN
#define LM20_PATHLEN            260
#define LM20_MAXPERMENTRIES     64
#define MAXWORKSTATIONS         8

//
// Maximum sizes
//

#define UAS_MAX_ACL_SIZE        (sizeof(UAS_ACCESREC) + LM20_PATHLEN \
                                    + sizeof(UAS_VPERM) \
                                    + (LM20_MAXPERMENTRIES - 1) * sizeof(PERM))

#define UAS_MAX_USER_SIZE       (sizeof(UAS_USERINFO) \
                                    + sizeof(WORD) * 8)

                                //  Force header to sector size
#define UAS_GROUP_HASH_START    ((sizeof(UAS_AHDR) + 511) & ~511)

#define UAS_GROUP_HASH_OFFSET(i) (UAS_GROUP_HASH_START \
                                     + i * sizeof (UAS_GROUPREC))

#define UAS_HASH_TBL_OFFSET     UAS_GROUP_HASH_OFFSET(UAS_MAXGROUP)

#define UAS_HASH_ENTRY(i)       (UAS_HASH_TBL_OFFSET \
                                    + (i * sizeof (UAS_DISKUSERHASH)))

#define UAS_HASH_TBL_SIZE       (sizeof(UAS_DISKUSERHASH)*UAS_USER_HASH_ENTRIES)

#define UAS_STRING(s,field)     ((LPSTR)s + s->field)

#define UAS_VPERM_PTR(acc)      (LPUAS_VPERM)((acc)->resource \
                                    + ((((acc)->namelen) + 1) & ~1))

//
// Name Literal
//

#define UAS_USERNAME            0
#define UAS_GROUPNAME           1
#define UAS_ACCESSNAME          2

//
// names of the database file(s)
//

#define UAS_ACCOUNTS_FILE       "NET.ACC"
#define UAS_ACCOUNTS_PATH       "C:\\LANMAN\\ACCOUNTS\\"

//
// special values of uid and serial number for Local calls
//

#define UAS_LOCAL_UID           -1
#define UAS_LOCAL_SERIAL        0L
#define UAS_NONEXISTENT_GID     -1

//
// audit flags
//

#define UAS_AUDIT_ALL           0x1
#define UAS_AUDIT_OPTIONS       0xFFFE
#define UAS_LMFILE_AUDIT_RESERVED   0xF006
#define UAS_PBFILE_AUDIT_RESERVED   0x3


//
// Types of records
//

#define UAS_ACCESS_REC          2
#define UAS_GROUP_REC           1
#define UAS_USER_REC            0

//
// Special Groups Info
//

#define UAS_NUM_SPECIAL_GROUPS  4
#define UAS_GROUP_ADMIN         0
#define UAS_GROUP_USERS         1
#define UAS_GROUP_GUEST         2
#define UAS_GROUP_LOCAL         3
#define UAS_GROUP_NT            (DWORD)-1

#define UAS_GROUP_ADMIN_WNAME   L"ADMINS"
#define UAS_GROUP_USERS_WNAME   L"USERS"
#define UAS_GROUP_GUEST_WNAME   L"GUESTS"
#define UAS_GROUP_LOCAL_WNAME   L"LOCAL"

//
// Signature, text strings
//

#define UAS_LMSIG               "MICROSOFT LANMAN 2.0"
#define UAS_DBIDINFO_TEXT       "LANMAN 2.0 UAS DATABASE"

#define UAS_ROLE_NAME_PRIMARY       "PRIMARY"
#define UAS_ROLE_NAME_BACKUP        "BACKUP"
#define UAS_ROLE_NAME_MEMBER        "MEMBER"
#define UAS_ROLE_NAME_STANDALONE    "STANDALONE"

#define UAS_DOMAIN_LOCAL        "LOCAL"
#define UAS_NLS_YES_KEY         'Y'
#define UAS_NLS_NO_KEY          'N'
#define UAS_DEFAULT_YES         "(Y/N) [Y]"
#define UAS_DEFAULT_NO          "(Y/N) [N]"

#define UAS_DEFAULT_PASSWORD    "PASSWORD"

//
// # of records reserved as the header (store signature) ..
//
//      Note
//      record size of group record  = sizeof(UAS_GROUPREC)
//      record size of user  record  = sizeof(UAS_USERREC)
//      record size of access record = sizeof(UAS_ACCESSREC)
//

#define UAS_GROUPHDR            2
#define UAS_ACCESSHDR           1
#define UAS_USERHDR             1

//
// File_Record Representation
// It is in the first character of the record (name field)
//

#define UAS_REC_EMPTY           '\0'
#define UAS_REC_DELETE          (BYTE)-1
#define UAS_REC_USE             (BYTE)1

//
// Status returned in UserId
//

#define UAS_NAME_NotFound       -1
#define UAS_NAME_NotCache       -2

//
// General Purpose Macros
//

// BitMap macro
#define UAS_MARKUSE(map, pos)   ((map)[(pos) >> 3] |= (1 << ((pos) & 7 ) ))
#define UAS_MARKOFF(map, pos)   ((map)[(pos) >> 3] &= ~(1 << ((pos) & 7 ) ))
#define UAS_ISBITON(map, id)    ((map)[id >> 3] & ( 1 << ((id) & 0x7) ) )
#define UAS_ISBITOFF(map, id)   !UAS_ISBITON((map), (id))

// Conversion from perm ptr back to the access ptr
#define UAS_GETACCHDR(perm, len)    (LPUAS_ACCESS) ((LPBYTE)(perm) \
                                        - WORDALIGN(len) \
                                        - sizeof(UAS_ACCESS) + 1)

// Test if every user's record is cached
#define UAS_ALLUSERCACHED       (Ucb->usercnt < Ucb->maxuser)

// Find the size of block needed to hold access record and perm entries
#define UAS_ACCRECSIZE(len, cnt)    WORDALIGN(sizeof(UAS_ACCESS) - 1 \
                                        + (len) + sizeof(WORD) \
                                        + (cnt)* sizeof(PERM))

// The size of disk record needed to hold access record and perm entries
#define UAS_DISKACCRECSIZE(len, cnt)    WORDALIGN(sizeof(UAS_ACCESSREC) - 1 \
                                            + (len) + sizeof (WORD) \
                                            + (cnt) * sizeof(UAS_PERM))

//
// Record structures in UAS Database (NET.ACC)
//

//
// Header block structure of NET.ACC
//

struct _UAS_AHDR {  // typedef'ed above.

    BYTE signature[WORDALIGN(sizeof(UAS_LMSIG))];   // LANMAN signature
    WORD encryption_flag;               // is database encrypted?
    WORD min_passwd_len;                // password length modal
    DWORD min_passwd_age;               // password age modal
    DWORD max_passwd_age;               // password age modal
    DWORD force_logoff;                 // forced logoff modal
    WORD passwd_hist_len;               // password history modal
    WORD max_bad_passwd;                // max bad passwd try modal
    WORD role;                          // role under SSI
    UAS_INFO_0 local;                   // local database info
    UAS_INFO_0 primary;                 // primary database info
    BYTE DBIdInfo[UAS_DBIDINFO_SIZE];   // database identifier str
    DWORD alist_mtime;                  // last update to ACL's
    DWORD glist_mtime;                  // last upd to groups
    DWORD ulist_mtime;                  // last upd to users
    WORD num_users;                     // Total users in DB
    DWORD free_list;                    // Head of free list
    DWORD access_list;                  // Head of access list
    WORD integrity_flag;                // if FALSE, UAS is corrupt

};


#define UAS_INTEGRITY_OFFSET    (sizeof(UAS_AHDR) - sizeof(WORD))

//
// Structure of a group record in UAS Database
//

struct _UAS_GROUP {  // typedef'ed above.

    BYTE name[LM20_GNLEN+1];
    DWORD serial;

};

struct _UAS_GROUPREC {  // typedef'ed above.

    BYTE name[LM20_GNLEN+1];
    BYTE comment[LM20_MAXCOMMENTSZ+1];
    DWORD serial;

};

//
// Structure of a user record in UAS Database
//
// fields ending in _o are offsets from the start of the structure
// to ASCIIZ strings.
//
// WARNING: When updating this structure update the matching structure
//          UAS_USERINFO. You may also have to update the UAS_MAX_USER_SIZE
//          macro.
//

struct _UAS_USERREC {  // typedef'ed above.

    UAS_USER            user;
    BYTE name[LM20_UNLEN+1];            // user name
    WORD size;                          // total size of user entry
    BYTE passwd[ENCRYPTED_PWLEN];       // encrypted password
    DWORD last;                         // last time passwd changed
    WORD directory_o;                   // directory & logon script
    WORD comment_o;                     // comment
    WORD flags;                         // User flags
    WORD script_o;                      // logon script name
    WORD full_name_o;
    WORD usr_comment_o;
    WORD parms_o;
    DWORD last_logon;
    DWORD last_logoff;
    DWORD max_storage;
    DWORD acct_expires;
    WORD bad_pw_count;
    WORD num_logons;
    BYTE logonhrs[UNITS_PER_WEEK/8];
    WORD workstation_o;
    BYTE old_passwds[DEF_MAX_PWHIST * ENCRYPTED_PWLEN];
    WORD logon_server_o;
    WORD country_code;
    WORD code_page;

};

//
// Decompressed user record.
//

struct _UAS_USERINFO {  // typedef'ed above.

    UAS_USER user;
    BYTE name[LM20_UNLEN+1];            // user name
    BYTE passwd[ENCRYPTED_PWLEN];       // encrypted password
    DWORD last;                         // last time passwd changed
    BYTE directory[LM20_PATHLEN+1];     // directory & logon script
    BYTE comment[LM20_MAXCOMMENTSZ+1];  // comment
    WORD flags;                         // User flags
    BYTE script[LM20_PATHLEN+1];        // logon script name
    BYTE full_name[LM20_MAXCOMMENTSZ+1];
    BYTE usr_comment[MAXCOMMENTSZ+1];
    BYTE parms[MAXCOMMENTSZ+1];
    DWORD last_logon;
    DWORD last_logoff;
    DWORD max_storage;
    DWORD acct_expires;
    WORD bad_pw_count;
    WORD num_logons;
    BYTE logonhrs[UNITS_PER_WEEK/8];
    BYTE workstation[MAXWORKSTATIONS * (LM20_CNLEN+1)];
    BYTE old_passwds[DEF_MAX_PWHIST * ENCRYPTED_PWLEN];
    BYTE logon_server[LM20_UNCLEN+1];
    WORD country_code;
    WORD code_page;

};

#define UAS_URECSIZE        UAS_MAX_USER_SIZE
#define UAS_GRECSIZE        sizeof(UAS_GROUPREC)


typedef struct _UAS_DISK_OBJ_HDR {

    BYTE do_type;
    BYTE do_numblocks;
    DWORD do_next;
    DWORD do_prev;

} UAS_DISK_OBJ_HDR, *LPUAS_DISK_OBJ_HDR;

#define UAS_NEXT_OFFSET     (2 * sizeof(BYTE))
#define UAS_PREV_OFFSET     (2 * sizeof(BYTE) + sizeof(DWORD))

#define UAS_FREE_OBJECT_ID     0
#define UAS_USER_OBJECT_ID     1
#define UAS_ACCESS_OBJECT_ID   2

typedef struct _UAS_USER_OBJECT {

    UAS_DISK_OBJ_HDR uo_header;
    UAS_USERREC uo_record;
    BYTE uo_data[1];                    // Variable size

} UAS_USER_OBJECT, *LPUAS_USER_OBJECT;

//
// User hash table entry in memory
//

typedef struct _UAS_USERHASH {

    DWORD uh_disk;
    WORD uh_cache;
    DWORD uh_serial;

} UAS_USERHASH, *LPUAS_USERHASH;

//
// User hash table entry on disk
//

struct _UAS_DISKUSERHASH {  // typedef'ed above.

    DWORD dh_disk;
    DWORD dh_serial;

};

//
// Permission data
//

struct _UAS_PERM {  // typedef'ed above.

    WORD uid;                   // bit 15: 0 = uid, 1 = gid
    DWORD serial;
    BYTE access;
    BYTE pad;                   // word align this puppy

};

//
// Access Record structure in Database (NET.ACC)
//

struct _UAS_ACCESSREC {  // typedef'ed above.

    WORD attr;                  // audit attribute
    WORD recsize;
    WORD namelen;
    BYTE resource[1];

};

//
// Internal access record structure in memory
//

struct _UAS_ACCESS {  // typedef'ed above.

    LPUAS_ACCESS next;
    DWORD position;
    WORD attr;
    WORD recsize;
    WORD namelen;
    BYTE resource[1];

};

//
// followed by variable number of permission entry
//

struct _UAS_VPERM {  // typedef'ed above.

    WORD permcnt;
    UAS_PERM perm[1];

};

//  Size (in bytes) of a variable size ACL

#define UAS_ACL_RECORD_SIZE(acl,namelen,permcnt) \
                (((sizeof(UAS_ACCESSREC) + namelen \
                    + sizeof (UAS_VPERM) \
                    + sizeof (UAS_PERM) * (permcnt - 1)) + 1) & ~1)

typedef struct _UAS_ACCESS_OBJECT {

    UAS_DISK_OBJ_HDR ao_header;         // Fixed length header
    UAS_ACCESSREC ao_record;            // Variable length
    UAS_VPERM ao_data;                  // Variable length

} UAS_ACCESS_OBJECT, *LPUAS_ACCESS_OBJECT;

#include <packoff.h>


#endif // _PERMIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\samimp.h ===
#include <nt.h>
//#include <ntrpcnew.h>
#include <lsass.h>
#include <ntsam.h>
#include <ntsamp.h>


#ifdef MIDL_PASS
// put any typedef redefinitions in here...
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\rxserver.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    RxServer.h

Abstract:

    This is the public header file for the NT version of RpcXlate.
    This contains prototypes for the RxNetServer APIs and old info level
    structures (in 32-bit format).

Author:

    John Rogers (JohnRo) 01-May-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include <windef.h>, <lmcons.h>, and <rap.h> before this file.

Revision History:

    01-May-1991 JohnRo
        Created.
    26-May-1991 JohnRo
        Added incomplete output parm to RxGetServerInfoLevelEquivalent.
    04-Dec-1991 JohnRo
        Change RxNetServerSetInfo() to new-style interface.

--*/

#ifndef _RXSERVER_
#define _RXSERVER_


//
// Handlers for individual APIs:
// (Add prototypes for other APIs here, in alphabetical order.)
//

NET_API_STATUS
RxNetServerDiskEnum (
    IN LPTSTR UncServerName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PrefMaxSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD Resume_Handle OPTIONAL
    );

NET_API_STATUS
RxNetServerEnum (
    IN LPCWSTR UncServerName,
    IN LPCWSTR TransportName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PrefMaxSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN DWORD ServerType,
    IN LPCWSTR Domain OPTIONAL,
    IN LPCWSTR FirstNameToReturn OPTIONAL
    );

NET_API_STATUS
RxNetServerGetInfo (
    IN LPTSTR UncServerName,
    IN DWORD Level,             // May be old or new info level.
    OUT LPBYTE *BufPtr
    );

NET_API_STATUS
RxNetServerSetInfo (
    IN LPTSTR UncServerName,
    IN DWORD Level,             // Level and/or ParmNum
    IN LPBYTE Buf,
    OUT LPDWORD ParmError OPTIONAL
    );

//
// Equates for set-info handling.
//
#define NEW_SERVER_SUPERSET_LEVEL       102
#define OLD_SERVER_SUPERSET_LEVEL       3


//
// Server-specific common routines:
//

NET_API_STATUS
RxGetServerInfoLevelEquivalent (
    IN DWORD FromLevel,
    IN BOOL FromNative,
    IN BOOL ToNative,
    OUT LPDWORD ToLevel,
    OUT LPDESC * ToDataDesc16 OPTIONAL,
    OUT LPDESC * ToDataDesc32 OPTIONAL,
    OUT LPDESC * ToDataDescSmb OPTIONAL,
    OUT LPDWORD FromMaxSize OPTIONAL,
    OUT LPDWORD FromFixedSize OPTIONAL,
    OUT LPDWORD FromStringSize OPTIONAL,
    OUT LPDWORD ToMaxSize OPTIONAL,
    OUT LPDWORD ToFixedSize OPTIONAL,
    OUT LPDWORD ToStringSize OPTIONAL,
    OUT LPBOOL IncompleteOutput OPTIONAL
    );

#endif // ndef _RXSERVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\rxprint.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    RxPrint.h

Abstract:

    This contains prototypes for the RxPrint routines.

Author:

    Dave Snipp (DaveSn) 16-Apr-1991

Environment:

Notes:

    All of the RxPrint APIs are wide-character APIs, regardless of
    whether or not UNICODE is defined.  This allows the net/dosprint/dosprint.c
    code to use the winspool APIs (which are currently ANSI APIs, despite their
    prototypes using LPTSTR in some places).

Revision History:

    22-Apr-1991 JohnRo
        Use constants from <lmcons.h>.
    14-May-1991 JohnRo
        Change WORD to DWORD in all parameter lists.  Similarly, change
        PWORD to LPDWORD and PUSHORT to LPDWORD.
    18-May-1991 JohnRo
        Changed SPLERR to be defined as NET_API_STATUS.
    22-May-1991 CliffV
        Added local definitions of PDLEN and DTLEN since they are no longer
        in lmcons.h.
    26-May-1991 JohnRo
        Use IN, OUT, OPTIONAL, LPVOID, LPTSTR, etc.
    18-Jun-1991 JohnRo
        Deleted RxPrintJobGetId, as it will be an IOCTL rather than a remoted
        API.
    26-Jun-1991 CliffV
        Used LM2.0 versions of CNLEN, UNLEN, and QNLEN.
    16-Jul-1991 JohnRo
        Estimate bytes needed for print APIs.
    16-Jun-1992 JohnRo
        RAID 10324: net print vs. UNICODE.
    08-Feb-1993 JohnRo
        RAID 10164: Data misalignment error during XsDosPrintQGetInfo().
    07-Apr-1993 JohnRo
        RAID 5670: "NET PRINT \\server\share" gives err 124 (bad level) on NT.

--*/

#ifndef _RXPRINT_
#define _RXPRINT_

#include <windef.h>     // DWORD, LPVOID, LPTSTR, TCHAR, etc.
#include <lmcons.h>     // LM20_CNLEN, IN, NET_API_STATUS, etc.

#define SPLENTRY pascal far

/* length for character arrays in structures (excluding zero terminator) */
#define PDLEN               8                  /* Print destination length  */
#define DTLEN               9                  /* Spool file data type      */
//                                             /* e.g. PM_Q_STD,PM_Q_RAW    */
#define QP_DATATYPE_SIZE 15                 /* returned by SplQpQueryDt  */
#define DRIV_DEVICENAME_SIZE 31             /* see DRIVDATA struc        */
#define DRIV_NAME_SIZE 8                    /* name of device driver     */
#define PRINTERNAME_SIZE 32                 /* max printer name length   */
#define FORMNAME_SIZE 31                    /* max form name length      */
// #define MAXCOMMENTSZ    48                  /* queue comment length      */

/**INTERNAL_ONLY**/
/* IOctl for RxPrintJobGetId */
#define SPOOL_LMCAT                     83
#define SPOOL_LMGetPrintId              0x60

// Used in remdef.h for structure definition to marshall data
#define MAX_DEPENDENT_FILES             64
/**END_INTERNAL**/


typedef NET_API_STATUS SPLERR;    /* err */


typedef struct _PRJINFOA {   /* prj1 */
    WORD    uJobId;
    CHAR    szUserName[LM20_UNLEN+1];
    CHAR    pad_1;
    CHAR    szNotifyName[LM20_CNLEN+1];
    CHAR    szDataType[DTLEN+1];
    LPSTR   pszParms;
    WORD    uPosition;
    WORD    fsStatus;
    LPSTR   pszStatus;
    DWORD   ulSubmitted;
    DWORD   ulSize;
    LPSTR   pszComment;
} PRJINFOA;
typedef struct _PRJINFOW {   /* prj1 */
    WORD    uJobId;
    WCHAR   szUserName[LM20_UNLEN+1];
    WCHAR   pad_1;
    WCHAR   szNotifyName[LM20_CNLEN+1];
    WCHAR   szDataType[DTLEN+1];
    LPWSTR  pszParms;
    WORD    uPosition;
    WORD    fsStatus;
    LPWSTR  pszStatus;
    DWORD   ulSubmitted;
    DWORD   ulSize;
    LPWSTR  pszComment;
} PRJINFOW;
#ifdef UNICODE
typedef PRJINFOW PRJINFO;
#else
typedef PRJINFOA PRJINFO;
#endif // UNICODE
typedef PRJINFOA far *PPRJINFOA;
typedef PRJINFOW far *PPRJINFOW;
#ifdef UNICODE
typedef PPRJINFOW PPRJINFO;
#else
typedef PPRJINFOA PPRJINFO;
#endif // UNICODE
typedef PRJINFOA near *NPPRJINFOA;
typedef PRJINFOW near *NPPRJINFOW;
#ifdef UNICODE
typedef NPPRJINFOW NPPRJINFO;
#else
typedef NPPRJINFOA NPPRJINFO;
#endif // UNICODE

typedef struct _PRJINFO2A {   /* prj2 */
    WORD    uJobId;
    WORD    uPriority;
    LPSTR   pszUserName;
    WORD    uPosition;
    WORD    fsStatus;
    DWORD   ulSubmitted;
    DWORD   ulSize;
    LPSTR   pszComment;
    LPSTR   pszDocument;
} PRJINFO2A;
typedef struct _PRJINFO2W {   /* prj2 */
    WORD    uJobId;
    WORD    uPriority;
    LPWSTR  pszUserName;
    WORD    uPosition;
    WORD    fsStatus;
    DWORD   ulSubmitted;
    DWORD   ulSize;
    LPWSTR  pszComment;
    LPWSTR  pszDocument;
} PRJINFO2W;
#ifdef UNICODE
typedef PRJINFO2W PRJINFO2;
#else
typedef PRJINFO2A PRJINFO2;
#endif // UNICODE
typedef PRJINFO2A far *PPRJINFO2A;
typedef PRJINFO2W far *PPRJINFO2W;
#ifdef UNICODE
typedef PPRJINFO2W PPRJINFO2;
#else
typedef PPRJINFO2A PPRJINFO2;
#endif // UNICODE
typedef PRJINFO2A near *NPPRJINFO2A;
typedef PRJINFO2W near *NPPRJINFO2W;
#ifdef UNICODE
typedef NPPRJINFO2W NPPRJINFO2;
#else
typedef NPPRJINFO2A NPPRJINFO2;
#endif // UNICODE

typedef struct _PRJINFO3A {   /* prj */
    WORD    uJobId;
    WORD    uPriority;
    LPSTR   pszUserName;
    WORD    uPosition;
    WORD    fsStatus;
    DWORD   ulSubmitted;
    DWORD   ulSize;
    LPSTR   pszComment;
    LPSTR   pszDocument;
    LPSTR   pszNotifyName;
    LPSTR   pszDataType;
    LPSTR   pszParms;
    LPSTR   pszStatus;
    LPSTR   pszQueue;
    LPSTR   pszQProcName;
    LPSTR   pszQProcParms;
    LPSTR   pszDriverName;
    LPVOID  pDriverData;
    LPSTR   pszPrinterName;
} PRJINFO3A;
typedef struct _PRJINFO3W {   /* prj */
    WORD    uJobId;
    WORD    uPriority;
    LPWSTR  pszUserName;
    WORD    uPosition;
    WORD    fsStatus;
    DWORD   ulSubmitted;
    DWORD   ulSize;
    LPWSTR  pszComment;
    LPWSTR  pszDocument;
    LPWSTR  pszNotifyName;
    LPWSTR  pszDataType;
    LPWSTR  pszParms;
    LPWSTR  pszStatus;
    LPWSTR  pszQueue;
    LPWSTR  pszQProcName;
    LPWSTR  pszQProcParms;
    LPWSTR  pszDriverName;
    LPVOID  pDriverData;
    LPWSTR  pszPrinterName;
} PRJINFO3W;
#ifdef UNICODE
typedef PRJINFO3W PRJINFO3;
#else
typedef PRJINFO3A PRJINFO3;
#endif // UNICODE
typedef PRJINFO3A far *PPRJINFO3A;
typedef PRJINFO3W far *PPRJINFO3W;
#ifdef UNICODE
typedef PPRJINFO3W PPRJINFO3;
#else
typedef PPRJINFO3A PPRJINFO3;
#endif // UNICODE
typedef PRJINFO3A near *NPPRJINFO3A;
typedef PRJINFO3W near *NPPRJINFO3W;
#ifdef UNICODE
typedef NPPRJINFO3W NPPRJINFO3;
#else
typedef NPPRJINFO3A NPPRJINFO3;
#endif // UNICODE


typedef struct _PRDINFOA {    /* prd1 */
    CHAR    szName[PDLEN+1];
    CHAR    szUserName[LM20_UNLEN+1];
    WORD    uJobId;
    WORD    fsStatus;
    LPSTR   pszStatus;
    WORD    time;
} PRDINFOA;
typedef struct _PRDINFOW {    /* prd1 */
    WCHAR   szName[PDLEN+1];
    WCHAR   szUserName[LM20_UNLEN+1];
    WORD    uJobId;
    WORD    fsStatus;
    LPWSTR  pszStatus;
    WORD    time;
} PRDINFOW;
#ifdef UNICODE
typedef PRDINFOW PRDINFO;
#else
typedef PRDINFOA PRDINFO;
#endif // UNICODE
typedef PRDINFOA far *PPRDINFOA;
typedef PRDINFOW far *PPRDINFOW;
#ifdef UNICODE
typedef PPRDINFOW PPRDINFO;
#else
typedef PPRDINFOA PPRDINFO;
#endif // UNICODE
typedef PRDINFOA near *NPPRDINFOA;
typedef PRDINFOW near *NPPRDINFOW;
#ifdef UNICODE
typedef NPPRDINFOW NPPRDINFO;
#else
typedef NPPRDINFOA NPPRDINFO;
#endif // UNICODE


typedef struct _PRDINFO3A {   /* prd */
    LPSTR   pszPrinterName;
    LPSTR   pszUserName;
    LPSTR   pszLogAddr;
    WORD    uJobId;
    WORD    fsStatus;
    LPSTR   pszStatus;
    LPSTR   pszComment;
    LPSTR   pszDrivers;
    WORD    time;
    WORD    pad1;
} PRDINFO3A;
typedef struct _PRDINFO3W {   /* prd */
    LPWSTR  pszPrinterName;
    LPWSTR  pszUserName;
    LPWSTR  pszLogAddr;
    WORD    uJobId;
    WORD    fsStatus;
    LPWSTR  pszStatus;
    LPWSTR  pszComment;
    LPWSTR  pszDrivers;
    WORD    time;
    WORD    pad1;
} PRDINFO3W;
#ifdef UNICODE
typedef PRDINFO3W PRDINFO3;
#else
typedef PRDINFO3A PRDINFO3;
#endif // UNICODE
typedef PRDINFO3A far *PPRDINFO3A;
typedef PRDINFO3W far *PPRDINFO3W;
#ifdef UNICODE
typedef PPRDINFO3W PPRDINFO3;
#else
typedef PPRDINFO3A PPRDINFO3;
#endif // UNICODE
typedef PRDINFO3A near *NPPRDINFO3A;
typedef PRDINFO3W near *NPPRDINFO3W;
#ifdef UNICODE
typedef NPPRDINFO3W NPPRDINFO3;
#else
typedef NPPRDINFO3A NPPRDINFO3;
#endif // UNICODE


typedef struct _PRQINFOA {   /* prq1 */
    CHAR    szName[LM20_QNLEN+1];
    CHAR    pad_1;
    WORD    uPriority;
    WORD    uStartTime;
    WORD    uUntilTime;
    LPSTR   pszSepFile;
    LPSTR   pszPrProc;
    LPSTR   pszDestinations;
    LPSTR   pszParms;
    LPSTR   pszComment;
    WORD    fsStatus;
    WORD    cJobs;
} PRQINFOA;
typedef struct _PRQINFOW {   /* prq1 */
    WCHAR   szName[LM20_QNLEN+1];
    WCHAR   pad_1;
    WORD    uPriority;
    WORD    uStartTime;
    WORD    uUntilTime;
    LPWSTR  pszSepFile;
    LPWSTR  pszPrProc;
    LPWSTR  pszDestinations;
    LPWSTR  pszParms;
    LPWSTR  pszComment;
    WORD    fsStatus;
    WORD    cJobs;
} PRQINFOW;
#ifdef UNICODE
typedef PRQINFOW PRQINFO;
#else
typedef PRQINFOA PRQINFO;
#endif // UNICODE
typedef PRQINFOA far *PPRQINFOA;
typedef PRQINFOW far *PPRQINFOW;
#ifdef UNICODE
typedef PPRQINFOW PPRQINFO;
#else
typedef PPRQINFOA PPRQINFO;
#endif // UNICODE
typedef PRQINFOA near *NPPRQINFOA;
typedef PRQINFOW near *NPPRQINFOW;
#ifdef UNICODE
typedef NPPRQINFOW NPPRQINFO;
#else
typedef NPPRQINFOA NPPRQINFO;
#endif // UNICODE


typedef struct _PRQINFO3A {  /* prq */
    LPSTR   pszName;
    WORD    uPriority;
    WORD    uStartTime;
    WORD    uUntilTime;
    WORD    pad1;
    LPSTR   pszSepFile;
    LPSTR   pszPrProc;
    LPSTR   pszParms;
    LPSTR   pszComment;
    WORD    fsStatus;
    WORD    cJobs;
    LPSTR   pszPrinters;
    LPSTR   pszDriverName;
    LPVOID  pDriverData;
} PRQINFO3A;
typedef struct _PRQINFO3W {  /* prq */
    LPWSTR  pszName;
    WORD    uPriority;
    WORD    uStartTime;
    WORD    uUntilTime;
    WORD    pad1;
    LPWSTR  pszSepFile;
    LPWSTR  pszPrProc;
    LPWSTR  pszParms;
    LPWSTR  pszComment;
    WORD    fsStatus;
    WORD    cJobs;
    LPWSTR  pszPrinters;
    LPWSTR  pszDriverName;
    LPVOID  pDriverData;
} PRQINFO3W;
#ifdef UNICODE
typedef PRQINFO3W PRQINFO3;
#else
typedef PRQINFO3A PRQINFO3;
#endif // UNICODE
typedef PRQINFO3A far *PPRQINFO3A;
typedef PRQINFO3W far *PPRQINFO3W;
#ifdef UNICODE
typedef PPRQINFO3W PPRQINFO3;
#else
typedef PPRQINFO3A PPRQINFO3;
#endif // UNICODE
typedef PRQINFO3A near *NPPRQINFO3A;
typedef PRQINFO3W near *NPPRQINFO3W;
#ifdef UNICODE
typedef NPPRQINFO3W NPPRQINFO3;
#else
typedef NPPRQINFO3A NPPRQINFO3;
#endif // UNICODE


typedef struct _PRQINFO52A {  /* prq */
    WORD        uVersion;
    LPSTR       pszModelName;
    LPSTR       pszDriverName;
    LPSTR       pszDataFileName;
    LPSTR       pszMonitorName;
    LPSTR       pszDriverPath;
    LPSTR       pszDefaultDataType;
    LPSTR       pszHelpFile;
    LPSTR       pszConfigFile;
    WORD        cDependentNames;
    LPSTR       pszDependentNames[MAX_DEPENDENT_FILES];
} PRQINFO52A;
typedef struct _PRQINFO52W {  /* prq */
    WORD        uVersion;
    LPWSTR      pszModelName;
    LPWSTR      pszDriverName;
    LPWSTR      pszDataFileName;
    LPWSTR      pszMonitorName;
    LPWSTR      pszDriverPath;
    LPWSTR      pszDefaultDataType;
    LPWSTR      pszHelpFile;
    LPWSTR      pszConfigFile;
    WORD        cDependentNames;
    LPWSTR      pszDependentNames[MAX_DEPENDENT_FILES];
} PRQINFO52W;
#ifdef UNICODE
typedef PRQINFO52W PRQINFO52;
#else
typedef PRQINFO52A PRQINFO52;
#endif // UNICODE
typedef PRQINFO52A far *PPRQINFO52A;
typedef PRQINFO52W far *PPRQINFO52W;
#ifdef UNICODE
typedef PPRQINFO52W PPRQINFO52;
#else
typedef PPRQINFO52A PPRQINFO52;
#endif // UNICODE
typedef PRQINFO52A near *NPPRQINFO52A;
typedef PRQINFO52W near *NPPRQINFO52W;
#ifdef UNICODE
typedef NPPRQINFO52W NPPRQINFO52;
#else
typedef NPPRQINFO52A NPPRQINFO52;
#endif // UNICODE


/*
 * structure for RxPrintJobGetId
 */
typedef struct _PRIDINFOA {  /* prjid */
    WORD    uJobId;
    CHAR    szServer[LM20_CNLEN + 1];
    CHAR    szQName[LM20_QNLEN+1];
    CHAR    pad_1;
} PRIDINFOA;
/*
 * structure for RxPrintJobGetId
 */
typedef struct _PRIDINFOW {  /* prjid */
    WORD    uJobId;
    WCHAR   szServer[LM20_CNLEN + 1];
    WCHAR   szQName[LM20_QNLEN+1];
    CHAR    pad_1;
} PRIDINFOW;
#ifdef UNICODE
typedef PRIDINFOW PRIDINFO;
#else
typedef PRIDINFOA PRIDINFO;
#endif // UNICODE
typedef PRIDINFOA far *PPRIDINFOA;
typedef PRIDINFOW far *PPRIDINFOW;
#ifdef UNICODE
typedef PPRIDINFOW PPRIDINFO;
#else
typedef PPRIDINFOA PPRIDINFO;
#endif // UNICODE
typedef PRIDINFOA near *NPPRIDINFOA;
typedef PRIDINFOW near *NPPRIDINFOW;
#ifdef UNICODE
typedef NPPRIDINFOW NPPRIDINFO;
#else
typedef NPPRIDINFOA NPPRIDINFO;
#endif // UNICODE


/****************************************************************
 *                                                              *
 *              Function prototypes                             *
 *                                                              *
 ****************************************************************/

SPLERR SPLENTRY RxPrintDestEnum(
            IN LPTSTR pszServer,
            IN DWORD uLevel,
            OUT LPBYTE pbBuf,
            IN DWORD cbBuf,
            IN LPDWORD pcReturned,
            OUT LPDWORD pcTotal
            );

SPLERR SPLENTRY RxPrintDestControl(
            IN LPTSTR pszServer,
            IN LPTSTR pszDevName,
            IN DWORD uControl
            );

SPLERR SPLENTRY RxPrintDestGetInfo(
            IN LPTSTR pszServer,
            IN LPTSTR pszName,
            IN DWORD uLevel,
            OUT LPBYTE pbBuf,
            IN DWORD cbBuf,
            OUT LPDWORD pcbNeeded   // estimated (probably too large).
            );

SPLERR SPLENTRY RxPrintDestAdd(
            IN LPTSTR pszServer,
            IN DWORD uLevel,
            IN LPBYTE pbBuf,
            IN DWORD cbBuf
            );

SPLERR SPLENTRY RxPrintDestSetInfo(
            IN LPTSTR pszServer,
            IN LPTSTR pszName,
            IN DWORD uLevel,
            IN LPBYTE pbBuf,
            IN DWORD cbBuf,
            IN DWORD uParmNum
            );

SPLERR SPLENTRY RxPrintDestDel(
            IN LPTSTR pszServer,
            IN LPTSTR pszPrinterName
            );

SPLERR SPLENTRY RxPrintQEnum(
            IN LPTSTR pszServer,
            IN DWORD uLevel,
            OUT LPBYTE pbBuf,
            IN DWORD cbBuf,
            OUT LPDWORD pcReturned,
            OUT LPDWORD pcTotal
            );

SPLERR SPLENTRY RxPrintQGetInfo(
            IN LPTSTR pszServer,
            IN LPTSTR pszQueueName,
            IN DWORD uLevel,
            OUT LPBYTE pbBuf,
            IN DWORD cbBuf,
            OUT LPDWORD pcbNeeded   // estimated (probably too large).
            );

SPLERR SPLENTRY RxPrintQSetInfo(
            IN LPTSTR pszServer,
            IN LPTSTR pszQueueName,
            IN DWORD uLevel,
            IN LPBYTE pbBuf,
            IN DWORD cbBuf,
            IN DWORD uParmNum
            );

SPLERR SPLENTRY RxPrintQPause(
            IN LPTSTR pszServer,
            IN LPTSTR pszQueueName
            );

SPLERR SPLENTRY RxPrintQContinue(
            IN LPTSTR pszServer,
            IN LPTSTR pszQueueName
            );

SPLERR SPLENTRY RxPrintQPurge(
            IN LPTSTR pszServer,
            IN LPTSTR pszQueueName
            );

SPLERR SPLENTRY RxPrintQAdd(
            IN LPTSTR pszServer,
            IN DWORD uLevel,
            IN LPBYTE pbBuf,
            IN DWORD cbBuf
            );

SPLERR SPLENTRY RxPrintQDel(
            IN LPTSTR pszServer,
            IN LPTSTR pszQueueName
            );

SPLERR SPLENTRY RxPrintJobGetInfo(
            IN LPTSTR pszServer,
            IN DWORD uJobId,
            IN DWORD uLevel,
            OUT LPBYTE pbBuf,
            IN DWORD cbBuf,
            OUT LPDWORD pcbNeeded   // estimated (probably too large).
            );

SPLERR SPLENTRY RxPrintJobSetInfo(
            IN LPTSTR pszServer,
            IN DWORD uJobId,
            IN DWORD uLevel,
            IN LPBYTE pbBuf,
            IN DWORD cbBuf,
            IN DWORD uParmNum
            );

SPLERR SPLENTRY RxPrintJobPause(
            IN LPTSTR pszServer,
            IN DWORD uJobId
            );

SPLERR SPLENTRY RxPrintJobContinue(
            IN LPTSTR pszServer,
            IN DWORD uJobId
            );

SPLERR SPLENTRY RxPrintJobDel(
            IN LPTSTR pszServer,
            IN DWORD uJobId
            );

SPLERR SPLENTRY RxPrintJobEnum(
            IN LPTSTR pszServer,
            IN LPTSTR pszQueueName,
            IN DWORD uLevel,
            OUT LPBYTE pbBuf,
            IN DWORD cbBuf,
            OUT LPDWORD pcReturned,
            OUT LPDWORD pcTotal
            );


/*
 *      Values for parmnum in RxPrintQSetInfo.
 */

#define PRQ_PRIORITY_PARMNUM            2
#define PRQ_STARTTIME_PARMNUM           3
#define PRQ_UNTILTIME_PARMNUM           4
#define PRQ_SEPARATOR_PARMNUM           5
#define PRQ_PROCESSOR_PARMNUM           6
#define PRQ_DESTINATIONS_PARMNUM        7
#define PRQ_PARMS_PARMNUM               8
#define PRQ_COMMENT_PARMNUM             9
#define PRQ_PRINTERS_PARMNUM           12
#define PRQ_DRIVERNAME_PARMNUM         13
#define PRQ_DRIVERDATA_PARMNUM         14
#define PRQ_MAXPARMNUM                 14

/*
 *      Print Queue Priority
 */

#define PRQ_MAX_PRIORITY                1           /* highest priority */
#define PRQ_DEF_PRIORITY                5
#define PRQ_MIN_PRIORITY                9           /* lowest priority */
#define PRQ_NO_PRIORITY                 0

/*
 *      Print queue status bitmask and values.
 */

#define PRQ_STATUS_MASK                 3
#define PRQ_ACTIVE                      0
#define PRQ_PAUSED                      1
#define PRQ_ERROR                       2
#define PRQ_PENDING                     3

/*
 *      Print queue status bits for level 3
 */

#define PRQ3_PAUSED                   0x1
#define PRQ3_PENDING                  0x2
/*
 *      Values for parmnum in RxPrintJobSetInfo.
 */

#define PRJ_NOTIFYNAME_PARMNUM        3
#define PRJ_DATATYPE_PARMNUM          4
#define PRJ_PARMS_PARMNUM             5
#define PRJ_POSITION_PARMNUM          6
#define PRJ_COMMENT_PARMNUM          11
#define PRJ_DOCUMENT_PARMNUM         12
#define PRJ_PRIORITY_PARMNUM         14
#define PRJ_PROCPARMS_PARMNUM        16
#define PRJ_DRIVERDATA_PARMNUM       18
#define PRJ_MAXPARMNUM               18

/*
 *      Bitmap masks for status field of PRJINFO.
 */

/* 2-7 bits also used in device status */

#define PRJ_QSTATUS      0x0003      /* Bits 0,1 */
#define PRJ_DEVSTATUS    0x0ffc      /* 2-11 bits */
#define PRJ_COMPLETE     0x0004      /*  Bit 2   */
#define PRJ_INTERV       0x0008      /*  Bit 3   */
#define PRJ_ERROR        0x0010      /*  Bit 4   */
#define PRJ_DESTOFFLINE  0x0020      /*  Bit 5   */
#define PRJ_DESTPAUSED   0x0040      /*  Bit 6   */
#define PRJ_NOTIFY       0x0080      /*  Bit 7   */
#define PRJ_DESTNOPAPER  0x0100      /*  Bit 8   */
#define PRJ_DESTFORMCHG  0x0200      /* BIT 9 */
#define PRJ_DESTCRTCHG   0x0400      /* BIT 10 */
#define PRJ_DESTPENCHG   0x0800      /* BIT 11 */
#define PRJ_DELETED      0x8000      /* Bit 15   */

/*
 *      Values of PRJ_QSTATUS bits in fsStatus field of PRJINFO.
 */

#define PRJ_QS_QUEUED                 0
#define PRJ_QS_PAUSED                 1
#define PRJ_QS_SPOOLING               2
#define PRJ_QS_PRINTING               3

/*
 *      Print Job Priority
 */

#define PRJ_MAX_PRIORITY                99          /* lowest priority */
#define PRJ_MIN_PRIORITY                 1          /* highest priority */
#define PRJ_NO_PRIORITY                  0


/*
 *      Bitmap masks for status field of PRDINFO.
 *      see PRJ_... for bits 2-11
 */

#define PRD_STATUS_MASK       0x0003      /* Bits 0,1 */
#define PRD_DEVSTATUS         0x0ffc      /* 2-11 bits */

/*
 *      Values of PRD_STATUS_MASK bits in fsStatus field of PRDINFO.
 */

#define PRD_ACTIVE                 0
#define PRD_PAUSED                 1

/*
 *      Control codes used in RxPrintDestControl.
 */

#define PRD_DELETE                    0
#define PRD_PAUSE                     1
#define PRD_CONT                      2
#define PRD_RESTART                   3

/*
 *      Values for parmnum in RxPrintDestSetInfo.
 */

#define PRD_LOGADDR_PARMNUM      3
#define PRD_COMMENT_PARMNUM      7
#define PRD_DRIVERS_PARMNUM      8
#endif // ndef _RXPRINT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\recovery.h ===
/*++

Copyright (C) Microsoft Corporation, 1998.
              Microsoft Windows

Module Name:

    RECOVERY.H

Abstract:


Author:

    09-Jan-99 ShaoYin

Environment:

    Kernel Mode - Win32

Revision History:

    09-Jan-99 ShaoYin Created Initial File.

    07-July-2000 ShaoYin Add API to retrieve next available RID from registry

--*/


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//     Global Variables and Private Routines                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


#ifndef _RECOVERY_
#define _RECOVERY_




//
// Exported API 
// 

#define REGISTRY_KEY_NAME_LENGTH_MAX    512


//
// The following API is exported to System Recovery Tool and Restore Utility. 
// 
// 1. will run in Kernel Mode if used by System Recovery Tool.
//         run in User Mode if used by Restore Utility
//
// 2. Parameters:
//  
//    Rid - Logon User's Relative ID
//
//    hSecurityRootKey - Handle of the Root of SECURITY hive
//
//    hSamRootKey - Handle of the Root of SAM hive
// 
//    hSystemRootKey - Handle of the root of system hive 
//
//          caller should Load the SAM hive and System hive, 
//                 and Unload them after this API returns.
//
//
//    BootKey -- OPTIONAL. During the first call of this API, should provide
//               NULL. Then SAM will query registry, check how the machine is
//               syskey'd. 
//
//               If the BootKey is stored in registry or the local machine is
//               not syskey'd yet, no further caller's side work.
//
//               If the BootKey is stored in floppy disk, this API will fail
//               with error code STATUS_SAM_NEED_BOOTKEY_FLOPPY, the caller 
//               should handle it by reading the syskey from floppy disk, the
//               try this API with the BootKey parameter filled correctly.
//               The syskey (the data) read from the floppy disk should be copy
//               to the BootKey->Buffer, and BootKey->Length indicate the 
//               length of the data.
//               
//               If the BootKey is derived from Boot Password, this API will 
//               fail with error code STATUS_SAM_NEED_BOOTKEY_PASSWORD, then
//               the caller should prompt the logon user to enter Boot Password, 
//               then try this API with the BootPassword again.  
//               In this case BootKey should be the entered password. 
//               BootKey->Buffer should be the WCHAR password, 
//               BootKey->Length should be the length of password in byte. 
//  
//    BootKeyType -- OPTIONAL. Accociated with BootKey, only used when 
//               BootKey is Not NULL. 
//               Valid Values:
//
//               SamBootKeyDisk - means BootKey->Buffer contains the actual
//                                syskey read from floppy disk, 
//                                BootKey->Length should be the length of 
//                                syskey in byte
//
//               SamBootKeyPassword - means BootKey contains the UNICODE_STRING
//                                format boot password.
//
//               
//    NtOwfPassword -- when SUCCEED, it will be filled with the logon user's 
//               Clear NT OWF Password. If the logon user's password is blank.
//               NtOwfPassword will be filled with NULL NT OWF Password.
//               no meaning when this API fails.
//               
//    NtPasswordPresent -- Meaningful only when the API succeeds. Indicate whether
//               the logon user's NT OWF Password present in registry or not.
//               TRUE - present in registry
//               
//               
//    NtPasswordNonNull -- When this API succeeds, indicates whether the clear
//               NT OWF Password is Null or not.
//               TRUE -- not NULL password.               
//
// 3. more information (including the algorithm and implementaion), 
//              please reference 
//              $(BASEDIR)\private\ds\src\newsam2\recovery\recovery.c
//
// 4. Return Values:
//
//      STATUS_SUCCESS
//      STATUS_SAM_NEED_BOOTKEY_PASSWORD
//      STATUS_SAM_NEED_BOOTKEY_FLOPPY
//      STATUS_NO_MEMORY
//      STATUS_INTERNAL_ERROR
//      STATUS_INVALID_PARAMETER
//      STATUS_INVALID_HANDLE
//      STATUS_NO_SUCH_USER
//      ...
//



NTSTATUS
SamRetrieveOwfPasswordUser(
    IN ULONG   Rid, 
    IN HANDLE  hSecurityRootKey,
    IN HANDLE  hSamRootKey, 
    IN HANDLE  hSystemRootKey, 
    IN PUNICODE_STRING BootKey OPTIONAL, 
    IN USHORT  BootKeyType OPTIONAL, 
    OUT PNT_OWF_PASSWORD NtOwfPassword, 
    OUT PBOOLEAN NtPasswordPresent, 
    OUT PBOOLEAN NtPasswordNonNull    
    );





// 
// Routine Description:
// 
//     This routine reads the SAM Account Domain infomation from SAM hive, passed
//     in through hSamRootKey, and returns the value of next available RID of 
//     this account domain.  
// 
// Parameters:
//
//     hSamRootKey - Handle of the Root of SAM hive
//
//             SAM hive is located in %windir%\system32\config, name is SAM
// 
//     pNextRid - Return the value of next available Rid if success. 
// 
// Return Values:
// 
//     STATUS_SUCCESS
//     or other error status code
// 
NTSTATUS
SamGetNextAvailableRid(
    IN HANDLE  hSamRootKey,
    OUT PULONG pNextRid
    );



//
// Routine Description:
// 
//     This routine queries the Account Domain's Fixed Length Attribute stored
//     in registry. Update it with the passed in NextRid value.
// 
// Parameters:
// 
//     hSamRootKey - Handle of the Root of the hive
//
//     NextRid - Set the domain next available rid to the passed in value
//
// Return Values:
//
NTSTATUS
SamSetNextAvailableRid(
    IN HANDLE  hSamRootKey,
    IN ULONG   NextRid
    );


                                        
#endif  // _RECOVERY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\samisrv.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    samisrv.h

Abstract:

    This file contain private routines for use by Trusted SAM clients
    which live in the same process as the SAM server.

    Included in these routines are services for freeing buffers returned
    by RPC server stub routines (SamrXxx() routines).

Author:

    Cliff Van Dyke (CliffV) 26-Feb-1992

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _SAMISRV_
#define _SAMISRV_

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Data types used by SAM and Netlogon for database replication            //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

typedef enum _SECURITY_DB_TYPE {
    SecurityDbSam = 1,
    SecurityDbLsa
} SECURITY_DB_TYPE, *PSECURITY_DB_TYPE;

//
// These structures are used to get and set private data.  Note that
// DataType must be the first field of every such structure.
//

typedef enum _SAMI_PRIVATE_DATA_TYPE {
    SamPrivateDataNextRid = 1,
    SamPrivateDataPassword
} SAMI_PRIVATE_DATA_TYPE, *PSAMI_PRIVATE_DATA_TYPE;


typedef struct _SAMI_PRIVATE_DATA_NEXTRID_TYPE {
    SAMI_PRIVATE_DATA_TYPE DataType;
    ULONG NextRid;
} SAMI_PRIVATE_DATA_NEXTRID_TYPE, *PSAMI_PRIVATE_DATA_NEXTRID_TYPE;

typedef struct _SAMI_PRIVATE_DATA_PASSWORD_TYPE {
    SAMI_PRIVATE_DATA_TYPE DataType;
    UNICODE_STRING CaseInsensitiveDbcs;
    ENCRYPTED_LM_OWF_PASSWORD CaseInsensitiveDbcsBuffer;
    UNICODE_STRING CaseSensitiveUnicode;
    ENCRYPTED_NT_OWF_PASSWORD CaseSensitiveUnicodeBuffer;
    UNICODE_STRING LmPasswordHistory;
    UNICODE_STRING NtPasswordHistory;
} SAMI_PRIVATE_DATA_PASSWORD_TYPE, *PSAMI_PRIVATE_DATA_PASSWORD_TYPE;


typedef struct _SAMP_UNICODE_STRING_RELATIVE {
    USHORT Length;
    USHORT MaximumLength;
    ULONG  Buffer; // note buffer is really an offset
} SAMP_UNICODE_STRING_RELATIVE , *PSAMP_UNICODE_STRING_RELATIVE;

typedef struct _SAMI_PRIVATE_DATA_PASSWORD_TYPE_RELATIVE {
    SAMI_PRIVATE_DATA_TYPE DataType;
    SAMP_UNICODE_STRING_RELATIVE CaseInsensitiveDbcs;
    ENCRYPTED_LM_OWF_PASSWORD    CaseInsensitiveDbcsBuffer;
    SAMP_UNICODE_STRING_RELATIVE CaseSensitiveUnicode;
    ENCRYPTED_NT_OWF_PASSWORD    CaseSensitiveUnicodeBuffer;
    SAMP_UNICODE_STRING_RELATIVE LmPasswordHistory;
    SAMP_UNICODE_STRING_RELATIVE NtPasswordHistory;
} SAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE, *PSAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE;

#define SAM_CLEARTEXT_CREDENTIAL_NAME L"CLEARTEXT"


NTSTATUS
SamISetPasswordInfoOnPdc(
    IN SAMPR_HANDLE SamDomainHandle,
    IN PUCHAR       OpaqueBuffer,
    IN ULONG        BufferLength
    );

NTSTATUS
SamIResetBadPwdCountOnPdc(
    IN SAMPR_HANDLE SamUserHandle
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                                                                          //
//       Flag Definitions for SamIGetUserLogonInformation                   //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define SAM_GET_MEMBERSHIPS_NO_GC        ((ULONG)0x00000001)
#define SAM_GET_MEMBERSHIPS_TWO_PHASE    ((ULONG)0x00000002)
#define SAM_GET_MEMBERSHIPS_MIXED_DOMAIN ((ULONG)0x00000004)
#define SAM_NO_MEMBERSHIPS               ((ULONG)0x00000008)
#define SAM_OPEN_BY_ALTERNATE_ID         ((ULONG)0x00000010)
#define SAM_OPEN_BY_UPN                  ((ULONG)0x00000020)
#define SAM_OPEN_BY_SPN                  ((ULONG)0x00000040)
#define SAM_OPEN_BY_SID                  ((ULONG)0x00000080)
#define SAM_OPEN_BY_GUID                 ((ULONG)0x00000100)
#define SAM_OPEN_BY_UPN_OR_ACCOUNTNAME   ((ULONG)0x00000200)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//   Data types used by SamIUpdateLogonStatistics                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
typedef enum _SAM_CLIENT_INFO_ENUM
{   
    SamClientNoInformation = 0,
    SamClientIpAddr        = 1

} SAM_CLIENT_INFO_TYPE, *PSAM_CLIENT_INFO_TYPE; 

typedef struct _SAM_CLIENT_INFO
{
    SAM_CLIENT_INFO_TYPE Type;
    union {
        ULONG IpAddr;  // corresponds to type SamClientIpAddr
    } Data;
} SAM_CLIENT_INFO, *PSAM_CLIENT_INFO;

typedef struct _SAM_LOGON_STATISTICS
{
    ULONG StatisticsToApply;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    LARGE_INTEGER LastLogon;
    LARGE_INTEGER LastLogoff;
    UNICODE_STRING Workstation;
    SAM_CLIENT_INFO ClientInfo;

} SAM_LOGON_STATISTICS, *PSAM_LOGON_STATISTICS;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//   Data types used by Reverse Membership Query Routines                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef struct _SID_AND_ATTRIBUTES_LIST {
    ULONG   Count;
    PSID_AND_ATTRIBUTES SidAndAttributes;
} SID_AND_ATTRIBUTES_LIST , *PSID_AND_ATTRIBUTES_LIST;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//   Data types used by Promotion/Demotion operations                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
//  These flags indicate what type of install
//
#define SAMP_PROMOTE_ENTERPRISE    ((ULONG)0x00000001)
#define SAMP_PROMOTE_DOMAIN        ((ULONG)0x00000002)
#define SAMP_PROMOTE_REPLICA       ((ULONG)0x00000004)

//
// When a new domain, these flags indicate how to seed the
// initial security pricipals in the domain
//
#define SAMP_PROMOTE_UPGRADE         ((ULONG)0x00000008)
#define SAMP_PROMOTE_MIGRATE         ((ULONG)0x00000010)
#define SAMP_PROMOTE_CREATE          ((ULONG)0x00000020)
#define SAMP_PROMOTE_ALLOW_ANON      ((ULONG)0x00000040)
#define SAMP_PROMOTE_DFLT_REPAIR_PWD ((ULONG)0x00000080)


//
// Flags for demote
//
#define SAMP_DEMOTE_STANDALONE     ((ULONG)0x00000040)
#define SAMP_DEMOTE_MEMBER         ((ULONG)0x00000080)

// unused
#define SAMP_DEMOTE_LAST_DOMAIN    ((ULONG)0x00000100)

#define SAMP_TEMP_UPGRADE          ((ULONG)0x00000200)

//
// This flag is not passed into SamIPromote; rather it is used
// to trigger new NT5 account creations on gui mode setup
// of NT5 to NT5 upgrades
//
#define SAMP_PROMOTE_INTERNAL_UPGRADE ((ULONG)0x00000400)




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// The following prototypes are usable throughout the process that SAM       //
// resides in.  This may include calls by LAN Manager code that is not       //
// part of SAM but is in the same process as SAM.                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SamIConnect(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE *ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient
    );

NTSTATUS
SamIAccountRestrictions(
    IN SAM_HANDLE UserHandle,
    IN PUNICODE_STRING LogonWorkstation,
    IN PUNICODE_STRING Workstations,
    IN PLOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    );

NTSTATUS
SamIUpdateLogonStatistics(
    IN SAM_HANDLE UserHandle,
    IN PSAM_LOGON_STATISTICS LogonStats
    );

NTSTATUS
SamICreateAccountByRid(
    IN SAMPR_HANDLE DomainHandle,
    IN SAM_ACCOUNT_TYPE AccountType,
    IN ULONG RelativeId,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT SAMPR_HANDLE *AccountHandle,
    OUT ULONG *ConflictingAccountRid
    );

NTSTATUS
SamIGetSerialNumberDomain(
    IN SAMPR_HANDLE DomainHandle,
    OUT PLARGE_INTEGER ModifiedCount,
    OUT PLARGE_INTEGER CreationTime
    );

NTSTATUS
SamISetSerialNumberDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PLARGE_INTEGER ModifiedCount,
    IN PLARGE_INTEGER CreationTime,
    IN BOOLEAN StartOfFullSync
    );


NTSTATUS
SamIGetPrivateData(
    IN SAMPR_HANDLE SamHandle,
    IN PSAMI_PRIVATE_DATA_TYPE PrivateDataType,
    OUT PBOOLEAN SensitiveData,
    OUT PULONG DataLength,
    OUT PVOID *Data
    );

NTSTATUS
SamISetPrivateData(
    IN SAMPR_HANDLE SamHandle,
    IN ULONG DataLength,
    IN PVOID Data
    );

NTSTATUS
SamISetAuditingInformation(
    IN PPOLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo
    );

NTSTATUS
SamINotifyDelta (
    IN SAMPR_HANDLE DomainHandle,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PUNICODE_STRING ObjectName,
    IN ULONG ReplicateImmediately,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    );

NTSTATUS
SamIEnumerateAccountRids(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG AccountTypesMask,
    IN  ULONG StartingRid,
    IN  ULONG PreferedMaximumLength,
    OUT PULONG ReturnCount,
    OUT PULONG *AccountRids
    );

NTSTATUS
SamIGetUserLogonInformation(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    );

NTSTATUS
SamIGetUserLogonInformationEx(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    IN  ULONG           WhichFields,
    OUT PSAMPR_USER_INFO_BUFFER * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    );

NTSTATUS
SamIGetUserLogonInformation2(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG   Flags,
    IN  PUNICODE_STRING AccountName,
    IN  ULONG           WhichFields,
    IN  ULONG           ExtendedFields,
    OUT PUSER_INTERNAL6_INFORMATION * Buffer,
    OUT PSID_AND_ATTRIBUTES_LIST ReverseMembership,
    OUT OPTIONAL SAMPR_HANDLE * UserHandle
    );

NTSTATUS
SamIGetResourceGroupMembershipsTransitive(
    IN SAMPR_HANDLE         DomainHandle,
    IN PSAMPR_PSID_ARRAY    SidArray,
    IN ULONG                Flags,
    OUT PSAMPR_PSID_ARRAY * Membership
    );


NTSTATUS
SamIGetAliasMembership(
    IN SAMPR_HANDLE DomainHandle,
    IN PSAMPR_PSID_ARRAY SidArray,
    OUT PSAMPR_ULONG_ARRAY Membership
    );


NTSTATUS
SamIOpenUserByAlternateId(
    IN SAMPR_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PUNICODE_STRING AlternateId,
    OUT SAMPR_HANDLE *UserHandle
    );

NTSTATUS
SamIOpenAccount(
    IN SAMPR_HANDLE         DomainHandle,
    IN ULONG                AccountRid,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    OUT SAMPR_HANDLE        *AccountHandle
    );

NTSTATUS
SamIChangePasswordForeignUser(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NewPassword,
    IN OPTIONAL HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess
    );

NTSTATUS
SamIChangePasswordForeignUser2(
    IN PSAM_CLIENT_INFO ClientInfo, OPTIONAL
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NewPassword,
    IN OPTIONAL HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess
    );

NTSTATUS
SamISetPasswordForeignUser(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NewPassword,
    IN HANDLE ClientToken
    );

NTSTATUS
SamISetPasswordForeignUser2(
    IN PSAM_CLIENT_INFO ClientInfo, OPTIONAL
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NewPassword,
    IN HANDLE ClientToken
    );

NTSTATUS
SamIPromote(
    IN  ULONG                        PromoteFlags,
    IN  PPOLICY_PRIMARY_DOMAIN_INFO  NewPrimaryDomainInfo  OPTIONAL,
    IN  PUNICODE_STRING              AdminPassword         OPTIONAL,
    IN  PUNICODE_STRING              SafeModeAdminPassword OPTIONAL
    );

NTSTATUS
SamIPromoteUndo(
    VOID
    );

NTSTATUS
SamIDemote(
    IN ULONG                        DemoteFlags,
    IN PPOLICY_ACCOUNT_DOMAIN_INFO  NewAccountDomainInfo,
    IN LPWSTR                       AdminPassword  OPTIONAL
    );

NTSTATUS
SamIDemoteUndo(
    VOID
    );

NTSTATUS
SamIReplaceDownlevelDatabase(
    IN PPOLICY_ACCOUNT_DOMAIN_INFO  NewAccountDomainInfo,
    IN LPWSTR                       NewAdminPassword,
    OUT ULONG                      *ExtendedWinError OPTIONAL
    );

NTSTATUS
SamILoadDownlevelDatabase(
    OUT ULONG *ExtendedWinError  OPTIONAL
    );

NTSTATUS
SamIUnLoadDownlevelDatabase(
    OUT ULONG *ExtendedWinError  OPTIONAL
    );

BOOLEAN
SamIMixedDomain(
  IN SAMPR_HANDLE DomainHandle
  );

NTSTATUS
SamIMixedDomain2(
  IN PSID DomainSid,
  OUT BOOLEAN * MixedDomain
  );

NTSTATUS
SamIDoFSMORoleChange(
  IN SAMPR_HANDLE DomainHandle
  );

NTSTATUS
SamINotifyRoleChange(
  IN PSID  DomainSid,
  IN DOMAIN_SERVER_ROLE NewRole
  );

NTSTATUS
SamIQueryServerRole(
  IN SAMPR_HANDLE DomainHandle,
  OUT DOMAIN_SERVER_ROLE *ServerRole
  );


NTSTATUS
SamIQueryServerRole2(
    IN PSID DomainSid,
    OUT DOMAIN_SERVER_ROLE *ServerRole
    );

NTSTATUS
SamISameSite(
  OUT BOOLEAN * result
  );

//
// Routines called by the NTDSA
//
typedef enum
{
    SampNotifySiteChanged = 0

} SAMP_NOTIFY_SERVER_CHANGE;

VOID
SamINotifyServerDelta(
    IN SAMP_NOTIFY_SERVER_CHANGE Change
    );


///////////////////////////////////////////////////////////////
//                                                           //
// The following functions are used to support in process    //
// client operations for upgrades from NT4.                  //
//                                                           //
///////////////////////////////////////////////////////////////

BOOLEAN
SamINT4UpgradeInProgress(
    VOID
    );

NTSTATUS
SamIEnumerateInterdomainTrustAccountsForUpgrade(
    IN OUT PULONG   EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG       PreferredMaximumLength,
    OUT PULONG     CountReturned
    );

NTSTATUS
SamIGetInterdomainTrustAccountPasswordsForUpgrade(
   IN ULONG AccountRid,
   OUT PUCHAR NtOwfPassword,
   OUT BOOLEAN *NtPasswordPresent,
   OUT PUCHAR LmOwfPassword,
   OUT BOOLEAN *LmPasswordPresent
   );

//
// Values to pass in as Options SamIGCLookup*
//

//
// Indicates to lookup by sid history as well
//
#define SAMP_LOOKUP_BY_SID_HISTORY     0x00000001

//
// Indicates to lookp by UPN as well
//
#define SAMP_LOOKUP_BY_UPN             0x00000002

//
// Values to be returned in Flags
//

//
// Indicates the Sid was resolved by Sid History
//
#define SAMP_FOUND_BY_SID_HISTORY      0x00000001

//
// Indicates the name passed in was the sam account name (UPN)
//
#define SAMP_FOUND_BY_SAM_ACCOUNT_NAME 0x00000002

//
// Indicates that entry was not resolved but does belong to an externally
// trusted forest
//
#define SAMP_FOUND_XFOREST_REF         0x00000004

NTSTATUS
SamIGCLookupSids(
    IN ULONG            cSids,
    IN PSID            *SidArray,
    IN ULONG            Options,
    OUT ULONG           *Flags,
    OUT SID_NAME_USE    *SidNameUse,
    OUT PSAMPR_RETURNED_USTRING_ARRAY Names
    );

NTSTATUS
SamIGCLookupNames(
    IN ULONG           cNames,
    IN PUNICODE_STRING Names,
    IN ULONG           Options,
    OUT ULONG           *Flags,
    OUT SID_NAME_USE  *SidNameUse,
    OUT PSAMPR_PSID_ARRAY *SidArray
    );

#ifdef __SECPKG_H__


NTSTATUS
SamIStorePrimaryCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PSECPKG_SUPPLEMENTAL_CRED Credentials
    );

NTSTATUS
SamIRetrievePrimaryCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PUNICODE_STRING PackageName,
    OUT PVOID * Credentials,
    OUT PULONG CredentialSize
    );

NTSTATUS
SamIStoreSupplementalCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PSECPKG_SUPPLEMENTAL_CRED Credentials
    );

NTSTATUS
SamIRetriveSupplementalCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PUNICODE_STRING PackageName,
    OUT PVOID * Credentials,
    OUT PULONG CredentialSize
    );

NTSTATUS
SamIRetriveAllSupplementalCredentials(
    IN SAMPR_HANDLE UserHandle,
    OUT PSECPKG_SUPPLEMENTAL_CRED * Credentials,
    OUT PULONG CredentialCount
    );
#endif

VOID
SamIFree_SAMPR_SR_SECURITY_DESCRIPTOR (
    PSAMPR_SR_SECURITY_DESCRIPTOR Source
    );

VOID
SamIFree_SAMPR_DOMAIN_INFO_BUFFER (
    PSAMPR_DOMAIN_INFO_BUFFER Source,
    DOMAIN_INFORMATION_CLASS Branch
    );

VOID
SamIFree_SAMPR_ENUMERATION_BUFFER (
    PSAMPR_ENUMERATION_BUFFER Source
    );

VOID
SamIFree_SAMPR_PSID_ARRAY (
    PSAMPR_PSID_ARRAY Source
    );

VOID
SamIFree_SAMPR_ULONG_ARRAY (
    PSAMPR_ULONG_ARRAY Source
    );

VOID
SamIFree_SAMPR_RETURNED_USTRING_ARRAY (
    PSAMPR_RETURNED_USTRING_ARRAY Source
    );

VOID
SamIFree_SAMPR_GROUP_INFO_BUFFER (
    PSAMPR_GROUP_INFO_BUFFER Source,
    GROUP_INFORMATION_CLASS Branch
    );

VOID
SamIFree_SAMPR_ALIAS_INFO_BUFFER (
    PSAMPR_ALIAS_INFO_BUFFER Source,
    ALIAS_INFORMATION_CLASS Branch
    );

VOID
SamIFree_SAMPR_GET_MEMBERS_BUFFER (
    PSAMPR_GET_MEMBERS_BUFFER Source
    );

VOID
SamIFree_SAMPR_USER_INFO_BUFFER (
    PSAMPR_USER_INFO_BUFFER Source,
    USER_INFORMATION_CLASS Branch
    );

VOID
SamIFree_SAMPR_GET_GROUPS_BUFFER (
    PSAMPR_GET_GROUPS_BUFFER Source
    );

VOID
SamIFree_SAMPR_DISPLAY_INFO_BUFFER (
    PSAMPR_DISPLAY_INFO_BUFFER Source,
    DOMAIN_DISPLAY_INFORMATION Branch
    );

VOID
SamIFree_UserInternal6Information (
   PUSER_INTERNAL6_INFORMATION  Source
   );

VOID
SamIFreeSidAndAttributesList(
    IN  PSID_AND_ATTRIBUTES_LIST List
    );

VOID
SamIFreeSidArray(
    IN  PSAMPR_PSID_ARRAY List
    );

VOID
SamIFreeVoid(
    IN  PVOID ptr
    );


BOOLEAN
SampUsingDsData();

BOOLEAN
SamIAmIGC();

typedef enum _SAM_PERF_COUNTER_TYPE {
    MsvLogonCounter,
    KerbServerContextCounter,
    KdcAsReqCounter,
    KdcTgsReqCounter
} SAM_PERF_COUNTER_TYPE, *PSAM_PERF_COUNTER_TYPE;

VOID
SamIIncrementPerformanceCounter(
    IN SAM_PERF_COUNTER_TYPE CounterType
    );

BOOLEAN SamIIsSetupInProgress(
          OUT BOOLEAN * fUpgrade
          );

BOOLEAN SamIIsDownlevelDcUpgrade();

NTSTATUS
SamIGetBootKeyInformation(
    IN SAMPR_HANDLE DomainHandle,
    OUT PSAMPR_BOOT_TYPE BootOptions
    );

NTSTATUS
SamIGetDefaultAdministratorName(
    OUT LPWSTR Name,  OPTIONAL
    IN OUT ULONG  *NameLength
    );

BOOLEAN
SamIIsExtendedSidMode(
    IN SAMPR_HANDLE DomainHandle
    );
    
NTSTATUS
SamINetLogonPing(
    IN  SAMPR_HANDLE    DomainHandle,
    IN  PUNICODE_STRING AccountName,
    OUT BOOLEAN         *AccountExists,
    OUT PULONG          UserAccountControl
    );

NTSTATUS
SamIUPNFromUserHandle(
    IN SAMPR_HANDLE UserHandle,
    OUT BOOLEAN     *UPNDefaulted,
    OUT PUNICODE_STRING UPN
    );

BOOLEAN
SamIIsRebootAfterPromotion(
    );

#endif // _SAMISRV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\samrpc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for samrpc.idl, samsrv.acf:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __samrpc_h__
#define __samrpc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "samimp.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __samr_INTERFACE_DEFINED__
#define __samr_INTERFACE_DEFINED__

/* interface samr */
/* [strict_context_handle][implicit_handle][unique][ms_union][version][uuid] */ 

typedef struct _RPC_UNICODE_STRING
    {
    USHORT Length;
    USHORT MaximumLength;
    /* [length_is][size_is] */ PWCH Buffer;
    } 	RPC_UNICODE_STRING;

typedef struct _RPC_UNICODE_STRING *PRPC_UNICODE_STRING;

typedef struct _RPC_CYPHER_DATA
    {
    ULONG Length;
    ULONG MaximumLength;
    /* [length_is][size_is] */ PCHAR Buffer;
    } 	RPC_CYPHER_DATA;

typedef struct _RPC_CYPHER_DATA *PRPC_CYPHER_DATA;

typedef struct _RPC_STRING
    {
    USHORT Length;
    USHORT MaximumLength;
    /* [length_is][size_is] */ PCHAR Buffer;
    } 	RPC_STRING;

typedef struct _RPC_STRING *PRPC_STRING;

typedef struct _RPC_STRING RPC_ANSI_STRING;

typedef struct _RPC_STRING *PRPC_ANSI_STRING;

typedef struct _RPC_SID
    {
    UCHAR Revision;
    UCHAR SubAuthorityCount;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    /* [size_is] */ ULONG SubAuthority[ 1 ];
    } 	RPC_SID;

typedef struct _RPC_SID *PRPC_SID;

typedef struct _RPC_SID **PPRPC_SID;

typedef /* [handle] */ LPWSTR PSAMPR_SERVER_NAME;

typedef /* [context_handle] */ PVOID SAMPR_HANDLE;

#define SAM_NETWORK_REVISION_1      (1)
#define SAM_NETWORK_REVISION_2      (2)
#define SAM_NETWORK_REVISION_3      (3)
#define SAM_NETWORK_REVISION_LATEST SAM_NETWORK_REVISION_3
#define SAM_CLIENT_PRE_NT5 SAM_NETWORK_REVISION_1
#define SAM_CLIENT_NT5     SAM_NETWORK_REVISION_2
#define SAM_CLIENT_LATEST  SAM_NETWORK_REVISION_LATEST
#define SAM_EXTENDED_SID_DOMAIN          0x00000001
#define SAM_EXTENDED_SID_DOMAIN_COMPAT_1 0x00000002
#define SAM_EXTENDED_SID_DOMAIN_COMPAT_2 0x00000004
typedef struct _SAMPR_RID_ENUMERATION
    {
    ULONG RelativeId;
    RPC_UNICODE_STRING Name;
    } 	SAMPR_RID_ENUMERATION;

typedef struct _SAMPR_RID_ENUMERATION *PSAMPR_RID_ENUMERATION;

typedef struct _SAMPR_SID_ENUMERATION
    {
    PSID Sid;
    RPC_UNICODE_STRING Name;
    } 	SAMPR_SID_ENUMERATION;

typedef struct _SAMPR_SID_ENUMERATION *PSAMPR_SID_ENUMERATION;

typedef struct _SAMPR_ENUMERATION_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_RID_ENUMERATION Buffer;
    } 	SAMPR_ENUMERATION_BUFFER;

typedef struct _SAMPR_ENUMERATION_BUFFER *PSAMPR_ENUMERATION_BUFFER;

typedef struct _SAMPR_SR_SECURITY_DESCRIPTOR
    {
    ULONG Length;
    /* [size_is] */ PUCHAR SecurityDescriptor;
    } 	SAMPR_SR_SECURITY_DESCRIPTOR;

typedef struct _SAMPR_SR_SECURITY_DESCRIPTOR *PSAMPR_SR_SECURITY_DESCRIPTOR;

typedef struct _SAMPR_GET_GROUPS_BUFFER
    {
    ULONG MembershipCount;
    /* [size_is] */ PGROUP_MEMBERSHIP Groups;
    } 	SAMPR_GET_GROUPS_BUFFER;

typedef struct _SAMPR_GET_GROUPS_BUFFER *PSAMPR_GET_GROUPS_BUFFER;

typedef struct _SAMPR_GET_MEMBERS_BUFFER
    {
    ULONG MemberCount;
    /* [size_is] */ PULONG Members;
    /* [size_is] */ PULONG Attributes;
    } 	SAMPR_GET_MEMBERS_BUFFER;

typedef struct _SAMPR_GET_MEMBERS_BUFFER *PSAMPR_GET_MEMBERS_BUFFER;

typedef struct _SAMPR_LOGON_HOURS
    {
    USHORT UnitsPerWeek;
    /* [length_is][size_is] */ PUCHAR LogonHours;
    } 	SAMPR_LOGON_HOURS;

typedef struct _SAMPR_LOGON_HOURS *PSAMPR_LOGON_HOURS;

typedef struct _SAMPR_ULONG_ARRAY
    {
    ULONG Count;
    /* [size_is] */ ULONG *Element;
    } 	SAMPR_ULONG_ARRAY;

typedef struct _SAMPR_ULONG_ARRAY *PSAMPR_ULONG_ARRAY;

typedef struct _SAMPR_SID_INFORMATION
    {
    PRPC_SID SidPointer;
    } 	SAMPR_SID_INFORMATION;

typedef /* [allocate] */ struct _SAMPR_SID_INFORMATION *PSAMPR_SID_INFORMATION;

typedef struct _SAMPR_PSID_ARRAY
    {
    ULONG Count;
    /* [size_is] */ PSAMPR_SID_INFORMATION Sids;
    } 	SAMPR_PSID_ARRAY;

typedef struct _SAMPR_PSID_ARRAY *PSAMPR_PSID_ARRAY;

typedef struct _SAMPR_UNICODE_STRING_ARRAY
    {
    ULONG Count;
    /* [size_is] */ RPC_UNICODE_STRING *Element;
    } 	SAMPR_UNICODE_STRING_ARRAY;

typedef struct _SAMPR_UNICODE_STRING_ARRAY *PSAMPR_UNICODE_STRING_ARRAY;

typedef RPC_UNICODE_STRING SAMPR_RETURNED_STRING;

typedef RPC_UNICODE_STRING *PSAMPR_RETURNED_STRING;

typedef STRING SAMPR_RETURNED_NORMAL_STRING;

typedef STRING *PSAMPR_RETURNED_NORMAL_STRING;

typedef struct _SAMPR_RETURNED_USTRING_ARRAY
    {
    ULONG Count;
    /* [size_is] */ PSAMPR_RETURNED_STRING Element;
    } 	SAMPR_RETURNED_USTRING_ARRAY;

typedef struct _SAMPR_RETURNED_USTRING_ARRAY *PSAMPR_RETURNED_USTRING_ARRAY;

typedef struct _SAMPR_REVISION_INFO_V1
    {
    ULONG Revision;
    ULONG SupportedFeatures;
    } 	SAMPR_REVISION_INFO_V1;

typedef struct _SAMPR_REVISION_INFO_V1 *PSAMPR_REVISION_INFO_V1;

typedef /* [public][public][public][switch_type] */ union __MIDL_samr_0001
    {
    /* [case()] */ SAMPR_REVISION_INFO_V1 V1;
    } 	SAMPR_REVISION_INFO;

typedef /* [switch_type] */ union __MIDL_samr_0001 *PSAMPR_REVISION_INFO;


#pragma pack(4)
typedef struct _SAMPR_DOMAIN_GENERAL_INFORMATION
    {
    OLD_LARGE_INTEGER ForceLogoff;
    RPC_UNICODE_STRING OemInformation;
    RPC_UNICODE_STRING DomainName;
    RPC_UNICODE_STRING ReplicaSourceNodeName;
    OLD_LARGE_INTEGER DomainModifiedCount;
    ULONG DomainServerState;
    ULONG DomainServerRole;
    BOOLEAN UasCompatibilityRequired;
    ULONG UserCount;
    ULONG GroupCount;
    ULONG AliasCount;
    } 	SAMPR_DOMAIN_GENERAL_INFORMATION;

typedef struct _SAMPR_DOMAIN_GENERAL_INFORMATION *PSAMPR_DOMAIN_GENERAL_INFORMATION;


#pragma pack()

#pragma pack(4)
typedef struct _SAMPR_DOMAIN_GENERAL_INFORMATION2
    {
    SAMPR_DOMAIN_GENERAL_INFORMATION I1;
    LARGE_INTEGER LockoutDuration;
    LARGE_INTEGER LockoutObservationWindow;
    USHORT LockoutThreshold;
    } 	SAMPR_DOMAIN_GENERAL_INFORMATION2;

typedef struct _SAMPR_DOMAIN_GENERAL_INFORMATION2 *PSAMPR_DOMAIN_GENERAL_INFORMATION2;


#pragma pack()
typedef struct _SAMPR_DOMAIN_OEM_INFORMATION
    {
    RPC_UNICODE_STRING OemInformation;
    } 	SAMPR_DOMAIN_OEM_INFORMATION;

typedef struct _SAMPR_DOMAIN_OEM_INFORMATION *PSAMPR_DOMAIN_OEM_INFORMATION;

typedef struct _SAMPR_DOMAIN_NAME_INFORMATION
    {
    RPC_UNICODE_STRING DomainName;
    } 	SAMPR_DOMAIN_NAME_INFORMATION;

typedef struct _SAMPR_DOMAIN_NAME_INFORMATION *PSAMPR_DOMAIN_NAME_INFORMATION;

typedef struct SAMPR_DOMAIN_REPLICATION_INFORMATION
    {
    RPC_UNICODE_STRING ReplicaSourceNodeName;
    } 	SAMPR_DOMAIN_REPLICATION_INFORMATION;

typedef struct SAMPR_DOMAIN_REPLICATION_INFORMATION *PSAMPR_DOMAIN_REPLICATION_INFORMATION;

typedef struct _SAMPR_DOMAIN_LOCKOUT_INFORMATION
    {
    LARGE_INTEGER LockoutDuration;
    LARGE_INTEGER LockoutObservationWindow;
    USHORT LockoutThreshold;
    } 	SAMPR_DOMAIN_LOCKOUT_INFORMATION;

typedef struct _SAMPR_DOMAIN_LOCKOUT_INFORMATION *PSAMPR_DOMAIN_LOCKOUT_INFORMATION;

typedef /* [switch_type] */ union _SAMPR_DOMAIN_INFO_BUFFER
    {
    /* [case()] */ DOMAIN_PASSWORD_INFORMATION Password;
    /* [case()] */ SAMPR_DOMAIN_GENERAL_INFORMATION General;
    /* [case()] */ DOMAIN_LOGOFF_INFORMATION Logoff;
    /* [case()] */ SAMPR_DOMAIN_OEM_INFORMATION Oem;
    /* [case()] */ SAMPR_DOMAIN_NAME_INFORMATION Name;
    /* [case()] */ DOMAIN_SERVER_ROLE_INFORMATION Role;
    /* [case()] */ SAMPR_DOMAIN_REPLICATION_INFORMATION Replication;
    /* [case()] */ DOMAIN_MODIFIED_INFORMATION Modified;
    /* [case()] */ DOMAIN_STATE_INFORMATION State;
    /* [case()] */ SAMPR_DOMAIN_GENERAL_INFORMATION2 General2;
    /* [case()] */ SAMPR_DOMAIN_LOCKOUT_INFORMATION Lockout;
    /* [case()] */ DOMAIN_MODIFIED_INFORMATION2 Modified2;
    } 	SAMPR_DOMAIN_INFO_BUFFER;

typedef /* [switch_type] */ union _SAMPR_DOMAIN_INFO_BUFFER *PSAMPR_DOMAIN_INFO_BUFFER;

typedef struct _SAMPR_GROUP_GENERAL_INFORMATION
    {
    RPC_UNICODE_STRING Name;
    ULONG Attributes;
    ULONG MemberCount;
    RPC_UNICODE_STRING AdminComment;
    } 	SAMPR_GROUP_GENERAL_INFORMATION;

typedef struct _SAMPR_GROUP_GENERAL_INFORMATION *PSAMPR_GROUP_GENERAL_INFORMATION;

typedef struct _SAMPR_GROUP_NAME_INFORMATION
    {
    RPC_UNICODE_STRING Name;
    } 	SAMPR_GROUP_NAME_INFORMATION;

typedef struct _SAMPR_GROUP_NAME_INFORMATION *PSAMPR_GROUP_NAME_INFORMATION;

typedef struct _SAMPR_GROUP_ADM_COMMENT_INFORMATION
    {
    RPC_UNICODE_STRING AdminComment;
    } 	SAMPR_GROUP_ADM_COMMENT_INFORMATION;

typedef struct _SAMPR_GROUP_ADM_COMMENT_INFORMATION *PSAMPR_GROUP_ADM_COMMENT_INFORMATION;

typedef /* [switch_type] */ union _SAMPR_GROUP_INFO_BUFFER
    {
    /* [case()] */ SAMPR_GROUP_GENERAL_INFORMATION General;
    /* [case()] */ SAMPR_GROUP_NAME_INFORMATION Name;
    /* [case()] */ GROUP_ATTRIBUTE_INFORMATION Attribute;
    /* [case()] */ SAMPR_GROUP_ADM_COMMENT_INFORMATION AdminComment;
    /* [case()] */ SAMPR_GROUP_GENERAL_INFORMATION DoNotUse;
    } 	SAMPR_GROUP_INFO_BUFFER;

typedef /* [switch_type] */ union _SAMPR_GROUP_INFO_BUFFER *PSAMPR_GROUP_INFO_BUFFER;

typedef struct _SAMPR_ALIAS_GENERAL_INFORMATION
    {
    RPC_UNICODE_STRING Name;
    ULONG MemberCount;
    RPC_UNICODE_STRING AdminComment;
    } 	SAMPR_ALIAS_GENERAL_INFORMATION;

typedef struct _SAMPR_ALIAS_GENERAL_INFORMATION *PSAMPR_ALIAS_GENERAL_INFORMATION;

typedef struct _SAMPR_ALIAS_NAME_INFORMATION
    {
    RPC_UNICODE_STRING Name;
    } 	SAMPR_ALIAS_NAME_INFORMATION;

typedef struct _SAMPR_ALIAS_NAME_INFORMATION *PSAMPR_ALIAS_NAME_INFORMATION;

typedef struct _SAMPR_ALIAS_ADM_COMMENT_INFORMATION
    {
    RPC_UNICODE_STRING AdminComment;
    } 	SAMPR_ALIAS_ADM_COMMENT_INFORMATION;

typedef struct _SAMPR_ALIAS_ADM_COMMENT_INFORMATION *PSAMPR_ALIAS_ADM_COMMENT_INFORMATION;

typedef /* [switch_type] */ union _SAMPR_ALIAS_INFO_BUFFER
    {
    /* [case()] */ SAMPR_ALIAS_GENERAL_INFORMATION General;
    /* [case()] */ SAMPR_ALIAS_NAME_INFORMATION Name;
    /* [case()] */ SAMPR_ALIAS_ADM_COMMENT_INFORMATION AdminComment;
    } 	SAMPR_ALIAS_INFO_BUFFER;

typedef /* [switch_type] */ union _SAMPR_ALIAS_INFO_BUFFER *PSAMPR_ALIAS_INFO_BUFFER;


#pragma pack(4)
typedef struct _SAMPR_USER_ALL_INFORMATION
    {
    OLD_LARGE_INTEGER LastLogon;
    OLD_LARGE_INTEGER LastLogoff;
    OLD_LARGE_INTEGER PasswordLastSet;
    OLD_LARGE_INTEGER AccountExpires;
    OLD_LARGE_INTEGER PasswordCanChange;
    OLD_LARGE_INTEGER PasswordMustChange;
    RPC_UNICODE_STRING UserName;
    RPC_UNICODE_STRING FullName;
    RPC_UNICODE_STRING HomeDirectory;
    RPC_UNICODE_STRING HomeDirectoryDrive;
    RPC_UNICODE_STRING ScriptPath;
    RPC_UNICODE_STRING ProfilePath;
    RPC_UNICODE_STRING AdminComment;
    RPC_UNICODE_STRING WorkStations;
    RPC_UNICODE_STRING UserComment;
    RPC_UNICODE_STRING Parameters;
    RPC_UNICODE_STRING LmOwfPassword;
    RPC_UNICODE_STRING NtOwfPassword;
    RPC_UNICODE_STRING PrivateData;
    SAMPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor;
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG UserAccountControl;
    ULONG WhichFields;
    SAMPR_LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    USHORT CountryCode;
    USHORT CodePage;
    BOOLEAN LmPasswordPresent;
    BOOLEAN NtPasswordPresent;
    BOOLEAN PasswordExpired;
    BOOLEAN PrivateDataSensitive;
    } 	SAMPR_USER_ALL_INFORMATION;

typedef struct _SAMPR_USER_ALL_INFORMATION *PSAMPR_USER_ALL_INFORMATION;


#pragma pack()

#pragma pack(4)
typedef struct _SAMPR_USER_INTERNAL3_INFORMATION
    {
    SAMPR_USER_ALL_INFORMATION I1;
    LARGE_INTEGER LastBadPasswordTime;
    } 	SAMPR_USER_INTERNAL3_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL3_INFORMATION *PSAMPR_USER_INTERNAL3_INFORMATION;


#pragma pack()
typedef struct _SAMPR_USER_GENERAL_INFORMATION
    {
    RPC_UNICODE_STRING UserName;
    RPC_UNICODE_STRING FullName;
    ULONG PrimaryGroupId;
    RPC_UNICODE_STRING AdminComment;
    RPC_UNICODE_STRING UserComment;
    } 	SAMPR_USER_GENERAL_INFORMATION;

typedef struct _SAMPR_USER_GENERAL_INFORMATION *PSAMPR_USER_GENERAL_INFORMATION;

typedef struct _SAMPR_USER_PREFERENCES_INFORMATION
    {
    RPC_UNICODE_STRING UserComment;
    RPC_UNICODE_STRING Reserved1;
    USHORT CountryCode;
    USHORT CodePage;
    } 	SAMPR_USER_PREFERENCES_INFORMATION;

typedef struct _SAMPR_USER_PREFERENCES_INFORMATION *PSAMPR_USER_PREFERENCES_INFORMATION;

typedef struct _SAMPR_USER_PARAMETERS_INFORMATION
    {
    RPC_UNICODE_STRING Parameters;
    } 	SAMPR_USER_PARAMETERS_INFORMATION;

typedef struct _SAMPR_USER_PARAMETERS_INFORMATION *PSAMPR_USER_PARAMETERS_INFORMATION;


#pragma pack(4)
typedef struct _SAMPR_USER_LOGON_INFORMATION
    {
    RPC_UNICODE_STRING UserName;
    RPC_UNICODE_STRING FullName;
    ULONG UserId;
    ULONG PrimaryGroupId;
    RPC_UNICODE_STRING HomeDirectory;
    RPC_UNICODE_STRING HomeDirectoryDrive;
    RPC_UNICODE_STRING ScriptPath;
    RPC_UNICODE_STRING ProfilePath;
    RPC_UNICODE_STRING WorkStations;
    OLD_LARGE_INTEGER LastLogon;
    OLD_LARGE_INTEGER LastLogoff;
    OLD_LARGE_INTEGER PasswordLastSet;
    OLD_LARGE_INTEGER PasswordCanChange;
    OLD_LARGE_INTEGER PasswordMustChange;
    SAMPR_LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    ULONG UserAccountControl;
    } 	SAMPR_USER_LOGON_INFORMATION;

typedef struct _SAMPR_USER_LOGON_INFORMATION *PSAMPR_USER_LOGON_INFORMATION;


#pragma pack()

#pragma pack(4)
typedef struct _SAMPR_USER_ACCOUNT_INFORMATION
    {
    RPC_UNICODE_STRING UserName;
    RPC_UNICODE_STRING FullName;
    ULONG UserId;
    ULONG PrimaryGroupId;
    RPC_UNICODE_STRING HomeDirectory;
    RPC_UNICODE_STRING HomeDirectoryDrive;
    RPC_UNICODE_STRING ScriptPath;
    RPC_UNICODE_STRING ProfilePath;
    RPC_UNICODE_STRING AdminComment;
    RPC_UNICODE_STRING WorkStations;
    OLD_LARGE_INTEGER LastLogon;
    OLD_LARGE_INTEGER LastLogoff;
    SAMPR_LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    OLD_LARGE_INTEGER PasswordLastSet;
    OLD_LARGE_INTEGER AccountExpires;
    ULONG UserAccountControl;
    } 	SAMPR_USER_ACCOUNT_INFORMATION;

typedef struct _SAMPR_USER_ACCOUNT_INFORMATION *PSAMPR_USER_ACCOUNT_INFORMATION;


#pragma pack()
typedef struct _SAMPR_USER_A_NAME_INFORMATION
    {
    RPC_UNICODE_STRING UserName;
    } 	SAMPR_USER_A_NAME_INFORMATION;

typedef struct _SAMPR_USER_A_NAME_INFORMATION *PSAMPR_USER_A_NAME_INFORMATION;

typedef struct _SAMPR_USER_F_NAME_INFORMATION
    {
    RPC_UNICODE_STRING FullName;
    } 	SAMPR_USER_F_NAME_INFORMATION;

typedef struct _SAMPR_USER_F_NAME_INFORMATION *PSAMPR_USER_F_NAME_INFORMATION;

typedef struct _SAMPR_USER_NAME_INFORMATION
    {
    RPC_UNICODE_STRING UserName;
    RPC_UNICODE_STRING FullName;
    } 	SAMPR_USER_NAME_INFORMATION;

typedef struct _SAMPR_USER_NAME_INFORMATION *PSAMPR_USER_NAME_INFORMATION;

typedef struct _SAMPR_USER_HOME_INFORMATION
    {
    RPC_UNICODE_STRING HomeDirectory;
    RPC_UNICODE_STRING HomeDirectoryDrive;
    } 	SAMPR_USER_HOME_INFORMATION;

typedef struct _SAMPR_USER_HOME_INFORMATION *PSAMPR_USER_HOME_INFORMATION;

typedef struct _SAMPR_USER_SCRIPT_INFORMATION
    {
    RPC_UNICODE_STRING ScriptPath;
    } 	SAMPR_USER_SCRIPT_INFORMATION;

typedef struct _SAMPR_USER_SCRIPT_INFORMATION *PSAMPR_USER_SCRIPT_INFORMATION;

typedef struct _SAMPR_USER_PROFILE_INFORMATION
    {
    RPC_UNICODE_STRING ProfilePath;
    } 	SAMPR_USER_PROFILE_INFORMATION;

typedef struct _SAMPR_USER_PROFILE_INFORMATION *PSAMPR_USER_PROFILE_INFORMATION;

typedef struct _SAMPR_USER_ADMIN_COMMENT_INFORMATION
    {
    RPC_UNICODE_STRING AdminComment;
    } 	SAMPR_USER_ADMIN_COMMENT_INFORMATION;

typedef struct _SAMPR_USER_ADMIN_COMMENT_INFORMATION *PSAMPR_USER_ADMIN_COMMENT_INFORMATION;

typedef struct _SAMPR_USER_WORKSTATIONS_INFORMATION
    {
    RPC_UNICODE_STRING WorkStations;
    } 	SAMPR_USER_WORKSTATIONS_INFORMATION;

typedef struct _SAMPR_USER_WORKSTATIONS_INFORMATION *PSAMPR_USER_WORKSTATIONS_INFORMATION;

typedef struct _SAMPR_USER_LOGON_HOURS_INFORMATION
    {
    SAMPR_LOGON_HOURS LogonHours;
    } 	SAMPR_USER_LOGON_HOURS_INFORMATION;

typedef struct _SAMPR_USER_LOGON_HOURS_INFORMATION *PSAMPR_USER_LOGON_HOURS_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL1_INFORMATION
    {
    ENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword;
    ENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword;
    BOOLEAN NtPasswordPresent;
    BOOLEAN LmPasswordPresent;
    BOOLEAN PasswordExpired;
    } 	SAMPR_USER_INTERNAL1_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL1_INFORMATION *PSAMPR_USER_INTERNAL1_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL4_INFORMATION
    {
    SAMPR_USER_ALL_INFORMATION I1;
    SAMPR_ENCRYPTED_USER_PASSWORD UserPassword;
    } 	SAMPR_USER_INTERNAL4_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL4_INFORMATION *PSAMPR_USER_INTERNAL4_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL4_INFORMATION_NEW
    {
    SAMPR_USER_ALL_INFORMATION I1;
    SAMPR_ENCRYPTED_USER_PASSWORD_NEW UserPassword;
    } 	SAMPR_USER_INTERNAL4_INFORMATION_NEW;

typedef struct _SAMPR_USER_INTERNAL4_INFORMATION_NEW *PSAMPR_USER_INTERNAL4_INFORMATION_NEW;

typedef struct _SAMPR_USER_INTERNAL5_INFORMATION
    {
    SAMPR_ENCRYPTED_USER_PASSWORD UserPassword;
    BOOLEAN PasswordExpired;
    } 	SAMPR_USER_INTERNAL5_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL5_INFORMATION *PSAMPR_USER_INTERNAL5_INFORMATION;

typedef struct _SAMPR_USER_INTERNAL5_INFORMATION_NEW
    {
    SAMPR_ENCRYPTED_USER_PASSWORD_NEW UserPassword;
    BOOLEAN PasswordExpired;
    } 	SAMPR_USER_INTERNAL5_INFORMATION_NEW;

typedef struct _SAMPR_USER_INTERNAL5_INFORMATION_NEW *PSAMPR_USER_INTERNAL5_INFORMATION_NEW;

typedef /* [switch_type] */ union _SAMPR_USER_INFO_BUFFER
    {
    /* [case()] */ SAMPR_USER_GENERAL_INFORMATION General;
    /* [case()] */ SAMPR_USER_PREFERENCES_INFORMATION Preferences;
    /* [case()] */ SAMPR_USER_LOGON_INFORMATION Logon;
    /* [case()] */ SAMPR_USER_LOGON_HOURS_INFORMATION LogonHours;
    /* [case()] */ SAMPR_USER_ACCOUNT_INFORMATION Account;
    /* [case()] */ SAMPR_USER_NAME_INFORMATION Name;
    /* [case()] */ SAMPR_USER_A_NAME_INFORMATION AccountName;
    /* [case()] */ SAMPR_USER_F_NAME_INFORMATION FullName;
    /* [case()] */ USER_PRIMARY_GROUP_INFORMATION PrimaryGroup;
    /* [case()] */ SAMPR_USER_HOME_INFORMATION Home;
    /* [case()] */ SAMPR_USER_SCRIPT_INFORMATION Script;
    /* [case()] */ SAMPR_USER_PROFILE_INFORMATION Profile;
    /* [case()] */ SAMPR_USER_ADMIN_COMMENT_INFORMATION AdminComment;
    /* [case()] */ SAMPR_USER_WORKSTATIONS_INFORMATION WorkStations;
    /* [case()] */ USER_CONTROL_INFORMATION Control;
    /* [case()] */ USER_EXPIRES_INFORMATION Expires;
    /* [case()] */ SAMPR_USER_INTERNAL1_INFORMATION Internal1;
    /* [case()] */ USER_INTERNAL2_INFORMATION Internal2;
    /* [case()] */ SAMPR_USER_PARAMETERS_INFORMATION Parameters;
    /* [case()] */ SAMPR_USER_ALL_INFORMATION All;
    /* [case()] */ SAMPR_USER_INTERNAL3_INFORMATION Internal3;
    /* [case()] */ SAMPR_USER_INTERNAL4_INFORMATION Internal4;
    /* [case()] */ SAMPR_USER_INTERNAL5_INFORMATION Internal5;
    /* [case()] */ SAMPR_USER_INTERNAL4_INFORMATION_NEW Internal4New;
    /* [case()] */ SAMPR_USER_INTERNAL5_INFORMATION_NEW Internal5New;
    } 	SAMPR_USER_INFO_BUFFER;

typedef /* [switch_type] */ union _SAMPR_USER_INFO_BUFFER *PSAMPR_USER_INFO_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_USER
    {
    ULONG Index;
    ULONG Rid;
    ULONG AccountControl;
    SAMPR_RETURNED_STRING LogonName;
    SAMPR_RETURNED_STRING AdminComment;
    SAMPR_RETURNED_STRING FullName;
    } 	SAMPR_DOMAIN_DISPLAY_USER;

typedef struct _SAMPR_DOMAIN_DISPLAY_USER *PSAMPR_DOMAIN_DISPLAY_USER;

typedef struct _SAMPR_DOMAIN_DISPLAY_MACHINE
    {
    ULONG Index;
    ULONG Rid;
    ULONG AccountControl;
    SAMPR_RETURNED_STRING Machine;
    SAMPR_RETURNED_STRING Comment;
    } 	SAMPR_DOMAIN_DISPLAY_MACHINE;

typedef struct _SAMPR_DOMAIN_DISPLAY_MACHINE *PSAMPR_DOMAIN_DISPLAY_MACHINE;

typedef struct _SAMPR_DOMAIN_DISPLAY_GROUP
    {
    ULONG Index;
    ULONG Rid;
    ULONG Attributes;
    SAMPR_RETURNED_STRING Group;
    SAMPR_RETURNED_STRING Comment;
    } 	SAMPR_DOMAIN_DISPLAY_GROUP;

typedef struct _SAMPR_DOMAIN_DISPLAY_GROUP *PSAMPR_DOMAIN_DISPLAY_GROUP;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_USER
    {
    ULONG Index;
    SAMPR_RETURNED_NORMAL_STRING OemUser;
    } 	SAMPR_DOMAIN_DISPLAY_OEM_USER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_USER *PSAMPR_DOMAIN_DISPLAY_OEM_USER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_GROUP
    {
    ULONG Index;
    SAMPR_RETURNED_NORMAL_STRING OemGroup;
    } 	SAMPR_DOMAIN_DISPLAY_OEM_GROUP;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_GROUP *PSAMPR_DOMAIN_DISPLAY_OEM_GROUP;

typedef struct _SAMPR_DOMAIN_DISPLAY_USER_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_DOMAIN_DISPLAY_USER Buffer;
    } 	SAMPR_DOMAIN_DISPLAY_USER_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_USER_BUFFER *PSAMPR_DOMAIN_DISPLAY_USER_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_DOMAIN_DISPLAY_MACHINE Buffer;
    } 	SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER *PSAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_DOMAIN_DISPLAY_GROUP Buffer;
    } 	SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER *PSAMPR_DOMAIN_DISPLAY_GROUP_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_DOMAIN_DISPLAY_OEM_USER Buffer;
    } 	SAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER *PSAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER
    {
    ULONG EntriesRead;
    /* [size_is] */ PSAMPR_DOMAIN_DISPLAY_OEM_GROUP Buffer;
    } 	SAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER;

typedef struct _SAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER *PSAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER;

typedef /* [switch_type] */ union _SAMPR_DISPLAY_INFO_BUFFER
    {
    /* [case()] */ SAMPR_DOMAIN_DISPLAY_USER_BUFFER UserInformation;
    /* [case()] */ SAMPR_DOMAIN_DISPLAY_MACHINE_BUFFER MachineInformation;
    /* [case()] */ SAMPR_DOMAIN_DISPLAY_GROUP_BUFFER GroupInformation;
    /* [case()] */ SAMPR_DOMAIN_DISPLAY_OEM_USER_BUFFER OemUserInformation;
    /* [case()] */ SAMPR_DOMAIN_DISPLAY_OEM_GROUP_BUFFER OemGroupInformation;
    } 	SAMPR_DISPLAY_INFO_BUFFER;

typedef /* [switch_type] */ union _SAMPR_DISPLAY_INFO_BUFFER *PSAMPR_DISPLAY_INFO_BUFFER;

NTSTATUS SamrConnect( 
    /* [unique][in] */ PSAMPR_SERVER_NAME ServerName,
    /* [out] */ SAMPR_HANDLE *ServerHandle,
    /* [in] */ ACCESS_MASK DesiredAccess);

NTSTATUS SamrCloseHandle( 
    /* [out][in] */ SAMPR_HANDLE *SamHandle);

NTSTATUS SamrSetSecurityObject( 
    /* [in] */ SAMPR_HANDLE ObjectHandle,
    /* [in] */ SECURITY_INFORMATION SecurityInformation,
    /* [in] */ PSAMPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor);

NTSTATUS SamrQuerySecurityObject( 
    /* [in] */ SAMPR_HANDLE ObjectHandle,
    /* [in] */ SECURITY_INFORMATION SecurityInformation,
    /* [out] */ PSAMPR_SR_SECURITY_DESCRIPTOR *SecurityDescriptor);

NTSTATUS SamrShutdownSamServer( 
    /* [in] */ SAMPR_HANDLE ServerHandle);

NTSTATUS SamrLookupDomainInSamServer( 
    /* [in] */ SAMPR_HANDLE ServerHandle,
    /* [in] */ PRPC_UNICODE_STRING Name,
    /* [out] */ PRPC_SID *DomainId);

NTSTATUS SamrEnumerateDomainsInSamServer( 
    /* [in] */ SAMPR_HANDLE ServerHandle,
    /* [out][in] */ PSAM_ENUMERATE_HANDLE EnumerationContext,
    /* [out] */ PSAMPR_ENUMERATION_BUFFER *Buffer,
    /* [in] */ ULONG PreferedMaximumLength,
    /* [out] */ PULONG CountReturned);

NTSTATUS SamrOpenDomain( 
    /* [in] */ SAMPR_HANDLE ServerHandle,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [in] */ PRPC_SID DomainId,
    /* [out] */ SAMPR_HANDLE *DomainHandle);

NTSTATUS SamrQueryInformationDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_INFORMATION_CLASS DomainInformationClass,
    /* [switch_is][out] */ PSAMPR_DOMAIN_INFO_BUFFER *Buffer);

NTSTATUS SamrSetInformationDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_INFORMATION_CLASS DomainInformationClass,
    /* [switch_is][in] */ PSAMPR_DOMAIN_INFO_BUFFER DomainInformation);

NTSTATUS SamrCreateGroupInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PRPC_UNICODE_STRING Name,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ SAMPR_HANDLE *GroupHandle,
    /* [out] */ PULONG RelativeId);

NTSTATUS SamrEnumerateGroupsInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [out][in] */ PSAM_ENUMERATE_HANDLE EnumerationContext,
    /* [out] */ PSAMPR_ENUMERATION_BUFFER *Buffer,
    /* [in] */ ULONG PreferedMaximumLength,
    /* [out] */ PULONG CountReturned);

NTSTATUS SamrCreateUserInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PRPC_UNICODE_STRING Name,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ SAMPR_HANDLE *UserHandle,
    /* [out] */ PULONG RelativeId);

NTSTATUS SamrEnumerateUsersInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [out][in] */ PSAM_ENUMERATE_HANDLE EnumerationContext,
    /* [in] */ ULONG UserAccountControl,
    /* [out] */ PSAMPR_ENUMERATION_BUFFER *Buffer,
    /* [in] */ ULONG PreferedMaximumLength,
    /* [out] */ PULONG CountReturned);

NTSTATUS SamrCreateAliasInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PRPC_UNICODE_STRING AccountName,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ SAMPR_HANDLE *AliasHandle,
    /* [out] */ PULONG RelativeId);

NTSTATUS SamrEnumerateAliasesInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [out][in] */ PSAM_ENUMERATE_HANDLE EnumerationContext,
    /* [out] */ PSAMPR_ENUMERATION_BUFFER *Buffer,
    /* [in] */ ULONG PreferedMaximumLength,
    /* [out] */ PULONG CountReturned);

NTSTATUS SamrGetAliasMembership( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PSAMPR_PSID_ARRAY SidArray,
    /* [out] */ PSAMPR_ULONG_ARRAY Membership);

NTSTATUS SamrLookupNamesInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ ULONG Count,
    /* [length_is][size_is][in] */ RPC_UNICODE_STRING Names[  ],
    /* [out] */ PSAMPR_ULONG_ARRAY RelativeIds,
    /* [out] */ PSAMPR_ULONG_ARRAY Use);

NTSTATUS SamrLookupIdsInDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ ULONG Count,
    /* [length_is][size_is][in] */ PULONG RelativeIds,
    /* [out] */ PSAMPR_RETURNED_USTRING_ARRAY Names,
    /* [out] */ PSAMPR_ULONG_ARRAY Use);

NTSTATUS SamrOpenGroup( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [in] */ ULONG GroupId,
    /* [out] */ SAMPR_HANDLE *GroupHandle);

NTSTATUS SamrQueryInformationGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [in] */ GROUP_INFORMATION_CLASS GroupInformationClass,
    /* [switch_is][out] */ PSAMPR_GROUP_INFO_BUFFER *Buffer);

NTSTATUS SamrSetInformationGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [in] */ GROUP_INFORMATION_CLASS GroupInformationClass,
    /* [switch_is][in] */ PSAMPR_GROUP_INFO_BUFFER Buffer);

NTSTATUS SamrAddMemberToGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [in] */ ULONG MemberId,
    /* [in] */ ULONG Attributes);

NTSTATUS SamrDeleteGroup( 
    /* [out][in] */ SAMPR_HANDLE *GroupHandle);

NTSTATUS SamrRemoveMemberFromGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [in] */ ULONG MemberId);

NTSTATUS SamrGetMembersInGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [out] */ PSAMPR_GET_MEMBERS_BUFFER *Members);

NTSTATUS SamrSetMemberAttributesOfGroup( 
    /* [in] */ SAMPR_HANDLE GroupHandle,
    /* [in] */ ULONG MemberId,
    /* [in] */ ULONG Attributes);

NTSTATUS SamrOpenAlias( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [in] */ ULONG AliasId,
    /* [out] */ SAMPR_HANDLE *AliasHandle);

NTSTATUS SamrQueryInformationAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ ALIAS_INFORMATION_CLASS AliasInformationClass,
    /* [switch_is][out] */ PSAMPR_ALIAS_INFO_BUFFER *Buffer);

NTSTATUS SamrSetInformationAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ ALIAS_INFORMATION_CLASS AliasInformationClass,
    /* [switch_is][in] */ PSAMPR_ALIAS_INFO_BUFFER Buffer);

NTSTATUS SamrDeleteAlias( 
    /* [out][in] */ SAMPR_HANDLE *AliasHandle);

NTSTATUS SamrAddMemberToAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ PRPC_SID MemberId);

NTSTATUS SamrRemoveMemberFromAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ PRPC_SID MemberId);

NTSTATUS SamrGetMembersInAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [out] */ PSAMPR_PSID_ARRAY Members);

NTSTATUS SamrOpenUser( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [in] */ ULONG UserId,
    /* [out] */ SAMPR_HANDLE *UserHandle);

NTSTATUS SamrDeleteUser( 
    /* [out][in] */ SAMPR_HANDLE *UserHandle);

NTSTATUS SamrQueryInformationUser( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [in] */ USER_INFORMATION_CLASS UserInformationClass,
    /* [switch_is][out] */ PSAMPR_USER_INFO_BUFFER *Buffer);

NTSTATUS SamrSetInformationUser( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [in] */ USER_INFORMATION_CLASS UserInformationClass,
    /* [switch_is][in] */ PSAMPR_USER_INFO_BUFFER Buffer);

NTSTATUS SamrChangePasswordUser( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [in] */ BOOLEAN LmPresent,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD LmOldEncryptedWithLmNew,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD LmNewEncryptedWithLmOld,
    /* [in] */ BOOLEAN NtPresent,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD NtOldEncryptedWithNtNew,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD NtNewEncryptedWithNtOld,
    /* [in] */ BOOLEAN NtCrossEncryptionPresent,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD NtNewEncryptedWithLmNew,
    /* [in] */ BOOLEAN LmCrossEncryptionPresent,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD LmNtNewEncryptedWithNtNew);

NTSTATUS SamrGetGroupsForUser( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [out] */ PSAMPR_GET_GROUPS_BUFFER *Groups);

NTSTATUS SamrQueryDisplayInformation( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_DISPLAY_INFORMATION DisplayInformationClass,
    /* [in] */ ULONG Index,
    /* [in] */ ULONG EntryCount,
    /* [in] */ ULONG PreferredMaximumLength,
    /* [out] */ PULONG TotalAvailable,
    /* [out] */ PULONG TotalReturned,
    /* [switch_is][out] */ PSAMPR_DISPLAY_INFO_BUFFER Buffer);

NTSTATUS SamrGetDisplayEnumerationIndex( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_DISPLAY_INFORMATION DisplayInformationClass,
    /* [in] */ PRPC_UNICODE_STRING Prefix,
    /* [out] */ PULONG Index);

NTSTATUS SamrTestPrivateFunctionsDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle);

NTSTATUS SamrTestPrivateFunctionsUser( 
    /* [in] */ SAMPR_HANDLE UserHandle);

NTSTATUS SamrGetUserDomainPasswordInformation( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [out] */ PUSER_DOMAIN_PASSWORD_INFORMATION PasswordInformation);

NTSTATUS SamrRemoveMemberFromForeignDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PRPC_SID MemberSid);

NTSTATUS SamrQueryInformationDomain2( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_INFORMATION_CLASS DomainInformationClass,
    /* [switch_is][out] */ PSAMPR_DOMAIN_INFO_BUFFER *Buffer);

NTSTATUS SamrQueryInformationUser2( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [in] */ USER_INFORMATION_CLASS UserInformationClass,
    /* [switch_is][out] */ PSAMPR_USER_INFO_BUFFER *Buffer);

NTSTATUS SamrQueryDisplayInformation2( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_DISPLAY_INFORMATION DisplayInformationClass,
    /* [in] */ ULONG Index,
    /* [in] */ ULONG EntryCount,
    /* [in] */ ULONG PreferredMaximumLength,
    /* [out] */ PULONG TotalAvailable,
    /* [out] */ PULONG TotalReturned,
    /* [switch_is][out] */ PSAMPR_DISPLAY_INFO_BUFFER Buffer);

NTSTATUS SamrGetDisplayEnumerationIndex2( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_DISPLAY_INFORMATION DisplayInformationClass,
    /* [in] */ PRPC_UNICODE_STRING Prefix,
    /* [out] */ PULONG Index);

NTSTATUS SamrCreateUser2InDomain( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ PRPC_UNICODE_STRING Name,
    /* [in] */ ULONG AccountType,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [out] */ SAMPR_HANDLE *UserHandle,
    /* [out] */ PULONG GrantedAccess,
    /* [out] */ PULONG RelativeId);

NTSTATUS SamrQueryDisplayInformation3( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ DOMAIN_DISPLAY_INFORMATION DisplayInformationClass,
    /* [in] */ ULONG Index,
    /* [in] */ ULONG EntryCount,
    /* [in] */ ULONG PreferredMaximumLength,
    /* [out] */ PULONG TotalAvailable,
    /* [out] */ PULONG TotalReturned,
    /* [switch_is][out] */ PSAMPR_DISPLAY_INFO_BUFFER Buffer);

NTSTATUS SamrAddMultipleMembersToAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ PSAMPR_PSID_ARRAY MembersBuffer);

NTSTATUS SamrRemoveMultipleMembersFromAlias( 
    /* [in] */ SAMPR_HANDLE AliasHandle,
    /* [in] */ PSAMPR_PSID_ARRAY MembersBuffer);

NTSTATUS SamrOemChangePasswordUser2( 
    /* [in] */ handle_t BindingHandle,
    /* [unique][in] */ PRPC_STRING ServerName,
    /* [in] */ PRPC_STRING UserName,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPassswordEncryptedWithNewLm);

NTSTATUS SamrUnicodeChangePasswordUser2( 
    /* [in] */ handle_t BindingHandle,
    /* [unique][in] */ PRPC_UNICODE_STRING ServerName,
    /* [in] */ PRPC_UNICODE_STRING UserName,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt,
    /* [in] */ BOOLEAN LmPresent,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPassswordEncryptedWithNewLmOrNt);

NTSTATUS SamrGetDomainPasswordInformation( 
    /* [in] */ handle_t BindingHandle,
    /* [unique][in] */ PRPC_UNICODE_STRING ServerName,
    /* [out] */ PUSER_DOMAIN_PASSWORD_INFORMATION PasswordInformation);

NTSTATUS SamrConnect2( 
    /* [string][unique][in] */ PSAMPR_SERVER_NAME ServerName,
    /* [out] */ SAMPR_HANDLE *ServerHandle,
    /* [in] */ ACCESS_MASK DesiredAccess);

NTSTATUS SamrSetInformationUser2( 
    /* [in] */ SAMPR_HANDLE UserHandle,
    /* [in] */ USER_INFORMATION_CLASS UserInformationClass,
    /* [switch_is][in] */ PSAMPR_USER_INFO_BUFFER Buffer);

NTSTATUS SamrSetBootKeyInformation( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [in] */ SAMPR_BOOT_TYPE BootOptions,
    /* [unique][in] */ PRPC_UNICODE_STRING OldBootKey,
    /* [unique][in] */ PRPC_UNICODE_STRING NewBootKey);

NTSTATUS SamrGetBootKeyInformation( 
    /* [in] */ SAMPR_HANDLE DomainHandle,
    /* [out] */ PSAMPR_BOOT_TYPE BootOptions);

NTSTATUS SamrConnect3( 
    /* [string][unique][in] */ PSAMPR_SERVER_NAME ServerName,
    /* [out] */ SAMPR_HANDLE *ServerHandle,
    /* [in] */ ULONG ClientRevision,
    /* [in] */ ACCESS_MASK DesiredAccess);

NTSTATUS SamrConnect4( 
    /* [string][unique][in] */ PSAMPR_SERVER_NAME ServerName,
    /* [out] */ SAMPR_HANDLE *ServerHandle,
    /* [in] */ ULONG ClientRevision,
    /* [in] */ ACCESS_MASK DesiredAccess);

NTSTATUS SamrUnicodeChangePasswordUser3( 
    /* [in] */ handle_t BindingHandle,
    /* [unique][in] */ PRPC_UNICODE_STRING ServerName,
    /* [in] */ PRPC_UNICODE_STRING UserName,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt,
    /* [in] */ BOOLEAN LmPresent,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    /* [unique][in] */ PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPassswordEncryptedWithNewLmOrNt,
    /* [unique][in] */ PSAMPR_ENCRYPTED_USER_PASSWORD AdditionalData,
    /* [out] */ PDOMAIN_PASSWORD_INFORMATION *EffectivePasswordPolicy,
    /* [out] */ PUSER_PWD_CHANGE_FAILURE_INFORMATION *PasswordChangeInfo);

NTSTATUS SamrConnect5( 
    /* [string][unique][in] */ PSAMPR_SERVER_NAME ServerName,
    /* [in] */ ACCESS_MASK DesiredAccess,
    /* [in] */ ULONG InVersion,
    /* [switch_is][in] */ SAMPR_REVISION_INFO *InRevisionInfo,
    /* [out] */ ULONG *OutVersion,
    /* [switch_is][out] */ SAMPR_REVISION_INFO *OutRevisionInfo,
    /* [out] */ SAMPR_HANDLE *ServerHandle);

NTSTATUS SamrRidToSid( 
    /* [in] */ SAMPR_HANDLE ObjectHandle,
    /* [in] */ ULONG Rid,
    /* [out] */ PRPC_SID *Sid);

NTSTATUS SamrSetDSRMPassword( 
    /* [in] */ handle_t BindingHandle,
    /* [unique][in] */ PRPC_UNICODE_STRING ServerName,
    /* [in] */ ULONG UserId,
    /* [unique][in] */ PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword);


extern handle_t samsrv_handle;


extern RPC_IF_HANDLE samr_ClientIfHandle;
extern RPC_IF_HANDLE samr_ServerIfHandle;
#endif /* __samr_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

handle_t __RPC_USER PSAMPR_SERVER_NAME_bind  ( PSAMPR_SERVER_NAME );
void     __RPC_USER PSAMPR_SERVER_NAME_unbind( PSAMPR_SERVER_NAME, handle_t );

void __RPC_USER SAMPR_HANDLE_rundown( SAMPR_HANDLE );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\samsrv.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    samsrv.h

Abstract:

    This file contains SAM server definitions that are used both
    internally within the SAM server and by other components
    in the security server.


    NOTE:  NetLogon calls SAM's RPC server stubs directly.
           The interface definitions for those routines are
           defined in MIDL generated include files.


Author:

    Jim Kelly    (JimK)  1-Feb-199

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef _SAMSRV_
#define _SAMSRV_



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntsam.h>




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// The following prototypes are usable throughout the process that SAM       //
// resides in.  This may include calls by LAN Manager code that is not       //
// part of SAM but is in the same process as SAM.                            //
//                                                                           //
// Many private services, defined in samisrv.h, are also available           //
// to NetLogon through a special arrangement.                                //
//                                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SamIInitialize( VOID );




#endif  // _SAMSRV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\scesetup.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    scesetup.h

Abstract:

    This module defines the exported data structures for system setup and
    network/oem/component setup

Author:

    Jin Huang (jinhuang) 21-Aug-1997

Revision History:

--*/

#ifndef _scesetup_
#define _scesetup_

#ifdef __cplusplus
extern "C"{
#endif

#include "setupapi.h"

#ifndef SCE_AREA_DEFINED
#define SCE_AREA_DEFINED

typedef DWORD  AREA_INFORMATION;

#define AREA_SECURITY_POLICY     0x0001L
#define AREA_USER_SETTINGS       0x0002L
#define AREA_GROUP_MEMBERSHIP    0x0004L
#define AREA_PRIVILEGES          0x0008L
#define AREA_DS_OBJECTS          0x0010L
#define AREA_REGISTRY_SECURITY   0x0020L
#define AREA_FILE_SECURITY       0x0040L
#define AREA_SYSTEM_SERVICE      0x0080L
#define AREA_ATTACHMENTS         0x8000L
#define AREA_ALL                 0xFFFFL

#endif

typedef
BOOL(CALLBACK *PSCE_NOTIFICATION_CALLBACK_ROUTINE)(
    IN HANDLE NotificationHandle,
    IN UINT   NotificationCode,
    IN UINT   NotificationSpecificValue,
    IN LPARAM lParam
    );

#define SCESETUP_CONFIGURE_SECURITY     0x0
#define SCESETUP_UPGRADE_SYSTEM         0x1
#define SCESETUP_UPDATE_FILE_KEY        0x2
#define SCESETUP_QUERY_TICKS            0x4
#define SCESETUP_RECONFIG_SECURITY      0x8
#define SCESETUP_BIND_NO_AUTH           0x80

#define SCESETUP_NOTIFICATION_TICKS     1

DWORD
WINAPI
SceSetupSystemByInfName(
    IN PWSTR InfFullName,
    IN PCWSTR LogFileName OPTIONAL,
    IN AREA_INFORMATION Area,
    IN UINT nFlag,
    IN PSCE_NOTIFICATION_CALLBACK_ROUTINE pSceNotificationCallBack OPTIONAL,
    IN OUT PVOID pValue OPTIONAL
    );

DWORD
WINAPI
SceSetupUpdateSecurityFile(
    IN PWSTR FileFullName,
    IN UINT nFlag,
    IN PWSTR SDText
    );

DWORD
WINAPI
SceSetupMoveSecurityFile(
    IN PWSTR FileToSetSecurity,
    IN PWSTR FileToSaveInDB OPTIONAL,
    IN PWSTR SDText OPTIONAL
    );

DWORD
WINAPI
SceSetupUnwindSecurityFile(
    IN PWSTR FileFullName,
    IN PSECURITY_DESCRIPTOR pSDBackup
    );

DWORD
WINAPI
SceSetupUpdateSecurityKey(
    IN HKEY hKeyRoot,
    IN PWSTR KeyPath,
    IN UINT nFlag,
    IN PWSTR SDText
    );

DWORD
WINAPI
SceSetupUpdateSecurityService(
     IN PWSTR ServiceName,
     IN DWORD StartType,
     IN PWSTR SDText
     );

DWORD
WINAPI
SceSetupBackupSecurity(
    IN LPTSTR LogFileName OPTIONAL   // default to %windir%\security\logs\backup.log
    );

DWORD
WINAPI
SceSetupConfigureServices(
    IN UINT SetupProductType
    );

typedef
DWORD(CALLBACK *PSCE_PROMOTE_CALLBACK_ROUTINE)(
    IN PWSTR StringUpdate
    );

#define SCE_DCPROMO_LOG_PATH    TEXT("%windir%\\security\\logs\\scedcpro.log")

#define SCE_PROMOTE_FLAG_UPGRADE        0x01L
#define SCE_PROMOTE_FLAG_REPLICA        0x02L
#define SCE_PROMOTE_FLAG_DEMOTE         0x04L

DWORD
WINAPI
SceDcPromoteSecurity(
    IN DWORD dwPromoteOptions,
    IN PSCE_PROMOTE_CALLBACK_ROUTINE pScePromoteCallBack OPTIONAL
    );

DWORD
WINAPI
SceDcPromoteSecurityEx(
    IN HANDLE ClientToken,
    IN DWORD dwPromoteOptions,
    IN PSCE_PROMOTE_CALLBACK_ROUTINE pScePromoteCallBack OPTIONAL
    );

#define STR_DEFAULT_DOMAIN_GPO_GUID                 TEXT("31B2F340-016D-11D2-945F-00C04FB984F9")
#define STR_DEFAULT_DOMAIN_CONTROLLER_GPO_GUID      TEXT("6AC1786C-016F-11D2-945F-00C04fB984F9")

DWORD
WINAPI
SceDcPromoCreateGPOsInSysvol(
    IN LPTSTR DomainDnsName,
    IN LPTSTR SysvolRoot,
    IN DWORD dwPromoteOptions,
    IN PSCE_PROMOTE_CALLBACK_ROUTINE pScePromoteCallBack OPTIONAL
    );

DWORD
WINAPI
SceDcPromoCreateGPOsInSysvolEx(
    IN HANDLE ClientToken,
    IN LPTSTR DomainDnsName,
    IN LPTSTR SysvolRoot,
    IN DWORD dwPromoteOptions,
    IN PSCE_PROMOTE_CALLBACK_ROUTINE pScePromoteCallBack OPTIONAL
    );

DWORD
WINAPI
SceSetupRootSecurity();

DWORD
WINAPI
SceEnforceSecurityPolicyPropagation();

/*
NTSTATUS
WINAPI
SceNotifyPolicyDelta (
    IN SECURITY_DB_TYPE DbType,
    IN LARGE_INTEGER SerialNumber,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PSID ObjectSid,
    IN PUNICODE_STRING ObjectName,
    IN DWORD ReplicateImmediately,
    IN PSAM_DELTA_DATA MemberId
    );
*/
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\scioctl.h ===
/*

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    scioctl.h

Abstract:

    This module defines the I/O control codes used to redirect the Smart Card Subsystem
    for Terminal Services.

Revision History:

--*/

#define SCARD_IOCTL_SMARTCARD_ONLINE           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 1,  METHOD_BUFFERED, FILE_ANY_ACCESS)

#define SCARD_IOCTL_ESTABLISHCONTEXT           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 5,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_RELEASECONTEXT             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 6,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_ISVALIDCONTEXT             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 7,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_LISTREADERGROUPSA          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 8,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_LISTREADERGROUPSW          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 9,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_LISTREADERSA               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 10,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_LISTREADERSW               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 11,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_INTRODUCEREADERGROUPA      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 20,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_INTRODUCEREADERGROUPW      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 21,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_FORGETREADERGROUPA         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 22,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_FORGETREADERGROUPW         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 23,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_INTRODUCEREADERA           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 24,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_INTRODUCEREADERW           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 25,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_FORGETREADERA              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 26,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_FORGETREADERW              CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 27,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_ADDREADERTOGROUPA          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 28,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_ADDREADERTOGROUPW          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 29,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_REMOVEREADERFROMGROUPA     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 30,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_REMOVEREADERFROMGROUPW     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 31,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_LOCATECARDSA               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 38,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_LOCATECARDSW               CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 39,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_GETSTATUSCHANGEA           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 40,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_GETSTATUSCHANGEW           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 41,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_CANCEL                     CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 42,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_CONNECTA                   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 43,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_CONNECTW                   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 44,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_RECONNECT                  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 45,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_DISCONNECT                 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 46,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_BEGINTRANSACTION           CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 47,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_ENDTRANSACTION             CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 48,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_STATE                      CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 49,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_STATUSA                    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 50,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_STATUSW                    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 51,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_TRANSMIT                   CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 52,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_CONTROL                    CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 53,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_GETATTRIB                  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 54,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_SETATTRIB                  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 55,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_ACCESSSTARTEDEVENT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 56,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_RELEASETARTEDEVENT         CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 57,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_LOCATECARDSBYATRA          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 58,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define SCARD_IOCTL_LOCATECARDSBYATRW          CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 59,  METHOD_BUFFERED, FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\scesrv.h ===
#include <svcs.h>

extern "C" {

DWORD
WINAPI
ScesrvInitializeServer(
    IN PSVCS_START_RPC_SERVER pStartRpcServer
    );

DWORD
WINAPI
ScesrvTerminateServer(
    IN PSVCS_STOP_RPC_SERVER pStopRpcServer
    );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\sddlp.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    sddlp.h

Abstract:

    This module defines private headers for SDDL conversions routines

Revision History:

--*/

#include <sddl.h>

#ifndef __SDDLP_H__
#define __SDDLP_H__


#ifdef __cplusplus
extern "C" {
#endif

#if(_WIN32_WINNT >= 0x0500)

WINADVAPI
BOOL
WINAPI
ConvertStringSDToSDRootDomainA(
    IN  PSID RootDomainSid OPTIONAL,
    IN  LPCSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    );

WINADVAPI
BOOL
WINAPI
ConvertStringSDToSDRootDomainW(
    IN  PSID RootDomainSid OPTIONAL,
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    );

#ifdef UNICODE
#define ConvertStringSDToSDRootDomain  ConvertStringSDToSDRootDomainW
#else
#define ConvertStringSDToSDRootDomain  ConvertStringSDToSDRootDomainA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
ConvertSDToStringSDRootDomainA(
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  DWORD RequestedStringSDRevision,
    IN  SECURITY_INFORMATION SecurityInformation,
    OUT LPSTR  *StringSecurityDescriptor OPTIONAL,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    );

WINADVAPI
BOOL
WINAPI
ConvertSDToStringSDRootDomainW(
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  DWORD RequestedStringSDRevision,
    IN  SECURITY_INFORMATION SecurityInformation,
    OUT LPWSTR  *StringSecurityDescriptor OPTIONAL,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    );


#ifdef UNICODE
#define ConvertSDToStringSDRootDomain  ConvertSDToStringSDRootDomainW
#else
#define ConvertSDToStringSDRootDomain  ConvertSDToStringSDRootDomainA
#endif // !UNICODE

WINADVAPI
BOOL
WINAPI
ConvertStringSDToSDDomainA(
    IN  PSID DomainSid,
    IN  PSID RootDomainSid OPTIONAL,
    IN  LPCSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    );

WINADVAPI
BOOL
WINAPI
ConvertStringSDToSDDomainW(
    IN  PSID DomainSid,
    IN  PSID RootDomainSid OPTIONAL,
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    );

NTSTATUS
SddlpAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PANSI_STRING SourceString
    );

#ifdef UNICODE
#define ConvertStringSDToSDDomain  ConvertStringSDToSDDomainW
#else
#define ConvertStringSDToSDDomain  ConvertStringSDToSDDomainA
#endif // !UNICODE

#endif /* _WIN32_WINNT >=  0x0500 */

#ifdef __cplusplus
}
#endif
#endif  // endif __SDDLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\sclogon.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ScLogon

Abstract:

    This header defines APIs for use by GINA and LSA during WinLogon via a
    smart card

Author:

    Amanda Matlosz (amatlosz) 10/23/1997

Environment:

    Win32

Revision History:

Notes:

--*/

#ifndef __SCLOGON_H__
#define __SCLOGON_H__

#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////////////
//
// defines
#ifndef NT_INCLUDED
    typedef LONG NTSTATUS;
    typedef NTSTATUS *PNTSTATUS;

    typedef struct _UNICODE_STRING {
        USHORT Length;
        USHORT MaximumLength;
        PWSTR  Buffer;
    } UNICODE_STRING, *PUNICODE_STRING;
#endif


//////////////////////////////////////////////////////////////////////////////
//
// Structs


// this entire struct is opaque, and is used by the helper APIs to contain
// information about the card currently in use
struct LogonInfo
{
    DWORD dwLogonInfoLen;
    PVOID ContextInformation;
    ULONG nCardNameOffset;
    ULONG nReaderNameOffset;
    ULONG nContainerNameOffset;
    ULONG nCSPNameOffset;

    // LogonInfo may include further information, like:
    // crypt context, useful handles, pid...

    TCHAR bBuffer[sizeof(DWORD)]; // expandable place for strings
};


typedef struct _ScHelper_RandomCredBits
{
        BYTE bR1[32]; // TBD: is 32 appropriate?
        BYTE bR2[32];
} ScHelper_RandomCredBits;

//////////////////////////////////////////////////////////////////////////////
//
// Functions
//

// helpers to access to items in opaque LogonInfo, such as:
LPCTSTR WINAPI GetReaderName(PBYTE pbLogonInfo);
LPCTSTR WINAPI GetCardName(PBYTE pbLogonInfo);
LPCTSTR WINAPI GetContainerName(PBYTE pbLogonInfo);
LPCTSTR WINAPI GetCSPName(PBYTE pbLogonInfo);

//
// Calls used by GINA to construct the blob that kerberos
// and sclogon share.
//

PBYTE
WINAPI
ScBuildLogonInfo(
    LPCTSTR szCard,
    LPCTSTR szReader,
    LPCTSTR szContainer,
    LPCTSTR szCSP);

//
// Calls used by LSA
//

NTSTATUS WINAPI
ScHelperInitializeContext(
    IN OUT PBYTE pbLogonInfo,
    IN ULONG cbLogonInfo
    );

VOID WINAPI
ScHelperRelease(
    IN PBYTE ppbLogonInfo
    );

NTSTATUS WINAPI
ScHelperGetProvParam(
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbLogonInfo,
    DWORD dwParam,
    BYTE*pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags
    );


// ScHelperGetCertFromLogonInfo may need the PIN to get a cert off certain SCs
NTSTATUS WINAPI
ScHelperGetCertFromLogonInfo(
    IN PBYTE pbLogonInfo,
    IN PUNICODE_STRING pucPIN,
    OUT PCCERT_CONTEXT * CertificateContext
    );


// ScHelperVerifyCard uses SignMessage() and VerifyMessage() to verify the
// card's integrity (that it has the keys it says it has)
NTSTATUS WINAPI
ScHelperVerifyCard(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo
    );

// ScHelper*Cred* functions provide for a more secure offline experience

NTSTATUS WINAPI
ScHelperGenRandBits
(
        IN PBYTE pbLogonInfo,
        IN ScHelper_RandomCredBits* psc_rcb
);

NTSTATUS WINAPI
ScHelperCreateCredKeys
(
    IN PUNICODE_STRING pucPIN,
        IN PBYTE pbLogonInfo,
        IN ScHelper_RandomCredBits* psc_rcb,
        IN OUT HCRYPTKEY* phHmacKey,
        IN OUT HCRYPTKEY* phRc4Key,
        IN OUT HCRYPTPROV* phProv
);

NTSTATUS WINAPI
ScHelperCreateCredHMAC
(
        IN HCRYPTPROV hProv,
        IN HCRYPTKEY hHmacKey,
        IN PBYTE CleartextData,
        IN ULONG CleartextDataSize,
        IN OUT PBYTE* ppbHmac,
        IN OUT DWORD* pdwHmacLen
);

NTSTATUS WINAPI
ScHelperVerifyCardAndCreds(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo,
    IN PBYTE SignedEncryptedData,
    IN ULONG SignedEncryptedDataSize,
    OUT OPTIONAL PBYTE CleartextData,
    OUT PULONG CleartextDataSize
    );

NTSTATUS WINAPI
ScHelperEncryptCredentials(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN ScHelper_RandomCredBits* psch_rcb,
    IN PBYTE pbLogonInfo,
    IN PBYTE CleartextData,
    IN ULONG CleartextDataSize,
    OUT OPTIONAL PBYTE EncryptedData,
    OUT PULONG EncryptedDataSize
    );

NTSTATUS WINAPI
ScHelperDecryptCredentials(
    IN PUNICODE_STRING pucPIN,
    IN PCCERT_CONTEXT CertificateContext,
    IN HCERTSTORE hCertStore,
    IN PBYTE pbLogonInfo,
    IN PBYTE EncryptedData,
    IN ULONG EncryptedDataSize,
    OUT OPTIONAL PBYTE CleartextData,
    OUT PULONG CleartextDataSize
    );


//
// The following two functions may be called in any order, and return a basic
// "success" or "failure"
//
// ScHelperSignMessage() needs the logoninfo and PIN in order to find the card
// that will do the signing...
//
NTSTATUS WINAPI
ScHelperSignMessage(
    IN PUNICODE_STRING pucPIN,
    IN PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT PBYTE Signature,
    OUT PULONG SignatureLength
    );

NTSTATUS WINAPI
ScHelperSignPkcsMessage(
    IN OPTIONAL PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT Certificate,
    IN PCRYPT_ALGORITHM_IDENTIFIER Algorithm,
    IN OPTIONAL DWORD dwSignMessageFlags,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE SignedBuffer,
    OUT OPTIONAL PULONG SignedBufferLength
    );

//
// ScHelperVerifyMessage() returns STATUS_SUCCESS if the signature provided is
// the hash of the buffer encrypted by the owner of the cert.
//

NTSTATUS WINAPI
ScHelperVerifyMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN ULONG Algorithm,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    IN PBYTE Signature,
    IN ULONG SignatureLength
    );

NTSTATUS WINAPI
ScHelperVerifyPkcsMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PBYTE Buffer,
    IN ULONG BufferLength,
    OUT OPTIONAL PBYTE DecodedBuffer,
    OUT OPTIONAL PULONG DecodedBufferLength,
    OUT OPTIONAL PCCERT_CONTEXT * CertificateContext
    );


//
// ScHelperEncryptMessage and ScHelperDecryptMessage
// encrypt and decrypt buffer/cipher text using PKCS7 crypto stuff.
//
NTSTATUS WINAPI
ScHelperEncryptMessage(
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN PCRYPT_ALGORITHM_IDENTIFIER Algorithm,
    IN PBYTE Buffer,                        // The data to encrypt
    IN ULONG BufferLength,                  // The length of that data
    OUT PBYTE CipherText,                   // Receives the formatted CipherText
    IN PULONG pCipherLength                 // Supplies size of CipherText buffer
    );                                       // Receives length of actual CipherText

NTSTATUS WINAPI
ScHelperDecryptMessage(
    IN PUNICODE_STRING pucPIN,
    IN OPTIONAL PBYTE pbLogonInfo,
    IN OPTIONAL HCRYPTPROV Provider,
    IN PCCERT_CONTEXT CertificateContext,
    IN PBYTE CipherText,        // Supplies formatted CipherText
    IN ULONG CipherLength,      // Supplies the length of the CiperText
    OUT PBYTE ClearText,        // Receives decrypted message
    IN OUT PULONG pClearLength  // Supplies length of buffer, receives actual length
    );


/////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif

#endif // __SCLOGON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\secedit.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    secedit.h

Abstract:

    This module defines the exported data structures and function prototypes
    for the security managment utility

Author:

    Jin Huang (jinhuang) 28-Oct-1996

Revision History:

--*/

#ifndef _secedit_
#define _secedit_

#ifdef __cplusplus
extern "C"{
#endif

//
// definition for areas
//
#ifndef SCE_AREA_DEFINED
#define SCE_AREA_DEFINED
typedef DWORD  AREA_INFORMATION;

#define AREA_SECURITY_POLICY     0x0001L
#define AREA_USER_SETTINGS       0x0002L
#define AREA_GROUP_MEMBERSHIP    0x0004L
#define AREA_PRIVILEGES          0x0008L
#define AREA_DS_OBJECTS          0x0010L
#define AREA_REGISTRY_SECURITY   0x0020L
#define AREA_FILE_SECURITY       0x0040L
#define AREA_SYSTEM_SERVICE      0x0080L
#define AREA_ATTACHMENTS         0x8000L
#define AREA_ALL                 0xFFFFL

#endif
//
// Other constants
//
#define AREA_PASSWORD_POLICY     0x0100L
#define AREA_LOCKOUT_POLICY      0x0200L
#define AREA_KERBEROS_POLICY     0x0400L
#define AREA_ACCOUNT_POLICY      (AREA_PASSWORD_POLICY | \
                                  AREA_LOCKOUT_POLICY | \
                                  AREA_KERBEROS_POLICY)

#define AREA_AUDIT_POLICY        0x0800L
#define AREA_SECURITY_OPTIONS    0x1000L
#define AREA_LOCAL_POLICY        (AREA_AUDIT_POLICY |\
                                  AREA_PRIVILEGES |\
                                  AREA_SECURITY_OPTIONS)

#define AREA_LOG_POLICY          0x2000L


#define SCE_STATUS_CHECK             0
#define SCE_STATUS_IGNORE            1
#define SCE_STATUS_OVERWRITE         2
#define SCE_STATUS_NO_AUTO_INHERIT   4

#define SCE_STATUS_IN                0
#define SCE_STATUS_NOT_IN            1

#define SCE_STATUS_NO_ACL_SUPPORT        3

#define SCE_STATUS_GOOD                  0
#define SCE_STATUS_MISMATCH              1
#define SCE_STATUS_CHILDREN_CONFIGURED   2
#define SCE_STATUS_NOT_CONFIGURED        4
#define SCE_STATUS_ERROR_NOT_AVAILABLE   5
#define SCE_STATUS_NEW_SERVICE           6
#define SCE_STATUS_NOT_ANALYZED          7

#define SCE_STATUS_PERMISSION_MISMATCH   0x40
#define SCE_STATUS_AUDIT_MISMATCH        0x80

#ifdef _WIN64
#define SCE_SETUP_32KEY   0x2000L
#endif

typedef enum _SCE_TYPE {

    SCE_ENGINE_SYSTEM=300,
    SCE_ENGINE_GPO,
    SCE_ENGINE_SCP,         // effective table
    SCE_ENGINE_SAP,         // analysis table
    SCE_ENGINE_SCP_INTERNAL,
    SCE_ENGINE_SMP_INTERNAL,
    SCE_ENGINE_SMP,         // local table
    SCE_STRUCT_INF,
    SCE_STRUCT_PROFILE,
    SCE_STRUCT_USER,
    SCE_STRUCT_NAME_LIST,
    SCE_STRUCT_NAME_STATUS_LIST,
    SCE_STRUCT_PRIVILEGE,
    SCE_STRUCT_GROUP,
    SCE_STRUCT_OBJECT_LIST,
    SCE_STRUCT_OBJECT_CHILDREN,
    SCE_STRUCT_OBJECT_SECURITY,
    SCE_STRUCT_OBJECT_ARRAY,
    SCE_STRUCT_ERROR_LOG_INFO,
    SCE_STRUCT_SERVICES,
    SCE_STRUCT_PRIVILEGE_VALUE_LIST

} SCETYPE;

typedef enum _SCE_FORMAT_TYPE_ {

    SCE_INF_FORMAT=1,
    SCE_JET_FORMAT,
    SCE_JET_ANALYSIS_REQUIRED

} SCE_FORMAT_TYPE, *PSCE_FORMAT_TYPE;

static const WCHAR szMembers[]             = L"__Members";
static const WCHAR szMemberof[]            = L"__Memberof";
static const WCHAR szPrivileges[]          = L"__Privileges";

#define SCE_BUF_LEN              1024

#define SCE_FOREVER_VALUE        (DWORD)-1
#define SCE_NO_VALUE             (DWORD)-2
#define SCE_KERBEROS_OFF_VALUE   (DWORD)-3
#define SCE_DELETE_VALUE         (DWORD)-4
#define SCE_SNAPSHOT_VALUE       (DWORD)-5
#define SCE_NOT_ANALYZED_VALUE   (DWORD)-6
#define SCE_ERROR_VALUE          (DWORD)-7

#ifndef _SCE_SHARED_HEADER
#define _SCE_SHARED_HEADER

typedef DWORD                   SCESTATUS;

#define SCESTATUS_SUCCESS              0L
#define SCESTATUS_INVALID_PARAMETER    1L
#define SCESTATUS_RECORD_NOT_FOUND     2L
#define SCESTATUS_INVALID_DATA         3L
#define SCESTATUS_OBJECT_EXIST         4L
#define SCESTATUS_BUFFER_TOO_SMALL     5L
#define SCESTATUS_PROFILE_NOT_FOUND    6L
#define SCESTATUS_BAD_FORMAT           7L
#define SCESTATUS_NOT_ENOUGH_RESOURCE  8L
#define SCESTATUS_ACCESS_DENIED        9L
#define SCESTATUS_CANT_DELETE          10L
#define SCESTATUS_PREFIX_OVERFLOW      11L
#define SCESTATUS_OTHER_ERROR          12L
#define SCESTATUS_ALREADY_RUNNING      13L
#define SCESTATUS_SERVICE_NOT_SUPPORT  14L
#define SCESTATUS_MOD_NOT_FOUND        15L
#define SCESTATUS_EXCEPTION_IN_SERVER  16L
#define SCESTATUS_NO_TEMPLATE_GIVEN    17L
#define SCESTATUS_NO_MAPPING           18L
#define SCESTATUS_TRUST_FAIL           19L
#define SCESTATUS_JET_DATABASE_ERROR   20L
#define SCESTATUS_TIMEOUT              21L
#define SCESTATUS_PENDING_IGNORE       22L
#define SCESTATUS_SPECIAL_ACCOUNT      23L

//
// defined for services
//
typedef struct _SCESVC_CONFIGURATION_LINE_ {

    LPTSTR  Key;
    LPTSTR  Value;
    DWORD   ValueLen; // number of bytes

} SCESVC_CONFIGURATION_LINE, *PSCESVC_CONFIGURATION_LINE;

typedef struct _SCESVC_CONFIGURATION_INFO_ {

    DWORD   Count;
    PSCESVC_CONFIGURATION_LINE Lines;

} SCESVC_CONFIGURATION_INFO, *PSCESVC_CONFIGURATION_INFO;

typedef PVOID SCE_HANDLE;
typedef ULONG SCE_ENUMERATION_CONTEXT, *PSCE_ENUMERATION_CONTEXT;

#define SCESVC_ENUMERATION_MAX  100L

typedef enum _SCESVC_INFO_TYPE {

    SceSvcConfigurationInfo,
    SceSvcMergedPolicyInfo,
    SceSvcAnalysisInfo,
    SceSvcInternalUse                   // !!!do not use this type!!!

} SCESVC_INFO_TYPE;

// root path for SCE key
#define SCE_ROOT_PATH TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\SeCEdit")

#define SCE_ROOT_SERVICE_PATH   \
            SCE_ROOT_PATH TEXT("\\SvcEngs")
#endif

//
// All section names defined in the SCP/SAP profiles.
//

static const WCHAR szDescription[]             = L"Profile Description";
static const WCHAR szAttachments[]             = L"Attachment Sections";
static const WCHAR szSystemAccess[]            = L"System Access";
static const WCHAR szPrivilegeRights[]         = L"Privilege Rights";
static const WCHAR szGroupMembership[]         = L"Group Membership";
static const WCHAR szAccountProfiles[]         = L"Account Profiles";
static const WCHAR szRegistryKeys[]            = L"Registry Keys";
static const WCHAR szFileSecurity[]            = L"File Security";
static const WCHAR szDSSecurity[]              = L"DS Security";
static const WCHAR szAuditSystemLog[]          = L"System Log";
static const WCHAR szAuditSecurityLog[]        = L"Security Log";
static const WCHAR szAuditApplicationLog[]     = L"Application Log";
static const WCHAR szAuditEvent[]              = L"Event Audit";
static const WCHAR szUserList[]                = L"User List";
static const WCHAR szServiceGeneral[]          = L"Service General Setting";
static const WCHAR szKerberosPolicy[]          = L"Kerberos Policy";
static const WCHAR szRegistryValues[]          = L"Registry Values";


//
// A list of names (e.g., users, groups, machines, and etc)
//

typedef struct _SCE_NAME_LIST {
    PWSTR                  Name;
    struct _SCE_NAME_LIST   *Next;
}SCE_NAME_LIST, *PSCE_NAME_LIST;

//
// a list of accounts with privileges held
//
typedef struct _SCE_PRIVILEGE_VALUE_LIST {
    PWSTR                  Name;
    DWORD                  PrivLowPart;
    DWORD                  PrivHighPart;
    struct _SCE_PRIVILEGE_VALUE_LIST   *Next;
}SCE_PRIVILEGE_VALUE_LIST, *PSCE_PRIVILEGE_VALUE_LIST;

//
// structure for error info
//

typedef struct _SCE_ERROR_LOG_INFO{
    PWSTR  buffer;
    DWORD   rc;
    struct _SCE_ERROR_LOG_INFO *next;
} SCE_ERROR_LOG_INFO, *PSCE_ERROR_LOG_INFO;

//
// The privileges/rights each user/group holds are saved into a INT field -
// PrivilegeRights. The first bit in this field is the first right defined
// in the SCE_Privileges array as above. The second bit is the second right
// defined in that array, and so on.
//
#define cPrivCnt    37
#define cPrivW2k    34

typedef struct _SCE_PRIVILEGE_ASSIGNMENT {
    PWSTR                           Name;
    DWORD                           Value;
    // This value could be translated by SceLookupPrivByValue
    // The reason we define another set of privilege values is
    // we include both privilege and user rights into one set
    // (user rights do not have priv value on NT system).
    PSCE_NAME_LIST                   AssignedTo;
    // SCE_STATUS_GOOD
    // SCE_STATUS_MISMATCH
    // SCE_STATUS_NOT_CONFIGURED
    // SCE_DELETE_VALUE indicates that this priv is deleted from local table
    DWORD                           Status;
    struct _SCE_PRIVILEGE_ASSIGNMENT *Next;
} SCE_PRIVILEGE_ASSIGNMENT, *PSCE_PRIVILEGE_ASSIGNMENT;

//
// A list of log on hours range
//

typedef struct _SCE_LOGON_HOUR {
    DWORD                  Start;
    DWORD                  End;
    struct _SCE_LOGON_HOUR  *Next;
}SCE_LOGON_HOUR, *PSCE_LOGON_HOUR;

//
// A list of names (e.g., users, groups, machines, and etc)
// with a status (e.g., disabled )
//

typedef struct _SCE_NAME_STATUS_LIST {
    PWSTR                       Name;
    DWORD                       Status;
    struct _SCE_NAME_STATUS_LIST *Next;
}SCE_NAME_STATUS_LIST, *PSCE_NAME_STATUS_LIST;

//
// Structure definition for service list (service dll)
//


#define SCE_STARTUP_BOOT             0x00
#define SCE_STARTUP_SYSTEM           0x01
#define SCE_STARTUP_AUTOMATIC        0x02
#define SCE_STARTUP_MANUAL           0x03
#define SCE_STARTUP_DISABLED         0x04

typedef struct _SCE_SERVICES_ {
    PWSTR               ServiceName;
    PWSTR               DisplayName;

    BYTE                Status;
    BYTE                Startup;

    union {

        PSECURITY_DESCRIPTOR pSecurityDescriptor;
        PWSTR                ServiceEngineName;

    } General;

    SECURITY_INFORMATION SeInfo;

    struct _SCE_SERVICES_ *Next;

}SCE_SERVICES, *PSCE_SERVICES;

//
// Group memberships
//

#define SCE_GROUP_STATUS_MEMBERS_MISMATCH      0x01
#define SCE_GROUP_STATUS_MEMBEROF_MISMATCH     0x02
#define SCE_GROUP_STATUS_NC_MEMBERS            0x04
#define SCE_GROUP_STATUS_NC_MEMBEROF           0x08
#define SCE_GROUP_STATUS_NOT_ANALYZED          0x10
#define SCE_GROUP_STATUS_ERROR_ANALYZED        0x20


typedef struct _SCE_GROUP_MEMBERSHIP {
    PWSTR                        GroupName;
    PSCE_NAME_LIST                pMembers;
    PSCE_NAME_LIST                pMemberOf;

    DWORD                         Status;
    //
    // pPrivilegesHeld is for analysis only.
    // The format of each entry in this list is:
    //    [PrivValue NULL] (directly assigned), or
    //    [PrivValue Name] (via group "Name")
    // To configure privileges, use AREA_PRIVILEGES area
    //
    // This PrivValue could be translated by SceLookupPrivByValue
    // The reason we define another set of privilege values is
    // we include both privilege and user rights into one set
    // (user rights do not have priv value on NT system).
    PSCE_NAME_STATUS_LIST         pPrivilegesHeld;
    struct _SCE_GROUP_MEMBERSHIP  *Next;
}SCE_GROUP_MEMBERSHIP, *PSCE_GROUP_MEMBERSHIP;

//
// Definition of Registry and file security
//

typedef struct _SCE_OBJECT_SECURITY {
    PWSTR   Name;
    BYTE    Status;
    BOOL    IsContainer;
    PSECURITY_DESCRIPTOR  pSecurityDescriptor;
    SECURITY_INFORMATION  SeInfo;
//    PWSTR   SDspec;
//    DWORD   SDsize;
}SCE_OBJECT_SECURITY, *PSCE_OBJECT_SECURITY;

//
// A list of objects (e.g., files, registry keys, and etc)
//

typedef struct _SCE_OBJECT_LIST {
    PWSTR                       Name;
    BYTE                        Status;
    // Status could be the status (mismatched/unknown) of the object
    // or, it could be a flag to ignore/check this ojbect
    //
    BOOL                        IsContainer;
    DWORD                       Count;
    //  Total count of mismatched/unknown objects under this object
    struct _SCE_OBJECT_LIST *Next;
}SCE_OBJECT_LIST, *PSCE_OBJECT_LIST;

typedef struct _SCE_OBJECT_ARRAY_ {

    DWORD               Count;
    PSCE_OBJECT_SECURITY *pObjectArray;

} SCE_OBJECT_ARRAY, *PSCE_OBJECT_ARRAY;

typedef union _SCE_OBJECTS_ {
    // for Jet databases
    PSCE_OBJECT_LIST      pOneLevel;
    // for Inf files
    PSCE_OBJECT_ARRAY     pAllNodes;
} SCE_OBJECTS, *PSCE_OBJECTS;

typedef struct _SCE_OBJECT_CHILDREN_NODE {

    PWSTR               Name;
    BYTE                Status;
    BOOL                IsContainer;
    DWORD               Count;

} SCE_OBJECT_CHILDREN_NODE, *PSCE_OBJECT_CHILDREN_NODE;

typedef struct _SCE_OBJECT_CHILDREN {

    DWORD               nCount;
    DWORD               MaxCount;
    PSCE_OBJECT_CHILDREN_NODE arrObject;

} SCE_OBJECT_CHILDREN, *PSCE_OBJECT_CHILDREN;

typedef struct _SCE_KERBEROS_TICKET_INFO_ {
    DWORD   MaxTicketAge;    // in hours (default 10), SCE_NO_VALUE, SCE_FOREVER_VALUE, no 0

    DWORD   MaxRenewAge;     // in days (default 7), SCE_NO_VALUE, SCE_FOREVER_VALUE, no 0

    DWORD   MaxServiceAge;   // in minutes (default 60), SCE_NO_VALUE, 10-MaxTicketAge
    DWORD   MaxClockSkew;    // in minutes (default 5), SCE_NO_VALUE

    // options
    DWORD   TicketValidateClient; // 0, 1, or SCE_NO_VALUE

    //
    // all other options are not configurable.
    //

} SCE_KERBEROS_TICKET_INFO, *PSCE_KERBEROS_TICKET_INFO;

typedef struct _SCE_REGISTRY_VALUE_INFO_ {
    LPTSTR  FullValueName;
    LPTSTR  Value;
    DWORD   ValueType;
    DWORD   Status;  // match, mismatch, not analyzed, error

} SCE_REGISTRY_VALUE_INFO, *PSCE_REGISTRY_VALUE_INFO;

//
// Profile structure
//
typedef struct _SCE_PROFILE_INFO {

// Type is used to free the structure by SceFreeMemory
    SCETYPE      Type;
//
// Area: System access
//
    DWORD       MinimumPasswordAge;
    DWORD       MaximumPasswordAge;
    DWORD       MinimumPasswordLength;
    DWORD       PasswordComplexity;
    DWORD       PasswordHistorySize;
    DWORD       LockoutBadCount;
    DWORD       ResetLockoutCount;
    DWORD       LockoutDuration;
    DWORD       RequireLogonToChangePassword;
    DWORD       ForceLogoffWhenHourExpire;
    PWSTR       NewAdministratorName;
    PWSTR       NewGuestName;
    DWORD       SecureSystemPartition;
    DWORD       ClearTextPassword;
    DWORD       LSAAnonymousNameLookup;
    union {
        struct {
            // Area : user settings (scp)
            PSCE_NAME_LIST   pAccountProfiles;
            // Area: privileges
            // Name field is the user/group name, Status field is the privilege(s)
            //     assigned to the user/group
            union {
//                PSCE_NAME_STATUS_LIST        pPrivilegeAssignedTo;
                PSCE_PRIVILEGE_VALUE_LIST   pPrivilegeAssignedTo;
                PSCE_PRIVILEGE_ASSIGNMENT    pInfPrivilegeAssignedTo;
            } u;
        } scp;
        struct {
            // Area: user settings (sap)
            PSCE_NAME_LIST        pUserList;
            // Area: privileges
            PSCE_PRIVILEGE_ASSIGNMENT    pPrivilegeAssignedTo;
        } sap;
        struct {
            // Area: user settings (smp)
            PSCE_NAME_LIST        pUserList;
            // Area: privileges
            // See sap structure for pPrivilegeAssignedTo
            PSCE_PRIVILEGE_ASSIGNMENT    pPrivilegeAssignedTo;
        } smp;
    } OtherInfo;

// Area: group membership
    PSCE_GROUP_MEMBERSHIP        pGroupMembership;

// Area: Registry
    SCE_OBJECTS            pRegistryKeys;

// Area: System Services
    PSCE_SERVICES                pServices;

// System storage
    SCE_OBJECTS            pFiles;
//
// ds object
//
    SCE_OBJECTS            pDsObjects;
//
// kerberos policy settings
//
    PSCE_KERBEROS_TICKET_INFO pKerberosInfo;
//
// System audit 0-system 1-security 2-application
//
    DWORD                 MaximumLogSize[3];
    DWORD                 AuditLogRetentionPeriod[3];
    DWORD                 RetentionDays[3];
    DWORD                 RestrictGuestAccess[3];
    DWORD                 AuditSystemEvents;
    DWORD                 AuditLogonEvents;
    DWORD                 AuditObjectAccess;
    DWORD                 AuditPrivilegeUse;
    DWORD                 AuditPolicyChange;
    DWORD                 AuditAccountManage;
    DWORD                 AuditProcessTracking;
    DWORD                 AuditDSAccess;
    DWORD                 AuditAccountLogon;
    DWORD                 CrashOnAuditFull;

//
// registry values
//
    DWORD                       RegValueCount;
    PSCE_REGISTRY_VALUE_INFO    aRegValues;
    DWORD                 EnableAdminAccount;
    DWORD                 EnableGuestAccount;

}SCE_PROFILE_INFO, *PSCE_PROFILE_INFO;

//
// The definition for security user profile which is used to assign common
// user settings to a group of users/groups in the security manager.
//

typedef struct _SCE_USER_PROFILE {
    SCETYPE     Type;
// Type is used to free the structure by SceFreeMemory
    DWORD      ForcePasswordChange;
    DWORD      DisallowPasswordChange;
    DWORD      NeverExpirePassword;
    DWORD      AccountDisabled;
    PWSTR      UserProfile;
    PWSTR      LogonScript;
    PWSTR      HomeDir;
    PSCE_LOGON_HOUR             pLogonHours;
    UNICODE_STRING             pWorkstations;
    PSCE_NAME_LIST              pGroupsBelongsTo;
    PSCE_NAME_LIST              pAssignToUsers;
    PSECURITY_DESCRIPTOR       pHomeDirSecurity;
    SECURITY_INFORMATION       HomeSeInfo;
    PSECURITY_DESCRIPTOR       pTempDirSecurity;
    SECURITY_INFORMATION       TempSeInfo;
} SCE_USER_PROFILE, *PSCE_USER_PROFILE;

//
// The definition for each user's setting
//

typedef struct _SCE_USER_SETTING {
    SCETYPE                  Type;
// Type is used to free the structure by SceFreeMemory
    DWORD                   ForcePasswordChange;
    DWORD                   DisallowPasswordChange;
    DWORD                   NeverExpirePassword;
    DWORD                   AccountDisabled;
    PSCE_NAME_LIST           pGroupsBelongsTo;
    PWSTR                   UserProfile;
    PSECURITY_DESCRIPTOR    pProfileSecurity;
    PWSTR                   LogonScript;
    PSECURITY_DESCRIPTOR    pLogonScriptSecurity;
    PWSTR                   HomeDir;
    PSECURITY_DESCRIPTOR    pHomeDirSecurity;
    SECURITY_INFORMATION    HomeDirSeInfo;
    PWSTR                   TempDir;
    PSECURITY_DESCRIPTOR    pTempDirSecurity;
    SECURITY_INFORMATION    TempDirSeInfo;
    PSCE_LOGON_HOUR          pLogonHours;
    UNICODE_STRING          pWorkstations;
    PSCE_NAME_STATUS_LIST    pPrivilegesHeld;
    DWORD                   BadPasswordAttempt;
} SCE_USER_SETTING, *PSCE_USER_SETTING;


//
// prototypes defined in sceclnt.cpp
//

SCESTATUS
WINAPI
SceGetSecurityProfileInfo(
    IN  PVOID               hProfile OPTIONAL,
    IN  SCETYPE             ProfileType,
    IN  AREA_INFORMATION    Area,
    IN OUT PSCE_PROFILE_INFO   *ppInfoBuffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
WINAPI
SceGetObjectChildren(
    IN PVOID hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectPrefix,
    OUT PSCE_OBJECT_CHILDREN *Buffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
WINAPI
SceOpenProfile(
    IN PCWSTR ProfileName,
    IN SCE_FORMAT_TYPE  ProfileFormat,
    OUT PVOID *hProfile
    );

SCESTATUS
WINAPI
SceCloseProfile(
    IN PVOID *hProfile
    );

SCESTATUS
WINAPI
SceGetScpProfileDescription(
    IN PVOID hProfile,
    OUT PWSTR *Description
    );

SCESTATUS
WINAPI
SceGetTimeStamp(
    IN PVOID hProfile,
    OUT PWSTR *ConfigTimeStamp,
    OUT PWSTR *AnalyzeTimeStamp
    );

SCESTATUS
WINAPI
SceGetDbTime(
    IN PVOID hProfile,
    OUT SYSTEMTIME *ConfigTime,
    OUT SYSTEMTIME *AnalyzeTime
    );

SCESTATUS
WINAPI
SceGetObjectSecurity(
    IN PVOID hProfile,
    IN SCETYPE ProfileType,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectName,
    OUT PSCE_OBJECT_SECURITY *ObjSecurity
    );

SCESTATUS
WINAPI
SceGetAnalysisAreaSummary(
    IN PVOID hProfile,
    IN AREA_INFORMATION Area,
    OUT PDWORD pCount
    );

SCESTATUS
WINAPI
SceCopyBaseProfile(
    IN PVOID hProfile,
    IN SCETYPE ProfileType,
    IN PWSTR InfFileName,
    IN AREA_INFORMATION Area,
    OUT PSCE_ERROR_LOG_INFO *pErrlog OPTIONAL
    );


#define SCE_OVERWRITE_DB        0x01L
#define SCE_UPDATE_DB           0x02L
#define SCE_CALLBACK_DELTA      0x04L
#define SCE_CALLBACK_TOTAL      0x08L
#define SCE_VERBOSE_LOG         0x10L
#define SCE_DISABLE_LOG         0x20L
#define SCE_NO_CONFIG           0x40L
#define SCE_DEBUG_LOG           0x80L

typedef
BOOL(CALLBACK *PSCE_AREA_CALLBACK_ROUTINE)(
    IN HANDLE CallbackHandle,
    IN AREA_INFORMATION Area,
    IN DWORD TotalTicks,
    IN DWORD CurrentTicks
    );

typedef
BOOL(CALLBACK *PSCE_BROWSE_CALLBACK_ROUTINE)(
    IN LONG GpoID,
    IN PWSTR KeyName OPTIONAL,
    IN PWSTR GpoName OPTIONAL,
    IN PWSTR Value OPTIONAL,
    IN DWORD Len
    );

SCESTATUS
WINAPI
SceConfigureSystem(
    IN LPTSTR SystemName OPTIONAL,
    IN PCWSTR InfFileName OPTIONAL,
    IN PCWSTR DatabaseName,
    IN PCWSTR LogFileName OPTIONAL,
    IN DWORD ConfigOptions,
    IN AREA_INFORMATION Area,
    IN PSCE_AREA_CALLBACK_ROUTINE pCallback OPTIONAL,
    IN HANDLE hCallbackWnd OPTIONAL,
    OUT PDWORD pdWarning OPTIONAL
    );

SCESTATUS
WINAPI
SceAnalyzeSystem(
    IN LPTSTR SystemName OPTIONAL,
    IN PCWSTR InfFileName OPTIONAL,
    IN PCWSTR DatabaseName,
    IN PCWSTR LogFileName OPTIONAL,
    IN DWORD AnalyzeOptions,
    IN AREA_INFORMATION Area,
    IN PSCE_AREA_CALLBACK_ROUTINE pCallback OPTIONAL,
    IN HANDLE hCallbackWnd OPTIONAL,
    OUT PDWORD pdWarning OPTIONAL
    );

SCESTATUS
WINAPI
SceGenerateRollback(
    IN LPTSTR SystemName OPTIONAL,
    IN PCWSTR InfFileName,
    IN PCWSTR InfRollback,
    IN PCWSTR LogFileName OPTIONAL,
    IN DWORD Options,
    IN AREA_INFORMATION Area,
    OUT PDWORD pdWarning OPTIONAL
    );

#define SCE_UPDATE_LOCAL_POLICY     0x1L
#define SCE_UPDATE_DIRTY_ONLY       0x2L
#define SCE_UPDATE_SYSTEM           0x4L

SCESTATUS
WINAPI
SceUpdateSecurityProfile(
    IN PVOID hProfile OPTIONAL,
    IN AREA_INFORMATION Area,
    IN PSCE_PROFILE_INFO pInfo,
    IN DWORD dwMode
    );

SCESTATUS
WINAPI
SceUpdateObjectInfo(
    IN PVOID hProfile,
    IN AREA_INFORMATION Area,
    IN PWSTR ObjectName,
    IN DWORD NameLen, // number of characters
    IN BYTE ConfigStatus,
    IN BOOL  IsContainer,
    IN PSECURITY_DESCRIPTOR pSD,
    IN SECURITY_INFORMATION SeInfo,
    OUT PBYTE pAnalysisStatus
    );

SCESTATUS
WINAPI
SceStartTransaction(
    IN PVOID cxtProfile
    );

SCESTATUS
WINAPI
SceCommitTransaction(
    IN PVOID cxtProfile
    );

SCESTATUS
WINAPI
SceRollbackTransaction(
    IN PVOID cxtProfile
    );

typedef enum _SCE_SERVER_TYPE_ {

   SCESVR_UNKNOWN = 0,
   SCESVR_DC_WITH_DS,
   SCESVR_DC,
   SCESVR_NT5_SERVER,
   SCESVR_NT4_SERVER,
   SCESVR_NT5_WKS,
   SCESVR_NT4_WKS

} SCE_SERVER_TYPE, *PSCE_SERVER_TYPE;

SCESTATUS
WINAPI
SceGetServerProductType(
   IN LPTSTR SystemName OPTIONAL,
   OUT PSCE_SERVER_TYPE pServerType
   );

SCESTATUS
WINAPI
SceLookupPrivRightName(
    IN INT Priv,
    OUT PWSTR Name,
    OUT PINT NameLen
    );

SCESTATUS
WINAPI
SceSvcUpdateInfo(
    IN PVOID       hProfile,
    IN PCWSTR      ServiceName,
    IN PSCESVC_CONFIGURATION_INFO Info
    );

//
// prototype defined in infget.c
//

SCESTATUS
WINAPI
SceSvcGetInformationTemplate(
    IN LPCTSTR              TemplateName,
    IN LPCTSTR              ServiceName,
    IN LPCTSTR              Key OPTIONAL,
    OUT PSCESVC_CONFIGURATION_INFO   *ServiceInfo
    );

//
// prototypes defined in infwrite.c
//
SCESTATUS
WINAPI
SceWriteSecurityProfileInfo(
    IN  PCWSTR             InfProfileName,
    IN  AREA_INFORMATION   Area,
    IN  PSCE_PROFILE_INFO   ppInfoBuffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
WINAPI
SceAppendSecurityProfileInfo(
    IN  PCWSTR             InfProfileName,
    IN  AREA_INFORMATION   Area,
    IN  PSCE_PROFILE_INFO   ppInfoBuffer,
    OUT PSCE_ERROR_LOG_INFO *Errlog OPTIONAL
    );

SCESTATUS
WINAPI
SceSvcSetInformationTemplate(
    IN LPCTSTR          TemplateName,
    IN LPCTSTR          ServiceName,
    IN BOOL             bExact,
    IN PSCESVC_CONFIGURATION_INFO ServiceInfo
    );

//
// prototypes defined in common.cpp
//

SCESTATUS
WINAPI
SceFreeMemory(
   IN PVOID smInfo,
   IN DWORD Category
   );

BOOL
WINAPI
SceCompareNameList(
    IN PSCE_NAME_LIST pList1,
    IN PSCE_NAME_LIST pList2
    );

SCESTATUS
WINAPI
SceCompareSecurityDescriptors(
    IN AREA_INFORMATION Area,
    IN PSECURITY_DESCRIPTOR pSD1,
    IN PSECURITY_DESCRIPTOR pSD2,
    IN SECURITY_INFORMATION SeInfo,
    OUT PBOOL IsDifferent
    );

SCESTATUS
WINAPI
SceCreateDirectory(
    IN PCWSTR ProfileLocation,
    IN BOOL FileOrDir,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

SCESTATUS
WINAPI
SceFreeProfileMemory(
    PSCE_PROFILE_INFO pProfile
    );

SCESTATUS
WINAPI
SceAddToNameStatusList(
    IN OUT PSCE_NAME_STATUS_LIST *pNameStatusList,
    IN PWSTR Name,
    IN ULONG Len,
    IN DWORD Status
    );

SCESTATUS
WINAPI
SceAddToNameList(
    IN OUT PSCE_NAME_LIST *pNameList,
    IN PWSTR Name,
    IN ULONG Len
    );

#define SCE_CHECK_DUP  0x01
#define SCE_INCREASE_COUNT 0x02

SCESTATUS
WINAPI
SceAddToObjectList(
    IN OUT PSCE_OBJECT_LIST  *pObjectList,
    IN PWSTR  Name,
    IN ULONG  Len,
    IN BOOL  IsContainer,
    IN BYTE  Status,
    IN BYTE  byFlags
    );

DWORD
WINAPI
SceEnumerateServices(
    OUT PSCE_SERVICES *pServiceList,
    IN BOOL bServiceNameOnly
    );

DWORD
WINAPI
SceSetupGenerateTemplate(
    IN LPTSTR SystemName OPTIONAL,
    IN LPTSTR JetDbName OPTIONAL,
    IN BOOL bFromMergedTable,
    IN LPTSTR InfTemplateName,
    IN LPTSTR LogFileName OPTIONAL,
    IN AREA_INFORMATION Area
    );


#define SCE_REG_DISPLAY_NAME    TEXT("DisplayName")
#define SCE_REG_DISPLAY_TYPE    TEXT("DisplayType")
#define SCE_REG_VALUE_TYPE      TEXT("ValueType")
#define SCE_REG_DISPLAY_UNIT    TEXT("DisplayUnit")
#define SCE_REG_DISPLAY_CHOICES TEXT("DisplayChoices")
#define SCE_REG_DISPLAY_FLAGLIST   TEXT("DisplayFlags")

#define SCE_REG_DISPLAY_ENABLE      0
#define SCE_REG_DISPLAY_NUMBER      1
#define SCE_REG_DISPLAY_STRING      2
#define SCE_REG_DISPLAY_CHOICE      3
#define SCE_REG_DISPLAY_MULTISZ     4
#define SCE_REG_DISPLAY_FLAGS       5

DWORD
WINAPI
SceRegisterRegValues(
    IN LPTSTR InfFileName
    );

//
// for service attachments
//

SCESTATUS
WINAPI
SceSvcQueryInfo(
    IN SCE_HANDLE           sceHandle,
    IN SCESVC_INFO_TYPE     sceType,
    IN LPTSTR               lpPrefix OPTIONAL,
    IN BOOL                 bExact,
    OUT PVOID               *ppvInfo,
    OUT PSCE_ENUMERATION_CONTEXT psceEnumHandle
    );

SCESTATUS
WINAPI
SceSvcSetInfo(
    IN SCE_HANDLE           sceHandle,
    IN SCESVC_INFO_TYPE     sceType,
    IN LPTSTR               lpPrefix OPTIONAL,
    IN BOOL                 bExact,
    IN PVOID                pvInfo
    );

SCESTATUS
WINAPI
SceSvcFree(
    IN PVOID pvServiceInfo
    );

SCESTATUS
WINAPI
SceSvcConvertTextToSD (
    IN  PWSTR                   pwszTextSD,
    OUT PSECURITY_DESCRIPTOR   *ppSD,
    OUT PULONG                  pulSDSize,
    OUT PSECURITY_INFORMATION   psiSeInfo
    );

SCESTATUS
WINAPI
SceSvcConvertSDToText (
    IN PSECURITY_DESCRIPTOR   pSD,
    IN SECURITY_INFORMATION   siSecurityInfo,
    OUT PWSTR                  *ppwszTextSD,
    OUT PULONG                 pulTextSize
    );

//
// check service.cpp if the following constants are changed because
// it has a buffer length dependency
//
#define SCE_ROOT_POLICY_PATH   \
            SCE_ROOT_PATH TEXT("\\Policies")
#define SCE_ROOT_REGVALUE_PATH   \
            SCE_ROOT_PATH TEXT("\\Reg Values")

// define for GPT integration
#define GPTSCE_PATH   TEXT("Software\\Policies\\Microsoft\\Windows NT\\SecEdit")
#define GPTSCE_PERIOD_NAME  TEXT("ConfigurePeriod")
#define GPTSCE_TEMPLATE  TEXT("Microsoft\\Windows NT\\SecEdit\\GptTmpl.inf")

AREA_INFORMATION
SceGetAreas(
    LPTSTR InfName
    );

BOOL
SceIsSystemDatabase(
    IN LPCTSTR DatabaseName
    );

SCESTATUS
SceBrowseDatabaseTable(
    IN PWSTR       DatabaseName OPTIONAL,
    IN SCETYPE     ProfileType,
    IN AREA_INFORMATION Area,
    IN BOOL        bDomainPolicyOnly,
    IN PSCE_BROWSE_CALLBACK_ROUTINE pCallback OPTIONAL
    );

SCESTATUS
WINAPI
SceGetDatabaseSetting(
    IN PVOID hProfile,
    IN SCETYPE ProfileType,
    IN PWSTR SectionName,
    IN PWSTR KeyName,
    OUT PWSTR *Value,
    OUT DWORD *pnBytes OPTIONAL
    );

SCESTATUS
WINAPI
SceSetDatabaseSetting(
    IN PVOID hProfile,
    IN SCETYPE ProfileType,
    IN PWSTR SectionName,
    IN PWSTR KeyName,
    IN PWSTR Value OPTIONAL,
    IN DWORD nBytes
    );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\seclogon.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for seclogon.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __seclogon_h__
#define __seclogon_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __ISeclogon_INTERFACE_DEFINED__
#define __ISeclogon_INTERFACE_DEFINED__

/* interface ISeclogon */
/* [auto_handle][unique][version][uuid] */ 

typedef struct _SECL_STRING
    {
    unsigned long ccLength;
    unsigned long ccSize;
    /* [length_is][size_is] */ wchar_t *pwsz;
    } 	SECL_STRING;

typedef struct _SECL_STRING *PSECL_STRING;

typedef struct _SECL_BLOB
    {
    unsigned long cb;
    /* [size_is] */ unsigned char *pb;
    } 	SECL_BLOB;

typedef struct _SECL_BLOB *PSECL_BLOB;

typedef struct _SECL_SLI
    {
    SECL_STRING ssUsername;
    SECL_STRING ssDomain;
    SECL_STRING ssPassword;
    SECL_STRING ssApplicationName;
    SECL_STRING ssCommandLine;
    SECL_STRING ssCurrentDirectory;
    SECL_STRING ssTitle;
    SECL_STRING ssDesktop;
    SECL_BLOB sbEnvironment;
    unsigned long ulProcessId;
    unsigned long ulLogonIdLowPart;
    long lLogonIdHighPart;
    unsigned long ulLogonFlags;
    unsigned long ulCreationFlags;
    unsigned long ulSeclogonFlags;
    unsigned __int64 hWinsta;
    unsigned __int64 hDesk;
    } 	SECL_SLI;

typedef struct _SECL_SLI *PSECL_SLI;

typedef struct _SECL_SLRI
    {
    unsigned __int64 hProcess;
    unsigned __int64 hThread;
    unsigned long ulProcessId;
    unsigned long ulThreadId;
    unsigned long ulErrorCode;
    } 	SECL_SLRI;

typedef struct _SECL_SLRI *PSECL_SLRI;

void SeclCreateProcessWithLogonW( 
    /* [in] */ handle_t hRPCBinding,
    /* [ref][in] */ SECL_SLI *psli,
    /* [ref][out] */ SECL_SLRI *pslri);



extern RPC_IF_HANDLE ISeclogon_v1_0_c_ifspec;
extern RPC_IF_HANDLE ISeclogon_v1_0_s_ifspec;
#endif /* __ISeclogon_INTERFACE_DEFINED__ */

/* interface __MIDL_itf_seclogon_0001 */
/* [local] */ 

#define wszSeclogonSharedProcEndpointName L"SECLOGON"
#define wszSvcName                        L"seclogon"
#define SECLOGON_CALLER_SPECIFIED_DESKTOP   0x00000001


extern RPC_IF_HANDLE __MIDL_itf_seclogon_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_seclogon_0001_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\secobj.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    secobj.h

Abstract:

    This header file defines the structures and function prototypes of
    routines which simplify the creation of security descriptors for
    user-mode objects.

Author:

    Rita Wong (ritaw) 27-Feb-1991

Revision History:

--*/

#ifndef _SECOBJ_INCLUDED_
#define _SECOBJ_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

//
// Global declarations
//

//
// NT well-known SIDs
//

extern PSID NullSid;                   // No members SID
extern PSID WorldSid;                  // All users SID
extern PSID LocalSid;                  // NT local users SID
extern PSID NetworkSid;                // NT remote users SID
extern PSID LocalSystemSid;            // NT system processes SID
extern PSID BuiltinDomainSid;          // Domain Id of the Builtin Domain
extern PSID AuthenticatedUserSid;      // Authenticated user SID
extern PSID AnonymousLogonSid;         // Anonymous Logon SID
extern PSID LocalServiceSid;           // NT service processes SID

//
// Well Known Aliases.
//
// These are aliases that are relative to the built-in domain.
//

extern PSID LocalAdminSid;             // NT local admins SID
extern PSID AliasAdminsSid;            // Administrator Sid
extern PSID AliasUsersSid;             // User Sid
extern PSID AliasGuestsSid;            // Guest Sid
extern PSID AliasPowerUsersSid;        // Power User Sid
extern PSID AliasAccountOpsSid;        // Account Operator Sid
extern PSID AliasSystemOpsSid;         // System Operator Sid
extern PSID AliasPrintOpsSid;          // Print Operator Sid
extern PSID AliasBackupOpsSid;         // Backup Operator Sid


//
// Structure to hold information about an ACE to be created
//

typedef struct {
    UCHAR AceType;
    UCHAR InheritFlags;
    UCHAR AceFlags;
    ACCESS_MASK Mask;
    PSID *Sid;
} ACE_DATA, *PACE_DATA;

//
// Function prototypes
//

NTSTATUS
NetpCreateWellKnownSids(
    PSID DomainId
    );

VOID
NetpFreeWellKnownSids(
    VOID
    );

NTSTATUS
NetpAllocateAndInitializeSid(
    OUT PSID *Sid,
    IN  PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN  ULONG SubAuthorityCount
);

NET_API_STATUS
NetpDomainIdToSid(
    IN PSID DomainId,
    IN ULONG RelativeId,
    OUT PSID *Sid
    );

NTSTATUS
NetpCreateSecurityDescriptor(
    IN  PACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid,
    IN  PSID GroupSid,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );

NTSTATUS
NetpCreateSecurityObject(
    IN  PACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid,
    IN  PSID GroupSid,
    IN  PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );

NTSTATUS
NetpDeleteSecurityObject(
    IN PSECURITY_DESCRIPTOR *Descriptor
    );

NET_API_STATUS
NetpAccessCheckAndAudit(
    IN  LPTSTR SubsystemName,
    IN  LPTSTR ObjectTypeName,
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    );

NET_API_STATUS
NetpAccessCheck(
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    );

NET_API_STATUS
NetpGetBuiltinDomainSID(
    PSID *BuiltinDomainSID
    );

#ifdef __cplusplus
}       // extern "C"
#endif

#endif // ifndef _SECOBJ_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\secint.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991-1999
//
// File:        Secint.h
//
// Contents:    Toplevel include file for security aware system components
//
//
// History:     14-April-1998   MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __SECINT_H__
#define __SECINT_H__

#if _MSC_VER > 1000
#pragma once
#endif

//
// NOTE:  Update this section if you add new files:
//
// SECURITY_PACKAGE     Include defines necessary for security packages
// SECURITY_KERBEROS    Include everything needed to talk to the kerberos pkg.
// SECURITY_NTLM        Include everything to talk to ntlm package.

//
// Each of the files included here are surrounded by guards, so you don't
// need to worry about including this file multiple times with different
// flags defined
//



#if !defined(_NTSRV_) && !defined(_NTIFS_)
// begin_ntifs

#ifndef SECURITY_USER_DATA_DEFINED
#define SECURITY_USER_DATA_DEFINED

typedef struct _SECURITY_USER_DATA {
    SECURITY_STRING UserName;           // User name
    SECURITY_STRING LogonDomainName;    // Domain the user logged on to
    SECURITY_STRING LogonServer;        // Server that logged the user on
    PSID            pSid;               // SID of user
} SECURITY_USER_DATA, *PSECURITY_USER_DATA;

typedef SECURITY_USER_DATA SecurityUserData, * PSecurityUserData;


#define UNDERSTANDS_LONG_NAMES  1
#define NO_LONG_NAMES           2

#endif // SECURITY_USER_DATA_DEFINED

HRESULT SEC_ENTRY
GetSecurityUserInfo(
    IN PLUID LogonId,
    IN ULONG Flags,
    OUT PSecurityUserData * UserInformation
    );

SECURITY_STATUS SEC_ENTRY
MapSecurityError( SECURITY_STATUS SecStatus );

// end_ntifs

#endif //  !define(_NTSRV_) && !defined(_NTIFS_)

BOOLEAN
SEC_ENTRY
SecGetLocaleSpecificEncryptionRules(
    BOOLEAN * Permitted
    );


// Include security package headers:

#ifdef SECURITY_PACKAGE

#include <secpkg.h>

#endif  // SECURITY_PACKAGE


#ifdef SECURITY_KERBEROS

#include <kerberos.h>

#endif

#ifdef SECURITY_NTLM

#include <ntlmsp.h>

#endif // SECURITY_NTLM


SECURITY_STATUS
SEC_ENTRY
KSecValidateBuffer(
    PUCHAR Buffer,
    ULONG Length
    );

#endif // __SECINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\shutimp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    shutimp.h

Abstract:

    This file allows us to include standard system header files in the
    shutinit.idl file.  The shutinit.idl file imports a file called
    shutimp.idl.  This allows the shutinit.idl file to use the types defined
    in these header files.  It also causes the following line to be added
    in the MIDL generated header file:

    #include "shutimp.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dragos C. Sambotin (dragoss) 21-May-1999

--*/

#ifndef __SHUTIMP_H__
#define __SHUTIMP_H__

#include <windef.h>

#define SHUTDOWN_INTERFACE_NAME  L"InitShutdown"

#endif //__SHUTIMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\shutinit.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for shutinit.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __shutinit_h__
#define __shutinit_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "shutimp.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __InitShutdown_INTERFACE_DEFINED__
#define __InitShutdown_INTERFACE_DEFINED__

/* interface InitShutdown */
/* [auto_handle][version][unique][uuid] */ 

typedef /* [handle] */ PWCHAR PREGISTRY_SERVER_NAME;

typedef struct _REG_UNICODE_STRING
    {
    USHORT Length;
    USHORT MaximumLength;
    /* [length_is][size_is] */ USHORT *Buffer;
    } 	*PREG_UNICODE_STRING;

ULONG BaseInitiateShutdown( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName,
    /* [unique][in] */ PREG_UNICODE_STRING lpMessage,
    /* [in] */ DWORD dwTimeout,
    /* [in] */ BOOLEAN bForceAppsClosed,
    /* [in] */ BOOLEAN bRebootAfterShutdown);

ULONG BaseAbortShutdown( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName);

ULONG BaseInitiateShutdownEx( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName,
    /* [unique][in] */ PREG_UNICODE_STRING lpMessage,
    /* [in] */ DWORD dwTimeout,
    /* [in] */ BOOLEAN bForceAppsClosed,
    /* [in] */ BOOLEAN bRebootAfterShutdown,
    /* [in] */ DWORD dwReason);



extern RPC_IF_HANDLE InitShutdown_ClientIfHandle;
extern RPC_IF_HANDLE InitShutdown_ServerIfHandle;
#endif /* __InitShutdown_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

handle_t __RPC_USER PREGISTRY_SERVER_NAME_bind  ( PREGISTRY_SERVER_NAME );
void     __RPC_USER PREGISTRY_SERVER_NAME_unbind( PREGISTRY_SERVER_NAME, handle_t );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\setup_browser.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    setup_browser.c

Abstract:

    This is used by syssetup to enable net browser.  It's generated from various files under
    ds\netapi\svcdlls\bworser\common.  Do not edit by hand.

Revision History:

--*/

#include <lmcons.h>                 // NET_API_STATUS
#include <lmerr.h>                  // NetError codes
#include <ntddbrow.h>
#include <netlibnt.h>               // NetpNtStatusToApiStatus
#include <align.h>

#define NetpAssert(x)



//
// Buffer allocation size for enumeration output buffer.
//
#define INITIAL_ALLOCATION_SIZE  48*1024  // First attempt size (48K)
#define FUDGE_FACTOR_SIZE        1024  // Second try TotalBytesNeeded
                                       //     plus this amount

//
// prototypes
//

#ifdef ENABLE_PSEUDO_BROWSER
DWORD
IsBrowserEnabled(
    IN  OPTIONAL    LPTSTR  Section,
    IN              LPTSTR  Key,
    IN              BOOL    fDefault
    );

DWORD
GetBrowserValue(
    IN  OPTIONAL    LPTSTR  Section,
    IN              LPTSTR  Key,
    OUT             PDWORD pdwValue
    );
#endif


//
// Implementation
//

NET_API_STATUS
BrDgReceiverIoControl(
    IN  HANDLE FileHandle,
    IN  ULONG DgReceiverControlCode,
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  ULONG DrpSize,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    )
/*++

Routine Description:

Arguments:

    FileHandle - Supplies a handle to the file or device on which the service
        is being performed.

    DgReceiverControlCode - Supplies the NtDeviceIoControlFile function code
        given to the datagram receiver.

    Drp - Supplies the datagram receiver request packet.

    DrpSize - Supplies the length of the datagram receiver request packet.

    SecondBuffer - Supplies the second buffer in call to NtDeviceIoControlFile.

    SecondBufferLength - Supplies the length of the second buffer.

    Information - Returns the information field of the I/O status block.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{
    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    PLMDR_REQUEST_PACKET RealDrp;
    HANDLE CompletionEvent;
    LPBYTE Where;

    if (FileHandle == NULL) {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Allocate a copy of the request packet where we can put the transport and
    //  emulated domain name in the packet itself.
    //
    RealDrp = (PLMDR_REQUEST_PACKET) MIDL_user_allocate(DrpSize+
                                 Drp->TransportName.Length+sizeof(WCHAR)+
                                 Drp->EmulatedDomainName.Length+sizeof(WCHAR) );

    if (RealDrp == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy the request packet into the local copy.
    //
    RtlCopyMemory(RealDrp, Drp, DrpSize);

    Where = (LPBYTE)RealDrp+DrpSize;
    if (Drp->TransportName.Length != 0) {
        RealDrp->TransportName.Buffer = (LPWSTR)Where;
        RealDrp->TransportName.MaximumLength = Drp->TransportName.Length+sizeof(WCHAR);
        RtlCopyUnicodeString(&RealDrp->TransportName, &Drp->TransportName);
        Where += RealDrp->TransportName.MaximumLength;
    }

    if (Drp->EmulatedDomainName.Length != 0) {
        RealDrp->EmulatedDomainName.Buffer = (LPWSTR)Where;
        RealDrp->EmulatedDomainName.MaximumLength = Drp->EmulatedDomainName.Length+sizeof(WCHAR);
        RtlCopyUnicodeString(&RealDrp->EmulatedDomainName, &Drp->EmulatedDomainName);
        Where += RealDrp->EmulatedDomainName.MaximumLength;
    }



    //
    // Create a completion event
    //
    CompletionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (CompletionEvent == NULL) {

        MIDL_user_free(RealDrp);

        return(GetLastError());
    }

    //
    // Send the request to the Datagram Receiver DD.
    //

    ntstatus = NtDeviceIoControlFile(
                   FileHandle,
                   CompletionEvent,
                   NULL,
                   NULL,
                   &IoStatusBlock,
                   DgReceiverControlCode,
                   RealDrp,
                   (ULONG)(Where-(LPBYTE)RealDrp),
                   SecondBuffer,
                   SecondBufferLength
                   );

    if (NT_SUCCESS(ntstatus)) {

        //
        //  If pending was returned, then wait until the request completes.
        //

        if (ntstatus == STATUS_PENDING) {

            do {
                ntstatus = WaitForSingleObjectEx(CompletionEvent, 0xffffffff, TRUE);
            } while ( ntstatus == WAIT_IO_COMPLETION );
        }


        if (NT_SUCCESS(ntstatus)) {
            ntstatus = IoStatusBlock.Status;
        }
    }

    if (ARGUMENT_PRESENT(Information)) {
        *Information = (ULONG)IoStatusBlock.Information;
    }

    MIDL_user_free(RealDrp);

    CloseHandle(CompletionEvent);

    return NetpNtStatusToApiStatus(ntstatus);
}

NET_API_STATUS
DeviceControlGetInfo(
    IN  HANDLE FileHandle,
    IN  ULONG DeviceControlCode,
    IN  PVOID RequestPacket,
    IN  ULONG RequestPacketLength,
    OUT LPVOID *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize,
    OUT PULONG Information OPTIONAL
    )
/*++

Routine Description:

    This function allocates the buffer and fill it with the information
    that is retrieved from the datagram receiver.

Arguments:

    DeviceDriverType - Supplies the value which indicates whether to call
        the datagram receiver.

    FileHandle - Supplies a handle to the file or device of which to get
        information about.

    DeviceControlCode - Supplies the NtFsControlFile or NtIoDeviceControlFile
        function control code.

    RequestPacket - Supplies a pointer to the device request packet.

    RrequestPacketLength - Supplies the length of the device request packet.

    OutputBuffer - Returns a pointer to the buffer allocated by this routine
        which contains the use information requested.  This pointer is set to
         NULL if return code is not NERR_Success.

    PreferedMaximumLength - Supplies the number of bytes of information to
        return in the buffer.  If this value is MAXULONG, we will try to
        return all available information if there is enough memory resource.

    BufferHintSize - Supplies the hint size of the output buffer so that the
        memory allocated for the initial buffer will most likely be large
        enough to hold all requested data.

    Information - Returns the information code from the NtFsControlFile or
        NtIoDeviceControlFile call.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    NTSTATUS ntstatus;
    DWORD OutputBufferLength;
    DWORD TotalBytesNeeded = 1;
    ULONG OriginalResumeKey;
    IO_STATUS_BLOCK IoStatusBlock;
    PLMDR_REQUEST_PACKET Drrp = (PLMDR_REQUEST_PACKET) RequestPacket;
    HANDLE CompletionEvent;

    OriginalResumeKey = Drrp->Parameters.EnumerateNames.ResumeHandle;

    //
    // If PreferedMaximumLength is MAXULONG, then we are supposed to get all
    // the information, regardless of size.  Allocate the output buffer of a
    // reasonable size and try to use it.  If this fails, the Redirector FSD
    // will say how much we need to allocate.
    //
    if (PreferedMaximumLength == MAXULONG) {
        OutputBufferLength = (BufferHintSize) ?
                             BufferHintSize :
                             INITIAL_ALLOCATION_SIZE;
    }
    else {
        OutputBufferLength = PreferedMaximumLength;
    }

    OutputBufferLength = ROUND_UP_COUNT(OutputBufferLength, ALIGN_WCHAR);

    if ((*OutputBuffer = MIDL_user_allocate(OutputBufferLength)) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory((PVOID) *OutputBuffer, OutputBufferLength);

    CompletionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (CompletionEvent == NULL) {
        MIDL_user_free(*OutputBuffer);
        *OutputBuffer = NULL;
        return(GetLastError());
    }

    Drrp->Parameters.EnumerateServers.EntriesRead = 0;

    //
    // Make the request of the Datagram Receiver
    //

    ntstatus = NtDeviceIoControlFile(
                     FileHandle,
                     CompletionEvent,
                     NULL,              // APC routine
                     NULL,              // APC context
                     &IoStatusBlock,
                     DeviceControlCode,
                     Drrp,
                     RequestPacketLength,
                     *OutputBuffer,
                     OutputBufferLength
                     );

    if (NT_SUCCESS(ntstatus)) {

        //
        //  If pending was returned, then wait until the request completes.
        //

        if (ntstatus == STATUS_PENDING) {
            do {
                ntstatus = WaitForSingleObjectEx(CompletionEvent, 0xffffffff, TRUE);
            } while ( ntstatus == WAIT_IO_COMPLETION );
        }

        if (NT_SUCCESS(ntstatus)) {
            ntstatus = IoStatusBlock.Status;
        }
    }

    //
    // Map NT status to Win error
    //
    status = NetpNtStatusToApiStatus(ntstatus);

    if (status == ERROR_MORE_DATA) {

        NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.TotalBytesNeeded
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.TotalBytesNeeded
                    )
                );

        NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.GetBrowserServerList.TotalBytesNeeded
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.TotalBytesNeeded
                    )
                );

        TotalBytesNeeded = Drrp->Parameters.EnumerateNames.TotalBytesNeeded;
    }

    if ((TotalBytesNeeded > OutputBufferLength) &&
        (PreferedMaximumLength == MAXULONG)) {
        PLMDR_REQUEST_PACKET Drrp = (PLMDR_REQUEST_PACKET) RequestPacket;

        //
        // Initial output buffer allocated was too small and we need to return
        // all data.  First free the output buffer before allocating the
        // required size plus a fudge factor just in case the amount of data
        // grew.
        //

        MIDL_user_free(*OutputBuffer);

        OutputBufferLength =
            ROUND_UP_COUNT((TotalBytesNeeded + FUDGE_FACTOR_SIZE),
                           ALIGN_WCHAR);

        if ((*OutputBuffer = MIDL_user_allocate(OutputBufferLength)) == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        RtlZeroMemory((PVOID) *OutputBuffer, OutputBufferLength);


        NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.ResumeHandle
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.ResumeHandle
                    )
                );

        NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.ResumeHandle
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.GetBrowserServerList.ResumeHandle
                    )
                );

        Drrp->Parameters.EnumerateNames.ResumeHandle = OriginalResumeKey;
        Drrp->Parameters.EnumerateServers.EntriesRead = 0;

        //
        //  Make the request of the Datagram Receiver
        //

        ntstatus = NtDeviceIoControlFile(
                         FileHandle,
                         CompletionEvent,
                         NULL,              // APC routine
                         NULL,              // APC context
                         &IoStatusBlock,
                         DeviceControlCode,
                         Drrp,
                         RequestPacketLength,
                         *OutputBuffer,
                         OutputBufferLength
                         );

        if (NT_SUCCESS(ntstatus)) {

            //
            //  If pending was returned, then wait until the request completes.
            //

            if (ntstatus == STATUS_PENDING) {
                do {
                    ntstatus = WaitForSingleObjectEx(CompletionEvent, 0xffffffff, TRUE);
                } while ( ntstatus == WAIT_IO_COMPLETION );
            }

            if (NT_SUCCESS(ntstatus)) {
                ntstatus = IoStatusBlock.Status;
            }
        }

        status = NetpNtStatusToApiStatus(ntstatus);

    }


    //
    // If not successful in getting any data, or if the caller asked for
    // all available data with PreferedMaximumLength == MAXULONG and
    // our buffer overflowed, free the output buffer and set its pointer
    // to NULL.
    //
    if ((status != NERR_Success && status != ERROR_MORE_DATA) ||
        (TotalBytesNeeded == 0) ||
        (PreferedMaximumLength == MAXULONG && status == ERROR_MORE_DATA) ||
        (Drrp->Parameters.EnumerateServers.EntriesRead == 0)) {

        MIDL_user_free(*OutputBuffer);
        *OutputBuffer = NULL;

        //
        // PreferedMaximumLength == MAXULONG and buffer overflowed means
        // we do not have enough memory to satisfy the request.
        //
        if (status == ERROR_MORE_DATA) {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    CloseHandle(CompletionEvent);

    return status;

    UNREFERENCED_PARAMETER(Information);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\shutinit_c.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for shutinit.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#include <string.h>

#include "shutinit.h"

#define TYPE_FORMAT_STRING_SIZE   51                                
#define PROC_FORMAT_STRING_SIZE   181                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

#define GENERIC_BINDING_TABLE_SIZE   1            


/* Standard interface: InitShutdown, ver. 1.0,
   GUID={0x894de0c0,0x0d55,0x11d3,{0xa3,0x22,0x00,0xc0,0x4f,0xa3,0x21,0xa1}} */



static const RPC_CLIENT_INTERFACE InitShutdown___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x894de0c0,0x0d55,0x11d3,{0xa3,0x22,0x00,0xc0,0x4f,0xa3,0x21,0xa1}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    0,
    0,
    0,
    0,
    0,
    0x00000000
    };
RPC_IF_HANDLE InitShutdown_ClientIfHandle = (RPC_IF_HANDLE)& InitShutdown___RpcClientInterface;

extern const MIDL_STUB_DESC InitShutdown_StubDesc;

static RPC_BINDING_HANDLE InitShutdown__MIDL_AutoBindHandle;


ULONG BaseInitiateShutdown( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName,
    /* [unique][in] */ PREG_UNICODE_STRING lpMessage,
    /* [in] */ DWORD dwTimeout,
    /* [in] */ BOOLEAN bForceAppsClosed,
    /* [in] */ BOOLEAN bRebootAfterShutdown)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&InitShutdown_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  ( unsigned char * )&ServerName);
    return ( ULONG  )_RetVal.Simple;
    
}


ULONG BaseAbortShutdown( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&InitShutdown_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[66],
                  ( unsigned char * )&ServerName);
    return ( ULONG  )_RetVal.Simple;
    
}


ULONG BaseInitiateShutdownEx( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName,
    /* [unique][in] */ PREG_UNICODE_STRING lpMessage,
    /* [in] */ DWORD dwTimeout,
    /* [in] */ BOOLEAN bForceAppsClosed,
    /* [in] */ BOOLEAN bRebootAfterShutdown,
    /* [in] */ DWORD dwReason)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&InitShutdown_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[108],
                  ( unsigned char * )&ServerName);
    return ( ULONG  )_RetVal.Simple;
    
}

extern const GENERIC_BINDING_ROUTINE_PAIR BindingRoutines[ GENERIC_BINDING_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure BaseInitiateShutdown */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 10 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 12 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 14 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 16 */	NdrFcShort( 0x2c ),	/* 44 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 22 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x1 ),	/* 1 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 30 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 32 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 34 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter lpMessage */

/* 36 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 38 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 40 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter dwTimeout */

/* 42 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 44 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 46 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bForceAppsClosed */

/* 48 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 50 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 52 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter bRebootAfterShutdown */

/* 54 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 56 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 58 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 60 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 62 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 64 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure BaseAbortShutdown */

/* 66 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 68 */	NdrFcLong( 0x0 ),	/* 0 */
/* 72 */	NdrFcShort( 0x1 ),	/* 1 */
/* 74 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 76 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 78 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 80 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 82 */	NdrFcShort( 0x1a ),	/* 26 */
/* 84 */	NdrFcShort( 0x8 ),	/* 8 */
/* 86 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 88 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 90 */	NdrFcShort( 0x0 ),	/* 0 */
/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 96 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 98 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 100 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Return value */

/* 102 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 104 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 106 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure BaseInitiateShutdownEx */

/* 108 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 110 */	NdrFcLong( 0x0 ),	/* 0 */
/* 114 */	NdrFcShort( 0x2 ),	/* 2 */
/* 116 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 118 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 120 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 122 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 124 */	NdrFcShort( 0x34 ),	/* 52 */
/* 126 */	NdrFcShort( 0x8 ),	/* 8 */
/* 128 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 130 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x1 ),	/* 1 */
/* 136 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 138 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 140 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 142 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter lpMessage */

/* 144 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 146 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 148 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter dwTimeout */

/* 150 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 152 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bForceAppsClosed */

/* 156 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 158 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 160 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter bRebootAfterShutdown */

/* 162 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 164 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 166 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter dwReason */

/* 168 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 170 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 172 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 174 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 176 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 178 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  4 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x12, 0x0,	/* FC_UP */
/*  8 */	NdrFcShort( 0x14 ),	/* Offset= 20 (28) */
/* 10 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 12 */	NdrFcShort( 0x2 ),	/* 2 */
/* 14 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 16 */	NdrFcShort( 0x2 ),	/* 2 */
/* 18 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 20 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 26 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 28 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 30 */	NdrFcShort( 0x8 ),	/* 8 */
/* 32 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 34 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 36 */	NdrFcShort( 0x4 ),	/* 4 */
/* 38 */	NdrFcShort( 0x4 ),	/* 4 */
/* 40 */	0x12, 0x0,	/* FC_UP */
/* 42 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (10) */
/* 44 */	
			0x5b,		/* FC_END */

			0x6,		/* FC_SHORT */
/* 46 */	0x6,		/* FC_SHORT */
			0x8,		/* FC_LONG */
/* 48 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */

			0x0
        }
    };

static const GENERIC_BINDING_ROUTINE_PAIR BindingRoutines[ GENERIC_BINDING_TABLE_SIZE ] = 
        {
        {
            (GENERIC_BINDING_ROUTINE)PREGISTRY_SERVER_NAME_bind,
            (GENERIC_UNBIND_ROUTINE)PREGISTRY_SERVER_NAME_unbind
         }
        
        };


static const unsigned short InitShutdown_FormatStringOffsetTable[] =
    {
    0,
    66,
    108
    };


static const MIDL_STUB_DESC InitShutdown_StubDesc = 
    {
    (void *)& InitShutdown___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &InitShutdown__MIDL_AutoBindHandle,
    0,
    BindingRoutines,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC client stubs */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for shutinit.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#include <string.h>

#include "shutinit.h"

#define TYPE_FORMAT_STRING_SIZE   47                                
#define PROC_FORMAT_STRING_SIZE   187                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

#define GENERIC_BINDING_TABLE_SIZE   1            


/* Standard interface: InitShutdown, ver. 1.0,
   GUID={0x894de0c0,0x0d55,0x11d3,{0xa3,0x22,0x00,0xc0,0x4f,0xa3,0x21,0xa1}} */



static const RPC_CLIENT_INTERFACE InitShutdown___RpcClientInterface =
    {
    sizeof(RPC_CLIENT_INTERFACE),
    {{0x894de0c0,0x0d55,0x11d3,{0xa3,0x22,0x00,0xc0,0x4f,0xa3,0x21,0xa1}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    0,
    0,
    0,
    0,
    0,
    0x00000000
    };
RPC_IF_HANDLE InitShutdown_ClientIfHandle = (RPC_IF_HANDLE)& InitShutdown___RpcClientInterface;

extern const MIDL_STUB_DESC InitShutdown_StubDesc;

static RPC_BINDING_HANDLE InitShutdown__MIDL_AutoBindHandle;


ULONG BaseInitiateShutdown( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName,
    /* [unique][in] */ PREG_UNICODE_STRING lpMessage,
    /* [in] */ DWORD dwTimeout,
    /* [in] */ BOOLEAN bForceAppsClosed,
    /* [in] */ BOOLEAN bRebootAfterShutdown)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&InitShutdown_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0],
                  ServerName,
                  lpMessage,
                  dwTimeout,
                  bForceAppsClosed,
                  bRebootAfterShutdown);
    return ( ULONG  )_RetVal.Simple;
    
}


ULONG BaseAbortShutdown( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&InitShutdown_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[68],
                  ServerName);
    return ( ULONG  )_RetVal.Simple;
    
}


ULONG BaseInitiateShutdownEx( 
    /* [unique][in] */ PREGISTRY_SERVER_NAME ServerName,
    /* [unique][in] */ PREG_UNICODE_STRING lpMessage,
    /* [in] */ DWORD dwTimeout,
    /* [in] */ BOOLEAN bForceAppsClosed,
    /* [in] */ BOOLEAN bRebootAfterShutdown,
    /* [in] */ DWORD dwReason)
{

    CLIENT_CALL_RETURN _RetVal;

    _RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&InitShutdown_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[112],
                  ServerName,
                  lpMessage,
                  dwTimeout,
                  bForceAppsClosed,
                  bRebootAfterShutdown,
                  dwReason);
    return ( ULONG  )_RetVal.Simple;
    
}

extern const GENERIC_BINDING_ROUTINE_PAIR BindingRoutines[ GENERIC_BINDING_TABLE_SIZE ];

#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure BaseInitiateShutdown */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 10 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 12 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 14 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 16 */	NdrFcShort( 0x2c ),	/* 44 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 22 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x1 ),	/* 1 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 32 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 34 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 36 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter lpMessage */

/* 38 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 40 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 42 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter dwTimeout */

/* 44 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 46 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 48 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bForceAppsClosed */

/* 50 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 52 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 54 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter bRebootAfterShutdown */

/* 56 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 58 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 60 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Return value */

/* 62 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 64 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 66 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure BaseAbortShutdown */

/* 68 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 70 */	NdrFcLong( 0x0 ),	/* 0 */
/* 74 */	NdrFcShort( 0x1 ),	/* 1 */
/* 76 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 78 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 80 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 82 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 84 */	NdrFcShort( 0x1a ),	/* 26 */
/* 86 */	NdrFcShort( 0x8 ),	/* 8 */
/* 88 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 90 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 92 */	NdrFcShort( 0x0 ),	/* 0 */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
/* 98 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 100 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 102 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 104 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Return value */

/* 106 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 108 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 110 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure BaseInitiateShutdownEx */

/* 112 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 114 */	NdrFcLong( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0x2 ),	/* 2 */
/* 120 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 122 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 124 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 126 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 128 */	NdrFcShort( 0x34 ),	/* 52 */
/* 130 */	NdrFcShort( 0x8 ),	/* 8 */
/* 132 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 134 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 136 */	NdrFcShort( 0x0 ),	/* 0 */
/* 138 */	NdrFcShort( 0x1 ),	/* 1 */
/* 140 */	NdrFcShort( 0x0 ),	/* 0 */
/* 142 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 144 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 146 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 148 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter lpMessage */

/* 150 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 152 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 154 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter dwTimeout */

/* 156 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 158 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 160 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter bForceAppsClosed */

/* 162 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 164 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 166 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter bRebootAfterShutdown */

/* 168 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 170 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 172 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter dwReason */

/* 174 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 176 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 178 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 180 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 182 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  4 */	0x5,		/* FC_WCHAR */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x12, 0x0,	/* FC_UP */
/*  8 */	NdrFcShort( 0x14 ),	/* Offset= 20 (28) */
/* 10 */	
			0x1c,		/* FC_CVARRAY */
			0x1,		/* 1 */
/* 12 */	NdrFcShort( 0x2 ),	/* 2 */
/* 14 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 16 */	NdrFcShort( 0x2 ),	/* 2 */
/* 18 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 20 */	0x17,		/* Corr desc:  field pointer, FC_USHORT */
			0x55,		/* FC_DIV_2 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 26 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 28 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 30 */	NdrFcShort( 0x10 ),	/* 16 */
/* 32 */	NdrFcShort( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0x8 ),	/* Offset= 8 (42) */
/* 36 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 38 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 40 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 42 */	
			0x12, 0x0,	/* FC_UP */
/* 44 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (10) */

			0x0
        }
    };

static const GENERIC_BINDING_ROUTINE_PAIR BindingRoutines[ GENERIC_BINDING_TABLE_SIZE ] = 
        {
        {
            (GENERIC_BINDING_ROUTINE)PREGISTRY_SERVER_NAME_bind,
            (GENERIC_UNBIND_ROUTINE)PREGISTRY_SERVER_NAME_unbind
         }
        
        };


static const unsigned short InitShutdown_FormatStringOffsetTable[] =
    {
    0,
    68,
    112
    };


static const MIDL_STUB_DESC InitShutdown_StubDesc = 
    {
    (void *)& InitShutdown___RpcClientInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    &InitShutdown__MIDL_AutoBindHandle,
    0,
    BindingRoutines,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\tstring.h ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    tstring.h

Abstract:

    This include file contains manifests and macros to be used to integrate
    the TCHAR and LPTSTR definitions

    Note that our naming convention is that a "size" indicates a number of
    bytes whereas a "length" indicates a number of characters.

Author:

    Richard Firth (rfirth) 02-Apr-1991

Environment:

    Portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names,
    _ultoa() routine.

Revision History:

    22-May-1991 Danl
        Added STRSIZE macro
    19-May-1991 JohnRo
        Changed some parm names to make things easier to read.
    15-May-1991 rfirth
        Added TCHAR_SPACE and MAKE_TCHAR() macro
    15-Jul-1991 RFirth
        Added STRING_SPACE_REQD() and DOWN_LEVEL_STRSIZE
    05-Aug-1991 JohnRo
        Added MEMCPY macro.
    19-Aug-1991 JohnRo
        Added character type stuff: ISDIGIT(), TOUPPER(), etc.
    20-Aug-1991 JohnRo
        Changed strnicmp to _strnicmp to keep PC-LINT happy.  Ditto stricmp.
    13-Sep-1991 JohnRo
        Need UNICODE STRSIZE() too.
    13-Sep-1991 JohnRo
        Added UNICODE STRCMP() and various others.
    18-Oct-1991 JohnRo
        Added NetpCopy routines and WCSSIZE().
    26-Nov-1991 JohnRo
        Added NetpNCopy routines (like strncpy but do conversions as well).
    09-Dec-1991 rfirth
        Added STRREV
    03-Jan-1992 JohnRo
        Added NetpAlloc{type}From{type} routines and macros.
    09-Jan-1992 JohnRo
        Added ATOL() macro and wtol() routine.
        Ditto ULTOA() macro and ultow() routine.
    13-Jan-1992 JohnRo
        Oops, I missed from NetpAlloc{type}From{type} macros
        Also added STRNCMPI as an alias for STRNICMP.
    16-Jan-1992 Danl
        Moved the macros to \private\inc\tstr.h
    23-Mar-1992 JohnRo
        Added NetpCopy{Str,TStr,WStr}ToUnalignedWStr().
    27-Apr-1992 JohnRo
        Changed NetpNCopy{type}From{type} to return NET_API_STATUS.
    03-Aug-1992 JohnRo
        RAID 1895: Net APIs and svcs should use OEM char set.
    14-Apr-1993 JohnRo
        RAID 6113 ("PortUAS: dangerous handling of Unicode").
        Made changes suggested by PC-LINT 5.0

--*/

#ifndef _TSTRING_H_INCLUDED
#define _TSTRING_H_INCLUDED


#include <lmcons.h>     // NET_API_STATUS.
// Don't complain about "unneeded" includes of these files:
/*lint -efile(764,tstr.h,winerror.h) */
/*lint -efile(766,tstr.h,winerror.h) */
#include <tstr.h>       // tstring stuff, used in macros below.
#include <winerror.h>   // NO_ERROR.


//
// Eventually, most uses of non-UNICODE strings should refer to the default
// codepage for the LAN.  The NetpCopy functions support the default codepage.
// The other STR macros may not.
//
VOID
NetpCopyStrToWStr(
    OUT LPWSTR Dest,
    IN  LPSTR  Src              // string in default LAN codepage
    );

NET_API_STATUS
NetpNCopyStrToWStr(
    OUT LPWSTR Dest,
    IN  LPSTR  Src,             // string in default LAN codepage
    IN  DWORD  CharCount
    );

VOID
NetpCopyWStrToStr(
    OUT LPSTR  Dest,            // string in default LAN codepage
    IN  LPWSTR Src
    );

NET_API_STATUS
NetpNCopyWStrToStr(
    OUT LPSTR  Dest,            // string in default LAN codepage
    IN  LPWSTR Src,
    IN  DWORD  CharCount
    );

VOID
NetpCopyWStrToStrDBCS(
    OUT LPSTR  Dest,            // string in default LAN codepage
    IN  LPWSTR Src
    );

ULONG
NetpUnicodeToDBCSLen(
    IN  LPWSTR Src
    );


#ifdef UNICODE

#define NetpCopyStrToTStr(Dest,Src)  NetpCopyStrToWStr((Dest),(Src))
#define NetpCopyTStrToStr(Dest,Src)  NetpCopyWStrToStr((LPSTR)(Dest),(LPWSTR)(Src))
#define NetpCopyTStrToWStr(Dest,Src) (void) wcscpy((Dest),(Src))

#define NetpNCopyTStrToWStr(Dest,Src,Len) \
                        (wcsncpy((Dest),(Src),(Len)), NO_ERROR)

#endif // UNICODE


//
// Define a set of allocate and copy functions.  These all return NULL if
// unable to allocate memory.  The memory must be freed with NetApiBufferFree.
//

LPSTR
NetpAllocStrFromWStr (
    IN LPWSTR Src
    );

LPWSTR
NetpAllocWStrFromStr (
    IN LPSTR Src
    );

LPWSTR
NetpAllocWStrFromWStr (
    IN LPWSTR Src
    );

//
// As of 03-Aug-1992, people are still arguing over whether there should
// be an RtlInitOemString.  So I'm inventing NetpInitOemString in the
// meantime.  --JR
//

#ifdef _NTDEF_   // POEM_STRING typedef visible?

VOID
NetpInitOemString(
    OUT POEM_STRING DestinationString,
    IN  PCSZ        SourceString
    );

#endif // _NTDEF_


//
//
// ANSI versions of the API.
//

LPWSTR
NetpAllocWStrFromAStr (
    IN LPCSTR Src
    );

LPSTR
NetpAllocAStrFromWStr (
    IN LPCWSTR Src
    );

#endif  // _TSTRING_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\usrprop.h ===
/*++

Copyright (c) 1993-1995, Microsoft Corp. All rights reserved.

Module Name:

    usrprop.h

Abstract:

    This is the public include file for some of the functions used by
    User Manager and Server Manager.

Author:

    Congpa You 02-Dec-1993  Created.

Revision History:

--*/

#ifndef _USRPROP_H_
#define _USRPROP_H_

//
//  These are exported by netapi32.dll.
//

NTSTATUS
NetpParmsSetUserProperty (
    IN LPWSTR             UserParms,
    IN LPWSTR             Property,
    IN UNICODE_STRING     PropertyValue,
    IN WCHAR              PropertyFlag,
    OUT LPWSTR *          pNewUserParms,       // memory has to be freed afer use.
    OUT BOOL *            Update
    );

NTSTATUS
NetpParmsSetUserPropertyWithLength (
    IN PUNICODE_STRING    UserParms,
    IN LPWSTR             Property,
    IN UNICODE_STRING     PropertyValue,
    IN WCHAR              PropertyFlag,
    OUT LPWSTR *          pNewUserParms,       // memory has to be freed afer use.
    OUT BOOL *            Update
    );

NTSTATUS
NetpParmsQueryUserProperty (
    IN  LPWSTR          UserParms,
    IN  LPWSTR          Property,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    );

NTSTATUS
NetpParmsQueryUserPropertyWithLength (
    IN  PUNICODE_STRING UserParms,
    IN  LPWSTR          Property,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    );

//
//  Call NetpParmsUserertyPropFree on new Parameters block returned by
//  NetpParmsSetUserProperty above after you're done writing it out.
//

VOID
NetpParmsUserPropertyFree (
    LPWSTR NewUserParms
    );

#endif // _USRPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\ssi.h ===
/*++

Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    ssi.h

Abstract:

    Definition of Netlogon service APIs and structures used for SAM database
    replication.

    This file is shared by the Netlogon service and the XACT server.

Author:

    Cliff Van Dyke (cliffv) 27-Jun-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    27-Jun-1991 (cliffv)
        Ported from LanMan 2.1.

    04-Apr-1992 (madana)
        Added support for LSA replication.

--*/

#ifndef _NET_SSI_H_
#define _NET_SSI_H_

//**************************************************************
//
//              Data structure template - AUTHENTICATION
//
// ***************************************************************//

typedef struct _NETLOGON_VALIDATION_UAS_INFO {
#ifdef MIDL_PASS
     [string] wchar_t * usrlog1_eff_name;
#else // MIDL_PASS
     LPWSTR usrlog1_eff_name;
#endif // MIDL_PASS
     DWORD usrlog1_priv;
     DWORD usrlog1_auth_flags;
     DWORD usrlog1_num_logons;
     DWORD usrlog1_bad_pw_count;
     DWORD usrlog1_last_logon;
     DWORD usrlog1_last_logoff;
     DWORD usrlog1_logoff_time;
     DWORD usrlog1_kickoff_time;
     DWORD usrlog1_password_age;
     DWORD usrlog1_pw_can_change;
     DWORD usrlog1_pw_must_change;
#ifdef MIDL_PASS
     [string] wchar_t * usrlog1_computer;
     [string] wchar_t * usrlog1_domain;
     [string] wchar_t * usrlog1_script_path;
#else // MIDL_PASS
     LPWSTR usrlog1_computer;
     LPWSTR usrlog1_domain;
     LPWSTR usrlog1_script_path;
#endif // MIDL_PASS
     DWORD usrlog1_reserved1;
} NETLOGON_VALIDATION_UAS_INFO, *PNETLOGON_VALIDATION_UAS_INFO ;

typedef struct _NETLOGON_LOGOFF_UAS_INFO {
     DWORD Duration;
     USHORT LogonCount;
} NETLOGON_LOGOFF_UAS_INFORMATION, *PNETLOGON_LOGOFF_UAS_INFO;

// ***************************************************************
//
//      Function prototypes - AUTHENTICATION
//
// ***************************************************************

NTSTATUS
I_NetServerReqChallenge(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR ComputerName,
    IN PNETLOGON_CREDENTIAL ClientChallenge,
    OUT PNETLOGON_CREDENTIAL ServerChallenge
);

NTSTATUS
I_NetServerAuthenticate(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_CREDENTIAL ClientCredential,
    OUT PNETLOGON_CREDENTIAL ServerCredential
);

NTSTATUS
I_NetServerAuthenticate2(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_CREDENTIAL ClientCredential,
    OUT PNETLOGON_CREDENTIAL ServerCredential,
    IN OUT PULONG NegotiatedFlags
);

NTSTATUS
I_NetServerAuthenticate3(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_CREDENTIAL ClientCredential,
    OUT PNETLOGON_CREDENTIAL ServerCredential,
    IN OUT PULONG NegotiatedFlags,
    OUT PULONG AccountRid
    );

//
// Values of I_NetServerAuthenticate2 NegotiatedFlags
//

#define NETLOGON_SUPPORTS_ACCOUNT_LOCKOUT   0x00000001
#define NETLOGON_SUPPORTS_PERSISTENT_BDC    0x00000002
#define NETLOGON_SUPPORTS_RC4_ENCRYPTION    0x00000004
#define NETLOGON_SUPPORTS_PROMOTION_COUNT   0x00000008
#define NETLOGON_SUPPORTS_BDC_CHANGELOG     0x00000010
#define NETLOGON_SUPPORTS_FULL_SYNC_RESTART 0x00000020
#define NETLOGON_SUPPORTS_MULTIPLE_SIDS     0x00000040
#define NETLOGON_SUPPORTS_REDO              0x00000080

//
// For NT 3.51, the mask was 0xFF.
//

#define NETLOGON_SUPPORTS_NT351_MASK        0x000000FF

#define NETLOGON_SUPPORTS_REFUSE_CHANGE_PWD 0x00000100

//
// For NT 4.0, the mask was 0x1FF.
// For NT 4 SP 4, the machine might have NETLOGON_SUPPORTS_AUTH_RPC or'd in
//

#define NETLOGON_SUPPORTS_NT4_MASK          0x400001FF

#define NETLOGON_SUPPORTS_PDC_PASSWORD      0x00000200
#define NETLOGON_SUPPORTS_GENERIC_PASSTHRU  0x00000400
#define NETLOGON_SUPPORTS_CONCURRENT_RPC    0x00000800
#define NETLOGON_SUPPORTS_AVOID_SAM_REPL    0x00001000
#define NETLOGON_SUPPORTS_AVOID_LSA_REPL    0x00002000
#define NETLOGON_SUPPORTS_STRONG_KEY        0x00004000  // Added after NT 5 Beta 2
#define NETLOGON_SUPPORTS_TRANSITIVE        0x00008000  // Added after NT 5 Beta 2
#define NETLOGON_SUPPORTS_DNS_DOMAIN_TRUST  0x00010000
#define NETLOGON_SUPPORTS_PASSWORD_SET_2    0x00020000
#define NETLOGON_SUPPORTS_GET_DOMAIN_INFO   0x00040000
#define NETLOGON_SUPPORTS_LSA_AUTH_RPC      0x20000000  // Added after NT 5 Beta 2
#define NETLOGON_SUPPORTS_AUTH_RPC          0x40000000

//
// For Windows 2000, the mask was 0x6007FFFF

#define NETLOGON_SUPPORTS_WIN2000_MASK      0x6007FFFF

//
// Masks added after Windows 2000
//

#define NETLOGON_SUPPORTS_CROSS_FOREST      0x00080000  // Added for Whistler
#define NETLOGON_SUPPORTS_NT4EMULATOR_NEUTRALIZER   0x00100000  // Added for Whistler


//
// Mask of bits always supported by current build (regardless of options)
//
#define NETLOGON_SUPPORTS_MASK ( \
            NETLOGON_SUPPORTS_ACCOUNT_LOCKOUT | \
            NETLOGON_SUPPORTS_PERSISTENT_BDC | \
            NETLOGON_SUPPORTS_RC4_ENCRYPTION | \
            NETLOGON_SUPPORTS_PROMOTION_COUNT | \
            NETLOGON_SUPPORTS_BDC_CHANGELOG | \
            NETLOGON_SUPPORTS_FULL_SYNC_RESTART | \
            NETLOGON_SUPPORTS_MULTIPLE_SIDS | \
            NETLOGON_SUPPORTS_REDO | \
            NETLOGON_SUPPORTS_REFUSE_CHANGE_PWD | \
            NETLOGON_SUPPORTS_PDC_PASSWORD | \
            NETLOGON_SUPPORTS_GENERIC_PASSTHRU | \
            NETLOGON_SUPPORTS_CONCURRENT_RPC | \
            NETLOGON_SUPPORTS_TRANSITIVE | \
            NETLOGON_SUPPORTS_DNS_DOMAIN_TRUST | \
            NETLOGON_SUPPORTS_PASSWORD_SET_2 | \
            NETLOGON_SUPPORTS_GET_DOMAIN_INFO | \
            NETLOGON_SUPPORTS_CROSS_FOREST )


NTSTATUS
I_NetServerPasswordSet(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN PENCRYPTED_LM_OWF_PASSWORD UasNewPassword
);

//
// Values of QueryLevel
#define NETLOGON_QUERY_DOMAIN_INFO      1
#define NETLOGON_QUERY_LSA_POLICY_INFO  2

NTSTATUS
I_NetLogonGetDomainInfo(
    IN LPWSTR ServerName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD QueryLevel,
    IN LPBYTE InBuffer,
    OUT LPBYTE *OutBuffer
    );



NET_API_STATUS NET_API_FUNCTION
I_NetLogonUasLogon (
    IN LPWSTR UserName,
    IN LPWSTR Workstation,
    OUT PNETLOGON_VALIDATION_UAS_INFO *ValidationInformation
);

NET_API_STATUS
I_NetLogonUasLogoff (
    IN LPWSTR UserName,
    IN LPWSTR Workstation,
    OUT PNETLOGON_LOGOFF_UAS_INFO LogoffInformation
);

// **************************************************************
//
//      Special values and constants - AUTHENTICATION
//
// **************************************************************

// **************************************************************
//
//              Data structure template - UAS/SAM REPLICATION
//
// **************************************************************

typedef struct _UAS_INFO_0 {
    CHAR ComputerName[LM20_CNLEN+1];
    ULONG TimeCreated;
    ULONG SerialNumber;
} UAS_INFO_0, *PUAS_INFO_0 ;

// **************************************************************
//
//      Function prototypes - UAS/SAM REPLICATION
//
// **************************************************************

NET_API_STATUS NET_API_FUNCTION
I_NetAccountDeltas (
    IN LPWSTR primaryname,
    IN LPWSTR computername,
    IN PNETLOGON_AUTHENTICATOR authenticator,
    OUT PNETLOGON_AUTHENTICATOR ret_auth,
    IN PUAS_INFO_0 record_id,
    IN DWORD count,
    IN DWORD level,
    OUT LPBYTE buffer,
    IN DWORD buffer_len,
    OUT PULONG entries_read,
    OUT PULONG total_entries,
    OUT PUAS_INFO_0 next_record_id
    );

NET_API_STATUS NET_API_FUNCTION
I_NetAccountSync (
    IN LPWSTR primaryname,
    IN LPWSTR computername,
    IN PNETLOGON_AUTHENTICATOR authenticator,
    OUT PNETLOGON_AUTHENTICATOR ret_auth,
    IN DWORD reference,
    IN DWORD level,
    OUT LPBYTE buffer,
    IN DWORD buffer_len,
    OUT PULONG entries_read,
    OUT PULONG total_entries,
    OUT PULONG next_reference,
    OUT PUAS_INFO_0 last_record_id
);

typedef enum _NETLOGON_DELTA_TYPE {
    AddOrChangeDomain = 1,
    AddOrChangeGroup,
    DeleteGroup,
    RenameGroup,
    AddOrChangeUser,
    DeleteUser,
    RenameUser,
    ChangeGroupMembership,
    AddOrChangeAlias,
    DeleteAlias,
    RenameAlias,
    ChangeAliasMembership,
    AddOrChangeLsaPolicy,
    AddOrChangeLsaTDomain,
    DeleteLsaTDomain,
    AddOrChangeLsaAccount,
    DeleteLsaAccount,
    AddOrChangeLsaSecret,
    DeleteLsaSecret,
    // The following deltas require NETLOGON_SUPPORTS_BDC_CHANGELOG to be
    // negotiated.
    DeleteGroupByName,
    DeleteUserByName,
    SerialNumberSkip,
    DummyChangeLogEntry
} NETLOGON_DELTA_TYPE;


//
// Group and User account used for SSI.
//

#define SSI_ACCOUNT_NAME_POSTFIX        L"$"
#define SSI_ACCOUNT_NAME_POSTFIX_CHAR   L'$'
#define SSI_ACCOUNT_NAME_POSTFIX_LENGTH 1
#define SSI_ACCOUNT_NAME_LENGTH         (CNLEN + SSI_ACCOUNT_NAME_POSTFIX_LENGTH)

#define SSI_SERVER_GROUP_W              L"SERVERS"

//
// Structure to pass an encrypted password over the wire.  The Length is the
// length of the password, which should be placed at the end of the buffer.
//

#define NL_MAX_PASSWORD_LENGTH 256
typedef struct _NL_TRUST_PASSWORD {
    WCHAR Buffer[NL_MAX_PASSWORD_LENGTH];
    ULONG Length;
} NL_TRUST_PASSWORD, *PNL_TRUST_PASSWORD;

//
// Structure to be prefixed before the password in the Buffer of NL_TRUST_PASSWORD
// structure passed over the wire.  It will be used to distinguish between diferent
// versions of information passed in the buffer. Begining with RC1 NT5, the presence
// of the structure in the buffer and the equality of PasswordVersionPresent to
// PASSWORD_VERSION_PRESENT indicates that the password version number is present
// and is stored in PasswordVersionNumber; the value of ReservedField is set to 0.
// RC0 NT5 clients will generate random numbers in place of NL_PASSWORD_VERSION; it
// is highly unlikely that they will generate PASSWORD_VERSION_PRESENT sequence of
// bits in place where the PasswordVersionPresent would be present.  This (very week)
// uncertainty will exist only between RC0 NT5 and RC1 NT5 machines.  A server running
// RC1 NT5 will check the PasswordVersionPresent field only for RC0 NT5 and higher
// clients. The ReservedField will be used in future versions to indicate the version
// of the information stored in the buffer.
//

#define PASSWORD_VERSION_NUMBER_PRESENT 0x02231968
typedef struct _NL_PASSWORD_VERSION {
    DWORD ReservedField;
    DWORD PasswordVersionNumber;
    DWORD PasswordVersionPresent;
} NL_PASSWORD_VERSION, *PNL_PASSWORD_VERSION;

NTSTATUS
I_NetServerPasswordSet2(
    IN LPWSTR PrimaryName OPTIONAL,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN PNL_TRUST_PASSWORD NewPassword
);

NTSTATUS
I_NetServerPasswordGet(
    IN LPWSTR PrimaryName,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    );

NTSTATUS
I_NetServerTrustPasswordsGet(
    IN LPWSTR TrustedDcName,
    IN LPWSTR AccountName,
    IN NETLOGON_SECURE_CHANNEL_TYPE AccountType,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNewOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedOldOwfPassword
    );

NTSTATUS
I_NetLogonSendToSam(
    IN LPWSTR PrimaryName,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN LPBYTE Buffer,
    IN ULONG BufferSize
    );


//
// Only define this API if the caller has #included the pre-requisite ntlsa.h

#ifdef _NTLSA_

NTSTATUS
I_NetGetForestTrustInformation (
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR ComputerName,
    IN PNETLOGON_AUTHENTICATOR Authenticator,
    OUT PNETLOGON_AUTHENTICATOR ReturnAuthenticator,
    IN DWORD Flags,
    OUT PLSA_FOREST_TRUST_INFORMATION *ForestTrustInfo
    );

#endif // _NTLSA_

#endif // _NET_SSI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\wlnotify.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name :
	
    wlnotify.h

Abstract:

    Shared wlnotify header.

Revision History:
--*/

#ifndef _WLNOTIFY_
#define _WLNOTIFY_

//
//	Resource string IDs
//
//
#define IDS_TSSESSION_STRING           2001
#define IDS_TSERRORDIALOG_STRING       2002
#define IDS_TSPTEMPLATE_FROM           2003
#define IDS_TSPTEMPLATE_FROM_IN        2004
#define IDS_TSPTEMPLATE_ON_FROM        2005
#define IDS_TSPTEMPLATE_ON_FROM_IN     2006
#define IDS_ON                         2007
#define IDS_DRIVE_INFO_TIP             2008

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\uascache.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    UASCache.h

Abstract:

    Data structures for logged on user cache.

Author:

    Shanku Niyogi (W-SHANKN)  24-Oct-1991

Revision History:

    24-Oct-1991     w-shankn
        Ported from LM2.0 code.
    07-Feb-1992 JohnRo
        Made changes suggested by PC-LINT.
    18-Mar-1992 JohnRo
        Allow inclusion multiple times.

--*/


#ifndef _UASCACHE_
#define _UASCACHE_


#include <packon.h>                     // Needed to avoid alignment

//
// Forward declarations for recursive structures.
//

typedef struct _UAS_USER_CACHE_0 UAS_USER_CACHE_0, *LPUAS_USER_CACHE_0;

//
// Structure of a Global User IDentifier
//

typedef struct _UAS_GUID {

    WORD guid_uid;                      // LM10 style user id
    DWORD guid_serial;                  // user record serial number
    BYTE guid_rsvd[10];                 // pad out to 16 bytes for now

} UAS_GUID;


//
// Structure of a logon record in the UAS cache
//

struct _UAS_USER_CACHE_0 {  // typedef'ed above.

    UAS_GUID uc0_guid;                  // GUID for this user
    DWORD uc0_auth_flags;               // operator privilege flag
    WORD uc0_priv;                      // bit0-1: 0 guest, 1 user, 2 admin
    WORD uc0_num_reqs;                  // use count for this record
    BYTE uc0_groups[32];                // group membership bit map
    LPUAS_USER_CACHE_0 uc0_next;        // pointer to the next

};

typedef UAS_USER_CACHE_0 UAS_USER, *LPUAS_USER;

//
// Structure of a group record in the UAS cache
//

typedef struct _UAS_GROUP_CACHE_0 {

    UAS_GUID gc0_guid;                  // GUID for this group

} UAS_GROUP_CACHE_0, *LPUAS_GROUP_CACHE_0;


//
// UAS info struct for SSI and update APIs
//

typedef struct _UAS_INFO_0 {

    BYTE uas0_computer[LM20_CNLEN+1];
    DWORD uas0_time_created;
    DWORD uas0_serial_number;

} UAS_INFO_0, *LPUAS_INFO_0;

#include <packoff.h>


#endif // _UASCACHE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\userenvp.h ===
//=============================================================================
//  userenv.h   -   Header file for user environment API.
//                  User Profiles, environment variables, and Group Policy
//
//  Copyright (c) Microsoft Corporation 1995-1999
//  All rights reserved
//
//=============================================================================


#ifndef _INC_USERENVP
#define _INC_USERENVP

#ifdef __cplusplus
extern "C" {
#endif
#define PI_LITELOAD     0x00000004      // Lite load of the profile (for system use only)
#define PI_HIDEPROFILE  0x00000008      // Mark the profile as super hidden

#ifndef _USERENV_NO_LINK_APIS_

//=============================================================================
//
// CreateGroup
//
// Creates a program group on the start menu
//
// lpGroupName  - Name of group
// bCommonGroup - Common or personal group
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
CreateGroupA(
     IN LPCSTR lpGroupName,
     IN BOOL    bCommonGroup);
USERENVAPI
BOOL
WINAPI
CreateGroupW(
     IN LPCWSTR lpGroupName,
     IN BOOL    bCommonGroup);
#ifdef UNICODE
#define CreateGroup  CreateGroupW
#else
#define CreateGroup  CreateGroupA
#endif // !UNICODE


//=============================================================================
//
// CreateGroupEx
//
// Creates a program group on the start menu
//
// lpGroupName  - Name of group
// bCommonGroup - Common or personal group
// lpResourceModuleName - Name of the resource module.
// uResourceID - Resource ID for the MUI display name.
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
CreateGroupExA(
     IN LPCSTR  lpGroupName,
     IN BOOL      bCommonGroup,
     IN LPCSTR  lpResourceModuleName,
     IN UINT      uResourceID);
USERENVAPI
BOOL
WINAPI
CreateGroupExW(
     IN LPCWSTR  lpGroupName,
     IN BOOL      bCommonGroup,
     IN LPCWSTR  lpResourceModuleName,
     IN UINT      uResourceID);
#ifdef UNICODE
#define CreateGroupEx  CreateGroupExW
#else
#define CreateGroupEx  CreateGroupExA
#endif // !UNICODE


//=============================================================================
//
// DeleteGroup
//
// Deletes a program group on the start menu and all of its contents
//
// lpGroupName  - Name of group
// bCommonGroup - Common or personal group
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:  This function uses a delnode routine.  Make sure you really want
//        to delete the group before you call this function.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
DeleteGroupA(
     IN LPCSTR lpGroupName,
     IN BOOL    bCommonGroup);
USERENVAPI
BOOL
WINAPI
DeleteGroupW(
     IN LPCWSTR lpGroupName,
     IN BOOL    bCommonGroup);
#ifdef UNICODE
#define DeleteGroup  DeleteGroupW
#else
#define DeleteGroup  DeleteGroupA
#endif // !UNICODE


//=============================================================================
//
// AddItem
//
// Creates an item on the Programs portion of the Start Menu in the
// requested group.
//
// lpGroupName        - Name of group
// bCommonGroup       - Common or personal group
// lpFileName         - Name of link without the .lnk extension (eg:  Notepad)
// lpCommandLine      - Command line of target path (eg:  notepad.exe)
// lpIconPath         - Optional icon path, can be NULL.
// iIconIndex         - Optional icon index, default to 0.
// lpWorkingDirectory - Working directory when target is invoked, can be NULL
// wHotKey            - Hot key for the link file, default to 0
// iShowCmd           - Specifies how the application should be launched.
//                      Use a default of SW_SHOWNORMAL
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Notes:    New applications should use the CreateLinkFile() function instead
//           of AddItem.  This allows for friendly tooltip descriptions.
//
//           The lpFileName argument should not include the .lnk extension.
//           This function will add the extension.
//
//           If the lpWorkingDirectory parameter is NULL, this function will
//           insert the home directory environment variables
//
//           If the requested group doesn't exist, it will be created.
//
//           If the lpCommandLine target is located below the system root,
//           the SystemRoot environment variable will be inserted into the path
//
//           Here's a sample of how this function is typically called:
//
//           AddItem (TEXT("Accessories"), FALSE, TEXT("Notepad"),
//                    TEXT("notepad.exe"), NULL, 0, NULL, 0, SW_SHOWNORMAL);
//
//           This function should only be used the Windows NT team.  Developers
//           outside of the Windows NT team can use the IShellLink interface
//           to create link files.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
AddItemA(
     IN LPCSTR lpGroupName,
     IN BOOL    bCommonGroup,
     IN LPCSTR lpFileName,
     IN LPCSTR lpCommandLine,
     IN LPCSTR lpIconPath,
     IN INT     iIconIndex,
     IN LPCSTR lpWorkingDirectory,
     IN WORD    wHotKey,
     IN INT     iShowCmd);
USERENVAPI
BOOL
WINAPI
AddItemW(
     IN LPCWSTR lpGroupName,
     IN BOOL    bCommonGroup,
     IN LPCWSTR lpFileName,
     IN LPCWSTR lpCommandLine,
     IN LPCWSTR lpIconPath,
     IN INT     iIconIndex,
     IN LPCWSTR lpWorkingDirectory,
     IN WORD    wHotKey,
     IN INT     iShowCmd);
#ifdef UNICODE
#define AddItem  AddItemW
#else
#define AddItem  AddItemA
#endif // !UNICODE


//=============================================================================
//
// DeleteItem
//
// Deletes an item on the Programs portion of the Start Menu in the
// requested group.
//
// lpGroupName        - Name of group
// bCommonGroup       - Common or personal group
// lpFileName         - Name of link without the .lnk extension (eg:  Notepad)
// bDeleteGroup       - After deleting the link, delete the group if its empty.
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Notes:    New applications should use the DeleteLinkFile() function instead
//           of DeleteItem.
//
//           The lpFileName argument should not include the .lnk extension.
//           This function will add the extension.
//
//           Here's a sample of how this function is typically called:
//
//           DeleteItem (TEXT("Accessories"), FALSE, TEXT("Notepad"), TRUE);
//
//           This function should only be used the Windows NT team.  Developers
//           outside of the Windows NT team can use the IShellLink interface
//           to create link files and DeleteFile to delete them.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
DeleteItemA(
     IN LPCSTR lpGroupName,
     IN BOOL     bCommonGroup,
     IN LPCSTR lpFileName,
     IN BOOL     bDeleteGroup);
USERENVAPI
BOOL
WINAPI
DeleteItemW(
     IN LPCWSTR lpGroupName,
     IN BOOL     bCommonGroup,
     IN LPCWSTR lpFileName,
     IN BOOL     bDeleteGroup);
#ifdef UNICODE
#define DeleteItem  DeleteItemW
#else
#define DeleteItem  DeleteItemA
#endif // !UNICODE


//=============================================================================
//
// AddDesktopItem
//
// Creates an item on desktop.  This function is very similar to AddItem()
// documented above.  See that function for more information.
//
// Notes:    New applications should use the CreateLinkFile() function instead
//           of AddItem.  This allows for friendly tooltip descriptions.
//
//           This function should only be used the Windows NT team.  Developers
//           outside of the Windows NT team can use the IShellLink interface
//           to create link files.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
AddDesktopItemA(
     IN BOOL    bCommonItem,
     IN LPCSTR lpFileName,
     IN LPCSTR lpCommandLine,
     IN LPCSTR lpIconPath,
     IN INT     iIconIndex,
     IN LPCSTR lpWorkingDirectory,
     IN WORD    wHotKey,
     IN INT     iShowCmd);
USERENVAPI
BOOL
WINAPI
AddDesktopItemW(
     IN BOOL    bCommonItem,
     IN LPCWSTR lpFileName,
     IN LPCWSTR lpCommandLine,
     IN LPCWSTR lpIconPath,
     IN INT     iIconIndex,
     IN LPCWSTR lpWorkingDirectory,
     IN WORD    wHotKey,
     IN INT     iShowCmd);
#ifdef UNICODE
#define AddDesktopItem  AddDesktopItemW
#else
#define AddDesktopItem  AddDesktopItemA
#endif // !UNICODE


//=============================================================================
//
// DeleteDesktopItem
//
// Deletes an item from the desktop.  This function is very similar to DeleteItem()
// documented above.  See that function for more information.
//
// Notes:    New applications should use the DeleteLinkFile() function instead
//           of DeleteDesktopItem.
//
//           This function should only be used the Windows NT team.  Developers
//           outside of the Windows NT team can use the IShellLink interface
//           to create link files and DeleteFile to delete them.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
DeleteDesktopItemA(
     IN BOOL     bCommonItem,
     IN LPCSTR lpFileName);
USERENVAPI
BOOL
WINAPI
DeleteDesktopItemW(
     IN BOOL     bCommonItem,
     IN LPCWSTR lpFileName);
#ifdef UNICODE
#define DeleteDesktopItem  DeleteDesktopItemW
#else
#define DeleteDesktopItem  DeleteDesktopItemA
#endif // !UNICODE


//=============================================================================
//
// CreateLinkFile
//
// Creates a link file (aka shortcut) in the requested special folder or
// subdirectory of a special folder.
//
// csidl              - CSIDL_* constant of special folder.  See shlobj.h
// lpSubDirectory     - Subdirectory name.  See note below
// lpFileName         - Name of link without the .lnk extension (eg:  Notepad)
// lpCommandLine      - Command line of target path (eg:  notepad.exe)
// lpIconPath         - Optional icon path, can be NULL.
// iIconIndex         - Optional icon index, default to 0.
// lpWorkingDirectory - Working directory when target is invoked, can be NULL
// wHotKey            - Hot key for the link file, default to 0
// iShowCmd           - Specifies how the application should be launched.
//                      Use a default of SW_SHOWNORMAL
// lpDescription      - Friendly description of shortcut, can be NULL.
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Notes:    New applications should use this function instead of AddItem or
//           AddDesktopItem.  This allows for friendly tooltip descriptions.
//
//           The link file name is a combination of the first three
//           parameters.  If a csidl is given, that special folder is
//           looked up first, and then the lpSubDirectory is appended to
//           it followed by the lpFileName.  If csidl is equal to 0, then
//           lpSubDirectory should contain the fully qualified path to the
//           directory the link file is to be placed in.  This allows
//           for link files to be be created outside of the scope of a
//           shell special folder.  The csidl constants are listed in
//           shlobj.h or in the Win32 documentation for SHGetSpecialFolderPath.
//           Commonly used csidl's will be:
//
//               CSIDL_PROGRAMS                 - Personal Program folder on Start Menu
//               CSIDL_COMMON_PROGRAMS          - Common Program folder on Start Menu
//               CSIDL_DESKTOPDIRECTORY         - Personal desktop folder
//               CSIDL_COMMON_DESKTOPDIRECTORY  - Common desktop folder
//
//           The lpFileName argument should not include the .lnk extension.
//           This function will add the extension.
//
//           If the lpWorkingDirectory parameter is NULL, this function will
//           insert home directory environment variables.
//
//           If the requested subdirectory doesn't exist, it will be created.
//
//           If the lpCommandLine target is located below the system root,
//           the SystemRoot environment variable will be inserted into the path
//
//           Here's a sample of how this function is typically called:
//
//           CreateLinkFile (CSIDL_PROGRAMS, TEXT("Accessories"), TEXT("Notepad"),
//                           TEXT("notepad.exe"), NULL, 0, NULL, 0, SW_SHOWNORMAL,
//                           TEXT("A simple word processor."));
//
//           This function should only be used the Windows NT team.  Developers
//           outside of the Windows NT team can use the IShellLink interface
//           to create link files.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
CreateLinkFileA(
     IN INT csidl,
     IN LPCSTR lpSubDirectory,
     IN LPCSTR lpFileName,
     IN LPCSTR lpCommandLine,
     IN LPCSTR lpIconPath,
     IN INT     iIconIndex,
     IN LPCSTR lpWorkingDirectory,
     IN WORD    wHotKey,
     IN INT     iShowCmd,
     IN LPCSTR lpDescription);
USERENVAPI
BOOL
WINAPI
CreateLinkFileW(
     IN INT csidl,
     IN LPCWSTR lpSubDirectory,
     IN LPCWSTR lpFileName,
     IN LPCWSTR lpCommandLine,
     IN LPCWSTR lpIconPath,
     IN INT     iIconIndex,
     IN LPCWSTR lpWorkingDirectory,
     IN WORD    wHotKey,
     IN INT     iShowCmd,
     IN LPCWSTR lpDescription);
#ifdef UNICODE
#define CreateLinkFile  CreateLinkFileW
#else
#define CreateLinkFile  CreateLinkFileA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// CreateLinkFileEx
//
// Creates a link file (aka shortcut) in the requested special folder or
// subdirectory of a special folder.
//
// csidl                - CSIDL_* constant of special folder.  See shlobj.h
// lpSubDirectory       - Subdirectory name.  See note below
// lpFileName           - Name of link without the .lnk extension (eg:  Notepad)
// lpCommandLine        - Command line of target path (eg:  notepad.exe)
// lpIconPath           - Optional icon path, can be NULL.
// iIconIndex           - Optional icon index, default to 0.
// lpWorkingDirectory   - Working directory when target is invoked, can be NULL
// wHotKey              - Hot key for the link file, default to 0
// iShowCmd             - Specifies how the application should be launched.
//                       Use a default of SW_SHOWNORMAL
// lpDescription        - Friendly description of shortcut, can be NULL.
// lpResourceModuleName - Name of the resource module. Can be NULL
// uResourceID          - Resource ID for the MUI display name.
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// for additional descriptions look in the description of Createlinkfile above.
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
CreateLinkFileExA(
     IN INT csidl,
     IN LPCSTR lpSubDirectory,
     IN LPCSTR lpFileName,
     IN LPCSTR lpCommandLine,
     IN LPCSTR lpIconPath,
     IN INT      iIconIndex,
     IN LPCSTR lpWorkingDirectory,
     IN WORD     wHotKey,
     IN INT      iShowCmd,
     IN LPCSTR lpDescription,
     IN LPCSTR lpResourceModuleName, 
     IN UINT     uResourceID);
USERENVAPI
BOOL
WINAPI
CreateLinkFileExW(
     IN INT csidl,
     IN LPCWSTR lpSubDirectory,
     IN LPCWSTR lpFileName,
     IN LPCWSTR lpCommandLine,
     IN LPCWSTR lpIconPath,
     IN INT      iIconIndex,
     IN LPCWSTR lpWorkingDirectory,
     IN WORD     wHotKey,
     IN INT      iShowCmd,
     IN LPCWSTR lpDescription,
     IN LPCWSTR lpResourceModuleName, 
     IN UINT     uResourceID);
#ifdef UNICODE
#define CreateLinkFileEx  CreateLinkFileExW
#else
#define CreateLinkFileEx  CreateLinkFileExA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// DeleteLinkFile
//
// Deletes a link file (aka shortcut) in the requested special folder or
// subdirectory of a special folder.
//
// csidl               - CSIDL_* constant of special folder.  See shlobj.h
// lpSubDirectory      - Subdirectory name.  See note below
// lpFileName          - Name of link without the .lnk extension (eg:  Notepad)
// bDeleteSubDirectory - After deleting the link, delete the subdirectory if its empty.
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Notes:    New applications should use this function instead DeleteItem or
//           DeleteDesktopItem.
//
//           The link file name is a combination of the first three
//           parameters.  If a csidl is given, that special folder is
//           looked up first, and then the lpSubDirectory is appended to
//           it followed by the lpFileName.  If csidl is equal to 0, then
//           lpSubDirectory should contain the fully qualified path to the
//           directory the link file is to be placed in.  This allows
//           for link files to be be deleted outside of the scope of a
//           shell special folder.  The csidl constants are listed in
//           shlobj.h or in the Win32 documentation for SHGetSpecialFolderPath.
//           Commonly used csidl's will be:
//
//               CSIDL_PROGRAMS                 - Personal Program folder on Start Menu
//               CSIDL_COMMON_PROGRAMS          - Common Program folder on Start Menu
//               CSIDL_DESKTOPDIRECTORY         - Personal desktop folder
//               CSIDL_COMMON_DESKTOPDIRECTORY  - Common desktop folder
//
//           The lpFileName argument should not include the .lnk extension.
//           This function will add the extension.
//
//           This function should only be used the Windows NT team.  Developers
//           outside of the Windows NT team can use the IShellLink interface
//           to create link files and DeleteFile to delete them.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
DeleteLinkFileA(
     IN INT csidl,
     IN LPCSTR lpSubDirectory,
     IN LPCSTR lpFileName,
     IN BOOL bDeleteSubDirectory);
USERENVAPI
BOOL
WINAPI
DeleteLinkFileW(
     IN INT csidl,
     IN LPCWSTR lpSubDirectory,
     IN LPCWSTR lpFileName,
     IN BOOL bDeleteSubDirectory);
#ifdef UNICODE
#define DeleteLinkFile  DeleteLinkFileW
#else
#define DeleteLinkFile  DeleteLinkFileA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

#endif // _USERENV_NO_LINK_APIS_


//=============================================================================
//
// InitializeProfiles
//
// This function is used by GUI mode setup only and setup repair.  It initializes
// the Default User and All User profiles and converts any common groups from
// Program Manager.
//
// bGuiModeSetup  - Gui Mode setup or not.
//
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
InitializeProfiles(
     IN BOOL bGuiModeSetup);


//*************************************************************
//
//  CopySystemProfile()
//
//  Purpose:    Create the system profile information under 
//              ProfileList entry.
//              In case of upgrade copy system profile from older
//              location to new location and delete the old system 
//              profile
//              
//  Parameters:
//
//  Return:     TRUE if successful
//              FALSE if an error occurs. Call GetLastError()
//
//  Comments:   This should only be called by GUI mode setup!
//
//*************************************************************

USERENVAPI
BOOL 
WINAPI 
CopySystemProfile(
    IN BOOL bCleanInstall);


//=============================================================================
//
// DetermineProfilesLocation
//
// This function is used by winlogon when GUI mode setup is about to start.
// It sets the correct user profile location in the registry.
//
// bCleanInstall    -  True if setup is performing a clean install
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
DetermineProfilesLocation(
     BOOL bCleanInstall);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// CreateUserProfile(Ex)
//
// Creates a user profile for the given user.  Used by the Win95 -> NT5
// migration code.
//
// pSid         - SID of new user
// lpUserName   - User name of new user
// lpUserHive   - Registry hive to use (optional, can be NULL)
// lpProfileDir - Receives the user's profile directory (can be NULL)
// dwDirSize    - Size of lpProfileDir
// bWin9xUpg    -   Flag to say whether it is win9x upgrade
//
// Returns:  TRUE if successful
//           FALSE if not.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
CreateUserProfileA(
     IN  PSID pSid,
     IN  LPCSTR lpUserName,
     IN  LPCSTR lpUserHive,
     OUT LPSTR lpProfileDir,
     IN  DWORD dwDirSize);
USERENVAPI
BOOL
WINAPI
CreateUserProfileW(
     IN  PSID pSid,
     IN  LPCWSTR lpUserName,
     IN  LPCWSTR lpUserHive,
     OUT LPWSTR lpProfileDir,
     IN  DWORD dwDirSize);
#ifdef UNICODE
#define CreateUserProfile  CreateUserProfileW
#else
#define CreateUserProfile  CreateUserProfileA
#endif // !UNICODE

USERENVAPI
BOOL
WINAPI
CreateUserProfileExA(
     IN  PSID pSid,
     IN  LPCSTR lpUserName,
     IN  LPCSTR lpUserHive,
     OUT LPSTR lpProfileDir,
     IN  DWORD dwDirSize,
     IN  BOOL bWin9xUpg);
USERENVAPI
BOOL
WINAPI
CreateUserProfileExW(
     IN  PSID pSid,
     IN  LPCWSTR lpUserName,
     IN  LPCWSTR lpUserHive,
     OUT LPWSTR lpProfileDir,
     IN  DWORD dwDirSize,
     IN  BOOL bWin9xUpg);
#ifdef UNICODE
#define CreateUserProfileEx  CreateUserProfileExW
#else
#define CreateUserProfileEx  CreateUserProfileExA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// CopyProfileDirectory(Ex)
//
// Multi-threaded user profile coping algorithm.
//
// lpSourceDir       - Source directory
// lpDestinationDir  - Destination directory
// dwFlags           - Flags (defined below)
// ftDelRefTime      - Reference time used when deleted extra files
//                     in a CPD_SYNCHRONIZE operation
// lpExclusionList   - List of directories to exclude when copying the
//                     profile
//
// Returns:  TRUE if successful
//           FALSE if not.
//
// Notes:    When CPD_SYNCHRONIZE is used to copy a profile from one
//           location to another, all the files / directories are copied first
//           and then extra files in the target directory are deleted.  In the
//           case of 2 machines using the same roaming profile, it doesn't make
//           sense to delete the extra files everytime.  If the CPD_USEDELREFTIME
//           flag is set, then before deleting a file or directory, the
//           time on that file or directory is compared with ftDelRefTime.
//           If the time is newer, the file / directory is not deleted because
//           it is probably a new file from a different machine.  If the
//           time is older, the file / directory is deleted.
//
//           CopyProfileDirectoryEx can also exclude certain directories
//           from the copy.  If the CPD_USEEXCLUSIONLIST flag is set and
//           lpExclusionList is non-null, the specified directories (and
//           their children) will be excuded from the copy.  The format
//           of this parameter is a semi-colon separated list of directories
//           relative to the root of the source profile. For example:
//
//               Temporary Internet Files;Temp;Foo\Bar
//
//=============================================================================

//
// Flags for CopyProfileDirectory(Ex)
//

#define CPD_FORCECOPY            0x00000001  // Ignore time stamps and always copy the file
#define CPD_IGNORECOPYERRORS     0x00000002  // Ignore errors and keep going
#define CPD_IGNOREHIVE           0x00000004  // Don't copy registry hive
#define CPD_WIN95HIVE            0x00000008  // Looking for Win 9x registry hive instead of NT registry hive
#define CPD_COPYIFDIFFERENT      0x00000010  // If a file exists in both src and dest with different time stamps, always copy it.
#define CPD_SYNCHRONIZE          0x00000020  // Make dest directory structure indentical to src directory structure (delete extra files and directories)
#define CPD_SLOWCOPY             0x00000040  // Don't use multiple thread.  Copy one file at a time.
#define CPD_SHOWSTATUS           0x00000080  // Show progress dialog
#define CPD_CREATETITLE          0x00000100  // Change progress dialog title to Creating... rather than Copying...
#define CPD_COPYHIVEONLY         0x00000200  // Only copy the hive, no other files
#define CPD_USEDELREFTIME        0x00000400  // Use ftDelRefTime parameter in CopyProfileDirectoryEx
#define CPD_USEEXCLUSIONLIST     0x00000800  // Use lpExclusionList parameter in CopyProfileDirectoryEx
#define CPD_SYSTEMFILES          0x00001000  // Only copy files and directories with the system file attribute set
#define CPD_DELDESTEXCLUSIONS    0x00002000  // If a directory that is excluded in the source already exists in the destination, delete it
#define CPD_NONENCRYPTEDONLY     0x00004000  // Copy only non encrypted files
#define CPD_IGNORESECURITY       0x00008000  // Ignore the ACLs etc. on the source files
#define CPD_NOERRORUI            0x00010000  // Do not show the UI if error occurs
#define CPD_SYSTEMDIRSONLY       0x00020000  // Only copy directories with the system file attribute set
#define CPD_IGNOREENCRYPTEDFILES 0x00040000  // Ignore Encrypted files
#define CPD_IGNORELONGFILENAMES  0x00080000  // Ignore files with long file names
#define CPD_USETMPHIVEFILE       0x00100000  // user hive is still loaded


USERENVAPI
BOOL
WINAPI
CopyProfileDirectoryA(
     IN  LPCSTR lpSourceDir,
     IN  LPCSTR lpDestinationDir,
     IN  DWORD dwFlags);
USERENVAPI
BOOL
WINAPI
CopyProfileDirectoryW(
     IN  LPCWSTR lpSourceDir,
     IN  LPCWSTR lpDestinationDir,
     IN  DWORD dwFlags);
#ifdef UNICODE
#define CopyProfileDirectory  CopyProfileDirectoryW
#else
#define CopyProfileDirectory  CopyProfileDirectoryA
#endif // !UNICODE


USERENVAPI
BOOL
WINAPI
CopyProfileDirectoryExA(
     IN  LPCSTR lpSourceDir,
     IN  LPCSTR lpDestinationDir,
     IN  DWORD dwFlags,
     IN  LPFILETIME ftDelRefTime,
     IN  LPCSTR lpExclusionList);
USERENVAPI
BOOL
WINAPI
CopyProfileDirectoryExW(
     IN  LPCWSTR lpSourceDir,
     IN  LPCWSTR lpDestinationDir,
     IN  DWORD dwFlags,
     IN  LPFILETIME ftDelRefTime,
     IN  LPCWSTR lpExclusionList);
#ifdef UNICODE
#define CopyProfileDirectoryEx  CopyProfileDirectoryExW
#else
#define CopyProfileDirectoryEx  CopyProfileDirectoryExA
#endif // !UNICODE


//=============================================================================
//
// MigrateNT4ToNT5
//
// Migrates a user's profile from NT4 to NT5.  This function should
// only be called by shmgrate.exe
//
// Returns:  TRUE if successful
//           FALSE if not.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
MigrateNT4ToNT5();

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// ResetUserSpecialFolderPaths
//
// Sets all of the user special folder paths back to their defaults
//
// Returns:  TRUE if successful
//           FALSE if not.
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
ResetUserSpecialFolderPaths();

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GetSystemTempDirectory
//
// Gets the system wide temp directory in short form
//
// Returns:  TRUE if successful
//           FALSE if not.
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
GetSystemTempDirectoryA(
    OUT LPSTR lpDir,
    IN OUT LPDWORD lpcchSize);
USERENVAPI
BOOL
WINAPI
GetSystemTempDirectoryW(
    OUT LPWSTR lpDir,
    IN OUT LPDWORD lpcchSize);
#ifdef UNICODE
#define GetSystemTempDirectory  GetSystemTempDirectoryW
#else
#define GetSystemTempDirectory  GetSystemTempDirectoryA
#endif // !UNICODE


//=============================================================================
//
// ApplySystemPolicy
//
//
// Entry point for Windows NT4 System Policy.
//
// dwFlags         - Flags
// hToken          - User's token
// hKeyCurrentUser - Registry to the root of the user's hive
// lpUserName      - User's name
// lpPolicyPath    - Path to the policy file (ntconfig.pol). Can be NULL.
// lpServerName    - Domain controller name used for group
//                   membership look up.  Can be NULL.
//
//
// Returns:  TRUE if successful
//           FALSE if not
//
//=============================================================================

#if(WINVER >= 0x0500)

#define SP_FLAG_APPLY_MACHINE_POLICY    0x00000001
#define SP_FLAG_APPLY_USER_POLICY       0x00000002

USERENVAPI
BOOL
WINAPI
ApplySystemPolicyA(
    IN DWORD dwFlags,
    IN HANDLE hToken,
    IN HKEY hKeyCurrentUser,
    IN LPCSTR lpUserName,
    IN LPCSTR lpPolicyPath,
    IN LPCSTR lpServerName);
USERENVAPI
BOOL
WINAPI
ApplySystemPolicyW(
    IN DWORD dwFlags,
    IN HANDLE hToken,
    IN HKEY hKeyCurrentUser,
    IN LPCWSTR lpUserName,
    IN LPCWSTR lpPolicyPath,
    IN LPCWSTR lpServerName);
#ifdef UNICODE
#define ApplySystemPolicy  ApplySystemPolicyW
#else
#define ApplySystemPolicy  ApplySystemPolicyA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

#if(WINVER >= 0x0500)

//=============================================================================
//
// Data types and data structures for foreground policy refresh info.
//
//=============================================================================

typedef enum _tagFgPolicyRefreshReason
{
    GP_ReasonUnknown = 0,
    GP_ReasonFirstPolicy,
    GP_ReasonCSERequiresSync,
    GP_ReasonCSESyncError,
    GP_ReasonSyncForced,
    GP_ReasonSyncPolicy,
    GP_ReasonNonCachedCredentials,
    GP_ReasonSKU
} FgPolicyRefreshReason;

typedef enum _tagFgPolicyRefreshMode
{
    GP_ModeUnknown = 0,
    GP_ModeSyncForeground,
    GP_ModeAsyncForeground,
} FgPolicyRefreshMode;

typedef struct _tagFgPolicyRefreshInfo
{
    FgPolicyRefreshReason   reason;
    FgPolicyRefreshMode     mode;
} FgPolicyRefreshInfo, *LPFgPolicyRefreshInfo;

//=============================================================================
//
// SetNextFgPolicyRefreshInfo
//
// Sets information about the next foreground policy
//
// szUserSid    - user's SID for user's info, 0 for machine info
// info         - FgPolicyRefreshInfo structure with the reason and mode info
//
// Returns:  WIN32 error code
//
//=============================================================================

USERENVAPI
DWORD
WINAPI
SetNextFgPolicyRefreshInfo( LPWSTR szUserSid,
                            FgPolicyRefreshInfo info );

//=============================================================================
//
// GetPreviousFgPolicyRefreshInfo
//
// Gets information about the previous foreground policy
//
// szUserSid    - user's SID for user's info, 0 for machine info
// pInfo        - pointer to the FgPolicyRefreshInfo structure; returns the info
//
// Returns:  WIN32 error code
//
//=============================================================================

USERENVAPI
DWORD
WINAPI
GetPreviousFgPolicyRefreshInfo( LPWSTR szUserSid,
                                FgPolicyRefreshInfo* pInfo );

//=============================================================================
//
// GetNextFgPolicyRefreshInfo
//
// Gets information about the previous foreground policy
//
// szUserSid    - user's SID for user's info, 0 for machine info
// pInfo        - pointer to the FgPolicyRefreshInfo structure; returns info
//
// Returns:  WIN32 error code
//
//=============================================================================

USERENVAPI
DWORD
WINAPI
GetNextFgPolicyRefreshInfo( LPWSTR szUserSid,
                            FgPolicyRefreshInfo* pInfo );

//=============================================================================
//
// ForceSyncFgPolicy
//
// Forces the next foreground policy to be Synchronous
//
// szUserSid    - user's SID for user's info, 0 for machine info
//
// Returns:  WIN32 error code
//
//=============================================================================

USERENVAPI
DWORD
WINAPI
ForceSyncFgPolicy( LPWSTR szUserSid );

//=============================================================================
//
// WaitForUserPolicyForegroundProcessing
//
// Blocks the caller until the user foreground policy is finished
//
// Returns:  WIN32 error code
//
//=============================================================================

USERENVAPI
DWORD
WINAPI
WaitForUserPolicyForegroundProcessing();

//=============================================================================
//
// WaitForMachinePolicyForegroundProcessing
//
// Blocks the caller until the machine foreground policy is finished
//
// Returns:  WIN32 error code
//
//=============================================================================

USERENVAPI
DWORD
WINAPI
WaitForMachinePolicyForegroundProcessing();

//=============================================================================
//
// IsSyncForegroundPolicyRefresh
//
// Called during foreground refresh to determine whether the refresh is sync or
// async
//
// bMachine             - user or machine
// hToken               - User or machine token
//
// Returns:  TRUE if foreground  policy should be applied synchronously,
//           FALSE otherwise
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
IsSyncForegroundPolicyRefresh(  BOOL bMachine,
                                HANDLE hToken );

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// ApplyGroupPolicy
//
//
// Entry point for Group Policy.  Causes either machine or user
// policy to be applied.
//
// dwFlags         - Flags defined below
// hToken          - User or machine token
// hEvent          - Handle to an event which causes the policy thread to
//                   terminate when signaled.
// hKeyRoot        - Registry to the root of the correspond hive
//                   eg: HKLM or HKCU for the user that matches hToken
// pStatusCallback - Callback function for displaying status messages
//
//
// Returns:  If GP_BACKGROUND_REFRESH is set, a thread handle
//           the process can wait until after signaling for policy
//           to stop. If GPT_BACKGROUND_REFRESH is not set, the
//           return value is 1.
//
//           In the case of failure, NULL will be returned.
//
//=============================================================================

#if(WINVER >= 0x0500)

//
// Flags to the ApplyGroupPolicy() function
//

#define GP_MACHINE             0x00000001  // Process for machine (vs user)
#define GP_BACKGROUND_REFRESH  0x00000002  // Use background thread
#define GP_APPLY_DS_POLICY     0x00000004  // Apply policy from the DS also
#define GP_ASYNC_FOREGROUND    0x00000008  // don't wait on network services

//
// Flags set by ApplyGroupPolicy() function (do not pass these in)
//

#define GP_BACKGROUND_THREAD          0x00010000  // Background thread processing
#define GP_REGPOLICY_CPANEL           0x00020000  // Something changed in the CP settings
#define GP_SLOW_LINK                  0x00040000  // Slow network connection
#define GP_VERBOSE                    0x00080000  // Verbose output to eventlog
#define GP_FORCED_REFRESH             0x00100000  // Forced Refresh
// The 2 bit values were briefly used. 
#define GP_PLANMODE                   0x00800000  // Planning mode flag

USERENVAPI
HANDLE
WINAPI
ApplyGroupPolicy(
    IN DWORD dwFlags,
    IN HANDLE hToken,
    IN HANDLE hEvent,
    IN HKEY hKeyRoot,
    IN PFNSTATUSMESSAGECALLBACK pStatusCallback);


//=============================================================================
//
//  GenerateRsopPolicy
//
//  Generates planning mode Rsop policy for specified target
//
//  dwFlags          - Processing flags
//  bstrMachName     - Target computer name
//  bstrNewMachSOM   - New machine domain or OU
//  psaMachSecGroups - New machine security groups
//  bstrUserName     - Target user name
//  psaUserSecGroups - New user security groups
//  bstrSite         - Site of target computer
//  pwszNameSpace    - Namespace to write Rsop data
//  pProgress        - Progress indicator info
//  pMachGpoFilter   - GPO Filters that pass in machine processing
//  pUserGpoFilter   - GPO Filters that pass in user processing
//
//  Return:     True if successful, False otherwise
//
//=============================================================================

USERENVAPI
BOOL
WINAPI
GenerateRsopPolicy(
    IN DWORD dwFlags,
    IN BSTR bstrMachName,
    IN BSTR bstrNewMachSOM,
    IN SAFEARRAY *psaMachSecGroups,
    IN BSTR bstrUserName,
    IN BSTR bstrNewUserSOM,
    IN SAFEARRAY *psaUserSecGroups,
    IN BSTR bstrSite,
    IN WCHAR *pwszNameSpace,
    IN LPVOID pProgress,
    IN LPVOID pMachGpoFilter,
    IN LPVOID pUserGpoFilter);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
//  ShutdownGPOProcessing()
//
//  Entry point for aborting GPO processing
//
//  bMachine    -  Shutdown machine or user processing ?
//
//  Returns:    void
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
void
WINAPI
ShutdownGPOProcessing(
    IN BOOL bMachine);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
//  PingComputer()
//
//  Pings the specified computer
//
//  ipaddr    -  IP address of the computer in unsigned long form
//  ulSpeed   -  Data transfer rate
//
//  Notes:      For fast connections (eg: LAN), it isn't possible
//              to get accurate transfer rates since the response
//              time from the computer is less than 10ms.  In
//              this case, the function returns ERROR_SUCCESS
//              and ulSpeed is set to 0.  If the function returns
//              ERROR_SUCCESS and the ulSpeed argument is non-zero
//              the connections is slower
//
//  Returns:    ERROR_SUCCESS if successful
//              Win32 error code if not
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
DWORD
WINAPI
PingComputer(
    IN ULONG ipaddr,
    OUT ULONG *ulSpeed);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
//  InitializeUserProfile()
//
//  Called by winlogon to initialize userenv.dll for loading/unloading user
//  profiles.
//
//  Returns:    fvoid
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
void
WINAPI
InitializeUserProfile();

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
//  EnterUserProfileLock()
//
//  Get the user profile synchronization lock for a user
//
//  Returns:    HRESULT
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
DWORD
WINAPI
EnterUserProfileLock(LPTSTR pSid);

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
//  LeaveUserProfileLock()
//
//  Release the user profile synchronization lock for a user
//
//  Returns:    HRESULT
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
DWORD
WINAPI
LeaveUserProfileLock(LPTSTR pSid);

#endif /* WINVER >= 0x0500 */

//*************************************************************************
//
// SecureUserProfiles()
//
// Routine Description : 
//          This function secures user profiles during FAT->NTFS conversion.
//          The function loops through all profiles registered under current 
//          OS and sets the security for the corresponding profile directory  
//          and  nested subdirs. Assumption is the  function will be called 
//          only during FAT->NTFS conversion.
//
// Arguments : 
//          None.
//
// Return Value : 
//          None.
//
// History:    Date        Author     Comment
//             8/8/00      santanuc   Created
//
//*************************************************************************

#if(WINVER >= 0x0500)

USERENVAPI
void
WINAPI
SecureUserProfiles(void);

#endif /* WINVER >= 0x0500 */

//*************************************************************************
//
// CheckAccessForPolicyGeneration()
//
// Routine Description : 
//          This function checks whether the given user represented by the token
//          has access to generate rsop data (planning or logging)
//
// Arguments : 
//          hToken      -       Token of the user
//          szContainer	-       Container for which access needs to be checked. 
//                              Should be OU or domain container
//          szDomain    -       Domaindns where the container exists
//          bLogging    -       True if the rsop data is to be genearated for 
//                              logging mode
//          pbAccessGranted -   Access Granted or not
//                        
//
// Return Value : 
//        ERROR_SUCCESS on success. Appropriate error code otherwise
//
//*************************************************************************

#if(WINVER >= 0x0500)

USERENVAPI
DWORD 
WINAPI
CheckAccessForPolicyGeneration( HANDLE hToken, 
                                LPCWSTR szContainer,
				LPWSTR  szDomain,
                                BOOL    bLogging,
                                BOOL*   pbAccessGranted);

#endif /* WINVER >= 0x0500 */

//*************************************************************************
//
// GetGroupPolicyNetworkName()
//
// Routine Description : 
//          This function returns the name of the network from which policy
//          was applied.
//
// Arguments : 
//          szNetworkName - unicode string buffer representing the network name
//          pdwByteCount - size in bytes of the unicode string buffer
//
// Return Value : 
//          ERROR_SUCCESS if successful, error code otherwise.
//
//*************************************************************************

#if(WINVER >= 0x0500)

USERENVAPI
DWORD 
WINAPI
GetGroupPolicyNetworkName( LPWSTR szNetworkName, LPDWORD pdwByteCount );

#endif /* WINVER >= 0x0500 */

//*************************************************************
//
//  GetUserAppDataPath()
//
//  Purpose:    Returns the path for user's Appdata.
//
//  Parameters: hToken          -   User's token
//              lpFolderPath    -   Output buffer
//
//  Return:     ERROR_SUCCESS if successful
//              otherwise the error code
//
//  Comments:   If error occurs then lpFolderPath set to empty.
//              Used by Crypto guys to avoid calling SHGetFolderPath.
//
//*************************************************************

#if(WINVER >= 0x0500)

USERENVAPI
DWORD 
WINAPI
GetUserAppDataPathA(
    IN HANDLE hToken, 
    OUT LPSTR lpFolderPath);
USERENVAPI
DWORD 
WINAPI
GetUserAppDataPathW(
    IN HANDLE hToken, 
    OUT LPWSTR lpFolderPath);
#ifdef UNICODE
#define GetUserAppDataPath  GetUserAppDataPathW
#else
#define GetUserAppDataPath  GetUserAppDataPathA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

//=============================================================================
//
// GetUserProfileDirFromSid
//
// Returns the path to the root of the requested user's profile
//
// pSid           -  User's SID returned from LookupAccountName()
// lpProfileDir   -  Receives the path
// lpcchSize      -  Size of lpProfileDir
//
// Returns:  TRUE if successful
//           FALSE if not.  Call GetLastError() for more details
//
// Note:     If lpProfileDir is not large enough, the function will fail,
//           and lpcchSize will contain the necessary buffer size.
//
// Example return value: C:\Documents and Settings\Joe
//
//=============================================================================

#if(WINVER >= 0x0500)

USERENVAPI
BOOL
WINAPI
GetUserProfileDirFromSidA(
    IN PSID pSid,
    OUT LPSTR lpProfileDir,
    IN OUT LPDWORD lpcchSize);
USERENVAPI
BOOL
WINAPI
GetUserProfileDirFromSidW(
    IN PSID pSid,
    OUT LPWSTR lpProfileDir,
    IN OUT LPDWORD lpcchSize);
#ifdef UNICODE
#define GetUserProfileDirFromSid  GetUserProfileDirFromSidW
#else
#define GetUserProfileDirFromSid  GetUserProfileDirFromSidA
#endif // !UNICODE

#endif /* WINVER >= 0x0500 */

#ifdef __cplusplus
}
#endif

#endif // _INC_USERENVP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\winsaferp.h ===
#ifdef __cplusplus
extern "C" {
#endif
#define SAFER_SCOPEID_REGISTRY 3
#define SAFER_LEVEL_DELETE 2
#define SAFER_LEVEL_CREATE 4

//
// Private registry key locations.
//

#define SAFER_HKLM_REGBASE L"Software\\Policies\\Microsoft\\Windows\\Safer"
#define SAFER_HKCU_REGBASE L"Software\\Policies\\Microsoft\\Windows\\Safer"

//
// default winsafer executable file types as a multisz string 
//

#define  SAFER_DEFAULT_EXECUTABLE_FILE_TYPES L"ADE\0ADP\0BAS\0BAT\0CHM\0\
CMD\0COM\0CPL\0CRT\0EXE\0HLP\0HTA\0INF\0INS\0ISP\0LNK\0MDB\0MDE\0MSC\0\
MSI\0MSP\0MST\0OCX\0PCD\0PIF\0REG\0SCR\0SHS\0URL\0VB\0WSC\0"


//
// name of the objects sub-branch.
//

#define SAFER_OBJECTS_REGSUBKEY L"LevelObjects"

//
// names of the values under each of the object sub-branches.
//

#define SAFER_OBJFRIENDLYNAME_REGVALUEW L"FriendlyName"
#define SAFER_OBJDESCRIPTION_REGVALUEW  L"Description"
#define SAFER_OBJDISALLOW_REGVALUE      L"DisallowExecution"

//
// name of the code identifiers sub-branch
//

#define SAFER_CODEIDS_REGSUBKEY L"CodeIdentifiers"

//
// name of the value under the top level code identifier branch.
//

#define SAFER_DEFAULTOBJ_REGVALUE         L"DefaultLevel"
#define SAFER_TRANSPARENTENABLED_REGVALUE L"TransparentEnabled"
#define SAFER_HONORUSER_REGVALUE          L"HonorUserIdentities"
#define SAFER_EXETYPES_REGVALUE           L"ExecutableTypes"
#define SAFER_POLICY_SCOPE                L"PolicyScope"
#define SAFER_LOGFILE_NAME                L"LogFileName"
#define SAFER_HIDDEN_LEVELS               L"Levels"
#define SAFER_AUTHENTICODE_REGVALUE       L"AuthenticodeEnabled"

//
// names of the various subkeys under the code identifier sub-branches
//

#define SAFER_PATHS_REGSUBKEY     L"Paths"
#define SAFER_HASHMD5_REGSUBKEY   L"Hashes"
#define SAFER_SOURCEURL_REGSUBKEY L"UrlZones"

//
// names of the various values under each code identifiery sub-branch.
//

#define SAFER_IDS_LASTMODIFIED_REGVALUE L"LastModified"
#define SAFER_IDS_DESCRIPTION_REGVALUE  L"Description"
#define SAFER_IDS_ITEMSIZE_REGVALUE     L"ItemSize"
#define SAFER_IDS_ITEMDATA_REGVALUE     L"ItemData"
#define SAFER_IDS_SAFERFLAGS_REGVALUE   L"SaferFlags"
#define SAFER_IDS_FRIENDLYNAME_REGVALUE L"FriendlyName"
#define SAFER_IDS_HASHALG_REGVALUE      L"HashAlg"
#define SAFER_VALUE_NAME_DEFAULT_LEVEL  L"DefaultLevel"
#define SAFER_VALUE_NAME_HASH_SIZE      L"HashSize"

//
// registry values
//

#define SAFER_IDS_LEVEL_DESCRIPTION_FULLY_TRUSTED   L"DescriptionFullyTrusted"
#define SAFER_IDS_LEVEL_DESCRIPTION_NORMAL_USER     L"DescriptionNormalUser"
#define SAFER_IDS_LEVEL_DESCRIPTION_CONSTRAINED     L"DescriptionConstrained"
#define SAFER_IDS_LEVEL_DESCRIPTION_UNTRUSTED       L"DescriptionUntrusted"
#define SAFER_IDS_LEVEL_DESCRIPTION_DISALLOWED      L"DescriptionDisallowed"

//
// defines for OOB rules
//
//#define SAFER_DEFAULT_OLK_RULE_PATH L"%USERPROFILE%\\Local Settings\\Temporary Internet Files\\OLK\\"

#define SAFER_LEVEL_ZERO    L"0"
#define SAFER_REGKEY_SEPERATOR    L"\\"
#define SAFER_DEFAULT_RULE_GUID L"{dda3f824-d8cb-441b-834d-be2efd2c1a33}"



#define SAFER_GUID_RESULT_TRUSTED_CERT       \
      { 0xc59e7b5a,                         \
        0xaf71,                             \
        0x4595,                             \
        {0xb8, 0xdb, 0x46, 0xb4, 0x91, 0xe8, 0x90, 0x07} }

#define SAFER_GUID_RESULT_DEFAULT_LEVEL      \
      { 0x11015445,                         \
        0xd282,                             \
        0x4f86,                             \
        {0x96, 0xa2, 0x9e, 0x48, 0x5f, 0x59, 0x33, 0x02} }



// 
// The following is a private function that is exported
// for WinVerifyTrust to call to determine if a given hash has a
// WinSafer policy associated with it.
//

BOOL WINAPI
SaferiSearchMatchingHashRules(
    IN  ALG_ID HashAlgorithm       OPTIONAL,
    IN  PBYTE  pHashBytes,
    IN  DWORD  dwHashSize,
    IN  DWORD  dwOriginalImageSize OPTIONAL,
    OUT PDWORD pdwFoundLevel,
    OUT PDWORD pdwSaferFlags
    );

//
// The following is a private function exported to allow the current
// registry scope to be altered.  This has the effect of changing
// how AUTHZSCOPEID_REGISTRY is interepreted.
//

WINADVAPI
BOOL WINAPI
SaferiChangeRegistryScope(
    IN HKEY  hKeyCustomRoot OPTIONAL,
    IN DWORD dwKeyOptions
    );

//
// The following is a private function provided to try to empiracally
// determine if the two access token have been restricted with comparable
// WinSafer authorization Levels.  When TRUE is returned, the pdwResult
// output parameter will receive any of the following values:
//      -1 = Client's access token is more authorized than Server's.
//       0 = Client's access token is comparable level to Server's.
//       1 = Server's access token is more authorized than Clients's.
//

WINADVAPI
BOOL WINAPI
SaferiCompareTokenLevels (
    IN  HANDLE ClientAccessToken,
    IN  HANDLE ServerAccessToken,
    OUT PDWORD pdwResult
    );


WINADVAPI
BOOL WINAPI
SaferiIsExecutableFileType(
    IN LPCWSTR szFullPathname,
    IN BOOLEAN bFromShellExecute
    );

//
// The following is a private function exported to allow population if defaults in 
// the registry.
//
BOOL WINAPI
SaferiPopulateDefaultsInRegistry(
        IN HKEY     hKeyBase,
        OUT BOOL *pbSetDefaults
        );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\w32timep.h ===
//--------------------------------------------------------------------
// w32timep - interface
//
// Copyright (C) Microsoft Corporation, 2000
//
// Created by: Duncan Bryce (duncanb), 12-07-00
//
// Contains methods to configure or query the windows time service
// 

#ifndef __W32TIMEP_H__
#define __W32TIMEP_H__ 1

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------------------------------------------------
// Configurable / queryable properties for the windows time service:
//
#ifndef MIDL_PASS
#define W32TIME_CONFIG_SPECIAL_POLL_INTERVAL  0
#define W32TIME_CONFIG_MANUAL_PEER_LIST       1
#endif // MIDL_PASS

//-------------------------------------------------------------------------------------
// W32TimeQueryConfig
//
// Queries configuration information for the windows time service.  The semantics
// of the parameters depend on which property is being query:
//  
// dwProperty:   W32TIME_CONFIG_SPECIAL_POLL_INTERVAL   
// pdwType:      REG_DWORD  
// pbConfig:     a DWORD-sized buffer, containing the special polling interval (in seconds).
//               The special polling interval can be specified as an alternative to 
//               using the standard, automatically-computed polling intervals specified by
//               NTP.  NOTE: The special polling interval applies only to microsoft time 
//               providers.
// pdwSize:      sizeof(DWORD)
//     
// 
// dwProperty:   W32TIME_CONFIG_MANUAL_PEER_LIST
// pdwType:      REG_SZ
// pbConfig:     a space-delimited unicode string containing the list of time sources which the
//               microsoft time providers should sync from.  Each is an IP address
//               or DNS name of an NTP server, optionally followed by a "flags" parameter.
//               For example: 
// 
//               time.windows.com,0x3 gproxy,0x2 ntdsdc9
//
//               The following flags are available:
// 
//                   0x1  --  use the special polling interval for this source, instead of the
//                            standard NTP polling
//                   0x2  --  use this source only when no domain hierarchy sources are available
//
// pdwSize:      sizeof(WCHAR) * (wcslen(pbConfig) + 1)
//
#ifndef MIDL_PASS
HRESULT W32TimeQueryConfig(IN       DWORD   dwProperty, 
                           OUT      DWORD  *pdwType, 
                           IN OUT   BYTE   *pbConfig, 
                           IN OUT   DWORD  *pdwSize); 
#endif // MIDL_PASS

//-------------------------------------------------------------------------------------
// W32TimeSetConfig
//
// Sets configuration information for the windows time service.  The semantics
// of the parameters depend on which property is being query.  For a description 
// of the properties, see W32TimeQueryConfig(). 
//  
#ifndef MIDL_PASS
HRESULT  W32TimeSetConfig(IN  DWORD   dwProperty, 
                          IN  DWORD   dwType, 
                          IN  BYTE   *pbConfig, 
                          IN  DWORD   dwSize);
#endif // MIDL_PASS


//-------------------------------------------------------------------------------------
//
// Client-side wrappers for the w32time RPC interface
//
//-------------------------------------------------------------------------------------

#ifndef MIDL_PASS

#define TimeSyncFlag_SoftResync         0x00
#define TimeSyncFlag_HardResync         0x01
#define TimeSyncFlag_ReturnResult       0x02
#define TimeSyncFlag_Rediscover         0x04
#define TimeSyncFlag_UpdateAndResync    0x08

#define ResyncResult_Success            0x00
#define ResyncResult_NoData             0x01
#define ResyncResult_StaleData          0x02
#define ResyncResult_Shutdown           0x03
#define ResyncResult_ChangeTooBig       0x04

#endif // MIDL_PASS

//-------------------------------------------------------------------------------------
// W32TimeSyncNow
//
// Sends an RPC request to the windows time service to attempt to synchronize time with
// its configured time sources. 
//
// wszServer:    The name of the computer which should resync. 
// ulWaitFlag:   if 0 is specified, the call will be asynchronous.  Passing non-zero value
//               causes the call to block until time synchronization completes, or fails.
// ulFlags:      One of the resync types, or'd with any of the other flags.  
//               NOTE: these flags are ignored by the Windows 2000 time service.  Only
//                     Windows XP and later servers will use them.  
//
//     Resync Types:
//
//         TimeSyncFlag_SoftResync    -- the time service will synchronize the computer clock with
//                                       whatever time samples it currently has available.  It will
//                                       not poll the network, or hardware providers, for more data. 
//         TimeSyncFlag_HardResync    -- tells the time service that a time slip has occured. 
//                                       causing the time service will discard its time data.  
//                                       Microsoft default providers will attempt to acquire more 
//                                       network samples, if possible. 
//         TimeSyncFlag_Rediscover    -- tells the time service that it needs to re-resolve its
//                                       network sources, and attempt to acquire network time data. 
//                                       
//
//     Flags:
//
//         TimeSyncFlag_ReturnResult  -- used only for asynchronous calls, causes the function
//                                       to return one of its possible return status codes, or an error.
//                                       See "Return Values".
//
// Return Values:
//
//     ResyncResult_Success      --  indicates that the time synchronization has succeeded.  For asynchronous
//                                   calls, this does not guarantee that the server has acquired more data, 
//                                   merely that the request has been successfully dispatched.  
//     ResyncResult_NoData       --  Windows XP and later.  For synchronous requests, or when the 
//                                   TimeSyncFlag_ReturnResult is set, indicates that the time service couldn't
//                                   synchronize time because it failed to acquire time data. 
//     ResyncResult_StaleData    --  Windows XP and later.  For synchronous requests, or when the 
//                                   TimeSyncFlag_ReturnResult is set, indicates that the time service couldn't
//                                   synchronize time because the data it received was stale (time stamped
//                                   as received earlier than the last good sample)
//     ResyncResult_Shutdown     --  Windows XP and later.  For synchronous requests, or when the 
//                                   TimeSyncFlag_ReturnResult is set, indicates that the time service couldn't
//                                   synchronize because the service was shutting down
//     ResyncResult_ChangeTooBig --  Windows XP and later.  For synchronous requests, or when the 
//                                   TimeSyncFlag_ReturnResult is set, indicates that the time service couldn't
//                                   synchronize because it would've required a change larger than that allowed
//                                   by the w32time policy
//
//     Otherwise, the function returns a standard windows error.
// 
#ifndef MIDL_PASS
DWORD W32TimeSyncNow(IN  const WCHAR    *wszServer, 
                     IN  unsigned long   ulWaitFlag, 
                     IN  unsigned long   ulFlags);

#endif // MIDL_PASS

//-------------------------------------------------------------------------------------
// W32TimeGetNetlogonServiceBits
//
// Queries the specified time service to determine what it advertises itself as in the
// DS.  
//
// wszServer:    The name of the computer which should resync. 
// pulBits:      A set of flags indicating what the specified time service is 
//               advertised as.  Can be the OR of the following values:
// 
//      DS_TIMESERV_FLAG:        if the service is advertising as a time service
//      DS_GOOD_TIMESERV_FLAG:   if the service is advertising as a reliable time service
//
// Return Values:
// 
//      ERROR_SUCCESS if the call succeeds, otherwise, the function returns a standard
//      windows error. 
//
#ifndef MIDL_PASS
DWORD W32TimeGetNetlogonServiceBits(IN   const WCHAR    *wszServer, 
                                    OUT  unsigned long  *pulBits);
#endif // MIDL_PASS

//--------------------------------------------------------------------------------
//
// NTP provider information structures
//
//--------------------------------------------------------------------------------

// 
// W32TIME_NTP_PEER_INFO
// 
// Represents the current state of a network provider's peer.  
//
// Fields:
//
//     ulSize                 --  sizeof(W32TIME_NTP_PEER_INFO), used for versioning
//     ulResolveAttempts      --  the number of times the NTP provider has attempted to 
//                                resolve this peer unsuccessfully.  Setting this 
//                                value to 0 indicates that the peer has been successfully
//                                resolved. 
//     u64TimeRemaining       --  the number of 100ns intervals until the provider will
//                                poll this peer again
//     u64LastSuccessfulSync  --  the number of 100ns intervals since (0h 1-Jan 1601) (in UTC). 
//     ulLastSyncError        --  S_OK if the last sync with this peer was successful, otherwise, 
//                                the error that occured attempting to sync
//     ulLastSyncErrorMsgId   --  the resource identifier of a string representing the last
//                                error that occured syncing from this peer.  0 if there is no
//                                string associated with this error.  The strings are stored in
//                                the DLL in which this provider is implemented. 
//     ulValidDataCount       --  the number of valid samples from this peer the provider 
//                                currently has in its clock filter
//     ulAuthTypeMsgId        --  the resource identifier of a string representing the 
//                                authentication mechanism used by the NTP provider to 
//                                secure communications with this peer.  0 if none. 
//                                The strings are stored in the DLL in which this 
//                                provider is implemented. 
//     wszUniqueName          --  a name uniquely identifying this peer (usually the peers
//                                dns name). 
//     ulMode                 --  one of the NTP modes specified in the NTPv3 spec:
//
//     +------------------+---+
//     | Reserved         | 0 |
//     | SymmetricActive  | 1 |
//     | SymmetricPassive | 2 |
//     | Client           | 3 |
//     | Server           | 4 |
//     | Broadcast        | 5 |
//     | Control          | 6 |
//     | PrivateUse       | 7 |
//     +------------------+---+
//                  
//     ulStratum              --  this peer's stratum
//     ulreachability         --  this peer's 1-byte reachability register.  Each bit represents
//                                whether or not a poll attempt returned valid data (set == success, 
//                                unset == failure).  The low bit indicates the most recent sync, 
//                                the second bit represents the previous sync, etc.  When this register
//                                is 0, the peer is assumed to be unreachable. 
//     ulPeerPollInterval     --  the poll interval which this peer returned to the NTP provider (in log (base 2) seconds). 
//     ulHostPollInterval     --  the interval at which the NTP provider is polling this peer (in log (base 2) seconds). 
// 
typedef struct _W32TIME_NTP_PEER_INFO { 
    unsigned __int32    ulSize; 
    unsigned __int32    ulResolveAttempts;
    unsigned __int64    u64TimeRemaining;
    unsigned __int64    u64LastSuccessfulSync; 
    unsigned __int32    ulLastSyncError; 
    unsigned __int32    ulLastSyncErrorMsgId; 
    unsigned __int32    ulValidDataCounter;
    unsigned __int32    ulAuthTypeMsgId; 
#ifdef MIDL_PASS
    [string, unique]
    wchar_t            *wszUniqueName; 
#else // MIDL_PASS
    LPWSTR              wszUniqueName;
#endif // MIDL_PASS
    unsigned   char     ulMode;
    unsigned   char     ulStratum; 
    unsigned   char     ulReachability;
    unsigned   char     ulPeerPollInterval;
    unsigned   char     ulHostPollInterval;
}  W32TIME_NTP_PEER_INFO, *PW32TIME_NTP_PEER_INFO; 

//
// W32TIME_NTP_PROVIDER_DATA
//
// Represents the state of an NTP provider.
// 
//     ulSize      --  sizeof(W32TIME_NTP_PROVIDER_DATA), used for versioning
//     ulError                  --  S_OK if the provider is functioning correctly, 
//                                  otherwise, the error which caused it to fail. 
//     ulErrorMsgId             --  the resource identifier of a string representing the
//                                  error that caused this provider to fail. 
//     cPeerInfo   --  the number of active peers used by this provider
//     pPeerInfo   --  an array of W32TIME_NTP_PEER_INFO structures, representing 
//                     the active peers this provider is currently synchronizing with
//
typedef struct _W32TIME_NTP_PROVIDER_DATA { 
    unsigned __int32        ulSize; 
    unsigned __int32        ulError; 
    unsigned __int32        ulErrorMsgId; 
    unsigned __int32        cPeerInfo; 
#ifdef MIDL_PASS
    [size_is(cPeerInfo)]
#endif // MIDL_PASS
    W32TIME_NTP_PEER_INFO  *pPeerInfo; 
} W32TIME_NTP_PROVIDER_DATA, *PW32TIME_NTP_PROVIDER_DATA;

//--------------------------------------------------------------------------------
//
// HARDWARE provider structures
//
//--------------------------------------------------------------------------------

// W32TIME_HARDWARE_PROVIDER_DATA
//
// Represents the state of a HARDWARE provider.
// 
//     ulSize                   --  sizeof(W32TIME_HARDWARE_PROVIDER_DATA), used for versioning
//     ulError                  --  S_OK if the provider is functioning correctly, 
//                                  otherwise, the error which caused it to fail. 
//     ulErrorMsgId             --  the resource identifier of a string representing the
//                                  error that caused this provider to fail. 
//     wszReferenceIdentifier   --  the synchronization source (usually, the provider's
//                                  suggested 4-byte reference ID).
//                                     
typedef struct _W32TIME_HARDWARE_PROVIDER_DATA { 
    unsigned __int32   ulSize; 
    unsigned __int32   ulError; 
    unsigned __int32   ulErrorMsgId; 
#ifdef MIDL_PASS
    [string, unique]
    wchar_t           *wszReferenceIdentifier; 
#else // MIDL_PASS
    LPWSTR             wszReferenceIdentifier; 
#endif // MIDL_PASS 
} W32TIME_HARDWARE_PROVIDER_DATA, *PW32TIME_HARDWARE_PROVIDER_DATA;


//-------------------------------------------------------------------------------------
// W32TimeQueryHardwareProviderStatus
//
// Queries the specified time service for information about one of its installed 
// time providers. 
// 
// wszServer:               The name of the computer which should resync. 
// dwFlags:                 Reserved, must be 0. 
// pwszProvider:            The name of the provider to query.  
// ppHardwareProviderData:  A structure representing the current state of this hardware provider. 
//                          The returned buffer is allocated by the system, and should be
//                          freed with W32TimeBufferFree(). 
//                         
// Return Values:
//    
//      ERROR_SUCCESS if the call succeeds, otherwise, the function returns a standard
//      windows error. 
//
#ifndef MIDL_PASS
DWORD W32TimeQueryHardwareProviderStatus(IN   const WCHAR                      *wszServer, 
                                         IN   DWORD                             dwFlags, 
                                         IN   LPWSTR                            pwszProvider, 
                                         OUT  W32TIME_HARDWARE_PROVIDER_DATA  **ppHardwareProviderData);
#endif // MIDL_PASS

//-------------------------------------------------------------------------------------
// W32TimeQueryNTPProviderStatus
//
// Queries the specified time service for information about one of its installed 
// time providers. 
// 
// wszServer:          The name of the computer which should resync. 
// dwFlags:            Reserved, must be 0. 
// pwszProvider:       The name of the provider to query.  
// ppNTPProviderData:  A structure representing the current state of this hardware provider. 
//                     The returned buffer is allocated by the system, and should be
//                     freed with W32TimeBufferFree(). 
//                         
// Return Values:
//    
//      ERROR_SUCCESS if the call succeeds, otherwise, the function returns a standard
//      windows error. 
//
#ifndef MIDL_PASS
DWORD W32TimeQueryNTPProviderStatus(IN   LPCWSTR                      pwszServer, 
                                    IN   DWORD                        dwFlags, 
                                    IN   LPWSTR                       pwszProvider, 
                                    OUT  W32TIME_NTP_PROVIDER_DATA  **ppNTPProviderData); 
#endif // MIDL_PASS

//-------------------------------------------------------------------------------------
// W32TimeBufferFree
//
// Frees a buffer allocated by the w32time client API. 
// 
// pvBuffer:  the buffer to free.
//
#ifndef MIDL_PASS
void W32TimeBufferFree(IN LPVOID pvBuffer); 
#endif // MIDL_PASS

//
//-------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------
//
// W32Time named events.  
// These events are ACL'd such that LocalSystem has full access.  
//
//-------------------------------------------------------------------------------------

//
// Signaling this event tells w32time that its time is off, causing the windows time
// service to attempt resynchronization.  This does not guarantee that the time service
// will successfully adjust the system clock, or that resynchronization will occur
// in a timely manner. 
// 
#define W32TIME_NAMED_EVENT_SYSTIME_NOT_CORRECT    L"W32TIME_NAMED_EVENT_SYSTIME_NOT_CORRECT"


#ifdef __cplusplus
}  // balance extern "C" { 
#endif
 
#endif // #ifndef __W32TIMEP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\aes.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    aes.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize the low-level AES encryption routines


Author:

    Scott Field (SField) 09-October-2000

Revision History:

--*/


#ifndef __AES_H__
#define __AES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif



#define AES_ROUNDS_128  (10)
#define AES_ROUNDS_192  (12)
#define AES_ROUNDS_256  (14)

#define AES_MAXROUNDS   AES_ROUNDS_256


typedef struct {
    int             rounds; // keytab data ends up padded.
    unsigned char   keytabenc[AES_MAXROUNDS+1][4][4];
    unsigned char   keytabdec[AES_MAXROUNDS+1][4][4];
} AESTable;

typedef struct {
    int             rounds; // keytab data ends up padded.
    unsigned char   keytabenc[AES_ROUNDS_128+1][4][4];
    unsigned char   keytabdec[AES_ROUNDS_128+1][4][4];
} AESTable_128;

typedef struct {
    int             rounds; // keytab data ends up padded.
    unsigned char   keytabenc[AES_ROUNDS_192+1][4][4];
    unsigned char   keytabdec[AES_ROUNDS_192+1][4][4];
} AESTable_192;

typedef struct {
    int             rounds; // keytab data ends up padded.
    unsigned char   keytabenc[AES_ROUNDS_256+1][4][4];
    unsigned char   keytabdec[AES_ROUNDS_256+1][4][4];
} AESTable_256;

#define AES_TABLESIZE   (sizeof(AESTable))
#define AES_TABLESIZE_128   (sizeof(AESTable_128))
#define AES_TABLESIZE_192   (sizeof(AESTable_192))
#define AES_TABLESIZE_256   (sizeof(AESTable_256))


#define AES_BLOCKLEN    (16)
#define AES_KEYSIZE     (32)

#define AES_KEYSIZE_128 (16)
#define AES_KEYSIZE_192 (24)
#define AES_KEYSIZE_256 (32)


void
RSA32API
aeskey(
    AESTable    *KeyTable,
    BYTE        *Key,
    int         rounds
    );

//
// generic AES crypt function -- caller can pass in keyin corresponding
// to any valid keysize.
//

void
RSA32API
aes(
    BYTE    *pbOut,
    BYTE    *pbIn,
    void    *keyin,
    int     op
    );

//
// AES crypt functions that can be used by a caller that passes in a keyin
// corresponding to a known keysize.
//

void
RSA32API
aes128(
    BYTE    *pbOut,
    BYTE    *pbIn,
    void    *keyin,
    int     op
    );

void
RSA32API
aes256(
    BYTE    *pbOut,
    BYTE    *pbIn,
    void    *keyin,
    int     op
    );



#ifdef __cplusplus
}
#endif

#endif // __AES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\des.h ===
#ifndef __DES_H__
#define __DES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _destable {
    unsigned long   keytab[16][2];
} DESTable;

#define DES_TABLESIZE   (sizeof(DESTable))
#define DES_BLOCKLEN    (8)
#define DES_KEYSIZE     (8)

typedef struct _desxtable {
    unsigned char inWhitening[8];
    unsigned char outWhitening[8];
    DESTable desTable;
} DESXTable;

#define DESX_TABLESIZE  (sizeof(DESXTable))
#define DESX_BLOCKLEN   (8)
#define DESX_KEYSIZE    (24)

/* In deskey.c:

     Fill in the DESTable struct with the decrypt and encrypt
     key expansions.

     Assumes that the second parameter points to DES_BLOCKLEN
     bytes of key.

*/

void RSA32API deskey(DESTable *,unsigned char *);

/* In desport.c:

     Encrypt or decrypt with the key in DESTable

*/

void RSA32API des(UCHAR *pbOut, UCHAR *pbIn, void *key, int op);

//
// set the parity on the DES key to be odd
// NOTE : must be called before deskey
// key must be cbKey number of bytes
//
void RSA32API desparityonkey(UCHAR *pbKey, ULONG cbKey);

//
// reduce the DES key to a 40 bit key
// NOTE : must be called before deskey
// key must be 8 bytes
//
void RSA32API desreducekey(UCHAR *key);

// Expand 40 bit DES key to 64 and check weakness
// same as desreducekey except expands instead of weakening keys
void RSA32API deskeyexpand(UCHAR *pbKey, UCHAR *pbExpanded_key);


void
RSA32API
desexpand128to192(
    UCHAR *pbKey,        // input 128bit or 192bit buffer
    UCHAR *pbExpandedKey // output buffer (must be 192bit wide if pbKey == pbExpandedKey
    );

// DES-X routines

// initialize desX key struct.  key size is 24 bytes
void RSA32API desxkey(DESXTable *k, UCHAR *key);

void RSA32API desx(UCHAR *pbOut, UCHAR *pbIn, void *keyin, int op);


extern int Asmversion;  /* 1 if we're linked with an asm version, 0 if C */

#ifdef __cplusplus
}
#endif

#endif // __DES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\bignum.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    bignum.h

Abstract:

    bignum package routines and defines.

--*/

#include <windows.h>
#include <math.h>

#ifndef RADIX_BITS              /* If not previously #included */

#define MP_LONGEST_BITS  2048
                        /*
                           Multiple precision moduli can have up to
                           MP_LONGEST_BITS bits, which is
                           MP_LONGEST words.  Some routines allow
                           longer operands.
                        */


                        /*
                           Error messages are not printed in the
                           production version of the code.
                           In the test version, compiled
                           by MSCV with ENABLE_ERROR_MESSAGES
                           listed under PREPROCESSOR DEFINITIONS
                           in the project workspace, they are printed,
                        */

#ifndef PRINT_ERROR_MESSAGES
    #ifdef ENABLE_ERROR_MESSAGES
        #define PRINT_ERROR_MESSAGES 1
    #else
        #define PRINT_ERROR_MESSAGES 0
    #endif
#endif

#if PRINT_ERROR_MESSAGES
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#endif

#define COMPILER_GCC 1
#define COMPILER_VC  2

#ifndef COMPILER
    #ifdef __GNUC__
        #define COMPILER COMPILER_GCC
                        /* GNU compiler */
    #endif
    #ifdef _MSC_VER
        #define COMPILER COMPILER_VC
    #endif              /* Microsoft Visual C compiler */
#endif

#if !defined(COMPILER) || COMPILER <= 0
    #error -- "Unknown COMPILER"
#endif

#define COMPILER_NAME  ( \
        COMPILER == COMPILER_GCC ? "GCC compiler" \
      : COMPILER == COMPILER_VC  ? "Microsoft Visual C++ compiler" \
      : "Unknown compiler")
/*
        Major Windows operating systems
*/

#define OS_WCE 1
#define OS_WNT 2


#if defined(_WIN32_WCE)
    #define TARGET_OS OS_WCE
    #define assert(exp) 0 // or ASSERT(exp)
                 // No assert.h in Windows CE
#elif defined(WIN32)
    #define TARGET_OS OS_WNT
#else
    #error "Unknown OS target"
#endif

/*
        List of architectures on which code has been run.
        The SPARC code was used only during development,
        and is not a deliverable.
*/

#define TARGET_AMD64 1
#define TARGET_IX86 2
#define TARGET_MIPS 3
#define TARGET_PPC 4
#define TARGET_SPARC 5
#define TARGET_IA64 6
#define TARGET_ARM 7
#define TARGET_SHX 8



#ifndef TARGET
    #if defined(_M_AMD64)               // AMD 64-bit
        #define TARGET TARGET_AMD64
    #endif
    #if defined(_M_IX86) || defined(_x86)  // Intel X86 (e.g., 486, Pentium)
        #define TARGET TARGET_IX86
    #endif
    #if defined(_M_MRX000) || defined(_MIPS_) // MIPS 32-bit systems
        #define TARGET TARGET_MIPS
    #endif
    #if defined(_M_PPC)       // Motorola/Macintosh Power PC
        #define TARGET TARGET_PPC
    #endif
    #if defined(__sparc__)    // Sun SPARC
        #define TARGET TARGET_SPARC
    #endif
    #if defined(_M_IA64)      // Intel IA-64 (e.g., Merced, McKinley)
        #define TARGET TARGET_IA64
    #endif
    #if defined(_ARM_)
        #define TARGET TARGET_ARM
    #endif
    #if defined(_SH3_) || defined(_SH4_)   // Hitachi SH-3 or SH-4
        #define TARGET TARGET_SHX
    #endif
#endif

#if !defined(TARGET) || TARGET <= 0
    #error -- "Unknown TARGET"
#endif

#define TARGET_NAME ( \
          TARGET == TARGET_AMD64   ? "AMD64" \
        : TARGET == TARGET_IX86    ? "Intel x86 (x >= 3) and Pentium" \
        : TARGET == TARGET_MIPS    ? "MIPS R2000/R3000" \
        : TARGET == TARGET_PPC     ? "Macintosh/Motorola PowerPC" \
        : TARGET == TARGET_SPARC   ? "Sun SPARC" \
        : TARGET == TARGET_IA64    ? "Intel IA-64" \
        : TARGET == TARGET_ARM     ? "ARM" \
        : TARGET == TARGET_SHX     ? "Hitachi SHx" \
        : "Unknown target architecture")

/*
        USEASM_AMD64, ... specify whether to use assembly language,
        if it has been written for a platform.
*/
#ifndef USEASM
    #if TARGET == TARGET_IX86
        #define USEASM 1
    #elif TARGET == TARGET_MIPS
        #define USEASM 1
    #elif TARGET == TARGET_SHX
        #define USEASM 1
    #else
        #define USEASM 0
    #endif
#endif

#if !defined(USEASM) || (USEASM != 0 && USEASM != 1)
    #error "USEASM not defined"
#endif

#define USEASM_AMD64    (USEASM && TARGET == TARGET_AMD64)
#define USEASM_IX86     (USEASM && TARGET == TARGET_IX86)
#define USEASM_MIPS     (USEASM && TARGET == TARGET_MIPS)
#define USEASM_PPC      (USEASM && TARGET == TARGET_PPC)
#define USEASM_SPARC    (USEASM && TARGET == TARGET_SPARC)
#define USEASM_IA64     (USEASM && TARGET == TARGET_IA64)
#define USEASM_ARM      (USEASM && TARGET == TARGET_ARM)
#define USEASM_SHX      (USEASM && TARGET == TARGET_SHX)


#if USEASM_SHX
void __asm(const char*, ...);    // this declartion needed to allow inline of asm
#endif

#if COMPILER == COMPILER_VC
        /*
           Visual C recognizes _inline but not inline.
        */
    #define inline _inline

    #pragma intrinsic(abs, labs, memcpy)

    #if TARGET != TARGET_SHX
    #pragma intrinsic(memset)
    #endif

    #pragma warning(disable: 4146 4514)
         /* 4146 -- unary minus operator applied
            to unsigned type, result still unsigned.
            4514 -- unreferenced inline function
          */
#endif


#if TARGET_OS == OS_WCE
    #define assert(exp) 0 // or ASSERT(exp)
                 // No assert.h in Windows CE
    #define CEstatic static
                 // Windows CE stack limited to 64K
                 // CEstatic should be used only in
                 // test codes and other
                 // single-threaded, non-recursive. codes.
#else
    #define CEstatic
#endif

/*
        x86 assembly routines are declared naked,
        so they do their own stack management and
        register saving.

        When using a DLL on Intel platforms, all functions use
        the __stdcall convention, so the assembly routines use it too.
        To ensure they are called with the __stdcall
        conventions always (i.e., even when compiled under Microsoft
        Developer Studio), we put __stdcall explicitly in the prototypes.
*/

#if USEASM_IX86
    #define Naked86 __declspec(naked)
    #define Stdcall86 __stdcall
#else
    #define Naked86
    #define Stdcall86
#endif


#if (TARGET == TARGET_AMD64) || (TARGET == TARGET_IA64)
    #define RADIX_BITS 64
    #define RADIX_BYTES 8
    typedef   signed __int64 sdigit_t;
    typedef unsigned __int64  digit_t;
#else
    #define RADIX_BITS 32
    #define RADIX_BYTES 4
    typedef   signed __int32 sdigit_t;
    typedef unsigned __int32 digit_t;
#endif

#define MP_LONGEST (MP_LONGEST_BITS/RADIX_BITS)

#if MP_LONGEST_BITS == RADIX_BITS
    #define LG2_MP_LONGEST 0
#elif MP_LONGEST_BITS == 2*RADIX_BITS
    #define LG2_MP_LONGEST 1
#elif MP_LONGEST_BITS == 4*RADIX_BITS
    #define LG2_MP_LONGEST 2
#elif MP_LONGEST_BITS == 8*RADIX_BITS
    #define LG2_MP_LONGEST 3
#elif MP_LONGEST_BITS == 16*RADIX_BITS
    #define LG2_MP_LONGEST 4
#elif MP_LONGEST_BITS == 32*RADIX_BITS
    #define LG2_MP_LONGEST 5
#elif MP_LONGEST_BITS == 64*RADIX_BITS
    #define LG2_MP_LONGEST 6
#elif MP_LONGEST_BITS == 128*RADIX_BITS
    #define LG2_MP_LONGEST 7
#elif MP_LONGEST_BITS == 256*RADIX_BITS
    #define LG2_MP_LONGEST 8
#else
    #define LG2_MP_LONGEST 0
#endif

#if MP_LONGEST_BITS != RADIX_BITS << LG2_MP_LONGEST
    #error "Unrecognized value of MP_LONGEST_BITS"
#endif


/*
        The letter 'c' following a type name identifies
        a const entity of that type.
*/
typedef const char charc;
typedef const  digit_t  digit_tc;
typedef const sdigit_t sdigit_tc;
typedef const int intc;


typedef int BOOL;       /* Same as windef.h */
#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif


#define DIGIT_ZERO ((digit_t)0)
#define DIGIT_ONE  ((digit_t)1)
#define RADIX_HALF (DIGIT_ONE << (RADIX_BITS - 1))
#define RADIXM1 (-DIGIT_ONE)
#define F_RADIX ((double)RADIXM1 + 1.0)

#define HALF_RADIX_BITS (RADIX_BITS/2)
#if (RADIX_BITS != 2*HALF_RADIX_BITS)
    #error -- "RADIX_BITS must be even"
#endif
#define RADIX_HALFMASK_BOTTOM (RADIXM1 >> HALF_RADIX_BITS)



//          Multiple-precision data is normally represented
//      in radix 2^RADIX_BITS, with RADIX_BITS bits per word.
//      Here ``word'' means type digit_t.  RADIX_BITS
//      is 32 on some architectures (Intel, MIPS, PowerPC)
//      and 64 bits on other architectures (Alpha).

//          Within Windows NT, the data type DWORD predominates.
//      DWORD is a 32-bit unsigned datatype on all platforms
//      (Intel, Alpha, MIPS, PowerPC).  DWORD data can safely be
//      written to disk on one architecture and read back on another,
//      unlike digit_t.


//      [CAUTION -- Even DWORD is not safe when sending data to
//      big-endian architectures, such as Office products for the Macintosh.]



typedef unsigned char BYTE;
typedef unsigned long DWORD;
typedef const DWORD DWORDC;


#define DWORD_BITS 32
#define DWORD_LEFT_BIT 0x80000000UL

#if RADIX_BITS % DWORD_BITS != 0
    #error "RADIX_BITS not a multiple of 32"
#endif

#define DWORDS_PER_DIGIT (RADIX_BITS/DWORD_BITS)

//      DWORDS_TO_DIGITS(lng_dwords) computes the number of digit_t
//      elements required to store an array with -lng_dwords- DWORDs.
//      DIGITS_TO_DWORDS converts in the opposite direction.


#define DWORDS_TO_DIGITS(lng_dwords) \
                ( ((lng_dwords) + DWORDS_PER_DIGIT - 1)/DWORDS_PER_DIGIT)

#define DIGITS_TO_DWORDS(lng_digits) ((lng_digits) * DWORDS_PER_DIGIT)

#define BITS_TO_DIGITS(nb) (((nb) + RADIX_BITS - 1)/RADIX_BITS)



/*
        DOUBLE_SHIFT_LEFT(n1, n0, amt) returns
        n1 shifted left by amt bits,
        with new bits coming in from the top of n0.

        DOUBLE_SHIFT_RIGHT(n1, n0, amt) returns n0 shifted right
        by amt bits, with new bits coming from the bottom of n1.

        The shift counts must satisfy 0 <= amt <= RADIX_BITS - 1.
        The shift by    RADIX_BITS - amt   is done in two stages
        (first by 1, then by RADIX_BITS - 1 - amt),
        to avoid an illegal shift count of RADIX_BITS if amt = 0.

        DOUBLE_SHIFT_LEFT_NONZERO and DOUBLE_SHIFT_RIGHT_NONZERO
        are similar, but disallow a zero shift count, allowing the
        RADIX_BITS - amt shift to be done in one stage,
        DOUBLE_SHIFT_LEFT_NONZERO(n1, n0, amt) is the same as
        DOUBLE_SHIFT_RIGHT_NONZERO(n1, n0, RADIX_BITS - amt).

        TBD -- If the x86 VC compiler optimizes __int64 shifts,
        (6.0 SP3 does not), try to rewrite these definitions to generate
        SHLD and SHRD instructions..
*/

#define DOUBLE_SHIFT_LEFT(n1, n0, amt)  \
        (((n1) << (amt)) | (((n0) >> 1) >> (RADIX_BITS - 1 - (amt))))

#define DOUBLE_SHIFT_LEFT_NONZERO(n1, n0, amt)  \
        (((n1) << (amt)) | ((n0) >> (RADIX_BITS - (amt))))

#define DOUBLE_SHIFT_RIGHT(n1, n0, amt)  \
        (((n0) >> (amt)) | (((n1) << 1) << (RADIX_BITS - 1 - (amt))))

#define DOUBLE_SHIFT_RIGHT_NONZERO(n1, n0, amt)  \
        (((n0) >> (amt)) | ((n1) << (RADIX_BITS - (amt))))

#include "dblint.h"

#define digit_getbit(iword, ibit) (((iword) >> (ibit)) & 1)
#define dword_getbit(iword, ibit) digit_getbit(iword, ibit)
                        /* Extract bit from a word.
                        // 0 <= ibit <= RADIX_BITS - 1.
                        // Rightmost (i.e., least significant) bit is bit 0.
                        */

/*
        Test whether a number is odd or even.
*/
#define IS_EVEN(n) (~(n) & 1)
#define IS_ODD(n) ((n) & 1)

/*
        Maximum and minimum of two arguments
        (no side effects in arguments)
*/

#if 0
    #define MAX _max
    #define MIN _min
#else
    #define MAX(x, y) ((x) > (y) ? (x) : (y))
    #define MIN(x, y) ((x) > (y) ? (y) : (x))
#endif

#if 0
/*
        If we are building a DLL, use __declspec before certain variable
        declarations (and out procedure names in a .def file).
        _PM_DLL should be #defined when compiling bignum but not the application.

        If we are building a static library, use normal C declarations.
*/
    #ifdef _PM_DLL
        #define exportable_var __declspec( dllexport )
        #define exportable_var_declaration __declspec (dllexport)
    #else
        #define exportable_var __declspec( dllimport )
    #endif
#else
    #define exportable_var extern
    #define exportable_var_declaration
#endif
#



/*
        Macro to return 3^i (exponentiation), for 0 <= i <= 15.
        Intended for use with constant argument, such as
        in array dimensions.  The POWER3 array should
        be used if the argument is variable.
*/

#define POWER3CON(i) (   ((i) & 1 ?  3 : 1)  *  ((i) & 2 ?    9 : 1) \
                       * ((i) & 4 ? 81 : 1)  *  ((i) & 8 ? 6561 : 1) )

exportable_var DWORDC POWER3[16];   /* See mpglobals.c */
/*
        kara.c repeatedly replaces an operand by three
        half-length operands and a sign.  The sign has
        type kara_sign_t.  The operands are partitioned
        in half until their size at most VMUL_MAX_LNG_SINGLE,
        and sometimes further (see padinfo_initialization in kara.c)
        This may require up to KARA_MAX_HALVINGS halvings,
        giving 3^KARA_MAX_HALVINGS outputs each with size
        as large as VMUL_MAX_SINGLE words.  The signs
        array has length (3^KARA_MAX_HALVINGS - 1)/2.
*/
#if TARGET == TARGET_ALPHA
    typedef int kara_sign_t;
                        /* Try to avoid char data on Alpha */
#else
    typedef unsigned char kara_sign_t;
                        /* Values SIGN_PLUS, SIGN_MINUS.  See kara.c. */
#endif

typedef const kara_sign_t kara_sign_tc;
#define VMUL_MAX_LNG_SINGLE 12
#define KARA_MAX_HALVINGS (LG2_MP_LONGEST - 2)
#if KARA_MAX_HALVINGS > 15
    #error -- "Extend POWER3CON macro"
#endif
#define KARA_MAX_LNG_DIFS ((MP_LONGEST >> KARA_MAX_HALVINGS) * POWER3CON(KARA_MAX_HALVINGS))
#define KARA_MAX_LNG_SIGNS ((POWER3CON(KARA_MAX_HALVINGS) - 1)/2)
#define MEMORY_BANK_ALLOWANCE 1

typedef struct  {
                  digit_t     difs[KARA_MAX_LNG_DIFS + MEMORY_BANK_ALLOWANCE];
                  kara_sign_t signs[KARA_MAX_LNG_SIGNS];
                } kara_longest_t;   /* For MP_LONGEST or less */
                       /* On the Pentium P5 and P6,
                          the two arguments to vmulnn
                          should lie in different memory banks
                          (i.e., different addresses mod 32 bytes).
                          We make the .difs arrays one digit_t entry
                          larger than essential, in an attempt to reduce
                          data cache conflicts.  Look for the
                          MEMORY_BANK_ALLOWANCE symbol in the source code.
                        */


#define kara_longest_NULL ((kara_longest_t*)0)
typedef struct  {
                  digit_t     difs[KARA_MAX_LNG_DIFS/3 + MEMORY_BANK_ALLOWANCE];
                  kara_sign_t signs[KARA_MAX_LNG_SIGNS/3];
                } kara_half_longest_t;  /* For MP_LONGEST/2 or less */

typedef const kara_half_longest_t kara_half_longest_tc;
typedef const kara_longest_t      kara_longest_tc;

typedef struct {      /* Constants relating to padding lengths. */
                  DWORD  length;
                                /* length = length3[0] * 2^nhalving */
                  DWORD  nhalving;
                  DWORD  length3[KARA_MAX_HALVINGS+1];
                                /* length3[0] is 1, 2, 3, or 4 */
                                /* length3[i] is length3[0] * 3^i */
               } padinfo_t;

typedef const padinfo_t padinfo_tc;
#define padinfo_NULL ((padinfo_t*)0)

/*
        The reciprocal_1_t type is used when div21
        or divide or divide_immediate would otherwise
        divide by the same number repeatedly.  See file divide.c.
*/

typedef struct {
                digit_t multiplier;
                DWORD   shiftamt;
               } reciprocal_1_t;

typedef const reciprocal_1_t reciprocal_1_tc;

/*
        mp_modulus_t struct has modulus-dependent constants
        used for fast reduction (typically for a fixed modulus,
        which will be used several times, as in modular exponentiation).
        These constants are initialized by function create_modulus:

        modulus -- Modulus used for computations.  Must be nonzero.

        length  -- Length of the modulus, without leading zeros.
                   Operands to mod_add, mod_mul, mod_sub, ...
                   are assumed to have this length.

        padinfo -- Pointer to a padinfo_t struct.  For fast arithmetic,
                   operands are padded to a length
                   length_padded >= length (see find_padinfo in kara.c).
                   The value of length_padded is stored in padinfo->length.
                   The present implementation requires length_padded be either
                   a power of 2, or 3 times a power of 2.
                   For example, if length = 19, then length_padded = 24,
                   and the operands are treated as 24-word
                   operands for Karatsuba.

        half_padinfo -- Pointer to a padinfo_t struct for length
                   CEIL(length/2).  Used in modular_reduce to
                   use Karatsuba multiplication on half-length operands.
                   We denote half_length_padded = half_padinfo->length.

        reddir  -- Equal to FROM_LEFT if reductions of
                   products are done from the left (traditional
                   division), and to FROM_RIGHT if reductions of
                   products are done from the right (Montgomery reduction).

                   When using FROM_RIGHT, the modulus must be odd.
                   Arguments to mod_mul should be pre-scaled by
                   RADIX^scaling_power (mod modulus).
                   The product will be similarly scaled.

        scaling_power --  Equal to 2*half_length_padded when
                   reddir = FROM_RIGHT.  Undefined
                   if reddir = FROM_LEFT.

        one --     Constant 1 (length length), scaled if reddir = FROM_RIGHT.
                   When reddir = FROM_RIGHT, this is
                   RADIX^scaling_power (mod modulus).

        left_multiplier_first -- The first multiplier when reducing from the
                   left.  Length length.

-RADIX^(length + half_length_padded)/2^(left_reciprocal_1.shiftamt) mod modulus

        left_reciprocal_1 -- Reciprocal of the divisor starting at the
                   leftmost digit (i.e., modulus[length-1]);

        right_reciprocal_1 -- If modulus is odd, this holds
                   1/modulus (mod RADIX), for use in mod_shift.
                   Otherwise the field is zero.

        right_multiplier_second -- If reddir = FROM_RIGHT,
                   then this has 1/modulus mod RADIX^(half_length_padded).

        right_multiplier_first --   -1/RADIX^half_length_padded mod modulus.
                   Equal to

        left_multiplier_second -- Contains the half_length_padded*RADIX_BITS

            (modulus * right_multiplier_second - 1)/RADIX^half_length_padded.
                   most significant bits of (high power of 2)/modulus
                   (excluding the leading -1-).  More precisely, this has

        RADIX^(length + half_length_padded) - 1
 FLOOR( --------------------------------------- ) - RADIX^(half_length_padded)
        modulus * 2^(left_reciprocal_1.shiftamt)


                   See file divide.c for an explanation
                   about how this constant is used to get accurate
                   quotients when dividing from the left.

        left_multiplier_second_over2 -- Left_multiplier_second/2.
*/


typedef enum {FROM_LEFT, FROM_RIGHT} reddir_t;
typedef const reddir_t reddir_tc;

typedef struct {
                  digit_t   modulus[MP_LONGEST];
                  DWORD     length;      /* Length passed to create_modulus */
                  DWORD     scaling_power; /* 2*half_padinfo->length */
                  padinfo_tc *padinfo;   /* Pointer to struct containing
                                            padded length and related info */
                  padinfo_tc *half_padinfo;
                                         /* Padinfo info for CEIL(length/2) */
                  reddir_t  reddir;      /* FROM_LEFT or FROM_RIGHT */
                  reciprocal_1_t  left_reciprocal_1;
                  digit_t  right_reciprocal_1;
                                        /* 1/modulus[0] mod RADIX,
                                           if modulus is odd */

                  kara_half_longest_t modulus_kara2[2];
                                        /*
                                            Copy of modulus.

                                            Lower half_length_padded
                                            and upper
                                            length - half_length_padded
                                            words separately passed
                                            to to_kara.
                                         */
                  kara_half_longest_t left_multiplier_first_kara2[2];
                                /* Remainder when dividing
                                     -RADIX^(length + half_length_padded)
                                   / 2^(left_reciprocal_1.shiftamt)
                                   by modulus.

                                   Lower and upper halvves separately
                                   passed to to_kara.
                                */

                  kara_half_longest_t left_multiplier_second_kara;
                                /* half_length_padded*RADIX_BITS
                                   most significant bits of (left)
                                   reciprocal of modulus,
                                   excluding the leading -1-. */

                  digit_t  left_multiplier_second_over2[MP_LONGEST/2];
                                /* left_multiplier_second/2 */
                  kara_half_longest_t right_multiplier_first_kara2[2];
                                        /*  -1/RADIX^half_length_padded
                                            mod modulus.
                                        */
                  digit_t             right_multiplier_second[MP_LONGEST/2];
                  kara_half_longest_t right_multiplier_second_kara;
                              /* 1/modulus mod RADIX^(half_length_padded) */
                  digit_t  cofactor[MP_LONGEST];
                  DWORD    lng_cofactor;
                             /*
                                In factorization programs, this
                                holds the cofactor after dividing
                                modulus by any factors found.
                                Used by gcdex_jacobi.
                             */
                  digit_t  one[MP_LONGEST];
                } mp_modulus_t;


typedef const mp_modulus_t mp_modulus_tc;
/*
       The modular multiplication code and its
       relatives (e.g., modular_reduce, to_kara)
       need large amounts of temporary space
       during processing.  All big temporaries
       are gathered into a modmultemp_t struct.
       Users of these routines can allocate the
       storage themselves, and pass a pointer
       to the temporary storage (fastest), or can pass
       a null pointer (modmultemp_NULL).

*/
typedef struct {
                   // mmul fields are for mod_mul,
                   // mod_mul_kara, mod_mul_kara1

        digit_t             mmul_adifs[KARA_MAX_LNG_DIFS];
        kara_sign_t         mmul_asigns[KARA_MAX_LNG_SIGNS];
        digit_t             mmul_bdifs[KARA_MAX_LNG_DIFS
                                       + MEMORY_BANK_ALLOWANCE];
        kara_sign_t         mmul_bsigns[KARA_MAX_LNG_SIGNS];

                   // mr_ fields are for modular_reduce.
                   // The input to modular_reduce can be stored
                   // in mr_dividend -- this will save a mp_copy call.

        digit_t             mr_dividend[MAX(2*MP_LONGEST,
                                            2*KARA_MAX_LNG_DIFS+1)];

        digit_t             mr_prd1[2*MP_LONGEST];
        digit_t             mr_prd2[2*MP_LONGEST];
        digit_t             mr_mptemp[2*MP_LONGEST];

                   // htk_ fields are for half_times_kara
                   // and half_times_kara2

        digit_t             htk_abprd[2][2*KARA_MAX_LNG_DIFS/3];
        kara_half_longest_t htk_ak;
        } modmultemp_t;


/*
        mod_exp2000 returns statistics on what happened during the
        exponentiation.
*/

typedef struct {              // Statistics from mod_exp2000
                              // This struct may grow in future versions.
        DWORD cnt_mod_mul_kara;      // Calls to mod_mul_kara
        DWORD cnt_mp_copy;           // Calls to mp_copy
        DWORD cnt_to_kara;           // Calls to to_kara
    } mod_exp_stats_t;


/*
        When an error is detected, variable mp_errno is set
        to the error number and execution continues.
        If the library was compiled with #define PRINT_ERROR_MESSAGES,
        then a message is written to file mp_errfil.

        The application program should occasionally check mp_errno.

        Except for MP_ERRNO_NO_ERROR, the error numbers are
        in alphabetical order by name.  The routine issuing
        each error number is part of the name.
*/

typedef enum {
        MP_ERRNO_NO_ERROR = 0,
        MP_ERRNO_CREATE_MODULUS_LEADING_ZERO,
        MP_ERRNO_CREATE_MODULUS_MONTGOMERY_EVEN,
        MP_ERRNO_CREATE_MODULUS_TOO_LONG,
        MP_ERRNO_DIGIT_JACOBI_EVEN_DENOMINATOR,
        MP_ERRNO_DIGIT_MOD_DIVIDE_ODD_EVEN_MODULUS,
        MP_ERRNO_DIGIT_MOD_DIVIDE_ODD_NONTRIVIAL_GCD,
        MP_ERRNO_DIGIT_MOD_DIVIDE_ODD_ZERO_DENOMINATOR,
        MP_ERRNO_DIGIT_NEXT_PRIME_TOO_HIGH,
        MP_ERRNO_DIV21_INVALID_ARGUMENT,
        MP_ERRNO_DIVIDE_ESTIMATION_ERROR,
        MP_ERRNO_DIVIDE_INVALID_LENGTHS,
        MP_ERRNO_DIVIDE_LEADING_ZERO,
        MP_ERRNO_DSA_KEY_GENERATION_INVALID_SIZES,
        MP_ERRNO_DSA_PRECOMPUTE_BAD_G,
        MP_ERRNO_DSA_PRECOMPUTE_INVALID_KEY,
        MP_ERRNO_DSA_PRECOMPUTE_PQ_NONPRIME,
        MP_ERRNO_DSA_PRECOMPUTE_WRONG_SC,
        MP_ERRNO_DSA_SIGNATURE_VERIFICATION_NONTRIVIAL_GCD,
        MP_ERRNO_FIND_BIG_PRIME_BAD_CONGRUENCE_CLASS,
        MP_ERRNO_FIND_BIG_PRIME_CONG_MOD_TOO_LARGE,
        MP_ERRNO_FIND_BIG_PRIME_CONG_TO_TOO_LARGE,
        MP_ERRNO_GCDEX_JACOBI_EVEN_MODULUS,
        MP_ERRNO_KP_TOO_SHORT,
        MP_ERRNO_KPDIV_ZERO_DENOMINATOR,
        MP_ERRNO_MOD_ADD_CARRY_NONZERO,
        MP_ERRNO_MOD_SHIFT_LEFT_CARRY_NONZERO,
        MP_ERRNO_MOD_SHIFT_RIGHT_CARRY_NONZERO,
        MP_ERRNO_MOD_SHIFT_RIGHT_EVEN,
        MP_ERRNO_MOD_SUB_BORROW_NONZERO,
        MP_ERRNO_MODULAR_REDUCE_BOTTOM_BITS_DIFFERENT,
        MP_ERRNO_MODULAR_REDUCE_TOO_LONG,
        MP_ERRNO_MODULAR_REDUCE_UNEXPECTED_CARRY,
        MP_ERRNO_MP_DECIMAL_INPUT_NONDIGIT,
        MP_ERRNO_MP_DECIMAL_INPUT_OVERFLOW,
        MP_ERRNO_MP_GCD_INTERMEDIATE_EVEN,
        MP_ERRNO_MP_GCD_TOO_LONG,
        MP_ERRNO_MP_GCDEX_INTERNAL_ERROR,
        MP_ERRNO_MP_GCDEX_NONZERO_REMAINDER,
        MP_ERRNO_MP_GCDEX_ZERO_OPERAND,
        MP_ERRNO_MP_SHIFT_INVALID_SHIFT_COUNT,
        MP_ERRNO_MP_TRAILING_ZERO_COUNT_ZERO_ARG,
        MP_ERRNO_MULTIPLY_LOW_INVALID_LENGTH,
        MP_ERRNO_NO_MEMORY,      // From mp_alloc_temp
        MP_ERRNO_PADINFO_INITIALIZATION_BAD_CUTOFF,
        MP_ERRNO_RANDOM_DIGIT_INTERVAL_INVALID_PARAMETERS,
        MP_ERRNO_RANDOM_MOD_INVALID_PARAMETERS,
        MP_ERRNO_RANDOM_MOD_INVERSE_NOT_PRIME,
        MP_ERRNO_RANDOM_MOD_NONZERO_INVALID_PARAMETERS,
        MP_ERRNO_SELECT_A0B0_BAD_COFACTOR,
        MP_ERRNO_SELECT_A0B0_BAD_MU,
        MP_ERRNO_SELECT_A0B0_NON_CONSTANT_QUOTIENT,
        MP_ERRNO_SELECT_A0B0_NONZERO_REMAINDER,
        MP_ERRNO_SELECT_CURVE_BAD_FIELD_TYPE,
        MP_ERRNO_SELECT_D_UNSUCCESSFUL,
        MP_ERRNO_TO_KARA_INVALID_LENGTH,
        MP_ERRNO_TO_KARA2_INVALID_LENGTH,
        MP_ERRNO_COUNT      // Number of entries above
    } mp_errno_t;

exportable_var mp_errno_t mp_errno;

#if defined(WIN32)
#define SetMpErrno(x) SetLastError((DWORD)(mp_errno = (x)))
#define GetMpErrno()  ((mp_errno_t)GetLastError())
#else
#define SetMpErrno(x) mp_errno = (x)
#define GetMpErrno()  mp_errno
#endif

#define inadequate_memory (GetMpErrno() == MP_ERRNO_NO_MEMORY)
extern const char* mp_errno_name(const mp_errno_t);
       // Update table in mperrnam.c when adding new error message


/*
        Some routine allow an argument of digit_NULL or
        reciprocal_1_NULL when the corresponding argument
        is not otherwise used.  For example, the division
        routine allows but does not require a
        reciprocal structure as argument,
        and allows the quotient to be suppressed.
*/

#define digit_NULL ((digit_t*)0)
#define reciprocal_1_NULL ((reciprocal_1_t*)0)
#define modmultemp_NULL ((modmultemp_t*)0)

/*
        The next several #defines are used in function prototypes.
*/

#define MP_INPUT      digit_tc[]
#define MP_OUTPUT     digit_t[]
#define MP_MODIFIED   digit_t[]
#define DIFS_INPUT    MP_INPUT
#define DIFS_OUTPUT   MP_OUTPUT
#define DIFS_MODIFIED MP_MODIFIED
#define SIGNS_INPUT   kara_sign_tc[]
#define SIGNS_MODIFIED kara_sign_t[]
#define SIGNS_OUTPUT  kara_sign_t[]

extern digit_t accumulate(MP_INPUT, digit_tc, MP_MODIFIED, DWORDC);

extern digit_t Stdcall86 add_diff(MP_INPUT, DWORDC, MP_INPUT, DWORDC, MP_OUTPUT);

extern DWORD add_full(MP_INPUT, DWORDC, MP_INPUT, DWORDC, MP_OUTPUT);

extern digit_t Stdcall86 add_same(MP_INPUT, MP_INPUT, MP_OUTPUT, DWORDC);

extern DWORD add_signed(MP_INPUT, DWORDC, MP_INPUT, DWORDC, MP_OUTPUT);

extern int compare_diff(MP_INPUT, DWORDC, MP_INPUT, DWORDC);

extern int compare_sum_diff(MP_INPUT, DWORDC, MP_INPUT, DWORDC, MP_INPUT, DWORDC);

BOOL create_modulus(MP_INPUT, DWORDC, reddir_tc, mp_modulus_t*);

extern dblint_t dblint_gcd(dblint_tc, dblint_tc);

extern dblint_t dblint_ogcd(dblint_tc, dblint_tc);

extern digit_t dblint_sqrt(dblint_tc);

extern digit_t decumulate(MP_INPUT, digit_tc, MP_MODIFIED, DWORDC);

extern DWORD digit_factor(digit_tc, digit_t[], DWORD[]);

extern digit_t digit_gcd(digit_tc, digit_tc);

extern int digit_jacobi(digit_tc, digit_tc);

extern digit_t digit_least_prime_divisor(digit_tc);

extern digit_t digit_mod_divide_odd(digit_tc, digit_tc, digit_tc);

extern digit_t digit_ogcd(digit_tc, digit_tc);

extern char* digit_out(digit_tc);

extern digit_t digit_sqrt(digit_tc);

/*
       digit2_aligned(array) checks that _array_ is
       aligned on a 2*sizeof(digit_t) boundary.

       Assembly code versions of the software sometimes load
       or store two digit_t values with one instruction.
       Specifically, MMX code on X86 can load or store two 32-bit
       digit_t values with one 64-bit MOVQ instruction.
       IA-64 and AMD64 code can load two 64-bit values to the floating
       point registers with a load pair instruction.

       The digit2_aligned macro checks whether its operand is
       appropriately aligned.  The required alignment is never
       worse than that returned by mp_alloc_temp.


*/
#if TARGET == TARGET_IX86 || TARGET == TARGET_IA64 || TARGET == TARGET_AMD64
#define digit2_aligned(array) (((DWORD)(array) & (2*sizeof(digit_t) - 1)) == 0)
#else
#define digit2_aligned(array) (TRUE)
#endif


extern void div21(dblint_tc, digit_tc, digit_t*, digit_t*);

extern void div21_fast(dblint_tc, digit_tc,
                       reciprocal_1_tc*, digit_t*, digit_t*);

extern DWORD divide(MP_INPUT, DWORDC, MP_INPUT, DWORDC,
                       reciprocal_1_tc*, MP_OUTPUT, MP_OUTPUT);

extern DWORD divide_rounded(MP_INPUT, DWORDC, MP_INPUT, DWORDC,
                       reciprocal_1_tc*, MP_OUTPUT, MP_OUTPUT);

extern void divide_precondition_1(MP_INPUT, DWORDC, reciprocal_1_t*);

extern digit_t divide_immediate(MP_INPUT, digit_tc,
                         reciprocal_1_tc*, MP_OUTPUT, DWORDC);

extern digit_t estimated_quotient_1(digit_tc, digit_tc,
                                    digit_tc, reciprocal_1_tc*);

extern BOOL find_big_prime(DWORDC, MP_INPUT, DWORDC,
                           MP_INPUT, DWORDC, MP_OUTPUT);

extern padinfo_tc *find_padinfo(DWORDC);

DWORD from_modular(MP_INPUT, MP_OUTPUT, mp_modulus_tc*);

extern int gcdex_jacobi(MP_INPUT, mp_modulus_tc*, MP_OUTPUT, MP_OUTPUT);

extern void mod_add(MP_INPUT, MP_INPUT, MP_OUTPUT, mp_modulus_tc*);

extern DWORD mod_exp(MP_INPUT, MP_INPUT, DWORDC, MP_OUTPUT,
                        mp_modulus_tc*);

extern BOOL mod_exp2000(MP_INPUT, MP_INPUT, DWORDC, MP_OUTPUT,
                        mp_modulus_tc*, mod_exp_stats_t*);

extern DWORD mod_exp_immediate(MP_INPUT, digit_tc, MP_OUTPUT,
                                  mp_modulus_tc*);

extern int mod_jacobi_immediate(const signed long, mp_modulus_tc*);

extern void mod_Lucas(MP_INPUT, MP_INPUT, DWORDC, MP_OUTPUT,
                      mp_modulus_tc*);

extern void mod_LucasUV(MP_INPUT, MP_INPUT, MP_INPUT, DWORDC,
                        MP_OUTPUT, MP_OUTPUT, mp_modulus_tc*);

extern void mod_mul(MP_INPUT, MP_INPUT, MP_OUTPUT,
                    mp_modulus_tc*, modmultemp_t*);

extern void mod_mul_immediate(MP_INPUT, digit_tc,
                              MP_OUTPUT, mp_modulus_tc*);

extern void mod_mul_kara1(MP_INPUT, DIFS_INPUT, SIGNS_INPUT,
                          MP_OUTPUT, mp_modulus_tc*, modmultemp_t*);

extern void mod_mul_kara(DIFS_INPUT, SIGNS_INPUT,
                         DIFS_INPUT, SIGNS_INPUT,
                         MP_OUTPUT, mp_modulus_tc*, modmultemp_t*);

extern void mod_negate(MP_INPUT, MP_OUTPUT, mp_modulus_tc*);

extern void mod_shift(MP_INPUT, intc, MP_OUTPUT, mp_modulus_tc*);

extern BOOL mod_sqrt(MP_INPUT, MP_OUTPUT, mp_modulus_tc*);

extern void mod_sub(MP_INPUT, MP_INPUT, MP_OUTPUT, mp_modulus_tc*);

extern BOOL modular_reduce(MP_INPUT, DWORDC, reddir_tc,
                           MP_OUTPUT, mp_modulus_tc*, modmultemp_t*);

extern void* mp_alloc_temp(DWORDC);
#define Allocate_Temporaries(typename, ptr) \
               ptr = (typename*)mp_alloc_temp(sizeof(typename))

#define Allocate_Temporaries_Multiple(nelmt, typename, ptr) \
               ptr = (typename*)mp_alloc_temp((nelmt)*sizeof(typename))


#if USEASM_ALPHA || USEASM_MIPS
extern void mp_copy(MP_INPUT, MP_OUTPUT, DWORDC);
#else
#define mp_copy(src, dest, lng) \
            memcpy((void *)(dest), (const void *)(src), (lng)*sizeof(digit_t))
#endif

extern char* mp_decimal(MP_INPUT, DWORDC);

extern long mp_decimal_input(charc*, MP_OUTPUT, DWORDC, charc**);

extern char* mp_dword_decimal(DWORDC*, DWORDC);

extern int mp_format(MP_MODIFIED, DWORDC,
                     digit_tc, charc*, char*, DWORDC);

extern void mp_free_temp(void*);
#define Free_Temporaries(ptr)    mp_free_temp((void*)ptr)

extern DWORD mp_gcd(MP_INPUT, DWORDC, MP_INPUT, DWORDC, MP_OUTPUT);

extern DWORD mp_gcdex(MP_INPUT, DWORDC, MP_INPUT, DWORDC,
                      MP_OUTPUT, MP_OUTPUT, MP_OUTPUT, MP_OUTPUT);

extern void mp_initialization(void);

extern void mp_longshift(MP_INPUT, intc, MP_OUTPUT, DWORDC);

extern void Stdcall86 mp_mul22s(digit_tc[4], MP_MODIFIED, MP_MODIFIED, DWORDC, sdigit_t[2]);

extern void Stdcall86 mp_mul22u(digit_tc[4], MP_MODIFIED, MP_MODIFIED, DWORDC,  digit_t[2]);

extern DWORD mp_remove2(MP_MODIFIED, DWORDC);

extern digit_t mp_shift(MP_INPUT, intc, MP_OUTPUT, DWORDC);

extern DWORD mp_significant_bit_count(MP_INPUT, DWORDC);

extern BOOL mp_sqrt(MP_INPUT, MP_OUTPUT, DWORDC);

extern DWORD mp_trailing_zero_count(MP_INPUT, DWORDC);

extern void mul_kara(DIFS_INPUT, SIGNS_INPUT,
                     DIFS_INPUT, SIGNS_INPUT,
                     MP_OUTPUT,  padinfo_tc*);

extern void mul_kara_know_low(DIFS_INPUT, SIGNS_INPUT,
                              DIFS_INPUT, SIGNS_INPUT,
                              MP_INPUT, MP_OUTPUT,
                              padinfo_tc*);

extern void mul_kara_squaring(MP_INPUT, DWORDC,
                              DIFS_MODIFIED, SIGNS_MODIFIED,
                              MP_OUTPUT, padinfo_tc*,
                              modmultemp_t*);

extern void multiply(MP_INPUT, DWORDC, MP_INPUT, DWORDC, MP_OUTPUT);

extern digit_t multiply_immediate(MP_INPUT, digit_tc, MP_OUTPUT, DWORDC);

extern void Stdcall86 multiply_low(MP_INPUT, MP_INPUT, MP_OUTPUT, DWORDC);

extern DWORD multiply_signed(MP_INPUT, DWORDC, MP_INPUT, DWORDC, MP_OUTPUT);

extern DWORD multiply_signed_immediate(MP_INPUT, DWORDC,
                                       signed long, MP_OUTPUT);
#if TARGET_OS == OS_WCE
    #define PRIME_SIEVE_LENGTH 300
#else
    #define PRIME_SIEVE_LENGTH 3000
#endif
          // Must be multiple of 3
#if PRIME_SIEVE_LENGTH % 3 != 0
    #error "PRIME_SIEVE_LENGTH must be a multiple of 3"
#endif

extern digit_t next_prime(
    digit_tc pstart,
    digit_t *lpsievbeg,
    digit_t sieve[PRIME_SIEVE_LENGTH],
    digit_t *lpmax_sieved_squared
    );

extern void padinfo_initialization(DWORDC);

extern BOOL probable_prime(MP_INPUT, DWORDC, MP_INPUT, DWORDC, DWORDC);

extern BOOL remove_small_primes(MP_INPUT, DWORDC, digit_tc,
                                digit_t[], DWORD[], DWORD*,
                                MP_OUTPUT, DWORD*);

#if USEASM_IX86
    #define SIGNIFICANT_BIT_COUNT_DEFINED 1
    #define UNIFORM_SIGNIFICANT_BIT_COUNT 1
    #pragma warning(disable : 4035)      /* No return value */
    static inline DWORD significant_bit_count(digit_tc pattern)
    {
    _asm {
            mov  eax,pattern        ; Nonzero pattern
            bsr  eax,eax            ; eax = index of leftmost nonzero bit
                                         ; BSR is slow on Pentium
                                         ; but fast on Pentium Pro
            inc  eax                ; Add one to get significant bit count
         }
    }
    #pragma warning(default : 4035)
#elif USEASM_ALPHA
    #define SIGNIFICANT_BIT_COUNT_DEFINED 1
    #define UNIFORM_SIGNIFICANT_BIT_COUNT 1
    extern const BYTE half_byte_significant_bit_count[128];  /* See mpmisc.c */
            /*
                The Alpha code uses the CMPBGE instruction to
                identify which bytes are nonzero.  The most significant
                bit must occur within the leftmost nonzero byte.
                We use the CMPBGE output to identify which byte that is.
                After we extract that byte, we identify its most significant bit.
            */
    static inline DWORD significant_bit_count(digit_tc pattern)
    {
        DWORDC zero_byte_pattern = __asm("cmpbge  zero, %0, v0", pattern);

        DWORDC byte_offset_plus_1
                = 8*half_byte_significant_bit_count[127 - (zero_byte_pattern >> 1)] + 1;

        return byte_offset_plus_1
                + half_byte_significant_bit_count[pattern >> byte_offset_plus_1];
    }
#else
    #define SIGNIFICANT_BIT_COUNT_DEFINED 0
    #define UNIFORM_SIGNIFICANT_BIT_COUNT 0
           /* Algorithm faster for larger inputs.  See mpmisc.c */
    extern DWORD significant_bit_count(digit_tc);
#endif


extern digit_t Stdcall86 sub_diff(MP_INPUT, DWORDC, MP_INPUT, DWORDC, MP_OUTPUT);

extern digit_t Stdcall86 sub_same(MP_INPUT, MP_INPUT, MP_OUTPUT, DWORDC);

#define sub_signed(a, lnga, b, lngb, c) add_signed(a, lnga, b, -(lngb), c)

extern BOOL test_primality(MP_INPUT, DWORDC);

extern BOOL test_primality_check_low(MP_INPUT, DWORDC);

extern BOOL get_prime(MP_OUTPUT, DWORDC);

extern BOOL get_generator(DWORD*, DWORD*, DWORDC);

extern void to_kara(MP_INPUT, DWORDC, DIFS_OUTPUT, SIGNS_OUTPUT,
                    padinfo_tc*);

extern BOOL to_modular(MP_INPUT, DWORDC, MP_OUTPUT, mp_modulus_tc*);


//     The following functions are indexed indirectly via pointers.
//     Also see GF2_get_funcs in field.h.

#if TARGET == TARGET_IX86
exportable_var BOOL  MMX_available;   /* See mpglobal.c */
#endif

typedef void Stdcall86 vmul_t(DIFS_INPUT, DIFS_INPUT, DIFS_OUTPUT, DWORDC);

exportable_var vmul_t *vmulnn[VMUL_MAX_LNG_SINGLE];
                /* Addresses for 1 x 1 to 12 x 12 products */
                /* Defined at end of vmul.c */


#if PRINT_ERROR_MESSAGES
    extern void mp_display(FILE*, charc*, MP_INPUT, DWORDC);
    exportable_var FILE* mp_errfil;       /* Set to stdout in mp_global.c */
    extern void mp_print_allocation_statistics(FILE*);
#endif /* PRINT_ERROR_MESSAGES */


/****************************************************************************/
static inline digit_t add_immediate(digit_tc  a[],
                                    digit_tc iadd,
                                    digit_t   b[],
                                    DWORDC    lng)
/*
        Compute b = a + iadd, where iadd has length 1.
        Both a and b have length lng.
        Function value is carry out of leftmost digit in b.
*/
{
    if (lng == 0) {
        return iadd;
    } else if (a == b && b[0] <= RADIXM1 - iadd) {
        b[0] += iadd;
        return 0;
    } else {
        return add_diff(a, lng, &iadd, 1, b);
    }
}
/***************************************************************************/
static inline int compare_immediate(digit_tc  a[],
                                    digit_tc  ivalue,
                                    DWORDC    lng)
/*
        Compare a multiple-precision number to a scalar.
*/
{
    return compare_diff(a, lng, &ivalue, 1);
}
/****************************************************************************/
#if USEASM_MIPS
extern int compare_same(MP_INPUT, MP_INPUT, DWORDC);
#else
static inline int compare_same(digit_tc  a[],
                               digit_tc  b[],
                               DWORDC    lng)
/*
        Compare two multiple precision numbers a and b each of length lng.
        Function value is the sign of a - b, namely

                          +1 if a > b
                           0 if a = b
                          -1 if a < b
*/
#if USEASM_IX86
    #pragma warning(disable : 4035)      /* No return value */
{
                    /*
                            We could use REPE CMPSD,
                            but REPE is slow (4 cycles)
                            on the Pentium.  Plus we
                            would need std and cld
                            to adjust the direction flag.
                            We anticipate that most loops
                            will have either 1 or 2 iterations,
                            and use RISC instructions.
                    */

    _asm {
        mov  eax,lng
        mov  esi,a
        mov  edi,b
     label1:
        test eax,eax
        jz   label2              ; If nothing left, exit with eax = 0

        mov  ecx,[esi+4*eax-4]   ;
        mov  edx,[edi+4*eax-4]

        dec  eax                 ; Decrement remaining loop count
        cmp  ecx,edx             ; Test a[i] - b[i]

        je   label1

        sbb  eax,eax             ; eax = 0 if a > b,   -1 if a < b
        or   eax,1               ; eax = 1 if a > b,   -1 if a < b
     label2:
    }
}
    #pragma warning(default : 4035)
#else
{
    DWORD i;
    for (i = lng-1; i != -1; i--) {
        if (a[i] != b[i]) return (a[i] > b[i] ? +1 : -1);
    }
    return 0;
}  /* compare_same */
#endif
#endif
/****************************************************************************/
#if USEASM_ALPHA || USEASM_MIPS
    extern void mp_clear(MP_OUTPUT, DWORDC);
#elif 0
static inline void mp_clear(digit_t a[],
                            DWORDC  lnga)
/*
        Zero a multiple-precision number.
*/
{
    DWORD i;
    for (i = 0; i != lnga; i++) a[i] = 0;
}
#else
#define mp_clear(dest, lng) (void)memset((void *)(dest), 0, (lng)*sizeof(digit_t))
#endif
/****************************************************************************/
#if USEASM_ALPHA || USEASM_MIPS
    extern void mp_extend(MP_INPUT, DWORDC, MP_OUTPUT, DWORDC);
        // See alpha.s
#else
static inline void mp_extend(digit_tc  a[],
                             DWORDC    lnga,
                             digit_t   b[],
                             DWORDC    lngb)
/*
        Copy a to b, while changing its length from
        lnga to lngb (zero fill).  Require lngb >= lnga.
*/
{
    mp_copy(a, b, lnga);
    mp_clear(b + lnga, lngb - lnga);
}
#endif
/****************************************************************************/
static inline digit_t mp_getbit(digit_tc a[],
                                DWORDC ibit)
                /* Extract bit of multiple precision number */
{
    return digit_getbit(a[ibit/RADIX_BITS],  ibit % RADIX_BITS);
}

/******************************************************************************/
static inline int mp_jacobi_wrt_immediate(digit_tc  numer[],
                                          DWORD     lnumer,
                                          digit_tc  denom)
// Return jacobi(numer, denom), where denom is single precision
{
   digit_tc rem = divide_immediate(numer, denom,
                                   reciprocal_1_NULL,
                                   digit_NULL, lnumer);
   return digit_jacobi(rem, denom);
} /* mp_jacobi_wrt_immediate */
/****************************************************************************/
static inline void mp_setbit(digit_t   a[],
                             DWORDC    ibit,
                             digit_tc  new_value)
/*
        Set a bit to 0 or 1,
        when the number is viewed as a bit array.
*/

{
    DWORDC j       = ibit / RADIX_BITS;
    DWORDC ishift  = ibit % RADIX_BITS;

    digit_tc mask1 = (DIGIT_ONE &  new_value) << ishift;
    digit_tc mask2 = (DIGIT_ONE & ~new_value) << ishift;

    a[j] = (a[j] & ~mask2) | mask1;
} // end mp_setbit
/****************************************************************************/
#if MEMORY_BANK_ALLOWANCE == 0
#define Preferred_Memory_Bank(new_array, old_array) new_array
#else
static inline digit_t* Preferred_Memory_Bank(digit_t  *new_array,
                                             digit_tc *old_array)
/*
        To avoid memory bank conflicts, it is desirable
        that (input) arguments to vmulxx assembly routines start
        on distinct memory banks, when not doing a squaring.
        If MEMORY_BANK_ALLOWANCE > 0,
        then new_array should have MEMORY_BANK_ALLOWANCE
        extra entries at the end.  We return either
        new_array or new_array + 1, whichever ensures the
        addresses are distinct.

        CAUTION -- This routine does non-portable pointer manipulations.
*/
{
    return new_array + (1 & ~(old_array - new_array));
}
#endif
/****************************************************************************/
static inline void set_immediate(digit_t  a[],
                                 digit_tc ivalue,
                                 DWORDC   lnga)
{
   a[0] = ivalue;
   mp_clear(a + 1, lnga - 1);
}
/****************************************************************************/
static inline DWORD set_immediate_signed(digit_t     a[],
                                         signed long ivalue)
{
    a[0] = labs(ivalue);
    return (ivalue > 0) - (ivalue < 0);     /* Sign of result  -- -1, 0, +1  */
}
/****************************************************************************/

#if USEASM_MIPS
extern DWORD significant_digit_count(MP_INPUT, DWORDC);
#else
static inline DWORD significant_digit_count(digit_tc  a[],
                                            DWORDC    lng)
/*
        Return the number of significant digits in a.
        Function value is zero precisely when a == 0.
*/
#if USEASM_IX86
    #pragma warning(disable : 4035)      /* No return value */
{
                /*
                   We could use REPE SCASD,
                   but the REPE overhead is
                   four cycles/compare on the Pentium.
                   We would also need sld and cld.
                   It is shorter to use RISC instructions.
                   We anticipate that the leading term a[lng-1]
                   will usually be nonzero.
                */

    _asm {
        mov  eax,lng
        mov  edx,a
     label1:
        test eax,eax
        jz   label2             ; If nothing left in number, return 0

        mov  ecx,[edx+4*eax-4]
        dec  eax

        test ecx,ecx            ; Test leading digit
        jz   label1

        inc  eax                ; Nonzero element found; return old eax
     label2:
    }
}
    #pragma warning(default : 4035)
#else
{
    DWORD i = lng;

    while (i != 0 && a[i-1] == 0) i--;
    return i;
}  /* significant_digit_count */
#endif
#endif
#define all_zero(a, lng) (significant_digit_count(a, lng) == 0)
/****************************************************************************/
static inline digit_t sub_immediate(digit_tc  a[],
                                    digit_tc  isub,
                                    digit_t   b[],
                                    DWORDC    lng)
/*
        Compute b = a - isub, where isub has length 1.
        Both a and b have length lng.
        Function value is borrow out of leftmost digit in b.
*/
{
    return (lng == 0 ? isub : sub_diff(a, lng, &isub, 1, b));
}
/****************************************************************************/
#if USEASM_IX86
#define TRAILING_ZERO_COUNT_DEFINED 1
static inline DWORD trailing_zero_count(digit_tc d)
    #pragma warning(disable : 4035)      /* No return value */
{
    _asm {
            mov  eax,d
            bsf  eax,eax            ; eax = index of rightmost nonzero bit
                                    ; BSF is slow on Pentium,
                                    ; but fast on Pentium Pro.
         }

}
    #pragma warning(default : 4035)
#elif UNIFORM_SIGNIFICANT_BIT_COUNT
#define TRAILING_ZERO_COUNT_DEFINED 1
static inline DWORD trailing_zero_count(digit_tc d)
/*
        Given a nonzero integer d, this routine computes
        the largest integer n such that 2^n divides d.

        If d = 2^n * (2k + 1), then

                        d =     k *2^(n+1) + 2^n
                       -d = (-1-k)*2^(n+1) + 2^n

        The integers k and -1 - k are one's complements of
        each other, so d & (-d) = 2^n.  Once we determine
        2^n from d, we can get n via significant_bit_count.
*/
{
    return significant_bit_count(d & (-d)) - 1;
}  /* trailing_zero_count */
#else
#define TRAILING_ZERO_COUNT_DEFINED 0
extern DWORD trailing_zero_count(digit_tc);   /* See mpmisc.c */
#endif
/****************************************************************************/
static inline void digits_to_dwords(digit_tc  pdigit[],
                                    DWORD     pdword[],
                                    DWORDC    lng_dwords)
{
#if DWORDS_PER_DIGIT == 1
    mp_copy(pdigit, (digit_t*)pdword, lng_dwords);
#elif DWORDS_PER_DIGIT == 2
    DWORDC lng_half = lng_dwords >> 1;
    DWORD i;

    if (IS_ODD(lng_dwords)) {
        pdword[lng_dwords-1] = (DWORD)pdigit[lng_half];
    }
    for (i = 0; i != lng_half; i++) {
        digit_tc dig = pdigit[i];
        pdword[2*i    ] = (DWORD)dig;
        pdword[2*i + 1] = (DWORD)(dig >> DWORD_BITS);
    }
#else
    #error "Unexpected DWORDS_PER_DIGIT"
#endif
}  /* digits_to_dwords */
/****************************************************************************/
static inline void dwords_to_digits(DWORDC  pdword[],
                                    digit_t pdigit[],
                                    DWORDC  lng_dwords)
{
#if DWORDS_PER_DIGIT == 1
    mp_copy((digit_t*)pdword, pdigit, lng_dwords);
#elif DWORDS_PER_DIGIT == 2
    DWORDC lng_half = lng_dwords >> 1;
    DWORD i;

    if (IS_ODD(lng_dwords)) {
        pdigit[lng_half] = (digit_t)pdword[lng_dwords - 1];  // Zero fill
    }
    for (i = 0; i != lng_half; i++) {
        pdigit[i] =    ((digit_t)pdword[2*i+1] << DWORD_BITS)
                     |  (digit_t)pdword[2*i];
    }
#else
    #error "Unexpected DWORDS_PER_DIGIT"
#endif
}  /* dwords_to_digits */

#endif // RADIX_BITS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\benaloh.h ===
#ifndef __BENALOH_H__
#define __BENALOH_H__

#ifdef __cplusplus
extern "C" {
#endif

struct BenalohData
{
    DWORD N;            /* length of modulus */
    LPDWORD M;          /* a multiple of modulus, with highest bit set */
    LPDWORD U;          /* base**(N+1) mod modulus */
    LPDWORD V;          /* modulus - U */
    LPDWORD product;
};

BOOL BenalohSetup(struct BenalohData *context, LPDWORD M, DWORD N);
void BenalohTeardown(struct BenalohData *context);
void BenalohMod(struct BenalohData *context, LPDWORD T, LPDWORD X);
void BenalohModSquare(struct BenalohData *context, LPDWORD A, LPDWORD B);
void BenalohModMultiply(struct BenalohData *context, LPDWORD A, LPDWORD B, LPDWORD C);
BOOL BenalohModExp(LPDWORD A, LPDWORD B, LPDWORD C, LPDWORD D, DWORD len);
BOOL BenalohModRoot(LPDWORD M, LPDWORD C, LPDWORD PP, LPDWORD QQ, LPDWORD DP, LPDWORD DQ, LPDWORD CR, DWORD PSize);
DWORD BenalohEstimateQuotient(DWORD a1, DWORD a2, DWORD m1);

#ifdef __cplusplus
}
#endif

#endif // __BENALOH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\xomi.h ===
/* $Workfile:   xomi.h  $ $Revision:   1.1  $ */

/* WORKSPACE INTERFACE */

typedef OM_descriptor        OMP_object_header[2];

typedef OMP_object_header    FAR * OMP_object;

typedef OM_return_code
(XOMAPI *OMP_copy) (
        OM_private_object          original,
        OM_workspace               workspace,
        OM_private_object    FAR * copy
);

typedef OM_return_code
(XOMAPI *OMP_copy_value) (
        OM_private_object          source,
        OM_type                    source_type,
        OM_value_position          source_value_position,
        OM_private_object          destination,
        OM_type                    destination_type,
        OM_value_position          destination_value_position
);

typedef OM_return_code
(XOMAPI *OMP_create) (
        OM_object_identifier       _class,
        OM_boolean                 initialise,
        OM_workspace               workspace,
        OM_private_object    FAR * object
);

typedef OM_return_code
(XOMAPI *OMP_decode) (
        OM_private_object          encoding,
        OM_private_object    FAR * original
);

typedef OM_return_code
(XOMAPI *OMP_delete) (
        OM_object                  subject
);

typedef OM_return_code
(XOMAPI *OMP_encode) (
        OM_private_object          original,
        OM_object_identifier       rules,
        OM_private_object    FAR * encoding
);

typedef OM_return_code
(XOMAPI *OMP_get) (
        OM_private_object          original,
        OM_exclusions              exclusions,
        OM_type_list               included_types,
        OM_boolean                 local_strings,
        OM_value_position          initial_value,
        OM_value_position          limiting_value,
        OM_public_object     FAR * copy,
        OM_value_position    FAR * total_number
);

typedef OM_return_code
(XOMAPI *OMP_instance) (
        OM_object                  subject,
        OM_object_identifier       _class,
        OM_boolean           FAR * instance
);

typedef OM_return_code
(XOMAPI *OMP_put) (
        OM_private_object          destination,
        OM_modification            modification,
        OM_object                  source,
        OM_type_list               included_types,
        OM_value_position          initial_value,
        OM_value_position          limiting_value
);

typedef OM_return_code
(XOMAPI *OMP_read) (
        OM_private_object          subject,
        OM_type                    type,
        OM_value_position          value_position,
        OM_boolean                 local_string,
        OM_string_length     FAR * string_offset,
        OM_string            FAR * elements
);

typedef OM_return_code
(XOMAPI *OMP_remove) (
        OM_private_object          subject,
        OM_type                    type,
        OM_value_position          initial_value,
        OM_value_position          limiting_value
);

typedef OM_return_code
(XOMAPI *OMP_write) (
        OM_private_object          subject,
        OM_type                    type,
        OM_value_position          value_position,
        OM_syntax                  syntax,
        OM_string_length     FAR * string_offset,
        OM_string                  elements
);

/* C++ doesn't do very well with the structures	*/
/* and macros that follow here.			*/

#ifndef __cplusplus

typedef struct OMP_functions_body {
        OM_uint32       function_number;
        OMP_copy        copy;
        OMP_copy_value  copy_value;
        OMP_create      create;
        OMP_decode      decode;
        OMP_delete      delete;
        OMP_encode      encode;
        OMP_get         get;
        OMP_instance    instance;
        OMP_put         put;
        OMP_read        read;
        OMP_remove      remove;
        OMP_write       write;
} OMP_functions;
typedef struct OMP_workspace_body {
        struct OMP_functions_body    FAR * functions;
} FAR * OMP_workspace;

#define OMP_EXTERNAL(internal)  ((OM_object)((OM_descriptor FAR *)(internal) + 1))

#define OMP_INTERNAL(external)  ((OM_descriptor FAR *)(external) - 1)

#define OMP_TYPE(external)      (((OM_descriptor FAR *)(external))->type)

#define OMP_WORKSPACE(external) ((OMP_workspace)(OMP_INTERNAL(external)->value.string.elements))

#define OMP_FUNCTIONS(external) (OMP_WORKSPACE(external)->functions)

#define om_copy(ORIGINAL,WORKSPACE,COPY) ((ORIGINAL)->type == OM_PRIVATE_OBJECT ? ((OMP_workspace)(WORKSPACE))->functions->copy((ORIGINAL),(WORKSPACE),(COPY)) : OM_NOT_PRIVATE)


#define om_copy_value(SOURCE, SOURCE_TYPE, SOURCE_POSITION, DEST, DEST_TYPE, DEST_POSITION) \
((((SOURCE)->type == OM_PRIVATE_OBJECT) && ((DEST)->type == OM_PRIVATE_OBJECT)) ? OMP_FUNCTIONS(DEST)->copy_value((SOURCE), (SOURCE_TYPE), (SOURCE_POSITION), (DEST), (DEST_TYPE), (DEST_POSITION)) : OM_NOT_PRIVATE)


#ifdef PIMPORT_DLL_DATA
#define om_create(CLASS,INITIALISE,WORKSPACE,OBJECT) (((OMP_workspace)(WORKSPACE))->functions->create(*(CLASS),(INITIALISE),(WORKSPACE),(OBJECT)))
#else
#define om_create(CLASS,INITIALISE,WORKSPACE,OBJECT) (((OMP_workspace)(WORKSPACE))->functions->create((CLASS),(INITIALISE),(WORKSPACE),(OBJECT)))
#endif


#define om_decode(ENCODING,ORIGINAL) ((ENCODING)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(ENCODING)->decode((ENCODING),(ORIGINAL)) : OM_NOT_PRIVATE)


#define om_delete(SUBJECT) (((SUBJECT)->syntax & OM_S_SERVICE_GENERATED) ? OMP_FUNCTIONS(SUBJECT)->delete((SUBJECT)) : OM_NOT_THE_SERVICES)


#define om_encode(ORIGINAL,RULES,ENCODING) ((ORIGINAL)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(ORIGINAL)->encode((ORIGINAL),(RULES),(ENCODING)) : OM_NOT_PRIVATE)


#define om_get(ORIGINAL,EXCLUSIONS,TYPES,LOCAL_STRINGS,INITIAL,LIMIT,COPY,TOTAL_NUMBER) \
((ORIGINAL)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(ORIGINAL)->get((ORIGINAL),(EXCLUSIONS),(TYPES),(LOCAL_STRINGS),(INITIAL),(LIMIT),(COPY),(TOTAL_NUMBER)) : OM_NOT_PRIVATE)


#ifdef PIMPORT_DLL_DATA
#define om_instance(SUBJECT,CLASS,INSTANCE) (((SUBJECT)->syntax & OM_S_SERVICE_GENERATED) ? OMP_FUNCTIONS(SUBJECT)->instance((SUBJECT),*(CLASS),(INSTANCE)) : OM_NOT_THE_SERVICES)
#else
#define om_instance(SUBJECT,CLASS,INSTANCE) (((SUBJECT)->syntax & OM_S_SERVICE_GENERATED) ? OMP_FUNCTIONS(SUBJECT)->instance((SUBJECT),(CLASS),(INSTANCE)) : OM_NOT_THE_SERVICES)
#endif


#define om_put(DESTINATION,MODIFICATION,SOURCE,INCLUDED_TYPES,INITIAL,LIMIT) ((DESTINATION)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(DESTINATION)->put((DESTINATION),(MODIFICATION),(SOURCE),(INCLUDED_TYPES),(INITIAL),(LIMIT)) : OM_NOT_PRIVATE)


#define om_read(SUBJECT,TYPE,VALUE_POS,LOCAL_STRING,STRING_OFFSET,ELEMENTS) ((SUBJECT)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(SUBJECT)->read((SUBJECT),(TYPE),(VALUE_POS),(LOCAL_STRING),(STRING_OFFSET),(ELEMENTS)) : OM_NOT_PRIVATE)


#define om_remove(SUBJECT,TYPE,INITIAL,LIMIT) ((SUBJECT)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(SUBJECT)->remove((SUBJECT),(TYPE),(INITIAL),(LIMIT)) : OM_NOT_PRIVATE)


#define om_write(SUBJECT,TYPE,VALUE_POS,SYNTAX,STRING_OFFSET,ELEMENTS) \
((SUBJECT)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(SUBJECT)->write((SUBJECT),(TYPE),(VALUE_POS),(SYNTAX),(STRING_OFFSET),(ELEMENTS)) : OM_NOT_PRIVATE)


#else /*_cplusplus*/

typedef struct OMP_functions_body {
        OM_uint32       _function_number;
        OMP_copy        _copy;
        OMP_copy_value  _copy_value;
        OMP_create      _create;
        OMP_decode      _decode;
        OMP_delete      _delete;
        OMP_encode      _encode;
        OMP_get         _get;
        OMP_instance    _instance;
        OMP_put         _put;
        OMP_read        _read;
        OMP_remove      _remove;
        OMP_write       _write;
} OMP_functions;
typedef struct OMP_workspace_body {
        struct OMP_functions_body    FAR * _functions;
} FAR * OMP_workspace;

#define OMP_EXTERNAL(internal)  ((OM_object)((OM_descriptor FAR *)(internal) + 1))

#define OMP_INTERNAL(external)  ((OM_descriptor FAR *)(external) - 1)

#define OMP_TYPE(external)      (((OM_descriptor FAR *)(external))->type)

#define OMP_WORKSPACE(external) ((OMP_workspace)(OMP_INTERNAL(external)->value.string.elements))

#define OMP_FUNCTIONS(external) (OMP_WORKSPACE(external)->_functions)


#define om_copy(ORIGINAL,WORKSPACE,COPY) ((ORIGINAL)->type == OM_PRIVATE_OBJECT ? ((OMP_workspace)(WORKSPACE))->_functions->_copy((ORIGINAL),(WORKSPACE),(COPY)) : OM_NOT_PRIVATE)


#define om_copy_value(SOURCE, SOURCE_TYPE, SOURCE_POSITION, DEST, DEST_TYPE, DEST_POSITION) \
((((SOURCE)->type == OM_PRIVATE_OBJECT) && ((DEST)->type == OM_PRIVATE_OBJECT)) ? OMP_FUNCTIONS(DEST)->_copy_value((SOURCE), (SOURCE_TYPE), (SOURCE_POSITION), (DEST), (DEST_TYPE), (DEST_POSITION)) : OM_NOT_PRIVATE)


#define om_create(CLASS,INITIALISE,WORKSPACE,OBJECT) (((OMP_workspace)(WORKSPACE))->_functions->_create((CLASS),(INITIALISE),(WORKSPACE),(OBJECT)))


#define om_decode(ENCODING,ORIGINAL) ((ENCODING)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(ENCODING)->_decode((ENCODING),(ORIGINAL)) : OM_NOT_PRIVATE)


#define om_delete(SUBJECT) (((SUBJECT)->syntax & OM_S_SERVICE_GENERATED) ? OMP_FUNCTIONS(SUBJECT)->_delete((SUBJECT)) : OM_NOT_THE_SERVICES)


#define om_encode(ORIGINAL,RULES,ENCODING) ((ORIGINAL)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(ORIGINAL)->_encode((ORIGINAL),(RULES),(ENCODING)) : OM_NOT_PRIVATE)


#define om_get(ORIGINAL,EXCLUSIONS,TYPES,LOCAL_STRINGS,INITIAL,LIMIT,COPY,TOTAL_NUMBER) \
((ORIGINAL)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(ORIGINAL)->_get((ORIGINAL),(EXCLUSIONS),(TYPES),(LOCAL_STRINGS),(INITIAL),(LIMIT),(COPY),(TOTAL_NUMBER)) : OM_NOT_PRIVATE)


#define om_instance(SUBJECT,CLASS,INSTANCE) (((SUBJECT)->syntax & OM_S_SERVICE_GENERATED) ? OMP_FUNCTIONS(SUBJECT)->_instance((SUBJECT),(CLASS),(INSTANCE)) : OM_NOT_THE_SERVICES)


#define om_put(DESTINATION,MODIFICATION,SOURCE,INCLUDED_TYPES,INITIAL,LIMIT) ((DESTINATION)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(DESTINATION)->_put((DESTINATION),(MODIFICATION),(SOURCE),(INCLUDED_TYPES),(INITIAL),(LIMIT)) : OM_NOT_PRIVATE)


#define om_read(SUBJECT,TYPE,VALUE_POS,LOCAL_STRING,STRING_OFFSET,ELEMENTS) ((SUBJECT)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(SUBJECT)->_read((SUBJECT),(TYPE),(VALUE_POS),(LOCAL_STRING),(STRING_OFFSET),(ELEMENTS)) : OM_NOT_PRIVATE)


#define om_remove(SUBJECT,TYPE,INITIAL,LIMIT) ((SUBJECT)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(SUBJECT)->_remove((SUBJECT),(TYPE),(INITIAL),(LIMIT)) : OM_NOT_PRIVATE)


#define om_write(SUBJECT,TYPE,VALUE_POS,SYNTAX,STRING_OFFSET,ELEMENTS) \
((SUBJECT)->type == OM_PRIVATE_OBJECT ? OMP_FUNCTIONS(SUBJECT)->_write((SUBJECT),(TYPE),(VALUE_POS),(SYNTAX),(STRING_OFFSET),(ELEMENTS)) : OM_NOT_PRIVATE)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\xom.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       xom.h
//
//--------------------------------------------------------------------------

/* <BANNER> */

#include <wtypes.h> // Including LARGE_INTEGERS [rajnath]
/*
** Header file for the X/OPEN Object Management (XOM) Interface and Package.
*/

#ifndef XOM_HEADER
#define XOM_HEADER

/* insure that all pointers are _far and that all interface APIs follow  */
/* the PASCAL calling convention for 8088 to 80286 machines, and stdcall */
/* convention on 32-bit platforms.                                       */

#if defined(M_I8086) || defined(M_I286)
# ifndef FAR
#  define FAR _far
# endif
# ifndef NEAR
#  define NEAR _near
# endif
# ifndef XOMAPI
#  if defined(M_I286)
#   define XOMAPI _far _pascal _loadds
#  else
#   define XOMAPI _far _pascal
#  endif
# endif
#else
# ifdef FAR
#  undef FAR
# endif
# define FAR
# ifdef NEAR
#  undef NEAR
# endif
# define NEAR
#endif

#if defined(_M_IX86) && (_M_IX86 >= 300)
# define XOMAPI __stdcall
#endif

#if defined(_M_IA64)
# define XOMAPI __stdcall
#endif

#if defined(_M_AMD64)
# define XOMAPI
#endif

#pragma pack(1)

#if !defined(XOMAPI)
# error -- TARGET MACHINE TYPE NOT SUPPORTED --
#endif

/* $Workfile:   XOM.H  $ $Revision:   1.1  $ */
/* BEGIN SERVICE INTERFACE */

/* INTERMEDIATE DATA TYPES */



typedef short           OM_sint;
typedef short           OM_sint16;
typedef long int        OM_sint32;
typedef short unsigned  OM_uint;
typedef short unsigned  OM_uint16;
typedef long unsigned   OM_uint32;


typedef LARGE_INTEGER   OM_sint64;


/* PRIMARY DATA TYPES */

/* Boolean */

typedef OM_uint32 OM_boolean;

/* Element Position */

typedef OM_uint32 OM_string_length;

/* Enumeration */

typedef OM_sint32 OM_enumeration;

/* Exclusions */

typedef OM_uint OM_exclusions;

/* Integer */

typedef OM_sint32 OM_integer;

/* Large Integer */

typedef OM_sint64   OM_i8;

/* DWORD_PTR */

typedef DWORD_PTR OM_dword_ptr;

/* Modification */

typedef OM_uint OM_modification;

/* Object */

typedef struct OM_descriptor_struct FAR *OM_object;

/* String */

#ifndef OM_STRING_DEFINED
#define OM_STRING_DEFINED
typedef struct {
        OM_string_length length;
        void        FAR *elements;
} OM_string;
#endif

#define OM_STRING(string)       \
        { (OM_string_length)(sizeof(string)-1), (string) }

/* Workspace */

typedef void FAR *OM_workspace;

/* SECONDARY DATA TYPES */

/* Object Identifier */

typedef OM_string OM_object_identifier;

/* Private Object */

typedef OM_object OM_private_object;

/* Public Object */

typedef OM_object OM_public_object;

/* Return Code */

typedef OM_uint OM_return_code;

/* Syntax */

typedef OM_uint16 OM_syntax;

/* Type */

typedef OM_uint16 OM_type;

/* Type List */

typedef OM_type FAR *OM_type_list;

/* Value */

typedef struct {
        OM_uint32       padding;
        OM_object       object;
} OM_padded_object;

typedef union OM_value_union {
        OM_string         string;
        OM_boolean        boolean;
        OM_enumeration    enumeration;
        OM_integer        integer;
        OM_padded_object  object;
        OM_i8             i8;
        OM_dword_ptr      dword_ptr;
} OM_value;

/* Value Length */

typedef OM_uint32 OM_value_length;

/* Value Position */

typedef OM_uint32 OM_value_position;

/* TERTIARY DATA TYPES */

/* Descriptor */
#include <pshpack4.h>
typedef struct OM_descriptor_struct {
        OM_type                 type;
        OM_syntax               syntax;
        union OM_value_union    value;
} OM_descriptor;
#include <poppack.h>

/* SYMBOLIC CONSTANTS */

/* Boolean */

#define OM_FALSE        ( (OM_boolean) 0 )
#define OM_TRUE         ( (OM_boolean) 1 )

/* Element Position */

#define OM_LENGTH_UNSPECIFIED   ( (OM_string_length) 0xFFFFFFFF )

/* Exclusions */

#define OM_NO_EXCLUSIONS                        ( (OM_exclusions) 0 )
#define OM_EXCLUDE_ALL_BUT_THESE_TYPES          ( (OM_exclusions) 1 )
#define OM_EXCLUDE_ALL_BUT_THESE_VALUES         ( (OM_exclusions) 2 )
#define OM_EXCLUDE_MULTIPLES                    ( (OM_exclusions) 4 )
#define OM_EXCLUDE_SUBOBJECTS                   ( (OM_exclusions) 8 )
#define OM_EXCLUDE_VALUES                       ( (OM_exclusions) 16 )
#define OM_EXCLUDE_DESCRIPTORS                  ( (OM_exclusions) 32 )

/* Modification */

#define OM_INSERT_AT_BEGINNING                  ( (OM_modification) 1 )
#define OM_INSERT_AT_CERTAIN_POINT              ( (OM_modification) 2 )
#define OM_INSERT_AT_END                        ( (OM_modification) 3 )
#define OM_REPLACE_ALL                          ( (OM_modification) 4 )
#define OM_REPLACE_CERTAIN_VALUES               ( (OM_modification) 5 )

/* Object Identifiers */

/*  NOTE: These macros rely on the ## token-pasting operator of ANSI C.
 *  On many pre-ANSI compilers the same effect can be obtained by
 *  replacing ## with /**/

/* Private macro to calculate length of an object identifier
 */
#define OMP_LENGTH(oid_string)  (sizeof(OMP_O_##oid_string)-1)


/* Macro to initialise the syntax and value of an object identifier
 */
#define OM_OID_DESC(type, oid_name)                                     \
        { (type), OM_S_OBJECT_IDENTIFIER_STRING,                        \
         { { OMP_LENGTH(oid_name) , OMP_D_##oid_name } } }


/* Macro to mark the end of a public object
 */
#define OM_NULL_DESCRIPTOR                                              \
        { OM_NO_MORE_TYPES, OM_S_NO_MORE_SYNTAXES,                      \
         { 0, OM_ELEMENTS_UNSPECIFIED } }


/* Macro to make class constants available within a compilation unit
 */
#define OM_IMPORT(class_name)                                           \
                extern char  FAR    OMP_D_##class_name[] ;                 \
                extern OM_string FAR class_name;


/* Macro to allocate memory for class constants within a compilation unit
 */
#define OM_EXPORT(class_name)                                           \
        char FAR OMP_D_##class_name[] = OMP_O_##class_name ;                \
        OM_string FAR class_name =                                          \
            { OMP_LENGTH(class_name), OMP_D_##class_name } ;


/* Constant for the OM package
 */
#define OMP_O_OM_OM             "\126\006\001\002\004"

/* Constant for the Encoding class
 */
#define OMP_O_OM_C_ENCODING     "\126\006\001\002\004\001"

/* Constant for the External class
 */
#define OMP_O_OM_C_EXTERNAL     "\126\006\001\002\004\002"

/* Constant for the Object class
 */
#define OMP_O_OM_C_OBJECT       "\126\006\001\002\004\003"

/* Constant for the BER Object Identifier
 */
#define OMP_O_OM_BER            "\121\001"

/* Constant for the Canonical-BER Object Identifier
 */
#define OMP_O_OM_CANONICAL_BER  "\126\006\001\002\005"

/* Return Code */

#define OM_SUCCESS                      ( (OM_return_code) 0 )
#define OM_ENCODING_INVALID             ( (OM_return_code) 1 )
#define OM_FUNCTION_DECLINED            ( (OM_return_code) 2 )
#define OM_FUNCTION_INTERRUPTED         ( (OM_return_code) 3 )
#define OM_MEMORY_INSUFFICIENT          ( (OM_return_code) 4 )
#define OM_NETWORK_ERROR                ( (OM_return_code) 5 )
#define OM_NO_SUCH_CLASS                ( (OM_return_code) 6 )
#define OM_NO_SUCH_EXCLUSION            ( (OM_return_code) 7 )
#define OM_NO_SUCH_MODIFICATION         ( (OM_return_code) 8 )
#define OM_NO_SUCH_OBJECT               ( (OM_return_code) 9 )
#define OM_NO_SUCH_RULES                ( (OM_return_code) 10 )
#define OM_NO_SUCH_SYNTAX               ( (OM_return_code) 11 )
#define OM_NO_SUCH_TYPE                 ( (OM_return_code) 12 )
#define OM_NO_SUCH_WORKSPACE            ( (OM_return_code) 13 )
#define OM_NOT_AN_ENCODING              ( (OM_return_code) 14 )
#define OM_NOT_CONCRETE                 ( (OM_return_code) 15 )
#define OM_NOT_PRESENT                  ( (OM_return_code) 16 )
#define OM_NOT_PRIVATE                  ( (OM_return_code) 17 )
#define OM_NOT_THE_SERVICES             ( (OM_return_code) 18 )
#define OM_PERMANENT_ERROR              ( (OM_return_code) 19 )
#define OM_POINTER_INVALID              ( (OM_return_code) 20 )
#define OM_SYSTEM_ERROR                 ( (OM_return_code) 21 )
#define OM_TEMPORARY_ERROR              ( (OM_return_code) 22 )
#define OM_TOO_MANY_VALUES              ( (OM_return_code) 23 )
#define OM_VALUES_NOT_ADJACENT          ( (OM_return_code) 24 )
#define OM_WRONG_VALUE_LENGTH           ( (OM_return_code) 25 )
#define OM_WRONG_VALUE_MAKEUP           ( (OM_return_code) 26 )
#define OM_WRONG_VALUE_NUMBER           ( (OM_return_code) 27 )
#define OM_WRONG_VALUE_POSITION         ( (OM_return_code) 28 )
#define OM_WRONG_VALUE_SYNTAX           ( (OM_return_code) 29 )
#define OM_WRONG_VALUE_TYPE             ( (OM_return_code) 30 )

/* String (Elements component) */

#define OM_ELEMENTS_UNSPECIFIED         ( (void *) 0 )

/* Syntax */

#define OM_S_NO_MORE_SYNTAXES           ( (OM_syntax) 0 )
#define OM_S_BIT_STRING                 ( (OM_syntax) 3 )
#define OM_S_BOOLEAN                    ( (OM_syntax) 1 )
#define OM_S_ENCODING_STRING            ( (OM_syntax) 8 )
#define OM_S_ENUMERATION                ( (OM_syntax) 10 )
#define OM_S_GENERAL_STRING             ( (OM_syntax) 27 )
#define OM_S_GENERALISED_TIME_STRING    ( (OM_syntax) 24 )
#define OM_S_GRAPHIC_STRING             ( (OM_syntax) 25 )
#define OM_S_IA5_STRING                 ( (OM_syntax) 22 )
#define OM_S_INTEGER                    ( (OM_syntax) 2 )
#define OM_S_NULL                       ( (OM_syntax) 5 )
#define OM_S_NUMERIC_STRING             ( (OM_syntax) 18 )
#define OM_S_OBJECT                     ( (OM_syntax) 127 )
#define OM_S_OBJECT_DESCRIPTOR_STRING   ( (OM_syntax) 7 )
#define OM_S_OBJECT_IDENTIFIER_STRING   ( (OM_syntax) 6 )
#define OM_S_OCTET_STRING               ( (OM_syntax) 4 )
#define OM_S_PRINTABLE_STRING           ( (OM_syntax) 19 )
#define OM_S_TELETEX_STRING             ( (OM_syntax) 20 )
#define OM_S_UTC_TIME_STRING            ( (OM_syntax) 23 )
#define OM_S_VIDEOTEX_STRING            ( (OM_syntax) 21 )
#define OM_S_VISIBLE_STRING             ( (OM_syntax) 26 )
#define OM_S_UNICODE_STRING                 ( (OM_syntax) 64 )
#define OM_S_I8                         ( (OM_syntax) 65 )
#define OM_S_OBJECT_SECURITY_DESCRIPTOR ( (OM_syntax) 66 )
#define OM_S_LONG_STRING                ((OM_syntax) 0x8000)
#define OM_S_NO_VALUE                   ((OM_syntax) 0x4000)
#define OM_S_LOCAL_STRING               ((OM_syntax) 0x2000)
#define OM_S_SERVICE_GENERATED          ((OM_syntax) 0x1000)
#define OM_S_PRIVATE                    ((OM_syntax) 0x0800)
#define OM_S_SYNTAX                     ((OM_syntax) 0x03FF)

/* Type */

#define OM_NO_MORE_TYPES                ( (OM_type) 0 )
#define OM_ARBITRARY_ENCODING           ( (OM_type) 1 )
#define OM_ASN1_ENCODING                ( (OM_type) 2 )
#define OM_CLASS                        ( (OM_type) 3 )
#define OM_DATA_VALUE_DESCRIPTOR        ( (OM_type) 4 )
#define OM_DIRECT_REFERENCE             ( (OM_type) 5 )
#define OM_INDIRECT_REFERENCE           ( (OM_type) 6 )
#define OM_OBJECT_CLASS                 ( (OM_type) 7 )
#define OM_OBJECT_ENCODING              ( (OM_type) 8 )
#define OM_OCTET_ALIGNED_ENCODING       ( (OM_type) 9 )
#define OM_PRIVATE_OBJECT               ( (OM_type) 10 )
#define OM_RULES                        ( (OM_type) 11 )

/* Value Position */

#define OM_ALL_VALUES                   ( (OM_value_position) 0xFFFFFFFF)


/* WORKSPACE INTERFACE */

#include <xomi.h>

#pragma pack()

/* END SERVICE INTERFACE */

#endif  /* XOM_HEADER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\dblint.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dblint.h

Abstract:

    Support primitives for bignum package.


--*/

/*
        File: dblint.h.  Supplement to bignum.h

        This file has declarations related to 
        double-precision integers,
        such as typedefs, constants, and primitive operations.

        Before #including this, one should #define

                digit_t -- typedef for single-precision integers.
                RADIX_BITS -- Number of bits per digit_t.

        and identify which compiler one is using.

        Constants defined herein include

                DBLINT_BUILTIN -- 1 if compiler directly
                                  supports double integers, 0 if not.

                DBLINT_HIGH_INDEX (optional)  -- When DBLINT_BUILTIN == 1,
                                  this is 0 if compiler stores
                                  the most significant half of a
                                  dblint_t datum first, and 1
                                  if compiler stores the least
                                  significant half first.  See
                                  HIGH_DIGIT and MAKE_DBLINT below.

                                  If this is not defined, then HIGH_DIGIT
                                  and MAKE_DBLINT are defined using
                                  shifts by RADIX_BITS.  If the compiler
                                  optimizes such shifts, then
                                  leave DBLINT_HIGH_INDEX undefined.


        The dblint_t type is unsigned and holds 
        twice as many bits as a digit_t datum.
        If (DBLINT_BUILTIN = 1),
        then use the type already in the language.
        Otherwise (DBLINT_BUILTIN = 0) 
        construct one of our own, 
        using a struct with two digit_t fields.

        Let u, u1, u2 have type digit_t and
        d, d1, d2 have type dblint_t.  
        The following primitives are defined, 
        whether we use the built-in type or our own type:

                DBLINT(u) -- Convert u from type digit_t to type dblint_t.             
                DBLINT_ADD(d1, d2) -- Sum d1 + d2.
                DBLINT_EQ(d1, d2)  -- Test whether d1 == d2.
                DBLINT_GE(d1, d2)  -- Test whether d1 >= d2.
                DBLINT_GT(d1, d2)  -- Test whether d1 > d2.
                DBLINT_LE(d1, d2)  -- Test whether d1 >= d2.
                DBLINT_LT(d1, d2)  -- Test whether d1 > d2.
                DBLINT_NE(d1, d2)  -- Test whether d1 <> d2.
                DBLINT_SUB(d1, d2) -- Difference d1 - d2.
                DPRODUU(u1, u2) -- Product of u1 and u2, as a dblint_t.
                HPRODUU(u1, u2) -- Most significant half of product
                                   of u1 and u2, as a digit_t.
                HIGH_DIGIT(d) -- Most significant half of d.
                LOW_DIGIT(d) -- Least significant half of d.
                MAKE_DBLINT(u1, u2) -- Construct a dblint_t
                        whose most significant half is u1 and
                        whose least significant half is u2.
*/

#if COMPILER == COMPILER_GCC

    #define DBLINT_BUILTIN 1
    typedef unsigned long long dblint_t;
    #define DBLINT_HIGH_INDEX 0  
                /* GCC on SPARC stores high half of dblint_t first */
#endif

#if COMPILER == COMPILER_VC && RADIX_BITS == 32  
    #define DBLINT_BUILTIN 1
    typedef unsigned __int64 dblint_t;
#if TARGET == TARGET_ALPHA
				/* If the Alpha is using RADIX_BITS == 32,
				   then use the shift instruction 
	               for HIGH_DIGIT and MAKE_DBLINT */ 
#else
    #define DBLINT_HIGH_INDEX 1
                /* Visual C++ on ix86 stores low half of dblint_t first */
#endif
#endif

#ifndef DBLINT_BUILTIN
                        /* No language support -- simulate using structs */
    #define DBLINT_BUILTIN 0
    typedef struct {
                     digit_t high;
                     digit_t low;
                   } dblint_t;
#endif

typedef const dblint_t dblint_tc;


#if DBLINT_BUILTIN
/*
        If language has support for double-length integers, use it.
        Good compilers will inline these simple operations.
*/

#define DBLINT(u) ((dblint_t)(u))


#define DBLINT_ADD(d1, d2) ((d1) + (d2))
#define DBLINT_EQ( d1, d2) ((d1) == (d2))
#define DBLINT_GE( d1, d2) ((d1) >= (d2))
#define DBLINT_GT( d1, d2) ((d1) > (d2))
#define DBLINT_LE( d1, d2) ((d1) <= (d2))
#define DBLINT_LT( d1, d2) ((d1) < (d2))
#define DBLINT_NE( d1, d2) ((d1) != (d2))
#define DBLINT_SUB(d1, d2) ((d1) - (d2))

#if COMPILER == COMPILER_GCC
#define DPRODUU(u1, u2) (DBLINT(u1) * DBLINT(u2))
#endif

#if COMPILER == COMPILER_VC
/*
        A problem in Visual C/C++ 4.0 (x86 version, 1995)
        prevents proper inlining of the DPRODUU function
        if we code it in a straightforward way.  Specifically,
        if we have two nearby references DPRODUU(x, y)
        and DPRODUU(x, z), where one argument (here x) is
        repeated, then the compiler calls library function
        __allmul rather than emit a MUL instruction.
        The -volatile- keyword inhibits the compiler from
        recognizing the repeated subexpression DBLINT(x),
        and circumvents the problem, alas with extra memory
        references.

		x86 version of VC 4.1 adds an __emulu function
*/
static inline dblint_t DPRODUU(digit_tc u1, digit_tc u2)
{
#if TARGET == TARGET_IX86

    #if _MFC_VER < 0x0410
        volatile digit_tc u1copy = u1, u2copy = u2;
	    return DBLINT(u1copy) * DBLINT(u2copy);
    #else
        #pragma intrinsic(__emulu)
		return __emulu(u1, u2);
    #endif
#elif TARGET == TARGET_MIPS 
        #pragma intrinsic(__emulu)
		return __emulu(u1, u2);
#else
		return DBLINT(u1) * DBLINT(u2);
#endif
}
#endif

#define LOW_DIGIT(d)   ((digit_t)(d))

#ifdef DBLINT_HIGH_INDEX
    #if DBLINT_HIGH_INDEX < 0 || DBLINT_HIGH_INDEX > 1
        #error "Illegal value of DBLINT_HIGH_INDEX"
    #endif

    static inline digit_t HIGH_DIGIT(dblint_tc d)
    {
        dblint_tc dcopy = d;
        return ((digit_tc*)&dcopy)[DBLINT_HIGH_INDEX];
    }

    static inline dblint_t MAKE_DBLINT(digit_tc high, digit_tc low)
    {
        dblint_t build = low;
        ((digit_t*)&build)[DBLINT_HIGH_INDEX] = high;
        return build;
    }
#else /* DBLINT_HIGH_INDEX */
    #define HIGH_DIGIT(d)  ((digit_t)((d) >> RADIX_BITS))

    #define MAKE_DBLINT(high, low) \
       ( (DBLINT(high) << RADIX_BITS) | DBLINT(low) )

#endif /* DBLINT_HIGH_INDEX */

#else  /* DBLINT_BUILTIN */
    

static inline dblint_t DBLINT(digit_tc d)
{
    dblint_t answer;
    answer.low = d;
    answer.high = 0;
    return answer;
}

static inline dblint_t DBLINT_ADD(dblint_tc d1, dblint_tc d2)
{
    dblint_t answer;
    answer.low = d1.low + d2.low;
    answer.high = d1.high + d2.high + (answer.low < d1.low);
    return answer;
}

static inline BOOL DBLINT_EQ(dblint_tc d1, dblint_tc d2)
{
   return (d1.high == d2.high && d1.low == d2.low);
}

static inline BOOL DBLINT_GE(dblint_tc d1, dblint_tc d2)
{
   return (d1.high == d2.high ? d1.low  >= d2.low
                              : d1.high >= d2.high);
}

static inline BOOL DBLINT_GT(dblint_tc d1, dblint_tc d2)
{
   return (d1.high == d2.high ? d1.low  > d2.low
                              : d1.high > d2.high);
}

#define DBLINT_LE(d1, d2) DBLINT_GE(d2, d1)
#define DBLINT_LT(d1, d2) DBLINT_GT(d2, d1)

static inline BOOL DBLINT_NE(dblint_tc d1, dblint_tc d2)
{
   return (d1.high != d2.high || d1.low != d2.low);
}

static inline dblint_t DBLINT_SUB(dblint_tc d1, dblint_tc d2)
{    
    dblint_t answer;
    answer.low = d1.low - d2.low;
    answer.high = d1.high - d2.high - (d1.low < d2.low);
    return answer;
}

#define HIGH_DIGIT(d) ((d).high)
#define LOW_DIGIT(d)  ((d).low)

static inline dblint_t MAKE_DBLINT(digit_tc high, digit_tc low)
{
     dblint_t answer;
     answer.low = low; 
     answer.high = high;
     return answer;
}

#if TARGET == TARGET_ALPHA
    #pragma intrinsic(__UMULH)
    #define HPRODUU(u1, u2) __UMULH(u1, u2)
    static inline dblint_t DPRODUU(digit_tc u1, digit_tc u2)
	{
		dblint_t answer;

		answer.high = HPRODUU(u1, u2);   /* Upper product */
		answer.low = u1*u2;			 	 /* Lower product */
		return answer;
	}
#else
static inline dblint_t DPRODUU(digit_tc u1, digit_tc u2)
/*                            
        Multiply two single-precision operands,
        return double precision product.
        This will normally be replaced by an assembly language routine.
        unless the top half of the product is available in C.
*/
{
    dblint_t answer;
    digit_tc u1bot = u1 & RADIX_HALFMASK_BOTTOM,  u1top = u1 >> HALF_RADIX_BITS;
    digit_tc u2bot = u2 & RADIX_HALFMASK_BOTTOM,  u2top = u2 >> HALF_RADIX_BITS;

    digit_tc low  = u1bot * u2bot;
    digit_t  mid1 = u1bot * u2top;
    digit_tc mid2 = u1top * u2bot;
    digit_tc high = u1top * u2top;
/*
        Each half-word product is bounded by
        (SQRT(RADIX) - 1)^2 = RADIX - 2*SQRT(RADIX) + 1,
        so we can add two half-word operands
        to any product without risking integer overflow.
*/
    mid1 += (mid2 & RADIX_HALFMASK_BOTTOM) + (low >> HALF_RADIX_BITS);

    answer.high = high + (mid1 >> HALF_RADIX_BITS) 
                       + (mid2 >> HALF_RADIX_BITS);
    answer.low = (low & RADIX_HALFMASK_BOTTOM) + (mid1 << HALF_RADIX_BITS);
    return answer;
}
#endif /* multiplication */ 

#endif  /* DBLINT_BUILTIN */

#ifndef HPRODUU
    #define HPRODUU(u1, u2) HIGH_DIGIT(DPRODUU(u1, u2))
#endif

/*
    The DBLINT_SUM, MULTIPLY_ADD1. MULTIPLY_ADD2
    functions take single-length (digit_t) operands and
    return double-length (dblint_t) results.
    Overflow is impossible.
*/

#if TARGET == TARGET_ALPHA && RADIX_BITS == 64 && !DBLINT_BUILT_IN
	static inline dblint_t DBLINT_SUM(digit_tc d1, digit_tc d2)
	{
        dblint_t answer;
		answer.low = d1 + d2;
		answer.high = (answer.low < d1);
		return answer;
	}
    static inline dblint_t MULTIPLY_ADD1(digit_tc d1, digit_tc d2, digit_tc d3)
	{
        dblint_t answer;
		digit_t ah, al;

        al = d1*d2;
		ah = __UMULH(d1, d2);
		al += d3;
		answer.high = ah + (al < d3);
		answer.low = al;
		return answer;
	}
	static inline dblint_t MULTIPLY_ADD2(digit_tc d1, digit_tc d2, 
		                                 digit_tc d3, digit_tc d4)
	{
		dblint_t answer;
		digit_t ah, al, bh, bl;

		al = d1*d2;
		ah = __UMULH(d1, d2);
		bl = d3 + d4;
		bh = (bl < d3);
        answer.low = al + bl;
		answer.high = ah + bh + (answer.low < al);
		return answer;
	}

#else
    #define DBLINT_SUM(d1, d2) DBLINT_ADD(DBLINT(d1), DBLINT(d2))
            /* d1 + d2 */

    #define MULTIPLY_ADD1(d1, d2, d3) \
        DBLINT_ADD(DPRODUU(d1, d2), DBLINT(d3));
           /* d1*d2 + d3 */

    #define MULTIPLY_ADD2(d1, d2, d3, d4) \
        DBLINT_ADD(DBLINT_ADD(DPRODUU(d1, d2), DBLINT(d3)), \
                   DBLINT(d4))
          /* d1*d2 + d3 + d4 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\descrypt.h ===
#ifndef __DESCRYPT_H__
#define __DESCRYPT_H__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef DECR_KEY
#define DECR_KEY  0
#define ENCR_KEY  1
#define ENCR_STD  2
#define ENCR_SES  4
#endif

#define CRYPT_ERR 1
#define CRYPT_OK  0


unsigned FAR __cdecl
DES_ECB_LM( unsigned            Option,
            const char FAR *    Key,
            unsigned char FAR * Src,
            unsigned char FAR * Dst);

#ifdef __cplusplus
}
#endif

#endif // __DESCRYPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\des3.h ===
#ifndef __DES3_H__
#define __DES3_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _DES3TABLE {
    DESTable    keytab1;
    DESTable    keytab2;
    DESTable    keytab3;
} DES3TABLE, *PDES3TABLE;

#define DES3_TABLESIZE  sizeof(DES3TABLE)
#define DES2_KEYSIZE    16
#define DES3_KEYSIZE    24

// In des2key.c:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 2 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API des2key(PDES3TABLE pDES3Table, PBYTE pbKey);

// In des3key.c:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 3 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API des3key(PDES3TABLE pDES3Table, PBYTE pbKey);

//
//   Encrypt or decrypt with the key in pKey
//

void RSA32API des3(PBYTE pbIn, PBYTE pbOut, void *pKey, int op);

//
// set the parity on the DES key to be odd
//

void RSA32API desparity(PBYTE pbKey, DWORD cbKey);

#ifdef __cplusplus
}
#endif

#endif // __DES3_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\engine.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    engine.h

Abstract:

    Defines public structures and APIs necessary to use the encryption engine

Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

--*/

#include "md4.h"

// This header file comes to use with FAR in it.
// Kill the FAR keyword within the file
#ifndef FAR
#define FAR
#include "descrypt.h"
#undef  FAR
#else
#include "descrypt.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\modes.h ===
#ifndef __MODES_H__
#define __MODES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* modes.h

    Defines the generic routines used to do chaining modes with a
    block cipher.
*/


#ifdef __cplusplus
extern "C" {
#endif

// constants for operations
#define ENCRYPT     1
#define DECRYPT     0

/* CBC()
 *
 * Performs a XOR on the plaintext with the previous ciphertext
 *
 * Parameters:
 *
 *      output      Input buffer    -- MUST be RC2_BLOCKLEN
 *      input       Output buffer   -- MUST be RC2_BLOCKLEN
 *      keyTable
 *      op      ENCRYPT, or DECRYPT
 *      feedback    feedback register
 *
 */
void
RSA32API
CBC(
         void   RSA32API Cipher(UCHAR *, UCHAR *, void *, int),
         ULONG  dwBlockLen,
         UCHAR   *output,
         UCHAR   *input,
         void   *keyTable,
         int    op,
         UCHAR   *feedback
         );


/* CFB (cipher feedback)
 *
 *
 * Parameters:
 *
 *
 *      output      Input buffer    -- MUST be RC2_BLOCKLEN
 *      input       Output buffer   -- MUST be RC2_BLOCKLEN
 *      keyTable
 *      op      ENCRYPT, or DECRYPT
 *      feedback    feedback register
 *
 */
void
RSA32API
CFB(
         void   RSA32API Cipher(UCHAR *, UCHAR *, void *, int),
         ULONG  dwBlockLen,
         UCHAR   *output,
         UCHAR   *input,
         void   *keyTable,
         int    op,
         UCHAR   *feedback
         );


#ifdef __cplusplus
}
#endif

#endif // __MODES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\md5.h ===
#ifndef __MD5_H__
#define __MD5_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

#ifdef __cplusplus
extern "C" {
#endif

/* Data structure for MD5 (Message-Digest) computation */
typedef struct {
  ULONG i[2];                          /* number of _bits_ handled mod 2^64 */
  ULONG buf[4];                                           /* scratch buffer */
  unsigned char in[64];                                     /* input buffer */
  unsigned char digest[16];            /* actual digest after MD5Final call */
  ULONG FinishFlag;
} MD5_CTX;


#define MD5DIGESTLEN    16
#define MD5_LEN         MD5DIGESTLEN    // second def for WinNT source compatibility

#define PROTO_LIST(list)    list


/*
 * MTS: Each of these assumes MD5_CTX is locked against simultaneous use.
 */
void RSA32API MD5Init PROTO_LIST ((MD5_CTX *));
void RSA32API MD5Update PROTO_LIST ((MD5_CTX *, const unsigned char *, unsigned int));
void RSA32API MD5Final PROTO_LIST ((MD5_CTX *));

#ifdef __cplusplus
}
#endif

#endif // __MD5_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\hmac.h ===
#ifndef __HMAC_H__
#define __HMAC_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

// include "md5.h" before this

typedef struct {
    MD5_CTX context_ipad;
    MD5_CTX context_opad;
} HMACMD5_CTX;

// Initialize an HMAC context with a session key
//  Afterword, context can be used to sign messages with the session key
//
void
RSA32API
HMACMD5Init(
    HMACMD5_CTX * pCtx,                 // IN, OUT -- the context to initialize
    unsigned char *pKey,                // IN -- the session key
    unsigned int cKey                   // IN -- session key length
    );

// Update the signature of a message
//  takes a fragment of a message, updates signature for that fragment
void
RSA32API
HMACMD5Update(
  HMACMD5_CTX * pCtx,                   // IN, OUT -- context of signature to update
  unsigned char *pMsg,                  // IN -- message fragment
  unsigned int cMsg                     // IN -- message length
  );

// Get the signature out of the context, reset for next message
//
void
RSA32API
HMACMD5Final(
    HMACMD5_CTX * pCtx,                 // IN, OUT -- the context
    unsigned char Hash[MD5DIGESTLEN]    // OUT -- the signature
    );

#ifdef __cplusplus
}
#endif


#endif // __HMAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\md2.h ===
#ifndef __MD2_H__
#define __MD2_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Copyright (C) 1990-2, RSA Data Security, Inc. Created 1990. All
   rights reserved.

   License to copy and use this software is granted for
   non-commercial Internet Privacy-Enhanced Mail provided that it is
   identified as the "RSA Data Security, Inc. MD2 Message Digest
   Algorithm" in all material mentioning or referencing this software
   or this function.

   RSA Data Security, Inc. makes no representations concerning either
   the merchantability of this software or the suitability of this
   software for any particular purpose. It is provided "as is"
   without express or implied warranty of any kind.

   These notices must be retained in any copies of any part of this
   documentation and/or software.
 */


typedef struct {
  unsigned char state[16];                                 /* state */
  unsigned char checksum[16];                           /* checksum */
  unsigned int count;                 /* number of bytes, modulo 16 */
  unsigned char buffer[16];                         /* input buffer */
} MD2_CTX;

int RSA32API MD2Update(MD2_CTX *, unsigned char *, unsigned int);
int RSA32API MD2Final(MD2_CTX *);
void RSA32API MD2Transform(unsigned char [16], unsigned char [16],
                  unsigned char [16]);


#ifdef __cplusplus
}
#endif

#endif // __MD2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\md4.h ===
#ifndef __MD4_H__
#define __MD4_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/*
** ********************************************************************
** md4.h -- Header file for implementation of                        **
** MD4 Message Digest Algorithm                                      **
** Updated: 2/13/90 by Ronald L. Rivest                              **
** (C) 1990 RSA Data Security, Inc.                                  **
** ********************************************************************
*/

#ifdef __cplusplus
extern "C" {
#endif

// MD4Update Errors
#define MD4_SUCCESS         0
#define MD4_TOO_BIG         1
#define MD4_ALREADY_DONE    2

// MD4 Digest length -- 4 word result == 16 bytes
#define MD4DIGESTLEN 16

// Block size of MD4 -- Assumes 8 bits per byte
#define MD4BLOCKSIZE 64
#define MD4BYTESTOBITS(bytes) ((bytes)*8)   // MDupdate wants bits

/* MDstruct is the data structure for a message digest computation.
*/
typedef struct {
  unsigned long buffer[4]; /* Holds 4-word result of MD computation */
  unsigned char count[8]; /* Number of bits processed so far */
  unsigned int done;      /* Nonzero means MD computation finished */
} MDstruct, *MDptr;

/* MDbegin(MD)
** Input: MD -- an MDptr
** Initialize the MDstruct prepatory to doing a message digest
** computation.
**
** MTS: Assumes MDPtr is locked against simultaneous use.
*/
extern void MDbegin(MDptr);

/* MDupdate(MD,X,count)
** Input: MD -- an MDptr
**     X -- a pointer to an array of unsigned characters.
**        count -- the number of bits of X to use (an unsigned int).
** Updates MD using the first "count" bits of X.
** The array pointed to by X is not modified.
** If count is not a multiple of 8, MDupdate uses high bits of
** last byte.
** This is the basic input routine for a user.
** The routine terminates the MD computation when count < MD4BLOCKSIZE, so
** every MD computation should end with one call to MDupdate with a
** count less than MD4BLOCKSIZE.  Zero is OK for a count.
**
** Return values:
**      MD4_SUCCESS:        success
**      MD4_TOO_LONG:       Hash is already terminated
**      MD4_ALREADY_DONE:   Length is invalid (too big)
**
** MTS: Assumes MDPtr is locked against simultaneous use.
**
**
** NOTE: MDupdate wants the length in BITS
*/
extern int MDupdate(MDptr, const unsigned char *pbData, int wLen);



/*

    This second implementation of MD4 entry points is the newer style,
    optimized implementation, compatible with newer code expecting these
    entry point names.

    Scott Field (sfield)    21-Oct-97

*/


#ifndef UINT4
#define UINT4   unsigned long
#endif

/* Data structure for MD4 (Message Digest) computation */
typedef struct {
  UINT4 state[4];                                   /* state (ABCD) */
  UINT4 count[2];        /* number of bits, modulo 2^64 (lsb first) */
  unsigned char buffer[64];                         /* input buffer */
  unsigned char digest[16];    /* actual digest after MD4Final call */
} MD4_CTX;

#define MD4_LEN 16

void RSA32API MD4Init (MD4_CTX *);
void RSA32API MD4Update (MD4_CTX *, unsigned char *, unsigned int);
void RSA32API MD4Final (MD4_CTX * );

#ifdef __cplusplus
}
#endif

#endif __MD4_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\rc2.h ===
#ifndef __RC2_H__
#define __RC2_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* Copyright (C) RSA Data Security, Inc. created 1990.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifdef __cplusplus
extern "C" {
#endif

/* Actual table size to use */
#define RC2_TABLESIZE 128

/* number of bytes in an RC2 block */
#define RC2_BLOCKLEN    8

/* RC2Key()
 *
 * Generate the key control structure.  Key can be any size.
 *
 * Parameters:
 *      pwKT        Pointer to a key table that will be initialized.
 *                      MUST be RC2_TABLESIZE.
 *      pbKey       Pointer to the key.
 *      dwLen       Size of the key, in bytes.
 *                      MUST be <= RC2_TABLESIZE.
 *
 * MTS: Assumes pwKT is locked against simultaneous use.
 */
int
RSA32API
RC2Key (
    WORD *pwKT,
    BYTE *pbKey,
    DWORD dwLen
    );

/* RC2KeyEx()
 *
 * Generate the key control structure.  Key can be any size.
 *
 * Parameters:
 *      pwKT        Pointer to a key table that will be initialized.
 *                      MUST be RC2_TABLESIZE.
 *      pbKey       Pointer to the key.
 *      dwLen       Size of the key, in bytes.
 *                      MUST be <= RC2_TABLESIZE.
 *      eSpace      effective key space in bits, 0 < n <= 1024
 *
 * MTS: Assumes pwKT is locked against simultaneous use.
 */

int
RSA32API
RC2KeyEx (
    WORD *keyTable,
    BYTE *key,
    DWORD keyLen,
    DWORD eSpace
    );


/* RC2()
 *
 * Performs the actual encryption
 *
 * Parameters:
 *
 *      pbIn        Input buffer    -- MUST be RC2_BLOCKLEN
 *      pbOut       Output buffer   -- MUST be RC2_BLOCKLEN
 *      pwKT        Pointer to an initialized (by RC2Key) key table.
 *      op          ENCRYPT, or DECRYPT
 *
 * MTS: Assumes pwKT is locked against simultaneous use.
 */
void RSA32API RC2 (BYTE *pbIn, BYTE *pbOut, void *pwKT, int op);

#ifdef __cplusplus
}
#endif

#endif // __RC2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\rc4.h ===
#ifndef __RC4_H__
#define __RC4_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Key structure */
#if defined(_WIN64) && !defined(MIDL_PASS)
__declspec(align(8))
#endif
typedef struct RC4_KEYSTRUCT
{
  unsigned char S[256];     /* State table */
  unsigned char i,j;        /* Indices */
} RC4_KEYSTRUCT;

/* rc4_key()
 *
 * Generate the key control structure.  Key can be any size.
 *
 * Parameters:
 *   Key        A KEYSTRUCT structure that will be initialized.
 *   dwLen      Size of the key, in bytes.
 *   pbKey      Pointer to the key.
 *
 * MTS: Assumes pKS is locked against simultaneous use.
 */
void RSA32API rc4_key(struct RC4_KEYSTRUCT *pKS, unsigned int dwLen, unsigned char *pbKey);

/* rc4()
 *
 * Performs the actual encryption
 *
 * Parameters:
 *
 *   pKS        Pointer to the KEYSTRUCT created using rc4_key().
 *   dwLen      Size of buffer, in bytes.
 *   pbuf       Buffer to be encrypted.
 *
 * MTS: Assumes pKS is locked against simultaneous use.
 */
void RSA32API rc4(struct RC4_KEYSTRUCT *pKS, unsigned int dwLen, unsigned char *pbuf);

#ifdef __cplusplus
}
#endif

#endif // __RC4_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\rsa.h ===
#ifndef __RSA_H__
#define __RSA_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* rsa.h
 *
 *      RSA library functions.
 *
 * Copyright (C) RSA Data Security, Inc. created 1990.  This is an
 * unpublished work protected as such under copyright law.  This work
 * contains proprietary, confidential, and trade secret information of
 * RSA Data Security, Inc.  Use, disclosure or reproduction without the
 * express written authorization of RSA Data Security, Inc. is
 * prohibited.
 *
 */

#ifdef __cplusplus
extern "C" {
#endif

#define RSA1 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'1'<<24))
#define RSA2 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'2'<<24))

// Key header structures.
//
//    These structs define the fixed data at the beginning of an RSA key.
//    They are followed by a variable length of data, sized by the stlen
//    field.

typedef struct {
    DWORD       magic;                  /* Should always be RSA1 */
    DWORD       keylen;                 // size of modulus buffer
    DWORD       bitlen;                 // # of bits in modulus
    DWORD       datalen;                // max number of bytes to be encoded
    DWORD       pubexp;                 //public exponent
} BSAFE_PUB_KEY, FAR *LPBSAFE_PUB_KEY;

typedef struct {
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       keylen;                 // size of modulus buffer
    DWORD       bitlen;                 // bit size of key
    DWORD       datalen;                // max number of bytes to be encoded
    DWORD       pubexp;                 // public exponent
} BSAFE_PRV_KEY, FAR *LPBSAFE_PRV_KEY;

typedef struct {
    BYTE    *modulus;
    BYTE    *prvexp;
    BYTE    *prime1;
    BYTE    *prime2;
    BYTE    *exp1;
    BYTE    *exp2;
    BYTE    *coef;
    BYTE    *invmod;
    BYTE    *invpr1;
    BYTE    *invpr2;
} BSAFE_KEY_PARTS, FAR *LPBSAFE_KEY_PARTS;

typedef const BYTE far *cLPBYTE;                // const LPBYTE resolves wrong

// Structure for passing info into BSafe calls (currently this is used for
// passing in a callback function pointer for random number generation and
// information needed by the RNG, may eventually support exponentiation
// offload.
//

typedef struct {
    void        *pRNGInfo;              // dat
    void        *pFuncRNG;              // Function pointer for RNG callback
                                        // callback prototype is
                                        // void pFuncRNG(
                                        //        IN      void *pRNGInfo, 
                                        //        IN  OUT unsigned char **ppbRandSeed,    // initial seed value (ignored if already set)
                                        //        IN      unsigned long *pcbRandSeed,
                                        //        IN  OUT unsigned char *pbBuffer,
                                        //        IN      unsigned long dwLength
                                        //        );
} BSAFE_OTHER_INFO;


/* BSafeEncPublic
 *
 * BSafeEncPublic(key, part_in, part_out)
 *
 *      RSA encrypt a buffer of size key->keylen, filled with data of size
 *      key->datalen with the public key pointed to by key, returning the
 *      encrypted data in part_out.
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY key - points to a public key in BSAFE_KEY
 *                              format.
 *
 *              LPBYTE part_in - points to a BYTE array of size key->keylen
 *                              holding the data to be encrypted.  The
 *                              data in the buffer should be no larger
 *                              than key->datalen.  All other bytes should
 *                              be zero.
 *
 *              LPBYTE part_out - points to a BYTE array of size keylen
 *                              to receive the encrypted data.
 *
 *      Returns
 *
 *              TRUE - encryption succeeded.
 *              FALSE - encryption failed.
 *
 */

BOOL
RSA32API
BSafeEncPublic(
    const LPBSAFE_PUB_KEY key,
    cLPBYTE part_in,
    LPBYTE part_out
    );


/* BSafeDecPrivate
 *
 * BSafeDecPrivate(key, part_in, part_out)
 *
 *      RSA decrypt a buffer of size keylen, containing key->datalen bytes
 *      of data with the private key pointed to by key, returning the
 *      decrypted data in part_out.
 *
 *      Parameters
 *
 *              LPBSAFE_PRV_KEY key - points to a private key in BSAFE_KEY
 *                              format.
 *
 *              LPBYTE part_in - points to a BYTE array of size key->keylen
 *                              holding the data to be decrypted.  The data
 *                              in the buffer should be no longer than
 *                              key->datalen.  All other bytes should be zero.
 *
 *              LPBYTE part_out - points to a BYTE array of size GRAINSIZE
 *                              to receive the decrypted data.
 *
 *      Returns
 *
 *              TRUE - decryption succeeded.
 *              FALSE - decryption failed.
 *
 */

BOOL
RSA32API
BSafeDecPrivate(
    const LPBSAFE_PRV_KEY key,
    cLPBYTE part_in,
    LPBYTE part_out
    );

/* BSafeMakeKeyPair
 *
 * BSafeMakeKeyPair(public_key, private_key, bits)
 *
 *      Generate an RSA key pair.
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY public_key - points to the memory to recieve
 *                                      the public key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the public key size by
 *                                      BSafeComputeKeySizes.
 *
 *              LPBSAFE_PRV_KEY private_key - points to the memory to recieve
 *                                      the private key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the private key size
 *                                      by BSafeComputeKeySizes.
 *
 *              DWORD bits - length of the requested key in bits.
 *                              This value must be even and greater than 63
 *
 *      Returns
 *
 *              TRUE - keys were successfully generated
 *              FALSE - not enough memory to generate keys
 *
 */

BOOL
RSA32API
BSafeMakeKeyPair(
    LPBSAFE_PUB_KEY public_key,
    LPBSAFE_PRV_KEY private_key,
    DWORD bits
    );

/* BSafeMakeKeyPairEx
 *
 * BSafeMakeKeyPairEx(public_key, private_key, bits, public_exp)
 *
 *      Generate an RSA key pair.
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY public_key - points to the memory to recieve
 *                                      the public key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the public key size by
 *                                      BSafeComputeKeySizes.
 *
 *              LPBSAFE_PRV_KEY private_key - points to the memory to recieve
 *                                      the private key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the private key size
 *                                      by BSafeComputeKeySizes.
 *
 *              DWORD bits - length of the requested key in bits.
 *                                      This value must be even and greater
 *                                      than 63
 *
 *              DWORD public_exp = supplies the public key exponent.  This
 *                                      should be a prime number.
 *
 *
 *      Returns
 *
 *              TRUE - keys were successfully generated
 *              FALSE - not enough memory to generate keys
 *
 */

BOOL
RSA32API
BSafeMakeKeyPairEx(
    LPBSAFE_PUB_KEY public_key,
    LPBSAFE_PRV_KEY private_key,
    DWORD bits,
    DWORD public_exp
    );

/* BSafeMakeKeyPairEx2
 *
 * BSafeMakeKeyPairEx2(pOtherInfo, public_key, private_key, bits, public_exp)
 *
 *      Generate an RSA key pair.
 *
 *      Parameters
 *
 *              BSAFE_OTHER_INFO pOtherInfo - points to a structure with information
 *                                      alternate information to be used when
 *                                      generating the RSA key pair.  Currently
 *                                      this structure has a pointer to a callback
 *                                      function which may be used when generating
 *                                      keys.  It also has a information to pass
 *                                      into that callback function (see OTHER_INFO).
 *
 *              LPBSAFE_PUB_KEY public_key - points to the memory to recieve
 *                                      the public key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the public key size by
 *                                      BSafeComputeKeySizes.
 *
 *              LPBSAFE_PRV_KEY private_key - points to the memory to recieve
 *                                      the private key.  This pointer must
 *                                      point to at least the number of bytes
 *                                      specified as the private key size
 *                                      by BSafeComputeKeySizes.
 *
 *              DWORD bits - length of the requested key in bits.
 *                                      This value must be even and greater
 *                                      than 63
 *
 *              DWORD public_exp = supplies the public key exponent.  This
 *                                      should be a prime number.
 *
 *
 *      Returns
 *
 *              TRUE - keys were successfully generated
 *              FALSE - not enough memory to generate keys
 *
 */

BOOL
RSA32API
BSafeMakeKeyPairEx2(BSAFE_OTHER_INFO *pOtherInfo,
                    LPBSAFE_PUB_KEY public_key,
                    LPBSAFE_PRV_KEY private_key,
                    DWORD bits,
                    DWORD dwPubExp);

/* BSafeFreePubKey
 *
 * BSafeFreePubKey(public_key)
 *
 *      Free the data associated with a public key
 *
 *      Parameters
 *
 *              LPBSAFE_PUB_KEY public_key - points to a BSAFE_PUB_KEY
 *                               structure to free.
 *
 *      Returns
 *
 *              nothing
 *
 */

void
RSA32API
BSafeFreePubKey(
    LPBSAFE_PUB_KEY public_key
    );

/* BSafeFreePrvKey
 *
 * BSafeFreePrvKey(public_key)
 *
 *      Free the data associated with a private key
 *
 *      Parameters
 *
 *              LPBSAFE_PRV_KEY private_key - points to a BSAFE_PRV_KEY
 *                               structure to free.
 *
 *      Returns
 *
 *              nothing
 *
 */

void
RSA32API
BSafeFreePrvKey(
    LPBSAFE_PRV_KEY private_key
    );


/* BSafeComputeKeySizes
 *
 *      BSafeComputeKeySizes(   LPDWORD PubKeySize,
 *                              LPDWORD PrivKeySize,
 *                              LPDWORD bits )
 *
 *      Computes the required memory to hold a public and private key of
 *      a specified number of bits.
 *
 *      Parameters:
 *
 *              LPDWORD PubKeySize - pointer to DWORD to return the public
 *                                   key size, in bytes.
 *
 *              LPDWORD PrivKeySize - pointer to DWORD to return the private
 *                                    key size, in bytes.
 *
 *              LPDWORD bits      - pointer to DWORD specifying number of bits
 *                                  in the RSA modulus.
 *
 *      Returns:
 *
 *              TRUE if *bits is a valid RSA modulus size.
 *              FALSE if *bits is an invalid RSA modulus size.
 *
 */

BOOL
RSA32API
BSafeComputeKeySizes(
    LPDWORD PublicKeySize,
    LPDWORD PrivateKeySize,
    LPDWORD bits
    );

/* BSafeGetPrvKeyParts
 *
 * BOOL BSafeGetPrvKeyParts(    LPBSAFE_PRV_KEY key,
 *                              LPBSAFE_KEY_PARTS parts)
 *
 *      Returns pointers to the parts of a private key, and the length of
 *      the modulus in bytes.
 *
 *      Parameters:
 *
 *              LPBSAFE_PRV_KEY key     - the key to disassemble
 *              LPBSAFE_KEY_PARTS parts - the structure to fill in
 *
 *      Returns -
 *              FALSE if the key is not valid.
 */

BOOL
RSA32API
BSafeGetPrvKeyParts(
    LPBSAFE_PRV_KEY key,
    LPBSAFE_KEY_PARTS parts
    );


/* BSafeGetPubKeyModulus
 *
 * BYTE *BSafeGetPubKeyModulus(LPBSAFE_PUB_KEY key)
 *
 *      Returns pointer to the modulus of a public key
 *
 *      Parameters:
 *
 *              LPBSAFE_PUB_KEY key     - the key to disassemble
 *
 *      Returns -
 *
 *              Pointer to the parts, VOID on error.
 *              Fails if the key is not valid.
 */

BYTE *
RSA32API
BSafeGetPubKeyModulus(
    LPBSAFE_PUB_KEY key
    );

#ifdef __cplusplus
}
#endif


#endif // __RSA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\randlib.h ===
/*++

Copyright (c) 1993, 1998  Microsoft Corporation

Module Name:

    randlib.h

Abstract:

    Exported procedures for core cryptographic random number generation.

Author:

    Scott Field (sfield)    27-Oct-98

Revision History:

      Oct 11 1996 jeffspel moved from ntagimp1.h
      Aug 27 1997 sfield   Increase RAND_CTXT_LEN
      Aug 15 1998 sfield   Kernel mode and general cleanup

--*/

#ifndef __RANDLIB_H__
#define __RANDLIB_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif


typedef struct {
    unsigned long   cbSize;
    unsigned long   Flags;
    unsigned char   *pbRandSeed;
    unsigned long   cbRandSeed;
} RNG_CONTEXT, *PRNG_CONTEXT, *LPRNG_CONTEXT;

#define RNG_FLAG_REKEY_ONLY 1


//
// primary random number generation interface
// Functions return TRUE for success, FALSE for failure.
//

unsigned int
RSA32API
NewGenRandomEx(
    IN      RNG_CONTEXT *pRNGContext,
    IN  OUT unsigned char *pbRandBuffer,
    IN      unsigned long cbRandBuffer
    );


unsigned int
RSA32API
NewGenRandom(
    IN  OUT unsigned char **ppbRandSeed,    // initial seed value (ignored if already set)
    IN      unsigned long *pcbRandSeed,
    IN  OUT unsigned char *pbBuffer,
    IN      unsigned long dwLength
    );

//
// RNG seed set and query
//

unsigned int
RSA32API
InitRand(
    IN  OUT unsigned char **ppbRandSeed,    // new seed value to set (over-writes current)
    IN      unsigned long *pcbRandSeed
    );

unsigned int
RSA32API
DeInitRand(
    IN  OUT unsigned char *pbRandSeed,      // output of current seed
    IN      unsigned long cbRandSeed
    );


//
// RNG initializers for DLL_PROCESS_ATTACH, DLL_PROCESS_DETACH
//

unsigned int
RSA32API
InitializeRNG(
    VOID *pvReserved
    );

void
RSA32API
ShutdownRNG(
    VOID *pvReserved
    );



//
// RC4 thread safe primitives, for the bold users who stream data from RC4
// themselves.
//


//
// rc4_safe_startup called to initialize internal structures.
// typically called during DLL_PROCESS_ATTACH type initialiation code.
//

unsigned int
RSA32API
rc4_safe_startup(
    IN OUT  void **ppContext
    );

unsigned int
RSA32API
rc4_safe_startup_np(
    IN OUT  void **ppContext
    );


//
// typically call rc4_safe_shutdown during DLL_PROCESS_DETACH, with the
// value obtained during rc4_safe_startup
//

void
RSA32API
rc4_safe_shutdown(
    IN      void *pContext
    );

void
RSA32API
rc4_safe_shutdown_np(
    IN      void *pContext
    );


//
// select a safe entry.
// outputs: entry index
//          bytes used for specified index.  0xffffffff indicates caller
//          MUST call rc4_safe_key to initialize the key.
//          caller decides when to rekey based on non-zero output of pBytesUsed
//          example is RNG re-keying when pBytesUsed >= 16384
//


void
RSA32API
rc4_safe_select(
    IN      void *pContext,
    OUT     unsigned int *pEntry,
    OUT     unsigned int *pBytesUsed
    );

void
RSA32API
rc4_safe_select_np(
    IN      void *pContext,
    OUT     unsigned int *pEntry,
    OUT     unsigned int *pBytesUsed
    );

//
// initialize the key specified by Entry index.
//  key material is size cb, pointer to key is pv.
// this routine is the safe version of rc4_key()
//

void
RSA32API
rc4_safe_key(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      const void *pv
    );

void
RSA32API
rc4_safe_key_np(
    IN      void *pContext,
    IN      unsigned int Entry, // 0xffffffff for default
    IN      unsigned int cb,
    IN      const void *pv
    );

//
// encrypt using the key specified by Entry index.
// buffer of size cb at location pv is encrypted.
// this routine is the safe version of rc4()
//

void
RSA32API
rc4_safe(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      void *pv
    );

void
RSA32API
rc4_safe_np(
    IN      void *pContext,
    IN      unsigned int Entry,
    IN      unsigned int cb,
    IN      void *pv
    );


#ifdef __cplusplus
}
#endif

#endif // __RANDLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\rsa_sys.h ===
/* rsa_sys.c
 *
 *	RSA system dependent functions.
 *		Memory allocation
 *		Random number generation.
 *
 */

#ifndef __RSA_SYS_H__
#define __RSA_SYS_H__

#ifndef KMODE_RSA32

#define RSA32Alloc(cb) LocalAlloc(0, cb)
#define RSA32Free(pv) LocalFree(pv)

#else

void* __stdcall RSA32Alloc( unsigned long cb );
void __stdcall RSA32Free( void *pv );

#endif  // KMODE_RSA32

#endif  // __RSA_SYS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\sha.h ===
#ifndef RSA32API
#define RSA32API __stdcall
#endif

/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHA_H_
#define _SHA_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

#define A_SHA_DIGEST_LEN 20

typedef struct {
    ULONG       FinishFlag;
    UCHAR        HashVal[A_SHA_DIGEST_LEN];
    ULONG state[5];                             /* state (ABCDE) */
    ULONG count[2];                             /* number of bytes, msb first */
    unsigned char buffer[64];                   /* input buffer */
} A_SHA_CTX;

void RSA32API A_SHAInit(A_SHA_CTX *);
void RSA32API A_SHAUpdate(A_SHA_CTX *, unsigned char *, unsigned int);
void RSA32API A_SHAFinal(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

//
// versions that don't internally byteswap (NoSwap version), for apps like
// the RNG that don't need hash compatibility - perf increase helps.
//

void RSA32API A_SHAUpdateNS(A_SHA_CTX *, unsigned char *, unsigned int);
void RSA32API A_SHAFinalNS(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\shacomm.h ===
/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHACOMM_H_
#define _SHACOMM_H_ 1

//
// this file and it's contents were made obsolete.  Only sha.h is required.
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\rsa_fast.h ===
/* rsa_fast.h
 *
 *  Headers for performance critical RSA routines.
 */

/*
 *
 *  #defines used by RSA routines
 */

#define DIGIT_BYTES     4
#define DIGIT_BITS      32
#define DIGIT_HIBIT     0x80000000
#define DIGIT_ALLONES   0xffffffff

#define ULTRA           unsigned __int64
#define U_RADIX         (ULTRA)0x100000000

#ifndef BIGENDIAN
#define LODWORD(x)      (DWORD)(x & DIGIT_ALLONES)
#else
#define LODWORD(x)      (DWORD)(x)
#endif

// warning!!!!!
// the following macro defines a highspeed 32 bit right shift by modeling an ULTRA
// as a low dword followed by a high dword.  We just pick up the high dword instead
// of shifting.

#ifndef BIGENDIAN
#define HIDWORD(x)      (DWORD)(*(((DWORD *)&x)+1))
#else
#define HIDWORD(x)      (DWORD)(*(((DWORD *)&x)))
#endif

// Sub(A, B, C, N)
// A = B - C
// All operands are N DWORDS long.

DWORD Sub(LPDWORD A, LPDWORD B, LPDWORD C, DWORD N);

// Add(A, B, C, N)
// A = B + C
// All operands are N DWORDS long.

DWORD Add(LPDWORD A, LPDWORD B, LPDWORD C, DWORD N);

// BaseMult(A, B, C, N)
// A = B * C
// returns A[N]
// All operands are N DWORDS long.

DWORD BaseMult(LPDWORD A, DWORD B, LPDWORD C, DWORD N);

// Accumulate(A, B, C, N)
// A = A + B * C
// returns A[N]
// All operands are N DWORDS long.

DWORD Accumulate(LPDWORD A, DWORD B, LPDWORD C, DWORD N);

// Reduce(A, B, C, N)
// A = A - C * B
// returns -A[N]
// All operands are N DWORDS long.

DWORD Reduce(LPDWORD A, DWORD B, LPDWORD C, DWORD N);

// square the digits in B, and add them to A

void AccumulateSquares(LPDWORD A, LPDWORD B, DWORD blen);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\rsa_math.h ===
/* rsa_math.h
 *
 *	Headers for math routines related to RSA.
 *
 *  Except for Mod(), output parameters are listed first
 */

// void Decrement(LPDWORD A, DWORD N)
// Decrement the value A of length N.
void Decrement(LPDWORD A, DWORD N);

// BOOL Increment(LPDWORD A, DWORD N)
// Increment the value A of length N.
BOOL Increment(LPDWORD A, DWORD N);

// void SetValDWORD(LPDWORD num DWORD val, WORD len)
// Set the value of num to val.
void SetValDWORD(LPDWORD num, DWORD val, DWORD len);

// void TwoPower(LPDWORD A, DWORD V, DWORD N)
// Set A to 2^^V
void TwoPower(LPDWORD A, DWORD V, DWORD N);

// DWORD DigitLen(LPDWORD A, DWORD N)
// Return the number of non-zero words in A.
// N is number of total words in A.
DWORD DigitLen(LPDWORD A, DWORD N);

// DWORD BitLen(LPDWORD A, DWORD N)
// Return the bit length of A.
// N is the number of total words in A.
DWORD BitLen(LPDWORD A, DWORD N);

// void MultiplyLow(A, B, C, N)
// A = lower half of B * C.
void MultiplyLow(LPDWORD A, LPDWORD B, LPDWORD C, DWORD N);

// int Compare(A, B, N)
// Return 1 if A > B
// Return 0 if A = B
// Return -1 if A < B
int Compare(LPDWORD A, LPDWORD B, DWORD N);

// Multiply(A, B, C, N)
// A = B * C
// B and C are N DWORDS long
// A is 2N DWORDS long
void Multiply(LPDWORD A, LPDWORD B, LPDWORD C, DWORD N);

// Square(A, B, N)
// A = B * B
// B is N DWORDS long
// A is 2N DWORDS long

void Square(LPDWORD A, LPDWORD B, DWORD N);

// Mod(A, B, R, T, N)
// R = A mod B
// T = allocated length of A
// N = allocated length of B
BOOL Mod(LPDWORD A, LPDWORD B, LPDWORD R, DWORD T, DWORD N);

// ModSquare(A, B, D, N)
// A = B ^ 2 mod D
// N = len B
BOOL ModSquare(LPDWORD A, LPDWORD B, LPDWORD D, DWORD N);

// ModMultiply(A, B, C, D, N)
// A = B * C mod D
// N = len B, C, D
BOOL ModMultiply(LPDWORD A, LPDWORD B, LPDWORD C, LPDWORD D, DWORD N);

// Divide(qi, ri, uu, vv, N)
// qi = uu / vv
// ri = uu mod vv
// N = len uu, vv
BOOL Divide(LPDWORD qi,LPDWORD ri, LPDWORD uu, LPDWORD vv, DWORD ll, DWORD kk);

// GCD
// extended euclid GCD.
// N = length of params
BOOL GCD(LPDWORD u3, LPDWORD u1, LPDWORD u2, LPDWORD u, LPDWORD v, DWORD k);

// ModExp
// A = B ^ C mod D
// N = len of params
BOOL ModExp(LPDWORD A, LPDWORD B, LPDWORD C, LPDWORD D, DWORD len);

// ModRoot(M, C, PP, QQ, DP, DQ, CR)
// CRT ModExp.
BOOL ModRoot(LPDWORD M, LPDWORD C, LPDWORD PP, LPDWORD QQ, LPDWORD DP, LPDWORD DQ, LPDWORD CR, DWORD PSize) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\tripldes.h ===
#ifndef __TRIPLDES_H__
#define __TRIPLDES_H__

#ifndef RSA32API
#define RSA32API __stdcall
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _DES3TABLE {
    DESTable    keytab1;
    DESTable    keytab2;
    DESTable    keytab3;
} DES3TABLE, *PDES3TABLE;

#define DES3_TABLESIZE  sizeof(DES3TABLE)
#define DES2_KEYSIZE    16
#define DES3_KEYSIZE    24

//   tripledes2key:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 2 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API tripledes2key(PDES3TABLE pDES3Table, BYTE *pbKey);

//   tripledes3key:
//
//   Fill in the DES3Table structs with the decrypt and encrypt
//   key expansions.
//
//   Assumes that the second parameter points to 3 * DES_BLOCKLEN
//   bytes of key.
//
//

void RSA32API tripledes3key(PDES3TABLE pDES3Table, BYTE *pbKey);

//
//   Encrypt or decrypt with the key in pKey (DES3Table)
//

void RSA32API tripledes(BYTE *pbOut, BYTE *pbIn, void *pKey, int op);

extern int Asmversion;  /* 1 if we're linked with an asm version, 0 if C */

#ifdef __cplusplus
}
#endif

#endif // __TRIPLDES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\uint4.h ===
/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _UINT4_H_
#define _UINT4_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

/* Encodes x (DWORD) into block (unsigned char), most significant
     byte first.
 */
void DWORDToBigEndian (
    unsigned char *block,
    DWORD *x,
    unsigned int digits     // number of DWORDs
    );

/* Decodes block (unsigned char) into x (DWORD), most significant
     byte first.
 */
void DWORDFromBigEndian (
    DWORD *x,
    unsigned int digits,    // number of DWORDs
    unsigned char *block
    );

/* Encodes input (DWORD) into output (unsigned char), least significant
     byte first.  Assumes len is a multiple of 4.
 */
void DWORDToLittleEndian (
    unsigned char *output,
    const DWORD *input,
    unsigned int len
    );

void DWORDFromLittleEndian (
    DWORD *output,
    const unsigned char *input,
    unsigned int len
    );


#ifdef __cplusplus
}
#endif

#endif // _UINT4_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\swincryp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       wincrypt.h
//
//  Contents:   Cryptographic API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __SWINCRYP_H__
#define __SWINCRYP_H__

#ifdef __cplusplus
extern "C" {
#endif


BOOL
WINAPI
SCryptAcquireContextA(
    HCRYPTPROV *phProv,
    LPCSTR pszContainer,
    LPCSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);
BOOL
WINAPI
SCryptAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR pszContainer,
    LPCWSTR pszProvider,
    DWORD dwProvType,
    DWORD dwFlags);
#ifdef UNICODE
#define SCryptAcquireContext  SCryptAcquireContextW
#else
#define SCryptAcquireContext  SCryptAcquireContextA
#endif // !UNICODE


BOOL
WINAPI
SCryptReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags);


BOOL
WINAPI
SCryptGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

BOOL
WINAPI
SCryptDuplicateKey(
    HCRYPTKEY hKey,
    DWORD *pdwReserved,
    DWORD dwFlags,
    HCRYPTKEY * phKey);

BOOL
WINAPI
SCryptDeriveKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTHASH hBaseData,
    DWORD dwFlags,
    HCRYPTKEY *phKey);


BOOL
WINAPI
SCryptDestroyKey(
    HCRYPTKEY hKey);

BOOL
WINAPI
SCryptSetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGetKeyParam(
    HCRYPTKEY hKey,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

BOOL
WINAPI
SCryptSetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

BOOL
WINAPI
SCryptSetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGetProvParam(
    HCRYPTPROV hProv,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGenRandom(
    HCRYPTPROV hProv,
    DWORD dwLen,
    BYTE *pbBuffer);

BOOL
WINAPI
SCryptGetUserKey(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    HCRYPTKEY *phUserKey);

BOOL
WINAPI
SCryptExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

BOOL
WINAPI
SCryptImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

BOOL
WINAPI
SCryptEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen);

BOOL
WINAPI
SCryptDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

BOOL
WINAPI
SCryptCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash);

BOOL
WINAPI
SCryptDuplicateHash(
    HCRYPTHASH hHash,
    DWORD *pdwReserved,
    DWORD dwFlags,
    HCRYPTHASH * phHash);

BOOL
WINAPI
SCryptHashData(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags);

BOOL
WINAPI
SCryptHashSessionKey(
    HCRYPTHASH hHash,
    HCRYPTKEY hKey,
    DWORD dwFlags);

BOOL
WINAPI
SCryptGetHashValue(
    HCRYPTHASH hHash,
    DWORD dwFlags,
    BYTE *pbHash,
    DWORD *pdwHashLen);

BOOL
WINAPI
SCryptDestroyHash(
    HCRYPTHASH hHash);

BOOL
WINAPI
SCryptSignHashA(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

BOOL
WINAPI
SCryptSignHashW(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR sDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen);

#ifdef UNICODE
#define SCryptSignHash  SCryptSignHashW
#else
#define SCryptSignHash  SCryptSignHashA
#endif // !UNICODE

BOOL
WINAPI
SCryptVerifySignatureA(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCSTR sDescription,
    DWORD dwFlags);

BOOL
WINAPI
SCryptVerifySignatureW(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR sDescription,
    DWORD dwFlags);

#ifdef UNICODE
#define SCryptVerifySignature  SCryptVerifySignatureW
#else
#define SCryptVerifySignature  SCryptVerifySignatureA
#endif // !UNICODE

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // __SWINCRYP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\crypto\wintrustp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       wintrustP.h
//
//  Contents:   Microsoft Internet Security Trust PRIVATE INCLUDE
//
//  History:    20-Nov-1997 pberkman   created
//
//--------------------------------------------------------------------------

#ifndef WINTRUSTP_H
#define WINTRUSTP_H

#include    <wincrypt.h>

#ifdef __cplusplus
extern "C" 
{
#endif

#pragma pack(8)

typedef struct WINTRUST_PBCB_INFO_
{
    DWORD                       cbStruct;

    LPCWSTR                     pcwszFileName;
    HANDLE                      hFile;

    DWORD                       cbContent;
    BYTE                        *pbContent;

    struct WINTRUST_ADV_INFO_   *psAdvanced;    // optional

} WINTRUST_PBCB_INFO, *PWINTRUST_PBCB_INFO;

typedef struct WINTRUST_ADV_INFO_
{
    DWORD           cbStruct;

    DWORD           dwStoreFlags;
#                       define      WTCI_DONT_OPEN_STORES   0x00000001  // only open dummy "root" all other are in pahStores.
#                       define      WTCI_OPEN_ONLY_ROOT     0x00000002

    DWORD           chStores;       // number of stores in pahStores
    HCERTSTORE      *pahStores;     // array of stores to add to internal list

    GUID            *pgSubject;     // Optional: SIP to load

} WINTRUST_ADV_INFO, *PWINTRUST_ADV_INFO;

#pragma pack()

//////////////////////////////////////////////////////////////////////////////
//
// WinVerifyTrustEx
//----------------------------------------------------------------------------
//      *** DO NOT USE ***
//
//
extern HRESULT WINAPI WinVerifyTrustEx(HWND hwnd, GUID *pgActionID, 
                                       WINTRUST_DATA *pWinTrustData);

//////////////////////////////////////////////////////////////////////////////
//
// TrustFindIssuerCertificate
//----------------------------------------------------------------------------
//
//  Usage:
//
//  Returns:
//
//  Last Errors:
//
//  Comments:
//      the dwFlags parameter is reserved for future use and MUST be set 
//      to NULL.
//
extern PCCERT_CONTEXT WINAPI TrustFindIssuerCertificate(IN PCCERT_CONTEXT pChildContext,
                                                        IN DWORD dwEncoding,
                                                        IN DWORD chStores,
                                                        IN HCERTSTORE  *pahStores,
                                                        IN FILETIME *psftVerifyAsOf,
                                                        OUT OPTIONAL DWORD *pdwConfidence,
                                                        OUT OPTIONAL DWORD *pdwError,
                                                        IN DWORD dwFlags);

//////////////////////////////////////////////////////////////////////////////
//
// TrustOpenStores
//----------------------------------------------------------------------------
//
//  Usage:
//
//  Returns:
//
//  Last Errors:
//
//  Comments:
//      the dwFlags parameter is reserved for future use and MUST be set 
//      to NULL.
//
extern BOOL WINAPI TrustOpenStores(IN HCRYPTPROV hProv,
                                   IN OUT DWORD *chStores,
                                   IN OUT OPTIONAL HCERTSTORE *pahStores,
                                   IN DWORD dwFlags);


//////////////////////////////////////////////////////////////////////////////
//
// TrustIsCertificateSelfSigned
//----------------------------------------------------------------------------
//
//  Usage:
//
//  Returns:
//
//  Last Errors:
//
//  Comments:
//      the dwFlags parameter is reserved for future use and MUST be set 
//      to NULL.
//
extern BOOL WINAPI TrustIsCertificateSelfSigned(IN PCCERT_CONTEXT pContext,
                                                IN DWORD dwEncoding, 
                                                IN DWORD dwFlags);

//////////////////////////////////////////////////////////////////////////////
//
// Exported "helper" functions
//----------------------------------------------------------------------------
//  

extern BOOL WINAPI WTHelperOpenKnownStores(CRYPT_PROVIDER_DATA *pProvData);

#define     WTH_ALLOC                       0x00000001
#define     WTH_FREE                        0x00000002
extern BOOL WINAPI                      WTHelperGetKnownUsages(DWORD fdwAction, 
                                                               PCCRYPT_OID_INFO **ppOidInfo);

extern HANDLE WINAPI                    WTHelperGetFileHandle(WINTRUST_DATA *pWintrustData);
extern WCHAR * WINAPI                   WTHelperGetFileName(WINTRUST_DATA *pWintrustData);
extern BOOL WINAPI                      WTHelperCertIsSelfSignedEx(DWORD dwEncoding, PCCERT_CONTEXT pContext);
extern BOOL WINAPI                      WTHelperOpenKnownStores(CRYPT_PROVIDER_DATA *pProvData);
extern BOOL WINAPI                      WTHelperCheckCertUsage(PCCERT_CONTEXT pCertContext, 
                                                               LPCSTR pszRequestedUsageOID);
extern BOOL WINAPI                      WTHelperIsInRootStore(CRYPT_PROVIDER_DATA *pProvData, 
                                                              PCCERT_CONTEXT pCertContext);
extern BOOL WINAPI                      WTHelperGetAgencyInfo(PCCERT_CONTEXT pCert, 
                                                              DWORD *pcbAgencyInfo, 
                                                              struct _SPC_SP_AGENCY_INFO *psAgencyInfo);


#define WVT_MODID_WINTRUST              0x00000001
#define WVT_MODID_SOFTPUB               0x00010000
#define WVT_MODID_MSSIP                 0x00001000
extern BOOL WINAPI TrustDecode(DWORD dwModuleId, BYTE **ppbRet, DWORD *pcbRet, DWORD cbHint,
                               DWORD dwEncoding, const char *pcszOID, const BYTE *pbEncoded, DWORD cbEncoded,
                               DWORD dwDecodeFlags);
extern BOOL WINAPI TrustFreeDecode(DWORD dwModuleId, BYTE **pbAllocated);


// Returns ERROR_SUCCESS and the hash if the file was signed and contains a
// valid hash
extern LONG WINAPI WTHelperGetFileHash(
    IN LPCWSTR pwszFilename,
    IN DWORD dwFlags,
    IN OUT OPTIONAL PVOID *pvReserved,
    OUT OPTIONAL BYTE *pbFileHash,
    IN OUT OPTIONAL DWORD *pcbFileHash,
    OUT OPTIONAL ALG_ID *pHashAlgid
    );

// Open the cert manager UI dialog's TrustedPublisher Tab.
//
// The following flags may be set:
//   WT_TRUSTDBDIALOG_NO_UI_FLAG
//      Set this flag in conjunction with
//      WT_TRUSTDBDIALOG_WRITE_LEGACY_REG_FLAG and/or
//      WT_TRUSTDBDIALOG_WRITE_IEAK_STORE_FLAG to do the registry and/or
//      store write without any UI.
//   WT_TRUSTDBDIALOG_ONLY_PUB_TAB_FLAG
//      By default all of the UI tabs are displayed with TrustedPublisher
//      as the initial tab. Setting this flag only displays the
//      TrustedPublisher tab.
//   WT_TRUSTDBDIALOG_WRITE_LEGACY_REG_FLAG
//      Setting this flag causes the trusted publishers to be written to the
//      following legacy registry location:
//          "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\
//              WinTrust\Trust Providers\Software Publishing\Trust Database\0"
//      The registry value names are constructed as ascii generated
//      representations of the md5 hash of the issuer name and the cert's serial
//      number. The string value is the subject display name.
//
//      Note, the above registry key is initially deleted to force the removal
//      of any previous publisher values.
//   WT_TRUSTDBDIALOG_WRITE_IEAK_STORE_FLAG
//      Setting this flag causes all of the trusted publishers to be copied to
//      the "TrustedPublisher_IEAK" system registry store at the following
//      location:
//          "HKEY_CURRENT_USER\Software\Microsoft\SystemCertificates\
//              TrustedPublisher_IEAK\Certificates\..."
//      Note, the logical HKCU TrustedPublisher store inherits from HKLM and
//      GroupPolicy. The TrustedPublisher_IEAK will contain the entire set
//      under a single registry subkey.
//
//      Note, initially all certs are removed from the above store.
//          
extern BOOL WINAPI OpenPersonalTrustDBDialogEx(
    IN OPTIONAL HWND hwndParent,
    IN DWORD dwFlags,
    IN OUT OPTIONAL PVOID *pvReserved
    );

#define WT_TRUSTDBDIALOG_NO_UI_FLAG             0x00000001
#define WT_TRUSTDBDIALOG_ONLY_PUB_TAB_FLAG      0x00000002
#define WT_TRUSTDBDIALOG_WRITE_LEGACY_REG_FLAG  0x00000100
#define WT_TRUSTDBDIALOG_WRITE_IEAK_STORE_FLAG  0x00000200


// Calls above with dwFlags = 0 and pvReserved = NULL
extern BOOL WINAPI OpenPersonalTrustDBDialog(
    IN OPTIONAL HWND hwndParent
    );


#ifdef __cplusplus
}
#endif

#endif // WINTRUSTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\dfs\import.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    import.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/

#include <windef.h>
#include <lmcons.h>

#ifdef MIDL_PASS
#define LPWSTR [string] LPWSTR
#endif

#include <lmdfs.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\dfs\netdfs.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for netdfs.idl, dfscli.acf:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __netdfs_h__
#define __netdfs_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "import.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __netdfs_INTERFACE_DEFINED__
#define __netdfs_INTERFACE_DEFINED__

/* interface netdfs */
/* [implicit_handle][unique][ms_union][version][uuid] */ 

#pragma once
typedef struct _DFS_INFO_1_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ LPDFS_INFO_1 Buffer;
    } 	DFS_INFO_1_CONTAINER;

typedef struct _DFS_INFO_1_CONTAINER *LPDFS_INFO_1_CONTAINER;

typedef struct _DFS_INFO_2_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ LPDFS_INFO_2 Buffer;
    } 	DFS_INFO_2_CONTAINER;

typedef struct _DFS_INFO_2_CONTAINER *LPDFS_INFO_2_CONTAINER;

typedef struct _DFS_INFO_3_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ LPDFS_INFO_3 Buffer;
    } 	DFS_INFO_3_CONTAINER;

typedef struct _DFS_INFO_3_CONTAINER *LPDFS_INFO_3_CONTAINER;

typedef struct _DFS_INFO_4_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ LPDFS_INFO_4 Buffer;
    } 	DFS_INFO_4_CONTAINER;

typedef struct _DFS_INFO_4_CONTAINER *LPDFS_INFO_4_CONTAINER;

typedef struct _DFS_INFO_200_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ LPDFS_INFO_200 Buffer;
    } 	DFS_INFO_200_CONTAINER;

typedef struct _DFS_INFO_200_CONTAINER *LPDFS_INFO_200_CONTAINER;

typedef struct _DFS_INFO_300_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ LPDFS_INFO_300 Buffer;
    } 	DFS_INFO_300_CONTAINER;

typedef struct _DFS_INFO_300_CONTAINER *LPDFS_INFO_300_CONTAINER;

typedef struct _DFS_INFO_ENUM_STRUCT
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPDFS_INFO_1_CONTAINER DfsInfo1Container;
        /* [case()] */ LPDFS_INFO_2_CONTAINER DfsInfo2Container;
        /* [case()] */ LPDFS_INFO_3_CONTAINER DfsInfo3Container;
        /* [case()] */ LPDFS_INFO_4_CONTAINER DfsInfo4Container;
        /* [case()] */ LPDFS_INFO_200_CONTAINER DfsInfo200Container;
        /* [case()] */ LPDFS_INFO_300_CONTAINER DfsInfo300Container;
        } 	DfsInfoContainer;
    } 	DFS_INFO_ENUM_STRUCT;

typedef struct _DFS_INFO_ENUM_STRUCT *LPDFS_INFO_ENUM_STRUCT;

typedef /* [switch_type] */ union _DFS_INFO_STRUCT
    {
    /* [case()] */ LPDFS_INFO_1 DfsInfo1;
    /* [case()] */ LPDFS_INFO_2 DfsInfo2;
    /* [case()] */ LPDFS_INFO_3 DfsInfo3;
    /* [case()] */ LPDFS_INFO_4 DfsInfo4;
    /* [case()] */ LPDFS_INFO_100 DfsInfo100;
    /* [case()] */ LPDFS_INFO_101 DfsInfo101;
    /* [case()] */ LPDFS_INFO_102 DfsInfo102;
    /* [default] */  /* Empty union arm */ 
    } 	DFS_INFO_STRUCT;

typedef /* [switch_type] */ union _DFS_INFO_STRUCT *LPDFS_INFO_STRUCT;

typedef struct _DFSM_ENTRY_ID
    {
    GUID idSubordinate;
    /* [unique][string] */ LPWSTR wszSubordinate;
    } 	DFSM_ENTRY_ID;

typedef struct _DFSM_ENTRY_ID *LPDFSM_ENTRY_ID;

typedef struct _DFSM_RELATION_INFO
    {
    DWORD cSubordinates;
    /* [size_is] */ DFSM_ENTRY_ID eid[ 1 ];
    } 	DFSM_RELATION_INFO;

typedef /* [allocate] */ struct _DFSM_RELATION_INFO *LPDFSM_RELATION_INFO;

typedef struct _DFSM_ROOT_LIST_ENTRY
    {
    /* [unique][string] */ LPWSTR ServerShare;
    } 	DFSM_ROOT_LIST_ENTRY;

typedef struct _DFSM_ROOT_LIST_ENTRY *PDFSM_ROOT_LIST_ENTRY;

typedef struct _DFSM_ROOT_LIST_ENTRY *LPDFSM_ROOT_LIST_ENTRY;

typedef struct _DFSM_ROOT_LIST
    {
    DWORD cEntries;
    /* [size_is] */ DFSM_ROOT_LIST_ENTRY Entry[ 1 ];
    } 	DFSM_ROOT_LIST;

typedef struct _DFSM_ROOT_LIST *PDFSM_ROOT_LIST;

typedef /* [allocate] */ struct _DFSM_ROOT_LIST *LPDFSM_ROOT_LIST;

DWORD NetrDfsManagerGetVersion( void);

DWORD NetrDfsAdd( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [string][in] */ LPWSTR ServerName,
    /* [string][unique][in] */ LPWSTR ShareName,
    /* [string][unique][in] */ LPWSTR Comment,
    /* [in] */ DWORD Flags);

DWORD NetrDfsRemove( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [string][unique][in] */ LPWSTR ServerName,
    /* [string][unique][in] */ LPWSTR ShareName);

DWORD NetrDfsSetInfo( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [string][unique][in] */ LPWSTR ServerName,
    /* [string][unique][in] */ LPWSTR ShareName,
    /* [in] */ DWORD Level,
    /* [switch_is][in] */ LPDFS_INFO_STRUCT DfsInfo);

DWORD NetrDfsGetInfo( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [string][unique][in] */ LPWSTR ServerName,
    /* [string][unique][in] */ LPWSTR ShareName,
    /* [in] */ DWORD Level,
    /* [switch_is][out] */ LPDFS_INFO_STRUCT DfsInfo);

DWORD NetrDfsEnum( 
    /* [in] */ DWORD Level,
    /* [in] */ DWORD PrefMaxLen,
    /* [unique][out][in] */ LPDFS_INFO_ENUM_STRUCT DfsEnum,
    /* [unique][out][in] */ LPDWORD ResumeHandle);

DWORD NetrDfsMove( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [string][in] */ LPWSTR NewDfsEntryPath);

DWORD NetrDfsRename( 
    /* [string][in] */ LPWSTR Path,
    /* [string][in] */ LPWSTR NewPath);

DWORD NetrDfsManagerGetConfigInfo( 
    /* [string][in] */ LPWSTR wszServer,
    /* [string][in] */ LPWSTR wszLocalVolumeEntryPath,
    /* [in] */ GUID idLocalVolume,
    /* [unique][out][in] */ LPDFSM_RELATION_INFO *ppRelationInfo);

DWORD NetrDfsManagerSendSiteInfo( 
    /* [string][in] */ LPWSTR wszServer,
    /* [in] */ LPDFS_SITELIST_INFO pSiteInfo);

DWORD NetrDfsAddFtRoot( 
    /* [string][in] */ LPWSTR ServerName,
    /* [string][in] */ LPWSTR DcName,
    /* [string][in] */ LPWSTR RootShare,
    /* [string][in] */ LPWSTR FtDfsName,
    /* [string][in] */ LPWSTR Comment,
    /* [string][in] */ LPWSTR ConfigDN,
    /* [in] */ BOOLEAN NewFtDfs,
    /* [in] */ DWORD Flags,
    /* [unique][out][in] */ PDFSM_ROOT_LIST *ppRootList);

DWORD NetrDfsRemoveFtRoot( 
    /* [string][in] */ LPWSTR ServerName,
    /* [string][in] */ LPWSTR DcName,
    /* [string][in] */ LPWSTR RootShare,
    /* [string][in] */ LPWSTR FtDfsName,
    /* [in] */ DWORD Flags,
    /* [unique][out][in] */ PDFSM_ROOT_LIST *ppRootList);

DWORD NetrDfsAddStdRoot( 
    /* [string][in] */ LPWSTR ServerName,
    /* [string][in] */ LPWSTR RootShare,
    /* [string][in] */ LPWSTR Comment,
    /* [in] */ DWORD Flags);

DWORD NetrDfsRemoveStdRoot( 
    /* [string][in] */ LPWSTR ServerName,
    /* [string][in] */ LPWSTR RootShare,
    /* [in] */ DWORD Flags);

DWORD NetrDfsManagerInitialize( 
    /* [string][in] */ LPWSTR ServerName,
    /* [in] */ DWORD Flags);

DWORD NetrDfsAddStdRootForced( 
    /* [string][in] */ LPWSTR ServerName,
    /* [string][in] */ LPWSTR RootShare,
    /* [string][in] */ LPWSTR Comment,
    /* [string][in] */ LPWSTR Share);

DWORD NetrDfsGetDcAddress( 
    /* [string][in] */ LPWSTR ServerName,
    /* [string][out][in] */ LPWSTR *DcName,
    /* [out][in] */ BOOLEAN *IsRoot,
    /* [out][in] */ ULONG *Timeout);

DWORD NetrDfsSetDcAddress( 
    /* [string][in] */ LPWSTR ServerName,
    /* [string][in] */ LPWSTR DcName,
    /* [in] */ DWORD Timeout,
    /* [in] */ DWORD Flags);

DWORD NetrDfsFlushFtTable( 
    /* [string][in] */ LPWSTR DcName,
    /* [string][in] */ LPWSTR wszFtDfsName);

DWORD NetrDfsAdd2( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [string][in] */ LPWSTR DcName,
    /* [string][in] */ LPWSTR ServerName,
    /* [string][unique][in] */ LPWSTR ShareName,
    /* [string][unique][in] */ LPWSTR Comment,
    /* [in] */ DWORD Flags,
    /* [unique][out][in] */ PDFSM_ROOT_LIST *ppRootList);

DWORD NetrDfsRemove2( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [string][in] */ LPWSTR DcName,
    /* [string][unique][in] */ LPWSTR ServerName,
    /* [string][unique][in] */ LPWSTR ShareName,
    /* [unique][out][in] */ PDFSM_ROOT_LIST *ppRootList);

DWORD NetrDfsEnumEx( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [in] */ DWORD Level,
    /* [in] */ DWORD PrefMaxLen,
    /* [unique][out][in] */ LPDFS_INFO_ENUM_STRUCT DfsEnum,
    /* [unique][out][in] */ LPDWORD ResumeHandle);

DWORD NetrDfsSetInfo2( 
    /* [string][in] */ LPWSTR DfsEntryPath,
    /* [string][in] */ LPWSTR DcName,
    /* [string][unique][in] */ LPWSTR ServerName,
    /* [string][unique][in] */ LPWSTR ShareName,
    /* [in] */ DWORD Level,
    /* [switch_is][in] */ LPDFS_INFO_STRUCT pDfsInfo,
    /* [unique][out][in] */ PDFSM_ROOT_LIST *ppRootList);


extern handle_t netdfs_bhandle;


extern RPC_IF_HANDLE netdfs_ClientIfHandle;
extern RPC_IF_HANDLE netdfs_ServerIfHandle;
#endif /* __netdfs_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\enduser\inc\cdm.h ===
//=======================================================================
//
//  Copyright (c) 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   cdm.h
//
//  Description:
//
//    Public header file for the IU (V4) Code Download Manager (CDM.DLL).
//
//=======================================================================

#ifndef _INC_CDM
#define _INC_CDM

#if defined(__cplusplus)
extern "C" {
#endif

//
// Define API decoration for direct importing of DLL references.
//
#if !defined(_CDM_)
#define CDMAPI DECLSPEC_IMPORT
#else
#define CDMAPI
#endif

//
// HWID_LEN must remain 2048 for backwards CDM compatibility, however note that the maximum
// length for a hardware ID is defined in //depot/Lab04_N/Root/Public/sdk/inc/cfgmgr32.h
// as #define MAX_DEVICE_ID_LEN     200
//
#define HWID_LEN						2048
#ifndef LINE_LEN
	#define LINE_LEN                    256 // Win95-compatible maximum for displayable
											// strings coming from a device INF.
#endif                                        

//Win 98 DOWNLOADINFO
typedef struct _DOWNLOADINFOWIN98
{
	DWORD		dwDownloadInfoSize;	//size of this structure
	LPTSTR		lpHardwareIDs;		//multi_sz list of Hardware PnP IDs
	LPTSTR		lpCompatIDs;		//multi_sz list of compatible IDs
	LPTSTR		lpFile;				//File name (string)
	OSVERSIONINFO	OSVersionInfo;	//OSVERSIONINFO from GetVersionEx()
	DWORD		dwFlags;			//Flags
	DWORD		dwClientID;			//Client ID
} DOWNLOADINFOWIN98, *PDOWNLOADINFOWIN98;

typedef struct _DOWNLOADINFO {
    DWORD          dwDownloadInfoSize;    // size of this structure
    LPCWSTR        lpHardwareIDs;         // multi_sz list of Hardware PnP IDs
    LPCWSTR        lpDeviceInstanceID;    // Device Instance ID
    LPCWSTR        lpFile;                // File name (string)
    OSVERSIONINFOW OSVersionInfo;         // OSVERSIONINFO from GetVersionEx()
    DWORD          dwArchitecture;        // Specifies the system's processor architecture.
                                          //This value can be one of the following values: 
                                          //PROCESSOR_ARCHITECTURE_INTEL
                                          //Windows NT only: PROCESSOR_ARCHITECTURE_MIPS
                                          //Windows NT only: PROCESSOR_ARCHITECTURE_ALPHA
                                          //Windows NT only: PROCESSOR_ARCHITECTURE_PPC
                                          //Windows NT only: PROCESSOR_ARCHITECTURE_UNKNOWN 
    DWORD          dwFlags;               // Flags
    DWORD          dwClientID;            // Client ID
    LCID           localid;               // local id
} DOWNLOADINFO, *PDOWNLOADINFO;


typedef struct _WUDRIVERINFO
{
    DWORD dwStructSize;					// size of this structure
	WCHAR wszHardwareID[HWID_LEN];		// ID being used to match
	WCHAR wszDescription[LINE_LEN];		// from INF	
	WCHAR wszMfgName[LINE_LEN];			// from INF
	WCHAR wszProviderName[LINE_LEN];	// INF provider
	WCHAR wszDriverVer[LINE_LEN];		// from INF
} WUDRIVERINFO, *PWUDRIVERINFO;

typedef void (*PFN_QueryDetectionFilesCallback)(void* pCallbackParam, LPCWSTR pszURL, LPCWSTR pszLocalFile);

//
// CDM exported function declarations
//

CDMAPI
VOID
WINAPI
CloseCDMContext(
    IN HANDLE hConnection
    );

CDMAPI
void
WINAPI
DetFilesDownloaded(
    IN  HANDLE			hConnection
	);
//
// IMPORTANT:	DownloadGetUpdatedFiles is only exported from the IU CDM.DLL stub.
//				It is NOT present in the Whistler version of the "Classic" V3 control.
//
CDMAPI
BOOL
DownloadGetUpdatedFiles(
	IN PDOWNLOADINFOWIN98	pDownloadInfoWin98,
	IN OUT LPTSTR			lpDownloadPath,
	IN UINT					uSize
);

CDMAPI
BOOL
WINAPI
DownloadIsInternetAvailable(
	void
	);

CDMAPI
BOOL
WINAPI
DownloadUpdatedFiles(
    IN  HANDLE        hConnection, 
    IN  HWND          hwnd,  
    IN  PDOWNLOADINFO pDownloadInfo, 
    OUT LPWSTR        lpDownloadPath, 
    IN  UINT          uSize, 
    OUT PUINT         puRequiredSize
    );

CDMAPI
BOOL
WINAPI
FindMatchingDriver(
    IN  HANDLE			hConnection, 
	IN  PDOWNLOADINFO	pDownloadInfo,
	OUT PWUDRIVERINFO	pWuDriverInfo
	);

CDMAPI
void
WINAPI
LogDriverNotFound(
    IN HANDLE	hConnection, 
	IN LPCWSTR  lpDeviceInstanceID,
	IN DWORD	dwFlags
	);

CDMAPI
HANDLE
WINAPI
OpenCDMContext(
    IN HWND hwnd
    );

CDMAPI
HANDLE
WINAPI
OpenCDMContextEx(
    IN BOOL fConnectIfNotConnected
    );

CDMAPI
int
WINAPI
QueryDetectionFiles(
    IN  HANDLE							hConnection, 
	IN	void*							pCallbackParam, 
	IN	PFN_QueryDetectionFilesCallback	pCallback
	);

//
// 502965 Windows Error Reporting bucket 2096553: Hang following NEWDEV.DLL!CancelDriverSearch
//
CDMAPI
HRESULT
WINAPI
CancelCDMOperation(
	void
);



//
// CDM prototypes
//

typedef VOID (WINAPI *CLOSE_CDM_CONTEXT_PROC)(
    IN HANDLE hConnection
    );

typedef void (WINAPI *DET_FILES_DOWNLOADED_PROC)(
    IN  HANDLE hConnection 
    );

typedef BOOL (WINAPI *DOWNLOAD_GET_UPDATED_FILES)(
	IN PDOWNLOADINFOWIN98	pDownloadInfoWin98,
	IN OUT LPTSTR			lpDownloadPath,
	IN UINT					uSize
);

typedef BOOL (WINAPI *CDM_INTERNET_AVAILABLE_PROC)(
    void
    );

typedef BOOL (WINAPI *DOWNLOAD_UPDATED_FILES_PROC)(
    IN HANDLE hConnection,
    IN HWND hwnd,
    IN PDOWNLOADINFO pDownloadInfo,
    OUT LPWSTR lpDownloadPath,
    IN UINT uSize,
    OUT PUINT puRequiredSize
    );

typedef BOOL (WINAPI *FIND_MATCHING_DRIVER_PROC)(
    IN  HANDLE hConnection,
	IN  PDOWNLOADINFO pDownloadInfo,
	OUT PWUDRIVERINFO pWuDriverInfo
    );

typedef void (WINAPI *LOG_DRIVER_NOT_FOUND_PROC)(
    IN HANDLE	hConnection, 
	IN LPCWSTR  lpDeviceInstanceID,
	IN DWORD	dwFlags
    );

typedef HANDLE (WINAPI *OPEN_CDM_CONTEXT_PROC)(
    IN  HWND   hwnd
    );

typedef HANDLE (WINAPI *OPEN_CDM_CONTEXT_EX_PROC)(
    IN BOOL fConnectIfNotConnected
    );

typedef int (WINAPI *QUERY_DETECTION_FILES_PROC)(
    IN  HANDLE hConnection, 
	IN	void* pCallbackParam, 
	IN	PFN_QueryDetectionFilesCallback	pCallback
    );

typedef HRESULT (WINAPI *CANCEL_CDM_OPERATION_PROC)(
    void
    );


//
// The following defines and structures are private internal interfaces so 
// they are in cdm.h and not in setupapi.h
//
#define DIF_GETWINDOWSUPDATEINFO            0x00000025

#define DI_FLAGSEX_SHOWWINDOWSUPDATE        0x00400000L

	
//For dwFlags parameter of LogDriverNotFound(...) 
//used with bitwising
#define BEGINLOGFLAG 0x00000002	//if 1, batch logging ends, flushing internal hardware id list to file


//
// Structure corresponding to a DIF_GETWINDOWSUPDATEINFO install function.
//
typedef struct _SP_WINDOWSUPDATE_PARAMS_A {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    CHAR                   PackageId[MAX_PATH];
    HANDLE                 CDMContext;
} SP_WINDOWSUPDATE_PARAMS_A, *PSP_WINDOWSUPDATE_PARAMS_A;

typedef struct _SP_WINDOWSUPDATE_PARAMS_W {
    SP_CLASSINSTALL_HEADER ClassInstallHeader;
    WCHAR                  PackageId[MAX_PATH];
    HANDLE                 CDMContext;
} SP_WINDOWSUPDATE_PARAMS_W, *PSP_WINDOWSUPDATE_PARAMS_W;


#ifdef UNICODE
typedef SP_WINDOWSUPDATE_PARAMS_W SP_WINDOWSUPDATE_PARAMS;
typedef PSP_WINDOWSUPDATE_PARAMS_W PSP_WINDOWSUPDATE_PARAMS;
#else
typedef SP_WINDOWSUPDATE_PARAMS_A SP_WINDOWSUPDATE_PARAMS;
typedef PSP_WINDOWSUPDATE_PARAMS_A PSP_WINDOWSUPDATE_PARAMS;
#endif

#if defined(__cplusplus)
}	// end extern "C"
#endif

#endif // _INC_CDM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\ds\inc\dfs\netdfs_s.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for netdfs.idl, dfscli.acf:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#include <string.h>
#include "netdfs.h"

#define TYPE_FORMAT_STRING_SIZE   1017                              
#define PROC_FORMAT_STRING_SIZE   1255                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: netdfs, ver. 3.0,
   GUID={0x4fc742e0,0x4a10,0x11cf,{0x82,0x73,0x00,0xaa,0x00,0x4a,0xe6,0x73}} */


extern const MIDL_SERVER_INFO netdfs_ServerInfo;

extern RPC_DISPATCH_TABLE netdfs_DispatchTable;

static const RPC_SERVER_INTERFACE netdfs___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x4fc742e0,0x4a10,0x11cf,{0x82,0x73,0x00,0xaa,0x00,0x4a,0xe6,0x73}},{3,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &netdfs_DispatchTable,
    0,
    0,
    0,
    &netdfs_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE netdfs_ServerIfHandle = (RPC_IF_HANDLE)& netdfs___RpcServerInterface;

extern const MIDL_STUB_DESC netdfs_StubDesc;


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure NetrDfsManagerGetVersion */

			0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 16 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 24 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 26 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 28 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAdd */

/* 30 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 32 */	NdrFcLong( 0x0 ),	/* 0 */
/* 36 */	NdrFcShort( 0x1 ),	/* 1 */
/* 38 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 40 */	NdrFcShort( 0x8 ),	/* 8 */
/* 42 */	NdrFcShort( 0x8 ),	/* 8 */
/* 44 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 46 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 48 */	NdrFcShort( 0x0 ),	/* 0 */
/* 50 */	NdrFcShort( 0x0 ),	/* 0 */
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 54 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 56 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 58 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 60 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 62 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 64 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ShareName */

/* 66 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 68 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 70 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Comment */

/* 72 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 74 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 76 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Flags */

/* 78 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 80 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 82 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 84 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 86 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 88 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemove */

/* 90 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 92 */	NdrFcLong( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x2 ),	/* 2 */
/* 98 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 100 */	NdrFcShort( 0x0 ),	/* 0 */
/* 102 */	NdrFcShort( 0x8 ),	/* 8 */
/* 104 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 106 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 108 */	NdrFcShort( 0x0 ),	/* 0 */
/* 110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 112 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 114 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 116 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 118 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 120 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 122 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 124 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 126 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 128 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 130 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 132 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 134 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 136 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetInfo */

/* 138 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 140 */	NdrFcLong( 0x0 ),	/* 0 */
/* 144 */	NdrFcShort( 0x3 ),	/* 3 */
/* 146 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 148 */	NdrFcShort( 0x8 ),	/* 8 */
/* 150 */	NdrFcShort( 0x8 ),	/* 8 */
/* 152 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 154 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 156 */	NdrFcShort( 0x0 ),	/* 0 */
/* 158 */	NdrFcShort( 0x3 ),	/* 3 */
/* 160 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 162 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 164 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 166 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 168 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 170 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 172 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 174 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 176 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 178 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 180 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 182 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsInfo */

/* 186 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 188 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 190 */	NdrFcShort( 0xe ),	/* Type Offset=14 */

	/* Return value */

/* 192 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 194 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 196 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsGetInfo */

/* 198 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 200 */	NdrFcLong( 0x0 ),	/* 0 */
/* 204 */	NdrFcShort( 0x4 ),	/* 4 */
/* 206 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 208 */	NdrFcShort( 0x8 ),	/* 8 */
/* 210 */	NdrFcShort( 0x8 ),	/* 8 */
/* 212 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 214 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 216 */	NdrFcShort( 0x3 ),	/* 3 */
/* 218 */	NdrFcShort( 0x0 ),	/* 0 */
/* 220 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 222 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 224 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 226 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 228 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 230 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 232 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 234 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 236 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 238 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 240 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 242 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 244 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsInfo */

/* 246 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 248 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 250 */	NdrFcShort( 0x17c ),	/* Type Offset=380 */

	/* Return value */

/* 252 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 254 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 256 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsEnum */

/* 258 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 260 */	NdrFcLong( 0x0 ),	/* 0 */
/* 264 */	NdrFcShort( 0x5 ),	/* 5 */
/* 266 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 268 */	NdrFcShort( 0x2c ),	/* 44 */
/* 270 */	NdrFcShort( 0x24 ),	/* 36 */
/* 272 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 274 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 276 */	NdrFcShort( 0x9 ),	/* 9 */
/* 278 */	NdrFcShort( 0x9 ),	/* 9 */
/* 280 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter Level */

/* 282 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 284 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 286 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PrefMaxLen */

/* 288 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 290 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 292 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsEnum */

/* 294 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 296 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 298 */	NdrFcShort( 0x186 ),	/* Type Offset=390 */

	/* Parameter ResumeHandle */

/* 300 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 302 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 304 */	NdrFcShort( 0x32a ),	/* Type Offset=810 */

	/* Return value */

/* 306 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 308 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsMove */

/* 312 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 314 */	NdrFcLong( 0x0 ),	/* 0 */
/* 318 */	NdrFcShort( 0x6 ),	/* 6 */
/* 320 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 322 */	NdrFcShort( 0x0 ),	/* 0 */
/* 324 */	NdrFcShort( 0x8 ),	/* 8 */
/* 326 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 328 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 330 */	NdrFcShort( 0x0 ),	/* 0 */
/* 332 */	NdrFcShort( 0x0 ),	/* 0 */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 336 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 338 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 340 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewDfsEntryPath */

/* 342 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 344 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 346 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 348 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 350 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 352 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRename */

/* 354 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 356 */	NdrFcLong( 0x0 ),	/* 0 */
/* 360 */	NdrFcShort( 0x7 ),	/* 7 */
/* 362 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 364 */	NdrFcShort( 0x0 ),	/* 0 */
/* 366 */	NdrFcShort( 0x8 ),	/* 8 */
/* 368 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 370 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 372 */	NdrFcShort( 0x0 ),	/* 0 */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter Path */

/* 378 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 380 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 382 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewPath */

/* 384 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 386 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 388 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 390 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 392 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 394 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerGetConfigInfo */

/* 396 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 398 */	NdrFcLong( 0x0 ),	/* 0 */
/* 402 */	NdrFcShort( 0x8 ),	/* 8 */
/* 404 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 406 */	NdrFcShort( 0x30 ),	/* 48 */
/* 408 */	NdrFcShort( 0x8 ),	/* 8 */
/* 410 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 412 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 414 */	NdrFcShort( 0x1 ),	/* 1 */
/* 416 */	NdrFcShort( 0x1 ),	/* 1 */
/* 418 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter wszServer */

/* 420 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 422 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 424 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter wszLocalVolumeEntryPath */

/* 426 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 428 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 430 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter idLocalVolume */

/* 432 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 434 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 436 */	NdrFcShort( 0x108 ),	/* Type Offset=264 */

	/* Parameter ppRelationInfo */

/* 438 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 440 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 442 */	NdrFcShort( 0x32e ),	/* Type Offset=814 */

	/* Return value */

/* 444 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 446 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 448 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerSendSiteInfo */

/* 450 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 452 */	NdrFcLong( 0x0 ),	/* 0 */
/* 456 */	NdrFcShort( 0x9 ),	/* 9 */
/* 458 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 460 */	NdrFcShort( 0x0 ),	/* 0 */
/* 462 */	NdrFcShort( 0x8 ),	/* 8 */
/* 464 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 466 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 470 */	NdrFcShort( 0x1 ),	/* 1 */
/* 472 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter wszServer */

/* 474 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 476 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 478 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter pSiteInfo */

/* 480 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 482 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 484 */	NdrFcShort( 0x38e ),	/* Type Offset=910 */

	/* Return value */

/* 486 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 488 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddFtRoot */

/* 492 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 494 */	NdrFcLong( 0x0 ),	/* 0 */
/* 498 */	NdrFcShort( 0xa ),	/* 10 */
/* 500 */	NdrFcShort( 0x28 ),	/* x86 Stack size/offset = 40 */
/* 502 */	NdrFcShort( 0xd ),	/* 13 */
/* 504 */	NdrFcShort( 0x8 ),	/* 8 */
/* 506 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xa,		/* 10 */
/* 508 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 510 */	NdrFcShort( 0x1 ),	/* 1 */
/* 512 */	NdrFcShort( 0x1 ),	/* 1 */
/* 514 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 516 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 518 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 520 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 522 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 524 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 526 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 528 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 530 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 532 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter FtDfsName */

/* 534 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 536 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 538 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 540 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 542 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 544 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ConfigDN */

/* 546 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 548 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 550 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewFtDfs */

/* 552 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 554 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 556 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter Flags */

/* 558 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 560 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 562 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 564 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 566 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 568 */	NdrFcShort( 0x3aa ),	/* Type Offset=938 */

	/* Return value */

/* 570 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 572 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
/* 574 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemoveFtRoot */

/* 576 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 578 */	NdrFcLong( 0x0 ),	/* 0 */
/* 582 */	NdrFcShort( 0xb ),	/* 11 */
/* 584 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 586 */	NdrFcShort( 0x8 ),	/* 8 */
/* 588 */	NdrFcShort( 0x8 ),	/* 8 */
/* 590 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 592 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 594 */	NdrFcShort( 0x1 ),	/* 1 */
/* 596 */	NdrFcShort( 0x1 ),	/* 1 */
/* 598 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 600 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 602 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 604 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 606 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 608 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 610 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 612 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 614 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 616 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter FtDfsName */

/* 618 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 620 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 622 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 624 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 626 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 628 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 630 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 632 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 634 */	NdrFcShort( 0x3aa ),	/* Type Offset=938 */

	/* Return value */

/* 636 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 638 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 640 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddStdRoot */

/* 642 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 644 */	NdrFcLong( 0x0 ),	/* 0 */
/* 648 */	NdrFcShort( 0xc ),	/* 12 */
/* 650 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 652 */	NdrFcShort( 0x8 ),	/* 8 */
/* 654 */	NdrFcShort( 0x8 ),	/* 8 */
/* 656 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 658 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 660 */	NdrFcShort( 0x0 ),	/* 0 */
/* 662 */	NdrFcShort( 0x0 ),	/* 0 */
/* 664 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 666 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 668 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 670 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 672 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 674 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 676 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 678 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 680 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 682 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 684 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 686 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 688 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 690 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 692 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 694 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemoveStdRoot */

/* 696 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 698 */	NdrFcLong( 0x0 ),	/* 0 */
/* 702 */	NdrFcShort( 0xd ),	/* 13 */
/* 704 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 706 */	NdrFcShort( 0x8 ),	/* 8 */
/* 708 */	NdrFcShort( 0x8 ),	/* 8 */
/* 710 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 712 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 714 */	NdrFcShort( 0x0 ),	/* 0 */
/* 716 */	NdrFcShort( 0x0 ),	/* 0 */
/* 718 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 720 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 722 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 724 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 726 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 728 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 730 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 732 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 734 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 736 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 738 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 740 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 742 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerInitialize */

/* 744 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 746 */	NdrFcLong( 0x0 ),	/* 0 */
/* 750 */	NdrFcShort( 0xe ),	/* 14 */
/* 752 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 754 */	NdrFcShort( 0x8 ),	/* 8 */
/* 756 */	NdrFcShort( 0x8 ),	/* 8 */
/* 758 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 760 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 762 */	NdrFcShort( 0x0 ),	/* 0 */
/* 764 */	NdrFcShort( 0x0 ),	/* 0 */
/* 766 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 768 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 770 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 772 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 774 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 776 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 778 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 780 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 782 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 784 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddStdRootForced */

/* 786 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 788 */	NdrFcLong( 0x0 ),	/* 0 */
/* 792 */	NdrFcShort( 0xf ),	/* 15 */
/* 794 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 796 */	NdrFcShort( 0x0 ),	/* 0 */
/* 798 */	NdrFcShort( 0x8 ),	/* 8 */
/* 800 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 802 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 804 */	NdrFcShort( 0x0 ),	/* 0 */
/* 806 */	NdrFcShort( 0x0 ),	/* 0 */
/* 808 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 810 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 812 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 814 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 816 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 818 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 820 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 822 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 824 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 826 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Share */

/* 828 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 830 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 832 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 834 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 836 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 838 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsGetDcAddress */

/* 840 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 842 */	NdrFcLong( 0x0 ),	/* 0 */
/* 846 */	NdrFcShort( 0x10 ),	/* 16 */
/* 848 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 850 */	NdrFcShort( 0x35 ),	/* 53 */
/* 852 */	NdrFcShort( 0x3d ),	/* 61 */
/* 854 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 856 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 858 */	NdrFcShort( 0x0 ),	/* 0 */
/* 860 */	NdrFcShort( 0x0 ),	/* 0 */
/* 862 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 864 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 866 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 868 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 870 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 872 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 874 */	NdrFcShort( 0x3de ),	/* Type Offset=990 */

	/* Parameter IsRoot */

/* 876 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 878 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 880 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter Timeout */

/* 882 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 884 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 886 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 888 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 890 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 892 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetDcAddress */

/* 894 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 896 */	NdrFcLong( 0x0 ),	/* 0 */
/* 900 */	NdrFcShort( 0x11 ),	/* 17 */
/* 902 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 904 */	NdrFcShort( 0x10 ),	/* 16 */
/* 906 */	NdrFcShort( 0x8 ),	/* 8 */
/* 908 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 910 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 912 */	NdrFcShort( 0x0 ),	/* 0 */
/* 914 */	NdrFcShort( 0x0 ),	/* 0 */
/* 916 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 918 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 920 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 922 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 924 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 926 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 928 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Timeout */

/* 930 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 932 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 934 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Flags */

/* 936 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 938 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 940 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 942 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 944 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 946 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsFlushFtTable */

/* 948 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 950 */	NdrFcLong( 0x0 ),	/* 0 */
/* 954 */	NdrFcShort( 0x12 ),	/* 18 */
/* 956 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 958 */	NdrFcShort( 0x0 ),	/* 0 */
/* 960 */	NdrFcShort( 0x8 ),	/* 8 */
/* 962 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 964 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 966 */	NdrFcShort( 0x0 ),	/* 0 */
/* 968 */	NdrFcShort( 0x0 ),	/* 0 */
/* 970 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DcName */

/* 972 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 974 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 976 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter wszFtDfsName */

/* 978 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 980 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 982 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 984 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 986 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 988 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAdd2 */

/* 990 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 992 */	NdrFcLong( 0x0 ),	/* 0 */
/* 996 */	NdrFcShort( 0x13 ),	/* 19 */
/* 998 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 1000 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1002 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1004 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1006 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1008 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1010 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1012 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1014 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1016 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 1018 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1020 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1022 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1024 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1026 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1028 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1030 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ShareName */

/* 1032 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1034 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1036 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Comment */

/* 1038 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1040 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1042 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Flags */

/* 1044 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1046 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1048 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 1050 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1052 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1054 */	NdrFcShort( 0x3aa ),	/* Type Offset=938 */

	/* Return value */

/* 1056 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1058 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1060 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemove2 */

/* 1062 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1064 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1068 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1070 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1072 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1074 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1076 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 1078 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1080 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1082 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1084 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1086 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1088 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 1090 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1092 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1094 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1096 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1098 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1100 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1102 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 1104 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1106 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1108 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ppRootList */

/* 1110 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1112 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1114 */	NdrFcShort( 0x3aa ),	/* Type Offset=938 */

	/* Return value */

/* 1116 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1118 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1120 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsEnumEx */

/* 1122 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1124 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1128 */	NdrFcShort( 0x15 ),	/* 21 */
/* 1130 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1132 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1134 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1136 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 1138 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1140 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1142 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1144 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1146 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1148 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 1150 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Level */

/* 1152 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1154 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1156 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PrefMaxLen */

/* 1158 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1160 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1162 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsEnum */

/* 1164 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 1166 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1168 */	NdrFcShort( 0x186 ),	/* Type Offset=390 */

	/* Parameter ResumeHandle */

/* 1170 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 1172 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1174 */	NdrFcShort( 0x32a ),	/* Type Offset=810 */

	/* Return value */

/* 1176 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1178 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1180 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetInfo2 */

/* 1182 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1184 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1188 */	NdrFcShort( 0x16 ),	/* 22 */
/* 1190 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
/* 1192 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1194 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1196 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1198 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1200 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1202 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1204 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1206 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1208 */	NdrFcShort( 0x0 ),	/* x86 Stack size/offset = 0 */
/* 1210 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1212 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1214 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 1216 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1218 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1220 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 1222 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 1224 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1226 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 1228 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 1230 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1232 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1234 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pDfsInfo */

/* 1236 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1238 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 1240 */	NdrFcShort( 0x3ee ),	/* Type Offset=1006 */

	/* Parameter ppRootList */

/* 1242 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1244 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 1246 */	NdrFcShort( 0x3aa ),	/* Type Offset=938 */

	/* Return value */

/* 1248 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1250 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 1252 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/*  4 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  8 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 10 */	
			0x11, 0x0,	/* FC_RP */
/* 12 */	NdrFcShort( 0x2 ),	/* Offset= 2 (14) */
/* 14 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 16 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 18 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 20 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 22 */	NdrFcShort( 0x2 ),	/* Offset= 2 (24) */
/* 24 */	NdrFcShort( 0x4 ),	/* 4 */
/* 26 */	NdrFcShort( 0x3007 ),	/* 12295 */
/* 28 */	NdrFcLong( 0x1 ),	/* 1 */
/* 32 */	NdrFcShort( 0x28 ),	/* Offset= 40 (72) */
/* 34 */	NdrFcLong( 0x2 ),	/* 2 */
/* 38 */	NdrFcShort( 0x3a ),	/* Offset= 58 (96) */
/* 40 */	NdrFcLong( 0x3 ),	/* 3 */
/* 44 */	NdrFcShort( 0x58 ),	/* Offset= 88 (132) */
/* 46 */	NdrFcLong( 0x4 ),	/* 4 */
/* 50 */	NdrFcShort( 0xcc ),	/* Offset= 204 (254) */
/* 52 */	NdrFcLong( 0x64 ),	/* 100 */
/* 56 */	NdrFcShort( 0x10 ),	/* Offset= 16 (72) */
/* 58 */	NdrFcLong( 0x65 ),	/* 101 */
/* 62 */	NdrFcShort( 0x130 ),	/* Offset= 304 (366) */
/* 64 */	NdrFcLong( 0x66 ),	/* 102 */
/* 68 */	NdrFcShort( 0x12a ),	/* Offset= 298 (366) */
/* 70 */	NdrFcShort( 0x0 ),	/* Offset= 0 (70) */
/* 72 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 74 */	NdrFcShort( 0x2 ),	/* Offset= 2 (76) */
/* 76 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 78 */	NdrFcShort( 0x4 ),	/* 4 */
/* 80 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 82 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 84 */	NdrFcShort( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x0 ),	/* 0 */
/* 88 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 90 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 92 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 94 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 96 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 98 */	NdrFcShort( 0x2 ),	/* Offset= 2 (100) */
/* 100 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 102 */	NdrFcShort( 0x10 ),	/* 16 */
/* 104 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 106 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 108 */	NdrFcShort( 0x0 ),	/* 0 */
/* 110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 112 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 114 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 116 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 118 */	NdrFcShort( 0x4 ),	/* 4 */
/* 120 */	NdrFcShort( 0x4 ),	/* 4 */
/* 122 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 124 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 126 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 128 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 130 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 132 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 134 */	NdrFcShort( 0x4c ),	/* Offset= 76 (210) */
/* 136 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 138 */	NdrFcShort( 0xc ),	/* 12 */
/* 140 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 142 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 144 */	NdrFcShort( 0x4 ),	/* 4 */
/* 146 */	NdrFcShort( 0x4 ),	/* 4 */
/* 148 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 150 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 152 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 154 */	NdrFcShort( 0x8 ),	/* 8 */
/* 156 */	NdrFcShort( 0x8 ),	/* 8 */
/* 158 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 160 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 162 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 164 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 166 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 168 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 170 */	NdrFcShort( 0xc ),	/* 12 */
/* 172 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 174 */	NdrFcShort( 0xc ),	/* 12 */
/* 176 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 178 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 180 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 182 */	NdrFcShort( 0xc ),	/* 12 */
/* 184 */	NdrFcShort( 0x0 ),	/* 0 */
/* 186 */	NdrFcShort( 0x2 ),	/* 2 */
/* 188 */	NdrFcShort( 0x4 ),	/* 4 */
/* 190 */	NdrFcShort( 0x4 ),	/* 4 */
/* 192 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 194 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 196 */	NdrFcShort( 0x8 ),	/* 8 */
/* 198 */	NdrFcShort( 0x8 ),	/* 8 */
/* 200 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 202 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 204 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 206 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb9 ),	/* Offset= -71 (136) */
			0x5b,		/* FC_END */
/* 210 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 212 */	NdrFcShort( 0x14 ),	/* 20 */
/* 214 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 216 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 218 */	NdrFcShort( 0x0 ),	/* 0 */
/* 220 */	NdrFcShort( 0x0 ),	/* 0 */
/* 222 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 224 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 226 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 228 */	NdrFcShort( 0x4 ),	/* 4 */
/* 230 */	NdrFcShort( 0x4 ),	/* 4 */
/* 232 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 234 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 236 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 238 */	NdrFcShort( 0x10 ),	/* 16 */
/* 240 */	NdrFcShort( 0x10 ),	/* 16 */
/* 242 */	0x12, 0x0,	/* FC_UP */
/* 244 */	NdrFcShort( 0xffffffb4 ),	/* Offset= -76 (168) */
/* 246 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 248 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 250 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 252 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 254 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 256 */	NdrFcShort( 0x3e ),	/* Offset= 62 (318) */
/* 258 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 260 */	NdrFcShort( 0x8 ),	/* 8 */
/* 262 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 264 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 266 */	NdrFcShort( 0x10 ),	/* 16 */
/* 268 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 270 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 272 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (258) */
			0x5b,		/* FC_END */
/* 276 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 278 */	NdrFcShort( 0xc ),	/* 12 */
/* 280 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 282 */	NdrFcShort( 0x20 ),	/* 32 */
/* 284 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 286 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 288 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 290 */	NdrFcShort( 0xc ),	/* 12 */
/* 292 */	NdrFcShort( 0x0 ),	/* 0 */
/* 294 */	NdrFcShort( 0x2 ),	/* 2 */
/* 296 */	NdrFcShort( 0x4 ),	/* 4 */
/* 298 */	NdrFcShort( 0x4 ),	/* 4 */
/* 300 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 302 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 304 */	NdrFcShort( 0x8 ),	/* 8 */
/* 306 */	NdrFcShort( 0x8 ),	/* 8 */
/* 308 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 310 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 312 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 314 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff4d ),	/* Offset= -179 (136) */
			0x5b,		/* FC_END */
/* 318 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 320 */	NdrFcShort( 0x28 ),	/* 40 */
/* 322 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 324 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 328 */	NdrFcShort( 0x0 ),	/* 0 */
/* 330 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 332 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 334 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 336 */	NdrFcShort( 0x4 ),	/* 4 */
/* 338 */	NdrFcShort( 0x4 ),	/* 4 */
/* 340 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 342 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 344 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 346 */	NdrFcShort( 0x24 ),	/* 36 */
/* 348 */	NdrFcShort( 0x24 ),	/* 36 */
/* 350 */	0x12, 0x0,	/* FC_UP */
/* 352 */	NdrFcShort( 0xffffffb4 ),	/* Offset= -76 (276) */
/* 354 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 356 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 358 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 360 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff9f ),	/* Offset= -97 (264) */
			0x8,		/* FC_LONG */
/* 364 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 366 */	
			0x12, 0x0,	/* FC_UP */
/* 368 */	NdrFcShort( 0x2 ),	/* Offset= 2 (370) */
/* 370 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 372 */	NdrFcShort( 0x4 ),	/* 4 */
/* 374 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 376 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 378 */	NdrFcShort( 0x2 ),	/* Offset= 2 (380) */
/* 380 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 382 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 384 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 386 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 388 */	NdrFcShort( 0xfffffe94 ),	/* Offset= -364 (24) */
/* 390 */	
			0x12, 0x0,	/* FC_UP */
/* 392 */	NdrFcShort( 0x194 ),	/* Offset= 404 (796) */
/* 394 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 396 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 398 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 400 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 402 */	NdrFcShort( 0x2 ),	/* Offset= 2 (404) */
/* 404 */	NdrFcShort( 0x4 ),	/* 4 */
/* 406 */	NdrFcShort( 0x3006 ),	/* 12294 */
/* 408 */	NdrFcLong( 0x1 ),	/* 1 */
/* 412 */	NdrFcShort( 0x22 ),	/* Offset= 34 (446) */
/* 414 */	NdrFcLong( 0x2 ),	/* 2 */
/* 418 */	NdrFcShort( 0x56 ),	/* Offset= 86 (504) */
/* 420 */	NdrFcLong( 0x3 ),	/* 3 */
/* 424 */	NdrFcShort( 0x92 ),	/* Offset= 146 (570) */
/* 426 */	NdrFcLong( 0x4 ),	/* 4 */
/* 430 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (644) */
/* 432 */	NdrFcLong( 0xc8 ),	/* 200 */
/* 436 */	NdrFcShort( 0xa ),	/* Offset= 10 (446) */
/* 438 */	NdrFcLong( 0x12c ),	/* 300 */
/* 442 */	NdrFcShort( 0x114 ),	/* Offset= 276 (718) */
/* 444 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (443) */
/* 446 */	
			0x12, 0x0,	/* FC_UP */
/* 448 */	NdrFcShort( 0x24 ),	/* Offset= 36 (484) */
/* 450 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 452 */	NdrFcShort( 0x4 ),	/* 4 */
/* 454 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 458 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 460 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 462 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 464 */	NdrFcShort( 0x4 ),	/* 4 */
/* 466 */	NdrFcShort( 0x0 ),	/* 0 */
/* 468 */	NdrFcShort( 0x1 ),	/* 1 */
/* 470 */	NdrFcShort( 0x0 ),	/* 0 */
/* 472 */	NdrFcShort( 0x0 ),	/* 0 */
/* 474 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 476 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 478 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 480 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe6b ),	/* Offset= -405 (76) */
			0x5b,		/* FC_END */
/* 484 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 486 */	NdrFcShort( 0x8 ),	/* 8 */
/* 488 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 490 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 492 */	NdrFcShort( 0x4 ),	/* 4 */
/* 494 */	NdrFcShort( 0x4 ),	/* 4 */
/* 496 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 498 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (450) */
/* 500 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 502 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 504 */	
			0x12, 0x0,	/* FC_UP */
/* 506 */	NdrFcShort( 0x2c ),	/* Offset= 44 (550) */
/* 508 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 510 */	NdrFcShort( 0x10 ),	/* 16 */
/* 512 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 514 */	NdrFcShort( 0x0 ),	/* 0 */
/* 516 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 518 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 520 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 522 */	NdrFcShort( 0x10 ),	/* 16 */
/* 524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 526 */	NdrFcShort( 0x2 ),	/* 2 */
/* 528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 530 */	NdrFcShort( 0x0 ),	/* 0 */
/* 532 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 534 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 536 */	NdrFcShort( 0x4 ),	/* 4 */
/* 538 */	NdrFcShort( 0x4 ),	/* 4 */
/* 540 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 542 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 544 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 546 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe41 ),	/* Offset= -447 (100) */
			0x5b,		/* FC_END */
/* 550 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 552 */	NdrFcShort( 0x8 ),	/* 8 */
/* 554 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 556 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 558 */	NdrFcShort( 0x4 ),	/* 4 */
/* 560 */	NdrFcShort( 0x4 ),	/* 4 */
/* 562 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 564 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (508) */
/* 566 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 568 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 570 */	
			0x12, 0x0,	/* FC_UP */
/* 572 */	NdrFcShort( 0x34 ),	/* Offset= 52 (624) */
/* 574 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 576 */	NdrFcShort( 0x14 ),	/* 20 */
/* 578 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 580 */	NdrFcShort( 0x0 ),	/* 0 */
/* 582 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 584 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 586 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 588 */	NdrFcShort( 0x14 ),	/* 20 */
/* 590 */	NdrFcShort( 0x0 ),	/* 0 */
/* 592 */	NdrFcShort( 0x3 ),	/* 3 */
/* 594 */	NdrFcShort( 0x0 ),	/* 0 */
/* 596 */	NdrFcShort( 0x0 ),	/* 0 */
/* 598 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 600 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 602 */	NdrFcShort( 0x4 ),	/* 4 */
/* 604 */	NdrFcShort( 0x4 ),	/* 4 */
/* 606 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 608 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 610 */	NdrFcShort( 0x10 ),	/* 16 */
/* 612 */	NdrFcShort( 0x10 ),	/* 16 */
/* 614 */	0x12, 0x0,	/* FC_UP */
/* 616 */	NdrFcShort( 0xfffffe40 ),	/* Offset= -448 (168) */
/* 618 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 620 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe65 ),	/* Offset= -411 (210) */
			0x5b,		/* FC_END */
/* 624 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 626 */	NdrFcShort( 0x8 ),	/* 8 */
/* 628 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 630 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 632 */	NdrFcShort( 0x4 ),	/* 4 */
/* 634 */	NdrFcShort( 0x4 ),	/* 4 */
/* 636 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 638 */	NdrFcShort( 0xffffffc0 ),	/* Offset= -64 (574) */
/* 640 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 642 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 644 */	
			0x12, 0x0,	/* FC_UP */
/* 646 */	NdrFcShort( 0x34 ),	/* Offset= 52 (698) */
/* 648 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 650 */	NdrFcShort( 0x28 ),	/* 40 */
/* 652 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 654 */	NdrFcShort( 0x0 ),	/* 0 */
/* 656 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 658 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 660 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 662 */	NdrFcShort( 0x28 ),	/* 40 */
/* 664 */	NdrFcShort( 0x0 ),	/* 0 */
/* 666 */	NdrFcShort( 0x3 ),	/* 3 */
/* 668 */	NdrFcShort( 0x0 ),	/* 0 */
/* 670 */	NdrFcShort( 0x0 ),	/* 0 */
/* 672 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 674 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 676 */	NdrFcShort( 0x4 ),	/* 4 */
/* 678 */	NdrFcShort( 0x4 ),	/* 4 */
/* 680 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 682 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 684 */	NdrFcShort( 0x24 ),	/* 36 */
/* 686 */	NdrFcShort( 0x24 ),	/* 36 */
/* 688 */	0x12, 0x0,	/* FC_UP */
/* 690 */	NdrFcShort( 0xfffffe62 ),	/* Offset= -414 (276) */
/* 692 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 694 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe87 ),	/* Offset= -377 (318) */
			0x5b,		/* FC_END */
/* 698 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 700 */	NdrFcShort( 0x8 ),	/* 8 */
/* 702 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 704 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 706 */	NdrFcShort( 0x4 ),	/* 4 */
/* 708 */	NdrFcShort( 0x4 ),	/* 4 */
/* 710 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 712 */	NdrFcShort( 0xffffffc0 ),	/* Offset= -64 (648) */
/* 714 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 716 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 718 */	
			0x12, 0x0,	/* FC_UP */
/* 720 */	NdrFcShort( 0x38 ),	/* Offset= 56 (776) */
/* 722 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 724 */	NdrFcShort( 0x8 ),	/* 8 */
/* 726 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 728 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 730 */	NdrFcShort( 0x4 ),	/* 4 */
/* 732 */	NdrFcShort( 0x4 ),	/* 4 */
/* 734 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 736 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 738 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 740 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 742 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 744 */	NdrFcShort( 0x8 ),	/* 8 */
/* 746 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 748 */	NdrFcShort( 0x0 ),	/* 0 */
/* 750 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 752 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 754 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 756 */	NdrFcShort( 0x8 ),	/* 8 */
/* 758 */	NdrFcShort( 0x0 ),	/* 0 */
/* 760 */	NdrFcShort( 0x1 ),	/* 1 */
/* 762 */	NdrFcShort( 0x4 ),	/* 4 */
/* 764 */	NdrFcShort( 0x4 ),	/* 4 */
/* 766 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 768 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 770 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 772 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffcd ),	/* Offset= -51 (722) */
			0x5b,		/* FC_END */
/* 776 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 778 */	NdrFcShort( 0x8 ),	/* 8 */
/* 780 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 782 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 784 */	NdrFcShort( 0x4 ),	/* 4 */
/* 786 */	NdrFcShort( 0x4 ),	/* 4 */
/* 788 */	0x12, 0x1,	/* FC_UP [all_nodes] */
/* 790 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (742) */
/* 792 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 794 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 796 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 798 */	NdrFcShort( 0x8 ),	/* 8 */
/* 800 */	NdrFcShort( 0x0 ),	/* 0 */
/* 802 */	NdrFcShort( 0x0 ),	/* Offset= 0 (802) */
/* 804 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 806 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe63 ),	/* Offset= -413 (394) */
			0x5b,		/* FC_END */
/* 810 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 812 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 814 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 816 */	NdrFcShort( 0x2 ),	/* Offset= 2 (818) */
/* 818 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 820 */	NdrFcShort( 0x2a ),	/* Offset= 42 (862) */
/* 822 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 824 */	NdrFcShort( 0x14 ),	/* 20 */
/* 826 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 828 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 830 */	NdrFcShort( 0x10 ),	/* 16 */
/* 832 */	NdrFcShort( 0x10 ),	/* 16 */
/* 834 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 836 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 838 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 840 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffdbf ),	/* Offset= -577 (264) */
			0x8,		/* FC_LONG */
/* 844 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 846 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 848 */	NdrFcShort( 0x14 ),	/* 20 */
/* 850 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 852 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 854 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 856 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 858 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (822) */
/* 860 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 862 */	
			0x18,		/* FC_CPSTRUCT */
			0x3,		/* 3 */
/* 864 */	NdrFcShort( 0x4 ),	/* 4 */
/* 866 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (846) */
/* 868 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 870 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 872 */	NdrFcShort( 0x14 ),	/* 20 */
/* 874 */	NdrFcShort( 0x4 ),	/* 4 */
/* 876 */	NdrFcShort( 0x1 ),	/* 1 */
/* 878 */	NdrFcShort( 0x14 ),	/* 20 */
/* 880 */	NdrFcShort( 0x14 ),	/* 20 */
/* 882 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 884 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 886 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 888 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 890 */	
			0x11, 0x0,	/* FC_RP */
/* 892 */	NdrFcShort( 0x12 ),	/* Offset= 18 (910) */
/* 894 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 896 */	NdrFcShort( 0x8 ),	/* 8 */
/* 898 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 900 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 902 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 904 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 906 */	NdrFcShort( 0xffffff48 ),	/* Offset= -184 (722) */
/* 908 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 910 */	
			0x18,		/* FC_CPSTRUCT */
			0x3,		/* 3 */
/* 912 */	NdrFcShort( 0x4 ),	/* 4 */
/* 914 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (894) */
/* 916 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 918 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 920 */	NdrFcShort( 0x8 ),	/* 8 */
/* 922 */	NdrFcShort( 0x4 ),	/* 4 */
/* 924 */	NdrFcShort( 0x1 ),	/* 1 */
/* 926 */	NdrFcShort( 0x8 ),	/* 8 */
/* 928 */	NdrFcShort( 0x8 ),	/* 8 */
/* 930 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 932 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 934 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 936 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 938 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 940 */	NdrFcShort( 0x2 ),	/* Offset= 2 (942) */
/* 942 */	
			0x12, 0x0,	/* FC_UP */
/* 944 */	NdrFcShort( 0x12 ),	/* Offset= 18 (962) */
/* 946 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 948 */	NdrFcShort( 0x4 ),	/* 4 */
/* 950 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 952 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 954 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 956 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 958 */	NdrFcShort( 0xfffffc8e ),	/* Offset= -882 (76) */
/* 960 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 962 */	
			0x18,		/* FC_CPSTRUCT */
			0x3,		/* 3 */
/* 964 */	NdrFcShort( 0x4 ),	/* 4 */
/* 966 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (946) */
/* 968 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 970 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 972 */	NdrFcShort( 0x4 ),	/* 4 */
/* 974 */	NdrFcShort( 0x4 ),	/* 4 */
/* 976 */	NdrFcShort( 0x1 ),	/* 1 */
/* 978 */	NdrFcShort( 0x4 ),	/* 4 */
/* 980 */	NdrFcShort( 0x4 ),	/* 4 */
/* 982 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 984 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 986 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 988 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 990 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 992 */	NdrFcShort( 0xfffffc26 ),	/* Offset= -986 (6) */
/* 994 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 996 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 998 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1000 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1002 */	
			0x11, 0x0,	/* FC_RP */
/* 1004 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1006) */
/* 1006 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 1008 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 1010 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 1012 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1014 */	NdrFcShort( 0xfffffc22 ),	/* Offset= -990 (24) */

			0x0
        }
    };

static const unsigned short netdfs_FormatStringOffsetTable[] =
    {
    0,
    30,
    90,
    138,
    198,
    258,
    312,
    354,
    396,
    450,
    492,
    576,
    642,
    696,
    744,
    786,
    840,
    894,
    948,
    990,
    1062,
    1122,
    1182
    };


static const MIDL_STUB_DESC netdfs_StubDesc = 
    {
    (void *)& netdfs___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION netdfs_table[] =
    {
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE netdfs_DispatchTable = 
    {
    23,
    netdfs_table
    };

static const SERVER_ROUTINE netdfs_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)NetrDfsManagerGetVersion,
    (SERVER_ROUTINE)NetrDfsAdd,
    (SERVER_ROUTINE)NetrDfsRemove,
    (SERVER_ROUTINE)NetrDfsSetInfo,
    (SERVER_ROUTINE)NetrDfsGetInfo,
    (SERVER_ROUTINE)NetrDfsEnum,
    (SERVER_ROUTINE)NetrDfsMove,
    (SERVER_ROUTINE)NetrDfsRename,
    (SERVER_ROUTINE)NetrDfsManagerGetConfigInfo,
    (SERVER_ROUTINE)NetrDfsManagerSendSiteInfo,
    (SERVER_ROUTINE)NetrDfsAddFtRoot,
    (SERVER_ROUTINE)NetrDfsRemoveFtRoot,
    (SERVER_ROUTINE)NetrDfsAddStdRoot,
    (SERVER_ROUTINE)NetrDfsRemoveStdRoot,
    (SERVER_ROUTINE)NetrDfsManagerInitialize,
    (SERVER_ROUTINE)NetrDfsAddStdRootForced,
    (SERVER_ROUTINE)NetrDfsGetDcAddress,
    (SERVER_ROUTINE)NetrDfsSetDcAddress,
    (SERVER_ROUTINE)NetrDfsFlushFtTable,
    (SERVER_ROUTINE)NetrDfsAdd2,
    (SERVER_ROUTINE)NetrDfsRemove2,
    (SERVER_ROUTINE)NetrDfsEnumEx,
    (SERVER_ROUTINE)NetrDfsSetInfo2
    };

static const MIDL_SERVER_INFO netdfs_ServerInfo = 
    {
    &netdfs_StubDesc,
    netdfs_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    netdfs_FormatStringOffsetTable,
    0,
    0,
    0,
    0};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for netdfs.idl, dfscli.acf:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#include <string.h>
#include "netdfs.h"

#define TYPE_FORMAT_STRING_SIZE   863                               
#define PROC_FORMAT_STRING_SIZE   1301                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: netdfs, ver. 3.0,
   GUID={0x4fc742e0,0x4a10,0x11cf,{0x82,0x73,0x00,0xaa,0x00,0x4a,0xe6,0x73}} */


extern const MIDL_SERVER_INFO netdfs_ServerInfo;

extern RPC_DISPATCH_TABLE netdfs_DispatchTable;

static const RPC_SERVER_INTERFACE netdfs___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x4fc742e0,0x4a10,0x11cf,{0x82,0x73,0x00,0xaa,0x00,0x4a,0xe6,0x73}},{3,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &netdfs_DispatchTable,
    0,
    0,
    0,
    &netdfs_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE netdfs_ServerIfHandle = (RPC_IF_HANDLE)& netdfs___RpcServerInterface;

extern const MIDL_STUB_DESC netdfs_StubDesc;


#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure NetrDfsManagerGetVersion */

			0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 16 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 26 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 28 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 30 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAdd */

/* 32 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 34 */	NdrFcLong( 0x0 ),	/* 0 */
/* 38 */	NdrFcShort( 0x1 ),	/* 1 */
/* 40 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 42 */	NdrFcShort( 0x8 ),	/* 8 */
/* 44 */	NdrFcShort( 0x8 ),	/* 8 */
/* 46 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 48 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 50 */	NdrFcShort( 0x0 ),	/* 0 */
/* 52 */	NdrFcShort( 0x0 ),	/* 0 */
/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 58 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 60 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 62 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 64 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 66 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 68 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ShareName */

/* 70 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 72 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 74 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Comment */

/* 76 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 78 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 80 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Flags */

/* 82 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 84 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 86 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 88 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 90 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 92 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemove */

/* 94 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 96 */	NdrFcLong( 0x0 ),	/* 0 */
/* 100 */	NdrFcShort( 0x2 ),	/* 2 */
/* 102 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 104 */	NdrFcShort( 0x0 ),	/* 0 */
/* 106 */	NdrFcShort( 0x8 ),	/* 8 */
/* 108 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 110 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 112 */	NdrFcShort( 0x0 ),	/* 0 */
/* 114 */	NdrFcShort( 0x0 ),	/* 0 */
/* 116 */	NdrFcShort( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 120 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 122 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 124 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 126 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 128 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 130 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 132 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 134 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 136 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 138 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 140 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 142 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetInfo */

/* 144 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 146 */	NdrFcLong( 0x0 ),	/* 0 */
/* 150 */	NdrFcShort( 0x3 ),	/* 3 */
/* 152 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 154 */	NdrFcShort( 0x8 ),	/* 8 */
/* 156 */	NdrFcShort( 0x8 ),	/* 8 */
/* 158 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 160 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 162 */	NdrFcShort( 0x0 ),	/* 0 */
/* 164 */	NdrFcShort( 0x3 ),	/* 3 */
/* 166 */	NdrFcShort( 0x0 ),	/* 0 */
/* 168 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 170 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 172 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 174 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 176 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 178 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 180 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 182 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 184 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 186 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 188 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 190 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 192 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsInfo */

/* 194 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 196 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 198 */	NdrFcShort( 0xe ),	/* Type Offset=14 */

	/* Return value */

/* 200 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 202 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 204 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsGetInfo */

/* 206 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 208 */	NdrFcLong( 0x0 ),	/* 0 */
/* 212 */	NdrFcShort( 0x4 ),	/* 4 */
/* 214 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 216 */	NdrFcShort( 0x8 ),	/* 8 */
/* 218 */	NdrFcShort( 0x8 ),	/* 8 */
/* 220 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 222 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 224 */	NdrFcShort( 0x3 ),	/* 3 */
/* 226 */	NdrFcShort( 0x0 ),	/* 0 */
/* 228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 230 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 232 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 234 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 236 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 238 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 240 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 242 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 244 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 246 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 248 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 250 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 252 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 254 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsInfo */

/* 256 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 258 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 260 */	NdrFcShort( 0x12a ),	/* Type Offset=298 */

	/* Return value */

/* 262 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 264 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 266 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsEnum */

/* 268 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 270 */	NdrFcLong( 0x0 ),	/* 0 */
/* 274 */	NdrFcShort( 0x5 ),	/* 5 */
/* 276 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 278 */	NdrFcShort( 0x2c ),	/* 44 */
/* 280 */	NdrFcShort( 0x24 ),	/* 36 */
/* 282 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 284 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 286 */	NdrFcShort( 0x9 ),	/* 9 */
/* 288 */	NdrFcShort( 0x9 ),	/* 9 */
/* 290 */	NdrFcShort( 0x0 ),	/* 0 */
/* 292 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter Level */

/* 294 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 296 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 298 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PrefMaxLen */

/* 300 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 302 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 304 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsEnum */

/* 306 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 308 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 310 */	NdrFcShort( 0x134 ),	/* Type Offset=308 */

	/* Parameter ResumeHandle */

/* 312 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 314 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 316 */	NdrFcShort( 0x296 ),	/* Type Offset=662 */

	/* Return value */

/* 318 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 320 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 322 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsMove */

/* 324 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 326 */	NdrFcLong( 0x0 ),	/* 0 */
/* 330 */	NdrFcShort( 0x6 ),	/* 6 */
/* 332 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */
/* 336 */	NdrFcShort( 0x8 ),	/* 8 */
/* 338 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 340 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 342 */	NdrFcShort( 0x0 ),	/* 0 */
/* 344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 346 */	NdrFcShort( 0x0 ),	/* 0 */
/* 348 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 350 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 352 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 354 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewDfsEntryPath */

/* 356 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 358 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 360 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 362 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 364 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 366 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRename */

/* 368 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 370 */	NdrFcLong( 0x0 ),	/* 0 */
/* 374 */	NdrFcShort( 0x7 ),	/* 7 */
/* 376 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 380 */	NdrFcShort( 0x8 ),	/* 8 */
/* 382 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 384 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 386 */	NdrFcShort( 0x0 ),	/* 0 */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x0 ),	/* 0 */
/* 392 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter Path */

/* 394 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 396 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 398 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewPath */

/* 400 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 402 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 404 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 406 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 408 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 410 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerGetConfigInfo */

/* 412 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 414 */	NdrFcLong( 0x0 ),	/* 0 */
/* 418 */	NdrFcShort( 0x8 ),	/* 8 */
/* 420 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 422 */	NdrFcShort( 0x30 ),	/* 48 */
/* 424 */	NdrFcShort( 0x8 ),	/* 8 */
/* 426 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 428 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 430 */	NdrFcShort( 0x1 ),	/* 1 */
/* 432 */	NdrFcShort( 0x1 ),	/* 1 */
/* 434 */	NdrFcShort( 0x0 ),	/* 0 */
/* 436 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter wszServer */

/* 438 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 440 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 442 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter wszLocalVolumeEntryPath */

/* 444 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 446 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 448 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter idLocalVolume */

/* 450 */	NdrFcShort( 0x8a ),	/* Flags:  must free, in, by val, */
/* 452 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 454 */	NdrFcShort( 0xc8 ),	/* Type Offset=200 */

	/* Parameter ppRelationInfo */

/* 456 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 458 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 460 */	NdrFcShort( 0x29a ),	/* Type Offset=666 */

	/* Return value */

/* 462 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 464 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 466 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerSendSiteInfo */

/* 468 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 470 */	NdrFcLong( 0x0 ),	/* 0 */
/* 474 */	NdrFcShort( 0x9 ),	/* 9 */
/* 476 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 478 */	NdrFcShort( 0x0 ),	/* 0 */
/* 480 */	NdrFcShort( 0x8 ),	/* 8 */
/* 482 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 484 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 486 */	NdrFcShort( 0x0 ),	/* 0 */
/* 488 */	NdrFcShort( 0x1 ),	/* 1 */
/* 490 */	NdrFcShort( 0x0 ),	/* 0 */
/* 492 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter wszServer */

/* 494 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 496 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 498 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter pSiteInfo */

/* 500 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 502 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 504 */	NdrFcShort( 0x300 ),	/* Type Offset=768 */

	/* Return value */

/* 506 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 508 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 510 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddFtRoot */

/* 512 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 514 */	NdrFcLong( 0x0 ),	/* 0 */
/* 518 */	NdrFcShort( 0xa ),	/* 10 */
/* 520 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 522 */	NdrFcShort( 0xd ),	/* 13 */
/* 524 */	NdrFcShort( 0x8 ),	/* 8 */
/* 526 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xa,		/* 10 */
/* 528 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 530 */	NdrFcShort( 0x1 ),	/* 1 */
/* 532 */	NdrFcShort( 0x1 ),	/* 1 */
/* 534 */	NdrFcShort( 0x0 ),	/* 0 */
/* 536 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 538 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 540 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 542 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 544 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 546 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 548 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 550 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 552 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 554 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter FtDfsName */

/* 556 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 558 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 560 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 562 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 564 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 566 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ConfigDN */

/* 568 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 570 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 572 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter NewFtDfs */

/* 574 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 576 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 578 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter Flags */

/* 580 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 582 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 584 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 586 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 588 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 590 */	NdrFcShort( 0x30c ),	/* Type Offset=780 */

	/* Return value */

/* 592 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 594 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 596 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemoveFtRoot */

/* 598 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 600 */	NdrFcLong( 0x0 ),	/* 0 */
/* 604 */	NdrFcShort( 0xb ),	/* 11 */
/* 606 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 608 */	NdrFcShort( 0x8 ),	/* 8 */
/* 610 */	NdrFcShort( 0x8 ),	/* 8 */
/* 612 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 614 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 616 */	NdrFcShort( 0x1 ),	/* 1 */
/* 618 */	NdrFcShort( 0x1 ),	/* 1 */
/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 622 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 624 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 626 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 628 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 630 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 632 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 634 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 636 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 638 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 640 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter FtDfsName */

/* 642 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 644 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 646 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 648 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 650 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 652 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 654 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 656 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 658 */	NdrFcShort( 0x30c ),	/* Type Offset=780 */

	/* Return value */

/* 660 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 662 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 664 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddStdRoot */

/* 666 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 668 */	NdrFcLong( 0x0 ),	/* 0 */
/* 672 */	NdrFcShort( 0xc ),	/* 12 */
/* 674 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 676 */	NdrFcShort( 0x8 ),	/* 8 */
/* 678 */	NdrFcShort( 0x8 ),	/* 8 */
/* 680 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 682 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 684 */	NdrFcShort( 0x0 ),	/* 0 */
/* 686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 688 */	NdrFcShort( 0x0 ),	/* 0 */
/* 690 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 692 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 694 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 696 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 698 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 700 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 702 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 704 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 706 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 708 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 710 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 712 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 714 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 716 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 718 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 720 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemoveStdRoot */

/* 722 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 724 */	NdrFcLong( 0x0 ),	/* 0 */
/* 728 */	NdrFcShort( 0xd ),	/* 13 */
/* 730 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 732 */	NdrFcShort( 0x8 ),	/* 8 */
/* 734 */	NdrFcShort( 0x8 ),	/* 8 */
/* 736 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 738 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 740 */	NdrFcShort( 0x0 ),	/* 0 */
/* 742 */	NdrFcShort( 0x0 ),	/* 0 */
/* 744 */	NdrFcShort( 0x0 ),	/* 0 */
/* 746 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 748 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 750 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 752 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 754 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 756 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 758 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 760 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 762 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 764 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 766 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 768 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 770 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsManagerInitialize */

/* 772 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 774 */	NdrFcLong( 0x0 ),	/* 0 */
/* 778 */	NdrFcShort( 0xe ),	/* 14 */
/* 780 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 782 */	NdrFcShort( 0x8 ),	/* 8 */
/* 784 */	NdrFcShort( 0x8 ),	/* 8 */
/* 786 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 788 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 790 */	NdrFcShort( 0x0 ),	/* 0 */
/* 792 */	NdrFcShort( 0x0 ),	/* 0 */
/* 794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 796 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 798 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 800 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 802 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Flags */

/* 804 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 806 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 808 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 810 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 812 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 814 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAddStdRootForced */

/* 816 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 818 */	NdrFcLong( 0x0 ),	/* 0 */
/* 822 */	NdrFcShort( 0xf ),	/* 15 */
/* 824 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	NdrFcShort( 0x8 ),	/* 8 */
/* 830 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 832 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 834 */	NdrFcShort( 0x0 ),	/* 0 */
/* 836 */	NdrFcShort( 0x0 ),	/* 0 */
/* 838 */	NdrFcShort( 0x0 ),	/* 0 */
/* 840 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 842 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 844 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 846 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter RootShare */

/* 848 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 850 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 852 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Comment */

/* 854 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 856 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 858 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Share */

/* 860 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 862 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 864 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 866 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 868 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 870 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsGetDcAddress */

/* 872 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 874 */	NdrFcLong( 0x0 ),	/* 0 */
/* 878 */	NdrFcShort( 0x10 ),	/* 16 */
/* 880 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 882 */	NdrFcShort( 0x35 ),	/* 53 */
/* 884 */	NdrFcShort( 0x3d ),	/* 61 */
/* 886 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 888 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 890 */	NdrFcShort( 0x0 ),	/* 0 */
/* 892 */	NdrFcShort( 0x0 ),	/* 0 */
/* 894 */	NdrFcShort( 0x0 ),	/* 0 */
/* 896 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 898 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 900 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 902 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 904 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 906 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 908 */	NdrFcShort( 0x344 ),	/* Type Offset=836 */

	/* Parameter IsRoot */

/* 910 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 912 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 914 */	0x2,		/* FC_CHAR */
			0x0,		/* 0 */

	/* Parameter Timeout */

/* 916 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 918 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 920 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 922 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 924 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 926 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetDcAddress */

/* 928 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 930 */	NdrFcLong( 0x0 ),	/* 0 */
/* 934 */	NdrFcShort( 0x11 ),	/* 17 */
/* 936 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 938 */	NdrFcShort( 0x10 ),	/* 16 */
/* 940 */	NdrFcShort( 0x8 ),	/* 8 */
/* 942 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 944 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 946 */	NdrFcShort( 0x0 ),	/* 0 */
/* 948 */	NdrFcShort( 0x0 ),	/* 0 */
/* 950 */	NdrFcShort( 0x0 ),	/* 0 */
/* 952 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerName */

/* 954 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 956 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 958 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 960 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 962 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 964 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Timeout */

/* 966 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 968 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 970 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Flags */

/* 972 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 974 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 976 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 978 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 980 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 982 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsFlushFtTable */

/* 984 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 986 */	NdrFcLong( 0x0 ),	/* 0 */
/* 990 */	NdrFcShort( 0x12 ),	/* 18 */
/* 992 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 994 */	NdrFcShort( 0x0 ),	/* 0 */
/* 996 */	NdrFcShort( 0x8 ),	/* 8 */
/* 998 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1000 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1004 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1006 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1008 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DcName */

/* 1010 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1012 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 1014 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter wszFtDfsName */

/* 1016 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1018 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1020 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Return value */

/* 1022 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1024 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1026 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsAdd2 */

/* 1028 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1030 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1034 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1036 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 1038 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1040 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1042 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1044 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1046 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1048 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1050 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1052 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1054 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1056 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 1058 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1060 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1062 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1064 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1066 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1068 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1070 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ShareName */

/* 1072 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1074 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1076 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Comment */

/* 1078 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1080 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1082 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Flags */

/* 1084 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1086 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1088 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppRootList */

/* 1090 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1092 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1094 */	NdrFcShort( 0x30c ),	/* Type Offset=780 */

	/* Return value */

/* 1096 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1098 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 1100 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsRemove2 */

/* 1102 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1104 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1108 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1110 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1112 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1114 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1116 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 1118 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1120 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1122 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1124 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1126 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1128 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1130 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 1132 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1134 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1136 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1138 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1140 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1142 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1144 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 1146 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1148 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1150 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ppRootList */

/* 1152 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1154 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1156 */	NdrFcShort( 0x30c ),	/* Type Offset=780 */

	/* Return value */

/* 1158 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1160 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1162 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsEnumEx */

/* 1164 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1166 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1170 */	NdrFcShort( 0x15 ),	/* 21 */
/* 1172 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1174 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1176 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1178 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 1180 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1182 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1184 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1188 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1190 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1192 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 1194 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter Level */

/* 1196 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1198 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1200 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PrefMaxLen */

/* 1202 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1204 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1206 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter DfsEnum */

/* 1208 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 1210 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1212 */	NdrFcShort( 0x134 ),	/* Type Offset=308 */

	/* Parameter ResumeHandle */

/* 1214 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 1216 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1218 */	NdrFcShort( 0x296 ),	/* Type Offset=662 */

	/* Return value */

/* 1220 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1222 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1224 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure NetrDfsSetInfo2 */

/* 1226 */	0x32,		/* FC_BIND_PRIMITIVE */
			0x48,		/* Old Flags:  */
/* 1228 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1232 */	NdrFcShort( 0x16 ),	/* 22 */
/* 1234 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 1236 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1238 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1240 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1242 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1244 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1246 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1250 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter DfsEntryPath */

/* 1252 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1254 */	NdrFcShort( 0x0 ),	/* ia64 Stack size/offset = 0 */
/* 1256 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter DcName */

/* 1258 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1260 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1262 */	NdrFcShort( 0x4 ),	/* Type Offset=4 */

	/* Parameter ServerName */

/* 1264 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1266 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1268 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ShareName */

/* 1270 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1272 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1274 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter Level */

/* 1276 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1278 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1280 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pDfsInfo */

/* 1282 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1284 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1286 */	NdrFcShort( 0x354 ),	/* Type Offset=852 */

	/* Parameter ppRootList */

/* 1288 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1290 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1292 */	NdrFcShort( 0x30c ),	/* Type Offset=780 */

	/* Return value */

/* 1294 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1296 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 1298 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/*  4 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  8 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 10 */	
			0x11, 0x0,	/* FC_RP */
/* 12 */	NdrFcShort( 0x2 ),	/* Offset= 2 (14) */
/* 14 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 16 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 18 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 20 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 22 */	NdrFcShort( 0x2 ),	/* Offset= 2 (24) */
/* 24 */	NdrFcShort( 0x8 ),	/* 8 */
/* 26 */	NdrFcShort( 0x3007 ),	/* 12295 */
/* 28 */	NdrFcLong( 0x1 ),	/* 1 */
/* 32 */	NdrFcShort( 0x28 ),	/* Offset= 40 (72) */
/* 34 */	NdrFcLong( 0x2 ),	/* 2 */
/* 38 */	NdrFcShort( 0x34 ),	/* Offset= 52 (90) */
/* 40 */	NdrFcLong( 0x3 ),	/* 3 */
/* 44 */	NdrFcShort( 0x48 ),	/* Offset= 72 (116) */
/* 46 */	NdrFcLong( 0x4 ),	/* 4 */
/* 50 */	NdrFcShort( 0x8c ),	/* Offset= 140 (190) */
/* 52 */	NdrFcLong( 0x64 ),	/* 100 */
/* 56 */	NdrFcShort( 0xd2 ),	/* Offset= 210 (266) */
/* 58 */	NdrFcLong( 0x65 ),	/* 101 */
/* 62 */	NdrFcShort( 0xde ),	/* Offset= 222 (284) */
/* 64 */	NdrFcLong( 0x66 ),	/* 102 */
/* 68 */	NdrFcShort( 0xd8 ),	/* Offset= 216 (284) */
/* 70 */	NdrFcShort( 0x0 ),	/* Offset= 0 (70) */
/* 72 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 74 */	NdrFcShort( 0x2 ),	/* Offset= 2 (76) */
/* 76 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 78 */	NdrFcShort( 0x8 ),	/* 8 */
/* 80 */	NdrFcShort( 0x0 ),	/* 0 */
/* 82 */	NdrFcShort( 0x4 ),	/* Offset= 4 (86) */
/* 84 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 86 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 88 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 90 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 92 */	NdrFcShort( 0x2 ),	/* Offset= 2 (94) */
/* 94 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 96 */	NdrFcShort( 0x18 ),	/* 24 */
/* 98 */	NdrFcShort( 0x0 ),	/* 0 */
/* 100 */	NdrFcShort( 0x8 ),	/* Offset= 8 (108) */
/* 102 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 104 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 106 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 108 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 110 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 112 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 114 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 116 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 118 */	NdrFcShort( 0x2e ),	/* Offset= 46 (164) */
/* 120 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 122 */	NdrFcShort( 0x18 ),	/* 24 */
/* 124 */	NdrFcShort( 0x0 ),	/* 0 */
/* 126 */	NdrFcShort( 0x8 ),	/* Offset= 8 (134) */
/* 128 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 130 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 132 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 134 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 136 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 138 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 140 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 142 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 144 */	NdrFcShort( 0x0 ),	/* 0 */
/* 146 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 148 */	NdrFcShort( 0x14 ),	/* 20 */
/* 150 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 152 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 156 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 158 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 160 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (120) */
/* 162 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 164 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 166 */	NdrFcShort( 0x20 ),	/* 32 */
/* 168 */	NdrFcShort( 0x0 ),	/* 0 */
/* 170 */	NdrFcShort( 0x8 ),	/* Offset= 8 (178) */
/* 172 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 174 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 176 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 178 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 180 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 182 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 184 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 186 */	
			0x12, 0x0,	/* FC_UP */
/* 188 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (142) */
/* 190 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 192 */	NdrFcShort( 0x2a ),	/* Offset= 42 (234) */
/* 194 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 196 */	NdrFcShort( 0x8 ),	/* 8 */
/* 198 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 200 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 202 */	NdrFcShort( 0x10 ),	/* 16 */
/* 204 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 206 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 208 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (194) */
			0x5b,		/* FC_END */
/* 212 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 216 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 218 */	NdrFcShort( 0x28 ),	/* 40 */
/* 220 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 222 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 226 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 228 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 230 */	NdrFcShort( 0xffffff92 ),	/* Offset= -110 (120) */
/* 232 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 234 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 236 */	NdrFcShort( 0x38 ),	/* 56 */
/* 238 */	NdrFcShort( 0x0 ),	/* 0 */
/* 240 */	NdrFcShort( 0xe ),	/* Offset= 14 (254) */
/* 242 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 244 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 246 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 248 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (200) */
/* 250 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 252 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 254 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 256 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 258 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 260 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 262 */	
			0x12, 0x0,	/* FC_UP */
/* 264 */	NdrFcShort( 0xffffffcc ),	/* Offset= -52 (212) */
/* 266 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 268 */	NdrFcShort( 0x2 ),	/* Offset= 2 (270) */
/* 270 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 272 */	NdrFcShort( 0x8 ),	/* 8 */
/* 274 */	NdrFcShort( 0x0 ),	/* 0 */
/* 276 */	NdrFcShort( 0x4 ),	/* Offset= 4 (280) */
/* 278 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 280 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 282 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 284 */	
			0x12, 0x0,	/* FC_UP */
/* 286 */	NdrFcShort( 0x2 ),	/* Offset= 2 (288) */
/* 288 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 290 */	NdrFcShort( 0x4 ),	/* 4 */
/* 292 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 294 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 296 */	NdrFcShort( 0x2 ),	/* Offset= 2 (298) */
/* 298 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 300 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 302 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 304 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 306 */	NdrFcShort( 0xfffffee6 ),	/* Offset= -282 (24) */
/* 308 */	
			0x12, 0x0,	/* FC_UP */
/* 310 */	NdrFcShort( 0x150 ),	/* Offset= 336 (646) */
/* 312 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 314 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 316 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 318 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 320 */	NdrFcShort( 0x2 ),	/* Offset= 2 (322) */
/* 322 */	NdrFcShort( 0x8 ),	/* 8 */
/* 324 */	NdrFcShort( 0x3006 ),	/* 12294 */
/* 326 */	NdrFcLong( 0x1 ),	/* 1 */
/* 330 */	NdrFcShort( 0x22 ),	/* Offset= 34 (364) */
/* 332 */	NdrFcLong( 0x2 ),	/* 2 */
/* 336 */	NdrFcShort( 0x46 ),	/* Offset= 70 (406) */
/* 338 */	NdrFcLong( 0x3 ),	/* 3 */
/* 342 */	NdrFcShort( 0x6a ),	/* Offset= 106 (448) */
/* 344 */	NdrFcLong( 0x4 ),	/* 4 */
/* 348 */	NdrFcShort( 0x8e ),	/* Offset= 142 (490) */
/* 350 */	NdrFcLong( 0xc8 ),	/* 200 */
/* 354 */	NdrFcShort( 0xb2 ),	/* Offset= 178 (532) */
/* 356 */	NdrFcLong( 0x12c ),	/* 300 */
/* 360 */	NdrFcShort( 0xe4 ),	/* Offset= 228 (588) */
/* 362 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (361) */
/* 364 */	
			0x12, 0x0,	/* FC_UP */
/* 366 */	NdrFcShort( 0x18 ),	/* Offset= 24 (390) */
/* 368 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 370 */	NdrFcShort( 0x0 ),	/* 0 */
/* 372 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 378 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 382 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 384 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 386 */	NdrFcShort( 0xfffffeca ),	/* Offset= -310 (76) */
/* 388 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 390 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 392 */	NdrFcShort( 0x10 ),	/* 16 */
/* 394 */	NdrFcShort( 0x0 ),	/* 0 */
/* 396 */	NdrFcShort( 0x6 ),	/* Offset= 6 (402) */
/* 398 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 400 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 402 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 404 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (368) */
/* 406 */	
			0x12, 0x0,	/* FC_UP */
/* 408 */	NdrFcShort( 0x18 ),	/* Offset= 24 (432) */
/* 410 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 414 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 416 */	NdrFcShort( 0x0 ),	/* 0 */
/* 418 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 420 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 424 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 426 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 428 */	NdrFcShort( 0xfffffeb2 ),	/* Offset= -334 (94) */
/* 430 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 432 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 434 */	NdrFcShort( 0x10 ),	/* 16 */
/* 436 */	NdrFcShort( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0x6 ),	/* Offset= 6 (444) */
/* 440 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 442 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 444 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 446 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (410) */
/* 448 */	
			0x12, 0x0,	/* FC_UP */
/* 450 */	NdrFcShort( 0x18 ),	/* Offset= 24 (474) */
/* 452 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 454 */	NdrFcShort( 0x0 ),	/* 0 */
/* 456 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 458 */	NdrFcShort( 0x0 ),	/* 0 */
/* 460 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 462 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 466 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 468 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 470 */	NdrFcShort( 0xfffffece ),	/* Offset= -306 (164) */
/* 472 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 474 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 476 */	NdrFcShort( 0x10 ),	/* 16 */
/* 478 */	NdrFcShort( 0x0 ),	/* 0 */
/* 480 */	NdrFcShort( 0x6 ),	/* Offset= 6 (486) */
/* 482 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 484 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 486 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 488 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (452) */
/* 490 */	
			0x12, 0x0,	/* FC_UP */
/* 492 */	NdrFcShort( 0x18 ),	/* Offset= 24 (516) */
/* 494 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 496 */	NdrFcShort( 0x0 ),	/* 0 */
/* 498 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 500 */	NdrFcShort( 0x0 ),	/* 0 */
/* 502 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 504 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 508 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 510 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 512 */	NdrFcShort( 0xfffffeea ),	/* Offset= -278 (234) */
/* 514 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 516 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 518 */	NdrFcShort( 0x10 ),	/* 16 */
/* 520 */	NdrFcShort( 0x0 ),	/* 0 */
/* 522 */	NdrFcShort( 0x6 ),	/* Offset= 6 (528) */
/* 524 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 526 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 528 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 530 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (494) */
/* 532 */	
			0x12, 0x0,	/* FC_UP */
/* 534 */	NdrFcShort( 0x26 ),	/* Offset= 38 (572) */
/* 536 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 538 */	NdrFcShort( 0x8 ),	/* 8 */
/* 540 */	NdrFcShort( 0x0 ),	/* 0 */
/* 542 */	NdrFcShort( 0x4 ),	/* Offset= 4 (546) */
/* 544 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 546 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 548 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 550 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 552 */	NdrFcShort( 0x0 ),	/* 0 */
/* 554 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 556 */	NdrFcShort( 0x0 ),	/* 0 */
/* 558 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 560 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 564 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 566 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 568 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (536) */
/* 570 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 572 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 574 */	NdrFcShort( 0x10 ),	/* 16 */
/* 576 */	NdrFcShort( 0x0 ),	/* 0 */
/* 578 */	NdrFcShort( 0x6 ),	/* Offset= 6 (584) */
/* 580 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 582 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 584 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 586 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (550) */
/* 588 */	
			0x12, 0x0,	/* FC_UP */
/* 590 */	NdrFcShort( 0x28 ),	/* Offset= 40 (630) */
/* 592 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 594 */	NdrFcShort( 0x10 ),	/* 16 */
/* 596 */	NdrFcShort( 0x0 ),	/* 0 */
/* 598 */	NdrFcShort( 0x6 ),	/* Offset= 6 (604) */
/* 600 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 602 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 604 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 606 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 608 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 610 */	NdrFcShort( 0x0 ),	/* 0 */
/* 612 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 614 */	NdrFcShort( 0x0 ),	/* 0 */
/* 616 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 618 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 622 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 624 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 626 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (592) */
/* 628 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 630 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 632 */	NdrFcShort( 0x10 ),	/* 16 */
/* 634 */	NdrFcShort( 0x0 ),	/* 0 */
/* 636 */	NdrFcShort( 0x6 ),	/* Offset= 6 (642) */
/* 638 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 640 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 642 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 644 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (608) */
/* 646 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 648 */	NdrFcShort( 0x10 ),	/* 16 */
/* 650 */	NdrFcShort( 0x0 ),	/* 0 */
/* 652 */	NdrFcShort( 0x0 ),	/* Offset= 0 (652) */
/* 654 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 656 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 658 */	NdrFcShort( 0xfffffea6 ),	/* Offset= -346 (312) */
/* 660 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 662 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 664 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 666 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 668 */	NdrFcShort( 0x2 ),	/* Offset= 2 (670) */
/* 670 */	
			0x12, 0x1,	/* FC_UP [all_nodes] */
/* 672 */	NdrFcShort( 0x2a ),	/* Offset= 42 (714) */
/* 674 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 676 */	NdrFcShort( 0x18 ),	/* 24 */
/* 678 */	NdrFcShort( 0x0 ),	/* 0 */
/* 680 */	NdrFcShort( 0x8 ),	/* Offset= 8 (688) */
/* 682 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 684 */	NdrFcShort( 0xfffffe1c ),	/* Offset= -484 (200) */
/* 686 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 688 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 690 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 692 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 694 */	NdrFcShort( 0x0 ),	/* 0 */
/* 696 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 698 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 700 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 702 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 706 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 708 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 710 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (674) */
/* 712 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 714 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 716 */	NdrFcShort( 0x8 ),	/* 8 */
/* 718 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (692) */
/* 720 */	NdrFcShort( 0x0 ),	/* Offset= 0 (720) */
/* 722 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 724 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 726 */	
			0x11, 0x0,	/* FC_RP */
/* 728 */	NdrFcShort( 0x28 ),	/* Offset= 40 (768) */
/* 730 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 732 */	NdrFcShort( 0x10 ),	/* 16 */
/* 734 */	NdrFcShort( 0x0 ),	/* 0 */
/* 736 */	NdrFcShort( 0x6 ),	/* Offset= 6 (742) */
/* 738 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 740 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 742 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 744 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 746 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 748 */	NdrFcShort( 0x0 ),	/* 0 */
/* 750 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 752 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 754 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 756 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 760 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 762 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 764 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (730) */
/* 766 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 768 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 770 */	NdrFcShort( 0x8 ),	/* 8 */
/* 772 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (746) */
/* 774 */	NdrFcShort( 0x0 ),	/* Offset= 0 (774) */
/* 776 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 778 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 780 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 782 */	NdrFcShort( 0x2 ),	/* Offset= 2 (784) */
/* 784 */	
			0x12, 0x0,	/* FC_UP */
/* 786 */	NdrFcShort( 0x26 ),	/* Offset= 38 (824) */
/* 788 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 790 */	NdrFcShort( 0x8 ),	/* 8 */
/* 792 */	NdrFcShort( 0x0 ),	/* 0 */
/* 794 */	NdrFcShort( 0x4 ),	/* Offset= 4 (798) */
/* 796 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 798 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 800 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 802 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 804 */	NdrFcShort( 0x0 ),	/* 0 */
/* 806 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 808 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 810 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 812 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 816 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 818 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 820 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (788) */
/* 822 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 824 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 826 */	NdrFcShort( 0x8 ),	/* 8 */
/* 828 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (802) */
/* 830 */	NdrFcShort( 0x0 ),	/* Offset= 0 (830) */
/* 832 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 834 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 836 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 838 */	NdrFcShort( 0xfffffcc0 ),	/* Offset= -832 (6) */
/* 840 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 842 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 844 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 846 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 848 */	
			0x11, 0x0,	/* FC_RP */
/* 850 */	NdrFcShort( 0x2 ),	/* Offset= 2 (852) */
/* 852 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 854 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 856 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 858 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 860 */	NdrFcShort( 0xfffffcbc ),	/* Offset= -836 (24) */

			0x0
        }
    };

static const unsigned short netdfs_FormatStringOffsetTable[] =
    {
    0,
    32,
    94,
    144,
    206,
    268,
    324,
    368,
    412,
    468,
    512,
    598,
    666,
    722,
    772,
    816,
    872,
    928,
    984,
    1028,
    1102,
    1164,
    1226
    };


static const MIDL_STUB_DESC netdfs_StubDesc = 
    {
    (void *)& netdfs___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION netdfs_table[] =
    {
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE netdfs_DispatchTable = 
    {
    23,
    netdfs_table
    };

static const SERVER_ROUTINE netdfs_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)NetrDfsManagerGetVersion,
    (SERVER_ROUTINE)NetrDfsAdd,
    (SERVER_ROUTINE)NetrDfsRemove,
    (SERVER_ROUTINE)NetrDfsSetInfo,
    (SERVER_ROUTINE)NetrDfsGetInfo,
    (SERVER_ROUTINE)NetrDfsEnum,
    (SERVER_ROUTINE)NetrDfsMove,
    (SERVER_ROUTINE)NetrDfsRename,
    (SERVER_ROUTINE)NetrDfsManagerGetConfigInfo,
    (SERVER_ROUTINE)NetrDfsManagerSendSiteInfo,
    (SERVER_ROUTINE)NetrDfsAddFtRoot,
    (SERVER_ROUTINE)NetrDfsRemoveFtRoot,
    (SERVER_ROUTINE)NetrDfsAddStdRoot,
    (SERVER_ROUTINE)NetrDfsRemoveStdRoot,
    (SERVER_ROUTINE)NetrDfsManagerInitialize,
    (SERVER_ROUTINE)NetrDfsAddStdRootForced,
    (SERVER_ROUTINE)NetrDfsGetDcAddress,
    (SERVER_ROUTINE)NetrDfsSetDcAddress,
    (SERVER_ROUTINE)NetrDfsFlushFtTable,
    (SERVER_ROUTINE)NetrDfsAdd2,
    (SERVER_ROUTINE)NetrDfsRemove2,
    (SERVER_ROUTINE)NetrDfsEnumEx,
    (SERVER_ROUTINE)NetrDfsSetInfo2
    };

static const MIDL_SERVER_INFO netdfs_ServerInfo = 
    {
    &netdfs_StubDesc,
    netdfs_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    netdfs_FormatStringOffsetTable,
    0,
    0,
    0,
    0};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\enduser\inc\msber.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __MS_BER_H__
#define __MS_BER_H__

#include <msasn1.h>

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif

extern ASN1_PUBLIC int ASN1API ASN1BEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char32_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncDouble(ASN1encoding_t enc, ASN1uint32_t tag, double);
extern ASN1_PUBLIC int ASN1API ASN1BEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncS32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1int32_t);
extern ASN1_PUBLIC int ASN1API ASN1BEREncSX(ASN1encoding_t enc, ASN1uint32_t tag, ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1BEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncNull(ASN1encoding_t enc, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncObjectIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncObjectIdentifier2(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier2_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncRemoveZeroBits(ASN1uint32_t *, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncFlush(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1BEREncOpenType(ASN1encoding_t enc, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecExplicitTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1decoding_t *dd, ASN1octet_t **di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecEndOfContents(ASN1decoding_t dec, ASN1decoding_t dd, ASN1octet_t *di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOctetString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOctetString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBitString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBitString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecDouble(ASN1decoding_t dec, ASN1uint32_t tag, double *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecGeneralizedTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecNull(ASN1decoding_t dec, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BERDecObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecObjectIdentifier2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier2_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int8_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int32_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecSXVal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint8_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecUTCTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1utctime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecSkip(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1BERDecFlush(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOpenType(ASN1decoding_t dec, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOpenType2(ASN1decoding_t dec, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncCheck(ASN1encoding_t enc, ASN1uint32_t noctets);
extern ASN1_PUBLIC int ASN1API ASN1BEREncTag(ASN1encoding_t enc, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncExplicitTag(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t *pLengthOffset);
extern ASN1_PUBLIC int ASN1API ASN1BEREncEndOfContents(ASN1encoding_t enc, ASN1uint32_t LengthOffset);
extern ASN1_PUBLIC int ASN1API ASN1BEREncLength(ASN1encoding_t enc, ASN1uint32_t len);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCheck(ASN1decoding_t dec, ASN1uint32_t len);
extern ASN1_PUBLIC int ASN1API ASN1BERDecTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *constructed);
extern ASN1_PUBLIC int ASN1API ASN1BERDecLength(ASN1decoding_t dec, ASN1uint32_t *len, ASN1uint32_t *infinite);
extern ASN1_PUBLIC int ASN1API ASN1BERDecNotEndOfContents(ASN1decoding_t dec, ASN1octet_t *di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecPeekTag(ASN1decoding_t dec, ASN1uint32_t *tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncU32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncBool(ASN1encoding_t enc, ASN1uint32_t tag, ASN1bool_t);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBool(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bool_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncEoid(ASN1encoding_t enc, ASN1uint32_t tag, ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecEoid(ASN1decoding_t dec, ASN1uint32_t tag, ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDotVal2Eoid(ASN1encoding_t enc, char *pszDotVal, ASN1encodedOID_t *pOut);
extern ASN1_PUBLIC int ASN1API ASN1BEREoid2DotVal(ASN1decoding_t dec, ASN1encodedOID_t *pIn, char **ppszDotVal);
extern ASN1_PUBLIC void ASN1API ASN1BEREoid_free(ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value);
extern ASN1_PUBLIC int ASN1API ASN1BERDecUTF8String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1wstring_t *val);

/* CER variant of BER */

extern ASN1_PUBLIC int ASN1API ASN1CEREncCharString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncChar16String(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char16_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncChar32String(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char32_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncBitString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1CEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncOctetString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t, ASN1utctime_t *);

extern ASN1_PUBLIC int ASN1API ASN1CEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk);
extern ASN1_PUBLIC int ASN1API ASN1CEREncNewBlkElement(void *pBlk, ASN1encoding_t *enc2);
extern ASN1_PUBLIC int ASN1API ASN1CEREncFlushBlkElement(void *pBlk);
extern ASN1_PUBLIC int ASN1API ASN1CEREncEndBlk(void *pBlk);

/* DER variant of BER */

__inline int ASN1API ASN1DEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    return ASN1CEREncGeneralizedTime(enc, tag, val);
}
__inline int ASN1API ASN1DEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *val)
{
    return ASN1CEREncUTCTime(enc, tag, val);
}

__inline int ASN1API ASN1DEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk)
{
    return ASN1CEREncBeginBlk(enc, eBlkType, ppBlk);
}
__inline int ASN1API ASN1DEREncNewBlkElement(void *pBlk, ASN1encoding_t *enc2)
{
    return ASN1CEREncNewBlkElement(pBlk, enc2);
}
__inline int ASN1API ASN1DEREncFlushBlkElement(void *pBlk)
{
    return ASN1CEREncFlushBlkElement(pBlk);
}
__inline int ASN1API ASN1DEREncEndBlk(void *pBlk)
{
    return ASN1CEREncEndBlk(pBlk);
}

__inline int ASN1API ASN1DEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char_t *val)
{
    return ASN1BEREncCharString(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char16_t *val)
{
    return ASN1BEREncChar16String(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char32_t *val)
{
    return ASN1BEREncChar32String(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    return ASN1BEREncBitString(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t val)
{
    return ASN1BEREncZeroMultibyteString(enc, tag, val);
}
__inline int ASN1API ASN1DEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1BEREncMultibyteString(enc, tag, val);
}
__inline int ASN1API ASN1DEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    return ASN1BEREncOctetString(enc, tag, len, val);
}

__inline int ASN1API ASN1DEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value)
{
    return ASN1BEREncUTF8String(enc, tag, length, value);
}
__inline int ASN1API ASN1CEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value)
{
    return ASN1BEREncUTF8String(enc, tag, length, value);
}


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

extern ASN1_PUBLIC int ASN1API ASN1BEREncEmbeddedPdv(ASN1encoding_t enc, ASN1uint32_t tag, ASN1embeddedpdv_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncExternal(ASN1encoding_t enc, ASN1uint32_t tag, ASN1external_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncCharacterString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1characterstring_t *);

extern ASN1_PUBLIC int ASN1API ASN1BERDecEmbeddedPdv(ASN1decoding_t dec, ASN1uint32_t tag, ASN1embeddedpdv_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecExternal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1external_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCharacterString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1characterstring_t *);

#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End 8-byte packing */

#endif // __MS_BER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\enduser\inc\msper.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __MS_PER_H__
#define __MS_PER_H__

#include <msasn1.h>

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif

extern ASN1_PUBLIC int ASN1API ASN1PEREncZero(ASN1encoding_t enc, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBit(ASN1encoding_t enc, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBitVal(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBitIntx(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBits(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncNormallySmallBits(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctets(ASN1encoding_t enc, ASN1uint32_t noctets, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncRemoveZeroBits(ASN1uint32_t *nbits, ASN1octet_t *val, ASN1uint32_t minlen);
extern ASN1_PUBLIC int ASN1API ASN1PEREncNormallySmall(ASN1encoding_t enc, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncTableCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncTableChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncTableChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedTableCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedTableChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedTableChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedIntx(ASN1encoding_t enc, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedUIntx(ASN1encoding_t enc, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmentedLength(ASN1uint32_t *len, ASN1encoding_t enc, ASN1uint32_t nitems);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFragmented(ASN1encoding_t enc, ASN1uint32_t nitems, ASN1octet_t *val, ASN1uint32_t itemsize);
extern ASN1_PUBLIC int ASN1API ASN1PEREncObjectIdentifier(ASN1encoding_t enc, ASN1objectidentifier_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncObjectIdentifier2(ASN1encoding_t enc, ASN1objectidentifier2_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncDouble(ASN1encoding_t enc, double d);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFlush(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1PEREncFlushFragmentedToParent(ASN1encoding_t enc);
extern ASN1_PUBLIC void ASN1API ASN1PEREncAlignment(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1PEREncMultibyteString(ASN1encoding_t enc, ASN1char_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncGeneralizedTime(ASN1encoding_t enc, ASN1generalizedtime_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncUTCTime(ASN1encoding_t dec, ASN1utctime_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCheckExtensions(ASN1uint32_t nbits, ASN1octet_t *val);

extern ASN1_PUBLIC int ASN1API ASN1PERDecBit(ASN1decoding_t dec, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecU32Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecU16Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint16_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecU8Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint8_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUXVal(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecS32Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecS16Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int16_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecS8Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int8_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSXVal(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecN32Val(ASN1decoding_t dec, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecN16Val(ASN1decoding_t dec, ASN1uint16_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecN8Val(ASN1decoding_t dec, ASN1uint8_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecNXVal(ASN1decoding_t dec, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmented(ASN1decoding_t dec, ASN1uint32_t *nitems, ASN1octet_t **val, ASN1uint32_t itemsize);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFlush(ASN1decoding_t dec);
extern ASN1_PUBLIC void ASN1API ASN1PERDecAlignment(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1PERDecExtension(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecNormallySmallExtension(ASN1decoding_t dec, ASN1uint32_t *nextensions, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecBits(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t **val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecDouble(ASN1decoding_t dec, double *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecBitIntx(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecTableCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecTableCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecTableChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecTableChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroTableCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroTableCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroTableChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecZeroTableChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedIntx(ASN1decoding_t dec, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedUIntx(ASN1decoding_t dec, ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedExtension(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedLength(ASN1decoding_t dec, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecObjectIdentifier2(ASN1decoding_t dec, ASN1objectidentifier2_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedCharString(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedChar16String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char16_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedChar32String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char32_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroCharString(ASN1decoding_t dec, ASN1char_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroChar16String(ASN1decoding_t dec, ASN1char16_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroChar32String(ASN1decoding_t dec, ASN1char32_t **val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedTableCharString(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedTableChar16String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedTableChar32String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroTableCharString(ASN1decoding_t dec, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroTableChar16String(ASN1decoding_t dec, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecFragmentedZeroTableChar32String(ASN1decoding_t dec, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PERDecMultibyteString(ASN1decoding_t dec, ASN1char_t **val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecGeneralizedTime(ASN1decoding_t dec, ASN1generalizedtime_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUTCTime(ASN1decoding_t dec, ASN1utctime_t *val, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipBits(ASN1decoding_t dec, ASN1uint32_t nbits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipFragmented(ASN1decoding_t dec, ASN1uint32_t itemsize);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipNormallySmall(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipNormallySmallExtension(ASN1decoding_t dec, ASN1uint32_t *nextensions);

extern ASN1_PUBLIC int ASN1API ASN1PEREncInteger(ASN1encoding_t enc, ASN1int32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecInteger(ASN1decoding_t dec, ASN1int32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncUnsignedInteger(ASN1encoding_t enc, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUnsignedInteger(ASN1decoding_t dec, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncUnsignedShort(ASN1encoding_t enc, ASN1uint32_t val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUnsignedShort(ASN1decoding_t dec, ASN1uint16_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncBoolean(ASN1encoding_t enc, ASN1bool_t val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecBoolean(ASN1decoding_t dec, ASN1bool_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncExtensionBitClear(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1PEREncExtensionBitSet(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1PEREncSimpleChoice(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSimpleChoice(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncSimpleChoiceEx(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSimpleChoiceEx(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits);
extern ASN1_PUBLIC int ASN1API ASN1PEREncComplexChoice(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits, ASN1choice_t ExtensionChoice);
extern ASN1_PUBLIC int ASN1API ASN1PERDecComplexChoice(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits, ASN1choice_t ExtensionChoice);

/* unconstrained */
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_NoSize(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_NoSize(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr);

/* fixed-array */
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_FixedSize(ASN1encoding_t enc, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLimit);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_FixedSize(ASN1decoding_t dec, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLimit);
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_VarSize(ASN1encoding_t enc, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_VarSize(ASN1decoding_t dec, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);

/* unbounded */
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_FixedSizeEx(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLimit);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_FixedSizeEx(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLimit);
extern ASN1_PUBLIC int ASN1API ASN1PEREncOctetString_VarSizeEx(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecOctetString_VarSizeEx(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);

typedef int (ASN1CALL *ASN1iterator_encfn) (ASN1encoding_t, ASN1iterator_t *);
typedef int (ASN1CALL *ASN1iterator_decfn) (ASN1decoding_t, ASN1iterator_t *);
typedef int (ASN1CALL *ASN1iterator_freefn) (ASN1iterator_t *);
extern ASN1_PUBLIC int ASN1API ASN1PEREncSeqOf_NoSize(ASN1encoding_t enc, ASN1iterator_t **val, ASN1iterator_encfn pfnIterator);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSeqOf_NoSize(ASN1decoding_t dec, ASN1iterator_t **val, ASN1iterator_decfn pfnIterator, ASN1uint32_t cbElementSize);
extern ASN1_PUBLIC int ASN1API ASN1PEREncSeqOf_VarSize(ASN1encoding_t enc, ASN1iterator_t **val, ASN1iterator_encfn pfnIterator, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSeqOf_VarSize(ASN1decoding_t dec, ASN1iterator_t **val, ASN1iterator_decfn pfnIterator, ASN1uint32_t cbElementSize, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);
extern ASN1_PUBLIC void ASN1API ASN1PERFreeSeqOf(ASN1iterator_t **val, ASN1iterator_freefn pfnIterator);

extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipNormallySmallExtensionFragmented(ASN1decoding_t dec);
__inline int ASN1PERDecExtensionBit(ASN1decoding_t dec, ASN1uint32_t *val)
{
    return ASN1PERDecBit(dec, val);
}


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

extern ASN1_PUBLIC int ASN1API ASN1PEREncCheckTableCharString(ASN1uint32_t nchars, ASN1char_t *val, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCheckTableChar16String(ASN1uint32_t nchars, ASN1char16_t *val, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCheckTableChar32String(ASN1uint32_t nchars, ASN1char32_t *val, ASN1stringtable_t *table);

extern ASN1_PUBLIC int ASN1API ASN1PEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t nchars, WCHAR *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUTF8String(ASN1decoding_t dec, ASN1uint32_t nchars, WCHAR **val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUTF8StringEx(ASN1decoding_t dec, ASN1uint32_t *nchars, WCHAR **val);

extern ASN1_PUBLIC int ASN1API ASN1PEREncExternal(ASN1encoding_t enc, ASN1external_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncEmbeddedPdv(ASN1encoding_t enc, ASN1embeddedpdv_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncEmbeddedPdvOpt(ASN1encoding_t enc, ASN1embeddedpdv_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCharacterString(ASN1encoding_t enc, ASN1characterstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCharacterStringOpt(ASN1encoding_t enc, ASN1characterstring_t *val);

extern ASN1_PUBLIC int ASN1API ASN1PERDecExternal(ASN1decoding_t dec, ASN1external_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecEmbeddedPdv(ASN1decoding_t dec, ASN1embeddedpdv_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecEmbeddedPdvOpt(ASN1decoding_t dec, ASN1embeddedpdv_t *val, ASN1objectidentifier_t *abstract, ASN1objectidentifier_t *transfer);
extern ASN1_PUBLIC int ASN1API ASN1PERDecCharacterString(ASN1decoding_t dec, ASN1characterstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecCharacterStringOpt(ASN1decoding_t dec, ASN1characterstring_t *val, ASN1objectidentifier_t *abstract, ASN1objectidentifier_t *transfer);

#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End 8-byte packing */

#endif // __MS_PER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\inetcore\inc\dxtransp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for dxtransp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxtransp_h__
#define __dxtransp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDXRasterizer_FWD_DEFINED__
#define __IDXRasterizer_FWD_DEFINED__
typedef interface IDXRasterizer IDXRasterizer;
#endif 	/* __IDXRasterizer_FWD_DEFINED__ */


#ifndef __IDXTLabel_FWD_DEFINED__
#define __IDXTLabel_FWD_DEFINED__
typedef interface IDXTLabel IDXTLabel;
#endif 	/* __IDXTLabel_FWD_DEFINED__ */


#ifndef __IDX2DDebug_FWD_DEFINED__
#define __IDX2DDebug_FWD_DEFINED__
typedef interface IDX2DDebug IDX2DDebug;
#endif 	/* __IDX2DDebug_FWD_DEFINED__ */


#ifndef __IDX2D_FWD_DEFINED__
#define __IDX2D_FWD_DEFINED__
typedef interface IDX2D IDX2D;
#endif 	/* __IDX2D_FWD_DEFINED__ */


#ifndef __IDXGradient2_FWD_DEFINED__
#define __IDXGradient2_FWD_DEFINED__
typedef interface IDXGradient2 IDXGradient2;
#endif 	/* __IDXGradient2_FWD_DEFINED__ */


#ifndef __IDXTFilterBehavior_FWD_DEFINED__
#define __IDXTFilterBehavior_FWD_DEFINED__
typedef interface IDXTFilterBehavior IDXTFilterBehavior;
#endif 	/* __IDXTFilterBehavior_FWD_DEFINED__ */


#ifndef __IDXTFilterBehaviorSite_FWD_DEFINED__
#define __IDXTFilterBehaviorSite_FWD_DEFINED__
typedef interface IDXTFilterBehaviorSite IDXTFilterBehaviorSite;
#endif 	/* __IDXTFilterBehaviorSite_FWD_DEFINED__ */


#ifndef __IDXTFilterCollection_FWD_DEFINED__
#define __IDXTFilterCollection_FWD_DEFINED__
typedef interface IDXTFilterCollection IDXTFilterCollection;
#endif 	/* __IDXTFilterCollection_FWD_DEFINED__ */


#ifndef __IDXTFilter_FWD_DEFINED__
#define __IDXTFilter_FWD_DEFINED__
typedef interface IDXTFilter IDXTFilter;
#endif 	/* __IDXTFilter_FWD_DEFINED__ */


#ifndef __IDXTFilterController_FWD_DEFINED__
#define __IDXTFilterController_FWD_DEFINED__
typedef interface IDXTFilterController IDXTFilterController;
#endif 	/* __IDXTFilterController_FWD_DEFINED__ */


#ifndef __IDXTRedirectFilterInit_FWD_DEFINED__
#define __IDXTRedirectFilterInit_FWD_DEFINED__
typedef interface IDXTRedirectFilterInit IDXTRedirectFilterInit;
#endif 	/* __IDXTRedirectFilterInit_FWD_DEFINED__ */


#ifndef __IDXTClipOrigin_FWD_DEFINED__
#define __IDXTClipOrigin_FWD_DEFINED__
typedef interface IDXTClipOrigin IDXTClipOrigin;
#endif 	/* __IDXTClipOrigin_FWD_DEFINED__ */


#ifndef __DXTLabel_FWD_DEFINED__
#define __DXTLabel_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTLabel DXTLabel;
#else
typedef struct DXTLabel DXTLabel;
#endif /* __cplusplus */

#endif 	/* __DXTLabel_FWD_DEFINED__ */


#ifndef __DXRasterizer_FWD_DEFINED__
#define __DXRasterizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXRasterizer DXRasterizer;
#else
typedef struct DXRasterizer DXRasterizer;
#endif /* __cplusplus */

#endif 	/* __DXRasterizer_FWD_DEFINED__ */


#ifndef __DX2D_FWD_DEFINED__
#define __DX2D_FWD_DEFINED__

#ifdef __cplusplus
typedef class DX2D DX2D;
#else
typedef struct DX2D DX2D;
#endif /* __cplusplus */

#endif 	/* __DX2D_FWD_DEFINED__ */


#ifndef __DXTFilterBehavior_FWD_DEFINED__
#define __DXTFilterBehavior_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTFilterBehavior DXTFilterBehavior;
#else
typedef struct DXTFilterBehavior DXTFilterBehavior;
#endif /* __cplusplus */

#endif 	/* __DXTFilterBehavior_FWD_DEFINED__ */


#ifndef __DXTFilterFactory_FWD_DEFINED__
#define __DXTFilterFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTFilterFactory DXTFilterFactory;
#else
typedef struct DXTFilterFactory DXTFilterFactory;
#endif /* __cplusplus */

#endif 	/* __DXTFilterFactory_FWD_DEFINED__ */


#ifndef __DXTFilterCollection_FWD_DEFINED__
#define __DXTFilterCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTFilterCollection DXTFilterCollection;
#else
typedef struct DXTFilterCollection DXTFilterCollection;
#endif /* __cplusplus */

#endif 	/* __DXTFilterCollection_FWD_DEFINED__ */


/* header files for imported files */
#include "dxtrans.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_dxtransp_0000 */
/* [local] */ 








typedef 
enum DXRASTERFILL
    {	DXRASTER_PEN	= 0,
	DXRASTER_BRUSH	= 1,
	DXRASTER_BACKGROUND	= 2
    } 	DXRASTERFILL;

typedef struct DXRASTERSCANINFO
    {
    ULONG ulIndex;
    ULONG Row;
    const BYTE *pWeights;
    const DXRUNINFO *pRunInfo;
    ULONG cRunInfo;
    } 	DXRASTERSCANINFO;

typedef struct DXRASTERPOINTINFO
    {
    DXOVERSAMPLEDESC Pixel;
    ULONG ulIndex;
    BYTE Weight;
    } 	DXRASTERPOINTINFO;

typedef struct DXRASTERRECTINFO
    {
    ULONG ulIndex;
    RECT Rect;
    BYTE Weight;
    } 	DXRASTERRECTINFO;



extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0000_v0_0_s_ifspec;

#ifndef __IDXRasterizer_INTERFACE_DEFINED__
#define __IDXRasterizer_INTERFACE_DEFINED__

/* interface IDXRasterizer */
/* [object][hidden][unique][uuid][local] */ 


EXTERN_C const IID IID_IDXRasterizer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B635-C37D-11d1-905E-00C04FD9189D")
    IDXRasterizer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSurface( 
            /* [in] */ IDXSurface *pDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [out] */ IDXSurface **ppDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFill( 
            /* [in] */ ULONG ulIndex,
            /* [in] */ IDXSurface *pSurface,
            /* [in] */ const POINT *ppt,
            /* [in] */ DXSAMPLE FillColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFill( 
            /* [in] */ ULONG ulIndex,
            /* [out] */ IDXSurface **ppSurface,
            /* [out] */ POINT *ppt,
            /* [out] */ DXSAMPLE *pFillColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginRendering( 
            /* [in] */ ULONG ulTimeOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndRendering( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderScan( 
            /* [in] */ const DXRASTERSCANINFO *pScanInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPixel( 
            /* [in] */ DXRASTERPOINTINFO *pPointInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FillRect( 
            /* [in] */ const DXRASTERRECTINFO *pRectInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBounds( 
            /* [out] */ DXBNDS *pBounds) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXRasterizerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXRasterizer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXRasterizer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXRasterizer * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSurface )( 
            IDXRasterizer * This,
            /* [in] */ IDXSurface *pDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurface )( 
            IDXRasterizer * This,
            /* [out] */ IDXSurface **ppDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE *SetFill )( 
            IDXRasterizer * This,
            /* [in] */ ULONG ulIndex,
            /* [in] */ IDXSurface *pSurface,
            /* [in] */ const POINT *ppt,
            /* [in] */ DXSAMPLE FillColor);
        
        HRESULT ( STDMETHODCALLTYPE *GetFill )( 
            IDXRasterizer * This,
            /* [in] */ ULONG ulIndex,
            /* [out] */ IDXSurface **ppSurface,
            /* [out] */ POINT *ppt,
            /* [out] */ DXSAMPLE *pFillColor);
        
        HRESULT ( STDMETHODCALLTYPE *BeginRendering )( 
            IDXRasterizer * This,
            /* [in] */ ULONG ulTimeOut);
        
        HRESULT ( STDMETHODCALLTYPE *EndRendering )( 
            IDXRasterizer * This);
        
        HRESULT ( STDMETHODCALLTYPE *RenderScan )( 
            IDXRasterizer * This,
            /* [in] */ const DXRASTERSCANINFO *pScanInfo);
        
        HRESULT ( STDMETHODCALLTYPE *SetPixel )( 
            IDXRasterizer * This,
            /* [in] */ DXRASTERPOINTINFO *pPointInfo);
        
        HRESULT ( STDMETHODCALLTYPE *FillRect )( 
            IDXRasterizer * This,
            /* [in] */ const DXRASTERRECTINFO *pRectInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetBounds )( 
            IDXRasterizer * This,
            /* [out] */ DXBNDS *pBounds);
        
        END_INTERFACE
    } IDXRasterizerVtbl;

    interface IDXRasterizer
    {
        CONST_VTBL struct IDXRasterizerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXRasterizer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXRasterizer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXRasterizer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXRasterizer_SetSurface(This,pDXSurface)	\
    (This)->lpVtbl -> SetSurface(This,pDXSurface)

#define IDXRasterizer_GetSurface(This,ppDXSurface)	\
    (This)->lpVtbl -> GetSurface(This,ppDXSurface)

#define IDXRasterizer_SetFill(This,ulIndex,pSurface,ppt,FillColor)	\
    (This)->lpVtbl -> SetFill(This,ulIndex,pSurface,ppt,FillColor)

#define IDXRasterizer_GetFill(This,ulIndex,ppSurface,ppt,pFillColor)	\
    (This)->lpVtbl -> GetFill(This,ulIndex,ppSurface,ppt,pFillColor)

#define IDXRasterizer_BeginRendering(This,ulTimeOut)	\
    (This)->lpVtbl -> BeginRendering(This,ulTimeOut)

#define IDXRasterizer_EndRendering(This)	\
    (This)->lpVtbl -> EndRendering(This)

#define IDXRasterizer_RenderScan(This,pScanInfo)	\
    (This)->lpVtbl -> RenderScan(This,pScanInfo)

#define IDXRasterizer_SetPixel(This,pPointInfo)	\
    (This)->lpVtbl -> SetPixel(This,pPointInfo)

#define IDXRasterizer_FillRect(This,pRectInfo)	\
    (This)->lpVtbl -> FillRect(This,pRectInfo)

#define IDXRasterizer_GetBounds(This,pBounds)	\
    (This)->lpVtbl -> GetBounds(This,pBounds)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXRasterizer_SetSurface_Proxy( 
    IDXRasterizer * This,
    /* [in] */ IDXSurface *pDXSurface);


void __RPC_STUB IDXRasterizer_SetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetSurface_Proxy( 
    IDXRasterizer * This,
    /* [out] */ IDXSurface **ppDXSurface);


void __RPC_STUB IDXRasterizer_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_SetFill_Proxy( 
    IDXRasterizer * This,
    /* [in] */ ULONG ulIndex,
    /* [in] */ IDXSurface *pSurface,
    /* [in] */ const POINT *ppt,
    /* [in] */ DXSAMPLE FillColor);


void __RPC_STUB IDXRasterizer_SetFill_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetFill_Proxy( 
    IDXRasterizer * This,
    /* [in] */ ULONG ulIndex,
    /* [out] */ IDXSurface **ppSurface,
    /* [out] */ POINT *ppt,
    /* [out] */ DXSAMPLE *pFillColor);


void __RPC_STUB IDXRasterizer_GetFill_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_BeginRendering_Proxy( 
    IDXRasterizer * This,
    /* [in] */ ULONG ulTimeOut);


void __RPC_STUB IDXRasterizer_BeginRendering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_EndRendering_Proxy( 
    IDXRasterizer * This);


void __RPC_STUB IDXRasterizer_EndRendering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_RenderScan_Proxy( 
    IDXRasterizer * This,
    /* [in] */ const DXRASTERSCANINFO *pScanInfo);


void __RPC_STUB IDXRasterizer_RenderScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_SetPixel_Proxy( 
    IDXRasterizer * This,
    /* [in] */ DXRASTERPOINTINFO *pPointInfo);


void __RPC_STUB IDXRasterizer_SetPixel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_FillRect_Proxy( 
    IDXRasterizer * This,
    /* [in] */ const DXRASTERRECTINFO *pRectInfo);


void __RPC_STUB IDXRasterizer_FillRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetBounds_Proxy( 
    IDXRasterizer * This,
    /* [out] */ DXBNDS *pBounds);


void __RPC_STUB IDXRasterizer_GetBounds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXRasterizer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtransp_0283 */
/* [local] */ 

typedef 
enum DX2DXFORMOPS
    {	DX2DXO_IDENTITY	= 0,
	DX2DXO_TRANSLATE	= DX2DXO_IDENTITY + 1,
	DX2DXO_SCALE	= DX2DXO_TRANSLATE + 1,
	DX2DXO_SCALE_AND_TRANS	= DX2DXO_SCALE + 1,
	DX2DXO_GENERAL	= DX2DXO_SCALE_AND_TRANS + 1,
	DX2DXO_GENERAL_AND_TRANS	= DX2DXO_GENERAL + 1
    } 	DX2DXFORMOPS;

typedef struct DX2DXFORM
    {
    FLOAT eM11;
    FLOAT eM12;
    FLOAT eM21;
    FLOAT eM22;
    FLOAT eDx;
    FLOAT eDy;
    DX2DXFORMOPS eOp;
    } 	DX2DXFORM;

typedef struct DX2DXFORM *PDX2DXFORM;

typedef 
enum DX2DPOLYDRAW
    {	DX2D_WINDING_FILL	= 1L << 0,
	DX2D_NO_FLATTEN	= 1L << 1,
	DX2D_DO_GRID_FIT	= 1L << 2,
	DX2D_IS_RECT	= 1L << 3,
	DX2D_STROKE	= 1L << 4,
	DX2D_FILL	= 1L << 5,
	DX2D_UNUSED	= 0xffffffc0
    } 	DX2DPOLYDRAW;

typedef struct DXFPOINT
    {
    FLOAT x;
    FLOAT y;
    } 	DXFPOINT;

typedef 
enum DX2DPEN
    {	DX2D_PEN_DEFAULT	= 0,
	DX2D_PEN_WIDTH_IN_DISPLAY_COORDS	= 1L << 0,
	DX2D_PEN_UNUSED	= 0xfffffffe
    } 	DX2DPEN;

typedef struct DXPEN
    {
    DXSAMPLE Color;
    float Width;
    DWORD Style;
    IDXSurface *pTexture;
    DXFPOINT TexturePos;
    DWORD dwFlags;
    } 	DXPEN;

typedef struct DXBRUSH
    {
    DXSAMPLE Color;
    IDXSurface *pTexture;
    DXFPOINT TexturePos;
    } 	DXBRUSH;

typedef 
enum DX2DGRADIENT
    {	DX2DGRAD_DEFAULT	= 0,
	DX2DGRAD_CLIPGRADIENT	= 1,
	DX2DGRAD_UNUSED	= 0xfffffffe
    } 	DX2DGRADIENT;

typedef 
enum DXLOGFONTENUM
    {	DXLF_HEIGHT	= 1,
	DXLF_WIDTH	= 2,
	DXLF_ESC	= 4,
	DXLF_ORIENTATION	= 8,
	DXLF_WEIGHT	= 16,
	DXLF_ITALIC	= 32,
	DXLF_UNDERLINE	= 64,
	DXLF_STRIKEOUT	= 128,
	DXLF_CHARSET	= 256,
	DXLF_OUTPREC	= 512,
	DXLF_CLIPPREC	= 1024,
	DXLF_QUALITY	= 2048,
	DXLF_PITCHANDFAM	= 4096,
	DXLF_FACENAME	= 8192,
	DXLF_ALL	= 0x3fff
    } 	DXLOGFONTENUM;

#ifndef _WINGDI_
typedef struct tagLOGFONTA
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    } 	LOGFONTA;

typedef struct tagLOGFONTW
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    } 	LOGFONTW;

typedef LOGFONTA LOGFONT;

#endif


extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0283_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0283_v0_0_s_ifspec;

#ifndef __IDXTLabel_INTERFACE_DEFINED__
#define __IDXTLabel_INTERFACE_DEFINED__

/* interface IDXTLabel */
/* [object][hidden][unique][uuid] */ 


EXTERN_C const IID IID_IDXTLabel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0C17F0E-AE41-11d1-9A3B-0000F8756A10")
    IDXTLabel : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFontHandle( 
            /* [in] */ HFONT hFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFontHandle( 
            /* [out] */ HFONT *phFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTextString( 
            /* [in] */ LPCWSTR pString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextString( 
            /* [out] */ LPWSTR *ppString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillColor( 
            /* [out] */ DXSAMPLE *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFillColor( 
            /* [in] */ DXSAMPLE newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackgroundColor( 
            /* [out] */ DXSAMPLE *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundColor( 
            /* [in] */ DXSAMPLE newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTexturePosition( 
            /* [out] */ long *px,
            /* [out] */ long *py) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTexturePosition( 
            /* [in] */ long x,
            /* [in] */ long y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMatrix( 
            /* [out] */ PDX2DXFORM pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMatrix( 
            /* [in] */ const PDX2DXFORM pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogfont( 
            /* [in] */ const LOGFONT *plf,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogfont( 
            /* [out] */ LOGFONT *plf,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteWithRasterizer( 
            /* [in] */ IDXRasterizer *pRasterizer,
            /* [in] */ const DXBNDS *pClipBnds,
            /* [in] */ const DXVEC *pPlacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBaselineOffset( 
            /* [out] */ long *px,
            /* [out] */ long *py,
            /* [out] */ long *pdx,
            /* [out] */ long *pdy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTLabelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTLabel * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTLabel * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTLabel * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFontHandle )( 
            IDXTLabel * This,
            /* [in] */ HFONT hFont);
        
        HRESULT ( STDMETHODCALLTYPE *GetFontHandle )( 
            IDXTLabel * This,
            /* [out] */ HFONT *phFont);
        
        HRESULT ( STDMETHODCALLTYPE *SetTextString )( 
            IDXTLabel * This,
            /* [in] */ LPCWSTR pString);
        
        HRESULT ( STDMETHODCALLTYPE *GetTextString )( 
            IDXTLabel * This,
            /* [out] */ LPWSTR *ppString);
        
        HRESULT ( STDMETHODCALLTYPE *GetFillColor )( 
            IDXTLabel * This,
            /* [out] */ DXSAMPLE *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetFillColor )( 
            IDXTLabel * This,
            /* [in] */ DXSAMPLE newVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackgroundColor )( 
            IDXTLabel * This,
            /* [out] */ DXSAMPLE *pVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackgroundColor )( 
            IDXTLabel * This,
            /* [in] */ DXSAMPLE newVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetTexturePosition )( 
            IDXTLabel * This,
            /* [out] */ long *px,
            /* [out] */ long *py);
        
        HRESULT ( STDMETHODCALLTYPE *SetTexturePosition )( 
            IDXTLabel * This,
            /* [in] */ long x,
            /* [in] */ long y);
        
        HRESULT ( STDMETHODCALLTYPE *GetMatrix )( 
            IDXTLabel * This,
            /* [out] */ PDX2DXFORM pXform);
        
        HRESULT ( STDMETHODCALLTYPE *SetMatrix )( 
            IDXTLabel * This,
            /* [in] */ const PDX2DXFORM pXform);
        
        HRESULT ( STDMETHODCALLTYPE *SetLogfont )( 
            IDXTLabel * This,
            /* [in] */ const LOGFONT *plf,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetLogfont )( 
            IDXTLabel * This,
            /* [out] */ LOGFONT *plf,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ExecuteWithRasterizer )( 
            IDXTLabel * This,
            /* [in] */ IDXRasterizer *pRasterizer,
            /* [in] */ const DXBNDS *pClipBnds,
            /* [in] */ const DXVEC *pPlacement);
        
        HRESULT ( STDMETHODCALLTYPE *GetBaselineOffset )( 
            IDXTLabel * This,
            /* [out] */ long *px,
            /* [out] */ long *py,
            /* [out] */ long *pdx,
            /* [out] */ long *pdy);
        
        END_INTERFACE
    } IDXTLabelVtbl;

    interface IDXTLabel
    {
        CONST_VTBL struct IDXTLabelVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTLabel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTLabel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTLabel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTLabel_SetFontHandle(This,hFont)	\
    (This)->lpVtbl -> SetFontHandle(This,hFont)

#define IDXTLabel_GetFontHandle(This,phFont)	\
    (This)->lpVtbl -> GetFontHandle(This,phFont)

#define IDXTLabel_SetTextString(This,pString)	\
    (This)->lpVtbl -> SetTextString(This,pString)

#define IDXTLabel_GetTextString(This,ppString)	\
    (This)->lpVtbl -> GetTextString(This,ppString)

#define IDXTLabel_GetFillColor(This,pVal)	\
    (This)->lpVtbl -> GetFillColor(This,pVal)

#define IDXTLabel_SetFillColor(This,newVal)	\
    (This)->lpVtbl -> SetFillColor(This,newVal)

#define IDXTLabel_GetBackgroundColor(This,pVal)	\
    (This)->lpVtbl -> GetBackgroundColor(This,pVal)

#define IDXTLabel_SetBackgroundColor(This,newVal)	\
    (This)->lpVtbl -> SetBackgroundColor(This,newVal)

#define IDXTLabel_GetTexturePosition(This,px,py)	\
    (This)->lpVtbl -> GetTexturePosition(This,px,py)

#define IDXTLabel_SetTexturePosition(This,x,y)	\
    (This)->lpVtbl -> SetTexturePosition(This,x,y)

#define IDXTLabel_GetMatrix(This,pXform)	\
    (This)->lpVtbl -> GetMatrix(This,pXform)

#define IDXTLabel_SetMatrix(This,pXform)	\
    (This)->lpVtbl -> SetMatrix(This,pXform)

#define IDXTLabel_SetLogfont(This,plf,dwFlags)	\
    (This)->lpVtbl -> SetLogfont(This,plf,dwFlags)

#define IDXTLabel_GetLogfont(This,plf,dwFlags)	\
    (This)->lpVtbl -> GetLogfont(This,plf,dwFlags)

#define IDXTLabel_ExecuteWithRasterizer(This,pRasterizer,pClipBnds,pPlacement)	\
    (This)->lpVtbl -> ExecuteWithRasterizer(This,pRasterizer,pClipBnds,pPlacement)

#define IDXTLabel_GetBaselineOffset(This,px,py,pdx,pdy)	\
    (This)->lpVtbl -> GetBaselineOffset(This,px,py,pdx,pdy)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTLabel_SetFontHandle_Proxy( 
    IDXTLabel * This,
    /* [in] */ HFONT hFont);


void __RPC_STUB IDXTLabel_SetFontHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetFontHandle_Proxy( 
    IDXTLabel * This,
    /* [out] */ HFONT *phFont);


void __RPC_STUB IDXTLabel_GetFontHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetTextString_Proxy( 
    IDXTLabel * This,
    /* [in] */ LPCWSTR pString);


void __RPC_STUB IDXTLabel_SetTextString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetTextString_Proxy( 
    IDXTLabel * This,
    /* [out] */ LPWSTR *ppString);


void __RPC_STUB IDXTLabel_GetTextString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetFillColor_Proxy( 
    IDXTLabel * This,
    /* [out] */ DXSAMPLE *pVal);


void __RPC_STUB IDXTLabel_GetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetFillColor_Proxy( 
    IDXTLabel * This,
    /* [in] */ DXSAMPLE newVal);


void __RPC_STUB IDXTLabel_SetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetBackgroundColor_Proxy( 
    IDXTLabel * This,
    /* [out] */ DXSAMPLE *pVal);


void __RPC_STUB IDXTLabel_GetBackgroundColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetBackgroundColor_Proxy( 
    IDXTLabel * This,
    /* [in] */ DXSAMPLE newVal);


void __RPC_STUB IDXTLabel_SetBackgroundColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetTexturePosition_Proxy( 
    IDXTLabel * This,
    /* [out] */ long *px,
    /* [out] */ long *py);


void __RPC_STUB IDXTLabel_GetTexturePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetTexturePosition_Proxy( 
    IDXTLabel * This,
    /* [in] */ long x,
    /* [in] */ long y);


void __RPC_STUB IDXTLabel_SetTexturePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetMatrix_Proxy( 
    IDXTLabel * This,
    /* [out] */ PDX2DXFORM pXform);


void __RPC_STUB IDXTLabel_GetMatrix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetMatrix_Proxy( 
    IDXTLabel * This,
    /* [in] */ const PDX2DXFORM pXform);


void __RPC_STUB IDXTLabel_SetMatrix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetLogfont_Proxy( 
    IDXTLabel * This,
    /* [in] */ const LOGFONT *plf,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXTLabel_SetLogfont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetLogfont_Proxy( 
    IDXTLabel * This,
    /* [out] */ LOGFONT *plf,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXTLabel_GetLogfont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_ExecuteWithRasterizer_Proxy( 
    IDXTLabel * This,
    /* [in] */ IDXRasterizer *pRasterizer,
    /* [in] */ const DXBNDS *pClipBnds,
    /* [in] */ const DXVEC *pPlacement);


void __RPC_STUB IDXTLabel_ExecuteWithRasterizer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetBaselineOffset_Proxy( 
    IDXTLabel * This,
    /* [out] */ long *px,
    /* [out] */ long *py,
    /* [out] */ long *pdx,
    /* [out] */ long *pdy);


void __RPC_STUB IDXTLabel_GetBaselineOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTLabel_INTERFACE_DEFINED__ */


#ifndef __IDX2DDebug_INTERFACE_DEFINED__
#define __IDX2DDebug_INTERFACE_DEFINED__

/* interface IDX2DDebug */
/* [object][hidden][unique][uuid][local] */ 


EXTERN_C const IID IID_IDX2DDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03BB2457-A279-11d1-81C6-0000F87557DB")
    IDX2DDebug : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDC( 
            HDC hDC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDC( 
            HDC *phDC) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDX2DDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDX2DDebug * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDX2DDebug * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDX2DDebug * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDC )( 
            IDX2DDebug * This,
            HDC hDC);
        
        HRESULT ( STDMETHODCALLTYPE *GetDC )( 
            IDX2DDebug * This,
            HDC *phDC);
        
        END_INTERFACE
    } IDX2DDebugVtbl;

    interface IDX2DDebug
    {
        CONST_VTBL struct IDX2DDebugVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDX2DDebug_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDX2DDebug_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDX2DDebug_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDX2DDebug_SetDC(This,hDC)	\
    (This)->lpVtbl -> SetDC(This,hDC)

#define IDX2DDebug_GetDC(This,phDC)	\
    (This)->lpVtbl -> GetDC(This,phDC)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDX2DDebug_SetDC_Proxy( 
    IDX2DDebug * This,
    HDC hDC);


void __RPC_STUB IDX2DDebug_SetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2DDebug_GetDC_Proxy( 
    IDX2DDebug * This,
    HDC *phDC);


void __RPC_STUB IDX2DDebug_GetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDX2DDebug_INTERFACE_DEFINED__ */


#ifndef __IDX2D_INTERFACE_DEFINED__
#define __IDX2D_INTERFACE_DEFINED__

/* interface IDX2D */
/* [object][hidden][unique][uuid][local] */ 


EXTERN_C const IID IID_IDX2D;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EFD02A9-A996-11d1-81C9-0000F87557DB")
    IDX2D : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTransformFactory( 
            IDXTransformFactory *pTransFact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransformFactory( 
            IDXTransformFactory **ppTransFact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSurface( 
            IUnknown *pSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            REFIID riid,
            void **ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClipRect( 
            RECT *pClipRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClipRect( 
            RECT *pClipRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWorldTransform( 
            const DX2DXFORM *pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWorldTransform( 
            DX2DXFORM *pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPen( 
            const DXPEN *pPen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPen( 
            DXPEN *pPen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBrush( 
            const DXBRUSH *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBrush( 
            DXBRUSH *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundBrush( 
            const DXBRUSH *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackgroundBrush( 
            DXBRUSH *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFont( 
            HFONT hFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFont( 
            HFONT *phFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Blt( 
            IUnknown *punkSrc,
            const RECT *pSrcRect,
            const POINT *pDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AAPolyDraw( 
            const DXFPOINT *pPos,
            const BYTE *pTypes,
            ULONG ulCount,
            ULONG SubSampRes,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AAText( 
            DXFPOINT Pos,
            LPWSTR pString,
            ULONG ulCount,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRadialGradientBrush( 
            /* [size_is][in] */ double *rgdblOffsets,
            /* [size_is][in] */ double *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinearGradientBrush( 
            /* [size_is][in] */ double *rgdblOffsets,
            /* [size_is][in] */ double *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDX2DVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDX2D * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDX2D * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDX2D * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetTransformFactory )( 
            IDX2D * This,
            IDXTransformFactory *pTransFact);
        
        HRESULT ( STDMETHODCALLTYPE *GetTransformFactory )( 
            IDX2D * This,
            IDXTransformFactory **ppTransFact);
        
        HRESULT ( STDMETHODCALLTYPE *SetSurface )( 
            IDX2D * This,
            IUnknown *pSurface);
        
        HRESULT ( STDMETHODCALLTYPE *GetSurface )( 
            IDX2D * This,
            REFIID riid,
            void **ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE *SetClipRect )( 
            IDX2D * This,
            RECT *pClipRect);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipRect )( 
            IDX2D * This,
            RECT *pClipRect);
        
        HRESULT ( STDMETHODCALLTYPE *SetWorldTransform )( 
            IDX2D * This,
            const DX2DXFORM *pXform);
        
        HRESULT ( STDMETHODCALLTYPE *GetWorldTransform )( 
            IDX2D * This,
            DX2DXFORM *pXform);
        
        HRESULT ( STDMETHODCALLTYPE *SetPen )( 
            IDX2D * This,
            const DXPEN *pPen);
        
        HRESULT ( STDMETHODCALLTYPE *GetPen )( 
            IDX2D * This,
            DXPEN *pPen);
        
        HRESULT ( STDMETHODCALLTYPE *SetBrush )( 
            IDX2D * This,
            const DXBRUSH *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE *GetBrush )( 
            IDX2D * This,
            DXBRUSH *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE *SetBackgroundBrush )( 
            IDX2D * This,
            const DXBRUSH *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE *GetBackgroundBrush )( 
            IDX2D * This,
            DXBRUSH *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE *SetFont )( 
            IDX2D * This,
            HFONT hFont);
        
        HRESULT ( STDMETHODCALLTYPE *GetFont )( 
            IDX2D * This,
            HFONT *phFont);
        
        HRESULT ( STDMETHODCALLTYPE *Blt )( 
            IDX2D * This,
            IUnknown *punkSrc,
            const RECT *pSrcRect,
            const POINT *pDest);
        
        HRESULT ( STDMETHODCALLTYPE *AAPolyDraw )( 
            IDX2D * This,
            const DXFPOINT *pPos,
            const BYTE *pTypes,
            ULONG ulCount,
            ULONG SubSampRes,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AAText )( 
            IDX2D * This,
            DXFPOINT Pos,
            LPWSTR pString,
            ULONG ulCount,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetRadialGradientBrush )( 
            IDX2D * This,
            /* [size_is][in] */ double *rgdblOffsets,
            /* [size_is][in] */ double *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM *pXform,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetLinearGradientBrush )( 
            IDX2D * This,
            /* [size_is][in] */ double *rgdblOffsets,
            /* [size_is][in] */ double *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM *pXform,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDX2DVtbl;

    interface IDX2D
    {
        CONST_VTBL struct IDX2DVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDX2D_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDX2D_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDX2D_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDX2D_SetTransformFactory(This,pTransFact)	\
    (This)->lpVtbl -> SetTransformFactory(This,pTransFact)

#define IDX2D_GetTransformFactory(This,ppTransFact)	\
    (This)->lpVtbl -> GetTransformFactory(This,ppTransFact)

#define IDX2D_SetSurface(This,pSurface)	\
    (This)->lpVtbl -> SetSurface(This,pSurface)

#define IDX2D_GetSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetSurface(This,riid,ppSurface)

#define IDX2D_SetClipRect(This,pClipRect)	\
    (This)->lpVtbl -> SetClipRect(This,pClipRect)

#define IDX2D_GetClipRect(This,pClipRect)	\
    (This)->lpVtbl -> GetClipRect(This,pClipRect)

#define IDX2D_SetWorldTransform(This,pXform)	\
    (This)->lpVtbl -> SetWorldTransform(This,pXform)

#define IDX2D_GetWorldTransform(This,pXform)	\
    (This)->lpVtbl -> GetWorldTransform(This,pXform)

#define IDX2D_SetPen(This,pPen)	\
    (This)->lpVtbl -> SetPen(This,pPen)

#define IDX2D_GetPen(This,pPen)	\
    (This)->lpVtbl -> GetPen(This,pPen)

#define IDX2D_SetBrush(This,pBrush)	\
    (This)->lpVtbl -> SetBrush(This,pBrush)

#define IDX2D_GetBrush(This,pBrush)	\
    (This)->lpVtbl -> GetBrush(This,pBrush)

#define IDX2D_SetBackgroundBrush(This,pBrush)	\
    (This)->lpVtbl -> SetBackgroundBrush(This,pBrush)

#define IDX2D_GetBackgroundBrush(This,pBrush)	\
    (This)->lpVtbl -> GetBackgroundBrush(This,pBrush)

#define IDX2D_SetFont(This,hFont)	\
    (This)->lpVtbl -> SetFont(This,hFont)

#define IDX2D_GetFont(This,phFont)	\
    (This)->lpVtbl -> GetFont(This,phFont)

#define IDX2D_Blt(This,punkSrc,pSrcRect,pDest)	\
    (This)->lpVtbl -> Blt(This,punkSrc,pSrcRect,pDest)

#define IDX2D_AAPolyDraw(This,pPos,pTypes,ulCount,SubSampRes,dwFlags)	\
    (This)->lpVtbl -> AAPolyDraw(This,pPos,pTypes,ulCount,SubSampRes,dwFlags)

#define IDX2D_AAText(This,Pos,pString,ulCount,dwFlags)	\
    (This)->lpVtbl -> AAText(This,Pos,pString,ulCount,dwFlags)

#define IDX2D_SetRadialGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetRadialGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#define IDX2D_SetLinearGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetLinearGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDX2D_SetTransformFactory_Proxy( 
    IDX2D * This,
    IDXTransformFactory *pTransFact);


void __RPC_STUB IDX2D_SetTransformFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetTransformFactory_Proxy( 
    IDX2D * This,
    IDXTransformFactory **ppTransFact);


void __RPC_STUB IDX2D_GetTransformFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetSurface_Proxy( 
    IDX2D * This,
    IUnknown *pSurface);


void __RPC_STUB IDX2D_SetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetSurface_Proxy( 
    IDX2D * This,
    REFIID riid,
    void **ppSurface);


void __RPC_STUB IDX2D_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetClipRect_Proxy( 
    IDX2D * This,
    RECT *pClipRect);


void __RPC_STUB IDX2D_SetClipRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetClipRect_Proxy( 
    IDX2D * This,
    RECT *pClipRect);


void __RPC_STUB IDX2D_GetClipRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetWorldTransform_Proxy( 
    IDX2D * This,
    const DX2DXFORM *pXform);


void __RPC_STUB IDX2D_SetWorldTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetWorldTransform_Proxy( 
    IDX2D * This,
    DX2DXFORM *pXform);


void __RPC_STUB IDX2D_GetWorldTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetPen_Proxy( 
    IDX2D * This,
    const DXPEN *pPen);


void __RPC_STUB IDX2D_SetPen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetPen_Proxy( 
    IDX2D * This,
    DXPEN *pPen);


void __RPC_STUB IDX2D_GetPen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetBrush_Proxy( 
    IDX2D * This,
    const DXBRUSH *pBrush);


void __RPC_STUB IDX2D_SetBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetBrush_Proxy( 
    IDX2D * This,
    DXBRUSH *pBrush);


void __RPC_STUB IDX2D_GetBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetBackgroundBrush_Proxy( 
    IDX2D * This,
    const DXBRUSH *pBrush);


void __RPC_STUB IDX2D_SetBackgroundBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetBackgroundBrush_Proxy( 
    IDX2D * This,
    DXBRUSH *pBrush);


void __RPC_STUB IDX2D_GetBackgroundBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetFont_Proxy( 
    IDX2D * This,
    HFONT hFont);


void __RPC_STUB IDX2D_SetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetFont_Proxy( 
    IDX2D * This,
    HFONT *phFont);


void __RPC_STUB IDX2D_GetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_Blt_Proxy( 
    IDX2D * This,
    IUnknown *punkSrc,
    const RECT *pSrcRect,
    const POINT *pDest);


void __RPC_STUB IDX2D_Blt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_AAPolyDraw_Proxy( 
    IDX2D * This,
    const DXFPOINT *pPos,
    const BYTE *pTypes,
    ULONG ulCount,
    ULONG SubSampRes,
    DWORD dwFlags);


void __RPC_STUB IDX2D_AAPolyDraw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_AAText_Proxy( 
    IDX2D * This,
    DXFPOINT Pos,
    LPWSTR pString,
    ULONG ulCount,
    DWORD dwFlags);


void __RPC_STUB IDX2D_AAText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetRadialGradientBrush_Proxy( 
    IDX2D * This,
    /* [size_is][in] */ double *rgdblOffsets,
    /* [size_is][in] */ double *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDX2D_SetRadialGradientBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetLinearGradientBrush_Proxy( 
    IDX2D * This,
    /* [size_is][in] */ double *rgdblOffsets,
    /* [size_is][in] */ double *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDX2D_SetLinearGradientBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDX2D_INTERFACE_DEFINED__ */


#ifndef __IDXGradient2_INTERFACE_DEFINED__
#define __IDXGradient2_INTERFACE_DEFINED__

/* interface IDXGradient2 */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXGradient2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d0ef2a80-61dc-11d2-b2eb-00a0c936b212")
    IDXGradient2 : public IDXGradient
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRadialGradient( 
            /* [size_is][in] */ double *rgdblOffsets,
            /* [size_is][in] */ double *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinearGradient( 
            /* [size_is][in] */ double *rgdblOffsets,
            /* [size_is][in] */ double *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGradient2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXGradient2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXGradient2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXGradient2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputSize )( 
            IDXGradient2 * This,
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect);
        
        HRESULT ( STDMETHODCALLTYPE *SetGradient )( 
            IDXGradient2 * This,
            DXSAMPLE StartColor,
            DXSAMPLE EndColor,
            BOOL bHorizontal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputSize )( 
            IDXGradient2 * This,
            /* [out] */ SIZE *pOutSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetRadialGradient )( 
            IDXGradient2 * This,
            /* [size_is][in] */ double *rgdblOffsets,
            /* [size_is][in] */ double *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM *pXform,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetLinearGradient )( 
            IDXGradient2 * This,
            /* [size_is][in] */ double *rgdblOffsets,
            /* [size_is][in] */ double *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM *pXform,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDXGradient2Vtbl;

    interface IDXGradient2
    {
        CONST_VTBL struct IDXGradient2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGradient2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXGradient2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXGradient2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXGradient2_SetOutputSize(This,OutSize,bMaintainAspect)	\
    (This)->lpVtbl -> SetOutputSize(This,OutSize,bMaintainAspect)


#define IDXGradient2_SetGradient(This,StartColor,EndColor,bHorizontal)	\
    (This)->lpVtbl -> SetGradient(This,StartColor,EndColor,bHorizontal)

#define IDXGradient2_GetOutputSize(This,pOutSize)	\
    (This)->lpVtbl -> GetOutputSize(This,pOutSize)


#define IDXGradient2_SetRadialGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetRadialGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#define IDXGradient2_SetLinearGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetLinearGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXGradient2_SetRadialGradient_Proxy( 
    IDXGradient2 * This,
    /* [size_is][in] */ double *rgdblOffsets,
    /* [size_is][in] */ double *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXGradient2_SetRadialGradient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXGradient2_SetLinearGradient_Proxy( 
    IDXGradient2 * This,
    /* [size_is][in] */ double *rgdblOffsets,
    /* [size_is][in] */ double *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXGradient2_SetLinearGradient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXGradient2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtransp_0287 */
/* [local] */ 

typedef 
enum DXTFILTERCAPS
    {	DXTFILTERCAPS_IDXSURFACE	= 1L << 0,
	DXTFILTERCAPS_IDXEFFECT	= 1L << 1,
	DXTFILTERCAPS_INPUT1REQ	= 1L << 2,
	DXTFILTERCAPS_INPUT2REQ	= 1L << 3,
	DXTFILTERCAPS_INPUT1OPT	= 1L << 4,
	DXTFILTERCAPS_INPUT2OPT	= 1L << 5,
	DXTFILTERCAPS_PRIV_MATRIX	= 1L << 6,
	DXTFILTERCAPS_MAX	= 1L << 7
    } 	DXTFILTERCAPS;

typedef void *HFILTER;

typedef 
enum DXT_FILTER_TYPE_FLAGS
    {	DXTFTF_INVALID	= 0,
	DXTFTF_CSS	= 1L << 0,
	DXTFTF_PRIVATE	= 1L << 1,
	DXTFTF_ALLMODIFIERS	= DXTFTF_CSS | DXTFTF_PRIVATE,
	DXTFTF_SURFACE	= 1L << 16,
	DXTFTF_ZEROINPUT	= 1L << 17,
	DXTFTF_FILTER	= 1L << 18,
	DXTFTF_ALLTYPES	= DXTFTF_SURFACE | DXTFTF_ZEROINPUT | DXTFTF_FILTER
    } 	DXT_FILTER_TYPE_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0287_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0287_v0_0_s_ifspec;

#ifndef __IDXTFilterBehavior_INTERFACE_DEFINED__
#define __IDXTFilterBehavior_INTERFACE_DEFINED__

/* interface IDXTFilterBehavior */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTFilterBehavior;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14D7DDDD-ACA2-4E45-9504-3808ABEB4F92")
    IDXTFilterBehavior : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            IDXTransformFactory *pDXTransformFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterCollection( 
            IDXTFilterCollection **ppDXTFilterCollection) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockFilterChainForEdit( 
            DWORD *pdwKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFilterFromBSTR( 
            const BSTR bstrFilterString,
            const DWORD dwFlags,
            DWORD *const pdwFilterType,
            HFILTER *const phFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyFilter( 
            HFILTER hFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockFilterChain( 
            DWORD dwKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTFilterBehaviorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTFilterBehavior * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTFilterBehavior * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTFilterBehavior * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDXTFilterBehavior * This,
            IDXTransformFactory *pDXTransformFactory);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterCollection )( 
            IDXTFilterBehavior * This,
            IDXTFilterCollection **ppDXTFilterCollection);
        
        HRESULT ( STDMETHODCALLTYPE *LockFilterChainForEdit )( 
            IDXTFilterBehavior * This,
            DWORD *pdwKey);
        
        HRESULT ( STDMETHODCALLTYPE *AddFilterFromBSTR )( 
            IDXTFilterBehavior * This,
            const BSTR bstrFilterString,
            const DWORD dwFlags,
            DWORD *const pdwFilterType,
            HFILTER *const phFilter);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyFilter )( 
            IDXTFilterBehavior * This,
            HFILTER hFilter);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockFilterChain )( 
            IDXTFilterBehavior * This,
            DWORD dwKey);
        
        END_INTERFACE
    } IDXTFilterBehaviorVtbl;

    interface IDXTFilterBehavior
    {
        CONST_VTBL struct IDXTFilterBehaviorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTFilterBehavior_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTFilterBehavior_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTFilterBehavior_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTFilterBehavior_Initialize(This,pDXTransformFactory)	\
    (This)->lpVtbl -> Initialize(This,pDXTransformFactory)

#define IDXTFilterBehavior_GetFilterCollection(This,ppDXTFilterCollection)	\
    (This)->lpVtbl -> GetFilterCollection(This,ppDXTFilterCollection)

#define IDXTFilterBehavior_LockFilterChainForEdit(This,pdwKey)	\
    (This)->lpVtbl -> LockFilterChainForEdit(This,pdwKey)

#define IDXTFilterBehavior_AddFilterFromBSTR(This,bstrFilterString,dwFlags,pdwFilterType,phFilter)	\
    (This)->lpVtbl -> AddFilterFromBSTR(This,bstrFilterString,dwFlags,pdwFilterType,phFilter)

#define IDXTFilterBehavior_DestroyFilter(This,hFilter)	\
    (This)->lpVtbl -> DestroyFilter(This,hFilter)

#define IDXTFilterBehavior_UnlockFilterChain(This,dwKey)	\
    (This)->lpVtbl -> UnlockFilterChain(This,dwKey)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTFilterBehavior_Initialize_Proxy( 
    IDXTFilterBehavior * This,
    IDXTransformFactory *pDXTransformFactory);


void __RPC_STUB IDXTFilterBehavior_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehavior_GetFilterCollection_Proxy( 
    IDXTFilterBehavior * This,
    IDXTFilterCollection **ppDXTFilterCollection);


void __RPC_STUB IDXTFilterBehavior_GetFilterCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehavior_LockFilterChainForEdit_Proxy( 
    IDXTFilterBehavior * This,
    DWORD *pdwKey);


void __RPC_STUB IDXTFilterBehavior_LockFilterChainForEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehavior_AddFilterFromBSTR_Proxy( 
    IDXTFilterBehavior * This,
    const BSTR bstrFilterString,
    const DWORD dwFlags,
    DWORD *const pdwFilterType,
    HFILTER *const phFilter);


void __RPC_STUB IDXTFilterBehavior_AddFilterFromBSTR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehavior_DestroyFilter_Proxy( 
    IDXTFilterBehavior * This,
    HFILTER hFilter);


void __RPC_STUB IDXTFilterBehavior_DestroyFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehavior_UnlockFilterChain_Proxy( 
    IDXTFilterBehavior * This,
    DWORD dwKey);


void __RPC_STUB IDXTFilterBehavior_UnlockFilterChain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTFilterBehavior_INTERFACE_DEFINED__ */


#ifndef __IDXTFilterBehaviorSite_INTERFACE_DEFINED__
#define __IDXTFilterBehaviorSite_INTERFACE_DEFINED__

/* interface IDXTFilterBehaviorSite */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTFilterBehaviorSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("909B23C2-9018-499f-A86D-4E7DA937E931")
    IDXTFilterBehaviorSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InvalidateElement( 
            BOOL fInvalidateSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateFilterChain( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteFilterChain( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FireOnFilterChangeEvent( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnFilterChangeStatus( 
            DXTFILTER_STATUS eStatusOld,
            DXTFILTER_STATUS eStatusNew) = 0;
        
        virtual void STDMETHODCALLTYPE OnFatalError( 
            HRESULT hrFatalError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTimer( 
            void **ppvTimer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnsureView( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTFilterBehaviorSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTFilterBehaviorSite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTFilterBehaviorSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTFilterBehaviorSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateElement )( 
            IDXTFilterBehaviorSite * This,
            BOOL fInvalidateSize);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateFilterChain )( 
            IDXTFilterBehaviorSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExecuteFilterChain )( 
            IDXTFilterBehaviorSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *FireOnFilterChangeEvent )( 
            IDXTFilterBehaviorSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnFilterChangeStatus )( 
            IDXTFilterBehaviorSite * This,
            DXTFILTER_STATUS eStatusOld,
            DXTFILTER_STATUS eStatusNew);
        
        void ( STDMETHODCALLTYPE *OnFatalError )( 
            IDXTFilterBehaviorSite * This,
            HRESULT hrFatalError);
        
        HRESULT ( STDMETHODCALLTYPE *GetTimer )( 
            IDXTFilterBehaviorSite * This,
            void **ppvTimer);
        
        HRESULT ( STDMETHODCALLTYPE *EnsureView )( 
            IDXTFilterBehaviorSite * This);
        
        END_INTERFACE
    } IDXTFilterBehaviorSiteVtbl;

    interface IDXTFilterBehaviorSite
    {
        CONST_VTBL struct IDXTFilterBehaviorSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTFilterBehaviorSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTFilterBehaviorSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTFilterBehaviorSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTFilterBehaviorSite_InvalidateElement(This,fInvalidateSize)	\
    (This)->lpVtbl -> InvalidateElement(This,fInvalidateSize)

#define IDXTFilterBehaviorSite_InvalidateFilterChain(This)	\
    (This)->lpVtbl -> InvalidateFilterChain(This)

#define IDXTFilterBehaviorSite_ExecuteFilterChain(This)	\
    (This)->lpVtbl -> ExecuteFilterChain(This)

#define IDXTFilterBehaviorSite_FireOnFilterChangeEvent(This)	\
    (This)->lpVtbl -> FireOnFilterChangeEvent(This)

#define IDXTFilterBehaviorSite_OnFilterChangeStatus(This,eStatusOld,eStatusNew)	\
    (This)->lpVtbl -> OnFilterChangeStatus(This,eStatusOld,eStatusNew)

#define IDXTFilterBehaviorSite_OnFatalError(This,hrFatalError)	\
    (This)->lpVtbl -> OnFatalError(This,hrFatalError)

#define IDXTFilterBehaviorSite_GetTimer(This,ppvTimer)	\
    (This)->lpVtbl -> GetTimer(This,ppvTimer)

#define IDXTFilterBehaviorSite_EnsureView(This)	\
    (This)->lpVtbl -> EnsureView(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTFilterBehaviorSite_InvalidateElement_Proxy( 
    IDXTFilterBehaviorSite * This,
    BOOL fInvalidateSize);


void __RPC_STUB IDXTFilterBehaviorSite_InvalidateElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehaviorSite_InvalidateFilterChain_Proxy( 
    IDXTFilterBehaviorSite * This);


void __RPC_STUB IDXTFilterBehaviorSite_InvalidateFilterChain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehaviorSite_ExecuteFilterChain_Proxy( 
    IDXTFilterBehaviorSite * This);


void __RPC_STUB IDXTFilterBehaviorSite_ExecuteFilterChain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehaviorSite_FireOnFilterChangeEvent_Proxy( 
    IDXTFilterBehaviorSite * This);


void __RPC_STUB IDXTFilterBehaviorSite_FireOnFilterChangeEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehaviorSite_OnFilterChangeStatus_Proxy( 
    IDXTFilterBehaviorSite * This,
    DXTFILTER_STATUS eStatusOld,
    DXTFILTER_STATUS eStatusNew);


void __RPC_STUB IDXTFilterBehaviorSite_OnFilterChangeStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXTFilterBehaviorSite_OnFatalError_Proxy( 
    IDXTFilterBehaviorSite * This,
    HRESULT hrFatalError);


void __RPC_STUB IDXTFilterBehaviorSite_OnFatalError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehaviorSite_GetTimer_Proxy( 
    IDXTFilterBehaviorSite * This,
    void **ppvTimer);


void __RPC_STUB IDXTFilterBehaviorSite_GetTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterBehaviorSite_EnsureView_Proxy( 
    IDXTFilterBehaviorSite * This);


void __RPC_STUB IDXTFilterBehaviorSite_EnsureView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTFilterBehaviorSite_INTERFACE_DEFINED__ */


#ifndef __IDXTFilterCollection_INTERFACE_DEFINED__
#define __IDXTFilterCollection_INTERFACE_DEFINED__

/* interface IDXTFilterCollection */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTFilterCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("22B07B33-8BFB-49d4-9B90-0938370C9019")
    IDXTFilterCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            const IDXTFilterBehavior *pDXTFilterBehavior) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFilter( 
            const BSTR bstrFilterString,
            const DWORD dwFlags,
            DWORD *const pdwFilterType,
            HFILTER *const phFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFilter( 
            const HFILTER hFilter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveFilters( 
            const DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterController( 
            const HFILTER hFilter,
            IDXTFilterController **const ppDXTFilterController) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTFilterCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTFilterCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTFilterCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTFilterCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IDXTFilterCollection * This,
            const IDXTFilterBehavior *pDXTFilterBehavior);
        
        HRESULT ( STDMETHODCALLTYPE *AddFilter )( 
            IDXTFilterCollection * This,
            const BSTR bstrFilterString,
            const DWORD dwFlags,
            DWORD *const pdwFilterType,
            HFILTER *const phFilter);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFilter )( 
            IDXTFilterCollection * This,
            const HFILTER hFilter);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveFilters )( 
            IDXTFilterCollection * This,
            const DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterController )( 
            IDXTFilterCollection * This,
            const HFILTER hFilter,
            IDXTFilterController **const ppDXTFilterController);
        
        END_INTERFACE
    } IDXTFilterCollectionVtbl;

    interface IDXTFilterCollection
    {
        CONST_VTBL struct IDXTFilterCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTFilterCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTFilterCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTFilterCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTFilterCollection_Init(This,pDXTFilterBehavior)	\
    (This)->lpVtbl -> Init(This,pDXTFilterBehavior)

#define IDXTFilterCollection_AddFilter(This,bstrFilterString,dwFlags,pdwFilterType,phFilter)	\
    (This)->lpVtbl -> AddFilter(This,bstrFilterString,dwFlags,pdwFilterType,phFilter)

#define IDXTFilterCollection_RemoveFilter(This,hFilter)	\
    (This)->lpVtbl -> RemoveFilter(This,hFilter)

#define IDXTFilterCollection_RemoveFilters(This,dwFlags)	\
    (This)->lpVtbl -> RemoveFilters(This,dwFlags)

#define IDXTFilterCollection_GetFilterController(This,hFilter,ppDXTFilterController)	\
    (This)->lpVtbl -> GetFilterController(This,hFilter,ppDXTFilterController)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTFilterCollection_Init_Proxy( 
    IDXTFilterCollection * This,
    const IDXTFilterBehavior *pDXTFilterBehavior);


void __RPC_STUB IDXTFilterCollection_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterCollection_AddFilter_Proxy( 
    IDXTFilterCollection * This,
    const BSTR bstrFilterString,
    const DWORD dwFlags,
    DWORD *const pdwFilterType,
    HFILTER *const phFilter);


void __RPC_STUB IDXTFilterCollection_AddFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterCollection_RemoveFilter_Proxy( 
    IDXTFilterCollection * This,
    const HFILTER hFilter);


void __RPC_STUB IDXTFilterCollection_RemoveFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterCollection_RemoveFilters_Proxy( 
    IDXTFilterCollection * This,
    const DWORD dwFlags);


void __RPC_STUB IDXTFilterCollection_RemoveFilters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterCollection_GetFilterController_Proxy( 
    IDXTFilterCollection * This,
    const HFILTER hFilter,
    IDXTFilterController **const ppDXTFilterController);


void __RPC_STUB IDXTFilterCollection_GetFilterController_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTFilterCollection_INTERFACE_DEFINED__ */


#ifndef __IDXTFilter_INTERFACE_DEFINED__
#define __IDXTFilter_INTERFACE_DEFINED__

/* interface IDXTFilter */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6187E5A2-A445-4608-8FC0-BE7A6C8DB386")
    IDXTFilter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IDXTransform *pDXTransform,
            /* [in] */ IDXSurfaceFactory *pDXSurfaceFactory,
            /* [in] */ IDXTFilterBehaviorSite *pDXTFilterBehaviorSite,
            /* [in] */ DWORD dwFilterCaps,
            /* [in] */ BOOL fUsesOldStyleFilterName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputSurface( 
            /* [in] */ IDXSurface *pDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputSurface( 
            /* [in] */ IDXSurface *pDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputSurface( 
            /* [out] */ IDXSurface **ppDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapBoundsIn2Out( 
            /* [in] */ DXBNDS *pbndsIn,
            /* [out][in] */ DXBNDS *pbndsOut,
            /* [in] */ BOOL fResetOutputSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapBoundsOut2In( 
            /* [in] */ DXBNDS *pbndsOut,
            /* [out][in] */ DXBNDS *pbndsIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ DXBNDS *pbndsPortion,
            /* [in] */ DXVEC *pvecPlacement,
            /* [in] */ BOOL fFireFilterChange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMiscFlags( 
            /* [in] */ DWORD dwMiscFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HitTest( 
            /* [in] */ const DXVEC *pvecOut,
            /* [out][in] */ BOOL *pfInactiveInputHit,
            /* [out][in] */ DXVEC *pvecIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsEnabled( void) = 0;
        
        virtual void STDMETHODCALLTYPE HardDisable( 
            HRESULT hrHardDisable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTFilter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTFilter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTFilter * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDXTFilter * This,
            /* [in] */ IDXTransform *pDXTransform,
            /* [in] */ IDXSurfaceFactory *pDXSurfaceFactory,
            /* [in] */ IDXTFilterBehaviorSite *pDXTFilterBehaviorSite,
            /* [in] */ DWORD dwFilterCaps,
            /* [in] */ BOOL fUsesOldStyleFilterName);
        
        HRESULT ( STDMETHODCALLTYPE *SetInputSurface )( 
            IDXTFilter * This,
            /* [in] */ IDXSurface *pDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputSurface )( 
            IDXTFilter * This,
            /* [in] */ IDXSurface *pDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputSurface )( 
            IDXTFilter * This,
            /* [out] */ IDXSurface **ppDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE *MapBoundsIn2Out )( 
            IDXTFilter * This,
            /* [in] */ DXBNDS *pbndsIn,
            /* [out][in] */ DXBNDS *pbndsOut,
            /* [in] */ BOOL fResetOutputSize);
        
        HRESULT ( STDMETHODCALLTYPE *MapBoundsOut2In )( 
            IDXTFilter * This,
            /* [in] */ DXBNDS *pbndsOut,
            /* [out][in] */ DXBNDS *pbndsIn);
        
        HRESULT ( STDMETHODCALLTYPE *Execute )( 
            IDXTFilter * This,
            /* [in] */ DXBNDS *pbndsPortion,
            /* [in] */ DXVEC *pvecPlacement,
            /* [in] */ BOOL fFireFilterChange);
        
        HRESULT ( STDMETHODCALLTYPE *SetMiscFlags )( 
            IDXTFilter * This,
            /* [in] */ DWORD dwMiscFlags);
        
        HRESULT ( STDMETHODCALLTYPE *HitTest )( 
            IDXTFilter * This,
            /* [in] */ const DXVEC *pvecOut,
            /* [out][in] */ BOOL *pfInactiveInputHit,
            /* [out][in] */ DXVEC *pvecIn);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            IDXTFilter * This);
        
        BOOL ( STDMETHODCALLTYPE *IsEnabled )( 
            IDXTFilter * This);
        
        void ( STDMETHODCALLTYPE *HardDisable )( 
            IDXTFilter * This,
            HRESULT hrHardDisable);
        
        END_INTERFACE
    } IDXTFilterVtbl;

    interface IDXTFilter
    {
        CONST_VTBL struct IDXTFilterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTFilter_Initialize(This,pDXTransform,pDXSurfaceFactory,pDXTFilterBehaviorSite,dwFilterCaps,fUsesOldStyleFilterName)	\
    (This)->lpVtbl -> Initialize(This,pDXTransform,pDXSurfaceFactory,pDXTFilterBehaviorSite,dwFilterCaps,fUsesOldStyleFilterName)

#define IDXTFilter_SetInputSurface(This,pDXSurface)	\
    (This)->lpVtbl -> SetInputSurface(This,pDXSurface)

#define IDXTFilter_SetOutputSurface(This,pDXSurface)	\
    (This)->lpVtbl -> SetOutputSurface(This,pDXSurface)

#define IDXTFilter_GetOutputSurface(This,ppDXSurface)	\
    (This)->lpVtbl -> GetOutputSurface(This,ppDXSurface)

#define IDXTFilter_MapBoundsIn2Out(This,pbndsIn,pbndsOut,fResetOutputSize)	\
    (This)->lpVtbl -> MapBoundsIn2Out(This,pbndsIn,pbndsOut,fResetOutputSize)

#define IDXTFilter_MapBoundsOut2In(This,pbndsOut,pbndsIn)	\
    (This)->lpVtbl -> MapBoundsOut2In(This,pbndsOut,pbndsIn)

#define IDXTFilter_Execute(This,pbndsPortion,pvecPlacement,fFireFilterChange)	\
    (This)->lpVtbl -> Execute(This,pbndsPortion,pvecPlacement,fFireFilterChange)

#define IDXTFilter_SetMiscFlags(This,dwMiscFlags)	\
    (This)->lpVtbl -> SetMiscFlags(This,dwMiscFlags)

#define IDXTFilter_HitTest(This,pvecOut,pfInactiveInputHit,pvecIn)	\
    (This)->lpVtbl -> HitTest(This,pvecOut,pfInactiveInputHit,pvecIn)

#define IDXTFilter_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define IDXTFilter_IsEnabled(This)	\
    (This)->lpVtbl -> IsEnabled(This)

#define IDXTFilter_HardDisable(This,hrHardDisable)	\
    (This)->lpVtbl -> HardDisable(This,hrHardDisable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTFilter_Initialize_Proxy( 
    IDXTFilter * This,
    /* [in] */ IDXTransform *pDXTransform,
    /* [in] */ IDXSurfaceFactory *pDXSurfaceFactory,
    /* [in] */ IDXTFilterBehaviorSite *pDXTFilterBehaviorSite,
    /* [in] */ DWORD dwFilterCaps,
    /* [in] */ BOOL fUsesOldStyleFilterName);


void __RPC_STUB IDXTFilter_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_SetInputSurface_Proxy( 
    IDXTFilter * This,
    /* [in] */ IDXSurface *pDXSurface);


void __RPC_STUB IDXTFilter_SetInputSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_SetOutputSurface_Proxy( 
    IDXTFilter * This,
    /* [in] */ IDXSurface *pDXSurface);


void __RPC_STUB IDXTFilter_SetOutputSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_GetOutputSurface_Proxy( 
    IDXTFilter * This,
    /* [out] */ IDXSurface **ppDXSurface);


void __RPC_STUB IDXTFilter_GetOutputSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_MapBoundsIn2Out_Proxy( 
    IDXTFilter * This,
    /* [in] */ DXBNDS *pbndsIn,
    /* [out][in] */ DXBNDS *pbndsOut,
    /* [in] */ BOOL fResetOutputSize);


void __RPC_STUB IDXTFilter_MapBoundsIn2Out_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_MapBoundsOut2In_Proxy( 
    IDXTFilter * This,
    /* [in] */ DXBNDS *pbndsOut,
    /* [out][in] */ DXBNDS *pbndsIn);


void __RPC_STUB IDXTFilter_MapBoundsOut2In_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_Execute_Proxy( 
    IDXTFilter * This,
    /* [in] */ DXBNDS *pbndsPortion,
    /* [in] */ DXVEC *pvecPlacement,
    /* [in] */ BOOL fFireFilterChange);


void __RPC_STUB IDXTFilter_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_SetMiscFlags_Proxy( 
    IDXTFilter * This,
    /* [in] */ DWORD dwMiscFlags);


void __RPC_STUB IDXTFilter_SetMiscFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_HitTest_Proxy( 
    IDXTFilter * This,
    /* [in] */ const DXVEC *pvecOut,
    /* [out][in] */ BOOL *pfInactiveInputHit,
    /* [out][in] */ DXVEC *pvecIn);


void __RPC_STUB IDXTFilter_HitTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilter_Detach_Proxy( 
    IDXTFilter * This);


void __RPC_STUB IDXTFilter_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IDXTFilter_IsEnabled_Proxy( 
    IDXTFilter * This);


void __RPC_STUB IDXTFilter_IsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXTFilter_HardDisable_Proxy( 
    IDXTFilter * This,
    HRESULT hrHardDisable);


void __RPC_STUB IDXTFilter_HardDisable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTFilter_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtransp_0291 */
/* [local] */ 

typedef 
enum DXT_QUICK_APPLY_TYPE
    {	DXTQAT_TransitionIn	= 0,
	DXTQAT_TransitionOut	= DXTQAT_TransitionIn + 1,
	DXTQAT_TransitionFromElement	= DXTQAT_TransitionOut + 1,
	DXTQAT_TransitionToElement	= DXTQAT_TransitionFromElement + 1
    } 	DXT_QUICK_APPLY_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0291_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtransp_0291_v0_0_s_ifspec;

#ifndef __IDXTFilterController_INTERFACE_DEFINED__
#define __IDXTFilterController_INTERFACE_DEFINED__

/* interface IDXTFilterController */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTFilterController;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5CF315F2-273D-47B6-B9ED-F75DC3B0150B")
    IDXTFilterController : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProgress( 
            float flProgress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnabled( 
            BOOL fEnabled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFilterControlsVisibility( 
            BOOL fFilterControlsVisibility) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QuickApply( 
            DXT_QUICK_APPLY_TYPE dxtqat,
            IUnknown *punkInput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTFilterControllerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTFilterController * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTFilterController * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTFilterController * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProgress )( 
            IDXTFilterController * This,
            float flProgress);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnabled )( 
            IDXTFilterController * This,
            BOOL fEnabled);
        
        HRESULT ( STDMETHODCALLTYPE *SetFilterControlsVisibility )( 
            IDXTFilterController * This,
            BOOL fFilterControlsVisibility);
        
        HRESULT ( STDMETHODCALLTYPE *QuickApply )( 
            IDXTFilterController * This,
            DXT_QUICK_APPLY_TYPE dxtqat,
            IUnknown *punkInput);
        
        END_INTERFACE
    } IDXTFilterControllerVtbl;

    interface IDXTFilterController
    {
        CONST_VTBL struct IDXTFilterControllerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTFilterController_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTFilterController_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTFilterController_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTFilterController_SetProgress(This,flProgress)	\
    (This)->lpVtbl -> SetProgress(This,flProgress)

#define IDXTFilterController_SetEnabled(This,fEnabled)	\
    (This)->lpVtbl -> SetEnabled(This,fEnabled)

#define IDXTFilterController_SetFilterControlsVisibility(This,fFilterControlsVisibility)	\
    (This)->lpVtbl -> SetFilterControlsVisibility(This,fFilterControlsVisibility)

#define IDXTFilterController_QuickApply(This,dxtqat,punkInput)	\
    (This)->lpVtbl -> QuickApply(This,dxtqat,punkInput)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTFilterController_SetProgress_Proxy( 
    IDXTFilterController * This,
    float flProgress);


void __RPC_STUB IDXTFilterController_SetProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterController_SetEnabled_Proxy( 
    IDXTFilterController * This,
    BOOL fEnabled);


void __RPC_STUB IDXTFilterController_SetEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterController_SetFilterControlsVisibility_Proxy( 
    IDXTFilterController * This,
    BOOL fFilterControlsVisibility);


void __RPC_STUB IDXTFilterController_SetFilterControlsVisibility_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTFilterController_QuickApply_Proxy( 
    IDXTFilterController * This,
    DXT_QUICK_APPLY_TYPE dxtqat,
    IUnknown *punkInput);


void __RPC_STUB IDXTFilterController_QuickApply_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTFilterController_INTERFACE_DEFINED__ */


#ifndef __IDXTRedirectFilterInit_INTERFACE_DEFINED__
#define __IDXTRedirectFilterInit_INTERFACE_DEFINED__

/* interface IDXTRedirectFilterInit */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTRedirectFilterInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D1A57094-21F7-4e6c-93E5-F5F77F748293")
    IDXTRedirectFilterInit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetHTMLPaintSite( 
            void *pvHTMLPaintSite) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTRedirectFilterInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTRedirectFilterInit * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTRedirectFilterInit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTRedirectFilterInit * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetHTMLPaintSite )( 
            IDXTRedirectFilterInit * This,
            void *pvHTMLPaintSite);
        
        END_INTERFACE
    } IDXTRedirectFilterInitVtbl;

    interface IDXTRedirectFilterInit
    {
        CONST_VTBL struct IDXTRedirectFilterInitVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTRedirectFilterInit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTRedirectFilterInit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTRedirectFilterInit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTRedirectFilterInit_SetHTMLPaintSite(This,pvHTMLPaintSite)	\
    (This)->lpVtbl -> SetHTMLPaintSite(This,pvHTMLPaintSite)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTRedirectFilterInit_SetHTMLPaintSite_Proxy( 
    IDXTRedirectFilterInit * This,
    void *pvHTMLPaintSite);


void __RPC_STUB IDXTRedirectFilterInit_SetHTMLPaintSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTRedirectFilterInit_INTERFACE_DEFINED__ */


#ifndef __IDXTClipOrigin_INTERFACE_DEFINED__
#define __IDXTClipOrigin_INTERFACE_DEFINED__

/* interface IDXTClipOrigin */
/* [local][unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDXTClipOrigin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE1663D8-0988-4C48-9FD6-DB4450885668")
    IDXTClipOrigin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClipOrigin( 
            DXVEC *pvecClipOrigin) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTClipOriginVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDXTClipOrigin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDXTClipOrigin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDXTClipOrigin * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClipOrigin )( 
            IDXTClipOrigin * This,
            DXVEC *pvecClipOrigin);
        
        END_INTERFACE
    } IDXTClipOriginVtbl;

    interface IDXTClipOrigin
    {
        CONST_VTBL struct IDXTClipOriginVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTClipOrigin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTClipOrigin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTClipOrigin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTClipOrigin_GetClipOrigin(This,pvecClipOrigin)	\
    (This)->lpVtbl -> GetClipOrigin(This,pvecClipOrigin)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTClipOrigin_GetClipOrigin_Proxy( 
    IDXTClipOrigin * This,
    DXVEC *pvecClipOrigin);


void __RPC_STUB IDXTClipOrigin_GetClipOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTClipOrigin_INTERFACE_DEFINED__ */



#ifndef __DXTRANSPLib_LIBRARY_DEFINED__
#define __DXTRANSPLib_LIBRARY_DEFINED__

/* library DXTRANSPLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DXTRANSPLib;

EXTERN_C const CLSID CLSID_DXTLabel;

#ifdef __cplusplus

class DECLSPEC_UUID("54702535-2606-11D1-999C-0000F8756A10")
DXTLabel;
#endif

EXTERN_C const CLSID CLSID_DXRasterizer;

#ifdef __cplusplus

class DECLSPEC_UUID("8652CE55-9E80-11D1-9053-00C04FD9189D")
DXRasterizer;
#endif

EXTERN_C const CLSID CLSID_DX2D;

#ifdef __cplusplus

class DECLSPEC_UUID("473AA80B-4577-11D1-81A8-0000F87557DB")
DX2D;
#endif

EXTERN_C const CLSID CLSID_DXTFilterBehavior;

#ifdef __cplusplus

class DECLSPEC_UUID("649EEC1E-B579-4E8C-BB3B-4997F8426536")
DXTFilterBehavior;
#endif

EXTERN_C const CLSID CLSID_DXTFilterFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("81397204-F51A-4571-8D7B-DC030521AABD")
DXTFilterFactory;
#endif

EXTERN_C const CLSID CLSID_DXTFilterCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("A7EE7F34-3BD1-427f-9231-F941E9B7E1FE")
DXTFilterCollection;
#endif
#endif /* __DXTRANSPLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HFONT_UserSize(     unsigned long *, unsigned long            , HFONT * ); 
unsigned char * __RPC_USER  HFONT_UserMarshal(  unsigned long *, unsigned char *, HFONT * ); 
unsigned char * __RPC_USER  HFONT_UserUnmarshal(unsigned long *, unsigned char *, HFONT * ); 
void                      __RPC_USER  HFONT_UserFree(     unsigned long *, HFONT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\inetcore\inc\dxtpriv.h ===
/*******************************************************************************
* DXVector.h *
*------------*
*   Description:
*       This is the header file for the matrix classes.
*
*******************************************************************************/
#ifndef __DXTPRIV_H_
#define __DXTPRIV_H_

#ifndef _INC_MATH
#include <math.h>
#endif

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

//=== Class, Enum, Struct and Union Declarations ===================
class CDXMatrix4x4F;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================
float det4x4( CDXMatrix4x4F *pIn );
float det3x3( float a1, float a2, float a3, float b1, float b2, float b3, 
              float c1, float c2, float c3 );
float det2x2( float a, float b, float c, float d );

/*** CDX2DXForm ************
*   This class implements basic matrix operation based on the GDI XFORM
*   structure.
*/
//const DX2DXFORM g_DX2DXFORMIdentity = { 1., 0., 0., 1., 0., 0., DX2DXO_IDENTITY };

class CDX2DXForm : public DX2DXFORM
{
  /*=== Methods =======*/
public:
    /*--- Constructors ---*/
    CDX2DXForm() { SetIdentity(); }
    CDX2DXForm( const CDX2DXForm& Other ) { memcpy( this, &Other, sizeof(*this) ); }
    CDX2DXForm( const DX2DXFORM& Other ) { memcpy( this, &Other, sizeof(*this) ); }

    /*--- methods ---*/
    void DetermineOp( void );
    void Set( const DX2DXFORM& Other ) { memcpy( this, &Other, sizeof(*this) ); DetermineOp(); }
    void ZeroMatrix( void ) { memset( this, 0, sizeof( *this ) ); }
    void SetIdentity( void ) {  
        eM11 = 1.;
        eM12 = 0.;
        eM21 = 0.;
        eM22 = 1.;
        eDx = 0.;
        eDy = 0.;
        eOp = DX2DXO_IDENTITY;
    }
    BOOL IsIdentity() const { return eOp == DX2DXO_IDENTITY; }
    void Scale( float sx, float sy );
    void Rotate( float Rotation );
    void Translate( float dx, float dy );
    BOOL Invert();
    void TransformBounds( const DXBNDS& Bnds, DXBNDS& ResultBnds ) const;
    void TransformPoints( const DXFPOINT InPnts[], DXFPOINT OutPnts[], ULONG ulCount ) const;
    void GetMinMaxScales( float& MinScale, float& MaxScale );

    /*--- operators ---*/
    DXFPOINT operator*( const DXFPOINT& v ) const;
    CDX2DXForm operator*( const CDX2DXForm& Other ) const;
};

//=== CDX2DXForm methods ==============================================================
inline void CDX2DXForm::DetermineOp( void )
{
    if( ( eM12 == 0. ) && ( eM21 == 0. ) )
    {
        if( ( eM11 == 1. ) && ( eM22 == 1. ) )
        {
            eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_IDENTITY):(DX2DXO_TRANSLATE);
        }
        else
        {
            eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_SCALE):(DX2DXO_SCALE_AND_TRANS);
        }
    }
    else
    {
        eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_GENERAL):(DX2DXO_GENERAL_AND_TRANS);
    }
} /* CDX2DXForm::DetermineOp */

inline float DXSq( float f ) { return f * f; }

// This function computes the Min and Max scale that a matrix represents.
// In other words, what is the maximum/minimum length that a line of length 1
// could get stretched/shrunk to if the line was transformed by this matrix.
//
// The function uses eigenvalues; and returns two float numbers. Both are
// non-negative; and MaxScale >= MinScale.
// 
inline void CDX2DXForm::GetMinMaxScales( float& MinScale, float& MaxScale )
{
    if( ( eM12 == 0. ) && ( eM21 == 0. ) )
    {
        // Let MinScale = abs(eM11)
        if (eM11 < 0)
            MinScale = -eM11;
        else
            MinScale = eM11;

        // Let MaxScale = abs(eM22)
        if (eM22 < 0)
            MaxScale = -eM22;
        else
            MaxScale = eM22;

        // Swap Min/Max if necessary
        if (MinScale > MaxScale)
        {
            float flTemp = MinScale;
            MinScale = MaxScale;
            MaxScale = flTemp;
        }
    }
    else
    {
        float t1 = DXSq(eM11) + DXSq(eM12) + DXSq(eM21) + DXSq(eM22);
        if( t1 == 0. )
        {
            MinScale = MaxScale = 0;
        }
        else
        {
            float t2 = (float)sqrt( (DXSq(eM12 + eM21) + DXSq(eM11 - eM22)) *
                                    (DXSq(eM12 - eM21) + DXSq(eM11 + eM22)) );

            // Due to floating point error; t1 may end up less than t2;
            // but that would mean that the min scale was small (relative
            // to max scale)
            if (t1 <= t2)
                MinScale = 0;
            else
                MinScale = (float)sqrt( (t1 - t2) * .5f );

            MaxScale = (float)sqrt( (t1 + t2) * .5f );
        }
    }
} /* CDX2DXForm::GetMinMaxScales */

inline void CDX2DXForm::Rotate( float Rotation )
{
    double Angle = Rotation * (3.1415926535/180.0);
    float CosZ   = (float)cos( Angle );
    float SinZ   = (float)sin( Angle );
    if (CosZ > 0.0F && CosZ < 0.0000005F)
    {
        CosZ = .0F;
    }
    if (SinZ > -0.0000005F && SinZ < .0F)
    {
        SinZ = .0F;
    }

    float M11 = ( CosZ * eM11 ) + ( SinZ * eM21 ); 
    float M21 = (-SinZ * eM11 ) + ( CosZ * eM21 );
    float M12 = ( CosZ * eM12 ) + ( SinZ * eM22 ); 
    float M22 = (-SinZ * eM12 ) + ( CosZ * eM22 );
    eM11 = M11; eM21 = M21; eM12 = M12; eM22 = M22;
    DetermineOp();
} /* CDX2DXForm::Rotate */

inline void CDX2DXForm::Scale( float sx, float sy )
{
    eM11 *= sx;
    eM12 *= sx;
    eDx  *= sx;
    eM21 *= sy;
    eM22 *= sy;
    eDy  *= sy;
    DetermineOp();
} /* CDX2DXForm::Scale */

inline void CDX2DXForm::Translate( float dx, float dy )
{
    eDx += dx;
    eDy += dy;
    DetermineOp();
} /* CDX2DXForm::Translate */

inline void CDX2DXForm::TransformBounds( const DXBNDS& Bnds, DXBNDS& ResultBnds ) const
{
    ResultBnds = Bnds;
    if( eOp != DX2DXO_IDENTITY )
    {
        ResultBnds.u.D[DXB_X].Min = (long)(( eM11 * Bnds.u.D[DXB_X].Min ) + ( eM12 * Bnds.u.D[DXB_Y].Min ) + eDx);
        ResultBnds.u.D[DXB_X].Max = (long)(( eM11 * Bnds.u.D[DXB_X].Max ) + ( eM12 * Bnds.u.D[DXB_Y].Max ) + eDx);
        ResultBnds.u.D[DXB_Y].Min = (long)(( eM21 * Bnds.u.D[DXB_X].Min ) + ( eM22 * Bnds.u.D[DXB_Y].Min ) + eDy);
        ResultBnds.u.D[DXB_Y].Max = (long)(( eM21 * Bnds.u.D[DXB_X].Max ) + ( eM22 * Bnds.u.D[DXB_Y].Max ) + eDy);
    }
} /* CDX2DXForm::TransformBounds */

inline void CDX2DXForm::TransformPoints( const DXFPOINT InPnts[], DXFPOINT OutPnts[], ULONG ulCount ) const
{
    ULONG i;
    switch( eOp )
    {
      case DX2DXO_IDENTITY:
        memcpy( OutPnts, InPnts, ulCount * sizeof( DXFPOINT ) );
        break;
      case DX2DXO_TRANSLATE:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = InPnts[i].x + eDx;
            OutPnts[i].y = InPnts[i].y + eDy;
        }
        break;
      case DX2DXO_SCALE:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = InPnts[i].x * eM11;
            OutPnts[i].y = InPnts[i].y * eM22;
        }
        break;
      case DX2DXO_SCALE_AND_TRANS:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = (InPnts[i].x * eM11) + eDx;
            OutPnts[i].y = (InPnts[i].y * eM22) + eDy;
        }
        break;
      case DX2DXO_GENERAL:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = ( InPnts[i].x * eM11 ) + ( InPnts[i].y * eM12 );
            OutPnts[i].y = ( InPnts[i].x * eM21 ) + ( InPnts[i].y * eM22 );
        }
        break;
      case DX2DXO_GENERAL_AND_TRANS:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = ( InPnts[i].x * eM11 ) + ( InPnts[i].y * eM12 ) + eDx;
            OutPnts[i].y = ( InPnts[i].x * eM21 ) + ( InPnts[i].y * eM22 ) + eDy;
        }
        break;
      default:
        _ASSERT( 0 );   // invalid operation id
    }
} /* CDX2DXForm::TransformPoints */

inline DXFPOINT CDX2DXForm::operator*( const DXFPOINT& v ) const
{
    DXFPOINT NewPnt;
    NewPnt.x = ( v.x * eM11 ) + ( v.y * eM12 ) + eDx;
    NewPnt.y = ( v.x * eM21 ) + ( v.y * eM22 ) + eDy;
    return NewPnt;
} /* CDX2DXForm::operator* */

inline CDX2DXForm CDX2DXForm::operator*( const CDX2DXForm& Other ) const
{
    DX2DXFORM x;
    x.eM11 = ( eM11 * Other.eM11 ) + ( eM12 * Other.eM21 );
    x.eM12 = ( eM11 * Other.eM12 ) + ( eM12 * Other.eM22 );
    x.eDx  = ( eM11 * Other.eDx  ) + ( eM12 * Other.eDy  ) + eDx;

    x.eM21 = ( eM21 * Other.eM11 ) + ( eM22 * Other.eM21 );
    x.eM22 = ( eM21 * Other.eM12 ) + ( eM22 * Other.eM22 );
    x.eDy  = ( eM21 * Other.eDx  ) + ( eM22 * Other.eDy  ) + eDy;
    return x;
} /* CDX2DXForm::operator*= */

inline BOOL CDX2DXForm::Invert()
{
    switch( eOp )
    {
    case DX2DXO_IDENTITY:
        break;
    case DX2DXO_TRANSLATE:
        eDx = -eDx;
        eDy = -eDy;
        break;
    case DX2DXO_SCALE:

        if (eM11 == 0.0 || eM22 == 0.0)
            return false;
        eM11 = 1.0f / eM11;
        eM22 = 1.0f / eM22;
        break;

    case DX2DXO_SCALE_AND_TRANS:
        {
            if (eM11 == 0.0f || eM22 == 0.0f)
                return false;

            // Our old equation was F = aG + b
            // The inverse is G = F/a - b/a where a is eM11 and b is eDx
            float flOneOverA = 1.0f / eM11;
            eDx = -eDx * flOneOverA;
            eM11 = flOneOverA;

            // Our old equation was F = aG + b
            // The inverse is G = F/a - b/a where a is eM22 and b is eDy

            flOneOverA = 1.0f / eM22;
            eDy = -eDy * flOneOverA;
            eM22 = flOneOverA;
            break;
        }

    case DX2DXO_GENERAL:
    case DX2DXO_GENERAL_AND_TRANS:
        {
            // The inverse of A=  |a b| is | d -c|*(1/Det) where Det is the determinant of A
            //                    |c d|    |-b  a|
            // Det(A) = ad - bc

            // Compute determininant
            float flDet = (eM11 * eM22 -  eM12 * eM21);
            if (flDet == 0.0f)
                return FALSE;

            float flCoef = 1.0f / flDet;

            // Remember old value of eM11
            float flM11Original = eM11;

            eM11 = flCoef * eM22;
            eM12 = -flCoef * eM12;
            eM21 = -flCoef * eM21;
            eM22 = flCoef * flM11Original;

            // If we have a translation; then we need to 
            // compute new values for that translation
            if (eOp == DX2DXO_GENERAL_AND_TRANS)
            {
                // Remember original value of eDx
                float eDxOriginal = eDx;

                eDx = -eM11 * eDx - eM12 * eDy;
                eDy = -eM21 * eDxOriginal - eM22 * eDy;
            }
        }
        break;

    default:
        _ASSERT( 0 );   // invalid operation id
    }

    // We don't need to call DetermineOp here
    // because the op doesn't change when inverted
    // i.e. a scale remains a scale, etc.

    return true;
} /* CDX2DXForm::Invert */

/*** CDXMatrix4x4F ************
*   This class implements basic matrix operation based on a 4x4 array.
*/
//const float g_DXMat4X4Identity[4][4] =
//{
//    { 1.0, 0. , 0. , 0.  },
//    { 0. , 1.0, 0. , 0.  },
//    { 0. , 0. , 1.0, 0.  },
//    { 0. , 0. , 0. , 1.0 }
//};

class CDXMatrix4x4F
{
public:
  /*=== Member Data ===*/
    float m_Coeff[4][4];

  /*=== Methods =======*/
public:
    /*--- Constructors ---*/
    CDXMatrix4x4F() { SetIdentity(); }
    CDXMatrix4x4F( const CDXMatrix4x4F& Other )
        { CopyMemory( (void *)&m_Coeff, (void *)&Other.m_Coeff, sizeof(m_Coeff) ); }
    CDXMatrix4x4F( DX2DXFORM& XForm );

    /*--- operations ---*/
    void ZeroMatrix( void ) { memset( m_Coeff, 0, sizeof( m_Coeff ) ); }
    void SetIdentity( void ) {
        memset( m_Coeff, 0, sizeof( m_Coeff ) );
        m_Coeff[0][0] = m_Coeff[1][1] = m_Coeff[2][2] = m_Coeff[3][3] = 1.0;
    }
    void SetCoefficients( float Coeff[4][4] ) { memcpy( m_Coeff, Coeff, sizeof( m_Coeff )); }
    void GetCoefficients( float Coeff[4][4] ) { memcpy( Coeff, m_Coeff, sizeof( m_Coeff )); }

    //BOOL IsIdentity();
    void Scale( float sx, float sy, float sz );
    void Rotate( float rx, float ry, float rz );
    void Translate( float dx, float dy, float dz );
    BOOL Invert();
    BOOL GetInverse( CDXMatrix4x4F *pIn );
    void Transpose();
    void GetTranspose( CDXMatrix4x4F *pIn );
    void GetAdjoint( CDXMatrix4x4F *pIn );
    HRESULT InitFromSafeArray( SAFEARRAY *psa );
    HRESULT GetSafeArray( SAFEARRAY **ppsa ) const;
    void TransformBounds( DXBNDS& Bnds, DXBNDS& ResultBnds );

    /*--- operators ---*/
    CDXDVec operator*( CDXDVec& v) const;
    CDXCVec operator*( CDXCVec& v) const;
    CDXMatrix4x4F operator*(CDXMatrix4x4F Matrix) const;
    void operator*=(CDXMatrix4x4F Matrix) const;
    void CDXMatrix4x4F::operator=(const CDXMatrix4x4F srcMatrix);
    void CDXMatrix4x4F::operator+=(const CDXMatrix4x4F otherMatrix);
    void CDXMatrix4x4F::operator-=(const CDXMatrix4x4F otherMatrix);
    BOOL CDXMatrix4x4F::operator==(const CDXMatrix4x4F otherMatrix) const;
    BOOL CDXMatrix4x4F::operator!=(const CDXMatrix4x4F otherMatrix) const;
};

inline CDXMatrix4x4F::CDXMatrix4x4F( DX2DXFORM& XForm )
{
    SetIdentity();
    m_Coeff[0][0] = XForm.eM11;
    m_Coeff[0][1] = XForm.eM12;
    m_Coeff[1][0] = XForm.eM21;
    m_Coeff[1][1] = XForm.eM22;
    m_Coeff[0][3] = XForm.eDx;
    m_Coeff[1][3] = XForm.eDy;
}

// Additional Operations

inline void CDXMatrix4x4F::operator=(const CDXMatrix4x4F srcMatrix)
{
    CopyMemory( (void *)m_Coeff, (const void *)srcMatrix.m_Coeff, sizeof(srcMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator= */

inline BOOL CDXMatrix4x4F::operator==(const CDXMatrix4x4F otherMatrix) const
{
    return !memcmp( (void *)m_Coeff, (const void *)otherMatrix.m_Coeff, sizeof(otherMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator== */

inline BOOL CDXMatrix4x4F::operator!=(const CDXMatrix4x4F otherMatrix) const
{
    return memcmp( (void *)m_Coeff, (const void *)otherMatrix.m_Coeff, sizeof(otherMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator!= */

inline void CDXMatrix4x4F::operator+=(const CDXMatrix4x4F otherMatrix)
{
    for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ )
            m_Coeff[i][j] += otherMatrix.m_Coeff[i][j];
} /* CDXMatrix4x4F::operator+= */

inline void CDXMatrix4x4F::operator-=(const CDXMatrix4x4F otherMatrix) 
{
    for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ )
            m_Coeff[i][j] -= otherMatrix.m_Coeff[i][j];
} /* CDXMatrix4x4F::operator-= */

inline CDXDVec CDXMatrix4x4F::operator*(CDXDVec& v) const
{
    CDXDVec t;
    float temp;
    temp = v[0]*m_Coeff[0][0]+v[1]*m_Coeff[1][0]+v[2]*m_Coeff[2][0]+v[3]*m_Coeff[3][0];
    t[0] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][1]+v[1]*m_Coeff[1][1]+v[2]*m_Coeff[2][1]+v[3]*m_Coeff[3][1];
    t[1] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][2]+v[1]*m_Coeff[1][2]+v[2]*m_Coeff[2][2]+v[3]*m_Coeff[3][2];
    t[2] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][3]+v[1]*m_Coeff[1][3]+v[2]*m_Coeff[2][3]+v[3]*m_Coeff[3][3];
    t[3] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    return t;
} /* CDXMatrix4x4F::operator*(DXDVEC) */

inline CDXCVec CDXMatrix4x4F::operator*(CDXCVec& v) const
{
    CDXCVec t;
    t[0] = v[0]*m_Coeff[0][0]+v[1]*m_Coeff[1][0]+v[2]*m_Coeff[2][0]+v[3]*m_Coeff[3][0];
    t[1] = v[0]*m_Coeff[0][1]+v[1]*m_Coeff[1][1]+v[2]*m_Coeff[2][1]+v[3]*m_Coeff[3][1];
    t[2] = v[0]*m_Coeff[0][2]+v[1]*m_Coeff[1][2]+v[2]*m_Coeff[2][2]+v[3]*m_Coeff[3][2];
    t[3] = v[0]*m_Coeff[0][3]+v[1]*m_Coeff[1][3]+v[2]*m_Coeff[2][3]+v[3]*m_Coeff[3][3];
    return t;
} /* CDXMatrix4x4F::operator*(DXCVEC) */

inline CDXMatrix4x4F CDXMatrix4x4F::operator*(CDXMatrix4x4F Mx) const
{
    CDXMatrix4x4F t;
    int i, j;

    for( i = 0; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            t.m_Coeff[i][j] =   m_Coeff[i][0] * Mx.m_Coeff[0][j] + 
                                m_Coeff[i][1] * Mx.m_Coeff[1][j] +
                                m_Coeff[i][2] * Mx.m_Coeff[2][j] +
                                m_Coeff[i][3] * Mx.m_Coeff[3][j];
        }
    }

    return t;
} /* CDXMatrix4x4F::operator*(CDXMatrix4x4F) */
            
inline void CDXMatrix4x4F::operator*=(CDXMatrix4x4F Mx) const
{
    CDXMatrix4x4F t;
    int i, j;

    for( i = 0; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            t.m_Coeff[i][j] =   m_Coeff[i][0] * Mx.m_Coeff[0][j] + 
                                m_Coeff[i][1] * Mx.m_Coeff[1][j] +
                                m_Coeff[i][2] * Mx.m_Coeff[2][j] +
                                m_Coeff[i][3] * Mx.m_Coeff[3][j];
        }
    }

    CopyMemory( (void *)m_Coeff, (void *)t.m_Coeff, sizeof(m_Coeff) );
} /* CDXMatrix4x4F::operator*=(CDXMatrix4x4F) */
            

inline void CDXMatrix4x4F::Scale( float sx, float sy, float sz )
{
    if( sx != 1. )
    {
        m_Coeff[0][0] *= sx;
        m_Coeff[0][1] *= sx;
        m_Coeff[0][2] *= sx;
        m_Coeff[0][3] *= sx;
    }
    if( sy != 1. )
    {
        m_Coeff[1][0] *= sy;
        m_Coeff[1][1] *= sy;
        m_Coeff[1][2] *= sy;
        m_Coeff[1][3] *= sy;
    }
    if( sz != 1. )
    {
        m_Coeff[2][0] *= sz;
        m_Coeff[2][1] *= sz;
        m_Coeff[2][2] *= sz;
        m_Coeff[2][3] *= sz;
    }
} /* CDXMatrix4x4F::Scale */

inline void CDXMatrix4x4F::Translate( float dx, float dy, float dz )
{
    float a, b, c, d;
    a = b = c = d = 0;
    if( dx != 0. )
    {
        a += m_Coeff[0][0]*dx;
        b += m_Coeff[0][1]*dx;
        c += m_Coeff[0][2]*dx;
        d += m_Coeff[0][3]*dx;
    }
    if( dy != 0. )
    {
        a += m_Coeff[1][0]*dy;
        b += m_Coeff[1][1]*dy;
        c += m_Coeff[1][2]*dy;
        d += m_Coeff[1][3]*dy;
    }
    if( dz != 0. )
    {
        a += m_Coeff[2][0]*dz;
        b += m_Coeff[2][1]*dz;
        c += m_Coeff[2][2]*dz;
        d += m_Coeff[2][3]*dz;
    }
    m_Coeff[3][0] += a;
    m_Coeff[3][1] += b;
    m_Coeff[3][2] += c;
    m_Coeff[3][3] += d;
} /* CDXMatrix4x4F::Translate */

inline void CDXMatrix4x4F::Rotate( float rx, float ry, float rz )
{
    const float l_dfCte = (const float)(3.1415926535/180.0);

    float lAngleY = 0.0;
    float lAngleX = 0.0;
    float lAngleZ = 0.0;
    float lCosX = 1.0;
    float lSinX = 0.0;
    float lCosY = 1.0;
    float lSinY = 0.0;
    float lCosZ = 1.0;
    float lSinZ = 0.0;

    // calculate rotation angle sines and cosines
    if( rx != 0 )
    {
        lAngleX = rx * l_dfCte;
        lCosX = (float)cos(lAngleX);
        lSinX = (float)sin(lAngleX);
        if (lCosX > 0.0F && lCosX < 0.0000005F)
        {
            lCosX = .0F;
        }
        if (lSinX > -0.0000005F && lSinX < .0F)
        {
            lSinX = .0F;
        }
    }
    if( ry != 0 )
    {
        lAngleY = ry * l_dfCte;
        lCosY = (float)cos(lAngleY);
        lSinY = (float)sin(lAngleY);
        if (lCosY > 0.0F && lCosY < 0.0000005F)
        {
            lCosY = .0F;
        }
        if (lSinY > -0.0000005F && lSinY < .0F)
        {
            lSinY = .0F;
        }
    }
    if( rz != 0 )
    {
        lAngleZ = rz * l_dfCte;
        lCosZ = (float)cos(lAngleZ);
        lSinZ = (float)sin(lAngleZ);
        if (lCosZ > 0.0F && lCosZ < 0.0000005F)
        {
            lCosZ = .0F;
        }
        if (lSinZ > -0.0000005F && lSinZ < .0F)
        {
            lSinZ = .0F;
        }
    }

    float u, v;
    int i;

    //--- X Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[1][i]; 
        v = m_Coeff[2][i];
        m_Coeff[1][i] = lCosX*u+lSinX*v; 
        m_Coeff[2][i] = -lSinX*u+lCosX*v;
    }

    //--- Y Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[0][i];
        v = m_Coeff[2][i];
        m_Coeff[0][i] = lCosY*u-lSinY*v; 
        m_Coeff[2][i] = lSinY*u+lCosY*v;
    }

    //--- Z Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[0][i];
        v = m_Coeff[1][i];
        m_Coeff[0][i] = lCosZ*u+lSinZ*v; 
        m_Coeff[1][i] = -lSinZ*u+lCosZ*v;
    }
}

/*
inline BOOL CDXMatrix4x4F::IsIdentity()
{
    return  !memcmp( m_Coeff, g_DXMat4X4Identity, sizeof(g_DXMat4X4Identity) );
} /* CDXMatrix4x4F::IsIdentity */


/*
   Uses Gaussian elimination to invert the 4 x 4 non-linear matrix in t and
   return the result in Mx.  The matrix t is destroyed in the process.
*/
inline BOOL CDXMatrix4x4F::Invert()
{
    int i,j,k,Pivot;
    float PValue;
    CDXMatrix4x4F Mx;
    Mx.SetIdentity();

/* Find pivot element.  Use partial pivoting by row */
    for( i = 0;i < 4; i++ )
    {
        Pivot = 0;
        for( j = 0; j < 4; j++ )
        {
            if( fabs(m_Coeff[i][j]) > fabs(m_Coeff[i][Pivot]) ) Pivot = j;
        }

        if( m_Coeff[i][Pivot] == 0.0 )
        {
            ZeroMatrix();   /* Singular Matrix */
            return FALSE; 
        }

/* Normalize */
        PValue = m_Coeff[i][Pivot];
        for( j = 0; j < 4; j++ )
        {
            m_Coeff[i][j] /= PValue;
            Mx.m_Coeff[i][j] /= PValue;
        }

/* Zeroing */
        for( j = 0; j < 4; j++ )
        {
            if( j != i )
            {
                PValue = m_Coeff[j][Pivot];
                for( k = 0; k < 4; k++ )
                {
                    m_Coeff[j][k] -= PValue*m_Coeff[i][k];
                    Mx.m_Coeff[j][k] -= PValue*Mx.m_Coeff[i][k];
                }
            }
        }
    }

/* Reorder rows */
    for( i = 0; i < 4; i++ )
    {
        if( m_Coeff[i][i] != 1.0 )
        {
            for( j = i + 1; j < 4; j++ )
                if( m_Coeff[j][i] == 1.0 ) break;
            if( j >= 4 )
            {
                ZeroMatrix();
                return FALSE;
            }

            //--- swap rows i and j of original
            for( k = 0; k < 4; k++ )
            {
                m_Coeff[i][k] += m_Coeff[j][k];
                m_Coeff[j][k] = m_Coeff[i][k] - m_Coeff[j][k];
                m_Coeff[i][k] -= m_Coeff[j][k];
            }
            
            //--- swap rows i and j of result
            for( k = 0; k < 4; k++ )
            {
                Mx.m_Coeff[i][k] += Mx.m_Coeff[j][k];
                Mx.m_Coeff[j][k] = Mx.m_Coeff[i][k] - Mx.m_Coeff[j][k];
                Mx.m_Coeff[i][k] -= Mx.m_Coeff[j][k];
            }
        }
    }
    *this = Mx;
    return TRUE;
} /* CDXMatrix4x4F::Invert */

inline void CDXMatrix4x4F::Transpose()
{
    float temp;

    temp = m_Coeff[0][1];
    m_Coeff[0][1] = m_Coeff[1][0];
    m_Coeff[1][0] = temp;

    temp = m_Coeff[0][2];
    m_Coeff[0][2] = m_Coeff[2][0];
    m_Coeff[2][0] = temp;

    temp = m_Coeff[0][3];
    m_Coeff[0][3] = m_Coeff[3][0];
    m_Coeff[3][0] = temp;

    temp = m_Coeff[1][2];
    m_Coeff[1][2] = m_Coeff[2][1];
    m_Coeff[2][1] = temp;

    temp = m_Coeff[1][3];
    m_Coeff[1][3] = m_Coeff[3][1];
    m_Coeff[3][1] = temp;

    temp = m_Coeff[2][3];
    m_Coeff[2][3] = m_Coeff[3][2];
    m_Coeff[3][2] = temp;

} /* CDXMatrix4x4F::Transpose */

inline void CDXMatrix4x4F::GetTranspose( CDXMatrix4x4F *m )
{
    float temp;

    (*this) = *m;

    temp = m_Coeff[0][1];
    m_Coeff[0][1] = m_Coeff[1][0];
    m_Coeff[1][0] = temp;

    temp = m_Coeff[0][2];
    m_Coeff[0][2] = m_Coeff[2][0];
    m_Coeff[2][0] = temp;

    temp = m_Coeff[0][3];
    m_Coeff[0][3] = m_Coeff[3][0];
    m_Coeff[3][0] = temp;

    temp = m_Coeff[1][2];
    m_Coeff[1][2] = m_Coeff[2][1];
    m_Coeff[2][1] = temp;

    temp = m_Coeff[1][3];
    m_Coeff[1][3] = m_Coeff[3][1];
    m_Coeff[3][1] = temp;

    temp = m_Coeff[2][3];
    m_Coeff[2][3] = m_Coeff[3][2];
    m_Coeff[3][2] = temp;

} /* CDXMatrix4x4F::Transpose */


/*
Matrix Inversion
by Richard Carling
from "Graphics Gems", Academic Press, 1990
*/

#define SMALL_NUMBER    1.e-8
/* 
 *   inverse( original_matrix, inverse_matrix )
 * 
 *    calculate the inverse of a 4x4 matrix
 *
 *     -1     
 *     A  = ___1__ adjoint A
 *         det A
 */

inline BOOL CDXMatrix4x4F::GetInverse( CDXMatrix4x4F *pIn )
{
    int i, j;
    float det;

    /* calculate the adjoint matrix */

    GetAdjoint( pIn );

    /*  calculate the 4x4 determinant
     *  if the determinant is zero, 
     *  then the inverse matrix is not unique.
     */

    det = det4x4( pIn );

    if( fabs( det ) < SMALL_NUMBER )
    {
        //  Non-singular matrix, no inverse!
        return FALSE;;
    }

    /* scale the adjoint matrix to get the inverse */

    for( i = 0; i < 4; i++ )
        for( j = 0; j < 4; j++ )
            m_Coeff[i][j] = m_Coeff[i][j] / det;

    return TRUE;
}


/* 
 *   adjoint( original_matrix, inverse_matrix )
 * 
 *     calculate the adjoint of a 4x4 matrix
 *
 *      Let  a   denote the minor determinant of matrix A obtained by
 *           ij
 *
 *      deleting the ith row and jth column from A.
 *
 *                    i+j
 *     Let  b   = (-1)    a
 *          ij            ji
 *
 *    The matrix B = (b  ) is the adjoint of A
 *                     ij
 */
inline void CDXMatrix4x4F::GetAdjoint( CDXMatrix4x4F *pIn )
{
    float a1, a2, a3, a4, b1, b2, b3, b4;
    float c1, c2, c3, c4, d1, d2, d3, d4;

    /* assign to individual variable names to aid  */
    /* selecting correct values  */

    a1 = pIn->m_Coeff[0][0]; b1 = pIn->m_Coeff[0][1]; 
    c1 = pIn->m_Coeff[0][2]; d1 = pIn->m_Coeff[0][3];

    a2 = pIn->m_Coeff[1][0]; b2 = pIn->m_Coeff[1][1]; 
    c2 = pIn->m_Coeff[1][2]; d2 = pIn->m_Coeff[1][3];

    a3 = pIn->m_Coeff[2][0]; b3 = pIn->m_Coeff[2][1];
    c3 = pIn->m_Coeff[2][2]; d3 = pIn->m_Coeff[2][3];

    a4 = pIn->m_Coeff[3][0]; b4 = pIn->m_Coeff[3][1]; 
    c4 = pIn->m_Coeff[3][2]; d4 = pIn->m_Coeff[3][3];


    /* row column labeling reversed since we transpose rows & columns */

    m_Coeff[0][0]  =   det3x3( b2, b3, b4, c2, c3, c4, d2, d3, d4);
    m_Coeff[1][0]  = - det3x3( a2, a3, a4, c2, c3, c4, d2, d3, d4);
    m_Coeff[2][0]  =   det3x3( a2, a3, a4, b2, b3, b4, d2, d3, d4);
    m_Coeff[3][0]  = - det3x3( a2, a3, a4, b2, b3, b4, c2, c3, c4);
        
    m_Coeff[0][1]  = - det3x3( b1, b3, b4, c1, c3, c4, d1, d3, d4);
    m_Coeff[1][1]  =   det3x3( a1, a3, a4, c1, c3, c4, d1, d3, d4);
    m_Coeff[2][1]  = - det3x3( a1, a3, a4, b1, b3, b4, d1, d3, d4);
    m_Coeff[3][1]  =   det3x3( a1, a3, a4, b1, b3, b4, c1, c3, c4);
        
    m_Coeff[0][2]  =   det3x3( b1, b2, b4, c1, c2, c4, d1, d2, d4);
    m_Coeff[1][2]  = - det3x3( a1, a2, a4, c1, c2, c4, d1, d2, d4);
    m_Coeff[2][2]  =   det3x3( a1, a2, a4, b1, b2, b4, d1, d2, d4);
    m_Coeff[3][2]  = - det3x3( a1, a2, a4, b1, b2, b4, c1, c2, c4);
        
    m_Coeff[0][3]  = - det3x3( b1, b2, b3, c1, c2, c3, d1, d2, d3);
    m_Coeff[1][3]  =   det3x3( a1, a2, a3, c1, c2, c3, d1, d2, d3);
    m_Coeff[2][3]  = - det3x3( a1, a2, a3, b1, b2, b3, d1, d2, d3);
    m_Coeff[3][3]  =   det3x3( a1, a2, a3, b1, b2, b3, c1, c2, c3);
}
/*
 * float = det4x4( matrix )
 * 
 * calculate the determinant of a 4x4 matrix.
 */
inline float det4x4( CDXMatrix4x4F *pIn )
{
    float ans;
    float a1, a2, a3, a4, b1, b2, b3, b4, c1, c2, c3, c4, d1, d2, d3, d4;

    /* assign to individual variable names to aid selecting */
    /*  correct elements */

    a1 = pIn->m_Coeff[0][0]; b1 = pIn->m_Coeff[0][1]; 
    c1 = pIn->m_Coeff[0][2]; d1 = pIn->m_Coeff[0][3];

    a2 = pIn->m_Coeff[1][0]; b2 = pIn->m_Coeff[1][1]; 
    c2 = pIn->m_Coeff[1][2]; d2 = pIn->m_Coeff[1][3];

    a3 = pIn->m_Coeff[2][0]; b3 = pIn->m_Coeff[2][1]; 
    c3 = pIn->m_Coeff[2][2]; d3 = pIn->m_Coeff[2][3];

    a4 = pIn->m_Coeff[3][0]; b4 = pIn->m_Coeff[3][1]; 
    c4 = pIn->m_Coeff[3][2]; d4 = pIn->m_Coeff[3][3];

    ans = a1 * det3x3( b2, b3, b4, c2, c3, c4, d2, d3, d4 )
        - b1 * det3x3( a2, a3, a4, c2, c3, c4, d2, d3, d4 )
        + c1 * det3x3( a2, a3, a4, b2, b3, b4, d2, d3, d4 )
        - d1 * det3x3( a2, a3, a4, b2, b3, b4, c2, c3, c4 );
    return ans;
}

/*
 * float = det3x3(  a1, a2, a3, b1, b2, b3, c1, c2, c3 )
 * 
 * calculate the determinant of a 3x3 matrix
 * in the form
 *
 *     | a1,  b1,  c1 |
 *     | a2,  b2,  c2 |
 *     | a3,  b3,  c3 |
 */

inline float det3x3( float a1, float a2, float a3, 
                     float b1, float b2, float b3, 
                     float c1, float c2, float c3 )
{
    float ans;

    ans = a1 * det2x2( b2, b3, c2, c3 )
        - b1 * det2x2( a2, a3, c2, c3 )
        + c1 * det2x2( a2, a3, b2, b3 );
    return ans;
}

/*
 * float = det2x2( float a, float b, float c, float d )
 * 
 * calculate the determinant of a 2x2 matrix.
 */
inline float det2x2( float a, float b, float c, float d )
{
    float ans = a * d - b * c;
    return ans;
}

inline HRESULT CDXMatrix4x4F::InitFromSafeArray( SAFEARRAY * /*pSA*/ )
{
    HRESULT hr = S_OK;
#if 0
    long *pData;

    if( !pSA || ( pSA->cDims != 1 ) ||
         ( pSA->cbElements != sizeof(float) ) ||
         ( pSA->rgsabound->lLbound   != 1 ) ||
         ( pSA->rgsabound->cElements != 8 ) 
      )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = SafeArrayAccessData(pSA, (void **)&pData);

        if( SUCCEEDED( hr ) )
        {
            for( int i = 0; i < 4; ++i )
            {
                m_Bounds[i].Min = pData[i];
                m_Bounds[i].Max = pData[i+4];
                m_Bounds[i].SampleRate = SampleRate;
            }

            hr = SafeArrayUnaccessData( pSA );
        }
    }
#endif
    return hr;
} /* CDXMatrix4x4F::InitFromSafeArray */

inline HRESULT CDXMatrix4x4F::GetSafeArray( SAFEARRAY ** /*ppSA*/ ) const
{
    HRESULT hr = S_OK;
#if 0
    SAFEARRAY *pSA;

    if( !ppSA )
    {
        hr = E_POINTER;
    }
    else
    {
        SAFEARRAYBOUND rgsabound;
        rgsabound.lLbound   = 1;
        rgsabound.cElements = 16;

        if( !(pSA = SafeArrayCreate( VT_I4, 1, &rgsabound ) ) )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            long *pData;
            hr = SafeArrayAccessData( pSA, (void **)&pData );

            if( SUCCEEDED( hr ) )
            {
                for( int i = 0; i < 4; ++i )
                {
                    pData[i]   = m_Bounds[i].Min;
                    pData[i+4] = m_Bounds[i].Max;
                }

                hr = SafeArrayUnaccessData( pSA );
            }
        }

        if( SUCCEEDED( hr ) )
        {
            *ppSA = pSA;
        }
    }
#endif
    return hr;
} /* CDXMatrix4x4F::GetSafeArray */

inline void CDXMatrix4x4F::TransformBounds( DXBNDS& /*Bnds*/, DXBNDS& /*ResultBnds*/ )
{

} /* CDXMatrix4x4F::TransformBounds */



#endif   // __DXTPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\enduser\inc\msasn1.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __MS_ASN1_H__
#define __MS_ASN1_H__

#include <pshpack8.h> /* Assume 8 byte packing throughout */

#ifdef __cplusplus
extern "C" {
#endif

/* ------ Basic integer types ------ */

typedef unsigned char   ASN1uint8_t;
typedef signed char     ASN1int8_t;

typedef unsigned short  ASN1uint16_t;
typedef signed short    ASN1int16_t;

typedef unsigned long   ASN1uint32_t;
typedef signed long     ASN1int32_t;


/* ------ Function modifiers ------ */

#ifdef ASN1LIB
#define ASN1_PUBLIC
#elif defined(ASN1C)
#define ASN1_PUBLIC
#else
#define ASN1_PUBLIC     __declspec(dllimport)
#endif
#define ASN1API         __stdcall
#define ASN1CALL        __stdcall


/* ------ Basic ASN.1 types ------ */

typedef ASN1uint8_t ASN1octet_t;

typedef ASN1uint8_t ASN1bool_t;

typedef struct tagASN1intx_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1intx_t;

typedef struct tagASN1octetstring_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1octetstring_t;

typedef struct tagASN1octetstring2_t
{
    ASN1uint32_t length;
    ASN1octet_t value[1];
}
    ASN1octetstring2_t;

typedef struct ASN1iterator_s
{
    struct ASN1iterator_s *next;
    void *value;
}
    ASN1iterator_t;

typedef struct tagASN1bitstring_t
{
    ASN1uint32_t length;
    ASN1octet_t *value;
}
    ASN1bitstring_t;

typedef char ASN1char_t;

typedef struct tagASN1charstring_t
{
    ASN1uint32_t length;
    ASN1char_t *value;
}
    ASN1charstring_t;

typedef ASN1uint16_t ASN1char16_t;

typedef struct tagASN1char16string_t
{
    ASN1uint32_t length;
    ASN1char16_t *value;
}
    ASN1char16string_t;

typedef ASN1uint32_t ASN1char32_t;

typedef struct tagASN1char32string_t
{
    ASN1uint32_t length;
    ASN1char32_t *value;
}
    ASN1char32string_t;

typedef ASN1char_t *ASN1ztcharstring_t;
typedef ASN1char16_t *ASN1ztchar16string_t;
typedef ASN1char32_t *ASN1ztchar32string_t;

typedef struct tagASN1wstring_t
{
    ASN1uint32_t length;
    WCHAR *value;
}
    ASN1wstring_t;

typedef struct ASN1objectidentifier_s
{
    struct ASN1objectidentifier_s *next;
    ASN1uint32_t value;
}
    *ASN1objectidentifier_t;

typedef struct tagASN1objectidentifier2_t
{
    ASN1uint16_t count;
    ASN1uint32_t value[16];
}
    ASN1objectidentifier2_t;

typedef struct tagASN1encodedOID_t
{
    ASN1uint16_t length;
    ASN1octet_t  *value;
}
    ASN1encodedOID_t;

typedef struct tagASN1stringtableentry_t
{
    ASN1char32_t lower;
    ASN1char32_t upper;
    ASN1uint32_t value;
}
    ASN1stringtableentry_t;

typedef struct tagASN1stringtable_t
{
    ASN1uint32_t length;
    ASN1stringtableentry_t *values;
}
    ASN1stringtable_t;

typedef ASN1ztcharstring_t ASN1objectdescriptor_t;

typedef struct tagASN1generalizedtime_t
{
    ASN1uint16_t year;
    ASN1uint8_t month;
    ASN1uint8_t day;
    ASN1uint8_t hour;
    ASN1uint8_t minute;
    ASN1uint8_t second;
    ASN1uint16_t millisecond;
    ASN1bool_t universal;
    ASN1int16_t diff;
}
    ASN1generalizedtime_t;

typedef struct tagASN1utctime_t
{
    ASN1uint8_t year;
    ASN1uint8_t month;
    ASN1uint8_t day;
    ASN1uint8_t hour;
    ASN1uint8_t minute;
    ASN1uint8_t second;
    ASN1bool_t universal;
    ASN1int16_t diff;
}
    ASN1utctime_t;

typedef struct tagASN1open_t
{
    // encoded
    ASN1uint32_t    length;
    union
    {
        void           *encoded;
        void           *value;
    };
}
    ASN1open_t;

typedef enum tagASN1blocktype_e
{
    ASN1_DER_SET_OF_BLOCK,
}
    ASN1blocktype_e;

typedef ASN1int32_t     ASN1enum_t;     // enumerated type

typedef ASN1uint16_t    ASN1choice_t;   // choice

typedef ASN1uint32_t    ASN1magic_t;

/* ------ Current version of this ASN.1 software ------ */

#define ASN1_MAKE_VERSION(major,minor)  (((major) << 16) | (minor))
#define ASN1_THIS_VERSION               ASN1_MAKE_VERSION(1,0)

enum
{
    ASN1_CHOICE_BASE      = 1,
    ASN1_CHOICE_INVALID   = -1,     // invalid choice
    ASN1_CHOICE_EXTENSION = 0,      // extension choice
};



/*
   Error codes for decoding functions:
   - err == 0:    data has been successfully decoded
   - err <  0:    fatal error has occured, no data has been generated
                  err contains the error number
   - err >  0:    non-fatal event has occured, data has been generated
                  err is a bit set of occured events
 */

typedef enum tagASN1error_e
{
    ASN1_SUCCESS        = 0,            /* success */

    // Teles specific error codes
    ASN1_ERR_INTERNAL   = (-1001),      /* internal error */
    ASN1_ERR_EOD        = (-1002),      /* unexpected end of data */
    ASN1_ERR_CORRUPT    = (-1003),      /* corrupted data */
    ASN1_ERR_LARGE      = (-1004),      /* value too large */
    ASN1_ERR_CONSTRAINT = (-1005),      /* constraint violated */
    ASN1_ERR_MEMORY     = (-1006),      /* out of memory */
    ASN1_ERR_OVERFLOW   = (-1007),      /* buffer overflow */
    ASN1_ERR_BADPDU     = (-1008),      /* function not supported for this pdu*/
    ASN1_ERR_BADARGS    = (-1009),      /* bad arguments to function call */
    ASN1_ERR_BADREAL    = (-1010),      /* bad real value */
    ASN1_ERR_BADTAG     = (-1011),      /* bad tag value met */
    ASN1_ERR_CHOICE     = (-1012),      /* bad choice value */
    ASN1_ERR_RULE       = (-1013),      /* bad encoding rule */
    ASN1_ERR_UTF8       = (-1014),      /* bad unicode (utf8) */

    // New error codes
    ASN1_ERR_PDU_TYPE   = (-1051),      /* bad pdu type */
    ASN1_ERR_NYI        = (-1052),      /* not yet implemented */

    // Teles specific warning codes
    ASN1_WRN_EXTENDED   = 1001,         /* skipped unknown extension(s) */
    ASN1_WRN_NOEOD      = 1002,         /* end of data expected */
}
    ASN1error_e;

#define ASN1_SUCCEEDED(ret)     (((int) (ret)) >= 0)
#define ASN1_FAILED(ret)        (((int) (ret)) < 0)


/* ------ Encoding rules ------ */

typedef enum
{
    ASN1_PER_RULE_ALIGNED       = 0x0001,
    ASN1_PER_RULE_UNALIGNED     = 0x0002, // not supported
    ASN1_PER_RULE               = ASN1_PER_RULE_ALIGNED | ASN1_PER_RULE_UNALIGNED,

    ASN1_BER_RULE_BER           = 0x0100,
    ASN1_BER_RULE_CER           = 0x0200,
    ASN1_BER_RULE_DER           = 0x0400,
    ASN1_BER_RULE               = ASN1_BER_RULE_BER | ASN1_BER_RULE_CER | ASN1_BER_RULE_DER,
}
    ASN1encodingrule_e;

/* ------ public structures ------ */

typedef struct ASN1encoding_s   *ASN1encoding_t;
typedef struct ASN1decoding_s   *ASN1decoding_t;

typedef ASN1int32_t (ASN1CALL *ASN1PerEncFun_t)(ASN1encoding_t enc, void *data);
typedef ASN1int32_t (ASN1CALL *ASN1PerDecFun_t)(ASN1decoding_t enc, void *data);
typedef struct tagASN1PerFunArr_t
{
    const ASN1PerEncFun_t *apfnEncoder;
    const ASN1PerDecFun_t *apfnDecoder;
}
    ASN1PerFunArr_t;

typedef ASN1int32_t (ASN1CALL *ASN1BerEncFun_t)(ASN1encoding_t enc, ASN1uint32_t tag, void *data);
typedef ASN1int32_t (ASN1CALL *ASN1BerDecFun_t)(ASN1decoding_t enc, ASN1uint32_t tag, void *data);
typedef struct tagASN1BerFunArr_t
{
    const ASN1BerEncFun_t *apfnEncoder;
    const ASN1BerDecFun_t *apfnDecoder;
}
    ASN1BerFunArr_t;

typedef void (ASN1CALL *ASN1GenericFun_t)(void);
typedef void (ASN1CALL *ASN1FreeFun_t)(void *data);

typedef struct tagASN1module_t
{
    ASN1magic_t             nModuleName;
    ASN1encodingrule_e      eRule;
    ASN1uint32_t            dwFlags;
    ASN1uint32_t            cPDUs;

    const ASN1FreeFun_t    *apfnFreeMemory;
    const ASN1uint32_t     *acbStructSize;
    union
    {
        ASN1PerFunArr_t     PER;
        ASN1BerFunArr_t     BER;
    };
}
    *ASN1module_t;


struct ASN1encoding_s
{
    ASN1magic_t         magic;  /* magic for this structure */
    ASN1uint32_t        version;/* version number of this library */
    ASN1module_t        module; /* module this encoding_t depends to */
    ASN1octet_t        *buf;    /* buffer to encode into */
    ASN1uint32_t        size;   /* current size of buffer */
    ASN1uint32_t        len;    /* len of encoded data in buffer */
    ASN1error_e         err;    /* error code for last encoding */
    ASN1uint32_t        bit;
    ASN1octet_t        *pos;
    ASN1uint32_t        cbExtraHeader;
    ASN1encodingrule_e  eRule;
    ASN1uint32_t        dwFlags;
};

struct ASN1decoding_s
{
    ASN1magic_t         magic;  /* magic for this structure */
    ASN1uint32_t        version;/* version number of this library */
    ASN1module_t        module; /* module this decoding_t depends to */
    ASN1octet_t        *buf;    /* buffer to decode from */
    ASN1uint32_t        size;   /* size of buffer */
    ASN1uint32_t        len;    /* len of decoded data in buffer */
    ASN1error_e         err;    /* error code for last decoding */
    ASN1uint32_t        bit;
    ASN1octet_t        *pos;
    ASN1encodingrule_e  eRule;
    ASN1uint32_t        dwFlags;
};


/* --- flags for functions --- */

#define ASN1DECFREE_NON_PDU_ID    ((ASN1uint32_t) -1)

enum
{
    ASN1FLAGS_NONE              = 0x00000000L, /* no flags */
    ASN1FLAGS_NOASSERT          = 0x00001000L, /* no asertion */
};

enum
{
    ASN1ENCODE_APPEND           = 0x00000001L, /* append to current buffer*/
    ASN1ENCODE_REUSEBUFFER      = 0x00000004L, /* empty destination buffer */
    ASN1ENCODE_SETBUFFER        = 0x00000008L, /* use a user-given destination buffer */
    ASN1ENCODE_ALLOCATEBUFFER   = 0x00000010L, /* do not free/reuse buffer */
    ASN1ENCODE_NOASSERT         = ASN1FLAGS_NOASSERT, /* no asertion */
};

enum
{
    ASN1DECODE_APPENDED         = 0x00000001L, /* continue behind last pdu*/
    ASN1DECODE_REWINDBUFFER     = 0x00000004L, /* rescan from buffer start*/
    ASN1DECODE_SETBUFFER        = 0x00000008L, /* use a user-given src buffer */
    ASN1DECODE_AUTOFREEBUFFER   = 0x00000010L, /* Assume responsibility for allocated buffer */
    ASN1DECODE_NOASSERT         = ASN1FLAGS_NOASSERT, /* no asertion */
};

/* ------ public basic ASN.1 API ------ */

extern ASN1_PUBLIC ASN1module_t ASN1API ASN1_CreateModule
(
    ASN1uint32_t            nVersion,
    ASN1encodingrule_e      eRule,
    ASN1uint32_t            dwFlags, /* ASN1FLAGS_NONE or ASN1FLAGS_NOASSERT */
    ASN1uint32_t            cPDU,
    const ASN1GenericFun_t  apfnEncoder[],
    const ASN1GenericFun_t  apfnDecoder[],
    const ASN1FreeFun_t     apfnFreeMemory[],
    const ASN1uint32_t      acbStructSize[],
    ASN1magic_t             nModuleName
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseModule
(
    ASN1module_t        pModule
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_CreateEncoder
(
    ASN1module_t        pModule,
    ASN1encoding_t     *ppEncoderInfo,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1encoding_t      pParent
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_Encode
(
    ASN1encoding_t      pEncoderInfo,
    void               *pDataStruct,
    ASN1uint32_t        nPduNum,
    ASN1uint32_t        dwFlags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseEncoder
(
    ASN1encoding_t      pEncoderInfo
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseEncoder2
(
    ASN1encoding_t      pEncoderInfo
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_CreateDecoder
(
    ASN1module_t        pModule,
    ASN1decoding_t     *ppDecoderInfo,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1decoding_t      pParent
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_CreateDecoderEx
(
    ASN1module_t        pModule,
    ASN1decoding_t     *ppDecoderInfo,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1decoding_t      pParent,
    ASN1uint32_t        dwFlags
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_Decode
(
    ASN1decoding_t      pDecoderInfo,
    void              **ppDataStruct,
    ASN1uint32_t        nPduNum,
    ASN1uint32_t        dwFlags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
);

extern ASN1_PUBLIC void ASN1API ASN1_CloseDecoder
(
    ASN1decoding_t      pDecoderInfo
);


extern ASN1_PUBLIC void ASN1API ASN1_FreeEncoded
(
    ASN1encoding_t      pEncoderInfo,
    void               *pBuf
);

extern ASN1_PUBLIC void ASN1API ASN1_FreeDecoded
(
    ASN1decoding_t      pDecoderInfo,
    void               *pDataStruct,
    ASN1uint32_t        nPduNum
);


/* ------ public advanced ASN.1 API ------ */

typedef enum
{
    // common set option
    ASN1OPT_CHANGE_RULE                 = 0x101,

    // common get option
    ASN1OPT_GET_RULE                    = 0x201,

    // set encoder option
    ASN1OPT_NOT_REUSE_BUFFER            = 0x301,
    ASN1OPT_REWIND_BUFFER               = 0x302,

    // get encoder option

    // set decoder option
    ASN1OPT_SET_DECODED_BUFFER          = 0x501,
    ASN1OPT_DEL_DECODED_BUFFER          = 0x502,

    // get decoder option
    ASN1OPT_GET_DECODED_BUFFER_SIZE     = 0x601,
}
    ASN1option_e;

typedef struct tagASN1optionparam_t
{
    ASN1option_e    eOption;
    union
    {
        ASN1encodingrule_e              eRule;
        ASN1uint32_t                    cbRequiredDecodedBufSize;
        struct
        {
            ASN1octet_t    *pbBuf;
            ASN1uint32_t    cbBufSize;
        }                               Buffer;
    };
}
    ASN1optionparam_t, ASN1optionparam_s;


extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_SetEncoderOption
(
    ASN1encoding_t      pEncoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_GetEncoderOption
(
    ASN1encoding_t      pEncoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_SetDecoderOption
(
    ASN1decoding_t      pDecoderInfo,
    ASN1optionparam_t  *pOptParam
);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1_GetDecoderOption
(
    ASN1decoding_t      pDecoderInfo,
    ASN1optionparam_t  *pOptParam
);


/* ------ internal ASN.1 API ------ */

extern ASN1_PUBLIC void ASN1API ASN1bitstring_free(ASN1bitstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1octetstring_free(ASN1octetstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1objectidentifier_free(ASN1objectidentifier_t *);
extern ASN1_PUBLIC void ASN1API ASN1charstring_free(ASN1charstring_t *);
extern ASN1_PUBLIC void ASN1API ASN1char16string_free(ASN1char16string_t *);
extern ASN1_PUBLIC void ASN1API ASN1char32string_free(ASN1char32string_t *);
extern ASN1_PUBLIC void ASN1API ASN1ztcharstring_free(ASN1ztcharstring_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar16string_free(ASN1ztchar16string_t);
extern ASN1_PUBLIC void ASN1API ASN1ztchar32string_free(ASN1ztchar32string_t);
extern ASN1_PUBLIC void ASN1API ASN1open_free(ASN1open_t *);
extern ASN1_PUBLIC void ASN1API ASN1utf8string_free(ASN1wstring_t *);

extern ASN1_PUBLIC void * ASN1API ASN1DecAlloc(ASN1decoding_t dec, ASN1uint32_t size);
extern ASN1_PUBLIC void * ASN1API ASN1DecRealloc(ASN1decoding_t dec, void *ptr, ASN1uint32_t size);
extern ASN1_PUBLIC void   ASN1API ASN1Free(void *ptr);

extern ASN1_PUBLIC ASN1error_e ASN1API ASN1EncSetError(ASN1encoding_t enc, ASN1error_e err);
extern ASN1_PUBLIC ASN1error_e ASN1API ASN1DecSetError(ASN1decoding_t dec, ASN1error_e err);

extern ASN1_PUBLIC void ASN1API ASN1intx_sub(ASN1intx_t *, ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1intx_uoctets(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_free(ASN1intx_t *);
extern ASN1_PUBLIC void ASN1API ASN1intx_add(ASN1intx_t *, ASN1intx_t *, ASN1intx_t *);
extern ASN1_PUBLIC ASN1int32_t ASN1intx2int32(ASN1intx_t *val);
extern ASN1_PUBLIC ASN1uint32_t ASN1intx2uint32(ASN1intx_t *val);
extern ASN1_PUBLIC int ASN1intxisuint32(ASN1intx_t *val);
extern ASN1_PUBLIC void ASN1intx_setuint32(ASN1intx_t *dst, ASN1uint32_t val);

extern ASN1_PUBLIC void ASN1API ASN1DbgMemTrackDumpCurrent ( ASN1uint32_t nModuleName );

extern ASN1_PUBLIC ASN1uint32_t ASN1API ASN1uint32_uoctets(ASN1uint32_t);

extern ASN1_PUBLIC int ASN1API ASN1objectidentifier_cmp(ASN1objectidentifier_t *v1, ASN1objectidentifier_t *v2);
extern ASN1_PUBLIC int ASN1API ASN1objectidentifier2_cmp(ASN1objectidentifier2_t *v1, ASN1objectidentifier2_t *v2);
extern ASN1_PUBLIC int ASN1API ASN1bitstring_cmp(ASN1bitstring_t *, ASN1bitstring_t *, int);
extern ASN1_PUBLIC int ASN1API ASN1octetstring_cmp(ASN1octetstring_t *, ASN1octetstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1objectidentifier_cmp(ASN1objectidentifier_t *, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1charstring_cmp(ASN1charstring_t *, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1char16string_cmp(ASN1char16string_t *, ASN1char16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1char32string_cmp(ASN1char32string_t *, ASN1char32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1ztcharstring_cmp(ASN1ztcharstring_t, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1ztchar16string_cmp(ASN1ztchar16string_t, ASN1ztchar16string_t);
extern ASN1_PUBLIC int ASN1API ASN1open_cmp(ASN1open_t *, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1generalizedtime_cmp(ASN1generalizedtime_t *, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1utctime_cmp(ASN1utctime_t *, ASN1utctime_t *);


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

typedef enum tagASN1real_e
{
    eReal_Normal,
    eReal_PlusInfinity,
    eReal_MinusInfinity
}
    ASN1real_e;

typedef struct tagASN1real_t
{
    ASN1real_e type;
    ASN1intx_t mantissa;
    ASN1uint32_t base;
    ASN1intx_t exponent;
}
    ASN1real_t;

typedef struct tagASN1external_t
{
#   define ASN1external_data_value_descriptor_o 0
    ASN1octet_t o[1];
    struct ASN1external_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1external_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1external_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1external_identification_context_negotiation_o 3
            struct ASN1external_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
        } u;
    } identification;
    ASN1objectdescriptor_t data_value_descriptor;
    struct ASN1external_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1external_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1external_data_value_encoded_o 1
            ASN1bitstring_t encoded;
        } u;
    } data_value;
}
    ASN1external_t;

typedef struct ASN1external_identification_s ASN1external_identification_t;
typedef struct ASN1external_identification_context_negotiation_s ASN1external_identification_context_negotiation_t;
typedef struct ASN1external_data_value_s ASN1external_data_value_t;

typedef struct tagASN1embeddedpdv_t
{
    struct ASN1embeddedpdv_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1embeddedpdv_identification_syntaxes_o 0
            struct ASN1embeddedpdv_identification_syntaxes_s
            {
                ASN1objectidentifier_t abstract;
                ASN1objectidentifier_t transfer;
            } syntaxes;
#            define ASN1embeddedpdv_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1embeddedpdv_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1embeddedpdv_identification_context_negotiation_o 3
            struct ASN1embeddedpdv_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
#            define ASN1embeddedpdv_identification_transfer_syntax_o 4
            ASN1objectidentifier_t transfer_syntax;
#            define ASN1embeddedpdv_identification_fixed_o 5
        } u;
    } identification;
    struct ASN1embeddedpdv_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1embeddedpdv_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1embeddedpdv_data_value_encoded_o 1
            ASN1bitstring_t encoded;
        } u;
    } data_value;
}
    ASN1embeddedpdv_t;

typedef struct ASN1embeddedpdv_identification_s ASN1embeddedpdv_identification_t;
typedef struct ASN1embeddedpdv_identification_syntaxes_s ASN1embeddedpdv_identification_syntaxes_t;
typedef struct ASN1embeddedpdv_identification_context_negotiation_s ASN1embeddedpdv_identification_context_negotiation_t;
typedef struct ASN1embeddedpdv_data_value_s ASN1embeddedpdv_data_value_t;

typedef struct tagASN1characterstring_t
{
    struct ASN1characterstring_identification_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1characterstring_identification_syntaxes_o 0
            struct ASN1characterstring_identification_syntaxes_s
            {
                ASN1objectidentifier_t abstract;
                ASN1objectidentifier_t transfer;
            } syntaxes;
#            define ASN1characterstring_identification_syntax_o 1
            ASN1objectidentifier_t syntax;
#            define ASN1characterstring_identification_presentation_context_id_o 2
            ASN1uint32_t presentation_context_id;
#            define ASN1characterstring_identification_context_negotiation_o 3
            struct ASN1characterstring_identification_context_negotiation_s
            {
                ASN1uint32_t presentation_context_id;
                ASN1objectidentifier_t transfer_syntax;
            } context_negotiation;
#            define ASN1characterstring_identification_transfer_syntax_o 4
            ASN1objectidentifier_t transfer_syntax;
#            define ASN1characterstring_identification_fixed_o 5
        } u;
    } identification;
    struct ASN1characterstring_data_value_s
    {
        ASN1uint8_t o;
        union
        {
#            define ASN1characterstring_data_value_notation_o 0
            ASN1open_t notation;
#            define ASN1characterstring_data_value_encoded_o 1
            ASN1octetstring_t encoded;
        } u;
    } data_value;
} ASN1characterstring_t;

typedef struct ASN1characterstring_identification_s ASN1characterstring_identification_t;
typedef struct ASN1characterstring_identification_syntaxes_s ASN1characterstring_identification_syntaxes_t;
typedef struct ASN1characterstring_identification_context_negotiation_s ASN1characterstring_identification_context_negotiation_t;
typedef struct ASN1characterstring_data_value_s ASN1characterstring_data_value_t;


extern ASN1_PUBLIC void ASN1API ASN1real_free(ASN1real_t *);
extern ASN1_PUBLIC void ASN1API ASN1external_free(ASN1external_t *);
extern ASN1_PUBLIC void ASN1API ASN1embeddedpdv_free(ASN1embeddedpdv_t *);
extern ASN1_PUBLIC void ASN1API ASN1characterstring_free(ASN1characterstring_t *);


#ifdef __cplusplus
}
#endif

#include <poppack.h> /* End 8-byte packing */

#endif // __MS_ASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\inetcore\inc\dxtranspguid.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for dxtransp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXRasterizer,0x9EA3B635,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTLabel,0xC0C17F0E,0xAE41,0x11d1,0x9A,0x3B,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDX2DDebug,0x03BB2457,0xA279,0x11d1,0x81,0xC6,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDX2D,0x9EFD02A9,0xA996,0x11d1,0x81,0xC9,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXGradient2,0xd0ef2a80,0x61dc,0x11d2,0xb2,0xeb,0x00,0xa0,0xc9,0x36,0xb2,0x12);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterBehavior,0x14D7DDDD,0xACA2,0x4E45,0x95,0x04,0x38,0x08,0xAB,0xEB,0x4F,0x92);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterBehaviorSite,0x909B23C2,0x9018,0x499f,0xA8,0x6D,0x4E,0x7D,0xA9,0x37,0xE9,0x31);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterCollection,0x22B07B33,0x8BFB,0x49d4,0x9B,0x90,0x09,0x38,0x37,0x0C,0x90,0x19);


MIDL_DEFINE_GUID(IID, IID_IDXTFilter,0x6187E5A2,0xA445,0x4608,0x8F,0xC0,0xBE,0x7A,0x6C,0x8D,0xB3,0x86);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterController,0x5CF315F2,0x273D,0x47B6,0xB9,0xED,0xF7,0x5D,0xC3,0xB0,0x15,0x0B);


MIDL_DEFINE_GUID(IID, IID_IDXTRedirectFilterInit,0xD1A57094,0x21F7,0x4e6c,0x93,0xE5,0xF5,0xF7,0x7F,0x74,0x82,0x93);


MIDL_DEFINE_GUID(IID, IID_IDXTClipOrigin,0xEE1663D8,0x0988,0x4C48,0x9F,0xD6,0xDB,0x44,0x50,0x88,0x56,0x68);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSPLib,0x527A4DA4,0x7F2C,0x11d2,0xB1,0x2D,0x00,0x00,0xF8,0x1F,0x59,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLabel,0x54702535,0x2606,0x11D1,0x99,0x9C,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXRasterizer,0x8652CE55,0x9E80,0x11D1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DX2D,0x473AA80B,0x4577,0x11D1,0x81,0xA8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterBehavior,0x649EEC1E,0xB579,0x4E8C,0xBB,0x3B,0x49,0x97,0xF8,0x42,0x65,0x36);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterFactory,0x81397204,0xF51A,0x4571,0x8D,0x7B,0xDC,0x03,0x05,0x21,0xAA,0xBD);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterCollection,0xA7EE7F34,0x3BD1,0x427f,0x92,0x31,0xF9,0x41,0xE9,0xB7,0xE1,0xFE);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for dxtransp.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXRasterizer,0x9EA3B635,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTLabel,0xC0C17F0E,0xAE41,0x11d1,0x9A,0x3B,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDX2DDebug,0x03BB2457,0xA279,0x11d1,0x81,0xC6,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDX2D,0x9EFD02A9,0xA996,0x11d1,0x81,0xC9,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXGradient2,0xd0ef2a80,0x61dc,0x11d2,0xb2,0xeb,0x00,0xa0,0xc9,0x36,0xb2,0x12);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterBehavior,0x14D7DDDD,0xACA2,0x4E45,0x95,0x04,0x38,0x08,0xAB,0xEB,0x4F,0x92);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterBehaviorSite,0x909B23C2,0x9018,0x499f,0xA8,0x6D,0x4E,0x7D,0xA9,0x37,0xE9,0x31);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterCollection,0x22B07B33,0x8BFB,0x49d4,0x9B,0x90,0x09,0x38,0x37,0x0C,0x90,0x19);


MIDL_DEFINE_GUID(IID, IID_IDXTFilter,0x6187E5A2,0xA445,0x4608,0x8F,0xC0,0xBE,0x7A,0x6C,0x8D,0xB3,0x86);


MIDL_DEFINE_GUID(IID, IID_IDXTFilterController,0x5CF315F2,0x273D,0x47B6,0xB9,0xED,0xF7,0x5D,0xC3,0xB0,0x15,0x0B);


MIDL_DEFINE_GUID(IID, IID_IDXTRedirectFilterInit,0xD1A57094,0x21F7,0x4e6c,0x93,0xE5,0xF5,0xF7,0x7F,0x74,0x82,0x93);


MIDL_DEFINE_GUID(IID, IID_IDXTClipOrigin,0xEE1663D8,0x0988,0x4C48,0x9F,0xD6,0xDB,0x44,0x50,0x88,0x56,0x68);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSPLib,0x527A4DA4,0x7F2C,0x11d2,0xB1,0x2D,0x00,0x00,0xF8,0x1F,0x59,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLabel,0x54702535,0x2606,0x11D1,0x99,0x9C,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXRasterizer,0x8652CE55,0x9E80,0x11D1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DX2D,0x473AA80B,0x4577,0x11D1,0x81,0xA8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterBehavior,0x649EEC1E,0xB579,0x4E8C,0xBB,0x3B,0x49,0x97,0xF8,0x42,0x65,0x36);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterFactory,0x81397204,0xF51A,0x4571,0x8D,0x7B,0xDC,0x03,0x05,0x21,0xAA,0xBD);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTFilterCollection,0xA7EE7F34,0x3BD1,0x427f,0x92,0x31,0xF9,0x41,0xE9,0xB7,0xE1,0xFE);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\inetcore\inc\mshtmlrc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Trident/MSHTML
//  Copyright (C) Microsoft Corporation, 1992 - 1998
//
//  File:       mshtmlrc.h
//
//  Contents:   Resource identifiers
//
//----------------------------------------------------------------------------


#ifndef I_MSHTMLRC_H_
#define I_MSHTMLRC_H_
#pragma INCMSG("--- Beg 'mshtmlrc.h'")


#define IDC_SELBAR                      2008    // Text select cursor for text site

#define IDC_NOSCROLLVH                  2025


#define IDC_HYPERLINK                   9801
#define IDC_HYPERLINK_OFFLINE           9802
#define IDC_HIBEAM                      9803
#define IDC_RESIZEROW2				    9804 
#define IDC_RESIZECOL2				    9805

#define IDR_DRAG_CONTEXT_MENU       24645  //0x6045  // bad id - not in core range

// HTML Form
#define IDR_HTMLFORM_MENUDESIGN     907
#define IDR_HTMLFORM_MENURUN        908
#define IDR_HTMLFORM_DOCDIR         909
#define IDS_HTMLFORM_USERTYPESHORT  181
#define IDS_HTMLFORM_USERTYPEFULL   180

// Form
#define IDR_ACCELS_SITE_DESIGN          41
#define IDR_ACCELS_SITE_RUN             40
#define IDR_ACCELS_FRAMESET_DESIGN      47
#define IDR_ACCELS_FRAMESET_RUN         46
#define IDR_ACCELS_INPUTTXT_DESIGN      43
#define IDR_ACCELS_INPUTTXT_RUN         42
#define IDR_ACCELS_TCELL_DESIGN         45
#define IDR_ACCELS_TCELL_RUN            44
#define IDR_ACCELS_BODY_RUN             48
#define IDR_ACCELS_BODY_DESIGN          49
#define IDR_ACCELS_TXTSITE_RUN          50
#define IDR_ACCELS_TXTSITE_DESIGN       51


//+------------------------------------------------------------------------
//
//  Error strings
//
//-------------------------------------------------------------------------
#define IDS_USERTYPEAPP                 2212    // Microsoft Forms 2.0
#define IDS_MESSAGE_BOX_TITLE           2213    // Microsoft Forms
#define IDS_ERROR_SOLUTION              2214    // Solution:\n<0s>
#define IDS_EA_SETTING_PROPERTY         2216    // Could not set property ...
#define IDS_EA_GETTING_PROPERTY         2217    // Could not get property ...
#define IDS_EA_CALLING_METHOD           2326    // Could not call method ...
#define IDS_EE_INVALID_PROPERTY_VALUE   2218    // The value entered is not valid ..
#define IDS_ES_ENTER_VALUE_IN_RANGE     2220    // Enter a value between..
#define IDS_ES_ENTER_VALUE_GT_ZERO      2221    // Enter a value greater than
#define IDS_ES_ENTER_VALUE_GE_ZERO      2222    // Enter a value greater than
#define IDS_EE_SETNOTSUPPORTEDATRUNTIME 2321    // Set property is not support at runtime.
#define IDS_EE_METHODNOTAPPLICABLE      2324
#define IDS_ES_ENTER_PROPER_VALUE       2325    // Enter a proper value
#define IDS_EE_INVALIDPICTURETYPE       2227    // CTL_E_INVALIDPICTURETYPE mouse icon must be a mouse icon
#define IDS_EE_CANTMOVEFOCUSTOCTRL      2322    // can't move focus to control because...
#define IDS_EE_INVALIDPICTURE           2331    // CTL_E_INVALIDPICTURE
#define IDS_EE_FAIL                     2330    // E_FAIL
#define IDS_EE_UNEXPECTED               2329    // E_UNEXPECTED
#define IDS_EE_INVALIDARG               2336    // E_INVALIDARG
#define IDS_EE_INVALIDPROPERTYARRAYINDEX 2332   // CTL_E_INVALIDPROPERTYARRAYINDEX
#define IDS_EE_INVALIDPROPERTYVALUE     2333    // CTL_E_INVALIDPROPERTYVALUE
#define IDS_EE_OVERFLOW                 2334    // CTL_E_OVERFLOW
#define IDS_EE_PERMISSIONDENIED         2335    // CTL_E_PERMISSIONDENIED
#define IDS_MSG_SAVE_MODIFIED_OBJECT    2223    // Save modified object?

#define IDS_CTRLPROPERTIES              2229
#define IDS_NAMEDCTRLPROPERTIES         2230
#define IDS_EA_PASTE_CONTROL            2235
#define IDS_EA_INSERT_CONTROL           2236

#define IDS_UNKNOWN_ERROR               2215    // Unknown error <0x>
#define IDS_EE_CONTROLNEEDSFOCUS        2327    // The control needs to have the focus
#define IDS_EE_NOTLICENSED              2337    // CLASS_E_NOTLICENSED
#define IDS_EE_INVALIDPASTETARGET       2338    // CTL_E_INVALIDPASTETARGET
#define IDS_EE_INVALIDPASTESOURCE       2339    // CTL_E_INVALIDPASTESOURCE

#define IDS_UNKNOWN                     2340

#define IDS_EE_INTERNET_INVALID_URL         2341
#define IDS_EE_INTERNET_NAME_NOT_RESOLVED   2342
#define IDS_EE_MISMATCHEDTAG                2345    // CTL_E_MISMATCHEDTAG
#define IDS_EE_INCOMPATIBLEPOINTERS         2346    // CTL_E_INCOMPATIBLEPOINTERS
#define IDS_EE_UNPOSITIONEDPOINTER          2347    // CTL_E_UNPOSITIONEDPOINTER
#define IDS_EE_UNPOSITIONEDELEMENT          2348    // CTL_E_UNPOSITIONEDELEMENT

#define IDS_EDITVERB                    2210
#define IDS_PROPVERB                    2211

//----------------------------------------------------------------------------
//
// Generic property page (52xx)
//
//----------------------------------------------------------------------------

#define IDS_PPG_GENERIC             5211
#define IDS_PPG_INLINE_STYLE        5212
#define IDC_PROPNAME                5204
#define IDE_PROPVALUE               5208

//----------------------------------------------------------------------------
//
// Misc strings
//
//----------------------------------------------------------------------------

//  The following IDS's must be kept in order, such that the
//    string for a given unit has the id IDS_UNITS_BASE + units
//    Otherwise, the StringToHimetric and HimetricToString functions
//    in himetric.cxx will break.  (chrisz)

#define IDS_UNITS_BASE                  2240
#define IDS_UNITS_INCH                  (IDS_UNITS_BASE+0)
#define IDS_UNITS_CM                    (IDS_UNITS_BASE+1)
#define IDS_UNITS_POINT                 (IDS_UNITS_BASE+2)


//----------------------------------------------------------------------------
//
// Undo strings
//
//----------------------------------------------------------------------------

#define IDS_UNDO                        (IDS_UNITS_POINT + 1)
#define IDS_REDO                        (IDS_UNDO + 1)
#define IDS_CANTUNDO                    (IDS_UNDO + 2)
#define IDS_CANTREDO                    (IDS_UNDO + 3)
#define IDS_UNDONEWCTRL                 (IDS_UNDO + 4)
#define IDS_UNDODELETE                  (IDS_UNDO + 5)
#define IDS_UNDOPROPCHANGE              (IDS_UNDO + 6)
#define IDS_UNDOMOVE                    (IDS_UNDO + 7)
#define IDS_UNDODRAGDROP                (IDS_UNDO + 9)
#define IDS_UNDOPASTE                   (IDS_UNDO + 15)
#define IDS_UNDOTYPING                  (IDS_UNDO + 16)
#define IDS_UNDOGENERICTEXT             (IDS_UNDO + 19)

#define IDS_E_CMDNOTSUPPORTED           2206


#define IDS_SITE_BASE      7999
#define IDS_HTMLDEFAULTFONT          (IDS_SITE_BASE + 19)
#define IDS_RUNAWAYSCRIPT            (IDS_SITE_BASE + 29)
#define IDS_PROTECTEDFROMUNSAFEOCX   (IDS_SITE_BASE + 31)
#define IDS_PROTECTEDFROMOCXINIT     (IDS_SITE_BASE + 32)
#define IDS_REPOSTFORMDATA           (IDS_SITE_BASE + 33)
#define IDS_OCXDISABLED              (IDS_SITE_BASE + 34)
#define IDS_MISMATCHEDXML            (IDS_SITE_BASE + 35)
#define IDS_DEBUGCONTINUE            (IDS_SITE_BASE + 36)
#define IDS_FMTDEBUGCONTINUE         (IDS_SITE_BASE + 37)

#define IDS_ERR_SAVEPICTUREAS        (IDS_SITE_BASE + 26)
#define IDS_ERR_SETWALLPAPER         (IDS_SITE_BASE + 27)
#define IDS_ERR_SETDESKTOPITEM       (IDS_SITE_BASE + 38)


//+----------------------------------------------------------------------------
//
// string used by script window
//
//----------------------------------------------------------------------------

#define IDS_OMWINDOW_FIRST             8300
#define IDS_VAR2STR_VTERROR             (IDS_OMWINDOW_FIRST + 0)
#define IDS_VAR2STR_VTNULL              (IDS_OMWINDOW_FIRST + 1)
#define IDS_VAR2STR_VTBOOL_TRUE         (IDS_OMWINDOW_FIRST + 2)
#define IDS_VAR2STR_VTBOOL_FALSE        (IDS_OMWINDOW_FIRST + 3)

//+----------------------------------------------------------------------------
//
// string used in conversion GetIDsOfNames
//
//----------------------------------------------------------------------------

#define IDS_DISPID_FIRST                8200                       // matches:
#define IDS_DISPID_FONTNAME             (IDS_DISPID_FIRST +  1)    // DISPID_CommonCtrl_FONTNAME
#define IDS_DISPID_FONTSIZE             (IDS_DISPID_FIRST +  2)    // DISPID_CommonCtrl_FONTSIZE
#define IDS_DISPID_FONTBOLD             (IDS_DISPID_FIRST +  3)    // DISPID_CommonCtrl_FONTBOLD
#define IDS_DISPID_FONTITAL             (IDS_DISPID_FIRST +  4)    // DISPID_CommonCtrl_FONTITAL
#define IDS_DISPID_FONTUNDER            (IDS_DISPID_FIRST +  5)    // DISPID_CommonCtrl_FONTUNDER
#define IDS_DISPID_BACKCOLOR            (IDS_DISPID_FIRST +  7)    // DISPID_BACKCOLOR
#define IDS_DISPID_BORDERCOLOR          (IDS_DISPID_FIRST +  9)    // DISPID_BORDERCOLOR
#define IDS_DISPID_BORDERSTYLE          (IDS_DISPID_FIRST + 10)    // DISPID_BORDERSTYLE
#define IDS_DISPID_TEXTALIGN            (IDS_DISPID_FIRST + 11)    // DISPID_CommonCtrl_TextAlign
#define IDS_DISPID_SPECIALEFFECT        (IDS_DISPID_FIRST + 12)    // DISPID_CommonCtrl_SpecialEffect
#define IDS_DISPID_FONTSUPERSCRIPT      (IDS_DISPID_FIRST + 13)    // DISPID_CommonCtrl_FONTSUPERSCRIPT
#define IDS_DISPID_FONTSUBSCRIPT        (IDS_DISPID_FIRST + 14)    // DISPID_CommonCtrl_FONTSUBSCRIPT

//+----------------------------------------------------------------------------
//
//  Button caption constants
//
//----------------------------------------------------------------------------

#define IDS_BUTTONCAPTION_RESET         8500
#define IDS_BUTTONCAPTION_SUBMIT        8501
#define IDS_BUTTONCAPTION_UPLOAD        8502

//+----------------------------------------------------------------------------
//
//  Printing constants
//
//----------------------------------------------------------------------------

#define IDS_PRINT_URLTITLE              8400
#define IDS_PRINT_URLCOL1HEAD           8401
#define IDS_PRINT_URLCOL2HEAD           8402
#define IDS_DEFAULTHEADER               8403
#define IDS_DEFAULTFOOTER               8404
#define IDS_DEFAULTMARGINTOP            8405
#define IDS_DEFAULTMARGINBOTTOM         8406
#define IDS_DEFAULTMARGINLEFT           8407
#define IDS_DEFAULTMARGINRIGHT          8408

//+----------------------------------------------------------------------------
//
// Progress status text strings
//
//-----------------------------------------------------------------------------

#define IDS_BINDSTATUS_DOWNLOADING                  8154
#define IDS_BINDSTATUS_DOWNLOADINGDATA_PICTURE      8155
#define IDS_BINDSTATUS_GENERATINGDATA_TEXT          8156
#define IDS_BINDSTATUS_DOWNLOADINGDATA_TEXT         8157
#define IDS_BINDSTATUS_INSTALLINGCOMPONENTS         8160
#define IDS_BINDSTATUS_DOWNLOADINGDATA_BITS         8167

#define IDS_DONE                                    8169

#define IDS_LOADINGTABLE                            8170
#define IDS_DATABINDING                             8171

#define IDS_FRIENDLYURL_SHORTCUTTO                  8172
#define IDS_FRIENDLYURL_AT                          8173
#define IDS_FRIENDLYURL_SENDSMAILTO                 8174
#define IDS_FRIENDLYURL_LOCAL                       8175
#define IDS_FRIENDLYURL_GOPHER                      8176
#define IDS_FRIENDLYURL_FTP                         8177
#define IDS_FRIENDLYURL_SECUREWEBSITE               8178

#define IDS_CANNOTLOAD                              8193
#define IDS_ONBEFOREUNLOAD_PREAMBLE                 8194
#define IDS_ONBEFOREUNLOAD_POSTAMBLE                8197

#define IDS_DEFAULT_ISINDEX_PROMPT                  8196


#define IDS_UNKNOWNPROTOCOL             2511    
#define IDS_SECURECONNECTIONINFO        2512
#define IDS_SECURE_LOW                  2513
#define IDS_SECURE_MEDIUM               2514
#define IDS_SECURE_HIGH                 2515
#define IDS_SECURESOURCE                2516

// Jave Script prompt() dialog
#define IDD_PROMPT_MSHTML                   8131
#define IDC_PROMPT_PROMPT                   8132
#define IDC_PROMPT_EDIT                     8133

// Plugin/ActiveX Viewer Not Installed dialog
#define IDD_PLUGIN_UPGRADE                  8134
#define IDC_PLUGIN_UPGRADE_CHECK            8135
#define IDC_PLUGIN_UPGRADE_EXTENSION        8136
#define IDC_PLUGIN_UPGRADE_MIME_TYPE        8137

#define IDS_PROPERTYOPENPICTURE     5010
#define IDS_PROPERTYOPENMOUSEICON   5011

#define IDS_HTMLFORM_SAVE                   8114

#define IDS_SAVEPICTUREAS_GIF               8116
#define IDS_SAVEPICTUREAS_JPG               8117
#define IDS_SAVEPICTUREAS_BMP               8118
#define IDS_SAVEPICTUREAS_XBM               8119
#define IDS_SAVEPICTUREAS_ART               8120
#define IDS_SAVEPICTUREAS_WMF               8121
#define IDS_SAVEPICTUREAS_EMF               8122
#define IDS_SAVEPICTUREAS_AVI               8123
#define IDS_SAVEPICTUREAS_MPG               8124
#define IDS_SAVEPICTUREAS_MOV               8125
#define IDS_SAVEPICTUREAS_ORIGINAL          8126
#define IDS_UNTITLED_BITMAP                 8127
#define IDS_UNTITLED_MSHTML                 8128
#define IDS_WALLPAPER_BMP                   8129
#define IDS_SAVEPICTUREAS_PNG               8138
#define IDS_UPLOADFILE              5444

#ifdef UNIX
#  define IDS_PRINT_ERROR             5445
#  define IDS_PRINT_ERROR_MSG         5446
#endif


#define IDS_DLAY_ERROR_BASE      8999
#define IDS_MSG_DB_CANTSAVE         (IDS_DLAY_ERROR_BASE + 1)
#define IDS_EE_DB_COERCE            (IDS_DLAY_ERROR_BASE + 2)
#define IDS_EE_DB_DELROW            (IDS_DLAY_ERROR_BASE + 3)
#define IDS_EE_DB_READ              (IDS_DLAY_ERROR_BASE + 4)
#define IDS_EE_DB_SCHEMA            (IDS_DLAY_ERROR_BASE + 5)
#define IDS_EE_DB_CANCELED          (IDS_DLAY_ERROR_BASE + 6)
#define IDS_EE_DB_OTHER_STATUS      (IDS_DLAY_ERROR_BASE + 7)

#define IDS_MENUHELP(idm) (10000 + (idm))
#define IDS_TOOLTIP(idm)  (20000 + (idm))

//+----------------------------------------------------------------------------
//
// HTML Block Format String
//
//-----------------------------------------------------------------------------

#define IDS_BLOCKFMT_NORMAL    1000
#define IDS_BLOCKFMT_PRE       1001
#define IDS_BLOCKFMT_ADDRESS   1002
#define IDS_BLOCKFMT_H1        1003
#define IDS_BLOCKFMT_H2        1004
#define IDS_BLOCKFMT_H3        1005
#define IDS_BLOCKFMT_H4        1006
#define IDS_BLOCKFMT_H5        1007
#define IDS_BLOCKFMT_H6        1008
#define IDS_BLOCKFMT_OL        1009
#define IDS_BLOCKFMT_UL        1010
#define IDS_BLOCKFMT_DIR       1011
#define IDS_BLOCKFMT_MENU      1012
#define IDS_BLOCKFMT_DT        1013
#define IDS_BLOCKFMT_DD        1014
#define IDS_BLOCKFMT_P         1016

#define IDS_HELPABOUT_STRING   1017

//+----------------------------------------------------------------------------
//
// default title caption for untitled HTML documents
//
//-----------------------------------------------------------------------------

#define IDS_NULL_TITLE         1020

// default document security property
#define IDS_DEFAULT_DOC_SECURITY_PROP       8130

//+----------------------------------------------------------------------------
//
//   MailTo constants
//
//----------------------------------------------------------------------------
#define IDS_MAILTO_DEFAULTSUBJECT       8600
#define IDS_MAILTO_MAILCLIENTNOTFOUND   8601
#define IDS_MAILTO_SUBMITALERT          8602

// New Encoding Menu
#define RES_STRING_ENCODING_MORE            4700

#if DBG == 1

#define IDS_COLOR_BLACK             5430
#define IDS_COLOR_NAVY              5431
#define IDS_COLOR_BLUE              5432
#define IDS_COLOR_CYAN              5433
#define IDS_COLOR_RED               5434
#define IDS_COLOR_LIME              5435
#define IDS_COLOR_GRAY              5436
#define IDS_COLOR_GREEN             5437
#define IDS_COLOR_YELLOW            5438
#define IDS_COLOR_PINK              5439
#define IDS_COLOR_VIOLET            5440
#define IDS_COLOR_WHITE             5441
// 5442 and 5443 replaced by html dialogs

#endif // DBG == 1

//----------------------------------------------------------------------------
//
// HTML dialog (53xx)
//
//----------------------------------------------------------------------------

#define IDS_WEBPAGEDIALOG           5301
#define IDS_CODEPAGE                5302

//----------------------------------------------------------------------------
//
// Icons
//
//----------------------------------------------------------------------------

#define RES_ICO_FRAME                   2660
#define RES_ICO_HTML                    2661
#define IDI_APPEARANCE                  2662
#define IDI_ADVANCED                    2663
#define IDI_GOTOURL                     2664
#define IDI_HOMEPAGE_MSHTML             2665
#define IDI_FINDTEXT                    2666
#define IDI_UNKNOWN_FILETYPE            2667
#define RES_ICO_GIF                     2668
#define RES_ICO_JPEG                    2669
#define RES_ICON_FOLDER_OPEN            2670
#define RES_ICON_FOLDER_CLOSED          2671
#define RES_ICON_URL_FILE               2672
#define RES_ICO_NOICON                  2673
#define RES_ICO_FINDING                 2674
#define RES_ICO_CONNECTING              2675
#define RES_ICO_ACCESSING               2676
#define RES_ICO_RECEIVING               2677
#define IDI_INTERNET                    2678
#define IDI_SECURITY                    2679
#define IDI_NEWS                        2680
#define IDI_VRML                        2681

#define IDB_DITHER                      2502
#define IDR_HATCHBMP                    2503    // Bitmap for border hatching
#define IDB_NOTLOADED                   2030
#define IDB_MISSING                     2031

//----------------------------------------------------------------------------
//
// Tab order dialog (3250 - 3260)
//
//----------------------------------------------------------------------------
#define IDR_TABORDERLBL             3250
#define IDR_TABORDERLSTBOX          3251
#define IDR_BTNMOVEUP               3252
#define IDR_BTNMOVEDOWN             3253
//#define IDR_BTNAUTOORDER            3254
#define IDR_TABORDERDLG             3255
//#define IDR_TABORDERMOVELBL         3256

// Menu index
#define MENU_INDEX_EDIT             1
#define MENU_INDEX_VIEW             2
#define MENU_INDEX_INSERT           3
#define MENU_INDEX_FORMAT           4


//

// unfortunately, these macros can't be used in defining
//  the symbols below: the resource compiler doesn't like them.
#define IDS_USERTYPEFULL(base)  ((base)/5)
#define IDS_USERTYPESHORT(base) ((base)/5 + 1)

#define IDR_FORM_CONTEXT_MENU       24640  //0x6040  // bad id - not in core range

#define CX_CONTEXTMENUOFFSET    2
#define CY_CONTEXTMENUOFFSET    2

#define RT_FILE                         2110



// siterc.h

// Add controls to the save as dialog.
#define IDC_SAVE_CHARSET_MSHTML    8194
#define IDR_BASE_HTMLFORM           900

#ifndef NO_HTML_DIALOG
// find resources are now located in shdocvw (peterlee)
//#define IDR_FINDDIALOG              _T("find.dlg")
//#define IDR_BIDIFINDDIALOG          _T("bidifind.dlg")
#define IDR_REPLACEDIALOG           _T("replace.dlg")
#define IDR_FORPARDIALOG            _T("forpar.dlg")
#define IDR_FORCHARDIALOG           _T("forchar.dlg")
#define IDR_GOBOOKDIALOG            _T("gobook.dlg")
#define IDR_INSIMAGEDIALOG          _T("insimage.dlg")
#define IDR_EDLINKDIALOG            _T("edlink.dlg")
#define IDR_EDBOOKDIALOG            _T("edbook.dlg")
#endif // NO_HTML_DIALOG


// otherrc.h
#define IDD_GENERICPAGE             5202
#define IDB_APPLY                   5209
#define IDB_OPENDLG                 5210

// window.close dialog string ID.
//
// BUGBUG (scotrobe): This same ID exists in
// resource.h in shdocvw. Don't change one 
// without the other.
//
#define IDS_CONFIRM_SCRIPT_CLOSE_TEXT 0x3035

#pragma INCMSG("--- End 'mshtmlrc.h'")
#else
#pragma INCMSG("*** Dup 'mshtmlrc.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\inetcore\inc\msoeimp.h ===
#ifndef _INC_NEWIMP_H
#define _INC_NEWIMP_H


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
// WARNING:  If you make changes to this header, you must also update  //
//           inetcore\published\inc\newimp.h !!!                       //
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


#ifndef NO_IMPORT_ERROR

#define HR_IMP_E(n) MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, n)
#define HR_IMP_S(n) MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, n)
#define HR_IMP      0x3000

#define hrFolderOpenFail    HR_IMP_E(HR_IMP + 1)
#define hrFolderReadFail    HR_IMP_E(HR_IMP + 2)
#define hrMapiInitFail      HR_IMP_E(HR_IMP + 3)
#define hrNoProfilesFound   HR_IMP_E(HR_IMP + 4)
#define hrDiskFull          HR_IMP_E(HR_IMP + 5)
#define hrUserCancel        HR_IMP_E(HR_IMP + 6)

#endif // NO_IMPORT_ERROR

typedef enum tagIMPORTFOLDERTYPE
    {
    FOLDER_TYPE_NORMAL = 0,
    FOLDER_TYPE_INBOX,
    FOLDER_TYPE_OUTBOX,
    FOLDER_TYPE_SENT,
    FOLDER_TYPE_DELETED,
    FOLDER_TYPE_DRAFT,
    CFOLDERTYPE
    } IMPORTFOLDERTYPE;

typedef struct IMSG IMSG;

typedef enum
    {
    MSG_TYPE_MAIL = 0,
    MSG_TYPE_NEWS
    } MSGTYPE;

#define MSG_STATE_UNREAD    0x0001
#define MSG_STATE_UNSENT    0x0002
#define MSG_STATE_SUBMITTED 0x0004
#define MSG_PRI_LOW         0x0010
#define MSG_PRI_NORMAL      0x0020
#define MSG_PRI_HIGH        0x0040
#define MSG_PRI_MASK        0x0070

// {E4499DE7-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IFolderImport, 0xE4499DE7L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

// provided by Athena or Outlook
typedef interface IFolderImport IFolderImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IFolderImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMessageCount(ULONG cMsg) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportMessage(MSGTYPE type, DWORD dwState, LPSTREAM pstm, const TCHAR **rgszAttach, DWORD cAttach) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportMessage(IMSG *pimsg) = 0;
    };
#else   /* C style interface */
typedef struct IFolderImportVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IFolderImport * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IFolderImport * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IFolderImport * This);

    HRESULT ( STDMETHODCALLTYPE *SetMessageCount )(
		IFolderImport * This,
		ULONG cMsg);
    HRESULT ( STDMETHODCALLTYPE *ImportMessageEx )(
		IFolderImport * This,
		MSGTYPE type, 
		DWORD dwState, 
		LPSTREAM pstm, 
		const TCHAR **rgszAttach, 
		DWORD cAttach);
    HRESULT ( STDMETHODCALLTYPE *ImportMessage )(
		IFolderImport * This,
		IMSG *pimsg);
    END_INTERFACE
} IFolderImportVtbl;

interface IFolderImport
{
    CONST_VTBL struct IFolderImportVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IFolderImport_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IFolderImport_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IFolderImport_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IFolderImport_SetMessageCount(This,cMsg)	\
	(This)->lpVtbl -> SetMessageCount(This,cMsg)
#define IFolderImport_ImportMessageEx(This,type,dwState,pstm,rgszAttach,cAttach)	\
	(This)->lpVtbl -> ImportMessageEx(This,type,dwState,pstm,rgszAttach,cAttach)
#define IFolderImport_ImportMessage(This,pimsg)	\
	(This)->lpVtbl -> ImportMessage(This,pimsg)
#endif /* COBJMACROS */

#endif  /* C style interface */



// {E4499DE8-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IMailImporter, 0xE4499DE8L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

// provided by Athena or Outlook
typedef interface IMailImporter IMailImporter;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IMailImporter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenFolder(DWORD_PTR dwCookie, const TCHAR *szFolder, IMPORTFOLDERTYPE type, DWORD dwFlags, IFolderImport **ppFldrImp, DWORD_PTR *pdwCookie) = 0;
    };
#else   /* C style interface */
typedef struct IMailImporterVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IMailImporter * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IMailImporter * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IMailImporter * This);

    HRESULT ( STDMETHODCALLTYPE *OpenFolder )(
		IMailImporter * This,
		DWORD_PTR dwCookie, 
		const TCHAR *szFolder, 
		IMPORTFOLDERTYPE type, 
		DWORD dwFlags, 
		IFolderImport **ppFldrImp, 
		DWORD_PTR *pdwCookie);
    END_INTERFACE
} IMailImporterVtbl;

interface IMailImporter
{
    CONST_VTBL struct IMailImporterVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IMailImporter_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IMailImporter_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IMailImporter_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IMailImporter_OpenFolder(This,dwCookie,szFolder,type,dwFlags,ppFldrImp,pdwCookie)	\
   (This)->lpVtbl -> OpenFolder(This,dwCookie,szFolder,type,dwFlags,ppFldrImp,pdwCookie)

#endif /* COBJMACROS */

#endif  /* C style interface */

typedef struct tagIMPORTFOLDER
    {
    DWORD_PTR           dwCookie;
    TCHAR               szName[MAX_PATH];
    IMPORTFOLDERTYPE    type;
    // DWORD       cMsg;
    BOOL                fSubFolders;
    DWORD               dwReserved1;
    DWORD               dwReserved2;
    } IMPORTFOLDER;

// {E4499DE9-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IEnumFOLDERS, 0xE4499DE9L, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

typedef interface IEnumFOLDERS IEnumFOLDERS;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IEnumFOLDERS : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next(IMPORTFOLDER *pfldr) = 0;
        virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;
    };
#else   /* C style interface */
typedef struct IEnumFOLDERSVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IEnumFOLDERS * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IEnumFOLDERS * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IEnumFOLDERS * This);

    HRESULT ( STDMETHODCALLTYPE *Next )(
		IEnumFOLDERS * This,
        IMPORTFOLDER *pfldr);
    HRESULT ( STDMETHODCALLTYPE *Reset )(
		IEnumFOLDERS * This);
    END_INTERFACE
} IEnumFOLDERSVtbl;

interface IEnumFOLDERS
{
    CONST_VTBL struct IEnumFOLDERSVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IEnumFOLDERS_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IEnumFOLDERS_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IEnumFOLDERS_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IEnumFOLDERS_Next(This,pfldr)	\
   (This)->lpVtbl -> Next(This,pfldr);
#define IEnumFOLDERS_Reset(This)	\
   (This)->lpVtbl -> Reset(This);
#endif /* COBJMACROS */

#endif  /* C style interface */


#define COOKIE_ROOT     MAXULONG_PTR

// {E4499DEA-9F57-11D0-8D5C-00C04FD6202B}
DEFINE_GUID(IID_IMailImport, 0xE4499DEAL, 0x9F57, 0x11D0, 0x8D, 0x5C, 0x00, 0xC0, 0x4F, 0xD6, 0x20, 0x2B);

typedef interface IMailImport IMailImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IMailImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitializeImport(HWND hwnd) = 0;
        virtual HRESULT STDMETHODCALLTYPE GetDirectory(char *szDir, UINT cch) = 0;
        virtual HRESULT STDMETHODCALLTYPE SetDirectory(char *szDir) = 0;
        virtual HRESULT STDMETHODCALLTYPE EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum) = 0;
        virtual HRESULT STDMETHODCALLTYPE ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport) = 0;
    };
#else   /* C style interface */
typedef struct IMailImportVtbl
{
    BEGIN_INTERFACE

    HRESULT ( STDMETHODCALLTYPE *QueryInterface )(
        IMailImport * This,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void **ppvObject);

    ULONG ( STDMETHODCALLTYPE *AddRef )(
        IMailImport * This);

    ULONG ( STDMETHODCALLTYPE *Release )(
        IMailImport * This);

    HRESULT ( STDMETHODCALLTYPE *InitializeImport )(
		IMailImport * This,
        HWND hwnd);
    HRESULT ( STDMETHODCALLTYPE *GetDirectory )(
		IMailImport * This,
        char *szDir, 
        UINT cch);
    HRESULT ( STDMETHODCALLTYPE *SetDirectory )(
		IMailImport * This,
        char *szDir);
    HRESULT ( STDMETHODCALLTYPE *EnumerateFolders )(
		IMailImport * This,
        DWORD_PTR dwCookie, 
		IEnumFOLDERS **ppEnum);
    HRESULT ( STDMETHODCALLTYPE *ImportFolder )(
		IMailImport * This,
        DWORD_PTR dwCookie, 
		IFolderImport *pImport);

    END_INTERFACE
} IMailImportVtbl;

interface IMailImport
{
    CONST_VTBL struct IMailImportVtbl *lpVtbl;
};

#ifdef COBJMACROS

#define IMailImport_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)
#define IMailImport_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)
#define IMailImport_Release(This)  \
    (This)->lpVtbl -> Release(This)
#define IMailImport_InitializeImport(This,hwnd) \
    (This)->lpVtbl -> InitializeImport(This,hwnd)
#define IMailImport_GetDirectory(This,szDir,cch)    \
    (This)->lpVtbl -> GetDirectory(This,szDir,cch)
#define IMailImport_SetDirectory(This,szDir)    \
    (This)->lpVtbl -> SetDirectory(This,szDir)
#define IMailImport_EnumerateFolders(This,dwCookie,ppEnum)  \
    (This)->lpVtbl -> EnumerateFolders(This,dwCookie,ppEnum)
#define IMailImport_ImportFolder(This,dwCookie,pImport) \
    (This)->lpVtbl -> ImportFolder(This,dwCookie,pImport)

#endif /* COBJMACROS */

#endif  /* C style interface */

#define achPerformImport    "PerformImport"
void PerformImport(HWND hwnd, IMailImporter *pMailImp, DWORD dwFlags);
typedef void (*PFNPERFORMIMPORT)(HWND, IMailImporter *, DWORD);

#define achPerformMigration "PerformMigration"
HRESULT PerformMigration(HWND hwnd, IMailImporter *pMailImp, DWORD dwFlags);
typedef HRESULT (*PFNPERFORMMIGRATION)(HWND, IMailImporter *, DWORD);

#endif // _INC_NEWIMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\inetcore\inc\httprequest_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for httprequest.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_WinHttp,0x662901fc,0x6951,0x4854,0x9e,0xb2,0xd9,0xa2,0x57,0x0f,0x2b,0x2e);


MIDL_DEFINE_GUID(IID, IID_IWinHttpRequest,0x016fe2ec,0xb2c8,0x45f8,0xb2,0x3b,0x39,0xe5,0x3a,0x75,0x39,0x6b);


MIDL_DEFINE_GUID(IID, IID_IWinHttpRequestEvents,0xf97f4e15,0xb787,0x4212,0x80,0xd1,0xd3,0x80,0xcb,0xbf,0x98,0x2e);


MIDL_DEFINE_GUID(CLSID, CLSID_WinHttpRequest,0x2087c2f4,0x2cef,0x4953,0xa8,0xab,0x66,0x77,0x9b,0x67,0x04,0x95);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for httprequest.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_WinHttp,0x662901fc,0x6951,0x4854,0x9e,0xb2,0xd9,0xa2,0x57,0x0f,0x2b,0x2e);


MIDL_DEFINE_GUID(IID, IID_IWinHttpRequest,0x016fe2ec,0xb2c8,0x45f8,0xb2,0x3b,0x39,0xe5,0x3a,0x75,0x39,0x6b);


MIDL_DEFINE_GUID(IID, IID_IWinHttpRequestEvents,0xf97f4e15,0xb787,0x4212,0x80,0xd1,0xd3,0x80,0xcb,0xbf,0x98,0x2e);


MIDL_DEFINE_GUID(CLSID, CLSID_WinHttpRequest,0x2087c2f4,0x2cef,0x4953,0xa8,0xab,0x66,0x77,0x9b,0x67,0x04,0x95);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\inetcore\inc\mshtmdbg.h ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       mshtmdbg.h
//
//  Contents:   External include file for mshtmdbg.dll
//
// ----------------------------------------------------------------------------

#ifndef _MSHTMDBG_H_
#define _MSHTMDBG_H_

#ifdef __cplusplus
extern "C" {
#endif

#define MSHTMDBG_API_VERSION    (7)     // Increment whenever API changes

struct IUnknown;

typedef INT     TRACETAG;
typedef INT_PTR PERFTAG;
typedef INT_PTR PERFMETERTAG;

DWORD       WINAPI  DbgExGetVersion();
BOOL        WINAPI  DbgExIsFullDebug();
void        WINAPI  DbgExSetDllMain(HANDLE hDllHandle, BOOL (WINAPI *)(HANDLE, DWORD, LPVOID));

void        WINAPI  DbgExDoTracePointsDialog(BOOL fWait);
void        WINAPI  DbgExRestoreDefaultDebugState();

BOOL        WINAPI  DbgExEnableTag(TRACETAG tag, BOOL fEnable);
BOOL        WINAPI  DbgExSetDiskFlag(TRACETAG tag, BOOL fSendToDisk);
BOOL        WINAPI  DbgExSetBreakFlag(TRACETAG tag, BOOL fBreak);
BOOL        WINAPI  DbgExIsTagEnabled(TRACETAG tag);
TRACETAG    WINAPI  DbgExFindTag(char * szTagDesc);

TRACETAG    WINAPI  DbgExTagError();
TRACETAG    WINAPI  DbgExTagWarning();
TRACETAG    WINAPI  DbgExTagThread();
TRACETAG    WINAPI  DbgExTagAssertExit();
TRACETAG    WINAPI  DbgExTagAssertStacks();
TRACETAG    WINAPI  DbgExTagMemoryStrict();
TRACETAG    WINAPI  DbgExTagCoMemoryStrict();
TRACETAG    WINAPI  DbgExTagMemoryStrictTail();
TRACETAG    WINAPI  DbgExTagMemoryStrictAlign();
TRACETAG    WINAPI  DbgExTagOLEWatch();
TRACETAG    WINAPI  DbgExTagRegisterTrace(CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled);
TRACETAG    WINAPI  DbgExTagRegisterOther(CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled);
TRACETAG    WINAPI  DbgExTagPerf();

BOOL        __cdecl DbgExTaggedTrace(TRACETAG tag, CHAR * szFmt, ...);
BOOL        __cdecl DbgExTaggedTraceEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, ...);
BOOL        WINAPI  DbgExTaggedTraceListEx(TRACETAG tag, USHORT usFlags, CHAR * szFmt, va_list valMarker);
void        WINAPI  DbgExTaggedTraceCallers(TRACETAG tag, int iStart, int cTotal);

BOOL        WINAPI  DbgExAssertImpl(char const * szFile, int iLine, char const * szMessage);
void        WINAPI  DbgExAssertThreadDisable(BOOL fDisable);
HRESULT     __cdecl DbgExCheckAndReturnResult(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, ...);
HRESULT     WINAPI  DbgExCheckAndReturnResultList(HRESULT hr, BOOL fTrace, LPSTR pstrFile, UINT line, int cHResult, va_list valMarker);

size_t      WINAPI  DbgExPreAlloc(size_t cbRequest);
void *      WINAPI  DbgExPostAlloc(void *pv);
void *      WINAPI  DbgExPreFree(void *pv);
void        WINAPI  DbgExPostFree();
size_t      WINAPI  DbgExPreRealloc(void *pvRequest, size_t cbRequest, void **ppv);
void *      WINAPI  DbgExPostRealloc(void *pv);
void *      WINAPI  DbgExPreGetSize(void *pvRequest);
size_t      WINAPI  DbgExPostGetSize(size_t cb);
void *      WINAPI  DbgExPreDidAlloc(void *pvRequest);
BOOL        WINAPI  DbgExPostDidAlloc(void *pvRequest, BOOL fActual);

void        WINAPI  DbgExMemoryTrackDisable(BOOL fDisable);
void        WINAPI  DbgExCoMemoryTrackDisable(BOOL fDisable);
void        WINAPI  DbgExMemoryBlockTrackDisable(void * pv);
void        WINAPI  DbgExMemSetHeader(void * pvRequest, size_t cb, PERFMETERTAG mt);
void *      WINAPI  DbgExGetMallocSpy();
void        WINAPI  DbgExTraceMemoryLeaks();
BOOL        WINAPI  DbgExValidateInternalHeap();

LONG_PTR    WINAPI  DbgExTraceFailL(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
LONG_PTR    WINAPI  DbgExTraceWin32L(LONG_PTR errExpr, LONG_PTR errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
HRESULT     WINAPI  DbgExTraceHR(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
HRESULT     WINAPI  DbgExTraceOLE(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line, LPVOID lpsite);
void        WINAPI  DbgExTraceEnter(LPSTR pstrExpr, LPSTR pstrFile, int line);
void        WINAPI  DbgExTraceExit(LPSTR pstrExpr, LPSTR pstrFile, int line);
void        WINAPI  DbgExSetSimFailCounts(int firstFailure, int cInterval);
void        WINAPI  DbgExShowSimFailDlg();
BOOL        WINAPI  DbgExFFail();
int         WINAPI  DbgExGetFailCount();
void        WINAPI  DbgExTrackItf(REFIID iid, char * pch, BOOL fTrackOnQI, void **ppv);

void        WINAPI  DbgExOpenViewObjectMonitor(HWND hwndOwner, IUnknown *pUnk, BOOL fUseFrameSize);
void        WINAPI  DbgExOpenMemoryMonitor();
void        WINAPI  DbgExOpenLogFile(LPCSTR szFName);

void *      __cdecl DbgExMemSetName(void *pvRequest, char * szFmt, ...);
void *      WINAPI  DbgExMemSetNameList(void * pvRequest, char * szFmt, va_list valMarker);
char *      WINAPI  DbgExMemGetName(void *pvRequest);

HRESULT     WINAPI  DbgExWsClear(HANDLE hProcess);
HRESULT     WINAPI  DbgExWsTakeSnapshot(HANDLE hProcess);
BSTR        WINAPI  DbgExWsGetModule(long row);
BSTR        WINAPI  DbgExWsGetSection(long row);
long        WINAPI  DbgExWsSize(long row);
long        WINAPI  DbgExWsCount();
long        WINAPI  DbgExWsTotal();
HRESULT     WINAPI  DbgExWsStartDelta(HANDLE hProcess);
long        WINAPI  DbgExWsEndDelta(HANDLE hProcess);

void        WINAPI  DbgExDumpProcessHeaps();

PERFTAG     WINAPI  DbgExPerfRegister(char * szTag, char * szOwner, char * szDescrip);
void        __cdecl DbgExPerfLogFn(PERFTAG tag, void * pvObj, const char * pchFmt, ...);
void        WINAPI  DbgExPerfLogFnList(PERFTAG tag, void * pvObj, const char * pchFmt, va_list valMarker);
void        WINAPI  DbgExPerfDump();
void        WINAPI  DbgExPerfClear();
void        WINAPI  DbgExPerfTags();
void        WINAPI  DbgExPerfEnable(BOOL fEnable);

char *      WINAPI  DbgExDecodeMessage(UINT msg);

PERFMETERTAG WINAPI  DbgExMtRegister(char * szTag, char * szOwner, char * szDescrip);
void        WINAPI  DbgExMtAdd(PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal);
void        WINAPI  DbgExMtSet(PERFMETERTAG mt, LONG lCnt, LONG_PTR lVal);
char *      WINAPI  DbgExMtGetName(PERFMETERTAG mt);
char *      WINAPI  DbgExMtGetDesc(PERFMETERTAG mt);
BOOL        WINAPI  DbgExMtSimulateOutOfMemory(PERFMETERTAG mt, LONG_PTR lNewValue);
void        WINAPI  DbgExMtOpenMonitor();
void        WINAPI  DbgExMtLogDump(LPSTR pchFile);
PERFMETERTAG WINAPI  DbgExMtLookupMeter(char * szTag);
long        WINAPI  DbgExMtGetMeterCnt(PERFMETERTAG mt, BOOL fExclusive);
long        WINAPI  DbgExMtGetMeterVal(PERFMETERTAG mt, BOOL fExclusive);

void        WINAPI  DbgExSetTopUrl(LPWSTR pstrUrl);
void        WINAPI  DbgExGetSymbolFromAddress(void * pvAddr, char * pszBuf, DWORD cchBuf);

BOOL        WINAPI  DbgExGetChkStkFill(DWORD * pdwFill);
int         WINAPI  DbgExGetStackTrace(int iStart, int cTotal, BYTE *pbBuffer, int cbBuffer, int cchModule, int cchSymbol);

#ifdef __cplusplus
}
#endif

// Performance Logging --------------------------------------------------------

#ifdef PERFTAGS

#define     IsPerfEnabled(tag) (*(BOOL *)tag)
#define     PerfTag(tag, szOwner, szDescrip) PERFTAG tag(DbgExPerfRegister(#tag, szOwner, szDescrip));
#define     PerfExtern(tag) extern PERFTAG tag;
#define     PerfLog(tag,pv,f) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f) : 0
#define     PerfLog1(tag,pv,f,a1) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1) : 0
#define     PerfLog2(tag,pv,f,a1,a2) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2) : 0
#define     PerfLog3(tag,pv,f,a1,a2,a3) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3) : 0
#define     PerfLog4(tag,pv,f,a1,a2,a3,a4) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4) : 0
#define     PerfLog5(tag,pv,f,a1,a2,a3,a4,a5) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5) : 0
#define     PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6) : 0
#define     PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) : 0
#define     PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) : 0
#define     PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) IsPerfEnabled(tag) ? DbgExPerfLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) : 0
#define     PerfDump()  DbgExPerfDump()
#define     PerfClear() DbgExPerfClear()
#define     PerfTags()  DbgExPerfTags()
#define     PerfEnable(fEnable) DbgExPerfEnable(fEnable)

#else

#define     IsPerfEnabled(tag) (FALSE)
#define     PerfTag(tag, szOwner, szDescrip)
#define     PerfExtern(tag)
#define     PerfLog(tag,pv,f)
#define     PerfLog1(tag,pv,f,a1)
#define     PerfLog2(tag,pv,f,a1,a2)
#define     PerfLog3(tag,pv,f,a1,a2,a3)
#define     PerfLog4(tag,pv,f,a1,a2,a3,a4)
#define     PerfLog5(tag,pv,f,a1,a2,a3,a4,a5)
#define     PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6)
#define     PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
#define     PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
#define     PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
#define     PerfDump()
#define     PerfClear()
#define     PerfTags()
#define     PerfEnable(fEnable)

#endif

// Performance Metering -------------------------------------------------------

#ifdef PERFMETER

#define     Mt(x)                               g_mt##x
#define     MtExtern(tag)                       extern PERFMETERTAG g_mt##tag;
#define     MtDefine(tag, tagOwner, szDescrip)  PERFMETERTAG g_mt##tag(DbgExMtRegister("mt" #tag, "mt" #tagOwner, szDescrip));
#define     MtAdd(mt, lCnt, lVal)               DbgExMtAdd(mt, lCnt, lVal)
#define     MtSet(mt, lCnt, lVal)               DbgExMtSet(mt, lCnt, lVal)
#define     MtSimulateOutOfMemory(mt, lNewVal)  DbgExMtSimulateOutOfMemory(mt, lNewVal)
#define     MtOpenMonitor()                     DbgExMtOpenMonitor()

#else

#define     Mt(x)                               ((PERFMETERTAG)0)
#define     MtExtern(tag)
#define     MtDefine(tag, szOwner, szDescrip)
#define     MtAdd(mt, lCnt, lVal)
#define     MtSet(mt, lCnt, lVal)
#define     MtSimulateOutOfMemory(mt, lNewValue)
#define     MtOpenMonitor()

#endif

// MSHTML perf control --------------------------------------------------------

#define HTMPERFCTL_NAME     "#MSHTML#PERF#"

enum
{
    HTMPF_CALLBACK_ONLOAD   = 0x00000001,   // callback when topdoc loaded (dwArg1:HTMPF_CALLBACK_ONLOAD, dwArg2: strURL)
    HTMPF_ENABLE_PROFILE    = 0x00000002,   // enable profiling
    HTMPF_ENABLE_MEMWATCH   = 0x00000004,   // enable memwatch sampling
    HTMPF_DISABLE_PADEVENTS = 0x00000008,   // disable firing of events from mshtmpad.exe
    HTMPF_DISABLE_IMGCACHE  = 0x00000010,   // disable image cache in mshtml
    HTMPF_DISABLE_OFFSCREEN = 0x00000020,   // disable offscreen buffering
    HTMPF_DISABLE_ALERTS    = 0x00000040,   // disable alert() and confirm() methods
    HTMPF_SYNC_DATABIND     = 0x00000080,   // grab all records at once for databinding
    HTMPF_CALLBACK_ONLOAD2  = 0x00000100,   // callback when topdoc loaded (dwArg1:HTMPF_CALLBACK_ONLOAD, dwArg2: CDoc IUnk)
    HTMPF_CALLBACK_ONVIEWQ  = 0x00000200,   // callback when ensure view is queued (dwArg1: HTMPF_CALLBACK_ONVIEWQ, dwArg2: CDoc IUnk)
    HTMPF_CALLBACK_ONVIEWD  = 0x00000400,   // callback when ensure view is dequeued (dwArg1: HTMPF_CALLBACK_ONVIEWD, dwArg2: CDoc IUnk)
#ifndef NO_ETW_TRACING
    HTMPF_CALLBACK_ONEVENT  = 0x00000800    // callback when event tracing for windows is enabled
                                            // (dwArg1: UCHAR EVENT-TYPE, dwArg2: WCHAR* URL)
                                            // See shlwapi.w for event types.
#endif
};

typedef void (WINAPI *HTMPFCBFN)(DWORD dwArg1, void * pvArg2);

typedef struct HTMPERFCTL
{
    DWORD       dwSize;     // set to sizeof(MSHTMLPERF)
    DWORD       dwFlags;    // see HTMPF_*
    HTMPFCBFN   pfnCall;    // Callback function
    void *      pvHost;     // Private data for host
} HTMPERFCTL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\inetcore\inc\interned.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for interned.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __interned_h__
#define __interned_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISelectionObject2_FWD_DEFINED__
#define __ISelectionObject2_FWD_DEFINED__
typedef interface ISelectionObject2 ISelectionObject2;
#endif 	/* __ISelectionObject2_FWD_DEFINED__ */


#ifndef __IHTMLEditor_FWD_DEFINED__
#define __IHTMLEditor_FWD_DEFINED__
typedef interface IHTMLEditor IHTMLEditor;
#endif 	/* __IHTMLEditor_FWD_DEFINED__ */


#ifndef __IHTMLPrivateWindow_FWD_DEFINED__
#define __IHTMLPrivateWindow_FWD_DEFINED__
typedef interface IHTMLPrivateWindow IHTMLPrivateWindow;
#endif 	/* __IHTMLPrivateWindow_FWD_DEFINED__ */


#ifndef __IHTMLPrivateWindow2_FWD_DEFINED__
#define __IHTMLPrivateWindow2_FWD_DEFINED__
typedef interface IHTMLPrivateWindow2 IHTMLPrivateWindow2;
#endif 	/* __IHTMLPrivateWindow2_FWD_DEFINED__ */


#ifndef __IHTMLPrivateWindow3_FWD_DEFINED__
#define __IHTMLPrivateWindow3_FWD_DEFINED__
typedef interface IHTMLPrivateWindow3 IHTMLPrivateWindow3;
#endif 	/* __IHTMLPrivateWindow3_FWD_DEFINED__ */


#ifndef __ISubDivisionProvider_FWD_DEFINED__
#define __ISubDivisionProvider_FWD_DEFINED__
typedef interface ISubDivisionProvider ISubDivisionProvider;
#endif 	/* __ISubDivisionProvider_FWD_DEFINED__ */


#ifndef __IElementBehaviorUI_FWD_DEFINED__
#define __IElementBehaviorUI_FWD_DEFINED__
typedef interface IElementBehaviorUI IElementBehaviorUI;
#endif 	/* __IElementBehaviorUI_FWD_DEFINED__ */


#ifndef __IElementAdorner_FWD_DEFINED__
#define __IElementAdorner_FWD_DEFINED__
typedef interface IElementAdorner IElementAdorner;
#endif 	/* __IElementAdorner_FWD_DEFINED__ */


#ifndef __IHTMLEditingServices_FWD_DEFINED__
#define __IHTMLEditingServices_FWD_DEFINED__
typedef interface IHTMLEditingServices IHTMLEditingServices;
#endif 	/* __IHTMLEditingServices_FWD_DEFINED__ */


#ifndef __IEditDebugServices_FWD_DEFINED__
#define __IEditDebugServices_FWD_DEFINED__
typedef interface IEditDebugServices IEditDebugServices;
#endif 	/* __IEditDebugServices_FWD_DEFINED__ */


#ifndef __IPrivacyServices_FWD_DEFINED__
#define __IPrivacyServices_FWD_DEFINED__
typedef interface IPrivacyServices IPrivacyServices;
#endif 	/* __IPrivacyServices_FWD_DEFINED__ */


#ifndef __IHTMLOMWindowServices_FWD_DEFINED__
#define __IHTMLOMWindowServices_FWD_DEFINED__
typedef interface IHTMLOMWindowServices IHTMLOMWindowServices;
#endif 	/* __IHTMLOMWindowServices_FWD_DEFINED__ */


#ifndef __IHTMLFilterPainter_FWD_DEFINED__
#define __IHTMLFilterPainter_FWD_DEFINED__
typedef interface IHTMLFilterPainter IHTMLFilterPainter;
#endif 	/* __IHTMLFilterPainter_FWD_DEFINED__ */


#ifndef __IHTMLFilterPaintSite_FWD_DEFINED__
#define __IHTMLFilterPaintSite_FWD_DEFINED__
typedef interface IHTMLFilterPaintSite IHTMLFilterPaintSite;
#endif 	/* __IHTMLFilterPaintSite_FWD_DEFINED__ */


#ifndef __IElementNamespacePrivate_FWD_DEFINED__
#define __IElementNamespacePrivate_FWD_DEFINED__
typedef interface IElementNamespacePrivate IElementNamespacePrivate;
#endif 	/* __IElementNamespacePrivate_FWD_DEFINED__ */


/* header files for imported files */
#include "dimm.h"
#include "mshtml.h"
#include "mshtmhst.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_interned_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// internal.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// TRIDENT Editing Services Interfaces.
//

#ifndef INTERNAL_H_
#define INTERNAL_H_



extern RPC_IF_HANDLE __MIDL_itf_interned_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_interned_0000_v0_0_s_ifspec;


#ifndef __MSHTMLINTERNAL_LIBRARY_DEFINED__
#define __MSHTMLINTERNAL_LIBRARY_DEFINED__

/* library MSHTMLINTERNAL */
/* [uuid][version][helpstring][lcid] */ 

typedef 
enum _EDITOR_NOTIFICATION
    {	EDITOR_NOTIFY_TIMER_TICK	= 0,
	EDITOR_NOTIFY_DOC_ENDED	= 1,
	EDITOR_NOTIFY_DOC_CHANGED	= 2,
	EDITOR_NOTIFY_CARET_IN_CONTEXT	= 3,
	EDITOR_NOTIFY_EXIT_TREE	= 4,
	EDITOR_NOTIFY_LOSE_FOCUS_FRAME	= 5,
	EDITOR_NOTIFY_LOSE_FOCUS	= 6,
	EDITOR_NOTIFY_BEFORE_FOCUS	= 7,
	EDITOR_NOTIFY_YIELD_FOCUS	= 8,
	EDITOR_NOTIFY_EDITABLE_CHANGE	= 9,
	EDITOR_NOTIFY_BEGIN_SELECTION_UNDO	= 10,
	EDITOR_NOTIFY_ATTACH_WIN	= 11,
	EDITOR_NOTIFY_UPDATE_CARET	= 12,
	EDITOR_NOTIFY_BEFORE_CURRENCY_CHANGE	= 13,
	EDITOR_NOTIFY_SETTING_VIEW_LINK	= 14,
	EDITOR_NOTIFY_CONTAINER_ENDED	= 15,
	EDITOR_NOTIFICATION_Max	= 2147483647L
    } 	EDITOR_NOTIFICATION;

typedef 
enum _DOCNAVFLAGS
    {	DOCNAVFLAG_DOCNAVIGATE	= 1,
	DOCNAVFLAG_DONTUPDATETLOG	= 2,
	DOCNAVFLAG_HTTPERRORPAGE	= 4,
	DOCNAVFLAG_OPENINNEWWINDOW	= 8,
	DOCNAVFLAG_REFRESH	= 16,
	DOCNAVFLAGS_Max	= 2147483647L
    } 	DOCNAVFLAGS;

typedef 
enum _NAVIGATEEXOPTIONS
    {	NAVIGATEEX_NONE	= 0,
	NAVIGATEEX_DONTUPDATETRAVELLOG	= 1,
	NAVIGATEEXOPTIONS_Max	= 2147483647L
    } 	NAVIGATEEXOPTIONS;

typedef 
enum _CHAR_FORMAT_FAMILY
    {	CHAR_FORMAT_None	= 0,
	CHAR_FORMAT_FontStyle	= 1,
	CHAR_FORMAT_FontInfo	= 2,
	CHAR_FORMAT_FontName	= 4,
	CHAR_FORMAT_ColorInfo	= 8,
	CHAR_FORMAT_ParaFormat	= 16,
	CHAR_FORMAT_FAMILY_Max	= 2147483647L
    } 	CHAR_FORMAT_FAMILY;

typedef 
enum _LAYOUT_MOVE_UNIT
    {	LAYOUT_MOVE_UNIT_PreviousLine	= 1,
	LAYOUT_MOVE_UNIT_NextLine	= 2,
	LAYOUT_MOVE_UNIT_CurrentLineStart	= 3,
	LAYOUT_MOVE_UNIT_CurrentLineEnd	= 4,
	LAYOUT_MOVE_UNIT_NextLineStart	= 5,
	LAYOUT_MOVE_UNIT_PreviousLineEnd	= 6,
	LAYOUT_MOVE_UNIT_TopOfWindow	= 7,
	LAYOUT_MOVE_UNIT_BottomOfWindow	= 8,
	LAYOUT_MOVE_UNIT_OuterLineStart	= 9,
	LAYOUT_MOVE_UNIT_OuterLineEnd	= 10,
	LAYOUT_MOVE_UNIT_Max	= 2147483647L
    } 	LAYOUT_MOVE_UNIT;

typedef 
enum _CARET_GRAVITY
    {	CARET_GRAVITY_NoChange	= 0,
	CARET_GRAVITY_BeginningOfLine	= 1,
	CARET_GRAVITY_EndOfLine	= 2,
	CARET_GRAVITY_Max	= 2147483647L
    } 	CARET_GRAVITY;

typedef 
enum _CARET_VISIBILITY
    {	CARET_TYPE_Hide	= 0,
	CARET_TYPE_Show	= 1,
	CARET_VISIBILITY_Max	= 2147483647L
    } 	CARET_VISIBILITY;

typedef 
enum _POINTER_SCROLLPIN
    {	POINTER_SCROLLPIN_TopLeft	= 0,
	POINTER_SCROLLPIN_BottomRight	= 1,
	POINTER_SCROLLPIN_Minimal	= 2,
	POINTER_SCROLLPIN_Max	= 2147483647L
    } 	POINTER_SCROLLPIN;

typedef 
enum _ADORNER_HTI
    {	ADORNER_HTI_NONE	= 0,
	ADORNER_HTI_TOPBORDER	= 1,
	ADORNER_HTI_LEFTBORDER	= 2,
	ADORNER_HTI_BOTTOMBORDER	= 3,
	ADORNER_HTI_RIGHTBORDER	= 4,
	ADORNER_HTI_TOPLEFTHANDLE	= 5,
	ADORNER_HTI_LEFTHANDLE	= 6,
	ADORNER_HTI_TOPHANDLE	= 7,
	ADORNER_HTI_BOTTOMLEFTHANDLE	= 8,
	ADORNER_HTI_TOPRIGHTHANDLE	= 9,
	ADORNER_HTI_BOTTOMHANDLE	= 10,
	ADORNER_HTI_RIGHTHANDLE	= 11,
	ADORNER_HTI_BOTTOMRIGHTHANDLE	= 12,
	ADORNER_HTI_Max	= 2147483647L
    } 	ADORNER_HTI;

typedef 
enum _FILTER_DRAW_LAYERS
    {	FILTER_DRAW_BORDER	= 0x1,
	FILTER_DRAW_BACKGROUND	= 0x2,
	FILTER_DRAW_CONTENT	= 0x4,
	FILTER_DRAW_ALLLAYERS	= 0x7,
	FILTER_DRAW_LAYERS_Max	= 2147483647L
    } 	FILTER_DRAW_LAYERS;

typedef 
enum _FILTER_FLAGS
    {	FILTER_FLAGS_PAGETRANSITION	= 0x1,
	FILTER_FLAGS_Max	= 2147483647L
    } 	FILTER_FLAGS;

typedef struct _HTMLPtrDispInfoRec
    {
    DWORD dwSize;
    LONG lBaseline;
    LONG lXPosition;
    LONG lLineHeight;
    LONG lTextHeight;
    LONG lDescent;
    LONG lTextDescent;
    BOOL fRTLLine;
    BOOL fRTLFlow;
    BOOL fAligned;
    BOOL fHasNestedRunOwner;
    } 	HTMLPtrDispInfoRec;




EXTERN_C const IID LIBID_MSHTMLINTERNAL;

#ifndef __ISelectionObject2_INTERFACE_DEFINED__
#define __ISelectionObject2_INTERFACE_DEFINED__

/* interface ISelectionObject2 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_ISelectionObject2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f7fc-98b5-11cf-bb82-00aa00bdce0b")
    ISelectionObject2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Select( 
            /* [in] */ ISegmentList *pISegmentList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPointerInSelection( 
            /* [in] */ IDisplayPointer *pIDispPointer,
            /* [out] */ BOOL *pfPointerInSelection,
            /* [in] */ POINT *pptGlobal,
            /* [in] */ IHTMLElement *pIElementOver) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EmptySelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroySelection( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyAllSelection( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISelectionObject2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISelectionObject2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISelectionObject2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISelectionObject2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            ISelectionObject2 * This,
            /* [in] */ ISegmentList *pISegmentList);
        
        HRESULT ( STDMETHODCALLTYPE *IsPointerInSelection )( 
            ISelectionObject2 * This,
            /* [in] */ IDisplayPointer *pIDispPointer,
            /* [out] */ BOOL *pfPointerInSelection,
            /* [in] */ POINT *pptGlobal,
            /* [in] */ IHTMLElement *pIElementOver);
        
        HRESULT ( STDMETHODCALLTYPE *EmptySelection )( 
            ISelectionObject2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DestroySelection )( 
            ISelectionObject2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyAllSelection )( 
            ISelectionObject2 * This);
        
        END_INTERFACE
    } ISelectionObject2Vtbl;

    interface ISelectionObject2
    {
        CONST_VTBL struct ISelectionObject2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISelectionObject2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISelectionObject2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISelectionObject2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISelectionObject2_Select(This,pISegmentList)	\
    (This)->lpVtbl -> Select(This,pISegmentList)

#define ISelectionObject2_IsPointerInSelection(This,pIDispPointer,pfPointerInSelection,pptGlobal,pIElementOver)	\
    (This)->lpVtbl -> IsPointerInSelection(This,pIDispPointer,pfPointerInSelection,pptGlobal,pIElementOver)

#define ISelectionObject2_EmptySelection(This)	\
    (This)->lpVtbl -> EmptySelection(This)

#define ISelectionObject2_DestroySelection(This)	\
    (This)->lpVtbl -> DestroySelection(This)

#define ISelectionObject2_DestroyAllSelection(This)	\
    (This)->lpVtbl -> DestroyAllSelection(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISelectionObject2_Select_Proxy( 
    ISelectionObject2 * This,
    /* [in] */ ISegmentList *pISegmentList);


void __RPC_STUB ISelectionObject2_Select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionObject2_IsPointerInSelection_Proxy( 
    ISelectionObject2 * This,
    /* [in] */ IDisplayPointer *pIDispPointer,
    /* [out] */ BOOL *pfPointerInSelection,
    /* [in] */ POINT *pptGlobal,
    /* [in] */ IHTMLElement *pIElementOver);


void __RPC_STUB ISelectionObject2_IsPointerInSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionObject2_EmptySelection_Proxy( 
    ISelectionObject2 * This);


void __RPC_STUB ISelectionObject2_EmptySelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionObject2_DestroySelection_Proxy( 
    ISelectionObject2 * This);


void __RPC_STUB ISelectionObject2_DestroySelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISelectionObject2_DestroyAllSelection_Proxy( 
    ISelectionObject2 * This);


void __RPC_STUB ISelectionObject2_DestroyAllSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISelectionObject2_INTERFACE_DEFINED__ */


#ifndef __IHTMLEditor_INTERFACE_DEFINED__
#define __IHTMLEditor_INTERFACE_DEFINED__

/* interface IHTMLEditor */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLEditor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f7fa-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLEditor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PreHandleEvent( 
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostHandleEvent( 
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator( 
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown *pIDocument,
            /* [in] */ IUnknown *pIContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ EDITOR_NOTIFICATION eSelectionNotification,
            /* [in] */ IUnknown *pUnknown,
            /* [in] */ DWORD dword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCommandTarget( 
            /* [in] */ IUnknown *pContext,
            /* [out][in] */ IUnknown **ppUnkTarget) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetElementToTabFrom( 
            /* [in] */ BOOL fForward,
            /* [out][in] */ IHTMLElement **ppElement,
            /* [out][in] */ BOOL *pfFindNext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEditContextUIActive( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TerminateIMEComposition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableModeless( 
            /* [in] */ BOOL fEnable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLEditorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLEditor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLEditor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *PreHandleEvent )( 
            IHTMLEditor * This,
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj);
        
        HRESULT ( STDMETHODCALLTYPE *PostHandleEvent )( 
            IHTMLEditor * This,
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj);
        
        HRESULT ( STDMETHODCALLTYPE *TranslateAccelerator )( 
            IHTMLEditor * This,
            /* [in] */ DISPID inEvtDispId,
            /* [in] */ IHTMLEventObj *pIEventObj);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IHTMLEditor * This,
            /* [in] */ IUnknown *pIDocument,
            /* [in] */ IUnknown *pIContainer);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IHTMLEditor * This,
            /* [in] */ EDITOR_NOTIFICATION eSelectionNotification,
            /* [in] */ IUnknown *pUnknown,
            /* [in] */ DWORD dword);
        
        HRESULT ( STDMETHODCALLTYPE *GetCommandTarget )( 
            IHTMLEditor * This,
            /* [in] */ IUnknown *pContext,
            /* [out][in] */ IUnknown **ppUnkTarget);
        
        HRESULT ( STDMETHODCALLTYPE *GetElementToTabFrom )( 
            IHTMLEditor * This,
            /* [in] */ BOOL fForward,
            /* [out][in] */ IHTMLElement **ppElement,
            /* [out][in] */ BOOL *pfFindNext);
        
        HRESULT ( STDMETHODCALLTYPE *IsEditContextUIActive )( 
            IHTMLEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *TerminateIMEComposition )( 
            IHTMLEditor * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnableModeless )( 
            IHTMLEditor * This,
            /* [in] */ BOOL fEnable);
        
        END_INTERFACE
    } IHTMLEditorVtbl;

    interface IHTMLEditor
    {
        CONST_VTBL struct IHTMLEditorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLEditor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLEditor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLEditor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLEditor_PreHandleEvent(This,inEvtDispId,pIEventObj)	\
    (This)->lpVtbl -> PreHandleEvent(This,inEvtDispId,pIEventObj)

#define IHTMLEditor_PostHandleEvent(This,inEvtDispId,pIEventObj)	\
    (This)->lpVtbl -> PostHandleEvent(This,inEvtDispId,pIEventObj)

#define IHTMLEditor_TranslateAccelerator(This,inEvtDispId,pIEventObj)	\
    (This)->lpVtbl -> TranslateAccelerator(This,inEvtDispId,pIEventObj)

#define IHTMLEditor_Initialize(This,pIDocument,pIContainer)	\
    (This)->lpVtbl -> Initialize(This,pIDocument,pIContainer)

#define IHTMLEditor_Notify(This,eSelectionNotification,pUnknown,dword)	\
    (This)->lpVtbl -> Notify(This,eSelectionNotification,pUnknown,dword)

#define IHTMLEditor_GetCommandTarget(This,pContext,ppUnkTarget)	\
    (This)->lpVtbl -> GetCommandTarget(This,pContext,ppUnkTarget)

#define IHTMLEditor_GetElementToTabFrom(This,fForward,ppElement,pfFindNext)	\
    (This)->lpVtbl -> GetElementToTabFrom(This,fForward,ppElement,pfFindNext)

#define IHTMLEditor_IsEditContextUIActive(This)	\
    (This)->lpVtbl -> IsEditContextUIActive(This)

#define IHTMLEditor_TerminateIMEComposition(This)	\
    (This)->lpVtbl -> TerminateIMEComposition(This)

#define IHTMLEditor_EnableModeless(This,fEnable)	\
    (This)->lpVtbl -> EnableModeless(This,fEnable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLEditor_PreHandleEvent_Proxy( 
    IHTMLEditor * This,
    /* [in] */ DISPID inEvtDispId,
    /* [in] */ IHTMLEventObj *pIEventObj);


void __RPC_STUB IHTMLEditor_PreHandleEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_PostHandleEvent_Proxy( 
    IHTMLEditor * This,
    /* [in] */ DISPID inEvtDispId,
    /* [in] */ IHTMLEventObj *pIEventObj);


void __RPC_STUB IHTMLEditor_PostHandleEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_TranslateAccelerator_Proxy( 
    IHTMLEditor * This,
    /* [in] */ DISPID inEvtDispId,
    /* [in] */ IHTMLEventObj *pIEventObj);


void __RPC_STUB IHTMLEditor_TranslateAccelerator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_Initialize_Proxy( 
    IHTMLEditor * This,
    /* [in] */ IUnknown *pIDocument,
    /* [in] */ IUnknown *pIContainer);


void __RPC_STUB IHTMLEditor_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_Notify_Proxy( 
    IHTMLEditor * This,
    /* [in] */ EDITOR_NOTIFICATION eSelectionNotification,
    /* [in] */ IUnknown *pUnknown,
    /* [in] */ DWORD dword);


void __RPC_STUB IHTMLEditor_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_GetCommandTarget_Proxy( 
    IHTMLEditor * This,
    /* [in] */ IUnknown *pContext,
    /* [out][in] */ IUnknown **ppUnkTarget);


void __RPC_STUB IHTMLEditor_GetCommandTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_GetElementToTabFrom_Proxy( 
    IHTMLEditor * This,
    /* [in] */ BOOL fForward,
    /* [out][in] */ IHTMLElement **ppElement,
    /* [out][in] */ BOOL *pfFindNext);


void __RPC_STUB IHTMLEditor_GetElementToTabFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_IsEditContextUIActive_Proxy( 
    IHTMLEditor * This);


void __RPC_STUB IHTMLEditor_IsEditContextUIActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_TerminateIMEComposition_Proxy( 
    IHTMLEditor * This);


void __RPC_STUB IHTMLEditor_TerminateIMEComposition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditor_EnableModeless_Proxy( 
    IHTMLEditor * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IHTMLEditor_EnableModeless_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLEditor_INTERFACE_DEFINED__ */


#ifndef __IHTMLPrivateWindow_INTERFACE_DEFINED__
#define __IHTMLPrivateWindow_INTERFACE_DEFINED__

/* interface IHTMLPrivateWindow */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLPrivateWindow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6dc-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLPrivateWindow : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SuperNavigate( 
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrShortcut,
            /* [in] */ BSTR bstrFrameName,
            /* [in] */ VARIANT *pvarPostData,
            /* [in] */ VARIANT *pvarHeaders,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPendingUrl( 
            /* [out] */ LPOLESTR *pstrURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPICSTarget( 
            /* [in] */ IOleCommandTarget *pctPICS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PICSComplete( 
            /* [in] */ BOOL fApproved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindWindowByName( 
            /* [in] */ LPCOLESTR pstrTargeName,
            /* [out] */ IHTMLWindow2 **ppWindow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddressBarUrl( 
            /* [out] */ BSTR *pbstrURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLPrivateWindowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLPrivateWindow * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLPrivateWindow * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLPrivateWindow * This);
        
        HRESULT ( STDMETHODCALLTYPE *SuperNavigate )( 
            IHTMLPrivateWindow * This,
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrShortcut,
            /* [in] */ BSTR bstrFrameName,
            /* [in] */ VARIANT *pvarPostData,
            /* [in] */ VARIANT *pvarHeaders,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetPendingUrl )( 
            IHTMLPrivateWindow * This,
            /* [out] */ LPOLESTR *pstrURL);
        
        HRESULT ( STDMETHODCALLTYPE *SetPICSTarget )( 
            IHTMLPrivateWindow * This,
            /* [in] */ IOleCommandTarget *pctPICS);
        
        HRESULT ( STDMETHODCALLTYPE *PICSComplete )( 
            IHTMLPrivateWindow * This,
            /* [in] */ BOOL fApproved);
        
        HRESULT ( STDMETHODCALLTYPE *FindWindowByName )( 
            IHTMLPrivateWindow * This,
            /* [in] */ LPCOLESTR pstrTargeName,
            /* [out] */ IHTMLWindow2 **ppWindow);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddressBarUrl )( 
            IHTMLPrivateWindow * This,
            /* [out] */ BSTR *pbstrURL);
        
        END_INTERFACE
    } IHTMLPrivateWindowVtbl;

    interface IHTMLPrivateWindow
    {
        CONST_VTBL struct IHTMLPrivateWindowVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLPrivateWindow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLPrivateWindow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLPrivateWindow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLPrivateWindow_SuperNavigate(This,bstrURL,bstrLocation,bstrShortcut,bstrFrameName,pvarPostData,pvarHeaders,dwFlags)	\
    (This)->lpVtbl -> SuperNavigate(This,bstrURL,bstrLocation,bstrShortcut,bstrFrameName,pvarPostData,pvarHeaders,dwFlags)

#define IHTMLPrivateWindow_GetPendingUrl(This,pstrURL)	\
    (This)->lpVtbl -> GetPendingUrl(This,pstrURL)

#define IHTMLPrivateWindow_SetPICSTarget(This,pctPICS)	\
    (This)->lpVtbl -> SetPICSTarget(This,pctPICS)

#define IHTMLPrivateWindow_PICSComplete(This,fApproved)	\
    (This)->lpVtbl -> PICSComplete(This,fApproved)

#define IHTMLPrivateWindow_FindWindowByName(This,pstrTargeName,ppWindow)	\
    (This)->lpVtbl -> FindWindowByName(This,pstrTargeName,ppWindow)

#define IHTMLPrivateWindow_GetAddressBarUrl(This,pbstrURL)	\
    (This)->lpVtbl -> GetAddressBarUrl(This,pbstrURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow_SuperNavigate_Proxy( 
    IHTMLPrivateWindow * This,
    /* [in] */ BSTR bstrURL,
    /* [in] */ BSTR bstrLocation,
    /* [in] */ BSTR bstrShortcut,
    /* [in] */ BSTR bstrFrameName,
    /* [in] */ VARIANT *pvarPostData,
    /* [in] */ VARIANT *pvarHeaders,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IHTMLPrivateWindow_SuperNavigate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow_GetPendingUrl_Proxy( 
    IHTMLPrivateWindow * This,
    /* [out] */ LPOLESTR *pstrURL);


void __RPC_STUB IHTMLPrivateWindow_GetPendingUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow_SetPICSTarget_Proxy( 
    IHTMLPrivateWindow * This,
    /* [in] */ IOleCommandTarget *pctPICS);


void __RPC_STUB IHTMLPrivateWindow_SetPICSTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow_PICSComplete_Proxy( 
    IHTMLPrivateWindow * This,
    /* [in] */ BOOL fApproved);


void __RPC_STUB IHTMLPrivateWindow_PICSComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow_FindWindowByName_Proxy( 
    IHTMLPrivateWindow * This,
    /* [in] */ LPCOLESTR pstrTargeName,
    /* [out] */ IHTMLWindow2 **ppWindow);


void __RPC_STUB IHTMLPrivateWindow_FindWindowByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow_GetAddressBarUrl_Proxy( 
    IHTMLPrivateWindow * This,
    /* [out] */ BSTR *pbstrURL);


void __RPC_STUB IHTMLPrivateWindow_GetAddressBarUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLPrivateWindow_INTERFACE_DEFINED__ */


#ifndef __IHTMLPrivateWindow2_INTERFACE_DEFINED__
#define __IHTMLPrivateWindow2_INTERFACE_DEFINED__

/* interface IHTMLPrivateWindow2 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLPrivateWindow2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f7e5-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLPrivateWindow2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NavigateEx( 
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrUnencodedUrl,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrContext,
            /* [in] */ IBindCtx *pBindCtx,
            /* [in] */ DWORD dwNavOptions,
            /* [in] */ DWORD dwFHLFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInnerWindowUnknown( 
            /* [out][in] */ IUnknown **ppUnknown) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLPrivateWindow2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLPrivateWindow2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLPrivateWindow2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLPrivateWindow2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *NavigateEx )( 
            IHTMLPrivateWindow2 * This,
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrUnencodedUrl,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrContext,
            /* [in] */ IBindCtx *pBindCtx,
            /* [in] */ DWORD dwNavOptions,
            /* [in] */ DWORD dwFHLFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetInnerWindowUnknown )( 
            IHTMLPrivateWindow2 * This,
            /* [out][in] */ IUnknown **ppUnknown);
        
        END_INTERFACE
    } IHTMLPrivateWindow2Vtbl;

    interface IHTMLPrivateWindow2
    {
        CONST_VTBL struct IHTMLPrivateWindow2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLPrivateWindow2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLPrivateWindow2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLPrivateWindow2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLPrivateWindow2_NavigateEx(This,bstrURL,bstrUnencodedUrl,bstrLocation,bstrContext,pBindCtx,dwNavOptions,dwFHLFlags)	\
    (This)->lpVtbl -> NavigateEx(This,bstrURL,bstrUnencodedUrl,bstrLocation,bstrContext,pBindCtx,dwNavOptions,dwFHLFlags)

#define IHTMLPrivateWindow2_GetInnerWindowUnknown(This,ppUnknown)	\
    (This)->lpVtbl -> GetInnerWindowUnknown(This,ppUnknown)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow2_NavigateEx_Proxy( 
    IHTMLPrivateWindow2 * This,
    /* [in] */ BSTR bstrURL,
    /* [in] */ BSTR bstrUnencodedUrl,
    /* [in] */ BSTR bstrLocation,
    /* [in] */ BSTR bstrContext,
    /* [in] */ IBindCtx *pBindCtx,
    /* [in] */ DWORD dwNavOptions,
    /* [in] */ DWORD dwFHLFlags);


void __RPC_STUB IHTMLPrivateWindow2_NavigateEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow2_GetInnerWindowUnknown_Proxy( 
    IHTMLPrivateWindow2 * This,
    /* [out][in] */ IUnknown **ppUnknown);


void __RPC_STUB IHTMLPrivateWindow2_GetInnerWindowUnknown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLPrivateWindow2_INTERFACE_DEFINED__ */


#ifndef __IHTMLPrivateWindow3_INTERFACE_DEFINED__
#define __IHTMLPrivateWindow3_INTERFACE_DEFINED__

/* interface IHTMLPrivateWindow3 */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLPrivateWindow3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f840-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLPrivateWindow3 : public IHTMLPrivateWindow2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenEx( 
            /* [in] */ BSTR url,
            /* [in] */ BSTR urlContext,
            /* [in] */ BSTR name,
            /* [in] */ BSTR features,
            /* [in] */ VARIANT_BOOL replace,
            /* [out] */ IHTMLWindow2 **pomWindowResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLPrivateWindow3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLPrivateWindow3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLPrivateWindow3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLPrivateWindow3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *NavigateEx )( 
            IHTMLPrivateWindow3 * This,
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrUnencodedUrl,
            /* [in] */ BSTR bstrLocation,
            /* [in] */ BSTR bstrContext,
            /* [in] */ IBindCtx *pBindCtx,
            /* [in] */ DWORD dwNavOptions,
            /* [in] */ DWORD dwFHLFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetInnerWindowUnknown )( 
            IHTMLPrivateWindow3 * This,
            /* [out][in] */ IUnknown **ppUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *OpenEx )( 
            IHTMLPrivateWindow3 * This,
            /* [in] */ BSTR url,
            /* [in] */ BSTR urlContext,
            /* [in] */ BSTR name,
            /* [in] */ BSTR features,
            /* [in] */ VARIANT_BOOL replace,
            /* [out] */ IHTMLWindow2 **pomWindowResult);
        
        END_INTERFACE
    } IHTMLPrivateWindow3Vtbl;

    interface IHTMLPrivateWindow3
    {
        CONST_VTBL struct IHTMLPrivateWindow3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLPrivateWindow3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLPrivateWindow3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLPrivateWindow3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLPrivateWindow3_NavigateEx(This,bstrURL,bstrUnencodedUrl,bstrLocation,bstrContext,pBindCtx,dwNavOptions,dwFHLFlags)	\
    (This)->lpVtbl -> NavigateEx(This,bstrURL,bstrUnencodedUrl,bstrLocation,bstrContext,pBindCtx,dwNavOptions,dwFHLFlags)

#define IHTMLPrivateWindow3_GetInnerWindowUnknown(This,ppUnknown)	\
    (This)->lpVtbl -> GetInnerWindowUnknown(This,ppUnknown)


#define IHTMLPrivateWindow3_OpenEx(This,url,urlContext,name,features,replace,pomWindowResult)	\
    (This)->lpVtbl -> OpenEx(This,url,urlContext,name,features,replace,pomWindowResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLPrivateWindow3_OpenEx_Proxy( 
    IHTMLPrivateWindow3 * This,
    /* [in] */ BSTR url,
    /* [in] */ BSTR urlContext,
    /* [in] */ BSTR name,
    /* [in] */ BSTR features,
    /* [in] */ VARIANT_BOOL replace,
    /* [out] */ IHTMLWindow2 **pomWindowResult);


void __RPC_STUB IHTMLPrivateWindow3_OpenEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLPrivateWindow3_INTERFACE_DEFINED__ */


#ifndef __ISubDivisionProvider_INTERFACE_DEFINED__
#define __ISubDivisionProvider_INTERFACE_DEFINED__

/* interface ISubDivisionProvider */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_ISubDivisionProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f4d2-98b5-11cf-bb82-00aa00bdce0b")
    ISubDivisionProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSubDivisionCount( 
            /* [out][retval] */ LONG *pcSubDivision) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubDivisionTabs( 
            /* [in] */ LONG cTabs,
            /* [out][retval] */ LONG *pSubDivisionTabs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SubDivisionFromPt( 
            /* [in] */ POINT pt,
            /* [out][retval] */ LONG *piSubDivision) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISubDivisionProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISubDivisionProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISubDivisionProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISubDivisionProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubDivisionCount )( 
            ISubDivisionProvider * This,
            /* [out][retval] */ LONG *pcSubDivision);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubDivisionTabs )( 
            ISubDivisionProvider * This,
            /* [in] */ LONG cTabs,
            /* [out][retval] */ LONG *pSubDivisionTabs);
        
        HRESULT ( STDMETHODCALLTYPE *SubDivisionFromPt )( 
            ISubDivisionProvider * This,
            /* [in] */ POINT pt,
            /* [out][retval] */ LONG *piSubDivision);
        
        END_INTERFACE
    } ISubDivisionProviderVtbl;

    interface ISubDivisionProvider
    {
        CONST_VTBL struct ISubDivisionProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISubDivisionProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISubDivisionProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISubDivisionProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISubDivisionProvider_GetSubDivisionCount(This,pcSubDivision)	\
    (This)->lpVtbl -> GetSubDivisionCount(This,pcSubDivision)

#define ISubDivisionProvider_GetSubDivisionTabs(This,cTabs,pSubDivisionTabs)	\
    (This)->lpVtbl -> GetSubDivisionTabs(This,cTabs,pSubDivisionTabs)

#define ISubDivisionProvider_SubDivisionFromPt(This,pt,piSubDivision)	\
    (This)->lpVtbl -> SubDivisionFromPt(This,pt,piSubDivision)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISubDivisionProvider_GetSubDivisionCount_Proxy( 
    ISubDivisionProvider * This,
    /* [out][retval] */ LONG *pcSubDivision);


void __RPC_STUB ISubDivisionProvider_GetSubDivisionCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISubDivisionProvider_GetSubDivisionTabs_Proxy( 
    ISubDivisionProvider * This,
    /* [in] */ LONG cTabs,
    /* [out][retval] */ LONG *pSubDivisionTabs);


void __RPC_STUB ISubDivisionProvider_GetSubDivisionTabs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISubDivisionProvider_SubDivisionFromPt_Proxy( 
    ISubDivisionProvider * This,
    /* [in] */ POINT pt,
    /* [out][retval] */ LONG *piSubDivision);


void __RPC_STUB ISubDivisionProvider_SubDivisionFromPt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISubDivisionProvider_INTERFACE_DEFINED__ */


#ifndef __IElementBehaviorUI_INTERFACE_DEFINED__
#define __IElementBehaviorUI_INTERFACE_DEFINED__

/* interface IElementBehaviorUI */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementBehaviorUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f4bf-98b5-11cf-bb82-00aa00bdce0b")
    IElementBehaviorUI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnReceiveFocus( 
            /* [in] */ BOOL fFocus,
            /* [in] */ LONG lSubDivision) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubDivisionProvider( 
            /* [out][retval] */ ISubDivisionProvider **ppProvider) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanTakeFocus( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementBehaviorUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementBehaviorUI * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementBehaviorUI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementBehaviorUI * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnReceiveFocus )( 
            IElementBehaviorUI * This,
            /* [in] */ BOOL fFocus,
            /* [in] */ LONG lSubDivision);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubDivisionProvider )( 
            IElementBehaviorUI * This,
            /* [out][retval] */ ISubDivisionProvider **ppProvider);
        
        HRESULT ( STDMETHODCALLTYPE *CanTakeFocus )( 
            IElementBehaviorUI * This);
        
        END_INTERFACE
    } IElementBehaviorUIVtbl;

    interface IElementBehaviorUI
    {
        CONST_VTBL struct IElementBehaviorUIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementBehaviorUI_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementBehaviorUI_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementBehaviorUI_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementBehaviorUI_OnReceiveFocus(This,fFocus,lSubDivision)	\
    (This)->lpVtbl -> OnReceiveFocus(This,fFocus,lSubDivision)

#define IElementBehaviorUI_GetSubDivisionProvider(This,ppProvider)	\
    (This)->lpVtbl -> GetSubDivisionProvider(This,ppProvider)

#define IElementBehaviorUI_CanTakeFocus(This)	\
    (This)->lpVtbl -> CanTakeFocus(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementBehaviorUI_OnReceiveFocus_Proxy( 
    IElementBehaviorUI * This,
    /* [in] */ BOOL fFocus,
    /* [in] */ LONG lSubDivision);


void __RPC_STUB IElementBehaviorUI_OnReceiveFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementBehaviorUI_GetSubDivisionProvider_Proxy( 
    IElementBehaviorUI * This,
    /* [out][retval] */ ISubDivisionProvider **ppProvider);


void __RPC_STUB IElementBehaviorUI_GetSubDivisionProvider_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementBehaviorUI_CanTakeFocus_Proxy( 
    IElementBehaviorUI * This);


void __RPC_STUB IElementBehaviorUI_CanTakeFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementBehaviorUI_INTERFACE_DEFINED__ */


#ifndef __IElementAdorner_INTERFACE_DEFINED__
#define __IElementAdorner_INTERFACE_DEFINED__

/* interface IElementAdorner */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementAdorner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f607-98b5-11cf-bb82-00aa00bdce0b")
    IElementAdorner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Draw( 
            /* [in] */ HDC hdc,
            /* [in] */ LPRECT prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HitTestPoint( 
            /* [in] */ POINT *pt,
            /* [in] */ LPRECT prc,
            /* [out][in] */ BOOL *fResult,
            /* [out][in] */ ADORNER_HTI *peAdornerHTI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [in] */ SIZE *pSizeElem,
            /* [in] */ SIZE *pSizeAdorn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPosition( 
            /* [in] */ POINT *pPosElem,
            /* [in] */ POINT *pPosAdorn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnPositionSet( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementAdornerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementAdorner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementAdorner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementAdorner * This);
        
        HRESULT ( STDMETHODCALLTYPE *Draw )( 
            IElementAdorner * This,
            /* [in] */ HDC hdc,
            /* [in] */ LPRECT prc);
        
        HRESULT ( STDMETHODCALLTYPE *HitTestPoint )( 
            IElementAdorner * This,
            /* [in] */ POINT *pt,
            /* [in] */ LPRECT prc,
            /* [out][in] */ BOOL *fResult,
            /* [out][in] */ ADORNER_HTI *peAdornerHTI);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            IElementAdorner * This,
            /* [in] */ SIZE *pSizeElem,
            /* [in] */ SIZE *pSizeAdorn);
        
        HRESULT ( STDMETHODCALLTYPE *GetPosition )( 
            IElementAdorner * This,
            /* [in] */ POINT *pPosElem,
            /* [in] */ POINT *pPosAdorn);
        
        HRESULT ( STDMETHODCALLTYPE *OnPositionSet )( 
            IElementAdorner * This);
        
        END_INTERFACE
    } IElementAdornerVtbl;

    interface IElementAdorner
    {
        CONST_VTBL struct IElementAdornerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementAdorner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementAdorner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementAdorner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementAdorner_Draw(This,hdc,prc)	\
    (This)->lpVtbl -> Draw(This,hdc,prc)

#define IElementAdorner_HitTestPoint(This,pt,prc,fResult,peAdornerHTI)	\
    (This)->lpVtbl -> HitTestPoint(This,pt,prc,fResult,peAdornerHTI)

#define IElementAdorner_GetSize(This,pSizeElem,pSizeAdorn)	\
    (This)->lpVtbl -> GetSize(This,pSizeElem,pSizeAdorn)

#define IElementAdorner_GetPosition(This,pPosElem,pPosAdorn)	\
    (This)->lpVtbl -> GetPosition(This,pPosElem,pPosAdorn)

#define IElementAdorner_OnPositionSet(This)	\
    (This)->lpVtbl -> OnPositionSet(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementAdorner_Draw_Proxy( 
    IElementAdorner * This,
    /* [in] */ HDC hdc,
    /* [in] */ LPRECT prc);


void __RPC_STUB IElementAdorner_Draw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementAdorner_HitTestPoint_Proxy( 
    IElementAdorner * This,
    /* [in] */ POINT *pt,
    /* [in] */ LPRECT prc,
    /* [out][in] */ BOOL *fResult,
    /* [out][in] */ ADORNER_HTI *peAdornerHTI);


void __RPC_STUB IElementAdorner_HitTestPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementAdorner_GetSize_Proxy( 
    IElementAdorner * This,
    /* [in] */ SIZE *pSizeElem,
    /* [in] */ SIZE *pSizeAdorn);


void __RPC_STUB IElementAdorner_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementAdorner_GetPosition_Proxy( 
    IElementAdorner * This,
    /* [in] */ POINT *pPosElem,
    /* [in] */ POINT *pPosAdorn);


void __RPC_STUB IElementAdorner_GetPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IElementAdorner_OnPositionSet_Proxy( 
    IElementAdorner * This);


void __RPC_STUB IElementAdorner_OnPositionSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementAdorner_INTERFACE_DEFINED__ */


#ifndef __IHTMLEditingServices_INTERFACE_DEFINED__
#define __IHTMLEditingServices_INTERFACE_DEFINED__

/* interface IHTMLEditingServices */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLEditingServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f7fb-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLEditingServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ BOOL fAdjustPointers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Paste( 
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ BSTR bstrText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PasteFromClipboard( 
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ IDataObject *pDO) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LaunderSpaces( 
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSanitizedText( 
            /* [in] */ IMarkupPointer *InsertHere,
            /* [in] */ OLECHAR *pstrText,
            /* [in] */ LONG cChInput,
            /* [in] */ BOOL fDataBinding) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UrlAutoDetectCurrentWord( 
            /* [in] */ IMarkupPointer *pWord) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UrlAutoDetectRange( 
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShouldUpdateAnchorText( 
            /* [in] */ OLECHAR *pstrHref,
            /* [in] */ OLECHAR *pstrAnchorText,
            /* [out] */ BOOL *pfResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdjustPointerForInsert( 
            /* [in] */ IDisplayPointer *pDispWhereIThinkIAm,
            /* [in] */ BOOL fFurtherInDocument,
            /* [in] */ IMarkupPointer *pConstraintStart,
            /* [in] */ IMarkupPointer *pConstraintEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindSiteSelectableElement( 
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerEnd,
            /* [in] */ IHTMLElement **ppIHTMLElement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsElementSiteSelectable( 
            /* [in] */ IHTMLElement *pIHTMLElement,
            /* [out] */ IHTMLElement **ppIElement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsElementUIActivatable( 
            /* [in] */ IHTMLElement *pIHTMLElement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsElementAtomic( 
            /* [in] */ IHTMLElement *pIHTMLElement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PositionPointersInMaster( 
            /* [in] */ IHTMLElement *pIElement,
            /* [in] */ IMarkupPointer *pIStart,
            /* [in] */ IMarkupPointer *pIEnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLEditingServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLEditingServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLEditingServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLEditingServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ BOOL fAdjustPointers);
        
        HRESULT ( STDMETHODCALLTYPE *Paste )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ BSTR bstrText);
        
        HRESULT ( STDMETHODCALLTYPE *PasteFromClipboard )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd,
            /* [in] */ IDataObject *pDO);
        
        HRESULT ( STDMETHODCALLTYPE *LaunderSpaces )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *InsertSanitizedText )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *InsertHere,
            /* [in] */ OLECHAR *pstrText,
            /* [in] */ LONG cChInput,
            /* [in] */ BOOL fDataBinding);
        
        HRESULT ( STDMETHODCALLTYPE *UrlAutoDetectCurrentWord )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pWord);
        
        HRESULT ( STDMETHODCALLTYPE *UrlAutoDetectRange )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pStart,
            /* [in] */ IMarkupPointer *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *ShouldUpdateAnchorText )( 
            IHTMLEditingServices * This,
            /* [in] */ OLECHAR *pstrHref,
            /* [in] */ OLECHAR *pstrAnchorText,
            /* [out] */ BOOL *pfResult);
        
        HRESULT ( STDMETHODCALLTYPE *AdjustPointerForInsert )( 
            IHTMLEditingServices * This,
            /* [in] */ IDisplayPointer *pDispWhereIThinkIAm,
            /* [in] */ BOOL fFurtherInDocument,
            /* [in] */ IMarkupPointer *pConstraintStart,
            /* [in] */ IMarkupPointer *pConstraintEnd);
        
        HRESULT ( STDMETHODCALLTYPE *FindSiteSelectableElement )( 
            IHTMLEditingServices * This,
            /* [in] */ IMarkupPointer *pPointerStart,
            /* [in] */ IMarkupPointer *pPointerEnd,
            /* [in] */ IHTMLElement **ppIHTMLElement);
        
        HRESULT ( STDMETHODCALLTYPE *IsElementSiteSelectable )( 
            IHTMLEditingServices * This,
            /* [in] */ IHTMLElement *pIHTMLElement,
            /* [out] */ IHTMLElement **ppIElement);
        
        HRESULT ( STDMETHODCALLTYPE *IsElementUIActivatable )( 
            IHTMLEditingServices * This,
            /* [in] */ IHTMLElement *pIHTMLElement);
        
        HRESULT ( STDMETHODCALLTYPE *IsElementAtomic )( 
            IHTMLEditingServices * This,
            /* [in] */ IHTMLElement *pIHTMLElement);
        
        HRESULT ( STDMETHODCALLTYPE *PositionPointersInMaster )( 
            IHTMLEditingServices * This,
            /* [in] */ IHTMLElement *pIElement,
            /* [in] */ IMarkupPointer *pIStart,
            /* [in] */ IMarkupPointer *pIEnd);
        
        END_INTERFACE
    } IHTMLEditingServicesVtbl;

    interface IHTMLEditingServices
    {
        CONST_VTBL struct IHTMLEditingServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLEditingServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLEditingServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLEditingServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLEditingServices_Delete(This,pStart,pEnd,fAdjustPointers)	\
    (This)->lpVtbl -> Delete(This,pStart,pEnd,fAdjustPointers)

#define IHTMLEditingServices_Paste(This,pStart,pEnd,bstrText)	\
    (This)->lpVtbl -> Paste(This,pStart,pEnd,bstrText)

#define IHTMLEditingServices_PasteFromClipboard(This,pStart,pEnd,pDO)	\
    (This)->lpVtbl -> PasteFromClipboard(This,pStart,pEnd,pDO)

#define IHTMLEditingServices_LaunderSpaces(This,pStart,pEnd)	\
    (This)->lpVtbl -> LaunderSpaces(This,pStart,pEnd)

#define IHTMLEditingServices_InsertSanitizedText(This,InsertHere,pstrText,cChInput,fDataBinding)	\
    (This)->lpVtbl -> InsertSanitizedText(This,InsertHere,pstrText,cChInput,fDataBinding)

#define IHTMLEditingServices_UrlAutoDetectCurrentWord(This,pWord)	\
    (This)->lpVtbl -> UrlAutoDetectCurrentWord(This,pWord)

#define IHTMLEditingServices_UrlAutoDetectRange(This,pStart,pEnd)	\
    (This)->lpVtbl -> UrlAutoDetectRange(This,pStart,pEnd)

#define IHTMLEditingServices_ShouldUpdateAnchorText(This,pstrHref,pstrAnchorText,pfResult)	\
    (This)->lpVtbl -> ShouldUpdateAnchorText(This,pstrHref,pstrAnchorText,pfResult)

#define IHTMLEditingServices_AdjustPointerForInsert(This,pDispWhereIThinkIAm,fFurtherInDocument,pConstraintStart,pConstraintEnd)	\
    (This)->lpVtbl -> AdjustPointerForInsert(This,pDispWhereIThinkIAm,fFurtherInDocument,pConstraintStart,pConstraintEnd)

#define IHTMLEditingServices_FindSiteSelectableElement(This,pPointerStart,pPointerEnd,ppIHTMLElement)	\
    (This)->lpVtbl -> FindSiteSelectableElement(This,pPointerStart,pPointerEnd,ppIHTMLElement)

#define IHTMLEditingServices_IsElementSiteSelectable(This,pIHTMLElement,ppIElement)	\
    (This)->lpVtbl -> IsElementSiteSelectable(This,pIHTMLElement,ppIElement)

#define IHTMLEditingServices_IsElementUIActivatable(This,pIHTMLElement)	\
    (This)->lpVtbl -> IsElementUIActivatable(This,pIHTMLElement)

#define IHTMLEditingServices_IsElementAtomic(This,pIHTMLElement)	\
    (This)->lpVtbl -> IsElementAtomic(This,pIHTMLElement)

#define IHTMLEditingServices_PositionPointersInMaster(This,pIElement,pIStart,pIEnd)	\
    (This)->lpVtbl -> PositionPointersInMaster(This,pIElement,pIStart,pIEnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLEditingServices_Delete_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IMarkupPointer *pStart,
    /* [in] */ IMarkupPointer *pEnd,
    /* [in] */ BOOL fAdjustPointers);


void __RPC_STUB IHTMLEditingServices_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_Paste_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IMarkupPointer *pStart,
    /* [in] */ IMarkupPointer *pEnd,
    /* [in] */ BSTR bstrText);


void __RPC_STUB IHTMLEditingServices_Paste_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_PasteFromClipboard_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IMarkupPointer *pStart,
    /* [in] */ IMarkupPointer *pEnd,
    /* [in] */ IDataObject *pDO);


void __RPC_STUB IHTMLEditingServices_PasteFromClipboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_LaunderSpaces_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IMarkupPointer *pStart,
    /* [in] */ IMarkupPointer *pEnd);


void __RPC_STUB IHTMLEditingServices_LaunderSpaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_InsertSanitizedText_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IMarkupPointer *InsertHere,
    /* [in] */ OLECHAR *pstrText,
    /* [in] */ LONG cChInput,
    /* [in] */ BOOL fDataBinding);


void __RPC_STUB IHTMLEditingServices_InsertSanitizedText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_UrlAutoDetectCurrentWord_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IMarkupPointer *pWord);


void __RPC_STUB IHTMLEditingServices_UrlAutoDetectCurrentWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_UrlAutoDetectRange_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IMarkupPointer *pStart,
    /* [in] */ IMarkupPointer *pEnd);


void __RPC_STUB IHTMLEditingServices_UrlAutoDetectRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_ShouldUpdateAnchorText_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ OLECHAR *pstrHref,
    /* [in] */ OLECHAR *pstrAnchorText,
    /* [out] */ BOOL *pfResult);


void __RPC_STUB IHTMLEditingServices_ShouldUpdateAnchorText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_AdjustPointerForInsert_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IDisplayPointer *pDispWhereIThinkIAm,
    /* [in] */ BOOL fFurtherInDocument,
    /* [in] */ IMarkupPointer *pConstraintStart,
    /* [in] */ IMarkupPointer *pConstraintEnd);


void __RPC_STUB IHTMLEditingServices_AdjustPointerForInsert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_FindSiteSelectableElement_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IMarkupPointer *pPointerStart,
    /* [in] */ IMarkupPointer *pPointerEnd,
    /* [in] */ IHTMLElement **ppIHTMLElement);


void __RPC_STUB IHTMLEditingServices_FindSiteSelectableElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_IsElementSiteSelectable_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IHTMLElement *pIHTMLElement,
    /* [out] */ IHTMLElement **ppIElement);


void __RPC_STUB IHTMLEditingServices_IsElementSiteSelectable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_IsElementUIActivatable_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IHTMLElement *pIHTMLElement);


void __RPC_STUB IHTMLEditingServices_IsElementUIActivatable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_IsElementAtomic_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IHTMLElement *pIHTMLElement);


void __RPC_STUB IHTMLEditingServices_IsElementAtomic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLEditingServices_PositionPointersInMaster_Proxy( 
    IHTMLEditingServices * This,
    /* [in] */ IHTMLElement *pIElement,
    /* [in] */ IMarkupPointer *pIStart,
    /* [in] */ IMarkupPointer *pIEnd);


void __RPC_STUB IHTMLEditingServices_PositionPointersInMaster_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLEditingServices_INTERFACE_DEFINED__ */


#ifndef __IEditDebugServices_INTERFACE_DEFINED__
#define __IEditDebugServices_INTERFACE_DEFINED__

/* interface IEditDebugServices */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IEditDebugServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f60b-98b5-11cf-bb82-00aa00bdce0b")
    IEditDebugServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCp( 
            /* [in] */ IMarkupPointer *pIPointer,
            /* [out] */ long *pcp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDebugName( 
            /* [in] */ IMarkupPointer *pIPointer,
            /* [in] */ LPCTSTR strDbgName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDisplayPointerDebugName( 
            /* [in] */ IDisplayPointer *pDispPointer,
            /* [in] */ LPCTSTR strDbgName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DumpTree( 
            /* [in] */ IMarkupPointer *pIPointer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LinesInElement( 
            /* [in] */ IHTMLElement *pIElement,
            /* [out] */ long *piLines) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FontsOnLine( 
            /* [in] */ IHTMLElement *pIElement,
            /* [in] */ long iLine,
            /* [out] */ BSTR *pbstrFonts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPixel( 
            /* [in] */ long X,
            /* [in] */ long Y,
            /* [out] */ long *piColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingBckgrnRecalc( 
            /* [out] */ BOOL *pfUsingBckgrnRecalc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEncodingAutoSelect( 
            /* [out] */ BOOL *pfEncodingAutoSelect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableEncodingAutoSelect( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUsingTableIncRecalc( 
            /* [out] */ BOOL *pfUsingTableIncRecalc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEditDebugServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEditDebugServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEditDebugServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEditDebugServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCp )( 
            IEditDebugServices * This,
            /* [in] */ IMarkupPointer *pIPointer,
            /* [out] */ long *pcp);
        
        HRESULT ( STDMETHODCALLTYPE *SetDebugName )( 
            IEditDebugServices * This,
            /* [in] */ IMarkupPointer *pIPointer,
            /* [in] */ LPCTSTR strDbgName);
        
        HRESULT ( STDMETHODCALLTYPE *SetDisplayPointerDebugName )( 
            IEditDebugServices * This,
            /* [in] */ IDisplayPointer *pDispPointer,
            /* [in] */ LPCTSTR strDbgName);
        
        HRESULT ( STDMETHODCALLTYPE *DumpTree )( 
            IEditDebugServices * This,
            /* [in] */ IMarkupPointer *pIPointer);
        
        HRESULT ( STDMETHODCALLTYPE *LinesInElement )( 
            IEditDebugServices * This,
            /* [in] */ IHTMLElement *pIElement,
            /* [out] */ long *piLines);
        
        HRESULT ( STDMETHODCALLTYPE *FontsOnLine )( 
            IEditDebugServices * This,
            /* [in] */ IHTMLElement *pIElement,
            /* [in] */ long iLine,
            /* [out] */ BSTR *pbstrFonts);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixel )( 
            IEditDebugServices * This,
            /* [in] */ long X,
            /* [in] */ long Y,
            /* [out] */ long *piColor);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingBckgrnRecalc )( 
            IEditDebugServices * This,
            /* [out] */ BOOL *pfUsingBckgrnRecalc);
        
        HRESULT ( STDMETHODCALLTYPE *IsEncodingAutoSelect )( 
            IEditDebugServices * This,
            /* [out] */ BOOL *pfEncodingAutoSelect);
        
        HRESULT ( STDMETHODCALLTYPE *EnableEncodingAutoSelect )( 
            IEditDebugServices * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *IsUsingTableIncRecalc )( 
            IEditDebugServices * This,
            /* [out] */ BOOL *pfUsingTableIncRecalc);
        
        END_INTERFACE
    } IEditDebugServicesVtbl;

    interface IEditDebugServices
    {
        CONST_VTBL struct IEditDebugServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEditDebugServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEditDebugServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEditDebugServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEditDebugServices_GetCp(This,pIPointer,pcp)	\
    (This)->lpVtbl -> GetCp(This,pIPointer,pcp)

#define IEditDebugServices_SetDebugName(This,pIPointer,strDbgName)	\
    (This)->lpVtbl -> SetDebugName(This,pIPointer,strDbgName)

#define IEditDebugServices_SetDisplayPointerDebugName(This,pDispPointer,strDbgName)	\
    (This)->lpVtbl -> SetDisplayPointerDebugName(This,pDispPointer,strDbgName)

#define IEditDebugServices_DumpTree(This,pIPointer)	\
    (This)->lpVtbl -> DumpTree(This,pIPointer)

#define IEditDebugServices_LinesInElement(This,pIElement,piLines)	\
    (This)->lpVtbl -> LinesInElement(This,pIElement,piLines)

#define IEditDebugServices_FontsOnLine(This,pIElement,iLine,pbstrFonts)	\
    (This)->lpVtbl -> FontsOnLine(This,pIElement,iLine,pbstrFonts)

#define IEditDebugServices_GetPixel(This,X,Y,piColor)	\
    (This)->lpVtbl -> GetPixel(This,X,Y,piColor)

#define IEditDebugServices_IsUsingBckgrnRecalc(This,pfUsingBckgrnRecalc)	\
    (This)->lpVtbl -> IsUsingBckgrnRecalc(This,pfUsingBckgrnRecalc)

#define IEditDebugServices_IsEncodingAutoSelect(This,pfEncodingAutoSelect)	\
    (This)->lpVtbl -> IsEncodingAutoSelect(This,pfEncodingAutoSelect)

#define IEditDebugServices_EnableEncodingAutoSelect(This,fEnable)	\
    (This)->lpVtbl -> EnableEncodingAutoSelect(This,fEnable)

#define IEditDebugServices_IsUsingTableIncRecalc(This,pfUsingTableIncRecalc)	\
    (This)->lpVtbl -> IsUsingTableIncRecalc(This,pfUsingTableIncRecalc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEditDebugServices_GetCp_Proxy( 
    IEditDebugServices * This,
    /* [in] */ IMarkupPointer *pIPointer,
    /* [out] */ long *pcp);


void __RPC_STUB IEditDebugServices_GetCp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_SetDebugName_Proxy( 
    IEditDebugServices * This,
    /* [in] */ IMarkupPointer *pIPointer,
    /* [in] */ LPCTSTR strDbgName);


void __RPC_STUB IEditDebugServices_SetDebugName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_SetDisplayPointerDebugName_Proxy( 
    IEditDebugServices * This,
    /* [in] */ IDisplayPointer *pDispPointer,
    /* [in] */ LPCTSTR strDbgName);


void __RPC_STUB IEditDebugServices_SetDisplayPointerDebugName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_DumpTree_Proxy( 
    IEditDebugServices * This,
    /* [in] */ IMarkupPointer *pIPointer);


void __RPC_STUB IEditDebugServices_DumpTree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_LinesInElement_Proxy( 
    IEditDebugServices * This,
    /* [in] */ IHTMLElement *pIElement,
    /* [out] */ long *piLines);


void __RPC_STUB IEditDebugServices_LinesInElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_FontsOnLine_Proxy( 
    IEditDebugServices * This,
    /* [in] */ IHTMLElement *pIElement,
    /* [in] */ long iLine,
    /* [out] */ BSTR *pbstrFonts);


void __RPC_STUB IEditDebugServices_FontsOnLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_GetPixel_Proxy( 
    IEditDebugServices * This,
    /* [in] */ long X,
    /* [in] */ long Y,
    /* [out] */ long *piColor);


void __RPC_STUB IEditDebugServices_GetPixel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_IsUsingBckgrnRecalc_Proxy( 
    IEditDebugServices * This,
    /* [out] */ BOOL *pfUsingBckgrnRecalc);


void __RPC_STUB IEditDebugServices_IsUsingBckgrnRecalc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_IsEncodingAutoSelect_Proxy( 
    IEditDebugServices * This,
    /* [out] */ BOOL *pfEncodingAutoSelect);


void __RPC_STUB IEditDebugServices_IsEncodingAutoSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_EnableEncodingAutoSelect_Proxy( 
    IEditDebugServices * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB IEditDebugServices_EnableEncodingAutoSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEditDebugServices_IsUsingTableIncRecalc_Proxy( 
    IEditDebugServices * This,
    /* [out] */ BOOL *pfUsingTableIncRecalc);


void __RPC_STUB IEditDebugServices_IsUsingTableIncRecalc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEditDebugServices_INTERFACE_DEFINED__ */


#ifndef __IPrivacyServices_INTERFACE_DEFINED__
#define __IPrivacyServices_INTERFACE_DEFINED__

/* interface IPrivacyServices */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IPrivacyServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f84b-98b5-11cf-bb82-00aa00bdce0b")
    IPrivacyServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddPrivacyInfoToList( 
            /* [in] */ LPOLESTR pstrUrl,
            /* [in] */ LPOLESTR pstrPolicyRef,
            /* [in] */ LPOLESTR pstrP3PHeader,
            /* [in] */ LONG dwReserved,
            /* [in] */ DWORD privacyFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrivacyServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrivacyServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrivacyServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrivacyServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPrivacyInfoToList )( 
            IPrivacyServices * This,
            /* [in] */ LPOLESTR pstrUrl,
            /* [in] */ LPOLESTR pstrPolicyRef,
            /* [in] */ LPOLESTR pstrP3PHeader,
            /* [in] */ LONG dwReserved,
            /* [in] */ DWORD privacyFlags);
        
        END_INTERFACE
    } IPrivacyServicesVtbl;

    interface IPrivacyServices
    {
        CONST_VTBL struct IPrivacyServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrivacyServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPrivacyServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPrivacyServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPrivacyServices_AddPrivacyInfoToList(This,pstrUrl,pstrPolicyRef,pstrP3PHeader,dwReserved,privacyFlags)	\
    (This)->lpVtbl -> AddPrivacyInfoToList(This,pstrUrl,pstrPolicyRef,pstrP3PHeader,dwReserved,privacyFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPrivacyServices_AddPrivacyInfoToList_Proxy( 
    IPrivacyServices * This,
    /* [in] */ LPOLESTR pstrUrl,
    /* [in] */ LPOLESTR pstrPolicyRef,
    /* [in] */ LPOLESTR pstrP3PHeader,
    /* [in] */ LONG dwReserved,
    /* [in] */ DWORD privacyFlags);


void __RPC_STUB IPrivacyServices_AddPrivacyInfoToList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPrivacyServices_INTERFACE_DEFINED__ */


#ifndef __IHTMLOMWindowServices_INTERFACE_DEFINED__
#define __IHTMLOMWindowServices_INTERFACE_DEFINED__

/* interface IHTMLOMWindowServices */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLOMWindowServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f5fc-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLOMWindowServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE moveTo( 
            /* [in] */ LONG x,
            /* [in] */ LONG y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE moveBy( 
            /* [in] */ LONG x,
            /* [in] */ LONG y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resizeTo( 
            /* [in] */ LONG x,
            /* [in] */ LONG y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE resizeBy( 
            /* [in] */ LONG x,
            /* [in] */ LONG y) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLOMWindowServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLOMWindowServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLOMWindowServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLOMWindowServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *moveTo )( 
            IHTMLOMWindowServices * This,
            /* [in] */ LONG x,
            /* [in] */ LONG y);
        
        HRESULT ( STDMETHODCALLTYPE *moveBy )( 
            IHTMLOMWindowServices * This,
            /* [in] */ LONG x,
            /* [in] */ LONG y);
        
        HRESULT ( STDMETHODCALLTYPE *resizeTo )( 
            IHTMLOMWindowServices * This,
            /* [in] */ LONG x,
            /* [in] */ LONG y);
        
        HRESULT ( STDMETHODCALLTYPE *resizeBy )( 
            IHTMLOMWindowServices * This,
            /* [in] */ LONG x,
            /* [in] */ LONG y);
        
        END_INTERFACE
    } IHTMLOMWindowServicesVtbl;

    interface IHTMLOMWindowServices
    {
        CONST_VTBL struct IHTMLOMWindowServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLOMWindowServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLOMWindowServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLOMWindowServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLOMWindowServices_moveTo(This,x,y)	\
    (This)->lpVtbl -> moveTo(This,x,y)

#define IHTMLOMWindowServices_moveBy(This,x,y)	\
    (This)->lpVtbl -> moveBy(This,x,y)

#define IHTMLOMWindowServices_resizeTo(This,x,y)	\
    (This)->lpVtbl -> resizeTo(This,x,y)

#define IHTMLOMWindowServices_resizeBy(This,x,y)	\
    (This)->lpVtbl -> resizeBy(This,x,y)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLOMWindowServices_moveTo_Proxy( 
    IHTMLOMWindowServices * This,
    /* [in] */ LONG x,
    /* [in] */ LONG y);


void __RPC_STUB IHTMLOMWindowServices_moveTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLOMWindowServices_moveBy_Proxy( 
    IHTMLOMWindowServices * This,
    /* [in] */ LONG x,
    /* [in] */ LONG y);


void __RPC_STUB IHTMLOMWindowServices_moveBy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLOMWindowServices_resizeTo_Proxy( 
    IHTMLOMWindowServices * This,
    /* [in] */ LONG x,
    /* [in] */ LONG y);


void __RPC_STUB IHTMLOMWindowServices_resizeTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLOMWindowServices_resizeBy_Proxy( 
    IHTMLOMWindowServices * This,
    /* [in] */ LONG x,
    /* [in] */ LONG y);


void __RPC_STUB IHTMLOMWindowServices_resizeBy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLOMWindowServices_INTERFACE_DEFINED__ */


#ifndef __IHTMLFilterPainter_INTERFACE_DEFINED__
#define __IHTMLFilterPainter_INTERFACE_DEFINED__

/* interface IHTMLFilterPainter */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLFilterPainter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6de-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLFilterPainter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InvalidateRectUnfiltered( 
            /* [in] */ RECT *prcInvalid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateRgnUnfiltered( 
            /* [in] */ HRGN hrgnInvalid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeElementVisibility( 
            /* [in] */ BOOL fVisible) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLFilterPainterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLFilterPainter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLFilterPainter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLFilterPainter * This);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateRectUnfiltered )( 
            IHTMLFilterPainter * This,
            /* [in] */ RECT *prcInvalid);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateRgnUnfiltered )( 
            IHTMLFilterPainter * This,
            /* [in] */ HRGN hrgnInvalid);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeElementVisibility )( 
            IHTMLFilterPainter * This,
            /* [in] */ BOOL fVisible);
        
        END_INTERFACE
    } IHTMLFilterPainterVtbl;

    interface IHTMLFilterPainter
    {
        CONST_VTBL struct IHTMLFilterPainterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLFilterPainter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLFilterPainter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLFilterPainter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLFilterPainter_InvalidateRectUnfiltered(This,prcInvalid)	\
    (This)->lpVtbl -> InvalidateRectUnfiltered(This,prcInvalid)

#define IHTMLFilterPainter_InvalidateRgnUnfiltered(This,hrgnInvalid)	\
    (This)->lpVtbl -> InvalidateRgnUnfiltered(This,hrgnInvalid)

#define IHTMLFilterPainter_ChangeElementVisibility(This,fVisible)	\
    (This)->lpVtbl -> ChangeElementVisibility(This,fVisible)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLFilterPainter_InvalidateRectUnfiltered_Proxy( 
    IHTMLFilterPainter * This,
    /* [in] */ RECT *prcInvalid);


void __RPC_STUB IHTMLFilterPainter_InvalidateRectUnfiltered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPainter_InvalidateRgnUnfiltered_Proxy( 
    IHTMLFilterPainter * This,
    /* [in] */ HRGN hrgnInvalid);


void __RPC_STUB IHTMLFilterPainter_InvalidateRgnUnfiltered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPainter_ChangeElementVisibility_Proxy( 
    IHTMLFilterPainter * This,
    /* [in] */ BOOL fVisible);


void __RPC_STUB IHTMLFilterPainter_ChangeElementVisibility_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLFilterPainter_INTERFACE_DEFINED__ */


#ifndef __IHTMLFilterPaintSite_INTERFACE_DEFINED__
#define __IHTMLFilterPaintSite_INTERFACE_DEFINED__

/* interface IHTMLFilterPaintSite */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IHTMLFilterPaintSite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f6d3-98b5-11cf-bb82-00aa00bdce0b")
    IHTMLFilterPaintSite : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DrawUnfiltered( 
            /* [in] */ HDC hdc,
            /* [in] */ IUnknown *punkDrawObject,
            /* [in] */ RECT rcBounds,
            /* [in] */ RECT rcUpdate,
            /* [in] */ LONG lDrawLayers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HitTestPointUnfiltered( 
            /* [in] */ POINT pt,
            /* [in] */ LONG lDrawLayers,
            /* [out][retval] */ BOOL *pbHit) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateRectFiltered( 
            /* [in] */ RECT *prcInvalid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateRgnFiltered( 
            /* [in] */ HRGN hrgnInvalid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeFilterVisibility( 
            /* [in] */ BOOL fVisible) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnsureViewForFilterSite( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDirectDraw( 
            /* [out][retval] */ void **ppDirectDraw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterFlags( 
            /* [out][retval] */ DWORD *nFlagVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHTMLFilterPaintSiteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHTMLFilterPaintSite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHTMLFilterPaintSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *DrawUnfiltered )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ HDC hdc,
            /* [in] */ IUnknown *punkDrawObject,
            /* [in] */ RECT rcBounds,
            /* [in] */ RECT rcUpdate,
            /* [in] */ LONG lDrawLayers);
        
        HRESULT ( STDMETHODCALLTYPE *HitTestPointUnfiltered )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ POINT pt,
            /* [in] */ LONG lDrawLayers,
            /* [out][retval] */ BOOL *pbHit);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateRectFiltered )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ RECT *prcInvalid);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateRgnFiltered )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ HRGN hrgnInvalid);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeFilterVisibility )( 
            IHTMLFilterPaintSite * This,
            /* [in] */ BOOL fVisible);
        
        HRESULT ( STDMETHODCALLTYPE *EnsureViewForFilterSite )( 
            IHTMLFilterPaintSite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDirectDraw )( 
            IHTMLFilterPaintSite * This,
            /* [out][retval] */ void **ppDirectDraw);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilterFlags )( 
            IHTMLFilterPaintSite * This,
            /* [out][retval] */ DWORD *nFlagVal);
        
        END_INTERFACE
    } IHTMLFilterPaintSiteVtbl;

    interface IHTMLFilterPaintSite
    {
        CONST_VTBL struct IHTMLFilterPaintSiteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHTMLFilterPaintSite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHTMLFilterPaintSite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHTMLFilterPaintSite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHTMLFilterPaintSite_DrawUnfiltered(This,hdc,punkDrawObject,rcBounds,rcUpdate,lDrawLayers)	\
    (This)->lpVtbl -> DrawUnfiltered(This,hdc,punkDrawObject,rcBounds,rcUpdate,lDrawLayers)

#define IHTMLFilterPaintSite_HitTestPointUnfiltered(This,pt,lDrawLayers,pbHit)	\
    (This)->lpVtbl -> HitTestPointUnfiltered(This,pt,lDrawLayers,pbHit)

#define IHTMLFilterPaintSite_InvalidateRectFiltered(This,prcInvalid)	\
    (This)->lpVtbl -> InvalidateRectFiltered(This,prcInvalid)

#define IHTMLFilterPaintSite_InvalidateRgnFiltered(This,hrgnInvalid)	\
    (This)->lpVtbl -> InvalidateRgnFiltered(This,hrgnInvalid)

#define IHTMLFilterPaintSite_ChangeFilterVisibility(This,fVisible)	\
    (This)->lpVtbl -> ChangeFilterVisibility(This,fVisible)

#define IHTMLFilterPaintSite_EnsureViewForFilterSite(This)	\
    (This)->lpVtbl -> EnsureViewForFilterSite(This)

#define IHTMLFilterPaintSite_GetDirectDraw(This,ppDirectDraw)	\
    (This)->lpVtbl -> GetDirectDraw(This,ppDirectDraw)

#define IHTMLFilterPaintSite_GetFilterFlags(This,nFlagVal)	\
    (This)->lpVtbl -> GetFilterFlags(This,nFlagVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHTMLFilterPaintSite_DrawUnfiltered_Proxy( 
    IHTMLFilterPaintSite * This,
    /* [in] */ HDC hdc,
    /* [in] */ IUnknown *punkDrawObject,
    /* [in] */ RECT rcBounds,
    /* [in] */ RECT rcUpdate,
    /* [in] */ LONG lDrawLayers);


void __RPC_STUB IHTMLFilterPaintSite_DrawUnfiltered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPaintSite_HitTestPointUnfiltered_Proxy( 
    IHTMLFilterPaintSite * This,
    /* [in] */ POINT pt,
    /* [in] */ LONG lDrawLayers,
    /* [out][retval] */ BOOL *pbHit);


void __RPC_STUB IHTMLFilterPaintSite_HitTestPointUnfiltered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPaintSite_InvalidateRectFiltered_Proxy( 
    IHTMLFilterPaintSite * This,
    /* [in] */ RECT *prcInvalid);


void __RPC_STUB IHTMLFilterPaintSite_InvalidateRectFiltered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPaintSite_InvalidateRgnFiltered_Proxy( 
    IHTMLFilterPaintSite * This,
    /* [in] */ HRGN hrgnInvalid);


void __RPC_STUB IHTMLFilterPaintSite_InvalidateRgnFiltered_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPaintSite_ChangeFilterVisibility_Proxy( 
    IHTMLFilterPaintSite * This,
    /* [in] */ BOOL fVisible);


void __RPC_STUB IHTMLFilterPaintSite_ChangeFilterVisibility_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPaintSite_EnsureViewForFilterSite_Proxy( 
    IHTMLFilterPaintSite * This);


void __RPC_STUB IHTMLFilterPaintSite_EnsureViewForFilterSite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPaintSite_GetDirectDraw_Proxy( 
    IHTMLFilterPaintSite * This,
    /* [out][retval] */ void **ppDirectDraw);


void __RPC_STUB IHTMLFilterPaintSite_GetDirectDraw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHTMLFilterPaintSite_GetFilterFlags_Proxy( 
    IHTMLFilterPaintSite * This,
    /* [out][retval] */ DWORD *nFlagVal);


void __RPC_STUB IHTMLFilterPaintSite_GetFilterFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHTMLFilterPaintSite_INTERFACE_DEFINED__ */


#ifndef __IElementNamespacePrivate_INTERFACE_DEFINED__
#define __IElementNamespacePrivate_INTERFACE_DEFINED__

/* interface IElementNamespacePrivate */
/* [uuid][unique][object] */ 


EXTERN_C const IID IID_IElementNamespacePrivate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f7ff-98b5-11cf-bb82-00aa00bdce0b")
    IElementNamespacePrivate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddTagPrivate( 
            /* [in] */ BSTR bstrTagName,
            /* [in] */ BSTR bstrBaseTagName,
            /* [in] */ LONG lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IElementNamespacePrivateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IElementNamespacePrivate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IElementNamespacePrivate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IElementNamespacePrivate * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddTagPrivate )( 
            IElementNamespacePrivate * This,
            /* [in] */ BSTR bstrTagName,
            /* [in] */ BSTR bstrBaseTagName,
            /* [in] */ LONG lFlags);
        
        END_INTERFACE
    } IElementNamespacePrivateVtbl;

    interface IElementNamespacePrivate
    {
        CONST_VTBL struct IElementNamespacePrivateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IElementNamespacePrivate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IElementNamespacePrivate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IElementNamespacePrivate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IElementNamespacePrivate_AddTagPrivate(This,bstrTagName,bstrBaseTagName,lFlags)	\
    (This)->lpVtbl -> AddTagPrivate(This,bstrTagName,bstrBaseTagName,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IElementNamespacePrivate_AddTagPrivate_Proxy( 
    IElementNamespacePrivate * This,
    /* [in] */ BSTR bstrTagName,
    /* [in] */ BSTR bstrBaseTagName,
    /* [in] */ LONG lFlags);


void __RPC_STUB IElementNamespacePrivate_AddTagPrivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IElementNamespacePrivate_INTERFACE_DEFINED__ */

#endif /* __MSHTMLINTERNAL_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_interned_0728 */
/* [local] */ 

#endif //INTERNAL_H_


extern RPC_IF_HANDLE __MIDL_itf_interned_0728_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_interned_0728_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\inetcore\inc\ratingsp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for ratingsp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ratingsp_h__
#define __ratingsp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRatingNotification_FWD_DEFINED__
#define __IRatingNotification_FWD_DEFINED__
typedef interface IRatingNotification IRatingNotification;
#endif 	/* __IRatingNotification_FWD_DEFINED__ */


#ifndef __ICustomRatingHelper_FWD_DEFINED__
#define __ICustomRatingHelper_FWD_DEFINED__
typedef interface ICustomRatingHelper ICustomRatingHelper;
#endif 	/* __ICustomRatingHelper_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_ratingsp_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// Ratingsp.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1999 Microsoft Corporation.  All Rights Reserved.
//
//Date : August 18, 1999
//DESCRIPTION : private interface definitions between Custom and msrating
//
typedef 
enum tagRATING_BLOCKING_SOURCE
    {	RBS_NO_RATINGS	= 0,
	RBS_PAGE	= RBS_NO_RATINGS + 1,
	RBS_RATING_HELPER	= RBS_PAGE + 1,
	RBS_CUSTOM_RATING_HELPER	= RBS_RATING_HELPER + 1,
	RBS_ERROR	= RBS_CUSTOM_RATING_HELPER + 1
    } 	RATING_BLOCKING_SOURCE;

typedef 
enum tagRATING_BLOCKING_METHOD
    {	RBM_DENY	= 0,
	RBM_LABEL	= RBM_DENY + 1,
	RBM_UNINIT	= RBM_LABEL + 1,
	RBM_ERROR_NOT_IN_CUSTOM_MODE	= RBM_UNINIT + 1
    } 	RATING_BLOCKING_METHOD;

typedef struct tagRATINGLEVEL
    {
    UINT nValue;
    LPWSTR pwszValueName;
    LPWSTR pwszDescription;
    } 	RATINGLEVEL;

typedef struct tagRATINGCATEGORY
    {
    LPWSTR pwszCategoryName;
    LPWSTR pwszTransmitName;
    } 	RATINGCATEGORY;

typedef struct tagRATINGBLOCKINGCATEGORY
    {
    LPWSTR pwszCategoryName;
    LPWSTR pwszTransmitName;
    UINT nValue;
    LPWSTR pwszValueName;
    } 	RATINGBLOCKINGCATEGORY;

typedef struct tagRATINGBLOCKINGLABELLIST
    {
    LPWSTR pwszRatingSystemName;
    UINT cBlockingLabels;
    RATINGBLOCKINGCATEGORY *paRBLS;
    } 	RATINGBLOCKINGLABELLIST;

typedef struct tagRATINGBLOCKINGINFO
    {
    LPWSTR pwszDeniedURL;
    RATING_BLOCKING_SOURCE rbSource;
    RATING_BLOCKING_METHOD rbMethod;
    UINT cLabels;
    RATINGBLOCKINGLABELLIST *prbLabelList;
    LPWSTR pwszRatingHelperName;
    LPWSTR pwszRatingHelperReason;
    } 	RATINGBLOCKINGINFO;

typedef struct tagRATINGCATEGORYSETTING
    {
    LPSTR pszValueName;
    UINT nValue;
    } 	RATINGCATEGORYSETTING;

typedef struct tagRATINGSYSTEMSETTING
    {
    LPSTR pszRatingSystemName;
    UINT cCategories;
    RATINGCATEGORYSETTING *paRCS;
    } 	RATINGSYSTEMSETTING;





extern RPC_IF_HANDLE __MIDL_itf_ratingsp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ratingsp_0000_v0_0_s_ifspec;

#ifndef __IRatingNotification_INTERFACE_DEFINED__
#define __IRatingNotification_INTERFACE_DEFINED__

/* interface IRatingNotification */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IRatingNotification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("639447BD-B2D3-44b9-9FB0-510F23CB45E4")
    IRatingNotification : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AccessDeniedNotify( 
            /* [in] */ RATINGBLOCKINGINFO *rbInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRatingsEnabled( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRatingNotificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRatingNotification * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRatingNotification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRatingNotification * This);
        
        HRESULT ( STDMETHODCALLTYPE *AccessDeniedNotify )( 
            IRatingNotification * This,
            /* [in] */ RATINGBLOCKINGINFO *rbInfo);
        
        HRESULT ( STDMETHODCALLTYPE *IsRatingsEnabled )( 
            IRatingNotification * This);
        
        END_INTERFACE
    } IRatingNotificationVtbl;

    interface IRatingNotification
    {
        CONST_VTBL struct IRatingNotificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRatingNotification_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRatingNotification_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRatingNotification_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRatingNotification_AccessDeniedNotify(This,rbInfo)	\
    (This)->lpVtbl -> AccessDeniedNotify(This,rbInfo)

#define IRatingNotification_IsRatingsEnabled(This)	\
    (This)->lpVtbl -> IsRatingsEnabled(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRatingNotification_AccessDeniedNotify_Proxy( 
    IRatingNotification * This,
    /* [in] */ RATINGBLOCKINGINFO *rbInfo);


void __RPC_STUB IRatingNotification_AccessDeniedNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRatingNotification_IsRatingsEnabled_Proxy( 
    IRatingNotification * This);


void __RPC_STUB IRatingNotification_IsRatingsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRatingNotification_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ratingsp_0136 */
/* [local] */ 


#define SID_SRatingNotification IID_IRatingNotification



extern RPC_IF_HANDLE __MIDL_itf_ratingsp_0136_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ratingsp_0136_v0_0_s_ifspec;

#ifndef __ICustomRatingHelper_INTERFACE_DEFINED__
#define __ICustomRatingHelper_INTERFACE_DEFINED__

/* interface ICustomRatingHelper */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ICustomRatingHelper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D0D9842D-E211-4b2c-88DC-BC729342DFCB")
    ICustomRatingHelper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ObtainCustomRating( 
            /* [in] */ LPCSTR pszTargetUrl,
            /* [in] */ HANDLE hAbortEvent,
            /* [in] */ IMalloc *pAllocator,
            /* [out] */ LPSTR *ppRatingOut,
            /* [out] */ LPSTR *ppRatingName,
            /* [out] */ LPSTR *ppRatingReason) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICustomRatingHelperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICustomRatingHelper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICustomRatingHelper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICustomRatingHelper * This);
        
        HRESULT ( STDMETHODCALLTYPE *ObtainCustomRating )( 
            ICustomRatingHelper * This,
            /* [in] */ LPCSTR pszTargetUrl,
            /* [in] */ HANDLE hAbortEvent,
            /* [in] */ IMalloc *pAllocator,
            /* [out] */ LPSTR *ppRatingOut,
            /* [out] */ LPSTR *ppRatingName,
            /* [out] */ LPSTR *ppRatingReason);
        
        END_INTERFACE
    } ICustomRatingHelperVtbl;

    interface ICustomRatingHelper
    {
        CONST_VTBL struct ICustomRatingHelperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICustomRatingHelper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICustomRatingHelper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICustomRatingHelper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICustomRatingHelper_ObtainCustomRating(This,pszTargetUrl,hAbortEvent,pAllocator,ppRatingOut,ppRatingName,ppRatingReason)	\
    (This)->lpVtbl -> ObtainCustomRating(This,pszTargetUrl,hAbortEvent,pAllocator,ppRatingOut,ppRatingName,ppRatingReason)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICustomRatingHelper_ObtainCustomRating_Proxy( 
    ICustomRatingHelper * This,
    /* [in] */ LPCSTR pszTargetUrl,
    /* [in] */ HANDLE hAbortEvent,
    /* [in] */ IMalloc *pAllocator,
    /* [out] */ LPSTR *ppRatingOut,
    /* [out] */ LPSTR *ppRatingName,
    /* [out] */ LPSTR *ppRatingReason);


void __RPC_STUB ICustomRatingHelper_ObtainCustomRating_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICustomRatingHelper_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ratingsp_0137 */
/* [local] */ 

STDAPI RatingCustomInit(BOOL bInit = TRUE);
STDAPI RatingCustomAddRatingSystem(LPSTR pszRatingSystemBuffer, UINT nBufferSize);
STDAPI RatingCustomSetUserOptions(RATINGSYSTEMSETTING* pRSSettings, UINT cSettings);
STDAPI RatingCustomAddRatingHelper(LPCSTR pszLibraryName, CLSID clsid, DWORD dwSort);
STDAPI RatingCustomRemoveRatingHelper(CLSID clsid);
STDAPI RatingCustomCrackData(LPCSTR pszUsername, void* pvRatingDetails, RATINGBLOCKINGINFO** pprbInfo);
STDAPI RatingCustomDeleteCrackedData(RATINGBLOCKINGINFO* prblInfo);
STDAPI RatingCustomSetDefaultBureau(LPCSTR pszRatingBureau);


extern RPC_IF_HANDLE __MIDL_itf_ratingsp_0137_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ratingsp_0137_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\inetcore\inc\httprequest.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for httprequest.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __httprequest_h__
#define __httprequest_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWinHttpRequest_FWD_DEFINED__
#define __IWinHttpRequest_FWD_DEFINED__
typedef interface IWinHttpRequest IWinHttpRequest;
#endif 	/* __IWinHttpRequest_FWD_DEFINED__ */


#ifndef __IWinHttpRequestEvents_FWD_DEFINED__
#define __IWinHttpRequestEvents_FWD_DEFINED__
typedef interface IWinHttpRequestEvents IWinHttpRequestEvents;
#endif 	/* __IWinHttpRequestEvents_FWD_DEFINED__ */


#ifndef __WinHttpRequest_FWD_DEFINED__
#define __WinHttpRequest_FWD_DEFINED__

#ifdef __cplusplus
typedef class WinHttpRequest WinHttpRequest;
#else
typedef struct WinHttpRequest WinHttpRequest;
#endif /* __cplusplus */

#endif 	/* __WinHttpRequest_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_httprequest_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows HTTP Services (WinHTTP) version 5.1
//  Copyright (C) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------


extern RPC_IF_HANDLE __MIDL_itf_httprequest_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_httprequest_0000_v0_0_s_ifspec;


#ifndef __WinHttp_LIBRARY_DEFINED__
#define __WinHttp_LIBRARY_DEFINED__

/* library WinHttp */
/* [version][lcid][helpstring][uuid] */ 

typedef /* [public] */ long HTTPREQUEST_PROXY_SETTING;

#define	HTTPREQUEST_PROXYSETTING_DEFAULT	( 0 )

#define	HTTPREQUEST_PROXYSETTING_PRECONFIG	( 0 )

#define	HTTPREQUEST_PROXYSETTING_DIRECT	( 0x1 )

#define	HTTPREQUEST_PROXYSETTING_PROXY	( 0x2 )

typedef /* [public] */ long HTTPREQUEST_SETCREDENTIALS_FLAGS;

#define	HTTPREQUEST_SETCREDENTIALS_FOR_SERVER	( 0 )

#define	HTTPREQUEST_SETCREDENTIALS_FOR_PROXY	( 0x1 )

typedef /* [helpstring][uuid] */  DECLSPEC_UUID("12782009-FE90-4877-9730-E5E183669B19") 
enum WinHttpRequestOption
    {	WinHttpRequestOption_UserAgentString	= 0,
	WinHttpRequestOption_URL	= WinHttpRequestOption_UserAgentString + 1,
	WinHttpRequestOption_URLCodePage	= WinHttpRequestOption_URL + 1,
	WinHttpRequestOption_EscapePercentInURL	= WinHttpRequestOption_URLCodePage + 1,
	WinHttpRequestOption_SslErrorIgnoreFlags	= WinHttpRequestOption_EscapePercentInURL + 1,
	WinHttpRequestOption_SelectCertificate	= WinHttpRequestOption_SslErrorIgnoreFlags + 1,
	WinHttpRequestOption_EnableRedirects	= WinHttpRequestOption_SelectCertificate + 1,
	WinHttpRequestOption_UrlEscapeDisable	= WinHttpRequestOption_EnableRedirects + 1,
	WinHttpRequestOption_UrlEscapeDisableQuery	= WinHttpRequestOption_UrlEscapeDisable + 1,
	WinHttpRequestOption_SecureProtocols	= WinHttpRequestOption_UrlEscapeDisableQuery + 1,
	WinHttpRequestOption_EnableTracing	= WinHttpRequestOption_SecureProtocols + 1,
	WinHttpRequestOption_RevertImpersonationOverSsl	= WinHttpRequestOption_EnableTracing + 1,
	WinHttpRequestOption_EnableHttpsToHttpRedirects	= WinHttpRequestOption_RevertImpersonationOverSsl + 1,
	WinHttpRequestOption_EnablePassportAuthentication	= WinHttpRequestOption_EnableHttpsToHttpRedirects + 1
    } 	WinHttpRequestOption;

typedef /* [uuid] */  DECLSPEC_UUID("9d8a6df8-13de-4b1f-a330-67c719d62514") 
enum WinHttpRequestAutoLogonPolicy
    {	AutoLogonPolicy_Always	= 0,
	AutoLogonPolicy_OnlyIfBypassProxy	= AutoLogonPolicy_Always + 1,
	AutoLogonPolicy_Never	= AutoLogonPolicy_OnlyIfBypassProxy + 1
    } 	WinHttpRequestAutoLogonPolicy;

typedef /* [uuid] */  DECLSPEC_UUID("152a1ca2-55a9-43a3-b187-0605bb886349") 
enum WinHttpRequestSslErrorFlags
    {	SslErrorFlag_UnknownCA	= 0x100,
	SslErrorFlag_CertWrongUsage	= 0x200,
	SslErrorFlag_CertCNInvalid	= 0x1000,
	SslErrorFlag_CertDateInvalid	= 0x2000,
	SslErrorFlag_Ignore_All	= 0x3300
    } 	WinHttpRequestSslErrorFlags;

typedef /* [uuid] */  DECLSPEC_UUID("6b2c51c1-a8ea-46bd-b928-c9b76f9f14dd") 
enum WinHttpRequestSecureProtocols
    {	SecureProtocol_SSL2	= 0x8,
	SecureProtocol_SSL3	= 0x20,
	SecureProtocol_TLS1	= 0x80,
	SecureProtocol_ALL	= 0xa8
    } 	WinHttpRequestSecureProtocols;


EXTERN_C const IID LIBID_WinHttp;

#ifndef __IWinHttpRequest_INTERFACE_DEFINED__
#define __IWinHttpRequest_INTERFACE_DEFINED__

/* interface IWinHttpRequest */
/* [unique][helpstring][nonextensible][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IWinHttpRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("016fe2ec-b2c8-45f8-b23b-39e53a75396b")
    IWinHttpRequest : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetProxy( 
            /* [in] */ HTTPREQUEST_PROXY_SETTING ProxySetting,
            /* [optional][in] */ VARIANT ProxyServer,
            /* [optional][in] */ VARIANT BypassList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetCredentials( 
            /* [in] */ BSTR UserName,
            /* [in] */ BSTR Password,
            /* [in] */ HTTPREQUEST_SETCREDENTIALS_FLAGS Flags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ BSTR Method,
            /* [in] */ BSTR Url,
            /* [optional][in] */ VARIANT Async) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetRequestHeader( 
            /* [in] */ BSTR Header,
            /* [in] */ BSTR Value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetResponseHeader( 
            /* [in] */ BSTR Header,
            /* [retval][out] */ BSTR *Value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAllResponseHeaders( 
            /* [retval][out] */ BSTR *Headers) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Send( 
            /* [optional][in] */ VARIANT Body) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ long *Status) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StatusText( 
            /* [retval][out] */ BSTR *Status) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ResponseText( 
            /* [retval][out] */ BSTR *Body) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ResponseBody( 
            /* [retval][out] */ VARIANT *Body) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ResponseStream( 
            /* [retval][out] */ VARIANT *Body) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Option( 
            /* [in] */ WinHttpRequestOption Option,
            /* [retval][out] */ VARIANT *Value) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Option( 
            /* [in] */ WinHttpRequestOption Option,
            /* [in] */ VARIANT Value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WaitForResponse( 
            /* [optional][in] */ VARIANT Timeout,
            /* [retval][out] */ VARIANT_BOOL *Succeeded) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetTimeouts( 
            /* [in] */ long ResolveTimeout,
            /* [in] */ long ConnectTimeout,
            /* [in] */ long SendTimeout,
            /* [in] */ long ReceiveTimeout) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetClientCertificate( 
            /* [in] */ BSTR ClientCertificate) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetAutoLogonPolicy( 
            /* [in] */ WinHttpRequestAutoLogonPolicy AutoLogonPolicy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinHttpRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinHttpRequest * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinHttpRequest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinHttpRequest * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IWinHttpRequest * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IWinHttpRequest * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IWinHttpRequest * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWinHttpRequest * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetProxy )( 
            IWinHttpRequest * This,
            /* [in] */ HTTPREQUEST_PROXY_SETTING ProxySetting,
            /* [optional][in] */ VARIANT ProxyServer,
            /* [optional][in] */ VARIANT BypassList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetCredentials )( 
            IWinHttpRequest * This,
            /* [in] */ BSTR UserName,
            /* [in] */ BSTR Password,
            /* [in] */ HTTPREQUEST_SETCREDENTIALS_FLAGS Flags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            IWinHttpRequest * This,
            /* [in] */ BSTR Method,
            /* [in] */ BSTR Url,
            /* [optional][in] */ VARIANT Async);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetRequestHeader )( 
            IWinHttpRequest * This,
            /* [in] */ BSTR Header,
            /* [in] */ BSTR Value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetResponseHeader )( 
            IWinHttpRequest * This,
            /* [in] */ BSTR Header,
            /* [retval][out] */ BSTR *Value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetAllResponseHeaders )( 
            IWinHttpRequest * This,
            /* [retval][out] */ BSTR *Headers);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Send )( 
            IWinHttpRequest * This,
            /* [optional][in] */ VARIANT Body);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            IWinHttpRequest * This,
            /* [retval][out] */ long *Status);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StatusText )( 
            IWinHttpRequest * This,
            /* [retval][out] */ BSTR *Status);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ResponseText )( 
            IWinHttpRequest * This,
            /* [retval][out] */ BSTR *Body);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ResponseBody )( 
            IWinHttpRequest * This,
            /* [retval][out] */ VARIANT *Body);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ResponseStream )( 
            IWinHttpRequest * This,
            /* [retval][out] */ VARIANT *Body);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Option )( 
            IWinHttpRequest * This,
            /* [in] */ WinHttpRequestOption Option,
            /* [retval][out] */ VARIANT *Value);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Option )( 
            IWinHttpRequest * This,
            /* [in] */ WinHttpRequestOption Option,
            /* [in] */ VARIANT Value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WaitForResponse )( 
            IWinHttpRequest * This,
            /* [optional][in] */ VARIANT Timeout,
            /* [retval][out] */ VARIANT_BOOL *Succeeded);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IWinHttpRequest * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetTimeouts )( 
            IWinHttpRequest * This,
            /* [in] */ long ResolveTimeout,
            /* [in] */ long ConnectTimeout,
            /* [in] */ long SendTimeout,
            /* [in] */ long ReceiveTimeout);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetClientCertificate )( 
            IWinHttpRequest * This,
            /* [in] */ BSTR ClientCertificate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetAutoLogonPolicy )( 
            IWinHttpRequest * This,
            /* [in] */ WinHttpRequestAutoLogonPolicy AutoLogonPolicy);
        
        END_INTERFACE
    } IWinHttpRequestVtbl;

    interface IWinHttpRequest
    {
        CONST_VTBL struct IWinHttpRequestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinHttpRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWinHttpRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWinHttpRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWinHttpRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWinHttpRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWinHttpRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWinHttpRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWinHttpRequest_SetProxy(This,ProxySetting,ProxyServer,BypassList)	\
    (This)->lpVtbl -> SetProxy(This,ProxySetting,ProxyServer,BypassList)

#define IWinHttpRequest_SetCredentials(This,UserName,Password,Flags)	\
    (This)->lpVtbl -> SetCredentials(This,UserName,Password,Flags)

#define IWinHttpRequest_Open(This,Method,Url,Async)	\
    (This)->lpVtbl -> Open(This,Method,Url,Async)

#define IWinHttpRequest_SetRequestHeader(This,Header,Value)	\
    (This)->lpVtbl -> SetRequestHeader(This,Header,Value)

#define IWinHttpRequest_GetResponseHeader(This,Header,Value)	\
    (This)->lpVtbl -> GetResponseHeader(This,Header,Value)

#define IWinHttpRequest_GetAllResponseHeaders(This,Headers)	\
    (This)->lpVtbl -> GetAllResponseHeaders(This,Headers)

#define IWinHttpRequest_Send(This,Body)	\
    (This)->lpVtbl -> Send(This,Body)

#define IWinHttpRequest_get_Status(This,Status)	\
    (This)->lpVtbl -> get_Status(This,Status)

#define IWinHttpRequest_get_StatusText(This,Status)	\
    (This)->lpVtbl -> get_StatusText(This,Status)

#define IWinHttpRequest_get_ResponseText(This,Body)	\
    (This)->lpVtbl -> get_ResponseText(This,Body)

#define IWinHttpRequest_get_ResponseBody(This,Body)	\
    (This)->lpVtbl -> get_ResponseBody(This,Body)

#define IWinHttpRequest_get_ResponseStream(This,Body)	\
    (This)->lpVtbl -> get_ResponseStream(This,Body)

#define IWinHttpRequest_get_Option(This,Option,Value)	\
    (This)->lpVtbl -> get_Option(This,Option,Value)

#define IWinHttpRequest_put_Option(This,Option,Value)	\
    (This)->lpVtbl -> put_Option(This,Option,Value)

#define IWinHttpRequest_WaitForResponse(This,Timeout,Succeeded)	\
    (This)->lpVtbl -> WaitForResponse(This,Timeout,Succeeded)

#define IWinHttpRequest_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#define IWinHttpRequest_SetTimeouts(This,ResolveTimeout,ConnectTimeout,SendTimeout,ReceiveTimeout)	\
    (This)->lpVtbl -> SetTimeouts(This,ResolveTimeout,ConnectTimeout,SendTimeout,ReceiveTimeout)

#define IWinHttpRequest_SetClientCertificate(This,ClientCertificate)	\
    (This)->lpVtbl -> SetClientCertificate(This,ClientCertificate)

#define IWinHttpRequest_SetAutoLogonPolicy(This,AutoLogonPolicy)	\
    (This)->lpVtbl -> SetAutoLogonPolicy(This,AutoLogonPolicy)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_SetProxy_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ HTTPREQUEST_PROXY_SETTING ProxySetting,
    /* [optional][in] */ VARIANT ProxyServer,
    /* [optional][in] */ VARIANT BypassList);


void __RPC_STUB IWinHttpRequest_SetProxy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_SetCredentials_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ BSTR UserName,
    /* [in] */ BSTR Password,
    /* [in] */ HTTPREQUEST_SETCREDENTIALS_FLAGS Flags);


void __RPC_STUB IWinHttpRequest_SetCredentials_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_Open_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ BSTR Method,
    /* [in] */ BSTR Url,
    /* [optional][in] */ VARIANT Async);


void __RPC_STUB IWinHttpRequest_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_SetRequestHeader_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ BSTR Header,
    /* [in] */ BSTR Value);


void __RPC_STUB IWinHttpRequest_SetRequestHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_GetResponseHeader_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ BSTR Header,
    /* [retval][out] */ BSTR *Value);


void __RPC_STUB IWinHttpRequest_GetResponseHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_GetAllResponseHeaders_Proxy( 
    IWinHttpRequest * This,
    /* [retval][out] */ BSTR *Headers);


void __RPC_STUB IWinHttpRequest_GetAllResponseHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_Send_Proxy( 
    IWinHttpRequest * This,
    /* [optional][in] */ VARIANT Body);


void __RPC_STUB IWinHttpRequest_Send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_get_Status_Proxy( 
    IWinHttpRequest * This,
    /* [retval][out] */ long *Status);


void __RPC_STUB IWinHttpRequest_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_get_StatusText_Proxy( 
    IWinHttpRequest * This,
    /* [retval][out] */ BSTR *Status);


void __RPC_STUB IWinHttpRequest_get_StatusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_get_ResponseText_Proxy( 
    IWinHttpRequest * This,
    /* [retval][out] */ BSTR *Body);


void __RPC_STUB IWinHttpRequest_get_ResponseText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_get_ResponseBody_Proxy( 
    IWinHttpRequest * This,
    /* [retval][out] */ VARIANT *Body);


void __RPC_STUB IWinHttpRequest_get_ResponseBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_get_ResponseStream_Proxy( 
    IWinHttpRequest * This,
    /* [retval][out] */ VARIANT *Body);


void __RPC_STUB IWinHttpRequest_get_ResponseStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_get_Option_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ WinHttpRequestOption Option,
    /* [retval][out] */ VARIANT *Value);


void __RPC_STUB IWinHttpRequest_get_Option_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_put_Option_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ WinHttpRequestOption Option,
    /* [in] */ VARIANT Value);


void __RPC_STUB IWinHttpRequest_put_Option_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_WaitForResponse_Proxy( 
    IWinHttpRequest * This,
    /* [optional][in] */ VARIANT Timeout,
    /* [retval][out] */ VARIANT_BOOL *Succeeded);


void __RPC_STUB IWinHttpRequest_WaitForResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_Abort_Proxy( 
    IWinHttpRequest * This);


void __RPC_STUB IWinHttpRequest_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_SetTimeouts_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ long ResolveTimeout,
    /* [in] */ long ConnectTimeout,
    /* [in] */ long SendTimeout,
    /* [in] */ long ReceiveTimeout);


void __RPC_STUB IWinHttpRequest_SetTimeouts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_SetClientCertificate_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ BSTR ClientCertificate);


void __RPC_STUB IWinHttpRequest_SetClientCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IWinHttpRequest_SetAutoLogonPolicy_Proxy( 
    IWinHttpRequest * This,
    /* [in] */ WinHttpRequestAutoLogonPolicy AutoLogonPolicy);


void __RPC_STUB IWinHttpRequest_SetAutoLogonPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWinHttpRequest_INTERFACE_DEFINED__ */


#ifndef __IWinHttpRequestEvents_INTERFACE_DEFINED__
#define __IWinHttpRequestEvents_INTERFACE_DEFINED__

/* interface IWinHttpRequestEvents */
/* [unique][helpstring][nonextensible][oleautomation][uuid][object] */ 


EXTERN_C const IID IID_IWinHttpRequestEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f97f4e15-b787-4212-80d1-d380cbbf982e")
    IWinHttpRequestEvents : public IUnknown
    {
    public:
        virtual void STDMETHODCALLTYPE OnResponseStart( 
            /* [in] */ long Status,
            /* [in] */ BSTR ContentType) = 0;
        
        virtual void STDMETHODCALLTYPE OnResponseDataAvailable( 
            /* [in] */ SAFEARRAY * *Data) = 0;
        
        virtual void STDMETHODCALLTYPE OnResponseFinished( void) = 0;
        
        virtual void STDMETHODCALLTYPE OnError( 
            /* [in] */ long ErrorNumber,
            /* [in] */ BSTR ErrorDescription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWinHttpRequestEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWinHttpRequestEvents * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWinHttpRequestEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWinHttpRequestEvents * This);
        
        void ( STDMETHODCALLTYPE *OnResponseStart )( 
            IWinHttpRequestEvents * This,
            /* [in] */ long Status,
            /* [in] */ BSTR ContentType);
        
        void ( STDMETHODCALLTYPE *OnResponseDataAvailable )( 
            IWinHttpRequestEvents * This,
            /* [in] */ SAFEARRAY * *Data);
        
        void ( STDMETHODCALLTYPE *OnResponseFinished )( 
            IWinHttpRequestEvents * This);
        
        void ( STDMETHODCALLTYPE *OnError )( 
            IWinHttpRequestEvents * This,
            /* [in] */ long ErrorNumber,
            /* [in] */ BSTR ErrorDescription);
        
        END_INTERFACE
    } IWinHttpRequestEventsVtbl;

    interface IWinHttpRequestEvents
    {
        CONST_VTBL struct IWinHttpRequestEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWinHttpRequestEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWinHttpRequestEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWinHttpRequestEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWinHttpRequestEvents_OnResponseStart(This,Status,ContentType)	\
    (This)->lpVtbl -> OnResponseStart(This,Status,ContentType)

#define IWinHttpRequestEvents_OnResponseDataAvailable(This,Data)	\
    (This)->lpVtbl -> OnResponseDataAvailable(This,Data)

#define IWinHttpRequestEvents_OnResponseFinished(This)	\
    (This)->lpVtbl -> OnResponseFinished(This)

#define IWinHttpRequestEvents_OnError(This,ErrorNumber,ErrorDescription)	\
    (This)->lpVtbl -> OnError(This,ErrorNumber,ErrorDescription)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IWinHttpRequestEvents_OnResponseStart_Proxy( 
    IWinHttpRequestEvents * This,
    /* [in] */ long Status,
    /* [in] */ BSTR ContentType);


void __RPC_STUB IWinHttpRequestEvents_OnResponseStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWinHttpRequestEvents_OnResponseDataAvailable_Proxy( 
    IWinHttpRequestEvents * This,
    /* [in] */ SAFEARRAY * *Data);


void __RPC_STUB IWinHttpRequestEvents_OnResponseDataAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWinHttpRequestEvents_OnResponseFinished_Proxy( 
    IWinHttpRequestEvents * This);


void __RPC_STUB IWinHttpRequestEvents_OnResponseFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IWinHttpRequestEvents_OnError_Proxy( 
    IWinHttpRequestEvents * This,
    /* [in] */ long ErrorNumber,
    /* [in] */ BSTR ErrorDescription);


void __RPC_STUB IWinHttpRequestEvents_OnError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWinHttpRequestEvents_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_WinHttpRequest;

#ifdef __cplusplus

class DECLSPEC_UUID("2087c2f4-2cef-4953-a8ab-66779b670495")
WinHttpRequest;
#endif
#endif /* __WinHttp_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\inetsrv\inc\cierror.h ===
#ifndef _CIERROR_H_
#define _CIERROR_H_
#ifndef FACILITY_WINDOWS
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_WINDOWS                 0x8
#define FACILITY_NULL                    0x0
#define FACILITY_ITF                     0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_COFAIL           0x3
#define STATUS_SEVERITY_COERROR          0x2


//
// MessageId: NOT_AN_ERROR1
//
// MessageText:
//
//  NOTE:  This dummy error message is necessary to force MC to output
//         the above defines inside the FACILITY_WINDOWS guard instead
//         of leaving it empty.
//
#define NOT_AN_ERROR1                    ((HRESULT)0x00081600L)

#endif // FACILITY_WINDOWS
//
// Range 0x1600-0x1850 is reserved by Content Index.
//
//
// Codes 0x1600-0x164f are reserved for QUERY
//
//
// MessageId: QUERY_E_FAILED
//
// MessageText:
//
//  Call failed for unknown reason.
//
#define QUERY_E_FAILED                   ((HRESULT)0x80041600L)

//
// MessageId: QUERY_E_INVALIDQUERY
//
// MessageText:
//
//  Invalid parameter.
//
#define QUERY_E_INVALIDQUERY             ((HRESULT)0x80041601L)

//
// MessageId: QUERY_E_INVALIDRESTRICTION
//
// MessageText:
//
//  The query restriction could not be parsed.
//
#define QUERY_E_INVALIDRESTRICTION       ((HRESULT)0x80041602L)

//
// MessageId: QUERY_E_INVALIDSORT
//
// MessageText:
//
//  An invalid sort order was requested.
//
#define QUERY_E_INVALIDSORT              ((HRESULT)0x80041603L)

//
// MessageId: QUERY_E_INVALIDCATEGORIZE
//
// MessageText:
//
//  An invalid categorization order was requested.
//
#define QUERY_E_INVALIDCATEGORIZE        ((HRESULT)0x80041604L)

//
// MessageId: QUERY_E_ALLNOISE
//
// MessageText:
//
//  The query contained only ignored words.
//
#define QUERY_E_ALLNOISE                 ((HRESULT)0x80041605L)

//
// MessageId: QUERY_E_TOOCOMPLEX
//
// MessageText:
//
//  The query was too complex to be executed.
//
#define QUERY_E_TOOCOMPLEX               ((HRESULT)0x80041606L)

//
// MessageId: QUERY_E_TIMEDOUT
//
// MessageText:
//
//  The query exceeded its execution time limit.
//
#define QUERY_E_TIMEDOUT                 ((HRESULT)0x80041607L)

//
// MessageId: QUERY_E_DUPLICATE_OUTPUT_COLUMN
//
// MessageText:
//
//  One or more columns in the output column list is a duplicate.
//
#define QUERY_E_DUPLICATE_OUTPUT_COLUMN  ((HRESULT)0x80041608L)

//
// MessageId: QUERY_E_INVALID_OUTPUT_COLUMN
//
// MessageText:
//
//  One or more columns in the output column list is not valid.
//
#define QUERY_E_INVALID_OUTPUT_COLUMN    ((HRESULT)0x80041609L)

//
// MessageId: QUERY_E_INVALID_DIRECTORY
//
// MessageText:
//
//  Invalid directory name.
//
#define QUERY_E_INVALID_DIRECTORY        ((HRESULT)0x8004160AL)

//
// MessageId: QUERY_E_DIR_ON_REMOVABLE_DRIVE
//
// MessageText:
//
//  Specified directory is on a removable medium.
//
#define QUERY_E_DIR_ON_REMOVABLE_DRIVE   ((HRESULT)0x8004160BL)

//
// MessageId: QUERY_S_NO_QUERY
//
// MessageText:
//
//  The catalog is in a state where indexing continues, but queries are not allowed.
//
#define QUERY_S_NO_QUERY                 ((HRESULT)0x8004160CL)

//
// Codes 0x1650-0x167f are reserved for qutil error codes
//
//
// MessageId: QPLIST_E_CANT_OPEN_FILE
//
// MessageText:
//
//  Can not open file.
//
#define QPLIST_E_CANT_OPEN_FILE          ((HRESULT)0x80041651L)

//
// MessageId: QPLIST_E_READ_ERROR
//
// MessageText:
//
//  Read error in file.
//
#define QPLIST_E_READ_ERROR              ((HRESULT)0x80041652L)

//
// MessageId: QPLIST_E_EXPECTING_NAME
//
// MessageText:
//
//  Expecting property name.
//
#define QPLIST_E_EXPECTING_NAME          ((HRESULT)0x80041653L)

//
// MessageId: QPLIST_E_EXPECTING_TYPE
//
// MessageText:
//
//  Expecting type specifier.
//
#define QPLIST_E_EXPECTING_TYPE          ((HRESULT)0x80041654L)

//
// MessageId: QPLIST_E_UNRECOGNIZED_TYPE
//
// MessageText:
//
//  Unrecognized type.
//
#define QPLIST_E_UNRECOGNIZED_TYPE       ((HRESULT)0x80041655L)

//
// MessageId: QPLIST_E_EXPECTING_INTEGER
//
// MessageText:
//
//  Expecting integer.
//
#define QPLIST_E_EXPECTING_INTEGER       ((HRESULT)0x80041656L)

//
// MessageId: QPLIST_E_EXPECTING_CLOSE_PAREN
//
// MessageText:
//
//  Expecting closing parenthesis.
//
#define QPLIST_E_EXPECTING_CLOSE_PAREN   ((HRESULT)0x80041657L)

//
// MessageId: QPLIST_E_EXPECTING_GUID
//
// MessageText:
//
//  Expecting GUID.
//
#define QPLIST_E_EXPECTING_GUID          ((HRESULT)0x80041658L)

//
// MessageId: QPLIST_E_BAD_GUID
//
// MessageText:
//
//  Invalid guid.
//
#define QPLIST_E_BAD_GUID                ((HRESULT)0x80041659L)

//
// MessageId: QPLIST_E_EXPECTING_PROP_SPEC
//
// MessageText:
//
//  Expecting property specifier.
//
#define QPLIST_E_EXPECTING_PROP_SPEC     ((HRESULT)0x8004165AL)

//
// MessageId: QPLIST_E_CANT_SET_PROPERTY
//
// MessageText:
//
//  Failed to set property name.
//
#define QPLIST_E_CANT_SET_PROPERTY       ((HRESULT)0x8004165BL)

//
// MessageId: QPLIST_E_DUPLICATE
//
// MessageText:
//
//  Duplicate property name.
//
#define QPLIST_E_DUPLICATE               ((HRESULT)0x8004165CL)

//
// MessageId: QPLIST_E_VECTORBYREF_USED_ALONE
//
// MessageText:
//
//  DBTYPE_VECTOR or DBTYPE_BYREF used alone.
//
#define QPLIST_E_VECTORBYREF_USED_ALONE  ((HRESULT)0x8004165DL)

//
// MessageId: QPLIST_E_BYREF_USED_WITHOUT_PTRTYPE
//
// MessageText:
//
//  DBTYPE_BYREF must be used with DBTYPE_STR, DBTYPE_WSTR, DBTYPE_GUID
//   or DBTYPE_UI1 types.
//
#define QPLIST_E_BYREF_USED_WITHOUT_PTRTYPE ((HRESULT)0x8004165EL)

//
// MessageId: QPARSE_E_UNEXPECTED_NOT
//
// MessageText:
//
//  Unexpected NOT operator.
//
#define QPARSE_E_UNEXPECTED_NOT          ((HRESULT)0x80041660L)

//
// MessageId: QPARSE_E_EXPECTING_INTEGER
//
// MessageText:
//
//  Expecting integer.
//
#define QPARSE_E_EXPECTING_INTEGER       ((HRESULT)0x80041661L)

//
// MessageId: QPARSE_E_EXPECTING_REAL
//
// MessageText:
//
//  Expecting real number.
//
#define QPARSE_E_EXPECTING_REAL          ((HRESULT)0x80041662L)

//
// MessageId: QPARSE_E_EXPECTING_DATE
//
// MessageText:
//
//  Expecting date.
//
#define QPARSE_E_EXPECTING_DATE          ((HRESULT)0x80041663L)

//
// MessageId: QPARSE_E_EXPECTING_CURRENCY
//
// MessageText:
//
//  Expecting currency.
//
#define QPARSE_E_EXPECTING_CURRENCY      ((HRESULT)0x80041664L)

//
// MessageId: QPARSE_E_EXPECTING_GUID
//
// MessageText:
//
//  Expecting GUID.
//
#define QPARSE_E_EXPECTING_GUID          ((HRESULT)0x80041665L)

//
// MessageId: QPARSE_E_EXPECTING_BRACE
//
// MessageText:
//
//  Expecting closing square bracket ']'.
//
#define QPARSE_E_EXPECTING_BRACE         ((HRESULT)0x80041666L)

//
// MessageId: QPARSE_E_EXPECTING_PAREN
//
// MessageText:
//
//  Expecting closing parenthesis ')'.
//
#define QPARSE_E_EXPECTING_PAREN         ((HRESULT)0x80041667L)

//
// MessageId: QPARSE_E_EXPECTING_PROPERTY
//
// MessageText:
//
//  Expecting property name.
//
#define QPARSE_E_EXPECTING_PROPERTY      ((HRESULT)0x80041668L)

//
// MessageId: QPARSE_E_NOT_YET_IMPLEMENTED
//
// MessageText:
//
//  Not yet implemented.
//
#define QPARSE_E_NOT_YET_IMPLEMENTED     ((HRESULT)0x80041669L)

//
// MessageId: QPARSE_E_EXPECTING_PHRASE
//
// MessageText:
//
//  Expecting phrase.
//
#define QPARSE_E_EXPECTING_PHRASE        ((HRESULT)0x8004166AL)

//
// MessageId: QPARSE_E_UNSUPPORTED_PROPERTY_TYPE
//
// MessageText:
//
//  Unsupported property type.
//
#define QPARSE_E_UNSUPPORTED_PROPERTY_TYPE ((HRESULT)0x8004166BL)

//
// MessageId: QPARSE_E_EXPECTING_REGEX
//
// MessageText:
//
//  Expecting regular expression.
//
#define QPARSE_E_EXPECTING_REGEX         ((HRESULT)0x8004166CL)

//
// MessageId: QPARSE_E_EXPECTING_REGEX_PROPERTY
//
// MessageText:
//
//  Regular expressions require a property of type string.
//
#define QPARSE_E_EXPECTING_REGEX_PROPERTY ((HRESULT)0x8004166DL)

//
// MessageId: QPARSE_E_INVALID_LITERAL
//
// MessageText:
//
//  Invalid literal.
//
#define QPARSE_E_INVALID_LITERAL         ((HRESULT)0x8004166EL)

//
// MessageId: QPARSE_E_NO_SUCH_PROPERTY
//
// MessageText:
//
//  No such property.
//
#define QPARSE_E_NO_SUCH_PROPERTY        ((HRESULT)0x8004166FL)

//
// MessageId: QPARSE_E_EXPECTING_EOS
//
// MessageText:
//
//  Expecting end of string.
//
#define QPARSE_E_EXPECTING_EOS           ((HRESULT)0x80041670L)

//
// MessageId: QPARSE_E_EXPECTING_COMMA
//
// MessageText:
//
//  Expecting comma.
//
#define QPARSE_E_EXPECTING_COMMA         ((HRESULT)0x80041671L)

//
// MessageId: QPARSE_E_UNEXPECTED_EOS
//
// MessageText:
//
//  Unexpected end of string.
//
#define QPARSE_E_UNEXPECTED_EOS          ((HRESULT)0x80041672L)

//
// MessageId: QPARSE_E_WEIGHT_OUT_OF_RANGE
//
// MessageText:
//
//  Weight must be between 0 and 1000 in short form queries and between 0.0 and 1.0 in long form queries.
//
#define QPARSE_E_WEIGHT_OUT_OF_RANGE     ((HRESULT)0x80041673L)

//
// MessageId: QPARSE_E_NO_SUCH_SORT_PROPERTY
//
// MessageText:
//
//  An invalid property was found in the sort specification.
//
#define QPARSE_E_NO_SUCH_SORT_PROPERTY   ((HRESULT)0x80041674L)

//
// MessageId: QPARSE_E_INVALID_SORT_ORDER
//
// MessageText:
//
//  An invalid sort order was specified.  Only [a] and [d] are supported.
//
#define QPARSE_E_INVALID_SORT_ORDER      ((HRESULT)0x80041675L)

//
// MessageId: QUTIL_E_CANT_CONVERT_VROOT
//
// MessageText:
//
//  Couldn't convert a virtual path to a physical path.
//
#define QUTIL_E_CANT_CONVERT_VROOT       ((HRESULT)0x80041676L)

//
// MessageId: QPARSE_E_INVALID_GROUPING
//
// MessageText:
//
//  An unsupported grouping type was specified.
//
#define QPARSE_E_INVALID_GROUPING        ((HRESULT)0x80041677L)

//
// MessageId: QUTIL_E_INVALID_CODEPAGE
//
// MessageText:
//
//  Invalid CiCodepage was specified.
//
#define QUTIL_E_INVALID_CODEPAGE         ((HRESULT)0xC0041678L)

//
// MessageId: QPLIST_S_DUPLICATE
//
// MessageText:
//
//  Exact duplicate property defined.
//
#define QPLIST_S_DUPLICATE               ((HRESULT)0x00041679L)

//
// MessageId: QPARSE_E_INVALID_QUERY
//
// MessageText:
//
//  Invalid query.
//
#define QPARSE_E_INVALID_QUERY           ((HRESULT)0x8004167AL)

//
// MessageId: QPARSE_E_INVALID_RANKMETHOD
//
// MessageText:
//
//  Invalid rank method.
//
#define QPARSE_E_INVALID_RANKMETHOD      ((HRESULT)0x8004167BL)

//
// 0x1680 - 0x169F are Filter daemon error codes
//
//
// MessageId: FDAEMON_W_WORDLISTFULL
//
// MessageText:
//
//  Wordlist has reached maximum size.  Additional documents should not be filtered.
//
#define FDAEMON_W_WORDLISTFULL           ((HRESULT)0x00041680L)

//
// MessageId: FDAEMON_E_LOWRESOURCE
//
// MessageText:
//
//  The system is running out of one of more resources needed for filtering, usually memory.
//
#define FDAEMON_E_LOWRESOURCE            ((HRESULT)0x80041681L)

//
// MessageId: FDAEMON_E_FATALERROR
//
// MessageText:
//
//  A critical error occurred during document filtering.  Consult system administrator.
//
#define FDAEMON_E_FATALERROR             ((HRESULT)0x80041682L)

//
// MessageId: FDAEMON_E_PARTITIONDELETED
//
// MessageText:
//
//  Documents not stored in content index because partition has been deleted.
//
#define FDAEMON_E_PARTITIONDELETED       ((HRESULT)0x80041683L)

//
// MessageId: FDAEMON_E_CHANGEUPDATEFAILED
//
// MessageText:
//
//  Documents not stored in content index because update of changelist failed.
//
#define FDAEMON_E_CHANGEUPDATEFAILED     ((HRESULT)0x80041684L)

//
// MessageId: FDAEMON_W_EMPTYWORDLIST
//
// MessageText:
//
//  Final wordlist was empty.
//
#define FDAEMON_W_EMPTYWORDLIST          ((HRESULT)0x00041685L)

//
// MessageId: FDAEMON_E_WORDLISTCOMMITFAILED
//
// MessageText:
//
//  Commit of wordlist failed.  Data not available for query.
//
#define FDAEMON_E_WORDLISTCOMMITFAILED   ((HRESULT)0x80041686L)

//
// MessageId: FDAEMON_E_NOWORDLIST
//
// MessageText:
//
//  No wordlist is being constructed.  May happen after fatal filter error.
//
#define FDAEMON_E_NOWORDLIST             ((HRESULT)0x80041687L)

//
// MessageId: FDAEMON_E_TOOMANYFILTEREDBLOCKS
//
// MessageText:
//
//  During document filtering the limit on buffers has been exceeded.
//
#define FDAEMON_E_TOOMANYFILTEREDBLOCKS  ((HRESULT)0x80041688L)

//
// ISearch error codes
//
//
// MessageId: SEARCH_S_NOMOREHITS
//
// MessageText:
//
//  End of hits has been reached.
//
#define SEARCH_S_NOMOREHITS              ((HRESULT)0x000416A0L)

//
// MessageId: SEARCH_E_NOMONIKER
//
// MessageText:
//
//  Retrival of hits as monikers is not supported (by filter passed into Init).
//
#define SEARCH_E_NOMONIKER               ((HRESULT)0x800416A1L)

//
// MessageId: SEARCH_E_NOREGION
//
// MessageText:
//
//  Retrival of hits as filter regions is not supported (by filter passed into Init).
//
#define SEARCH_E_NOREGION                ((HRESULT)0x800416A2L)

//
// Filter error codes
//
//
// MessageId: FILTER_E_TOO_BIG
//
// MessageText:
//
//  File is too large to filter.
//
#define FILTER_E_TOO_BIG                 ((HRESULT)0x80041730L)

//
// MessageId: FILTER_S_PARTIAL_CONTENTSCAN_IMMEDIATE
//
// MessageText:
//
//  A partial content scan of the disk needs to be scheduled for immediate execution.
//
#define FILTER_S_PARTIAL_CONTENTSCAN_IMMEDIATE ((HRESULT)0x00041731L)

//
// MessageId: FILTER_S_FULL_CONTENTSCAN_IMMEDIATE
//
// MessageText:
//
//  A full content scan of the disk needs to be scheduled for immediate execution.
//
#define FILTER_S_FULL_CONTENTSCAN_IMMEDIATE ((HRESULT)0x00041732L)

//
// MessageId: FILTER_S_CONTENTSCAN_DELAYED
//
// MessageText:
//
//  A content scan of the disk needs to be scheduled for execution later.
//
#define FILTER_S_CONTENTSCAN_DELAYED     ((HRESULT)0x00041733L)

//
// MessageId: FILTER_E_CONTENTINDEXCORRUPT
//
// MessageText:
//
//  The content index is corrupt. A content scan will to be scheduled after chkdsk or autochk is run.
//
#define FILTER_E_CONTENTINDEXCORRUPT     ((HRESULT)0xC0041734L)

//
// MessageId: FILTER_S_DISK_FULL
//
// MessageText:
//
//  The disk is getting full.
//
#define FILTER_S_DISK_FULL               ((HRESULT)0x00041735L)

//
// MessageId: FILTER_E_ALREADY_OPEN
//
// MessageText:
//
//  A file is already open. Cannot open another one while a file is open.
//
#define FILTER_E_ALREADY_OPEN            ((HRESULT)0x80041736L)

//
// MessageId: FILTER_E_UNREACHABLE
//
// MessageText:
//
//  The file is not reachable.
//
#define FILTER_E_UNREACHABLE             ((HRESULT)0x80041737L)

//
// MessageId: FILTER_E_IN_USE
//
// MessageText:
//
//  The document is in use by another process.
//
#define FILTER_E_IN_USE                  ((HRESULT)0x80041738L)

//
// MessageId: FILTER_E_NOT_OPEN
//
// MessageText:
//
//  The document is not opened.
//
#define FILTER_E_NOT_OPEN                ((HRESULT)0x80041739L)

//
// MessageId: FILTER_S_NO_PROPSETS
//
// MessageText:
//
//  The document has no property sets.
//
#define FILTER_S_NO_PROPSETS             ((HRESULT)0x0004173AL)

//
// MessageId: FILTER_E_NO_SUCH_PROPERTY
//
// MessageText:
//
//  There is no property with the given GUID.
//
#define FILTER_E_NO_SUCH_PROPERTY        ((HRESULT)0x8004173BL)

//
// MessageId: FILTER_S_NO_SECURITY_DESCRIPTOR
//
// MessageText:
//
//  The document has no security descriptor.
//
#define FILTER_S_NO_SECURITY_DESCRIPTOR  ((HRESULT)0x0004173CL)

//
// MessageId: FILTER_E_OFFLINE
//
// MessageText:
//
//  The document is offline.
//
#define FILTER_E_OFFLINE                 ((HRESULT)0x8004173DL)

//
// MessageId: FILTER_E_PARTIALLY_FILTERED
//
// MessageText:
//
//  The document was too large to filter in its entirety.  Portions of the document were not emitted.
//
#define FILTER_E_PARTIALLY_FILTERED      ((HRESULT)0x8004173EL)

//
// Word breaker error codes
//
//
// MessageId: WBREAK_E_END_OF_TEXT
//
// MessageText:
//
//  End of text reached in text source.
//
#define WBREAK_E_END_OF_TEXT             ((HRESULT)0x80041780L)

//
// MessageId: LANGUAGE_S_LARGE_WORD
//
// MessageText:
//
//  Word larger than maximum length.  May be truncated by word sink.
//
#define LANGUAGE_S_LARGE_WORD            ((HRESULT)0x00041781L)

//
// MessageId: WBREAK_E_QUERY_ONLY
//
// MessageText:
//
//  Feature only available in query mode.
//
#define WBREAK_E_QUERY_ONLY              ((HRESULT)0x80041782L)

//
// MessageId: WBREAK_E_BUFFER_TOO_SMALL
//
// MessageText:
//
//  Buffer too small to hold composed phrase.
//
#define WBREAK_E_BUFFER_TOO_SMALL        ((HRESULT)0x80041783L)

//
// MessageId: LANGUAGE_E_DATABASE_NOT_FOUND
//
// MessageText:
//
//  Langauge database/cache file could not be found.
//
#define LANGUAGE_E_DATABASE_NOT_FOUND    ((HRESULT)0x80041784L)

//
// MessageId: WBREAK_E_INIT_FAILED
//
// MessageText:
//
//  Initialization of word breaker failed.
//
#define WBREAK_E_INIT_FAILED             ((HRESULT)0x80041785L)

//
// MessageId: PSINK_E_QUERY_ONLY
//
// MessageText:
//
//  Feature only available in query mode.
//
#define PSINK_E_QUERY_ONLY               ((HRESULT)0x80041790L)

//
// MessageId: PSINK_E_INDEX_ONLY
//
// MessageText:
//
//  Feature only available in index mode.
//
#define PSINK_E_INDEX_ONLY               ((HRESULT)0x80041791L)

//
// MessageId: PSINK_E_LARGE_ATTACHMENT
//
// MessageText:
//
//  Attachment type beyond valid range.
//
#define PSINK_E_LARGE_ATTACHMENT         ((HRESULT)0x80041792L)

//
// MessageId: PSINK_S_LARGE_WORD
//
// MessageText:
//
//  Word larger than maximum length.  May be truncated by phrase sink.
//
#define PSINK_S_LARGE_WORD               ((HRESULT)0x00041793L)

//
// Content Index Framework Error Codes
//
//
// MessageId: CI_CORRUPT_DATABASE
//
// MessageText:
//
//  The content index is corrupt.
//
#define CI_CORRUPT_DATABASE              ((HRESULT)0xC0041800L)

//
// MessageId: CI_CORRUPT_CATALOG
//
// MessageText:
//
//  The content index meta data is corrupt.
//
#define CI_CORRUPT_CATALOG               ((HRESULT)0xC0041801L)

//
// MessageId: CI_INVALID_PARTITION
//
// MessageText:
//
//  The content index partition is invalid.
//
#define CI_INVALID_PARTITION             ((HRESULT)0xC0041802L)

//
// MessageId: CI_INVALID_PRIORITY
//
// MessageText:
//
//  The priority is invalid.
//
#define CI_INVALID_PRIORITY              ((HRESULT)0xC0041803L)

//
// MessageId: CI_NO_STARTING_KEY
//
// MessageText:
//
//  There is no starting key.
//
#define CI_NO_STARTING_KEY               ((HRESULT)0xC0041804L)

//
// MessageId: CI_OUT_OF_INDEX_IDS
//
// MessageText:
//
//  The content index is out of index ids.
//
#define CI_OUT_OF_INDEX_IDS              ((HRESULT)0xC0041805L)

//
// MessageId: CI_NO_CATALOG
//
// MessageText:
//
//  There is no catalog.
//
#define CI_NO_CATALOG                    ((HRESULT)0xC0041806L)

//
// MessageId: CI_CORRUPT_FILTER_BUFFER
//
// MessageText:
//
//  The filter buffer is corrupt.
//
#define CI_CORRUPT_FILTER_BUFFER         ((HRESULT)0xC0041807L)

//
// MessageId: CI_INVALID_INDEX
//
// MessageText:
//
//  The index is invalid.
//
#define CI_INVALID_INDEX                 ((HRESULT)0xC0041808L)

//
// MessageId: CI_PROPSTORE_INCONSISTENCY
//
// MessageText:
//
//  Inconsistency in property store detected.
//
#define CI_PROPSTORE_INCONSISTENCY       ((HRESULT)0xC0041809L)

//
// MessageId: CI_E_ALREADY_INITIALIZED
//
// MessageText:
//
//  The object is already initialzed.
//
#define CI_E_ALREADY_INITIALIZED         ((HRESULT)0x8004180AL)

//
// MessageId: CI_E_NOT_INITIALIZED
//
// MessageText:
//
//  The object is not initialzed.
//
#define CI_E_NOT_INITIALIZED             ((HRESULT)0x8004180BL)

//
// MessageId: CI_E_BUFFERTOOSMALL
//
// MessageText:
//
//  The buffer is too small.
//
#define CI_E_BUFFERTOOSMALL              ((HRESULT)0x8004180CL)

//
// MessageId: CI_E_PROPERTY_NOT_CACHED
//
// MessageText:
//
//  The given property is not cached.
//
#define CI_E_PROPERTY_NOT_CACHED         ((HRESULT)0x8004180DL)

//
// MessageId: CI_S_WORKID_DELETED
//
// MessageText:
//
//  The workid is deleted.
//
#define CI_S_WORKID_DELETED              ((HRESULT)0x0004180EL)

//
// MessageId: CI_E_INVALID_STATE
//
// MessageText:
//
//  The object is not in a valid state.
//
#define CI_E_INVALID_STATE               ((HRESULT)0x8004180FL)

//
// MessageId: CI_E_FILTERING_DISABLED
//
// MessageText:
//
//  Filtering is disabled in this content index.
//
#define CI_E_FILTERING_DISABLED          ((HRESULT)0x80041810L)

//
// MessageId: CI_E_DISK_FULL
//
// MessageText:
//
//  The disk is full and the specified operation cannot be done.
//
#define CI_E_DISK_FULL                   ((HRESULT)0x80041811L)

//
// MessageId: CI_E_SHUTDOWN
//
// MessageText:
//
//  Content Index has been shutdown.
//
#define CI_E_SHUTDOWN                    ((HRESULT)0x80041812L)

//
// MessageId: CI_E_WORKID_NOTVALID
//
// MessageText:
//
//  The workid is not valid.
//
#define CI_E_WORKID_NOTVALID             ((HRESULT)0x80041813L)

//
// MessageId: CI_S_END_OF_ENUMERATION
//
// MessageText:
//
//  There are no more documents to enumerate.
//
#define CI_S_END_OF_ENUMERATION          ((HRESULT)0x00041814L)    

//
// MessageId: CI_E_NOT_FOUND
//
// MessageText:
//
//  The object was not found.
//
#define CI_E_NOT_FOUND                   ((HRESULT)0x80041815L)

//
// MessageId: CI_E_USE_DEFAULT_PID
//
// MessageText:
//
//  The passed-in property id is not supported.
//
#define CI_E_USE_DEFAULT_PID             ((HRESULT)0x80041816L)

//
// MessageId: CI_E_DUPLICATE_NOTIFICATION
//
// MessageText:
//
//  There were two notifications for the same workid.
//
#define CI_E_DUPLICATE_NOTIFICATION      ((HRESULT)0x80041817L)

//
// MessageId: CI_E_UPDATES_DISABLED
//
// MessageText:
//
//  A document update was rejected because updates were disabled.
//
#define CI_E_UPDATES_DISABLED            ((HRESULT)0x80041818L)

//
// MessageId: CI_E_INVALID_FLAGS_COMBINATION
//
// MessageText:
//
//  The combination of flags specified is invalid.
//
#define CI_E_INVALID_FLAGS_COMBINATION   ((HRESULT)0x80041819L)

//
// MessageId: CI_E_OUTOFSEQ_INCREMENT_DATA
//
// MessageText:
//
//  The incremental data given to Load is not valid. It may be out of sequence.
//
#define CI_E_OUTOFSEQ_INCREMENT_DATA     ((HRESULT)0x8004181AL)

//
// MessageId: CI_E_SHARING_VIOLATION
//
// MessageText:
//
//  A sharing or locking violation caused a failure.
//
#define CI_E_SHARING_VIOLATION           ((HRESULT)0x8004181BL)

//
// MessageId: CI_E_LOGON_FAILURE
//
// MessageText:
//
//  A logon permission violation caused a failure.
//
#define CI_E_LOGON_FAILURE               ((HRESULT)0x8004181CL)

//
// MessageId: CI_E_NO_CATALOG
//
// MessageText:
//
//  There is no catalog.
//
#define CI_E_NO_CATALOG                  ((HRESULT)0x8004181DL)

//
// MessageId: CI_E_STRANGE_PAGEORSECTOR_SIZE
//
// MessageText:
//
//  Page size is not an integral multiple of the sector size of the volume where index is located.
//
#define CI_E_STRANGE_PAGEORSECTOR_SIZE   ((HRESULT)0x8004181EL)

//
// MessageId: CI_E_TIMEOUT
//
// MessageText:
//
//  Service is too busy.
//
#define CI_E_TIMEOUT                     ((HRESULT)0x8004181FL)

//
// MessageId: CI_E_NOT_RUNNING
//
// MessageText:
//
//  Service is not running.
//
#define CI_E_NOT_RUNNING                 ((HRESULT)0x80041820L)

//
// MessageId: CI_INCORRECT_VERSION
//
// MessageText:
//
//  The content index data on disk is for the wrong version.
//
#define CI_INCORRECT_VERSION             ((HRESULT)0xC0041821L)

//
// MessageId: CI_E_ENUMERATION_STARTED
//
// MessageText:
//
//  Enumeration has already been started for this query.
//
#define CI_E_ENUMERATION_STARTED         ((HRESULT)0xC0041822L)

//
// MessageId: CI_E_PROPERTY_TOOLARGE
//
// MessageText:
//
//  The specified variable length property is too large for the property cache.
//
#define CI_E_PROPERTY_TOOLARGE           ((HRESULT)0xC0041823L)

//
// MessageId: CI_E_CLIENT_FILTER_ABORT
//
// MessageText:
//
//  Filtering of object was aborted by client.
//
#define CI_E_CLIENT_FILTER_ABORT         ((HRESULT)0xC0041824L)

//
// MessageId: CI_S_NO_DOCSTORE
//
// MessageText:
//
//  For administrative connections from client without association to a docstore.
//
#define CI_S_NO_DOCSTORE                 ((HRESULT)0x00041825L)

//
// MessageId: CI_S_CAT_STOPPED
//
// MessageText:
//
//  The catalog has been stopped.
//
#define CI_S_CAT_STOPPED                 ((HRESULT)0x00041826L)

//
// MessageId: CI_E_CARDINALITY_MISMATCH
//
// MessageText:
//
//  Mismatch in cardinality of machine(s)/catalog(s)/scope(s).
//
#define CI_E_CARDINALITY_MISMATCH        ((HRESULT)0x80041827L)

//
// MessageId: CI_E_CONFIG_DISK_FULL
//
// MessageText:
//
//  The disk has reached its configured space limit.
//
#define CI_E_CONFIG_DISK_FULL            ((HRESULT)0x80041828L)

#endif // _CIERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\inetsrv\inc\ciodmguid.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for ciodm.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAdminIndexServer,0x3BC4F3A0,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(IID, IID_ICatAdm,0x3BC4F3A2,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(IID, IID_IScopeAdm,0x3BC4F3A4,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(IID, LIBID_CIODMLib,0x3BC4F393,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(CLSID, CLSID_AdminIndexServer,0x3BC4F3A1,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(CLSID, CLSID_CatAdm,0x3BC4F3A3,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(CLSID, CLSID_ScopeAdm,0x3BC4F3A7,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for ciodm.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAdminIndexServer,0x3BC4F3A0,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(IID, IID_ICatAdm,0x3BC4F3A2,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(IID, IID_IScopeAdm,0x3BC4F3A4,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(IID, LIBID_CIODMLib,0x3BC4F393,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(CLSID, CLSID_AdminIndexServer,0x3BC4F3A1,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(CLSID, CLSID_CatAdm,0x3BC4F3A3,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);


MIDL_DEFINE_GUID(CLSID, CLSID_ScopeAdm,0x3BC4F3A7,0x652A,0x11D1,0xB4,0xD4,0x00,0xC0,0x4F,0xC2,0xDB,0x8D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\d3d8rgbrast.h ===
// Copyright (C) Microsoft Corporation.  All Rights Reserved.

#ifndef __D3D8RGBRAST_H__
#define __D3D8RGBRAST_H__

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

extern void* D3D8RGBRasterizer;

#ifdef __cplusplus
}
#endif //__cplusplus

#endif //__D3D8RGBRAST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\d3prm.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3drm.h
 *  Content:	Direct3DRM include file
 *@@BEGIN_MSINTERNAL
 * 
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27/02/96   stevela Moved from RL to D3DRM.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __D3DRM_H__
#define __D3DRM_H__

#include "ddraw.h"

#ifdef __cplusplus
struct IDirect3DRM;
#endif

typedef struct IDirect3DRM *LPDIRECT3DRM;

//@@BEGIN_MSINTERNAL
#ifdef WINNT
#include "d3prmobj.h"
#else 
#include "d3drmobj.h"
#endif
#if 0
//@@END_MSINTERNAL
#include "d3drmobj.h"
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL

#ifdef __cplusplus
extern "C" {
#endif

//@@BEGIN_MSINTERNAL
typedef void (CDECL *D3DRMERRORHANDLER)(HRESULT error, void *arg);
#ifdef BUILD_RLAPI
typedef D3DRMERRORHANDLER RLErrorHandler;
#endif
//@@END_MSINTERNAL

DEFINE_GUID(IID_IDirect3DRM,	0x2bc49361, 0x8327, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRM2,	0x4516ecc8, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRM3,   0x4516ec83, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
WIN_TYPES(IDirect3DRM, DIRECT3DRM);
WIN_TYPES(IDirect3DRM2, DIRECT3DRM2);
WIN_TYPES(IDirect3DRM3, DIRECT3DRM3);

/*
 * Direct3DRM Object Class (for CoCreateInstance())
 */
DEFINE_GUID(CLSID_CDirect3DRM,  0x4516ec41, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);

//@@BEGIN_MSINTERNAL
/* Set the Reality Lab memory allocators */
STDAPI IDirect3DRMSetAllocator(D3DRMMALLOCFUNCTION, D3DRMREALLOCFUNCTION, D3DRMFREEFUNCTION);
STDAPI IDirect3DRMGetAllocator(LPD3DRMMALLOCFUNCTION, LPD3DRMREALLOCFUNCTION, LPD3DRMFREEFUNCTION);
//@@END_MSINTERNAL

/* Create a Direct3DRM API */
STDAPI Direct3DRMCreate(LPDIRECT3DRM FAR *lplpDirect3DRM);

#undef INTERFACE
#define INTERFACE IDirect3DRM

DECLARE_INTERFACE_(IDirect3DRM, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD(CreateObject)
	(THIS_ REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD(CreateFrame)	(THIS_ LPDIRECT3DRMFRAME, LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(CreateMesh)	(THIS_ LPDIRECT3DRMMESH *) PURE;
    STDMETHOD(CreateMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER *) PURE;
    STDMETHOD(CreateFace)	(THIS_ LPDIRECT3DRMFACE *) PURE;
    STDMETHOD(CreateAnimation)	(THIS_ LPDIRECT3DRMANIMATION *) PURE;
    STDMETHOD(CreateAnimationSet)(THIS_ LPDIRECT3DRMANIMATIONSET *) PURE;
    STDMETHOD(CreateTexture)	(THIS_ LPD3DRMIMAGE, LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(CreateLight)	(THIS_ D3DRMLIGHTTYPE, D3DCOLOR, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateLightRGB)
	(THIS_ D3DRMLIGHTTYPE, D3DVALUE, D3DVALUE, D3DVALUE, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateMaterial)	(THIS_ D3DVALUE, LPDIRECT3DRMMATERIAL *) PURE;
    STDMETHOD(CreateDevice)	(THIS_ DWORD, DWORD, LPDIRECT3DRMDEVICE *) PURE;

    /* Create a Windows Device using DirectDraw surfaces */
    STDMETHOD(CreateDeviceFromSurface)
    (	THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD,
	LPDIRECTDRAWSURFACE lpDDSBack, LPDIRECT3DRMDEVICE *
    ) PURE;

    /* Create a Windows Device using D3D objects */
    STDMETHOD(CreateDeviceFromD3D)
    (	THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev,
	LPDIRECT3DRMDEVICE *
    ) PURE;

    STDMETHOD(CreateDeviceFromClipper)
    (	THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID,
	int width, int height, LPDIRECT3DRMDEVICE *) PURE;

    STDMETHOD(CreateTextureFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS, LPDIRECT3DRMTEXTURE *) PURE;
   
    STDMETHOD(CreateShadow)
    (	THIS_ LPDIRECT3DRMVISUAL, LPDIRECT3DRMLIGHT,
	D3DVALUE px, D3DVALUE py, D3DVALUE pz,
	D3DVALUE nx, D3DVALUE ny, D3DVALUE nz,
	LPDIRECT3DRMVISUAL *
    ) PURE;
    STDMETHOD(CreateViewport)
    (	THIS_ LPDIRECT3DRMDEVICE, LPDIRECT3DRMFRAME, DWORD, DWORD,
	DWORD, DWORD, LPDIRECT3DRMVIEWPORT *
    ) PURE;
    STDMETHOD(CreateWrap)
    (	THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME,
	D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
	D3DVALUE ou, D3DVALUE ov,
	D3DVALUE su, D3DVALUE sv,
	LPDIRECT3DRMWRAP *
    ) PURE;
    STDMETHOD(CreateUserVisual) (THIS_ D3DRMUSERVISUALCALLBACK, LPVOID lPArg, LPDIRECT3DRMUSERVISUAL *) PURE;
    STDMETHOD(LoadTexture)	(THIS_ const char *, LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(LoadTextureFromResource)	(THIS_ HRSRC rs, LPDIRECT3DRMTEXTURE *) PURE;
   
    STDMETHOD(SetSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(AddSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(GetSearchPath)	(THIS_ DWORD *size_return, LPSTR path_return) PURE;
    STDMETHOD(SetDefaultTextureColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetDefaultTextureShades)(THIS_ DWORD) PURE;
   
    STDMETHOD(GetDevices)	(THIS_ LPDIRECT3DRMDEVICEARRAY *) PURE;
    STDMETHOD(GetNamedObject)	(THIS_ const char *, LPDIRECT3DRMOBJECT *) PURE;
   
    STDMETHOD(EnumerateObjects)	(THIS_ D3DRMOBJECTCALLBACK, LPVOID) PURE;
   
    STDMETHOD(Load)		
    (   THIS_ LPVOID, LPVOID, LPIID *, DWORD, D3DRMLOADOPTIONS,
    	D3DRMLOADCALLBACK, LPVOID, D3DRMLOADTEXTURECALLBACK, LPVOID,
	LPDIRECT3DRMFRAME
    ) PURE;
    STDMETHOD(Tick)		(THIS_ D3DVALUE) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRM2

DECLARE_INTERFACE_(IDirect3DRM2, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD(CreateObject)
	(THIS_ REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD(CreateFrame)	(THIS_ LPDIRECT3DRMFRAME, LPDIRECT3DRMFRAME2 *) PURE;
    STDMETHOD(CreateMesh)	(THIS_ LPDIRECT3DRMMESH *) PURE;
    STDMETHOD(CreateMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER2 *) PURE;
    STDMETHOD(CreateFace)	(THIS_ LPDIRECT3DRMFACE *) PURE;
    STDMETHOD(CreateAnimation)	(THIS_ LPDIRECT3DRMANIMATION *) PURE;
    STDMETHOD(CreateAnimationSet)(THIS_ LPDIRECT3DRMANIMATIONSET *) PURE;
    STDMETHOD(CreateTexture)	(THIS_ LPD3DRMIMAGE, LPDIRECT3DRMTEXTURE2 *) PURE;
    STDMETHOD(CreateLight)	(THIS_ D3DRMLIGHTTYPE, D3DCOLOR, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateLightRGB)
	(THIS_ D3DRMLIGHTTYPE, D3DVALUE, D3DVALUE, D3DVALUE, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateMaterial)	(THIS_ D3DVALUE, LPDIRECT3DRMMATERIAL *) PURE;
    STDMETHOD(CreateDevice)	(THIS_ DWORD, DWORD, LPDIRECT3DRMDEVICE2 *) PURE;

    /* Create a Windows Device using DirectDraw surfaces */
    STDMETHOD(CreateDeviceFromSurface)
    (	THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD,
	LPDIRECTDRAWSURFACE lpDDSBack, LPDIRECT3DRMDEVICE2 *
    ) PURE;

    /* Create a Windows Device using D3D objects */
    STDMETHOD(CreateDeviceFromD3D)
    (	THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev,
	LPDIRECT3DRMDEVICE2 *
    ) PURE;

    STDMETHOD(CreateDeviceFromClipper)
    (	THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID,
	int width, int height, LPDIRECT3DRMDEVICE2 *) PURE;

    STDMETHOD(CreateTextureFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS, LPDIRECT3DRMTEXTURE2 *) PURE;
   
    STDMETHOD(CreateShadow)
    (	THIS_ LPDIRECT3DRMVISUAL, LPDIRECT3DRMLIGHT,
	D3DVALUE px, D3DVALUE py, D3DVALUE pz,
	D3DVALUE nx, D3DVALUE ny, D3DVALUE nz,
	LPDIRECT3DRMVISUAL *
    ) PURE;
    STDMETHOD(CreateViewport)
    (	THIS_ LPDIRECT3DRMDEVICE, LPDIRECT3DRMFRAME, DWORD, DWORD,
	DWORD, DWORD, LPDIRECT3DRMVIEWPORT *
    ) PURE;
    STDMETHOD(CreateWrap)
    (	THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME,
	D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
	D3DVALUE ou, D3DVALUE ov,
	D3DVALUE su, D3DVALUE sv,
	LPDIRECT3DRMWRAP *
    ) PURE;
    STDMETHOD(CreateUserVisual) (THIS_ D3DRMUSERVISUALCALLBACK, LPVOID lPArg, LPDIRECT3DRMUSERVISUAL *) PURE;
    STDMETHOD(LoadTexture)	(THIS_ const char *, LPDIRECT3DRMTEXTURE2 *) PURE;
    STDMETHOD(LoadTextureFromResource)	(THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType, LPDIRECT3DRMTEXTURE2 *) PURE;
   
    STDMETHOD(SetSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(AddSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(GetSearchPath)	(THIS_ DWORD *size_return, LPSTR path_return) PURE;
    STDMETHOD(SetDefaultTextureColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetDefaultTextureShades)(THIS_ DWORD) PURE;
   
    STDMETHOD(GetDevices)	(THIS_ LPDIRECT3DRMDEVICEARRAY *) PURE;
    STDMETHOD(GetNamedObject)	(THIS_ const char *, LPDIRECT3DRMOBJECT *) PURE;
   
    STDMETHOD(EnumerateObjects)	(THIS_ D3DRMOBJECTCALLBACK, LPVOID) PURE;
   
    STDMETHOD(Load)		
    (   THIS_ LPVOID, LPVOID, LPIID *, DWORD, D3DRMLOADOPTIONS,
    	D3DRMLOADCALLBACK, LPVOID, D3DRMLOADTEXTURECALLBACK, LPVOID,
	LPDIRECT3DRMFRAME
    ) PURE;
    STDMETHOD(Tick)		(THIS_ D3DVALUE) PURE;

    STDMETHOD(CreateProgressiveMesh)(THIS_ LPDIRECT3DRMPROGRESSIVEMESH *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRM3

DECLARE_INTERFACE_(IDirect3DRM3, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD(CreateObject)
	(THIS_ REFCLSID rclsid, LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD(CreateFrame)	(THIS_ LPDIRECT3DRMFRAME3, LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD(CreateMesh)	(THIS_ LPDIRECT3DRMMESH *) PURE;
    STDMETHOD(CreateMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER3 *) PURE;
    STDMETHOD(CreateFace)	(THIS_ LPDIRECT3DRMFACE2 *) PURE;
    STDMETHOD(CreateAnimation)	(THIS_ LPDIRECT3DRMANIMATION2 *) PURE;
    STDMETHOD(CreateAnimationSet)(THIS_ LPDIRECT3DRMANIMATIONSET2 *) PURE;
    STDMETHOD(CreateTexture)	(THIS_ LPD3DRMIMAGE, LPDIRECT3DRMTEXTURE3 *) PURE;
    STDMETHOD(CreateLight)	(THIS_ D3DRMLIGHTTYPE, D3DCOLOR, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateLightRGB)
	(THIS_ D3DRMLIGHTTYPE, D3DVALUE, D3DVALUE, D3DVALUE, LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(CreateMaterial)	(THIS_ D3DVALUE, LPDIRECT3DRMMATERIAL2 *) PURE;
    STDMETHOD(CreateDevice)	(THIS_ DWORD, DWORD, LPDIRECT3DRMDEVICE3 *) PURE;

    /* Create a Windows Device using DirectDraw surfaces */
    STDMETHOD(CreateDeviceFromSurface)
    (	THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD,
	LPDIRECTDRAWSURFACE lpDDSBack, DWORD dwFlags, LPDIRECT3DRMDEVICE3 *
    ) PURE;

    /* Create a Windows Device using D3D objects */
    STDMETHOD(CreateDeviceFromD3D)
    (	THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev,
	LPDIRECT3DRMDEVICE3 *
    ) PURE;

    STDMETHOD(CreateDeviceFromClipper)
    (	THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID,
	int width, int height, LPDIRECT3DRMDEVICE3 *) PURE;

    STDMETHOD(CreateTextureFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS, LPDIRECT3DRMTEXTURE3 *) PURE;
   
    STDMETHOD(CreateShadow)
    (	THIS_ LPUNKNOWN, LPDIRECT3DRMLIGHT,
	D3DVALUE px, D3DVALUE py, D3DVALUE pz,
	D3DVALUE nx, D3DVALUE ny, D3DVALUE nz,
	LPDIRECT3DRMSHADOW2 *
    ) PURE;
    STDMETHOD(CreateViewport)
    (	THIS_ LPDIRECT3DRMDEVICE3, LPDIRECT3DRMFRAME3, DWORD, DWORD,
	DWORD, DWORD, LPDIRECT3DRMVIEWPORT2 *
    ) PURE;
    STDMETHOD(CreateWrap)
    (	THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME3,
	D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
	D3DVALUE ou, D3DVALUE ov,
	D3DVALUE su, D3DVALUE sv,
	LPDIRECT3DRMWRAP *
    ) PURE;
    STDMETHOD(CreateUserVisual) (THIS_ D3DRMUSERVISUALCALLBACK, LPVOID lPArg, LPDIRECT3DRMUSERVISUAL *) PURE;
    STDMETHOD(LoadTexture)	(THIS_ const char *, LPDIRECT3DRMTEXTURE3 *) PURE;
    STDMETHOD(LoadTextureFromResource)	(THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType, LPDIRECT3DRMTEXTURE3 *) PURE;
   
    STDMETHOD(SetSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(AddSearchPath)	(THIS_ LPCSTR) PURE;
    STDMETHOD(GetSearchPath)	(THIS_ DWORD *size_return, LPSTR path_return) PURE;
    STDMETHOD(SetDefaultTextureColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetDefaultTextureShades)(THIS_ DWORD) PURE;
   
    STDMETHOD(GetDevices)	(THIS_ LPDIRECT3DRMDEVICEARRAY *) PURE;
    STDMETHOD(GetNamedObject)	(THIS_ const char *, LPDIRECT3DRMOBJECT *) PURE;
   
    STDMETHOD(EnumerateObjects)	(THIS_ D3DRMOBJECTCALLBACK, LPVOID) PURE;
   
    STDMETHOD(Load)		
    (   THIS_ LPVOID, LPVOID, LPIID *, DWORD, D3DRMLOADOPTIONS,
    	D3DRMLOADCALLBACK, LPVOID, D3DRMLOADTEXTURE3CALLBACK, LPVOID,
	LPDIRECT3DRMFRAME3
    ) PURE;
    STDMETHOD(Tick)		(THIS_ D3DVALUE) PURE;

    STDMETHOD(CreateProgressiveMesh)(THIS_ LPDIRECT3DRMPROGRESSIVEMESH *) PURE;

    /* Used with IDirect3DRMObject2 */
    STDMETHOD(RegisterClient)   (THIS_ REFGUID rguid, LPDWORD lpdwID) PURE;
    STDMETHOD(UnregisterClient) (THIS_ REFGUID rguid) PURE;

    STDMETHOD(CreateClippedVisual) (THIS_ LPDIRECT3DRMVISUAL, LPDIRECT3DRMCLIPPEDVISUAL *) PURE;
    STDMETHOD(SetOptions) (THIS_ DWORD);
    STDMETHOD(GetOptions) (THIS_ LPDWORD);
};

#define D3DRM_OK			DD_OK
#define D3DRMERR_BADOBJECT		MAKE_DDHRESULT(781)
#define D3DRMERR_BADTYPE		MAKE_DDHRESULT(782)
#define D3DRMERR_BADALLOC		MAKE_DDHRESULT(783)
#define D3DRMERR_FACEUSED		MAKE_DDHRESULT(784)
#define D3DRMERR_NOTFOUND		MAKE_DDHRESULT(785)
#define D3DRMERR_NOTDONEYET		MAKE_DDHRESULT(786)
#define D3DRMERR_FILENOTFOUND		MAKE_DDHRESULT(787)
#define D3DRMERR_BADFILE		MAKE_DDHRESULT(788)
#define D3DRMERR_BADDEVICE		MAKE_DDHRESULT(789)
#define D3DRMERR_BADVALUE		MAKE_DDHRESULT(790)
#define D3DRMERR_BADMAJORVERSION	MAKE_DDHRESULT(791)
#define D3DRMERR_BADMINORVERSION	MAKE_DDHRESULT(792)
#define D3DRMERR_UNABLETOEXECUTE	MAKE_DDHRESULT(793)
#define D3DRMERR_LIBRARYNOTFOUND        MAKE_DDHRESULT(794)
#define D3DRMERR_INVALIDLIBRARY         MAKE_DDHRESULT(795)
#define D3DRMERR_PENDING                MAKE_DDHRESULT(796)
#define D3DRMERR_NOTENOUGHDATA          MAKE_DDHRESULT(797)
#define D3DRMERR_REQUESTTOOLARGE        MAKE_DDHRESULT(798)
#define D3DRMERR_REQUESTTOOSMALL        MAKE_DDHRESULT(799)
#define D3DRMERR_CONNECTIONLOST         MAKE_DDHRESULT(800)
#define D3DRMERR_LOADABORTED            MAKE_DDHRESULT(801)
#define D3DRMERR_NOINTERNET             MAKE_DDHRESULT(802)
#define D3DRMERR_BADCACHEFILE           MAKE_DDHRESULT(803)
#define D3DRMERR_BOXNOTSET		MAKE_DDHRESULT(804)
#define D3DRMERR_BADPMDATA              MAKE_DDHRESULT(805)
#define D3DRMERR_CLIENTNOTREGISTERED    MAKE_DDHRESULT(806)
#define D3DRMERR_NOTCREATEDFROMDDS	MAKE_DDHRESULT(807)
#define D3DRMERR_NOSUCHKEY              MAKE_DDHRESULT(808)
#define D3DRMERR_INCOMPATABLEKEY        MAKE_DDHRESULT(809)
#define D3DRMERR_ELEMENTINUSE		MAKE_DDHRESULT(810)
#define D3DRMERR_TEXTUREFORMATNOTFOUND  MAKE_DDHRESULT(811)
#define D3DRMERR_NOTAGGREGATED          MAKE_DDHRESULT(812)

#ifdef __cplusplus
};
#endif

#endif /* _D3DRMAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\d3ddm.hpp ===
// Copyright (C) Microsoft Corporation.  All Rights Reserved.

#ifndef _D3DDM_HPP
#define _D3DDM_HPP

#define D3DDM_VERSION       0xDBDB0003      // version tag

// base names for shared memory segments
#define D3DDM_TGTCTX_SM     "D3DDM_DTC_"    // tgt pid
#define D3DDM_MONCTX_SM     "D3DDM_DMC_"    // mon id
#define D3DDM_CMDDATA_SM    "D3DDM_CD_"     // mon id
#define D3DDM_TSHFILE_SM    "D3DDM_TSF_"    // tgt pid; target shader -> file association
#define D3DDM_IMAGE_SM      "D3DDM_I_"      // 0..n

// base names for events
#define D3DDM_TGT_EVENTBP   "D3DDM_TEBP_"   // tgt pid
#define D3DDM_TGT_EVENTACK  "D3DDM_TEACK_"  // tgt pid
#define D3DDM_MON_EVENTCMD  "D3DDM_MECMD_"  // mon id

#define D3DDM_MAX_BP   32    // max number of breakpoints for all types

// event definitions - can set more than one in single word so they
// can be used as breakpoint enables
#define D3DDM_EVENT_RSTOKEN             (1<<0)
#define D3DDM_EVENT_BEGINSCENE          (1<<1)
#define D3DDM_EVENT_ENDSCENE            (1<<2)

#define D3DDM_EVENT_VERTEX              (1<<8)
#define D3DDM_EVENT_VERTEXSHADERINST    (2<<8)
#define D3DDM_EVENT_VERTEXSHADER        (3<<8)

#define D3DDM_EVENT_PRIMITIVE           (1<<15)

#define D3DDM_EVENT_PIXEL               (1<<16)
#define D3DDM_EVENT_PIXELSHADERINST     (1<<17)
#define D3DDM_EVENT_PIXELSHADER         (1<<18)

#define D3DDM_EVENT_TARGETDISCONNECT    (1<<30)
#define D3DDM_EVENT_TARGETEXIT          (1<<31)

// command definitions - command enum is in upper 16 bits so lower 16
// can be used to send command specific parameter information
#define D3DDM_CMD_MASK                  (0xffff<<16)
#define D3DDM_CMD_GO                    (1<<16)

#define D3DDM_CMD_GETDEVICESTATE        (2<<16)
#define D3DDM_CMD_GETTEXTURESTATE       (3<<16)
#define D3DDM_CMD_GETPRIMITIVESTATE     (4<<16)
#define D3DDM_CMD_GETVERTEXSHADER       (5<<16)

#define D3DDM_CMD_GETVERTEXSTATE        (8<<16)
#define D3DDM_CMD_GETVERTEXSHADERCONST  (9<<16)
#define D3DDM_CMD_GETVERTEXSHADERINST   (10<<16) // 15:00 shader instruction
#define D3DDM_CMD_GETVERTEXSHADERSTATE  (11<<16)

#define D3DDM_CMD_GETPIXELSTATE         (16<<16) // 01:00 pixel selection from 2x2 grid
#define D3DDM_CMD_GETPIXELSHADERCONST   (17<<16)
#define D3DDM_CMD_GETPIXELSHADERINST    (18<<16) // 15:00 shader instruction
#define D3DDM_CMD_GETPIXELSHADERSTATE   (19<<16)

#define D3DDM_CMD_DUMPTEXTURE           (32<<16) // 03:00 SM selection (up to 16)
                                                 // 06:04 texture stage (0..7)
                                                 // 10:07 LOD (0..15)
                                                 // 15:11 cubemap or volume slice (0..31)
#define D3DDM_CMD_DUMPRENDERTARGET      (33<<16) // 03:00 SM selection (up to 16)

const UINT D3DDM_MAX_TSSSTAGES      = 8;
const UINT D3DDM_MAX_TSSVALUE       = 32;
const UINT D3DDM_MAX_RS             = 256;

const UINT D3DDM_MAX_VSDECL         = 128;
const UINT D3DDM_MAX_VSINPUTREG     = 16;
const UINT D3DDM_MAX_VSCONSTREG     = 128;
const UINT D3DDM_MAX_VSTEMPREG      = 12;
const UINT D3DDM_MAX_VSRASTOUTREG   = 3;
const UINT D3DDM_MAX_VSATTROUTREG   = 2;
const UINT D3DDM_MAX_VSTEXCRDOUTREG = 8;
const UINT D3DDM_MAX_VSINSTDWORD    = 32;
const UINT D3DDM_MAX_VSINSTSTRING   = 128;

const UINT D3DDM_MAX_PSINPUTREG     = 2;
const UINT D3DDM_MAX_PSCONSTREG     = 8;
const UINT D3DDM_MAX_PSTEMPREG      = 2;
const UINT D3DDM_MAX_PSTEXTREG      = 8;
const UINT D3DDM_MAX_PSINSTDWORD    = 32;
const UINT D3DDM_MAX_PSINSTSTRING   = 128;

// structs for command data
typedef struct _D3DDMDeviceState
{
    UINT32  TextureStageState[D3DDM_MAX_TSSSTAGES][D3DDM_MAX_TSSVALUE];
    UINT32  RenderState[D3DDM_MAX_RS];
    UINT32  VertexShaderHandle;
    UINT32  PixelShaderHandle;
    UINT    MaxVShaderHandle;
    UINT    MaxPShaderHandle;
} D3DDMDeviceState;
typedef struct _D3DDMTextureState
{
} D3DDMTextureState;
typedef struct _D3DDMVertexShader
{
    UINT32  Decl[D3DDM_MAX_VSDECL];
    // followed by user data
} D3DDMVertexShader;

typedef struct _D3DDMVertexState
{
    FLOAT   InputRegs[D3DDM_MAX_VSINPUTREG][4];
} D3DDMVertexState;
typedef struct _D3DDMVertexShaderConst
{
    FLOAT   ConstRegs[D3DDM_MAX_VSCONSTREG][4];
} D3DDMVertexShaderConst;
typedef struct _D3DDMVertexShaderInst
{
    DWORD   Inst[D3DDM_MAX_VSINSTDWORD];
    char    InstString[D3DDM_MAX_VSINSTSTRING];
} D3DDMVertexShaderInst;
typedef struct _D3DDMVertexShaderState
{
    UINT    CurrentInst;
    FLOAT   TempRegs[D3DDM_MAX_VSTEMPREG][4];
    FLOAT   AddressReg[4];
    FLOAT   RastOutRegs[D3DDM_MAX_VSRASTOUTREG][4];
    FLOAT   AttrOutRegs[D3DDM_MAX_VSATTROUTREG][4];
    FLOAT   TexCrdOutRegs[D3DDM_MAX_VSTEXCRDOUTREG][4];
} D3DDMVertexShaderState;

typedef struct _D3DDMPrimState
{
} D3DDMPrimState;

typedef struct _D3DDMPixelState
{
    UINT    Location[2];
    FLOAT   Depth;
    FLOAT   FogIntensity;
    FLOAT   InputRegs[D3DDM_MAX_PSINPUTREG][4];
} D3DDMPixelState;
typedef struct _D3DDMPixelShaderConst
{
    FLOAT   ConstRegs[D3DDM_MAX_PSCONSTREG][4];
} D3DDMPixelShaderConst;
typedef struct _D3DDMPixelShaderInst
{
    DWORD   Inst[D3DDM_MAX_PSINSTDWORD];
    char    InstString[D3DDM_MAX_PSINSTSTRING];
} D3DDMPixelShaderInst;
typedef struct _D3DDMPixelShaderState
{
    UINT    CurrentInst;
    FLOAT   TempRegs[D3DDM_MAX_PSTEMPREG][4];
    FLOAT   TextRegs[D3DDM_MAX_PSTEXTREG][4];
    BOOL    Discard;
} D3DDMPixelShaderState;

// size of command data buffer - large enough for any (single) command,
// the largest of which is the instruction + instruction comment (128KB)
#define D3DDM_CMDDATA_SIZE  0x28000

//
// DebugMonitorContext & DebugTargetContext - Contexts for each side of the
// target/monitor processes.
//
// DebugMonitorContext is R/W to monitor and RO to debug target.  The only
// exception is the TargetIDRequest, which is written by a target when
// requesting to be connected to that monitor.
//
// The TargetBP (BreakPoint) event is signaled by the target whenever a
// breakpoint is hit.
//
// The MonitorCmd (Command) event is signaled by the monitor when a command
// is ready to be processed by the target, and the TargetAck is signaled
// when the target is done processing the command.  This is reversed during
// target attachment, where the target signals (via MonitorCmd) the monitor
// to look at it's TargetIDRequest and connect to that target, sending an
// acknowledge to the target via TargetAck.
//

typedef struct _DebugMonitorContext
{
    int     MonitorID;          // 1..X ID of monitor
    int     TargetIDRequest;    // pid of CMDing target; writeable by target
    int     TargetID;           // pid of attached target; zero if not connected
    UINT32  Command;            // D3DDM_CMD_* token

// breakpoint settings
    UINT32  EventBP;
    UINT64  VertexCountBP;
    UINT64  PrimitiveCountBP;
    UINT64  PixelCountBP;
    DWORD   VertexShaderHandleBP;
    DWORD   PixelShaderHandleBP;
    UINT32  RastVertexBPEnable;
    UINT32  PixelBPEnable;

    INT32   RastVertexBP[D3DDM_MAX_BP][2];
    UINT    PixelBP[D3DDM_MAX_BP][2];
} DebugMonitorContext;

typedef struct _DebugTargetContext
{
    DWORD   Version;            // version
    int     ProcessID;          // pid of this target
    int     MonitorID;          // ID of monitor; zero if not connected
    UINT32  CommandBufferSize;  // size of data in command buffer

// status/state
    UINT32  EventStatus;
    UINT32  SceneCount;
    UINT64  PrimitiveCount;
    UINT64  PixelCount;

// The target side maintains dirty flags so the monitor side knows when to
// requery target-side state.
#define D3DDM_SC_DEVICESTATE        (1<<0)
#define D3DDM_SC_TEXTURE            (1<<1)
#define D3DDM_SC_PSSETSHADER        (1<<2)
#define D3DDM_SC_PSCONSTANTS        (1<<3)
#define D3DDM_SC_VSSETSHADER        (1<<4)
#define D3DDM_SC_VSCONSTANTS        (1<<5)
#define D3DDM_SC_VSMODIFYSHADERS    (1<<6)
#define D3DDM_SC_PSMODIFYSHADERS    (1<<7)
    UINT32  StateChanged;

} DebugTargetContext;

#endif // _D3DDM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\d3d8sddi.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       D3D8sddi.h
 *  Content:    Defines the interface between the ddi thunk layer
 *              and the refrast/RGB HEL layer..
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   04-nov-99  smac    initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifndef __D3D8SW_INCLUDED__
#define __D3D8SW_INCLUDED__

// Surface types
#define SWSURF_SURFACE                     0x00000001
#define SWSURF_VOLUME                      0x00000002
#define SWSURF_MIPMAP                      0x00000004
#define SWSURF_MIPVOLUME                   0x00000008
#define SWSURF_CUBEMAP                     0x00000010
#define SWSURF_VERTEXBUFFER                0x00000020
#define SWSURF_OPTIMIZERVERTEXBUFFER       0x00000040
#define SWSURF_INDEXBUFFER                 0x00000080
#define SWSURF_COMMANDBUFFER               0x00000100

// Flags
#define SWFLAG_D3DEXENDEDCAPS              0x00000001
#define SWFLAG_D3DGLOBALDRIVERDATA         0x00000002
#define SWFLAG_D3DCAPS8                    0x00000004



typedef struct _D3D8_SWCALLBACKS
{
    // From Callbacks
    LPD3DHAL_CONTEXTCREATECB                CreateContext;
    LPD3DHAL_CONTEXTDESTROYCB               ContextDestroy;
    LPD3DHAL_CONTEXTDESTROYALLCB            ContextDestroyAll;
    LPD3DHAL_SCENECAPTURECB                 SceneCapture;
    LPD3DHAL_RENDERSTATECB                  RenderState;
    LPD3DHAL_RENDERPRIMITIVECB              RenderPrimitive;
    LPD3DHAL_TEXTURECREATECB                TextureCreate;
    LPD3DHAL_TEXTUREDESTROYCB               TextureDestroy;
    LPD3DHAL_TEXTURESWAPCB                  TextureSwap;
    LPD3DHAL_TEXTUREGETSURFCB               TextureGetSurf;
    LPD3DHAL_GETSTATECB                     GetState;

    // From Callbacks2
    LPD3DHAL_SETRENDERTARGETCB              SetRenderTarget;
    LPD3DHAL_CLEARCB                        Clear;
    LPD3DHAL_DRAWONEPRIMITIVECB             DrawOnePrimitive;
    LPD3DHAL_DRAWONEINDEXEDPRIMITIVECB      DrawOneIndexedPrimitive;
    LPD3DHAL_DRAWPRIMITIVESCB               DrawPrimitives;

    // From Callbacks3
    LPD3DHAL_CLEAR2CB                       Clear2;
    LPD3DHAL_VALIDATETEXTURESTAGESTATECB    ValidateTextureStageState;
    LPD3DHAL_DRAWPRIMITIVES2CB              DrawPrimitives2;

    // From MiscCallbacks in DDraw
    LPDDHAL_GETDRIVERSTATE                  GetDriverState;
    LPDDHAL_CREATESURFACEEX                 CreateSurfaceEx;

    // DDraw Callbacks
    LPDDHAL_CREATESURFACE                   CreateSurface;
    LPDDHALSURFCB_DESTROYSURFACE            DestroySurface;
    LPDDHALSURFCB_LOCK                      Lock;
    LPDDHALSURFCB_UNLOCK                    Unlock;

} D3D8_SWCALLBACKS, * PD3D8_SWCALLBACKS;


#ifdef __cplusplus
extern "C" {
#endif

HRESULT APIENTRY D3D8GetSWInfo(
    D3DCAPS8*           pCaps,
    PD3D8_SWCALLBACKS   pCallbacks,
    DWORD*              pNumTextures,
    DDSURFACEDESC**     ppTexList
    );

#ifdef __cplusplus
}
#endif


// Prototypes required to hook the DDI layer (used by RefRast and the HEL

#define D3D8_REFRASTNAME            "D3DREF8.DLL"

#define D3D8HOOK_GETSWINFOPROCNAME  "D3D8GetSWInfo"

typedef HRESULT (WINAPI * PD3D8GetSWInfo)(D3DCAPS8*          pCaps,
                                          PD3D8_SWCALLBACKS  pCallbacks,
                                          DWORD*             pNumTextures,
                                          DDSURFACEDESC**    ppTexList
                                          );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\inetcore\inc\winhttpi.h ===
#if !defined(_WINHTTPXEX_)
#define _WINHTTPXEX_

#if defined(__cplusplus)
extern "C" {
#endif

#define INTERNETAPI
// url-parsing flags added internally
//#define WINHTTP_FLAG_DEFAULT_ESCAPE   0x00000010 //obloete because of WIHHTTP_FLAG_ESCAPE_DISABLE
#define WINHTTP_FLAG_VALID_HOSTNAME     0x00000020  //only for server name; fast conversion is performed, no escaping
// These flags are superseded by WINHTTP_OPTION_DISABLE_FEATURE
#define INTERNET_FLAG_KEEP_CONNECTION   0x00400000  // use keep-alive semantics
#define INTERNET_FLAG_NO_AUTO_REDIRECT  0x00200000  // don't handle redirections automatically
#define INTERNET_FLAG_NO_COOKIES        0x00080000  // no automatic cookie handling
#define INTERNET_FLAG_NO_AUTH           0x00040000  // no automatic authentication handling
// WARNING: these flags may become unsupported or done in a different way.
// Security Ignore Flags, Allow HttpOpenRequest to overide
//  Secure Channel (SSL) failures of the following types.

#define INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP   0x00008000 // ex: https:// to http://
#define INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS  0x00004000 // ex: http:// to https://
#define SECURITY_INTERNET_MASK  (SECURITY_FLAG_IGNORE_CERT_CN_INVALID    |  \
                                 SECURITY_FLAG_IGNORE_CERT_DATE_INVALID  |  \
                                 INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS  |  \
                                 INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP   |  \
                                 SECURITY_FLAG_IGNORE_UNKNOWN_CA         |  \
                                 SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE)


// parameter validation masks

#define WINHTTP_OPEN_FLAGS_MASK         (WINHTTP_FLAG_ASYNC) // valid flags mask
#define WINHTTP_CONNECT_FLAGS_MASK      0
#define WINHTTP_OPEN_REQUEST_FLAGS_MASK (WINHTTP_FLAG_SECURE                |  \
                                         WINHTTP_FLAG_ESCAPE_PERCENT        |  \
                                         WINHTTP_FLAG_NULL_CODEPAGE         |  \
                                         WINHTTP_FLAG_BYPASS_PROXY_CACHE    |  \
                                         WINHTTP_FLAG_ESCAPE_DISABLE        |  \
                                         WINHTTP_FLAG_ESCAPE_DISABLE_QUERY)
#define INTERNET_SCHEME_PARTIAL     (-2)
#define INTERNET_SCHEME_UNKNOWN     (-1)
#define INTERNET_SCHEME_DEFAULT     (0)
#define INTERNET_SCHEME_SOCKS       (3)
#define INTERNET_SCHEME_FIRST       (INTERNET_SCHEME_HTTP)
#define INTERNET_SCHEME_LAST        (INTERNET_SCHEME_SOCKS)
// WINHTTP_OPTION_VERSION is confusing, so we are killing it.
#define WINHTTP_OPTION_VERSION                       40
#define WINHTTP_OPTION_ERROR_MASK                    62
// Pass in pointer to INTERNET_SECURITY_CONNECTION_INFO to be filled in.
#define WINHTTP_OPTION_SECURITY_CONNECTION_INFO      66
#define WINHTTP_LAST_OPTION_INTERNAL           WINHTTP_LAST_OPTION
#define WINHTTP_OPTION_MASK                    0x0fff
#define MAX_INTERNET_STRING_OPTION  (WINHTTP_OPTION_PROXY_PASSWORD & WINHTTP_OPTION_MASK)
#define NUM_INTERNET_STRING_OPTION  (MAX_INTERNET_STRING_OPTION + 1)
// values for WINHTTP_OPTION_ERROR_MASK
#define INTERNET_ERROR_MASK_COMBINED_SEC_CERT                 0x2
#define WINHTTP_AUTH_SCHEME_KERBEROS   0x00000020
// setable flags
#define SECURITY_FLAG_CHECK_REVOCATION               0x00020000
// Other than the define for all supported secure protocols in winhttp,
// the single bit flags map directly to the SP_PROT_*_CLIENT flags
// defined in schannel.h
//ensure that WINHTTP_CALLBACK_FLAG_ALL always matches OR of all the CALLBACKFLAGS

//
// Note that adding any WINHTTP_QUERY_* codes here must be followed
//   by an equivlent line in wininet\http\hashgen\hashgen.cpp
//   please see that file for further information regarding
//   the addition of new HTTP headers
//


// These are not part of HTTP 1.1 yet. We will propose these to the
// HTTP extensions working group. These are required for the client-caps support
// we are doing in conjuntion with IIS.

#define WINHTTP_QUERY_ECHO_REQUEST                 71
#define WINHTTP_QUERY_ECHO_REPLY                   72

// These are the set of headers that should be added back to a request when
// re-doing a request after a RETRY_WITH response.
#define WINHTTP_QUERY_ECHO_HEADERS                 73
#define WINHTTP_QUERY_ECHO_HEADERS_CRLF            74


#define HTTP_QUERY_MODIFIER_FLAGS_MASK          (WINHTTP_QUERY_FLAG_REQUEST_HEADERS    \
                                                | WINHTTP_QUERY_FLAG_SYSTEMTIME        \
                                                | WINHTTP_QUERY_FLAG_NUMBER            \
                                                )

#define HTTP_QUERY_HEADER_MASK                  (~HTTP_QUERY_MODIFIER_FLAGS_MASK)


//
// AR_TYPE - Asynchronous Request Type designator. Used as index into array of
// ARB sizes, hence must start at 0
//

typedef enum {
    AR_INTERNET_CONNECT = 0,            // 0
    AR_INTERNET_OPEN_URL,               // 1
    AR_INTERNET_READ_FILE,              // 2
    AR_INTERNET_WRITE_FILE,             // 3
    AR_INTERNET_QUERY_DATA_AVAILABLE,   // 4
    AR_INTERNET_FIND_NEXT_FILE,         // 5
    AR_FTP_FIND_FIRST_FILE,             // 6
    AR_FTP_GET_FILE,                    // 7
    AR_FTP_PUT_FILE,                    // 8
    AR_FTP_DELETE_FILE,                 // 9
    AR_FTP_RENAME_FILE,                 // 10
    AR_FTP_OPEN_FILE,                   // 11
    AR_FTP_CREATE_DIRECTORY,            // 12
    AR_FTP_REMOVE_DIRECTORY,            // 13
    AR_FTP_SET_CURRENT_DIRECTORY,       // 14
    AR_FTP_GET_CURRENT_DIRECTORY,       // 15
    AR_GOPHER_FIND_FIRST_FILE,          // 16
    AR_GOPHER_OPEN_FILE,                // 17
    AR_GOPHER_GET_ATTRIBUTE,            // 18
    AR_HTTP_SEND_REQUEST,               // 19
    AR_HTTP_BEGIN_SEND_REQUEST,         // 20
    AR_HTTP_END_SEND_REQUEST,           // 21
    AR_READ_PREFETCH,                   // 22
    AR_SYNC_EVENT,                      // 23
    AR_TIMER_EVENT,                     // 24
    AR_HTTP_REQUEST1,                   // 25
    AR_FILE_IO,                         // 26
    AR_INTERNET_READ_FILE_EX,           // 27
    AR_MAX_REQUEST_TYPE
} AR_TYPE;

#define ERROR_WINHTTP_INCORRECT_PASSWORD       (WINHTTP_ERROR_BASE + 14)

#define WINHTTP_INFO                     4L
#define WINHTTP_WARNING                  2L
#define WINHTTP_ERROR                    1L
void LOG_EVENT(DWORD dwEventType, char* format, ...);
#define ERROR_WINHTTP_NOT_REDIRECTED               (WINHTTP_ERROR_BASE + 160)

#if defined(INCLUDE_CACHE)
// Cache control flags

// Control expiry behaviour
#define CACHE_FLAG_SYNC_MODE_AUTOMATIC          0x00000010
#define CACHE_FLAG_SYNC_MODE_ALWAYS             0x00000020
#define CACHE_FLAG_SYNC_MODE_ONCE_PER_SESSION   0x00000040 
#define CACHE_FLAG_SYNC_MODE_NEVER              0x00000080

#define CACHE_FLAG_BGUPDATE                     0x00000100
#define CACHE_FLAG_ALWAYS_RESYNCHRONIZE         0x00000200
#define CACHE_FLAG_DISABLE_CACHE_WRITE          0x00000400
#define CACHE_FLAG_DISABLE_CACHE_READ           0x00000800
#define CACHE_FLAG_DISABLE_SSL_CACHING          0x00001000
#define CACHE_FLAG_MAKE_PERSISTENT              0x00002000
#define CACHE_FLAG_FWD_BACK                     0x00004000

#define CACHE_FLAG_OFFLINE_BROWSING         	CACHE_FLAG_DISABLE_CACHE_READ | CACHE_FLAG_DISABLE_CACHE_WRITE
#define CACHE_FLAG_DEFAULT_SETTING           	CACHE_FLAG_SYNC_MODE_AUTOMATIC

#define WINHTTP_CACHE_FLAGS_MASK     ( CACHE_FLAG_SYNC_MODE_AUTOMATIC |           \
                                          CACHE_FLAG_SYNC_MODE_ALWAYS |              \
                                          CACHE_FLAG_SYNC_MODE_ONCE_PER_SESSION |   \
                                          CACHE_FLAG_SYNC_MODE_NEVER |               \
                                          CACHE_FLAG_BGUPDATE |                       \
                                          CACHE_FLAG_ALWAYS_RESYNCHRONIZE |          \
                                          CACHE_FLAG_DISABLE_CACHE_WRITE |           \
                                          CACHE_FLAG_DISABLE_CACHE_READ |            \
                                          CACHE_FLAG_MAKE_PERSISTENT |                \
                                          CACHE_FLAG_FWD_BACK |                       \
                                          CACHE_FLAG_OFFLINE_BROWSING |               \
                                          CACHE_FLAG_DEFAULT_SETTING)
#undef WINHTTP_OPEN_FLAGS_MASK
#define WINHTTP_OPEN_FLAGS_MASK    (WINHTTP_CACHE_FLAGS_MASK | \
                                      WINHTTP_FLAG_ASYNC)

WINHTTPAPI
HINTERNET
WINAPI
WinHttpCacheOpen(
    IN LPCWSTR pszAgentW,
    IN DWORD dwAccessType,
    IN LPCWSTR pszProxyW OPTIONAL,
    IN LPCWSTR pszProxyBypassW OPTIONAL,
    IN DWORD dwFlags
    );

WINHTTPAPI
HINTERNET
WINAPI
WinHttpCacheConnect(
    HINTERNET hSession,
    LPCWSTR pswzServerName,
    INTERNET_PORT nServerPort,
    DWORD dwReserved
    );

WINHTTPAPI
HINTERNET
WINAPI
WinHttpCacheOpenRequest(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags
    );

BOOLAPI
WinHttpCacheSendRequest(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional,
    IN DWORD dwOptionalLength,
    IN DWORD dwTotalLength,
    IN DWORD_PTR dwContext
    );

BOOLAPI
WinHttpCacheReceiveResponse(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffersOut
    );

BOOLAPI
WinHttpCacheQueryDataAvailable(
    IN HINTERNET hRequest,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    );

BOOLAPI
WinHttpCacheReadData(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

BOOLAPI
WinHttpCacheCloseHandle(
    IN HINTERNET hInternet
    );

BOOL
WINAPI
WinHttpCacheQueryOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    LPDWORD lpdwBufferLength
    );

BOOL
WINAPI
WinHttpCacheSetOption(
    HINTERNET hInternet,
    DWORD dwOption,
    LPVOID lpBuffer,
    DWORD dwBufferLength
    );

BOOL
WINAPI
WinHttpCacheQueryHeaders(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN LPCWSTR lpszName OPTIONAL, 
    OUT LPVOID  lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    );

BOOL
WINAPI
WinHttpCacheAddRequestHeaders(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );

BOOL
WINAPI
WinHttpCacheQueryAuthSchemes(
    IN  HINTERNET   hRequest,
    OUT LPDWORD     lpdwSupportedSchemes,
    OUT LPDWORD     lpdwPreferredScheme,
    OUT LPDWORD      pdwAuthTarget
    );

BOOL
WINAPI
WinHttpCacheSetCredentials(
    IN HINTERNET   hRequest,
    IN DWORD       AuthTargets,
    IN DWORD       AuthScheme,
    IN LPCWSTR     pwszUserName,
    IN LPCWSTR     pwszPassword,
    IN LPVOID      pAuthParams
    );

BOOL
WINAPI 
WinCacheHttpSetTimeouts(    
    IN HINTERNET    hInternet,
    IN int        nResolveTimeout,
    IN int        nConnectTimeout,
    IN int        nSendTimeout,
    IN int        nReceiveTimeout
    );

BOOL
WINAPI
WinCacheHttpWriteData(
    IN HINTERNET hFile,
    IN LPCVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    );

WINHTTP_STATUS_CALLBACK
WINAPI
WinHttpCacheSetStatusCallback(
    IN HINTERNET hInternet,
    IN WINHTTP_STATUS_CALLBACK lpfnInternetCallback,
    IN DWORD dwNotificationFlags,
    IN DWORD_PTR dwReserved
    );

VOID
WinHttpCacheStatusCallback(
    HINTERNET hInternet,
    DWORD_PTR dwContext,
    DWORD dwInternetStatus,
    LPVOID lpvStatusInformation,
    DWORD dwStatusInformationLength
    );

#endif


#if defined(__cplusplus)
}
#endif

#endif // !define(_WINHTTPXEX_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\inetsrv\inc\seoexports.h ===
//-----------------------------------------------------------------------------
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Description:
//      This header file defines stuff published by SEO to other (Microsoft
//      internal) projects in additon to the seo.idl file.
//
//-----------------------------------------------------------------------------

#ifndef __SEOEXPORTS_H__
#define __SEOEXPORTS_H__

class CStringGUID {
	public:
		CStringGUID() { m_bValid=FALSE; };
		CStringGUID(const CStringGUID& objGuid) { m_bValid=FALSE; Assign(objGuid); };
		CStringGUID(REFGUID rGuid) { m_bValid=FALSE; Assign(rGuid); };
		CStringGUID(LPCOLESTR pszGuid) { m_bValid=FALSE; Assign(pszGuid); };
		CStringGUID(LPCSTR pszGuid) { m_bValid=FALSE; Assign(pszGuid); };
		CStringGUID(const VARIANT *pvarGuid) { m_bValid=FALSE; Assign(pvarGuid); };
		CStringGUID(const VARIANT& varGuid) { m_bValid=FALSE; Assign(varGuid); };
		CStringGUID(REFGUID rGuid, DWORD dwIndex) {
			GUID tmp = rGuid;
			tmp.Data4[7] |= 0x80;
			tmp.Data2 = (WORD) (dwIndex >> 16);
			tmp.Data3 = (WORD) dwIndex;
			Assign(rGuid,dwIndex); };
		BOOL ReCalcFromGuid() {
			m_bValid = FALSE;
			if (SUCCEEDED(StringFromGUID2(m_guid,m_szGuidW,sizeof(m_szGuidW)/sizeof(m_szGuidW[0])))) {
				ATLW2AHELPER(m_szGuidA,m_szGuidW,sizeof(m_szGuidA)/sizeof(m_szGuidA[0])); m_bValid=TRUE; };
#ifdef DEBUG
			USES_CONVERSION;
			_ASSERTE(!m_bValid||(!strcmp(W2A(m_szGuidW),m_szGuidA)&&!wcscmp(m_szGuidW,A2W(m_szGuidA))));
#endif
			return (m_bValid); };
		BOOL CalcNew() {
			if (!SUCCEEDED(CoCreateGuid(&m_guid))) { m_bValid=FALSE; return (FALSE); };
			return (ReCalcFromGuid()); };
		BOOL CalcFromProgID(LPCOLESTR pszProgID) {
			if (!pszProgID || !SUCCEEDED(CLSIDFromProgID(pszProgID,&m_guid))) {
				m_bValid=FALSE; return (FALSE); };
			return (ReCalcFromGuid()); };
		BOOL CalcFromProgID(LPCSTR pszProgID) {
			USES_CONVERSION; return (CalcFromProgID(pszProgID?A2W(pszProgID):NULL)); };
		BOOL Assign(const CStringGUID& objGuid) { operator =(objGuid); return (m_bValid); };
		BOOL Assign(REFGUID rGuid) { operator =(rGuid); return (m_bValid); };
		BOOL Assign(LPCOLESTR pszGuid) { operator =(pszGuid); return (m_bValid); };
		BOOL Assign(LPCSTR pszGuid) { operator =(pszGuid); return (m_bValid); };
		BOOL Assign(const VARIANT *pvarGuid) { operator =(pvarGuid); return (m_bValid); };
		BOOL Assign(const VARIANT& varGuid) { operator =(varGuid); return (m_bValid); };
		BOOL Assign(REFGUID rGuid, DWORD dwIndex) {
			// For index'ed GUID's, we set the high-bit of the MAC-address in the GUID - this
			// is the multicast bit, and will never be set for any real MAC-address.  Then we
			// XOR the index value over the Data2 and Data 3 fields of the GUID.  Since we
			// leave the timestamp fields completely untouched, confidence is "high" that this
			// algorithm will never create collisions with any other GUID's.
			GUID tmp = rGuid;
			tmp.Data4[2] |= 0x80;
			tmp.Data2 ^= (WORD) (dwIndex >> 16);
			tmp.Data3 ^= (WORD) dwIndex;
			operator =(tmp);
			return (m_bValid); };
		BOOL GetIndex(REFGUID rGuid, DWORD *dwIndex) {
			// check to see if this is an indexed GUID by seeing if the
			// multicast bit is set to 1
			if ((m_guid.Data4[2] & 0x80) != 0x80) return FALSE;
			*dwIndex = 0;
			// get the high part
			*dwIndex = ((WORD) (rGuid.Data2) ^ (m_guid.Data2)) << 16;
			// get the low part
			*dwIndex += (WORD) ((rGuid.Data3) ^ (m_guid.Data3));
			// This does not check that rGuid mangles into m_guid
			// if you run it through the index function with dwIndex
			return TRUE;
		}
		operator REFGUID() { _ASSERTE(m_bValid); return (m_guid); };
		operator LPCOLESTR() { _ASSERTE(m_bValid); return (m_szGuidW); };
		operator LPCSTR() { _ASSERTE(m_bValid); return (m_szGuidA); };
		const CStringGUID& operator =(const CStringGUID& objGuid) {
			if (!objGuid) { m_bValid=FALSE; return (*this); };
			return (operator=((REFGUID) objGuid)); };
		const CStringGUID& operator =(REFGUID rGuid) {
			m_guid = rGuid; ReCalcFromGuid(); return (*this); };
		const CStringGUID& operator =(LPCOLESTR pszGuid) {
			m_bValid=FALSE;
			if (pszGuid && SUCCEEDED(CLSIDFromString((LPOLESTR) pszGuid,&m_guid))) ReCalcFromGuid();
			return (*this); };
		const CStringGUID& operator =(LPCSTR pszGuid) {
			USES_CONVERSION; return (operator=(pszGuid?A2W(pszGuid):NULL)); };
		const CStringGUID& operator =(const VARIANT *pvarGuid) {
			if (!pvarGuid) { m_bValid=FALSE; return (*this); } return (operator =(*pvarGuid)); };
		const CStringGUID& operator =(const VARIANT& varGuid) {
				CComVariant varTmp(varGuid);
				if (!SUCCEEDED(varTmp.ChangeType(VT_BSTR))) { m_bValid=FALSE; return (*this); };
				return (operator =(varTmp.bstrVal)); };
		GUID* operator &() { _ASSERTE(!m_bValid); return (&m_guid); };
		BOOL operator !() const { return (!m_bValid); };
	private:
		BOOL m_bValid;
		GUID m_guid;
		WCHAR m_szGuidW[40];
		CHAR m_szGuidA[40];
};

#endif // __SEOEXPORTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\d3prmwin.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3drm.h
 *  Content:	Direct3DRM include file
 *@@BEGIN_MSINTERNAL
 * 
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27/02/96   stevela Moved from RL to D3DRM.
 *   11/04/97	stevela Removed D3DRMUPDATECALLBACK
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __D3DRMWIN_H__
#define __D3DRMWIN_H__

#ifndef WIN32
#define WIN32
#endif

// @@BEGIN_MSINTERNAL
#ifdef WINNT
#include "d3prm.h"
#else 
#include "d3drm.h"
#endif
#if 0
// @@END_MSINTERNAL
#include "d3drm.h"
// @@BEGIN_MSINTERNAL
#endif
// @@END_MSINTERNAL

#include "ddraw.h"
#include "d3d.h"

/*
 * GUIDS used by Direct3DRM Windows interface
 */
DEFINE_GUID(IID_IDirect3DRMWinDevice,	0xc5016cc0, 0xd273, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);

WIN_TYPES(IDirect3DRMWinDevice, DIRECT3DRMWINDEVICE);

#undef INTERFACE
#define INTERFACE IDirect3DRMWinDevice

DECLARE_INTERFACE_(IDirect3DRMWinDevice, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMWinDevice methods
     */

    /* Repaint the window with the last frame which was rendered. */
    STDMETHOD(HandlePaint)(THIS_ HDC hdc) PURE;

    /* Respond to a WM_ACTIVATE message. */
    STDMETHOD(HandleActivate)(THIS_ WORD wparam) PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\d3prmobj.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3drm.h
 *  Content:	Direct3DRM include file
 *@@BEGIN_MSINTERNAL
 * 
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27/02/96   stevela Moved from RL to D3DRM.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _D3DRMOBJ_H_
#define _D3DRMOBJ_H_

// @@BEGIN_MSINTERNAL
#ifdef WIN32
// @@END_MSINTERNAL
#include <objbase.h> /* Use Windows header files */
#define VIRTUAL
// @@BEGIN_MSINTERNAL
#else
/* No Windows platform */
#include "d3drmbase.h"
#endif
// @@END_MSINTERNAL

// @@BEGIN_MSINTERNAL
#ifdef WINNT
#include "d3prmdef.h"
#else
#include "d3drmdef.h"
#endif
#if 0
// @@END_MSINTERNAL
#include "d3drmdef.h"
// @@BEGIN_MSINTERNAL
#endif
// @@END_MSINTERNAL

#include "d3d.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
 * The methods for IUnknown
 */
#define IUNKNOWN_METHODS(kind) \
    STDMETHOD(QueryInterface)	   	(THIS_ REFIID riid, LPVOID *ppvObj) kind; \
    STDMETHOD_(ULONG, AddRef)	   	(THIS) kind; \
    STDMETHOD_(ULONG, Release)	   	(THIS) kind

/*
 * The methods for IDirect3DRMObject
 */
#define IDIRECT3DRMOBJECT_METHODS(kind) \
    STDMETHOD(Clone)			(THIS_ LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObj) kind; \
    STDMETHOD(AddDestroyCallback)  	(THIS_ D3DRMOBJECTCALLBACK, LPVOID argument) kind; \
    STDMETHOD(DeleteDestroyCallback)	(THIS_ D3DRMOBJECTCALLBACK, LPVOID argument) kind; \
    STDMETHOD(SetAppData)	   	(THIS_ DWORD data) kind; \
    STDMETHOD_(DWORD, GetAppData)  	(THIS) kind; \
    STDMETHOD(SetName)		   	(THIS_ LPCSTR) kind; \
    STDMETHOD(GetName)			(THIS_ LPDWORD lpdwSize, LPSTR lpName) kind; \
    STDMETHOD(GetClassName)		(THIS_ LPDWORD lpdwSize, LPSTR lpName) kind


#define WIN_TYPES(itype, ptype) \
    typedef interface itype FAR *LP##ptype, FAR **LPLP##ptype

WIN_TYPES(IDirect3DRMObject, DIRECT3DRMOBJECT);
WIN_TYPES(IDirect3DRMObject2, DIRECT3DRMOBJECT2);
WIN_TYPES(IDirect3DRMDevice, DIRECT3DRMDEVICE);
WIN_TYPES(IDirect3DRMDevice2, DIRECT3DRMDEVICE2);
WIN_TYPES(IDirect3DRMDevice3, DIRECT3DRMDEVICE3);
WIN_TYPES(IDirect3DRMViewport, DIRECT3DRMVIEWPORT);
WIN_TYPES(IDirect3DRMViewport2, DIRECT3DRMVIEWPORT2);
WIN_TYPES(IDirect3DRMFrame, DIRECT3DRMFRAME);
WIN_TYPES(IDirect3DRMFrame2, DIRECT3DRMFRAME2);
WIN_TYPES(IDirect3DRMFrame3, DIRECT3DRMFRAME3);
WIN_TYPES(IDirect3DRMVisual, DIRECT3DRMVISUAL);
WIN_TYPES(IDirect3DRMMesh, DIRECT3DRMMESH);
WIN_TYPES(IDirect3DRMMeshBuilder, DIRECT3DRMMESHBUILDER);
WIN_TYPES(IDirect3DRMMeshBuilder2, DIRECT3DRMMESHBUILDER2);
WIN_TYPES(IDirect3DRMMeshBuilder3, DIRECT3DRMMESHBUILDER3);
WIN_TYPES(IDirect3DRMFace, DIRECT3DRMFACE);
WIN_TYPES(IDirect3DRMFace2, DIRECT3DRMFACE2);
WIN_TYPES(IDirect3DRMLight, DIRECT3DRMLIGHT);
WIN_TYPES(IDirect3DRMTexture, DIRECT3DRMTEXTURE);
WIN_TYPES(IDirect3DRMTexture2, DIRECT3DRMTEXTURE2);
WIN_TYPES(IDirect3DRMTexture3, DIRECT3DRMTEXTURE3);
WIN_TYPES(IDirect3DRMWrap, DIRECT3DRMWRAP);
WIN_TYPES(IDirect3DRMMaterial, DIRECT3DRMMATERIAL);
WIN_TYPES(IDirect3DRMMaterial2, DIRECT3DRMMATERIAL2);
WIN_TYPES(IDirect3DRMInterpolator, DIRECT3DRMINTERPOLATOR);
WIN_TYPES(IDirect3DRMAnimation, DIRECT3DRMANIMATION);
WIN_TYPES(IDirect3DRMAnimation2, DIRECT3DRMANIMATION2);
WIN_TYPES(IDirect3DRMAnimationSet, DIRECT3DRMANIMATIONSET);
WIN_TYPES(IDirect3DRMAnimationSet2, DIRECT3DRMANIMATIONSET2);
WIN_TYPES(IDirect3DRMUserVisual, DIRECT3DRMUSERVISUAL);
WIN_TYPES(IDirect3DRMShadow, DIRECT3DRMSHADOW);
WIN_TYPES(IDirect3DRMShadow2, DIRECT3DRMSHADOW2);
WIN_TYPES(IDirect3DRMArray, DIRECT3DRMARRAY);
WIN_TYPES(IDirect3DRMObjectArray, DIRECT3DRMOBJECTARRAY);
WIN_TYPES(IDirect3DRMDeviceArray, DIRECT3DRMDEVICEARRAY);
WIN_TYPES(IDirect3DRMFaceArray, DIRECT3DRMFACEARRAY);
WIN_TYPES(IDirect3DRMViewportArray, DIRECT3DRMVIEWPORTARRAY);
WIN_TYPES(IDirect3DRMFrameArray, DIRECT3DRMFRAMEARRAY);
WIN_TYPES(IDirect3DRMAnimationArray, DIRECT3DRMANIMATIONARRAY);
WIN_TYPES(IDirect3DRMVisualArray, DIRECT3DRMVISUALARRAY);
WIN_TYPES(IDirect3DRMPickedArray, DIRECT3DRMPICKEDARRAY);
WIN_TYPES(IDirect3DRMPicked2Array, DIRECT3DRMPICKED2ARRAY);
WIN_TYPES(IDirect3DRMLightArray, DIRECT3DRMLIGHTARRAY);
WIN_TYPES(IDirect3DRMProgressiveMesh, DIRECT3DRMPROGRESSIVEMESH);
WIN_TYPES(IDirect3DRMClippedVisual, DIRECT3DRMCLIPPEDVISUAL);

/*
 * Direct3DRM Object classes
 */
DEFINE_GUID(CLSID_CDirect3DRMDevice,	    0x4fa3568e, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMViewport,	    0x4fa3568f, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMFrame,	    0x4fa35690, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMesh,	    0x4fa35691, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMeshBuilder,   0x4fa35692, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMFace,	    0x4fa35693, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMLight,	    0x4fa35694, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMTexture,	    0x4fa35695, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMWrap,	    0x4fa35696, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMMaterial,	    0x4fa35697, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMAnimation,	    0x4fa35698, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMAnimationSet,  0x4fa35699, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMUserVisual,    0x4fa3569a, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMShadow,	    0x4fa3569b, 0x623f, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(CLSID_CDirect3DRMViewportInterpolator, 
0xde9eaa1, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMFrameInterpolator, 
0xde9eaa2, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMMeshInterpolator, 
0xde9eaa3, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMLightInterpolator, 
0xde9eaa6, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMMaterialInterpolator, 
0xde9eaa7, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMTextureInterpolator, 
0xde9eaa8, 0x3b84, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMProgressiveMesh, 0x4516ec40, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(CLSID_CDirect3DRMClippedVisual,   0x5434e72d, 0x6d66, 0x11d1, 0xbb, 0xb, 0x0, 0x0, 0xf8, 0x75, 0x86, 0x5a);


/*
 * Direct3DRM Object interfaces
 */
DEFINE_GUID(IID_IDirect3DRMObject, 	    0xeb16cb00, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMObject2,         0x4516ec7c, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice, 	    0xe9e19280, 0x6e05, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMDevice2,	    0x4516ec78, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDevice3,     0x549f498b, 0xbfeb, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMViewport, 	    0xeb16cb02, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewport2,   0x4a1b1be6, 0xbfed, 0x11d1, 0x8e, 0xd8, 0x0, 0xa0, 0xc9, 0x67, 0xa4, 0x82);
DEFINE_GUID(IID_IDirect3DRMFrame, 	    0xeb16cb03, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrame2,	    0xc3dfbd60, 0x3988, 0x11d0, 0x9e, 0xc2, 0x0, 0x0, 0xc0, 0x29, 0x1a, 0xc3);
DEFINE_GUID(IID_IDirect3DRMFrame3,              0xff6b7f70, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMVisual, 	    0xeb16cb04, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMesh, 	    0xa3a80d01, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder,	    0xa3a80d02, 0x6e12, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder2,    0x4516ec77, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMMeshBuilder3,    0x4516ec82, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMFace, 	    0xeb16cb07, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFace2,           0x4516ec81, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMLight, 	    0xeb16cb08, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture, 	    0xeb16cb09, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMTexture2,        0x120f30c0, 0x1629, 0x11d0, 0x94, 0x1c, 0x0, 0x80, 0xc8, 0xc, 0xfa, 0x7b);
DEFINE_GUID(IID_IDirect3DRMTexture3,        0xff6b7f73, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMWrap, 	    0xeb16cb0a, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial, 	    0xeb16cb0b, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMMaterial2,       0xff6b7f75, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimation, 	    0xeb16cb0d, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimation2,      0xff6b7f77, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMAnimationSet,    0xeb16cb0e, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationSet2,   0xff6b7f79, 0xa40e, 0x11d1, 0x91, 0xf9, 0x0, 0x0, 0xf8, 0x75, 0x8e, 0x66);
DEFINE_GUID(IID_IDirect3DRMObjectArray,	    0x242f6bc2, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMDeviceArray,	    0xeb16cb10, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMViewportArray,   0xeb16cb11, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFrameArray, 	    0xeb16cb12, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMVisualArray,	    0xeb16cb13, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMLightArray, 	    0xeb16cb14, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMPickedArray,	    0xeb16cb16, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMFaceArray,	    0xeb16cb17, 0xd271, 0x11ce, 0xac, 0x48, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMAnimationArray, 
0xd5f1cae0, 0x4bd7, 0x11d1, 0xb9, 0x74, 0x0, 0x60, 0x8, 0x3e, 0x45, 0xf3);
DEFINE_GUID(IID_IDirect3DRMUserVisual,	    0x59163de0, 0x6d43, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow,	    0xaf359780, 0x6ba3, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);
DEFINE_GUID(IID_IDirect3DRMShadow2,	    0x86b44e25, 0x9c82, 0x11d1, 0xbb, 0xb, 0x0, 0xa0, 0xc9, 0x81, 0xa0, 0xa6);
DEFINE_GUID(IID_IDirect3DRMInterpolator,    0x242f6bc1, 0x3849, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMProgressiveMesh, 0x4516ec79, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMPicked2Array,    0x4516ec7b, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x0, 0x0, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMClippedVisual,   0x5434e733, 0x6d66, 0x11d1, 0xbb, 0xb, 0x0, 0x0, 0xf8, 0x75, 0x86, 0x5a);

typedef void (__cdecl *D3DRMOBJECTCALLBACK)(LPDIRECT3DRMOBJECT obj, LPVOID arg);
typedef void (__cdecl *D3DRMFRAMEMOVECALLBACK)(LPDIRECT3DRMFRAME obj, LPVOID arg, D3DVALUE delta);
typedef void (__cdecl *D3DRMFRAME3MOVECALLBACK)(LPDIRECT3DRMFRAME3 obj, LPVOID arg, D3DVALUE delta);
typedef void (__cdecl *D3DRMUPDATECALLBACK)(LPDIRECT3DRMDEVICE obj, LPVOID arg, int, LPD3DRECT);
typedef void (__cdecl *D3DRMDEVICE3UPDATECALLBACK)(LPDIRECT3DRMDEVICE3 obj, LPVOID arg, int, LPD3DRECT);
typedef int (__cdecl *D3DRMUSERVISUALCALLBACK)
    (   LPDIRECT3DRMUSERVISUAL obj, LPVOID arg,	D3DRMUSERVISUALREASON reason,
        LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMVIEWPORT view
    );
typedef HRESULT (__cdecl *D3DRMLOADTEXTURECALLBACK)
    (char *tex_name, void *arg, LPDIRECT3DRMTEXTURE *);
typedef HRESULT (__cdecl *D3DRMLOADTEXTURE3CALLBACK)
    (char *tex_name, void *arg, LPDIRECT3DRMTEXTURE3 *);
typedef void (__cdecl *D3DRMLOADCALLBACK)
    (LPDIRECT3DRMOBJECT object, REFIID objectguid, LPVOID arg);

typedef HRESULT (__cdecl *D3DRMDOWNSAMPLECALLBACK)
    (LPDIRECT3DRMTEXTURE3 lpDirect3DRMTexture, LPVOID pArg,
     LPDIRECTDRAWSURFACE pDDSSrc, LPDIRECTDRAWSURFACE pDDSDst);
typedef HRESULT (__cdecl *D3DRMVALIDATIONCALLBACK)
    (LPDIRECT3DRMTEXTURE3 lpDirect3DRMTexture, LPVOID pArg,
     DWORD dwFlags, DWORD dwcRects, LPRECT pRects);

//@@BEGIN_MSINTERNAL
#ifdef BUILD_RLAPI
typedef D3DRMOBJECTCALLBACK RLObjectCallback;
typedef D3DRMFRAMEMOVECALLBACK RLFrameMoveCallback;
typedef D3DRMFRAME3MOVECALLBACK RLFrame3MoveCallback;
typedef D3DRMUPDATECALLBACK RLUpdateCallback;
typedef D3DRMDEVICE3UPDATECALLBACK RLDevice3UpdateCallback;
typedef D3DRMUSERVISUALCALLBACK RLUserVisualCallback;
typedef D3DRMLOADTEXTURECALLBACK RLLoadTextureCallback;
typedef D3DRMLOADTEXTURE3CALLBACK RLLoadTexture3Callback;
typedef D3DRMLOADCALLBACK RLLoadCallback;
typedef D3DRMDOWNSAMPLECALLBACK RLDownsampleCallback;
typedef D3DRMVALIDATIONCALLBACK RLValidationCallback;
#endif
//@@END_MSINTERNAL

typedef struct _D3DRMPICKDESC
{
    ULONG	ulFaceIdx;
    LONG	lGroupIdx;
    D3DVECTOR	vPosition;

} D3DRMPICKDESC, *LPD3DRMPICKDESC;

typedef struct _D3DRMPICKDESC2
{
    ULONG	ulFaceIdx;
    LONG	lGroupIdx;
    D3DVECTOR	dvPosition;
    D3DVALUE	tu;
    D3DVALUE	tv;
    D3DVECTOR	dvNormal;
    D3DCOLOR	dcColor;

} D3DRMPICKDESC2, *LPD3DRMPICKDESC2;

#undef INTERFACE
#define INTERFACE IDirect3DRMObject

/*
 * Base class
 */
DECLARE_INTERFACE_(IDirect3DRMObject, IUnknown)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMObject2

DECLARE_INTERFACE_(IDirect3DRMObject2, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    /*
     * IDirect3DRMObject2 methods
     */
    STDMETHOD(AddDestroyCallback)(THIS_ D3DRMOBJECTCALLBACK lpFunc, LPVOID pvArg) PURE;
    STDMETHOD(Clone)(THIS_ LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObj) PURE; \
    STDMETHOD(DeleteDestroyCallback)(THIS_ D3DRMOBJECTCALLBACK lpFunc, LPVOID pvArg) PURE; \
    STDMETHOD(GetClientData)(THIS_ DWORD dwID, LPVOID* lplpvData) PURE;
    STDMETHOD(GetDirect3DRM)(THIS_ LPDIRECT3DRM* lplpDirect3DRM) PURE;
    STDMETHOD(GetName)(THIS_ LPDWORD lpdwSize, LPSTR lpName) PURE;
    STDMETHOD(SetClientData)(THIS_ DWORD dwID, LPVOID lpvData, DWORD dwFlags) PURE;
    STDMETHOD(SetName)(THIS_ LPCSTR lpName) PURE;
    STDMETHOD(GetAge)(THIS_ DWORD dwFlags, LPDWORD pdwAge) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMVisual

DECLARE_INTERFACE_(IDirect3DRMVisual, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDevice

DECLARE_INTERFACE_(IDirect3DRMDevice, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMDevice methods
     */
    STDMETHOD(Init)(THIS_ ULONG width, ULONG height) PURE;
    STDMETHOD(InitFromD3D)(THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev) PURE;
    STDMETHOD(InitFromClipper)(THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID, int width, int height) PURE;

    STDMETHOD(Update)(THIS) PURE;
    STDMETHOD(AddUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(DeleteUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(SetBufferCount)(THIS_ DWORD) PURE;
    STDMETHOD_(DWORD, GetBufferCount)(THIS) PURE;

    STDMETHOD(SetDither)(THIS_ BOOL) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetTextureQuality)(THIS_ D3DRMTEXTUREQUALITY) PURE;

    STDMETHOD(GetViewports)(THIS_ LPDIRECT3DRMVIEWPORTARRAY *return_views) PURE;

    STDMETHOD_(BOOL, GetDither)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetTrianglesDrawn)(THIS) PURE;
    STDMETHOD_(DWORD, GetWireframeOptions)(THIS) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(D3DCOLORMODEL, GetColorModel)(THIS) PURE;
    STDMETHOD_(D3DRMTEXTUREQUALITY, GetTextureQuality)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice)(THIS_ LPDIRECT3DDEVICE *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDevice2

DECLARE_INTERFACE_(IDirect3DRMDevice2, IDirect3DRMDevice)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMDevice methods
     */
    STDMETHOD(Init)(THIS_ ULONG width, ULONG height) PURE;
    STDMETHOD(InitFromD3D)(THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev) PURE;
    STDMETHOD(InitFromClipper)(THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID, int width, int height) PURE;

    STDMETHOD(Update)(THIS) PURE;
    STDMETHOD(AddUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(DeleteUpdateCallback)(THIS_ D3DRMUPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(SetBufferCount)(THIS_ DWORD) PURE;
    STDMETHOD_(DWORD, GetBufferCount)(THIS) PURE;

    STDMETHOD(SetDither)(THIS_ BOOL) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetTextureQuality)(THIS_ D3DRMTEXTUREQUALITY) PURE;

    STDMETHOD(GetViewports)(THIS_ LPDIRECT3DRMVIEWPORTARRAY *return_views) PURE;

    STDMETHOD_(BOOL, GetDither)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetTrianglesDrawn)(THIS) PURE;
    STDMETHOD_(DWORD, GetWireframeOptions)(THIS) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(D3DCOLORMODEL, GetColorModel)(THIS) PURE;
    STDMETHOD_(D3DRMTEXTUREQUALITY, GetTextureQuality)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice)(THIS_ LPDIRECT3DDEVICE *) PURE;

    /*
     * IDirect3DRMDevice2 methods
     */
    STDMETHOD(InitFromD3D2)(THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE lpDDSBack) PURE;
    STDMETHOD(SetRenderMode)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD_(DWORD, GetRenderMode)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice2)(THIS_ LPDIRECT3DDEVICE2 *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDevice3

DECLARE_INTERFACE_(IDirect3DRMDevice3, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMDevice methods
     */
    STDMETHOD(Init)(THIS_ ULONG width, ULONG height) PURE;
    STDMETHOD(InitFromD3D)(THIS_ LPDIRECT3D lpD3D, LPDIRECT3DDEVICE lpD3DDev) PURE;
    STDMETHOD(InitFromClipper)(THIS_ LPDIRECTDRAWCLIPPER lpDDClipper, LPGUID lpGUID, int width, int height) PURE;

    STDMETHOD(Update)(THIS) PURE;
    STDMETHOD(AddUpdateCallback)(THIS_ D3DRMDEVICE3UPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(DeleteUpdateCallback)(THIS_ D3DRMDEVICE3UPDATECALLBACK, LPVOID arg) PURE;
    STDMETHOD(SetBufferCount)(THIS_ DWORD) PURE;
    STDMETHOD_(DWORD, GetBufferCount)(THIS) PURE;

    STDMETHOD(SetDither)(THIS_ BOOL) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetTextureQuality)(THIS_ D3DRMTEXTUREQUALITY) PURE;

    STDMETHOD(GetViewports)(THIS_ LPDIRECT3DRMVIEWPORTARRAY *return_views) PURE;

    STDMETHOD_(BOOL, GetDither)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetTrianglesDrawn)(THIS) PURE;
    STDMETHOD_(DWORD, GetWireframeOptions)(THIS) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(D3DCOLORMODEL, GetColorModel)(THIS) PURE;
    STDMETHOD_(D3DRMTEXTUREQUALITY, GetTextureQuality)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice)(THIS_ LPDIRECT3DDEVICE *) PURE;

    /*
     * IDirect3DRMDevice2 methods
     */
    STDMETHOD(InitFromD3D2)(THIS_ LPDIRECT3D2 lpD3D, LPDIRECT3DDEVICE2 lpD3DDev) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPGUID lpGUID, LPDIRECTDRAW lpDD, LPDIRECTDRAWSURFACE lpDDSBack, DWORD dwFlags) PURE;
    STDMETHOD(SetRenderMode)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD_(DWORD, GetRenderMode)(THIS) PURE;
    STDMETHOD(GetDirect3DDevice2)(THIS_ LPDIRECT3DDEVICE2 *) PURE;

    /*
     * IDirect3DRMDevice3 methods
     */
    STDMETHOD(FindPreferredTextureFormat)(THIS_ DWORD dwBitDepths, DWORD dwFlags, LPDDPIXELFORMAT lpDDPF) PURE;
    STDMETHOD(RenderStateChange)(THIS_ D3DRENDERSTATETYPE drsType, DWORD dwVal, DWORD dwFlags) PURE;
    STDMETHOD(LightStateChange)(THIS_ D3DLIGHTSTATETYPE drsType, DWORD dwVal, DWORD dwFlags) PURE;
    STDMETHOD(GetStateChangeOptions)(THIS_ DWORD dwStateClass, DWORD dwStateNum, LPDWORD pdwFlags) PURE;
    STDMETHOD(SetStateChangeOptions)(THIS_ DWORD dwStateClass, DWORD dwStateNum, DWORD dwFlags) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMViewport

DECLARE_INTERFACE_(IDirect3DRMViewport, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMViewport methods
     */
    STDMETHOD(Init)
    (	THIS_ LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMFRAME camera,
	DWORD xpos, DWORD ypos, DWORD width, DWORD height
    ) PURE;
    STDMETHOD(Clear)(THIS) PURE;
    STDMETHOD(Render)(THIS_ LPDIRECT3DRMFRAME) PURE;

    STDMETHOD(SetFront)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetBack)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetField)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetUniformScaling)(THIS_ BOOL) PURE;
    STDMETHOD(SetCamera)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(SetProjection)(THIS_ D3DRMPROJECTIONTYPE) PURE;
    STDMETHOD(Transform)(THIS_ D3DRMVECTOR4D *d, D3DVECTOR *s) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DRMVECTOR4D *s) PURE;
    STDMETHOD(Configure)(THIS_ LONG x, LONG y, DWORD width, DWORD height) PURE;
    STDMETHOD(ForceUpdate)(THIS_ DWORD x1, DWORD y1, DWORD x2, DWORD y2) PURE;
    STDMETHOD(SetPlane)(THIS_ D3DVALUE left, D3DVALUE right, D3DVALUE bottom, D3DVALUE top) PURE;

    STDMETHOD(GetCamera)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DRMDEVICE *) PURE;
    STDMETHOD(GetPlane)(THIS_ D3DVALUE *left, D3DVALUE *right, D3DVALUE *bottom, D3DVALUE *top) PURE;
    STDMETHOD(Pick)(THIS_ LONG x, LONG y, LPDIRECT3DRMPICKEDARRAY *return_visuals) PURE;

    STDMETHOD_(BOOL, GetUniformScaling)(THIS) PURE;
    STDMETHOD_(LONG, GetX)(THIS) PURE;
    STDMETHOD_(LONG, GetY)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetField)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetBack)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetFront)(THIS) PURE;
    STDMETHOD_(D3DRMPROJECTIONTYPE, GetProjection)(THIS) PURE;
    STDMETHOD(GetDirect3DViewport)(THIS_ LPDIRECT3DVIEWPORT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMViewport2
DECLARE_INTERFACE_(IDirect3DRMViewport2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMViewport2 methods
     */
    STDMETHOD(Init)
    (	THIS_ LPDIRECT3DRMDEVICE3 dev, LPDIRECT3DRMFRAME3 camera,
	DWORD xpos, DWORD ypos, DWORD width, DWORD height
    ) PURE;
    STDMETHOD(Clear)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Render)(THIS_ LPDIRECT3DRMFRAME3) PURE;

    STDMETHOD(SetFront)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetBack)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetField)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetUniformScaling)(THIS_ BOOL) PURE;
    STDMETHOD(SetCamera)(THIS_ LPDIRECT3DRMFRAME3) PURE;
    STDMETHOD(SetProjection)(THIS_ D3DRMPROJECTIONTYPE) PURE;
    STDMETHOD(Transform)(THIS_ D3DRMVECTOR4D *d, D3DVECTOR *s) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DRMVECTOR4D *s) PURE;
    STDMETHOD(Configure)(THIS_ LONG x, LONG y, DWORD width, DWORD height) PURE;
    STDMETHOD(ForceUpdate)(THIS_ DWORD x1, DWORD y1, DWORD x2, DWORD y2) PURE;
    STDMETHOD(SetPlane)(THIS_ D3DVALUE left, D3DVALUE right, D3DVALUE bottom, D3DVALUE top) PURE;

    STDMETHOD(GetCamera)(THIS_ LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD(GetDevice)(THIS_ LPDIRECT3DRMDEVICE3 *) PURE;
    STDMETHOD(GetPlane)(THIS_ D3DVALUE *left, D3DVALUE *right, D3DVALUE *bottom, D3DVALUE *top) PURE;
    STDMETHOD(Pick)(THIS_ LONG x, LONG y, LPDIRECT3DRMPICKEDARRAY *return_visuals) PURE;

    STDMETHOD_(BOOL, GetUniformScaling)(THIS) PURE;
    STDMETHOD_(LONG, GetX)(THIS) PURE;
    STDMETHOD_(LONG, GetY)(THIS) PURE;
    STDMETHOD_(DWORD, GetWidth)(THIS) PURE;
    STDMETHOD_(DWORD, GetHeight)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetField)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetBack)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetFront)(THIS) PURE;
    STDMETHOD_(D3DRMPROJECTIONTYPE, GetProjection)(THIS) PURE;
    STDMETHOD(GetDirect3DViewport)(THIS_ LPDIRECT3DVIEWPORT *) PURE;
    STDMETHOD(TransformVectors)(THIS_ DWORD dwNumVectors,
				LPD3DRMVECTOR4D lpDstVectors,
				LPD3DVECTOR lpSrcVectors) PURE;
    STDMETHOD(InverseTransformVectors)(THIS_ DWORD dwNumVectors,
				       LPD3DVECTOR lpDstVectors,
				       LPD3DRMVECTOR4D lpSrcVectors) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrame

DECLARE_INTERFACE_(IDirect3DRMFrame, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFrame methods
     */
    STDMETHOD(AddChild)(THIS_ LPDIRECT3DRMFRAME child) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(AddMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(AddTransform)(THIS_ D3DRMCOMBINETYPE, D3DRMMATRIX4D) PURE;
    STDMETHOD(AddTranslation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScale)(THIS_ D3DRMCOMBINETYPE, D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(AddRotation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(AddVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD(GetChildren)(THIS_ LPDIRECT3DRMFRAMEARRAY *children) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD(GetLights)(THIS_ LPDIRECT3DRMLIGHTARRAY *lights) PURE;
    STDMETHOD_(D3DRMMATERIALMODE, GetMaterialMode)(THIS) PURE;
    STDMETHOD(GetParent)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(GetPosition)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_position) PURE;
    STDMETHOD(GetRotation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR axis, LPD3DVALUE return_theta) PURE;
    STDMETHOD(GetScene)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD_(D3DRMSORTMODE, GetSortMode)(THIS) PURE;
    STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DRMMATRIX4D return_matrix) PURE;
    STDMETHOD(GetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_velocity, BOOL with_rotation) PURE;
    STDMETHOD(GetOrientation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR dir, LPD3DVECTOR up) PURE;
    STDMETHOD(GetVisuals)(THIS_ LPDIRECT3DRMVISUALARRAY *visuals) PURE;
    STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg)PURE;
    STDMETHOD(LookAt)(THIS_ LPDIRECT3DRMFRAME target, LPDIRECT3DRMFRAME reference, D3DRMFRAMECONSTRAINT) PURE;
    STDMETHOD(Move)(THIS_ D3DVALUE delta) PURE;
    STDMETHOD(DeleteChild)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(DeleteMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(DeleteVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneBackground)(THIS) PURE;
    STDMETHOD(GetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneFogColor)(THIS) PURE;
    STDMETHOD_(BOOL, GetSceneFogEnable)(THIS) PURE;
    STDMETHOD_(D3DRMFOGMODE, GetSceneFogMode)(THIS) PURE;
    STDMETHOD(GetSceneFogParams)(THIS_ D3DVALUE *return_start, D3DVALUE *return_end, D3DVALUE *return_density) PURE;
    STDMETHOD(SetSceneBackground)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneBackgroundRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(SetSceneBackgroundImage)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetSceneFogEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetSceneFogColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneFogMode)(THIS_ D3DRMFOGMODE) PURE;
    STDMETHOD(SetSceneFogParams)(THIS_ D3DVALUE start, D3DVALUE end, D3DVALUE density) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD_(D3DRMZBUFFERMODE, GetZbufferMode)(THIS) PURE;
    STDMETHOD(SetMaterialMode)(THIS_ D3DRMMATERIALMODE) PURE;
    STDMETHOD(SetOrientation)
    (	THIS_ LPDIRECT3DRMFRAME reference,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz
    ) PURE;
    STDMETHOD(SetPosition)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetRotation)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(SetSortMode)(THIS_ D3DRMSORTMODE) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, BOOL with_rotation) PURE;
    STDMETHOD(SetZbufferMode)(THIS_ D3DRMZBUFFERMODE) PURE;
    STDMETHOD(Transform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrame2

DECLARE_INTERFACE_(IDirect3DRMFrame2, IDirect3DRMFrame)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFrame methods
     */
    STDMETHOD(AddChild)(THIS_ LPDIRECT3DRMFRAME child) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(AddMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(AddTransform)(THIS_ D3DRMCOMBINETYPE, D3DRMMATRIX4D) PURE;
    STDMETHOD(AddTranslation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScale)(THIS_ D3DRMCOMBINETYPE, D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(AddRotation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(AddVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD(GetChildren)(THIS_ LPDIRECT3DRMFRAMEARRAY *children) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD(GetLights)(THIS_ LPDIRECT3DRMLIGHTARRAY *lights) PURE;
    STDMETHOD_(D3DRMMATERIALMODE, GetMaterialMode)(THIS) PURE;
    STDMETHOD(GetParent)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD(GetPosition)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_position) PURE;
    STDMETHOD(GetRotation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR axis, LPD3DVALUE return_theta) PURE;
    STDMETHOD(GetScene)(THIS_ LPDIRECT3DRMFRAME *) PURE;
    STDMETHOD_(D3DRMSORTMODE, GetSortMode)(THIS) PURE;
    STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE *) PURE;
    STDMETHOD(GetTransform)(THIS_ D3DRMMATRIX4D return_matrix) PURE;
    STDMETHOD(GetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR return_velocity, BOOL with_rotation) PURE;
    STDMETHOD(GetOrientation)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DVECTOR dir, LPD3DVECTOR up) PURE;
    STDMETHOD(GetVisuals)(THIS_ LPDIRECT3DRMVISUALARRAY *visuals) PURE;
    STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg)PURE;
    STDMETHOD(LookAt)(THIS_ LPDIRECT3DRMFRAME target, LPDIRECT3DRMFRAME reference, D3DRMFRAMECONSTRAINT) PURE;
    STDMETHOD(Move)(THIS_ D3DVALUE delta) PURE;
    STDMETHOD(DeleteChild)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(DeleteMoveCallback)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(DeleteVisual)(THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneBackground)(THIS) PURE;
    STDMETHOD(GetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneFogColor)(THIS) PURE;
    STDMETHOD_(BOOL, GetSceneFogEnable)(THIS) PURE;
    STDMETHOD_(D3DRMFOGMODE, GetSceneFogMode)(THIS) PURE;
    STDMETHOD(GetSceneFogParams)(THIS_ D3DVALUE *return_start, D3DVALUE *return_end, D3DVALUE *return_density) PURE;
    STDMETHOD(SetSceneBackground)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneBackgroundRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(SetSceneBackgroundImage)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetSceneFogEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetSceneFogColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneFogMode)(THIS_ D3DRMFOGMODE) PURE;
    STDMETHOD(SetSceneFogParams)(THIS_ D3DVALUE start, D3DVALUE end, D3DVALUE density) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD_(D3DRMZBUFFERMODE, GetZbufferMode)(THIS) PURE;
    STDMETHOD(SetMaterialMode)(THIS_ D3DRMMATERIALMODE) PURE;
    STDMETHOD(SetOrientation)
    (	THIS_ LPDIRECT3DRMFRAME reference,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz
    ) PURE;
    STDMETHOD(SetPosition)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetRotation)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(SetSortMode)(THIS_ D3DRMSORTMODE) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetVelocity)(THIS_ LPDIRECT3DRMFRAME reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, BOOL with_rotation) PURE;
    STDMETHOD(SetZbufferMode)(THIS_ D3DRMZBUFFERMODE) PURE;
    STDMETHOD(Transform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;

    /*
     * IDirect3DRMFrame2 methods
     */
    STDMETHOD(AddMoveCallback2)(THIS_ D3DRMFRAMEMOVECALLBACK, VOID *arg, DWORD dwFlags) PURE;
    STDMETHOD(GetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD_(BOOL, GetBoxEnable)(THIS) PURE;
    STDMETHOD(GetAxes)(THIS_ LPD3DVECTOR dir, LPD3DVECTOR up);
    STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL *) PURE;
    STDMETHOD_(BOOL, GetInheritAxes)(THIS);
    STDMETHOD(GetHierarchyBox)(THIS_ LPD3DRMBOX) PURE;

    STDMETHOD(SetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD(SetBoxEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetAxes)(THIS_ D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
		       D3DVALUE ux, D3DVALUE uy, D3DVALUE uz);
    STDMETHOD(SetInheritAxes)(THIS_ BOOL inherit_from_parent);
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
    STDMETHOD(SetQuaternion)(THIS_ LPDIRECT3DRMFRAME reference, D3DRMQUATERNION *q) PURE;

    STDMETHOD(RayPick)(THIS_ LPDIRECT3DRMFRAME reference, LPD3DRMRAY ray, DWORD dwFlags, LPDIRECT3DRMPICKED2ARRAY *return_visuals) PURE;
    STDMETHOD(Save)(THIS_ LPCSTR filename, D3DRMXOFFORMAT d3dFormat, 
		    D3DRMSAVEOPTIONS d3dSaveFlags);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrame3

DECLARE_INTERFACE_(IDirect3DRMFrame3, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFrame3 methods
     */
    STDMETHOD(AddChild)(THIS_ LPDIRECT3DRMFRAME3 child) PURE;
    STDMETHOD(AddLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(AddMoveCallback)(THIS_ D3DRMFRAME3MOVECALLBACK, VOID *arg, DWORD dwFlags) PURE;
    STDMETHOD(AddTransform)(THIS_ D3DRMCOMBINETYPE, D3DRMMATRIX4D) PURE;
    STDMETHOD(AddTranslation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScale)(THIS_ D3DRMCOMBINETYPE, D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(AddRotation)(THIS_ D3DRMCOMBINETYPE, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(AddVisual)(THIS_ LPUNKNOWN) PURE;
    STDMETHOD(GetChildren)(THIS_ LPDIRECT3DRMFRAMEARRAY *children) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD(GetLights)(THIS_ LPDIRECT3DRMLIGHTARRAY *lights) PURE;
    STDMETHOD_(D3DRMMATERIALMODE, GetMaterialMode)(THIS) PURE;
    STDMETHOD(GetParent)(THIS_ LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD(GetPosition)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR return_position) PURE;
    STDMETHOD(GetRotation)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR axis, LPD3DVALUE return_theta) PURE;
    STDMETHOD(GetScene)(THIS_ LPDIRECT3DRMFRAME3 *) PURE;
    STDMETHOD_(D3DRMSORTMODE, GetSortMode)(THIS) PURE;
    STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE3 *) PURE;
    STDMETHOD(GetTransform)(THIS_ LPDIRECT3DRMFRAME3 reference,
			     D3DRMMATRIX4D rmMatrix) PURE;
    STDMETHOD(GetVelocity)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR return_velocity, BOOL with_rotation) PURE;
    STDMETHOD(GetOrientation)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DVECTOR dir, LPD3DVECTOR up) PURE;
    STDMETHOD(GetVisuals)(THIS_ LPDWORD lpdwCount, LPUNKNOWN *) PURE;
    STDMETHOD(InverseTransform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURE3CALLBACK, LPVOID lpArg)PURE;
    STDMETHOD(LookAt)(THIS_ LPDIRECT3DRMFRAME3 target, LPDIRECT3DRMFRAME3 reference, D3DRMFRAMECONSTRAINT) PURE;
    STDMETHOD(Move)(THIS_ D3DVALUE delta) PURE;
    STDMETHOD(DeleteChild)(THIS_ LPDIRECT3DRMFRAME3) PURE;
    STDMETHOD(DeleteLight)(THIS_ LPDIRECT3DRMLIGHT) PURE;
    STDMETHOD(DeleteMoveCallback)(THIS_ D3DRMFRAME3MOVECALLBACK, VOID *arg) PURE;
    STDMETHOD(DeleteVisual)(THIS_ LPUNKNOWN) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneBackground)(THIS) PURE;
    STDMETHOD(GetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE *) PURE;
    STDMETHOD_(D3DCOLOR, GetSceneFogColor)(THIS) PURE;
    STDMETHOD_(BOOL, GetSceneFogEnable)(THIS) PURE;
    STDMETHOD_(D3DRMFOGMODE, GetSceneFogMode)(THIS) PURE;
    STDMETHOD(GetSceneFogParams)(THIS_ D3DVALUE *return_start, D3DVALUE *return_end, D3DVALUE *return_density) PURE;
    STDMETHOD(SetSceneBackground)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneBackgroundRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetSceneBackgroundDepth)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(SetSceneBackgroundImage)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
    STDMETHOD(SetSceneFogEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetSceneFogColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetSceneFogMode)(THIS_ D3DRMFOGMODE) PURE;
    STDMETHOD(SetSceneFogParams)(THIS_ D3DVALUE start, D3DVALUE end, D3DVALUE density) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD_(D3DRMZBUFFERMODE, GetZbufferMode)(THIS) PURE;
    STDMETHOD(SetMaterialMode)(THIS_ D3DRMMATERIALMODE) PURE;
    STDMETHOD(SetOrientation)
    (	THIS_ LPDIRECT3DRMFRAME3 reference,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz
    ) PURE;
    STDMETHOD(SetPosition)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetRotation)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, D3DVALUE theta) PURE;
    STDMETHOD(SetSortMode)(THIS_ D3DRMSORTMODE) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
    STDMETHOD(SetVelocity)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DVALUE x, D3DVALUE y, D3DVALUE z, BOOL with_rotation) PURE;
    STDMETHOD(SetZbufferMode)(THIS_ D3DRMZBUFFERMODE) PURE;
    STDMETHOD(Transform)(THIS_ D3DVECTOR *d, D3DVECTOR *s) PURE;
    STDMETHOD(GetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD_(BOOL, GetBoxEnable)(THIS) PURE;
    STDMETHOD(GetAxes)(THIS_ LPD3DVECTOR dir, LPD3DVECTOR up);
    STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2 *) PURE;
    STDMETHOD_(BOOL, GetInheritAxes)(THIS);
    STDMETHOD(GetHierarchyBox)(THIS_ LPD3DRMBOX) PURE;

    STDMETHOD(SetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD(SetBoxEnable)(THIS_ BOOL) PURE;
    STDMETHOD(SetAxes)(THIS_ D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
		       D3DVALUE ux, D3DVALUE uy, D3DVALUE uz);
    STDMETHOD(SetInheritAxes)(THIS_ BOOL inherit_from_parent);
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2) PURE;
    STDMETHOD(SetQuaternion)(THIS_ LPDIRECT3DRMFRAME3 reference, D3DRMQUATERNION *q) PURE;

    STDMETHOD(RayPick)(THIS_ LPDIRECT3DRMFRAME3 reference, LPD3DRMRAY ray, DWORD dwFlags, LPDIRECT3DRMPICKED2ARRAY *return_visuals) PURE;
    STDMETHOD(Save)(THIS_ LPCSTR filename, D3DRMXOFFORMAT d3dFormat, 
		    D3DRMSAVEOPTIONS d3dSaveFlags);
    STDMETHOD(TransformVectors)(THIS_ LPDIRECT3DRMFRAME3 reference,
				DWORD dwNumVectors,
				LPD3DVECTOR lpDstVectors,
				LPD3DVECTOR lpSrcVectors) PURE;
    STDMETHOD(InverseTransformVectors)(THIS_ LPDIRECT3DRMFRAME3 reference,
				       DWORD dwNumVectors,
				       LPD3DVECTOR lpDstVectors,
				       LPD3DVECTOR lpSrcVectors) PURE;
    STDMETHOD(SetTraversalOptions)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(GetTraversalOptions)(THIS_ LPDWORD lpdwFlags) PURE;
    STDMETHOD(SetSceneFogMethod)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(GetSceneFogMethod)(THIS_ LPDWORD lpdwFlags) PURE;
    STDMETHOD(SetMaterialOverride)(THIS_ LPD3DRMMATERIALOVERRIDE) PURE;
    STDMETHOD(GetMaterialOverride)(THIS_ LPD3DRMMATERIALOVERRIDE) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMesh

DECLARE_INTERFACE_(IDirect3DRMMesh, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMesh methods
     */
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(AddGroup)(THIS_ unsigned vCount, unsigned fCount, unsigned vPerFace, unsigned *fData, D3DRMGROUPINDEX *returnId) PURE;
    STDMETHOD(SetVertices)(THIS_ D3DRMGROUPINDEX id, unsigned index, unsigned count, D3DRMVERTEX *values) PURE;
    STDMETHOD(SetGroupColor)(THIS_ D3DRMGROUPINDEX id, D3DCOLOR value) PURE;
    STDMETHOD(SetGroupColorRGB)(THIS_ D3DRMGROUPINDEX id, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetGroupMapping)(THIS_ D3DRMGROUPINDEX id, D3DRMMAPPING value) PURE;
    STDMETHOD(SetGroupQuality)(THIS_ D3DRMGROUPINDEX id, D3DRMRENDERQUALITY value) PURE;
    STDMETHOD(SetGroupMaterial)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMMATERIAL value) PURE;
    STDMETHOD(SetGroupTexture)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMTEXTURE value) PURE;

    STDMETHOD_(unsigned, GetGroupCount)(THIS) PURE;
    STDMETHOD(GetGroup)(THIS_ D3DRMGROUPINDEX id, unsigned *vCount, unsigned *fCount, unsigned *vPerFace, DWORD *fDataSize, unsigned *fData) PURE;
    STDMETHOD(GetVertices)(THIS_ D3DRMGROUPINDEX id, DWORD index, DWORD count, D3DRMVERTEX *returnPtr) PURE;
    STDMETHOD_(D3DCOLOR, GetGroupColor)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD_(D3DRMMAPPING, GetGroupMapping)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetGroupQuality)(THIS_ D3DRMGROUPINDEX id) PURE;
    STDMETHOD(GetGroupMaterial)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMMATERIAL *returnPtr) PURE;
    STDMETHOD(GetGroupTexture)(THIS_ D3DRMGROUPINDEX id, LPDIRECT3DRMTEXTURE *returnPtr) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMProgressiveMesh

DECLARE_INTERFACE_(IDirect3DRMProgressiveMesh, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMProgressiveMesh methods
     */
    STDMETHOD(Load) (THIS_ LPVOID lpObjLocation, LPVOID lpObjId, 
		     D3DRMLOADOPTIONS dloLoadflags, D3DRMLOADTEXTURECALLBACK lpCallback,
		     LPVOID lpArg) PURE;
    STDMETHOD(GetLoadStatus) (THIS_ LPD3DRMPMESHLOADSTATUS lpStatus) PURE;
    STDMETHOD(SetMinRenderDetail) (THIS_ D3DVALUE d3dVal) PURE;
    STDMETHOD(Abort) (THIS_ DWORD dwFlags) PURE;
    
    STDMETHOD(GetFaceDetail) (THIS_ LPDWORD lpdwCount) PURE;
    STDMETHOD(GetVertexDetail) (THIS_ LPDWORD lpdwCount) PURE;
    STDMETHOD(SetFaceDetail) (THIS_ DWORD dwCount) PURE;
    STDMETHOD(SetVertexDetail) (THIS_ DWORD dwCount) PURE;
    STDMETHOD(GetFaceDetailRange) (THIS_ LPDWORD lpdwMin, LPDWORD lpdwMax) PURE;
    STDMETHOD(GetVertexDetailRange) (THIS_ LPDWORD lpdwMin, LPDWORD lpdwMax) PURE;
    STDMETHOD(GetDetail) (THIS_ D3DVALUE *lpdvVal) PURE;
    STDMETHOD(SetDetail) (THIS_ D3DVALUE d3dVal) PURE;

    STDMETHOD(RegisterEvents) (THIS_ HANDLE hEvent, DWORD dwFlags, DWORD dwReserved) PURE;
    STDMETHOD(CreateMesh) (THIS_ LPDIRECT3DRMMESH *lplpD3DRMMesh) PURE;
    STDMETHOD(Duplicate) (THIS_ LPDIRECT3DRMPROGRESSIVEMESH *lplpD3DRMPMesh) PURE;
    STDMETHOD(GetBox) (THIS_ LPD3DRMBOX lpBBox) PURE;
    STDMETHOD(SetQuality) (THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(GetQuality) (THIS_ LPD3DRMRENDERQUALITY lpdwquality) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMShadow

DECLARE_INTERFACE_(IDirect3DRMShadow, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMShadow methods
     */
    STDMETHOD(Init)
    (	THIS_ LPDIRECT3DRMVISUAL visual, LPDIRECT3DRMLIGHT light,
	D3DVALUE px, D3DVALUE py, D3DVALUE pz,
	D3DVALUE nx, D3DVALUE ny, D3DVALUE nz
    ) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMShadow2

DECLARE_INTERFACE_(IDirect3DRMShadow2, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMShadow methods
     */
    STDMETHOD(Init)
    (	THIS_ LPUNKNOWN pUNK, LPDIRECT3DRMLIGHT light,
	D3DVALUE px, D3DVALUE py, D3DVALUE pz,
	D3DVALUE nx, D3DVALUE ny, D3DVALUE nz
    ) PURE;

    /*
     * IDirect3DRMShadow2 methods
     */
    STDMETHOD(GetVisual)(THIS_ LPDIRECT3DRMVISUAL *) PURE;
    STDMETHOD(SetVisual)(THIS_ LPUNKNOWN pUNK, DWORD) PURE;
    STDMETHOD(GetLight)(THIS_ LPDIRECT3DRMLIGHT *) PURE;
    STDMETHOD(SetLight)(THIS_ LPDIRECT3DRMLIGHT, DWORD) PURE;
    STDMETHOD(GetPlane)(THIS_ LPD3DVALUE px, LPD3DVALUE py, LPD3DVALUE pz,
			LPD3DVALUE nx, LPD3DVALUE ny, LPD3DVALUE nz) PURE;
    STDMETHOD(SetPlane)(THIS_ D3DVALUE px, D3DVALUE py, D3DVALUE pz,
			D3DVALUE nx, D3DVALUE ny, D3DVALUE nz, DWORD) PURE;
    STDMETHOD(GetOptions)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetOptions)(THIS_ DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFace

DECLARE_INTERFACE_(IDirect3DRMFace, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFace methods
     */
     STDMETHOD(AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
     STDMETHOD(AddVertexAndNormalIndexed)(THIS_ DWORD vertex, DWORD normal) PURE;
     STDMETHOD(SetColorRGB)(THIS_ D3DVALUE, D3DVALUE, D3DVALUE) PURE;
     STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
     STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
     STDMETHOD(SetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE u, D3DVALUE v) PURE;
     STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
     STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;

     STDMETHOD(GetVertex)(THIS_ DWORD index, D3DVECTOR *vertex, D3DVECTOR *normal) PURE;
     STDMETHOD(GetVertices)(THIS_ DWORD *vertex_count, D3DVECTOR *coords, D3DVECTOR *normals);
     STDMETHOD(GetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE *u, D3DVALUE *v) PURE;
     STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
     STDMETHOD(GetNormal)(THIS_ D3DVECTOR *) PURE;
     STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE *) PURE;
     STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL *) PURE;

     STDMETHOD_(int, GetVertexCount)(THIS) PURE;
     STDMETHOD_(int, GetVertexIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(int, GetTextureCoordinateIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFace2

DECLARE_INTERFACE_(IDirect3DRMFace2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMFace methods
     */
     STDMETHOD(AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
     STDMETHOD(AddVertexAndNormalIndexed)(THIS_ DWORD vertex, DWORD normal) PURE;
     STDMETHOD(SetColorRGB)(THIS_ D3DVALUE, D3DVALUE, D3DVALUE) PURE;
     STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
     STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
     STDMETHOD(SetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE u, D3DVALUE v) PURE;
     STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2) PURE;
     STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;

     STDMETHOD(GetVertex)(THIS_ DWORD index, D3DVECTOR *vertex, D3DVECTOR *normal) PURE;
     STDMETHOD(GetVertices)(THIS_ DWORD *vertex_count, D3DVECTOR *coords, D3DVECTOR *normals);
     STDMETHOD(GetTextureCoordinates)(THIS_ DWORD vertex, D3DVALUE *u, D3DVALUE *v) PURE;
     STDMETHOD(GetTextureTopology)(THIS_ BOOL *wrap_u, BOOL *wrap_v) PURE;
     STDMETHOD(GetNormal)(THIS_ D3DVECTOR *) PURE;
     STDMETHOD(GetTexture)(THIS_ LPDIRECT3DRMTEXTURE3 *) PURE;
     STDMETHOD(GetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2 *) PURE;

     STDMETHOD_(int, GetVertexCount)(THIS) PURE;
     STDMETHOD_(int, GetVertexIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(int, GetTextureCoordinateIndex)(THIS_ DWORD which) PURE;
     STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMeshBuilder

DECLARE_INTERFACE_(IDirect3DRMMeshBuilder, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMeshBuilder methods
     */
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg) PURE;
    STDMETHOD(Save)(THIS_ const char *filename, D3DRMXOFFORMAT, D3DRMSAVEOPTIONS save) PURE;
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(SetColorSource)(THIS_ D3DRMCOLORSOURCE) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(GenerateNormals)(THIS) PURE;
    STDMETHOD_(D3DRMCOLORSOURCE, GetColorSource)(THIS) PURE;

    STDMETHOD(AddMesh)(THIS_ LPDIRECT3DRMMESH) PURE;
    STDMETHOD(AddMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER) PURE;
    STDMETHOD(AddFrame)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(AddFace)(THIS_ LPDIRECT3DRMFACE) PURE;
    STDMETHOD(AddFaces)
    (	THIS_ DWORD vcount, D3DVECTOR *vertices, DWORD ncount, D3DVECTOR *normals,
	DWORD *data, LPDIRECT3DRMFACEARRAY*
    ) PURE;
    STDMETHOD(ReserveSpace)(THIS_ DWORD vertex_Count, DWORD normal_count, DWORD face_count) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetPerspective)(THIS_ BOOL) PURE;
    STDMETHOD(SetVertex)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetNormal)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetTextureCoordinates)(THIS_ DWORD index, D3DVALUE u, D3DVALUE v) PURE;
    STDMETHOD(SetVertexColor)(THIS_ DWORD index, D3DCOLOR) PURE;
    STDMETHOD(SetVertexColorRGB)(THIS_ DWORD index, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;

    STDMETHOD(GetFaces)(THIS_ LPDIRECT3DRMFACEARRAY*) PURE;
    STDMETHOD(GetVertices)
    (	THIS_ DWORD *vcount, D3DVECTOR *vertices, DWORD *ncount, D3DVECTOR *normals, DWORD *face_data_size, DWORD *face_data
    ) PURE;
    STDMETHOD(GetTextureCoordinates)(THIS_ DWORD index, D3DVALUE *u, D3DVALUE *v) PURE;

    STDMETHOD_(int, AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD_(int, AddNormal)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(CreateFace)(THIS_ LPDIRECT3DRMFACE*) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(BOOL, GetPerspective)(THIS) PURE;
    STDMETHOD_(int, GetFaceCount)(THIS) PURE;
    STDMETHOD_(int, GetVertexCount)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetVertexColor)(THIS_ DWORD index) PURE;

    STDMETHOD(CreateMesh)(THIS_ LPDIRECT3DRMMESH*) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMeshBuilder2

DECLARE_INTERFACE_(IDirect3DRMMeshBuilder2, IDirect3DRMMeshBuilder)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMeshBuilder methods
     */
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg) PURE;
    STDMETHOD(Save)(THIS_ const char *filename, D3DRMXOFFORMAT, D3DRMSAVEOPTIONS save) PURE;
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(SetColorSource)(THIS_ D3DRMCOLORSOURCE) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(GenerateNormals)(THIS) PURE;
    STDMETHOD_(D3DRMCOLORSOURCE, GetColorSource)(THIS) PURE;

    STDMETHOD(AddMesh)(THIS_ LPDIRECT3DRMMESH) PURE;
    STDMETHOD(AddMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER) PURE;
    STDMETHOD(AddFrame)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(AddFace)(THIS_ LPDIRECT3DRMFACE) PURE;
    STDMETHOD(AddFaces)
    (	THIS_ DWORD vcount, D3DVECTOR *vertices, DWORD ncount, D3DVECTOR *normals,
	DWORD *data, LPDIRECT3DRMFACEARRAY*
    ) PURE;
    STDMETHOD(ReserveSpace)(THIS_ DWORD vertex_Count, DWORD normal_count, DWORD face_count) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetPerspective)(THIS_ BOOL) PURE;
    STDMETHOD(SetVertex)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetNormal)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetTextureCoordinates)(THIS_ DWORD index, D3DVALUE u, D3DVALUE v) PURE;
    STDMETHOD(SetVertexColor)(THIS_ DWORD index, D3DCOLOR) PURE;
    STDMETHOD(SetVertexColorRGB)(THIS_ DWORD index, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;

    STDMETHOD(GetFaces)(THIS_ LPDIRECT3DRMFACEARRAY*) PURE;
    STDMETHOD(GetVertices)
    (	THIS_ DWORD *vcount, D3DVECTOR *vertices, DWORD *ncount, D3DVECTOR *normals, DWORD *face_data_size, DWORD *face_data
    ) PURE;
    STDMETHOD(GetTextureCoordinates)(THIS_ DWORD index, D3DVALUE *u, D3DVALUE *v) PURE;

    STDMETHOD_(int, AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD_(int, AddNormal)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(CreateFace)(THIS_ LPDIRECT3DRMFACE*) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(BOOL, GetPerspective)(THIS) PURE;
    STDMETHOD_(int, GetFaceCount)(THIS) PURE;
    STDMETHOD_(int, GetVertexCount)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetVertexColor)(THIS_ DWORD index) PURE;

    STDMETHOD(CreateMesh)(THIS_ LPDIRECT3DRMMESH*) PURE;

    /*
     * IDirect3DRMMeshBuilder2 methods
     */
    STDMETHOD(GenerateNormals2)(THIS_ D3DVALUE crease, DWORD dwFlags) PURE;
    STDMETHOD(GetFace)(THIS_ DWORD index, LPDIRECT3DRMFACE*) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMeshBuilder3

DECLARE_INTERFACE_(IDirect3DRMMeshBuilder3, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMeshBuilder3 methods
     */
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURE3CALLBACK, LPVOID lpArg) PURE;
    STDMETHOD(Save)(THIS_ const char *filename, D3DRMXOFFORMAT, D3DRMSAVEOPTIONS save) PURE;
    STDMETHOD(Scale)(THIS_ D3DVALUE sx, D3DVALUE sy, D3DVALUE sz) PURE;
    STDMETHOD(Translate)(THIS_ D3DVALUE tx, D3DVALUE ty, D3DVALUE tz) PURE;
    STDMETHOD(SetColorSource)(THIS_ D3DRMCOLORSOURCE) PURE;
    STDMETHOD(GetBox)(THIS_ D3DRMBOX *) PURE;
    STDMETHOD(GenerateNormals)(THIS_ D3DVALUE crease, DWORD dwFlags) PURE;
    STDMETHOD_(D3DRMCOLORSOURCE, GetColorSource)(THIS) PURE;

    STDMETHOD(AddMesh)(THIS_ LPDIRECT3DRMMESH) PURE;
    STDMETHOD(AddMeshBuilder)(THIS_ LPDIRECT3DRMMESHBUILDER3, DWORD dwFlags) PURE;
    STDMETHOD(AddFrame)(THIS_ LPDIRECT3DRMFRAME3) PURE;
    STDMETHOD(AddFace)(THIS_ LPDIRECT3DRMFACE2) PURE;
    STDMETHOD(AddFaces)
    (	THIS_ DWORD vcount, D3DVECTOR *vertices, DWORD ncount, D3DVECTOR *normals,
	DWORD *data, LPDIRECT3DRMFACEARRAY*
    ) PURE;
    STDMETHOD(ReserveSpace)(THIS_ DWORD vertex_Count, DWORD normal_count, DWORD face_count) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetTexture)(THIS_ LPDIRECT3DRMTEXTURE3) PURE;
    STDMETHOD(SetMaterial)(THIS_ LPDIRECT3DRMMATERIAL2) PURE;
    STDMETHOD(SetTextureTopology)(THIS_ BOOL wrap_u, BOOL wrap_v) PURE;
    STDMETHOD(SetQuality)(THIS_ D3DRMRENDERQUALITY) PURE;
    STDMETHOD(SetPerspective)(THIS_ BOOL) PURE;
    STDMETHOD(SetVertex)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetNormal)(THIS_ DWORD index, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(SetTextureCoordinates)(THIS_ DWORD index, D3DVALUE u, D3DVALUE v) PURE;
    STDMETHOD(SetVertexColor)(THIS_ DWORD index, D3DCOLOR) PURE;
    STDMETHOD(SetVertexColorRGB)(THIS_ DWORD index, D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(GetFaces)(THIS_ LPDIRECT3DRMFACEARRAY*) PURE;
    STDMETHOD(GetGeometry)
    (	THIS_ DWORD *vcount, D3DVECTOR *vertices, DWORD *ncount, D3DVECTOR *normals, DWORD *face_data_size, DWORD *face_data
    ) PURE;
    STDMETHOD(GetTextureCoordinates)(THIS_ DWORD index, D3DVALUE *u, D3DVALUE *v) PURE;
    STDMETHOD_(int, AddVertex)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD_(int, AddNormal)(THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(CreateFace)(THIS_ LPDIRECT3DRMFACE2 *) PURE;
    STDMETHOD_(D3DRMRENDERQUALITY, GetQuality)(THIS) PURE;
    STDMETHOD_(BOOL, GetPerspective)(THIS) PURE;
    STDMETHOD_(int, GetFaceCount)(THIS) PURE;
    STDMETHOD_(int, GetVertexCount)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetVertexColor)(THIS_ DWORD index) PURE;
    STDMETHOD(CreateMesh)(THIS_ LPDIRECT3DRMMESH*) PURE;
    STDMETHOD(GetFace)(THIS_ DWORD index, LPDIRECT3DRMFACE2 *) PURE;
    STDMETHOD(GetVertex)(THIS_ DWORD dwIndex, LPD3DVECTOR lpVector) PURE;
    STDMETHOD(GetNormal)(THIS_ DWORD dwIndex, LPD3DVECTOR lpVector) PURE;
    STDMETHOD(DeleteVertices)(THIS_ DWORD dwIndexFirst, DWORD dwCount) PURE;
    STDMETHOD(DeleteNormals)(THIS_ DWORD dwIndexFirst, DWORD dwCount) PURE;
    STDMETHOD(DeleteFace)(THIS_ LPDIRECT3DRMFACE2) PURE;
    STDMETHOD(Empty)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Optimize)(THIS_ DWORD dwFlags) PURE;
    STDMETHOD(AddFacesIndexed)(THIS_ DWORD dwFlags, DWORD *lpdwvIndices, DWORD *dwIndexFirst, DWORD *dwCount) PURE;
    STDMETHOD(CreateSubMesh)(THIS_ LPUNKNOWN *) PURE;
    STDMETHOD(GetParentMesh)(THIS_ DWORD, LPUNKNOWN *) PURE;
    STDMETHOD(GetSubMeshes)(THIS_ LPDWORD lpdwCount, LPUNKNOWN *) PURE;
    STDMETHOD(DeleteSubMesh)(THIS_ LPUNKNOWN) PURE;
    STDMETHOD(Enable)(THIS_ DWORD) PURE;
    STDMETHOD(GetEnable)(THIS_ DWORD *) PURE;
    STDMETHOD(AddTriangles)(THIS_ DWORD dwFlags, DWORD dwFormat,
			    DWORD dwVertexCount, LPVOID lpvData) PURE;
    STDMETHOD(SetVertices)(THIS_ DWORD dwIndexFirst, DWORD dwCount, LPD3DVECTOR) PURE;
    STDMETHOD(GetVertices)(THIS_ DWORD dwIndexFirst, LPDWORD lpdwCount, LPD3DVECTOR) PURE;
    STDMETHOD(SetNormals)(THIS_ DWORD dwIndexFirst, DWORD dwCount, LPD3DVECTOR) PURE;
    STDMETHOD(GetNormals)(THIS_ DWORD dwIndexFirst, LPDWORD lpdwCount, LPD3DVECTOR) PURE;
    STDMETHOD_(int, GetNormalCount)(THIS) PURE;
};  

#undef INTERFACE
#define INTERFACE IDirect3DRMLight

DECLARE_INTERFACE_(IDirect3DRMLight, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMLight methods
     */
    STDMETHOD(SetType)(THIS_ D3DRMLIGHTTYPE) PURE;
    STDMETHOD(SetColor)(THIS_ D3DCOLOR) PURE;
    STDMETHOD(SetColorRGB)(THIS_ D3DVALUE red, D3DVALUE green, D3DVALUE blue) PURE;
    STDMETHOD(SetRange)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetUmbra)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetPenumbra)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetConstantAttenuation)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetLinearAttenuation)(THIS_ D3DVALUE) PURE;
    STDMETHOD(SetQuadraticAttenuation)(THIS_ D3DVALUE) PURE;

    STDMETHOD_(D3DVALUE, GetRange)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetUmbra)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetPenumbra)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetConstantAttenuation)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetLinearAttenuation)(THIS) PURE;
    STDMETHOD_(D3DVALUE, GetQuadraticAttenuation)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetColor)(THIS) PURE;
    STDMETHOD_(D3DRMLIGHTTYPE, GetType)(THIS) PURE;

    STDMETHOD(SetEnableFrame)(THIS_ LPDIRECT3DRMFRAME) PURE;
    STDMETHOD(GetEnableFrame)(THIS_ LPDIRECT3DRMFRAME*) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMTexture

DECLARE_INTERFACE_(IDirect3DRMTexture, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMTexture methods
     */
    STDMETHOD(InitFromFile)(THIS_ const char *filename) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS) PURE;
    STDMETHOD(InitFromResource)(THIS_ HRSRC) PURE;
    STDMETHOD(Changed)(THIS_ BOOL pixels, BOOL palette) PURE;

    STDMETHOD(SetColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalSize)(THIS_ D3DVALUE width, D3DVALUE height) PURE;
    STDMETHOD(SetDecalOrigin)(THIS_ LONG x, LONG y) PURE;
    STDMETHOD(SetDecalScale)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalTransparency)(THIS_ BOOL) PURE;
    STDMETHOD(SetDecalTransparentColor)(THIS_ D3DCOLOR) PURE;

    STDMETHOD(GetDecalSize)(THIS_ D3DVALUE *width_return, D3DVALUE *height_return) PURE;
    STDMETHOD(GetDecalOrigin)(THIS_ LONG *x_return, LONG *y_return) PURE;

    STDMETHOD_(D3DRMIMAGE *, GetImage)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetColors)(THIS) PURE;
    STDMETHOD_(DWORD, GetDecalScale)(THIS) PURE;
    STDMETHOD_(BOOL, GetDecalTransparency)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetDecalTransparentColor)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMTexture2

DECLARE_INTERFACE_(IDirect3DRMTexture2, IDirect3DRMTexture)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMTexture methods
     */
    STDMETHOD(InitFromFile)(THIS_ const char *filename) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS) PURE;
    STDMETHOD(InitFromResource)(THIS_ HRSRC) PURE;
    STDMETHOD(Changed)(THIS_ BOOL pixels, BOOL palette) PURE;

    STDMETHOD(SetColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalSize)(THIS_ D3DVALUE width, D3DVALUE height) PURE;
    STDMETHOD(SetDecalOrigin)(THIS_ LONG x, LONG y) PURE;
    STDMETHOD(SetDecalScale)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalTransparency)(THIS_ BOOL) PURE;
    STDMETHOD(SetDecalTransparentColor)(THIS_ D3DCOLOR) PURE;

    STDMETHOD(GetDecalSize)(THIS_ D3DVALUE *width_return, D3DVALUE *height_return) PURE;
    STDMETHOD(GetDecalOrigin)(THIS_ LONG *x_return, LONG *y_return) PURE;

    STDMETHOD_(D3DRMIMAGE *, GetImage)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetColors)(THIS) PURE;
    STDMETHOD_(DWORD, GetDecalScale)(THIS) PURE;
    STDMETHOD_(BOOL, GetDecalTransparency)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetDecalTransparentColor)(THIS) PURE;

    /*
     * IDirect3DRMTexture2 methods
     */
    STDMETHOD(InitFromImage)(THIS_ LPD3DRMIMAGE) PURE;
    STDMETHOD(InitFromResource2)(THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType) PURE;
    STDMETHOD(GenerateMIPMap)(THIS_ DWORD) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMTexture3

DECLARE_INTERFACE_(IDirect3DRMTexture3, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMTexture3 methods
     */
    STDMETHOD(InitFromFile)(THIS_ const char *filename) PURE;
    STDMETHOD(InitFromSurface)(THIS_ LPDIRECTDRAWSURFACE lpDDS) PURE;
    STDMETHOD(InitFromResource)(THIS_ HRSRC) PURE;
    STDMETHOD(Changed)(THIS_ DWORD dwFlags, DWORD dwcRects, LPRECT pRects) PURE;
    STDMETHOD(SetColors)(THIS_ DWORD) PURE;
    STDMETHOD(SetShades)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalSize)(THIS_ D3DVALUE width, D3DVALUE height) PURE;
    STDMETHOD(SetDecalOrigin)(THIS_ LONG x, LONG y) PURE;
    STDMETHOD(SetDecalScale)(THIS_ DWORD) PURE;
    STDMETHOD(SetDecalTransparency)(THIS_ BOOL) PURE;
    STDMETHOD(SetDecalTransparentColor)(THIS_ D3DCOLOR) PURE;

    STDMETHOD(GetDecalSize)(THIS_ D3DVALUE *width_return, D3DVALUE *height_return) PURE;
    STDMETHOD(GetDecalOrigin)(THIS_ LONG *x_return, LONG *y_return) PURE;

    STDMETHOD_(D3DRMIMAGE *, GetImage)(THIS) PURE;
    STDMETHOD_(DWORD, GetShades)(THIS) PURE;
    STDMETHOD_(DWORD, GetColors)(THIS) PURE;
    STDMETHOD_(DWORD, GetDecalScale)(THIS) PURE;
    STDMETHOD_(BOOL, GetDecalTransparency)(THIS) PURE;
    STDMETHOD_(D3DCOLOR, GetDecalTransparentColor)(THIS) PURE;
    STDMETHOD(InitFromImage)(THIS_ LPD3DRMIMAGE) PURE;
    STDMETHOD(InitFromResource2)(THIS_ HMODULE hModule, LPCTSTR strName, LPCTSTR strType) PURE;
    STDMETHOD(GenerateMIPMap)(THIS_ DWORD) PURE;
    STDMETHOD(GetSurface)(THIS_ DWORD dwFlags, LPDIRECTDRAWSURFACE* lplpDDS) PURE;
    STDMETHOD(SetCacheOptions)(THIS_ LONG lImportance, DWORD dwFlags) PURE;
    STDMETHOD(GetCacheOptions)(THIS_ LPLONG lplImportance, LPDWORD lpdwFlags) PURE;
    STDMETHOD(SetDownsampleCallback)(THIS_ D3DRMDOWNSAMPLECALLBACK pCallback, LPVOID pArg) PURE;
    STDMETHOD(SetValidationCallback)(THIS_ D3DRMVALIDATIONCALLBACK pCallback, LPVOID pArg) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMWrap

DECLARE_INTERFACE_(IDirect3DRMWrap, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMWrap methods
     */
    STDMETHOD(Init)
    (	THIS_ D3DRMWRAPTYPE, LPDIRECT3DRMFRAME ref,
	D3DVALUE ox, D3DVALUE oy, D3DVALUE oz,
	D3DVALUE dx, D3DVALUE dy, D3DVALUE dz,
	D3DVALUE ux, D3DVALUE uy, D3DVALUE uz,
	D3DVALUE ou, D3DVALUE ov,
	D3DVALUE su, D3DVALUE sv
    ) PURE;
    STDMETHOD(Apply)(THIS_ LPDIRECT3DRMOBJECT) PURE;
    STDMETHOD(ApplyRelative)(THIS_ LPDIRECT3DRMFRAME frame, LPDIRECT3DRMOBJECT) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMMaterial

DECLARE_INTERFACE_(IDirect3DRMMaterial, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMaterial methods
     */
    STDMETHOD(SetPower)(THIS_ D3DVALUE power) PURE;
    STDMETHOD(SetSpecular)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
    STDMETHOD(SetEmissive)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;

    STDMETHOD_(D3DVALUE, GetPower)(THIS) PURE;
    STDMETHOD(GetSpecular)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(GetEmissive)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMMaterial2

DECLARE_INTERFACE_(IDirect3DRMMaterial2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMMaterial2 methods
     */
    STDMETHOD(SetPower)(THIS_ D3DVALUE power) PURE;
    STDMETHOD(SetSpecular)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
    STDMETHOD(SetEmissive)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
    STDMETHOD_(D3DVALUE, GetPower)(THIS) PURE;
    STDMETHOD(GetSpecular)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(GetEmissive)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(GetAmbient)(THIS_ D3DVALUE* r, D3DVALUE* g, D3DVALUE* b) PURE;
    STDMETHOD(SetAmbient)(THIS_ D3DVALUE r, D3DVALUE g, D3DVALUE b) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMAnimation

DECLARE_INTERFACE_(IDirect3DRMAnimation, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimation methods
     */
    STDMETHOD(SetOptions)(THIS_ D3DRMANIMATIONOPTIONS flags) PURE;
    STDMETHOD(AddRotateKey)(THIS_ D3DVALUE time, D3DRMQUATERNION *q) PURE;
    STDMETHOD(AddPositionKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScaleKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(DeleteKey)(THIS_ D3DVALUE time) PURE;
    STDMETHOD(SetFrame)(THIS_ LPDIRECT3DRMFRAME frame) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;

    STDMETHOD_(D3DRMANIMATIONOPTIONS, GetOptions)(THIS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimation2

DECLARE_INTERFACE_(IDirect3DRMAnimation2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimation2 methods
     */
    STDMETHOD(SetOptions)(THIS_ D3DRMANIMATIONOPTIONS flags) PURE;
    STDMETHOD(AddRotateKey)(THIS_ D3DVALUE time, D3DRMQUATERNION *q) PURE;
    STDMETHOD(AddPositionKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(AddScaleKey)(THIS_ D3DVALUE time, D3DVALUE x, D3DVALUE y, D3DVALUE z) PURE;
    STDMETHOD(DeleteKey)(THIS_ D3DVALUE time) PURE;
    STDMETHOD(SetFrame)(THIS_ LPDIRECT3DRMFRAME3 frame) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;

    STDMETHOD_(D3DRMANIMATIONOPTIONS, GetOptions)(THIS) PURE;
    STDMETHOD(GetFrame)(THIS_ LPDIRECT3DRMFRAME3 *lpD3DFrame) PURE;
    STDMETHOD(DeleteKeyByID)(THIS_ DWORD dwID) PURE;
    STDMETHOD(AddKey)(THIS_ LPD3DRMANIMATIONKEY lpKey) PURE;
    STDMETHOD(ModifyKey)(THIS_ LPD3DRMANIMATIONKEY lpKey) PURE;
    STDMETHOD(GetKeys)(THIS_ D3DVALUE dvTimeMin,
		       D3DVALUE dvTimeMax, LPDWORD lpdwNumKeys,
		       LPD3DRMANIMATIONKEY lpKey);
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimationSet

DECLARE_INTERFACE_(IDirect3DRMAnimationSet, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimationSet methods
     */
    STDMETHOD(AddAnimation)(THIS_ LPDIRECT3DRMANIMATION aid) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURECALLBACK, LPVOID lpArg, LPDIRECT3DRMFRAME parent)PURE;
    STDMETHOD(DeleteAnimation)(THIS_ LPDIRECT3DRMANIMATION aid) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimationSet2

DECLARE_INTERFACE_(IDirect3DRMAnimationSet2, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMAnimationSet2 methods
     */
    STDMETHOD(AddAnimation)(THIS_ LPDIRECT3DRMANIMATION2 aid) PURE;
    STDMETHOD(Load)(THIS_ LPVOID filename, LPVOID name, D3DRMLOADOPTIONS loadflags, D3DRMLOADTEXTURE3CALLBACK, LPVOID lpArg, LPDIRECT3DRMFRAME3 parent)PURE;
    STDMETHOD(DeleteAnimation)(THIS_ LPDIRECT3DRMANIMATION2 aid) PURE;
    STDMETHOD(SetTime)(THIS_ D3DVALUE time) PURE;
    STDMETHOD(GetAnimations)(THIS_ LPDIRECT3DRMANIMATIONARRAY *) PURE;
};


#undef INTERFACE
#define INTERFACE IDirect3DRMUserVisual

DECLARE_INTERFACE_(IDirect3DRMUserVisual, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMUserVisual methods
     */
    STDMETHOD(Init)(THIS_ D3DRMUSERVISUALCALLBACK fn, void *arg) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMArray

DECLARE_INTERFACE_(IDirect3DRMArray, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    /* No GetElement method as it would get overloaded
     * in derived classes, and overloading is
     * a no-no in COM
     */
};

#undef INTERFACE
#define INTERFACE IDirect3DRMObjectArray

DECLARE_INTERFACE_(IDirect3DRMObjectArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMOBJECT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMDeviceArray

DECLARE_INTERFACE_(IDirect3DRMDeviceArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMDEVICE *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFrameArray

DECLARE_INTERFACE_(IDirect3DRMFrameArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMFRAME *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMViewportArray

DECLARE_INTERFACE_(IDirect3DRMViewportArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMVIEWPORT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMVisualArray

DECLARE_INTERFACE_(IDirect3DRMVisualArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMVISUAL *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMAnimationArray

DECLARE_INTERFACE_(IDirect3DRMAnimationArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMANIMATION2 *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMPickedArray

DECLARE_INTERFACE_(IDirect3DRMPickedArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetPick)(THIS_ DWORD index, LPDIRECT3DRMVISUAL *, LPDIRECT3DRMFRAMEARRAY *, LPD3DRMPICKDESC) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMLightArray

DECLARE_INTERFACE_(IDirect3DRMLightArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMLIGHT *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMFaceArray

DECLARE_INTERFACE_(IDirect3DRMFaceArray, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetElement)(THIS_ DWORD index, LPDIRECT3DRMFACE *) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMPicked2Array

DECLARE_INTERFACE_(IDirect3DRMPicked2Array, IDirect3DRMArray)
{
    IUNKNOWN_METHODS(PURE);

    STDMETHOD_(DWORD, GetSize)(THIS) PURE;
    STDMETHOD(GetPick)(THIS_ DWORD index, LPDIRECT3DRMVISUAL *, LPDIRECT3DRMFRAMEARRAY *, LPD3DRMPICKDESC2) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMInterpolator

DECLARE_INTERFACE_(IDirect3DRMInterpolator, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMInterpolator methods
     */
    STDMETHOD(AttachObject)(THIS_ LPDIRECT3DRMOBJECT) PURE;
    STDMETHOD(GetAttachedObjects)(THIS_ LPDIRECT3DRMOBJECTARRAY *) PURE;
    STDMETHOD(DetachObject)(THIS_ LPDIRECT3DRMOBJECT) PURE;
    STDMETHOD(SetIndex)(THIS_ D3DVALUE) PURE;
    STDMETHOD_(D3DVALUE, GetIndex)(THIS) PURE;
    STDMETHOD(Interpolate)(THIS_ D3DVALUE, LPDIRECT3DRMOBJECT, D3DRMINTERPOLATIONOPTIONS) PURE;
};

#undef INTERFACE
#define INTERFACE IDirect3DRMClippedVisual

DECLARE_INTERFACE_(IDirect3DRMClippedVisual, IDirect3DRMVisual)
{
    IUNKNOWN_METHODS(PURE);
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMClippedVisual methods
     */
    STDMETHOD(Init) (THIS_ LPDIRECT3DRMVISUAL) PURE;
    STDMETHOD(AddPlane) (THIS_ LPDIRECT3DRMFRAME3, LPD3DVECTOR, LPD3DVECTOR, DWORD, LPDWORD) PURE;
    STDMETHOD(DeletePlane)(THIS_ DWORD, DWORD) PURE;
    STDMETHOD(GetPlaneIDs)(THIS_ LPDWORD, LPDWORD, DWORD) PURE;
    STDMETHOD(GetPlane) (THIS_ DWORD, LPDIRECT3DRMFRAME3, LPD3DVECTOR, LPD3DVECTOR, DWORD) PURE;
    STDMETHOD(SetPlane) (THIS_ DWORD, LPDIRECT3DRMFRAME3, LPD3DVECTOR, LPD3DVECTOR, DWORD) PURE;
};

#ifdef __cplusplus
};
#endif
#endif /* _D3DRMOBJ_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\d3prmvis.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3drmvis.h
 *  Content:	Direct3DRM external visualinclude file
 *@@BEGIN_MSINTERNAL
 * 
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   12/06/97   stevela Initial rev
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _D3DRMVIS_H_
#define _D3DRMVIS_H_

//@@BEGIN_MSINTERNAL
#if 1
#include "d3prm.h"
#include "d3prmobj.h"
#else
//@@END_MSINTERNAL
#include "d3drm.h"
#include "d3drmobj.h"
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL

#include <ocidl.h>
#include "dxfile.h"

#ifdef __cplusplus
extern "C" {
#endif

WIN_TYPES(IDirect3DRMExternalVisual, DIRECT3DRMEXTERNALVISUAL);
WIN_TYPES(IDirect3DRMExternalUtil, DIRECT3DRMEXTERNALUTIL);

DEFINE_GUID(IID_IDirect3DRMExternalVisual,
0x4516ec80, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);
DEFINE_GUID(IID_IDirect3DRMExternalUtil,
0x4516ec80, 0x8f20, 0x11d0, 0x9b, 0x6d, 0x00, 0x00, 0xc0, 0x78, 0x1b, 0xc3);

/* In IDirect3DRMExternalVisual::CanSee() */
#define D3DRMEXTVIS_CANNOTSEE 0x00000001L
#define D3DRMEXTVIS_CANSEE    0x00000002L

/* In IDirect3DRMExternalVisual::Pick() */
#define D3DRMEXTVIS_NOTPICKED 0x00000001L
#define D3DRMEXTVIS_PICKED    0x00000002L

/* In D3DRMEXTVISRENDERCONTEXT.dwOverrides */
#define D3DRMEXTVIS_RENDERCONTEXT_OVERRIDEMATERIAL 0x00000001L
#define D3DRMEXTVIS_RENDERCONTEXT_OVERRIDETEXTURE  0x00000002L
#define D3DRMEXTVIS_RENDERCONTEXT_DEVICEOVERRIDE   0x00000004L

/* In D3DRMEXTVISRENDERCONTEXT.dwZBufferMode */
#define D3DRMEXTVIS_RENDERCONTEXT_ZBUFFERON        0x00000001L
#define D3DRMEXTVIS_RENDERCONTEXT_ZBUFFEROFF       0x00000002L

/*
 * Structure for IDirect3DRMExternalVisual::SetRenderContext()
 */
typedef struct
{
    DWORD dwSize;		/* Size of structure */
    DWORD dwFlags;		/* Must be zero */
    DWORD dwOverrides;		/* Indicates which overrides are in effect */
    D3DMATERIALHANDLE hMat;	/* If non-zero, this material handle MUST
				   be used for all rendering */
    D3DTEXTUREHANDLE hTex;	/* If non-zero, this texture handle MUST
				   be used for all rendering */
    D3DRMMATERIALOVERRIDE dmUserOverride; /* contains per-attribute overrides
					     for materials */
    D3DRMSHADEMODE pShadeMode;  /* Flat, gouraud or phong */
    D3DRMLIGHTMODE pLightMode;  /* On or off */
    D3DRMFILLMODE pFillMode;    /* Points, wireframe or solid */
    DWORD dwZBufferMode;	/* As defined above */
    DWORD dwRenderMode;		/* Blended transparency and/or sorted */
} D3DRMEXTVISRENDERCONTEXT, *LPD3DRMEXTVISRENDERCONTEXT;

/*
 * Structure for IDirect3DRMExternalVisual::RayPick()
 */
typedef struct
{
    D3DVALUE  dDistance;
    D3DVECTOR dvPosition;
    D3DVECTOR dvNormal;
    D3DVALUE  tu;
    D3DVALUE  tv;
    D3DCOLOR  dcColor;
} D3DRMEXTVISRAYPICKINFO, *LPD3DRMEXTVISRAYPICKINFO;

#undef INTERFACE
#define INTERFACE IDirect3DRMExternalVisual
DECLARE_INTERFACE_(IDirect3DRMExternalVisual, IUnknown)
{
    IUNKNOWN_METHODS(PURE);

    /*
     * IDirect3DRMExternalVisual methods
     */
    STDMETHOD(Initialize)(THIS_ LPDIRECT3DRM, LPDIRECT3DRMEXTERNALUTIL,
			  DWORD dwFlags) PURE;
    STDMETHOD(Load)(THIS_ IDirectXFileData *dObject, 
		    IPropertyBag *pPropBag, 
		    DWORD dwFlags) PURE;

    /*
     * Information about device state, viewport state, overrides, etc...
     */
    STDMETHOD(SetRenderContext)(THIS_ LPD3DRMEXTVISRENDERCONTEXT pCntx,
				DWORD dwFlags) PURE;
    
    /*
     * Rendering operations
     */
    STDMETHOD(CanSee)(THIS_ LPDIRECT3DRMDEVICE2, LPDIRECT3DRMVIEWPORT2,
		      LPDWORD pdwCanSee) PURE;
    STDMETHOD(Render)(THIS_ LPDIRECT3DRMDEVICE2, LPDIRECT3DRMVIEWPORT2,
		      DWORD dwFlags) PURE;
    STDMETHOD(DeviceChange)(THIS) PURE;

    /* 
     * Notify external visuals when BeginScene/EndScene are called during 
     * rendering
     */
    STDMETHOD(BeginScene)(THIS) PURE;
    STDMETHOD(EndScene)(THIS) PURE;

    /*
     * Picking
     */
    STDMETHOD(Pick)(THIS_ LPDIRECT3DRMVIEWPORT2 pViewIn,
		    LPDIRECT3DRMFRAME3 pFrameIn,
		    DWORD dwXIn, DWORD dwYIn,
		    LPD3DVALUE pdvZOut, LPDWORD pdwPicked) PURE;

    /*
     * RayPicking
     *
     * dwFlags can contain:
     * D3DRMRAYPICK_INTERPOLATENORMAL - pPickInfo.dvNormal must be filled in
     * D3DRMRAYPICK_INTERPOLATECOLOR  - pPickInfo.dcColor must be filled in
     * D3DRMRAYPICK_INTERPOLATEUV     - pPickInfo.tu, tv must be filled in
     */
    STDMETHOD(RayPick)(THIS_ LPDIRECT3DRMFRAME3 pFrameIn,
		       LPD3DRMRAY pRayIn,
		       DWORD dwFlags,
		       LPDWORD pdwPicked,
		       LPD3DRMEXTVISRAYPICKINFO pPickInfo) PURE;

    /*
     * Misc
     */
    STDMETHOD(GetBox)(THIS_ LPD3DRMBOX) PURE;
    STDMETHOD(GetAge)(THIS_ LPDWORD) PURE;
};

/*
 * Flags for UpdateBounds
 */
#define D3DRMEXTUTIL_BOUNDSINVALIDATE 0x00000001L
#define D3DRMEXTUTIL_BOUNDSVALID      0x00000002L

#undef INTERFACE
#define INTERFACE IDirect3DRMExternalUtil
DECLARE_INTERFACE_(IDirect3DRMExternalUtil, IDirect3DRMObject)
{
    IUNKNOWN_METHODS(PURE);

    /*
     * External Visual must use these methods to provide IDirect3DRMObject
     * functionality.
     */
    IDIRECT3DRMOBJECT_METHODS(PURE);

    /*
     * IDirect3DRMExternalUtil methods
     */

    /*
     * Texture Management
     */
    STDMETHOD(FindDeviceTexture)(LPDIRECT3DRMDEVICE2, LPDIRECT3DRMTEXTURE,
				 LPDWORD dwDevTexId) PURE;
    STDMETHOD(GetTextureHandle)(DWORD dwDevTexId, LPDWORD pdwHandle) PURE;
    STDMETHOD(DestroyDeviceTexture)(DWORD dwDevTexId) PURE;
    STDMETHOD(ValidateDeviceTextures)(LPDIRECT3DRMDEVICE2,
				      LPDWORD dwDevTexIds,
				      DWORD dwNumIds) PURE;
    STDMETHOD(UpdateBounds)(DWORD dwFlags,
			    LPD3DVECTOR dvMin,
			    LPD3DVECTOR dvMax) PURE;
    STDMETHOD(SetExtents)(LPDIRECT3DRMVIEWPORT2,
			  DWORD dwNumExtents, 
			  LPD3DCLIPSTATUS pExtents) PURE;
};

#ifdef __cplusplus
};
#endif /* __cplusplus */

#endif /* _D3DRMVIS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\ddmc.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddmc.h
 *  Content:	DirectDrawMotionComp include file
 *
 ***************************************************************************/

#ifndef __DDVA_INCLUDED__
#define __DDVA_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#undef  CO_E_NOTINITIALIZED
#define CO_E_NOTINITIALIZED 0x800401F0L
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectDrawVideoAccelerator objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
DEFINE_GUID( IID_IDDVideoAcceleratorContainer,	0xACA12120,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
DEFINE_GUID( IID_IDirectDrawVideoAccelerator,   0xC9B2D740,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDVideoAcceleratorContainer		FAR *LPDDVIDEOACCELERATORCONTAINER;
typedef struct IDirectDrawVideoAccelerator		FAR *LPDIRECTDRAWVIDEOACCELERATOR;

typedef struct IDDVideoAcceleratorContainerVtbl DDVIDEOACCELERATORCONTAINERCALLBACKS;
typedef struct IDirectDrawVideoAcceleratorVtbl  DIRECTDRAWVIDEOACCELERATORCALLBACKS;


typedef struct _tag_DDVAUncompDataInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwUncompWidth;              // [in]     width of uncompressed data
    DWORD                   dwUncompHeight;             // [in]     height of uncompressed data
    DDPIXELFORMAT           ddUncompPixelFormat;        // [in]     pixel-format of uncompressed data
} DDVAUncompDataInfo, *LPDDVAUncompDataInfo;

typedef struct _tag_DDVAInternalMemInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwScratchMemAlloc;          // [out]    amount of scratch memory will the hal allocate for its private use
} DDVAInternalMemInfo, *LPDDVAInternalMemInfo;


typedef struct _tag_DDVACompBufferInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwNumCompBuffers;           // [out]    number of buffers reqd for compressed data
    DWORD                   dwWidthToCreate;            // [out]    Width of surface to create
    DWORD                   dwHeightToCreate;           // [out]    Height of surface to create
    DWORD                   dwBytesToAllocate;          // [out]    Total number of bytes used by each surface
    DDSCAPS2                ddCompCaps;                 // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT           ddPixelFormat;              // [out]    fourcc to create surfaces to store compressed data
} DDVACompBufferInfo, *LPDDVACompBufferInfo;


// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVABeginFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    LPDIRECTDRAWSURFACE7    pddDestSurface;             // [in]     destination buffer in which to decoding this frame
    DWORD                   dwSizeInputData;            // [in]     size of other misc data to begin frame
    LPVOID                  pInputData;                 // [in]     pointer to misc data
    DWORD                   dwSizeOutputData;           // [in/out] size of other misc data to begin frame
    LPVOID                  pOutputData;                // [out]    pointer to misc data
} DDVABeginFrameInfo, *LPDDVABeginFrameInfo;

// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVAEndFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwSizeMiscData;             // [in]     size of other misc data to begin frame
    LPVOID                  pMiscData;                  // [in]     pointer to misc data
} DDVAEndFrameInfo, *LPDDVAEndFrameInfo;

typedef struct _tag_DDVABUFFERINFO
{
    DWORD                   dwSize;                     // [in]    size of the struct
    LPDIRECTDRAWSURFACE7    pddCompSurface;             // [in]    pointer to buffer containing compressed data
    DWORD                   dwDataOffset;               // [in]    offset of relevant data from the beginning of buffer
    DWORD                   dwDataSize;                 // [in]    size of relevant data
} DDVABUFFERINFO, *LPDDVABUFFERINFO;


/*
 * INTERACES FOLLOW:
 *	IDDVideoAcceleratorContainer
 *	IDirectDrawVideoAccelerator
 */

/*
 * IDDVideoAcceleratorContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDVideoAcceleratorContainer
DECLARE_INTERFACE_( IDDVideoAcceleratorContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDDVideoAcceleratorContainer methods ***/
    STDMETHOD(CreateVideoAccelerator)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPVOID, DWORD, LPDIRECTDRAWVIDEOACCELERATOR FAR *, IUnknown FAR *) PURE;
    STDMETHOD(GetCompBufferInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDWORD, LPDDVACompBufferInfo ) PURE;
    STDMETHOD(GetInternalMemInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDDVAInternalMemInfo ) PURE;
    STDMETHOD(GetVideoAcceleratorGUIDs)(THIS_ LPDWORD, LPGUID ) PURE;
    STDMETHOD(GetUncompFormatsSupported)(THIS_ LPGUID, LPDWORD, LPDDPIXELFORMAT ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->lpVtbl->QueryInterface(p, a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->lpVtbl->AddRef(p)
#define IVideoAcceleratorContainer_Release(p)                         (p)->lpVtbl->Release(p)
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p,a,b,c,d,e,f)    (p)->lpVtbl->CreateVideoAccelerator(p, a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->lpVtbl->GetCompBufferInfo(p, a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->lpVtbl->GetInternalMemInfo(p, a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->lpVtbl->GetVideoAcceleratorGUIDs(p, a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->lpVtbl->GetUncompFormatsSupported(p, a, b, c)
#else
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->QueryInterface(a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->AddRef()
#define IVideoAcceleratorContainer_Release(p)                         (p)->Release()
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p, a, b, c,d,e,f) (p)->CreateVideoAccelerator(a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->GetCompBufferInfo(a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->GetInternalMemInfo(a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->GetVideoAcceleratorGUIDs(a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->GetUncompFormatsSupported(a, b, c)
#endif

#endif


/*
 * IDirectDrawVideoAccelerator
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoAccelerator
DECLARE_INTERFACE_( IDirectDrawVideoAccelerator, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirecytDrawVideoAccelerator methods ***/
    STDMETHOD(BeginFrame)(THIS_ LPDDVABeginFrameInfo) PURE;
    STDMETHOD(EndFrame)(THIS_ LPDDVAEndFrameInfo) PURE;
    STDMETHOD(QueryRenderStatus)(THIS_ LPDIRECTDRAWSURFACE7, DWORD)PURE;
    STDMETHOD(Execute)(THIS_ 
                       DWORD,            // Function
                       LPVOID,           // Input data
                       DWORD,            // Input data length
                       LPVOID,           // Output data
                       DWORD,            // Output data length
                       DWORD,            // Number of buffers
                       LPDDVABUFFERINFO  // Buffer info array
                       ) PURE;
};

//  Flags for QueryRenderStatus
#define DDVA_QUERYRENDERSTATUSF_READ     0x00000001  // Query for read
                                                     // set this bit to 0 
                                                     // if query for update

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IVideoAccelerator_Release(p)                 (p)->lpVtbl->Release(p)
#define IVideoAccelerator_BeginFrame(p,a)            (p)->lpVtbl->BeginFrame(p,a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->lpVtbl->EndFrame(p,a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->lpVtbl->QueryRenderStatus(p,a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->lpVtbl->RenderMacroBlocks(p,a,b)
#else
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->AddRef()
#define IVideoAccelerator_Release(p)                 (p)->Release()
#define IVideoAccelerator_BeginFrame(p,a)            (p)->BeginFrame(a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->EndFrame(a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->QueryRenderStatus(a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->RenderMacroBlocks(a,b)
#endif

#endif


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\ddmcp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddmc.h
 *  Content:	DirectDrawMotionComp include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   22-sep-97	smac
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DDVA_INCLUDED__
#define __DDVA_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#undef  CO_E_NOTINITIALIZED
#define CO_E_NOTINITIALIZED 0x800401F0L
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectDrawVideoAccelerator objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
DEFINE_GUID( IID_IDDVideoAcceleratorContainer,	0xACA12120,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
DEFINE_GUID( IID_IDirectDrawVideoAccelerator,   0xC9B2D740,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDVideoAcceleratorContainer		FAR *LPDDVIDEOACCELERATORCONTAINER;
typedef struct IDirectDrawVideoAccelerator		FAR *LPDIRECTDRAWVIDEOACCELERATOR;

typedef struct IDDVideoAcceleratorContainerVtbl DDVIDEOACCELERATORCONTAINERCALLBACKS;
typedef struct IDirectDrawVideoAcceleratorVtbl  DIRECTDRAWVIDEOACCELERATORCALLBACKS;


typedef struct _tag_DDVAUncompDataInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwUncompWidth;              // [in]     width of uncompressed data
    DWORD                   dwUncompHeight;             // [in]     height of uncompressed data
    DDPIXELFORMAT           ddUncompPixelFormat;        // [in]     pixel-format of uncompressed data
} DDVAUncompDataInfo, *LPDDVAUncompDataInfo;

typedef struct _tag_DDVAInternalMemInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwScratchMemAlloc;          // [out]    amount of scratch memory will the hal allocate for its private use
} DDVAInternalMemInfo, *LPDDVAInternalMemInfo;


typedef struct _tag_DDVACompBufferInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwNumCompBuffers;           // [out]    number of buffers reqd for compressed data
    DWORD                   dwWidthToCreate;            // [out]    Width of surface to create
    DWORD                   dwHeightToCreate;           // [out]    Height of surface to create
    DWORD                   dwBytesToAllocate;          // [out]    Total number of bytes used by each surface
    DDSCAPS2                ddCompCaps;                 // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT           ddPixelFormat;              // [out]    fourcc to create surfaces to store compressed data
} DDVACompBufferInfo, *LPDDVACompBufferInfo;


// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVABeginFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    LPDIRECTDRAWSURFACE7    pddDestSurface;             // [in]     destination buffer in which to decoding this frame
    DWORD                   dwSizeInputData;            // [in]     size of other misc data to begin frame
    LPVOID                  pInputData;                 // [in]     pointer to misc data
    DWORD                   dwSizeOutputData;           // [in/out] size of other misc data to begin frame
    LPVOID                  pOutputData;                // [out]    pointer to misc data
} DDVABeginFrameInfo, *LPDDVABeginFrameInfo;

// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVAEndFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwSizeMiscData;             // [in]     size of other misc data to begin frame
    LPVOID                  pMiscData;                  // [in]     pointer to misc data
} DDVAEndFrameInfo, *LPDDVAEndFrameInfo;

typedef struct _tag_DDVABUFFERINFO
{
    DWORD                   dwSize;                     // [in]    size of the struct
    LPDIRECTDRAWSURFACE7    pddCompSurface;             // [in]    pointer to buffer containing compressed data
    DWORD                   dwDataOffset;               // [in]    offset of relevant data from the beginning of buffer
    DWORD                   dwDataSize;                 // [in]    size of relevant data
} DDVABUFFERINFO, *LPDDVABUFFERINFO;


/*
 * INTERACES FOLLOW:
 *	IDDVideoAcceleratorContainer
 *	IDirectDrawVideoAccelerator
 */

/*
 * IDDVideoAcceleratorContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDVideoAcceleratorContainer
DECLARE_INTERFACE_( IDDVideoAcceleratorContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDDVideoAcceleratorContainer methods ***/
    STDMETHOD(CreateVideoAccelerator)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPVOID, DWORD, LPDIRECTDRAWVIDEOACCELERATOR FAR *, IUnknown FAR *) PURE;
    STDMETHOD(GetCompBufferInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDWORD, LPDDVACompBufferInfo ) PURE;
    STDMETHOD(GetInternalMemInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDDVAInternalMemInfo ) PURE;
    STDMETHOD(GetVideoAcceleratorGUIDs)(THIS_ LPDWORD, LPGUID ) PURE;
    STDMETHOD(GetUncompFormatsSupported)(THIS_ LPGUID, LPDWORD, LPDDPIXELFORMAT ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->lpVtbl->QueryInterface(p, a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->lpVtbl->AddRef(p)
#define IVideoAcceleratorContainer_Release(p)                         (p)->lpVtbl->Release(p)
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p,a,b,c,d,e,f)    (p)->lpVtbl->CreateVideoAccelerator(p, a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->lpVtbl->GetCompBufferInfo(p, a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->lpVtbl->GetInternalMemInfo(p, a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->lpVtbl->GetVideoAcceleratorGUIDs(p, a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->lpVtbl->GetUncompFormatsSupported(p, a, b, c)
#else
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->QueryInterface(a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->AddRef()
#define IVideoAcceleratorContainer_Release(p)                         (p)->Release()
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p, a, b, c,d,e,f) (p)->CreateVideoAccelerator(a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->GetCompBufferInfo(a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->GetInternalMemInfo(a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->GetVideoAcceleratorGUIDs(a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->GetUncompFormatsSupported(a, b, c)
#endif

#endif


/*
 * IDirectDrawVideoAccelerator
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoAccelerator
DECLARE_INTERFACE_( IDirectDrawVideoAccelerator, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirecytDrawVideoAccelerator methods ***/
    STDMETHOD(BeginFrame)(THIS_ LPDDVABeginFrameInfo) PURE;
    STDMETHOD(EndFrame)(THIS_ LPDDVAEndFrameInfo) PURE;
    STDMETHOD(QueryRenderStatus)(THIS_ LPDIRECTDRAWSURFACE7, DWORD)PURE;
    STDMETHOD(Execute)(THIS_ 
                       DWORD,            // Function
                       LPVOID,           // Input data
                       DWORD,            // Input data length
                       LPVOID,           // Output data
                       DWORD,            // Output data length
                       DWORD,            // Number of buffers
                       LPDDVABUFFERINFO  // Buffer info array
                       ) PURE;
};

//  Flags for QueryRenderStatus
#define DDVA_QUERYRENDERSTATUSF_READ     0x00000001  // Query for read
                                                     // set this bit to 0 
                                                     // if query for update

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IVideoAccelerator_Release(p)                 (p)->lpVtbl->Release(p)
#define IVideoAccelerator_BeginFrame(p,a)            (p)->lpVtbl->BeginFrame(p,a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->lpVtbl->EndFrame(p,a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->lpVtbl->QueryRenderStatus(p,a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->lpVtbl->RenderMacroBlocks(p,a,b)
#else
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->AddRef()
#define IVideoAccelerator_Release(p)                 (p)->Release()
#define IVideoAccelerator_BeginFrame(p,a)            (p)->BeginFrame(a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->EndFrame(a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->QueryRenderStatus(a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->RenderMacroBlocks(a,b)
#endif

#endif


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\d3prmdef.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	d3drm.h
 *  Content:	Direct3DRM include file
 *@@BEGIN_MSINTERNAL
 * 
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27/02/96   stevela Moved from RL to D3DRM.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __D3DRMDEFS_H__
#define __D3DRMDEFS_H__

#include <stddef.h>
#include "d3dtypes.h"

#ifdef WIN32
#define D3DRMAPI  __stdcall
#else
#define D3DRMAPI
#endif

#if defined(__cplusplus)
extern "C" {
#endif

#ifndef TRUE
#define FALSE 0
#define TRUE 1
#endif

typedef struct _D3DRMVECTOR4D
{   D3DVALUE x, y, z, w;
} D3DRMVECTOR4D, *LPD3DRMVECTOR4D;

typedef D3DVALUE D3DRMMATRIX4D[4][4];

typedef struct _D3DRMQUATERNION
{   D3DVALUE s;
    D3DVECTOR v;
} D3DRMQUATERNION, *LPD3DRMQUATERNION;

typedef struct _D3DRMRAY
{   D3DVECTOR dvDir;
    D3DVECTOR dvPos;
} D3DRMRAY, *LPD3DRMRAY;

typedef struct _D3DRMBOX
{   D3DVECTOR min, max;
} D3DRMBOX, *LPD3DRMBOX;

typedef void (*D3DRMWRAPCALLBACK)
    (LPD3DVECTOR, int* u, int* v, LPD3DVECTOR a, LPD3DVECTOR b, LPVOID);

typedef enum _D3DRMLIGHTTYPE
{   D3DRMLIGHT_AMBIENT,
    D3DRMLIGHT_POINT,
    D3DRMLIGHT_SPOT,
    D3DRMLIGHT_DIRECTIONAL,
    D3DRMLIGHT_PARALLELPOINT
} D3DRMLIGHTTYPE, *LPD3DRMLIGHTTYPE;

typedef enum _D3DRMSHADEMODE {
    D3DRMSHADE_FLAT	= 0,
    D3DRMSHADE_GOURAUD	= 1,
    D3DRMSHADE_PHONG	= 2,

    D3DRMSHADE_MASK	= 7,
    D3DRMSHADE_MAX	= 8
} D3DRMSHADEMODE, *LPD3DRMSHADEMODE;

typedef enum _D3DRMLIGHTMODE {
    D3DRMLIGHT_OFF	= 0 * D3DRMSHADE_MAX,
    D3DRMLIGHT_ON	= 1 * D3DRMSHADE_MAX,

    D3DRMLIGHT_MASK	= 7 * D3DRMSHADE_MAX,
    D3DRMLIGHT_MAX	= 8 * D3DRMSHADE_MAX
} D3DRMLIGHTMODE, *LPD3DRMLIGHTMODE;

typedef enum _D3DRMFILLMODE {
    D3DRMFILL_POINTS	= 0 * D3DRMLIGHT_MAX,
    D3DRMFILL_WIREFRAME	= 1 * D3DRMLIGHT_MAX,
    D3DRMFILL_SOLID	= 2 * D3DRMLIGHT_MAX,

    D3DRMFILL_MASK	= 7 * D3DRMLIGHT_MAX,
    D3DRMFILL_MAX	= 8 * D3DRMLIGHT_MAX
} D3DRMFILLMODE, *LPD3DRMFILLMODE;

typedef DWORD D3DRMRENDERQUALITY, *LPD3DRMRENDERQUALITY;

#define D3DRMRENDER_WIREFRAME	(D3DRMSHADE_FLAT+D3DRMLIGHT_OFF+D3DRMFILL_WIREFRAME)
#define D3DRMRENDER_UNLITFLAT	(D3DRMSHADE_FLAT+D3DRMLIGHT_OFF+D3DRMFILL_SOLID)
#define D3DRMRENDER_FLAT	(D3DRMSHADE_FLAT+D3DRMLIGHT_ON+D3DRMFILL_SOLID)
#define D3DRMRENDER_GOURAUD	(D3DRMSHADE_GOURAUD+D3DRMLIGHT_ON+D3DRMFILL_SOLID)
#define D3DRMRENDER_PHONG	(D3DRMSHADE_PHONG+D3DRMLIGHT_ON+D3DRMFILL_SOLID)

#define D3DRMRENDERMODE_BLENDEDTRANSPARENCY	1
#define D3DRMRENDERMODE_SORTEDTRANSPARENCY	2
//@@BEGIN_MSINTERNAL
#define D3DRMRENDERMODE_SORTIFNOZBUFFER		4
//@@END_MSINTERNAL
#define D3DRMRENDERMODE_LIGHTINMODELSPACE	8
#define D3DRMRENDERMODE_VIEWDEPENDENTSPECULAR	16
#define D3DRMRENDERMODE_DISABLESORTEDALPHAZWRITE 32

//@@BEGIN_MSINTERNAL
typedef enum _D3DRMLIGHTINGFREQUENCY
{   D3DRMLIGHT_NEVER,
    D3DRMLIGHT_ONCE,
    D3DRMLIGHT_CONTINUALLY
} D3DRMLIGHTINGFREQUENCY;

//@@END_MSINTERNAL
typedef enum _D3DRMTEXTUREQUALITY
{   D3DRMTEXTURE_NEAREST,		/* choose nearest texel */
    D3DRMTEXTURE_LINEAR,		/* interpolate 4 texels */
    D3DRMTEXTURE_MIPNEAREST,		/* nearest texel in nearest mipmap  */
    D3DRMTEXTURE_MIPLINEAR,		/* interpolate 2 texels from 2 mipmaps */
    D3DRMTEXTURE_LINEARMIPNEAREST,	/* interpolate 4 texels in nearest mipmap */
    D3DRMTEXTURE_LINEARMIPLINEAR	/* interpolate 8 texels from 2 mipmaps */
} D3DRMTEXTUREQUALITY, *LPD3DRMTEXTUREQUALITY;

/*
 * Texture flags
 */
#define D3DRMTEXTURE_FORCERESIDENT	    0x00000001 /* texture should be kept in video memory */
#define D3DRMTEXTURE_STATIC		    0x00000002 /* texture will not change */
#define D3DRMTEXTURE_DOWNSAMPLEPOINT	    0x00000004 /* point filtering should be used when downsampling */
#define D3DRMTEXTURE_DOWNSAMPLEBILINEAR	    0x00000008 /* bilinear filtering should be used when downsampling */
#define D3DRMTEXTURE_DOWNSAMPLEREDUCEDEPTH  0x00000010 /* reduce bit depth when downsampling */
#define D3DRMTEXTURE_DOWNSAMPLENONE	    0x00000020 /* texture should never be downsampled */
#define D3DRMTEXTURE_CHANGEDPIXELS	    0x00000040 /* pixels have changed */
#define D3DRMTEXTURE_CHANGEDPALETTE	    0x00000080 /* palette has changed */
#define D3DRMTEXTURE_INVALIDATEONLY	    0x00000100 /* dirty regions are invalid */

/*
 * Shadow flags
 */
#define D3DRMSHADOW_TRUEALPHA		    0x00000001 /* shadow should render without artifacts when true alpha is on */

typedef enum _D3DRMCOMBINETYPE
{   D3DRMCOMBINE_REPLACE,
    D3DRMCOMBINE_BEFORE,
    D3DRMCOMBINE_AFTER
} D3DRMCOMBINETYPE, *LPD3DRMCOMBINETYPE;

typedef D3DCOLORMODEL D3DRMCOLORMODEL, *LPD3DRMCOLORMODEL;

typedef enum _D3DRMPALETTEFLAGS
{   D3DRMPALETTE_FREE,			/* renderer may use this entry freely */
    D3DRMPALETTE_READONLY,		/* fixed but may be used by renderer */
    D3DRMPALETTE_RESERVED		/* may not be used by renderer */
} D3DRMPALETTEFLAGS, *LPD3DRMPALETTEFLAGS;

typedef struct _D3DRMPALETTEENTRY
{   unsigned char red;		/* 0 .. 255 */
    unsigned char green;	/* 0 .. 255 */
    unsigned char blue;		/* 0 .. 255 */
    unsigned char flags;	/* one of D3DRMPALETTEFLAGS */
} D3DRMPALETTEENTRY, *LPD3DRMPALETTEENTRY;

typedef struct _D3DRMIMAGE
{   int width, height;		/* width and height in pixels */
    int aspectx, aspecty;	/* aspect ratio for non-square pixels */
    int depth;			/* bits per pixel */
    int rgb;			/* if false, pixels are indices into a
				   palette otherwise, pixels encode
				   RGB values. */
    int bytes_per_line;		/* number of bytes of memory for a
				   scanline. This must be a multiple
				   of 4. */
    void* buffer1;		/* memory to render into (first buffer). */
    void* buffer2;		/* second rendering buffer for double
				   buffering, set to NULL for single
				   buffering. */
    unsigned long red_mask;
    unsigned long green_mask;
    unsigned long blue_mask;
    unsigned long alpha_mask;	/* if rgb is true, these are masks for
				   the red, green and blue parts of a
				   pixel.  Otherwise, these are masks
				   for the significant bits of the
				   red, green and blue elements in the
				   palette.  For instance, most SVGA
				   displays use 64 intensities of red,
				   green and blue, so the masks should
				   all be set to 0xfc. */
    int palette_size;           /* number of entries in palette */
    D3DRMPALETTEENTRY* palette;	/* description of the palette (only if
				   rgb is false).  Must be (1<<depth)
				   elements. */
} D3DRMIMAGE, *LPD3DRMIMAGE;

typedef enum _D3DRMWRAPTYPE
{   D3DRMWRAP_FLAT,
    D3DRMWRAP_CYLINDER,
    D3DRMWRAP_SPHERE,
    D3DRMWRAP_CHROME,
    D3DRMWRAP_SHEET,
    D3DRMWRAP_BOX
} D3DRMWRAPTYPE, *LPD3DRMWRAPTYPE;

#define D3DRMWIREFRAME_CULL		1 /* cull backfaces */
#define D3DRMWIREFRAME_HIDDENLINE	2 /* lines are obscured by closer objects */

/*
 * Do not use righthanded perspective in Viewport2::SetProjection().
 * Set up righthanded mode by using IDirect3DRM3::SetOptions().
 */
typedef enum _D3DRMPROJECTIONTYPE
{   D3DRMPROJECT_PERSPECTIVE,
    D3DRMPROJECT_ORTHOGRAPHIC,
    D3DRMPROJECT_RIGHTHANDPERSPECTIVE, /* Only valid pre-DX6 */
    D3DRMPROJECT_RIGHTHANDORTHOGRAPHIC /* Only valid pre-DX6 */
} D3DRMPROJECTIONTYPE, *LPD3DRMPROJECTIONTYPE;

#define D3DRMOPTIONS_LEFTHANDED  0x00000001L /* Default */
#define D3DRMOPTIONS_RIGHTHANDED 0x00000002L

typedef enum _D3DRMXOFFORMAT
{   D3DRMXOF_BINARY,
    D3DRMXOF_COMPRESSED,
    D3DRMXOF_TEXT
} D3DRMXOFFORMAT, *LPD3DRMXOFFORMAT;

typedef DWORD D3DRMSAVEOPTIONS;
#define D3DRMXOFSAVE_NORMALS 1
#define D3DRMXOFSAVE_TEXTURECOORDINATES 2
#define D3DRMXOFSAVE_MATERIALS 4
#define D3DRMXOFSAVE_TEXTURENAMES 8
#define D3DRMXOFSAVE_ALL 15
#define D3DRMXOFSAVE_TEMPLATES 16
#define D3DRMXOFSAVE_TEXTURETOPOLOGY 32

typedef enum _D3DRMCOLORSOURCE
{   D3DRMCOLOR_FROMFACE,
    D3DRMCOLOR_FROMVERTEX
} D3DRMCOLORSOURCE, *LPD3DRMCOLORSOURCE;

typedef enum _D3DRMFRAMECONSTRAINT
{   D3DRMCONSTRAIN_Z,		/* use only X and Y rotations */
    D3DRMCONSTRAIN_Y,		/* use only X and Z rotations */
    D3DRMCONSTRAIN_X		/* use only Y and Z rotations */
} D3DRMFRAMECONSTRAINT, *LPD3DRMFRAMECONSTRAINT;

typedef enum _D3DRMMATERIALMODE
{   D3DRMMATERIAL_FROMMESH,
    D3DRMMATERIAL_FROMPARENT,
    D3DRMMATERIAL_FROMFRAME
} D3DRMMATERIALMODE, *LPD3DRMMATERIALMODE;

typedef enum _D3DRMFOGMODE
{   D3DRMFOG_LINEAR,		/* linear between start and end */
    D3DRMFOG_EXPONENTIAL,	/* density * exp(-distance) */
    D3DRMFOG_EXPONENTIALSQUARED	/* density * exp(-distance*distance) */
} D3DRMFOGMODE, *LPD3DRMFOGMODE;

typedef enum _D3DRMZBUFFERMODE {
    D3DRMZBUFFER_FROMPARENT,	/* default */
    D3DRMZBUFFER_ENABLE,	/* enable zbuffering */
    D3DRMZBUFFER_DISABLE	/* disable zbuffering */
} D3DRMZBUFFERMODE, *LPD3DRMZBUFFERMODE;

typedef enum _D3DRMSORTMODE {
    D3DRMSORT_FROMPARENT,	/* default */
    D3DRMSORT_NONE,		/* don't sort child frames */
    D3DRMSORT_FRONTTOBACK,	/* sort child frames front-to-back */
    D3DRMSORT_BACKTOFRONT	/* sort child frames back-to-front */
} D3DRMSORTMODE, *LPD3DRMSORTMODE;

typedef struct _D3DRMMATERIALOVERRIDE
{
    DWORD         dwSize;	/* Size of this structure */
    DWORD         dwFlags;	/* Indicate which fields are valid */
    D3DCOLORVALUE dcDiffuse;	/* RGBA */
    D3DCOLORVALUE dcAmbient;	/* RGB */
    D3DCOLORVALUE dcEmissive;	/* RGB */
    D3DCOLORVALUE dcSpecular;	/* RGB */
    D3DVALUE      dvPower;
    LPUNKNOWN     lpD3DRMTex;
} D3DRMMATERIALOVERRIDE, *LPD3DRMMATERIALOVERRIDE;

#define D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAONLY     0x00000001L
#define D3DRMMATERIALOVERRIDE_DIFFUSE_RGBONLY       0x00000002L
#define D3DRMMATERIALOVERRIDE_DIFFUSE               0x00000003L
#define D3DRMMATERIALOVERRIDE_AMBIENT               0x00000004L
#define D3DRMMATERIALOVERRIDE_EMISSIVE              0x00000008L
#define D3DRMMATERIALOVERRIDE_SPECULAR              0x00000010L
#define D3DRMMATERIALOVERRIDE_POWER                 0x00000020L
#define D3DRMMATERIALOVERRIDE_TEXTURE               0x00000040L
#define D3DRMMATERIALOVERRIDE_DIFFUSE_ALPHAMULTIPLY 0x00000080L
#define D3DRMMATERIALOVERRIDE_ALL                   0x000000FFL

#define D3DRMFPTF_ALPHA                           0x00000001L
#define D3DRMFPTF_NOALPHA                         0x00000002L
#define D3DRMFPTF_PALETTIZED                      0x00000004L
#define D3DRMFPTF_NOTPALETTIZED                   0x00000008L

#define D3DRMSTATECHANGE_UPDATEONLY		  0x000000001L
#define D3DRMSTATECHANGE_VOLATILE		  0x000000002L
#define D3DRMSTATECHANGE_NONVOLATILE		  0x000000004L
//@@BEGIN_MSINTERNAL
#define D3DRMSTATECHANGE_OVERRIDE		  0x000000008L
//@@END_MSINTERNAL
#define D3DRMSTATECHANGE_RENDER			  0x000000020L
#define D3DRMSTATECHANGE_LIGHT			  0x000000040L

/*
 * Values for flags in RM3::CreateDeviceFromSurface
 */
#define D3DRMDEVICE_NOZBUFFER           0x00000001L

/*
 * Values for flags in Object2::SetClientData
 */
#define D3DRMCLIENTDATA_NONE            0x00000001L
#define D3DRMCLIENTDATA_LOCALFREE       0x00000002L
#define D3DRMCLIENTDATA_IUNKNOWN        0x00000004L

/*
 * Values for flags in Frame2::AddMoveCallback.
 */
#define D3DRMCALLBACK_PREORDER		0
#define D3DRMCALLBACK_POSTORDER		1

/*
 * Values for flags in MeshBuilder2::RayPick.
 */
#define D3DRMRAYPICK_ONLYBOUNDINGBOXES		1
#define D3DRMRAYPICK_IGNOREFURTHERPRIMITIVES	2
#define D3DRMRAYPICK_INTERPOLATEUV		4
#define D3DRMRAYPICK_INTERPOLATECOLOR		8
#define D3DRMRAYPICK_INTERPOLATENORMAL		0x10	

/*
 * Values for flags in MeshBuilder3::AddFacesIndexed.
 */
#define D3DRMADDFACES_VERTICESONLY		1

/*
 * Values for flags in MeshBuilder2::GenerateNormals.
 */
#define D3DRMGENERATENORMALS_PRECOMPACT		1
#define D3DRMGENERATENORMALS_USECREASEANGLE	2

/*
 * Values for MeshBuilder3::GetParentMesh
 */
#define D3DRMMESHBUILDER_DIRECTPARENT		1
#define D3DRMMESHBUILDER_ROOTMESH		2

/*
 * Flags for MeshBuilder3::Enable
 */
#define D3DRMMESHBUILDER_RENDERENABLE	0x00000001L
#define D3DRMMESHBUILDER_PICKENABLE     0x00000002L

/*
 * Flags for MeshBuilder3::AddMeshBuilder
 */
#define D3DRMADDMESHBUILDER_DONTCOPYAPPDATA	1
#define D3DRMADDMESHBUILDER_FLATTENSUBMESHES	2
#define D3DRMADDMESHBUILDER_NOSUBMESHES		4

/*
 * Flags for Object2::GetAge when used with MeshBuilders
 */
#define D3DRMMESHBUILDERAGE_GEOMETRY    0x00000001L
#define D3DRMMESHBUILDERAGE_MATERIALS   0x00000002L
#define D3DRMMESHBUILDERAGE_TEXTURES    0x00000004L

/*
 * Format flags for MeshBuilder3::AddTriangles.
 */
#define D3DRMFVF_TYPE                   0x00000001L
#define D3DRMFVF_NORMAL                 0x00000002L
#define D3DRMFVF_COLOR                  0x00000004L
#define D3DRMFVF_TEXTURECOORDS          0x00000008L

#define D3DRMVERTEX_STRIP               0x00000001L
#define D3DRMVERTEX_FAN                 0x00000002L
#define D3DRMVERTEX_LIST                0x00000004L

/*
 * Values for flags in Viewport2::Clear2
 */
#define D3DRMCLEAR_TARGET               0x00000001L
#define D3DRMCLEAR_ZBUFFER              0x00000002L
#define D3DRMCLEAR_DIRTYRECTS           0x00000004L
#define D3DRMCLEAR_ALL                  (D3DRMCLEAR_TARGET | \
					 D3DRMCLEAR_ZBUFFER | \
					 D3DRMCLEAR_DIRTYRECTS)

/*
 * Values for flags in Frame3::SetSceneFogMethod
 */
#define D3DRMFOGMETHOD_VERTEX          0x00000001L
#define D3DRMFOGMETHOD_TABLE           0x00000002L
#define D3DRMFOGMETHOD_ANY             0x00000004L

/*
 * Values for flags in Frame3::SetTraversalOptions
 */
#define D3DRMFRAME_RENDERENABLE        0x00000001L
#define D3DRMFRAME_PICKENABLE          0x00000002L

typedef DWORD D3DRMANIMATIONOPTIONS;
#define D3DRMANIMATION_OPEN 0x01L
#define D3DRMANIMATION_CLOSED 0x02L
#define D3DRMANIMATION_LINEARPOSITION 0x04L
#define D3DRMANIMATION_SPLINEPOSITION 0x08L
#define D3DRMANIMATION_SCALEANDROTATION 0x00000010L
#define D3DRMANIMATION_POSITION 0x00000020L

typedef DWORD D3DRMINTERPOLATIONOPTIONS;
#define D3DRMINTERPOLATION_OPEN 0x01L
#define D3DRMINTERPOLATION_CLOSED 0x02L
#define D3DRMINTERPOLATION_NEAREST 0x0100L
#define D3DRMINTERPOLATION_LINEAR 0x04L
#define D3DRMINTERPOLATION_SPLINE 0x08L
#define D3DRMINTERPOLATION_VERTEXCOLOR 0x40L
#define D3DRMINTERPOLATION_SLERPNORMALS 0x80L

typedef DWORD D3DRMLOADOPTIONS;

#define D3DRMLOAD_FROMFILE  0x00L
#define D3DRMLOAD_FROMRESOURCE 0x01L
#define D3DRMLOAD_FROMMEMORY 0x02L
#define D3DRMLOAD_FROMSTREAM 0x04L
#define D3DRMLOAD_FROMURL 0x08L

#define D3DRMLOAD_BYNAME 0x10L
#define D3DRMLOAD_BYPOSITION 0x20L
#define D3DRMLOAD_BYGUID 0x40L
#define D3DRMLOAD_FIRST 0x80L

#define D3DRMLOAD_INSTANCEBYREFERENCE 0x100L
#define D3DRMLOAD_INSTANCEBYCOPYING 0x200L

#define D3DRMLOAD_ASYNCHRONOUS 0x400L

typedef struct _D3DRMLOADRESOURCE {
  HMODULE hModule;
  LPCTSTR lpName;
  LPCTSTR lpType;
} D3DRMLOADRESOURCE, *LPD3DRMLOADRESOURCE;

typedef struct _D3DRMLOADMEMORY {
  LPVOID lpMemory;
  DWORD dSize;
} D3DRMLOADMEMORY, *LPD3DRMLOADMEMORY;

#define D3DRMPMESHSTATUS_VALID 0x01L
#define D3DRMPMESHSTATUS_INTERRUPTED 0x02L
#define D3DRMPMESHSTATUS_BASEMESHCOMPLETE 0x04L
#define D3DRMPMESHSTATUS_COMPLETE 0x08L
#define D3DRMPMESHSTATUS_RENDERABLE 0x10L

#define D3DRMPMESHEVENT_BASEMESH 0x01L
#define D3DRMPMESHEVENT_COMPLETE 0x02L

typedef struct _D3DRMPMESHLOADSTATUS {
  DWORD dwSize;            // Size of this structure
  DWORD dwPMeshSize;       // Total Size (bytes)
  DWORD dwBaseMeshSize;    // Total Size of the Base Mesh
  DWORD dwBytesLoaded;     // Total bytes loaded
  DWORD dwVerticesLoaded;  // Number of vertices loaded
  DWORD dwFacesLoaded;     // Number of faces loaded
  HRESULT dwLoadResult;    // Result of the load operation
  DWORD dwFlags;
} D3DRMPMESHLOADSTATUS, *LPD3DRMPMESHLOADSTATUS;

typedef enum _D3DRMUSERVISUALREASON {
    D3DRMUSERVISUAL_CANSEE,
    D3DRMUSERVISUAL_RENDER
} D3DRMUSERVISUALREASON, *LPD3DRMUSERVISUALREASON;

//@@BEGIN_MSINTERNAL
typedef LPVOID (*D3DRMMALLOCFUNCTION)(DWORD);
typedef D3DRMMALLOCFUNCTION *LPD3DRMMALLOCFUNCTION;
typedef LPVOID (*D3DRMREALLOCFUNCTION)(LPVOID, DWORD);
typedef D3DRMREALLOCFUNCTION *LPD3DRMREALLOCFUNCTION; 
typedef VOID  (*D3DRMFREEFUNCTION)(LPVOID);
typedef D3DRMFREEFUNCTION *LPD3DRMFREEFUNCTION;
//@@END_MSINTERNAL

typedef struct _D3DRMANIMATIONKEY 
{
    DWORD dwSize;
    DWORD dwKeyType;
    D3DVALUE dvTime;
    DWORD dwID;
#if (!defined __cplusplus) || (!defined D3D_OVERLOADS)
    union 
    {
	D3DRMQUATERNION dqRotateKey;
	D3DVECTOR dvScaleKey;
	D3DVECTOR dvPositionKey;
    };
#else
    /*
     * We do this as D3D_OVERLOADS defines constructors for D3DVECTOR,
     * this can then not be used in a union.  Use the inlines provided
     * to extract and set the required component.
     */
    D3DVALUE dvK[4];
#endif
} D3DRMANIMATIONKEY;
typedef D3DRMANIMATIONKEY *LPD3DRMANIMATIONKEY;

#if (defined __cplusplus) && (defined D3D_OVERLOADS)
inline VOID
D3DRMAnimationGetRotateKey(const D3DRMANIMATIONKEY& rmKey,
			   D3DRMQUATERNION& rmQuat)
{
    rmQuat.s = rmKey.dvK[0];
    rmQuat.v = D3DVECTOR(rmKey.dvK[1], rmKey.dvK[2], rmKey.dvK[3]);
}

inline VOID
D3DRMAnimationGetScaleKey(const D3DRMANIMATIONKEY& rmKey,
			  D3DVECTOR& dvVec)
{
    dvVec = D3DVECTOR(rmKey.dvK[0], rmKey.dvK[1], rmKey.dvK[2]);
}

inline VOID
D3DRMAnimationGetPositionKey(const D3DRMANIMATIONKEY& rmKey,
			     D3DVECTOR& dvVec)
{
    dvVec = D3DVECTOR(rmKey.dvK[0], rmKey.dvK[1], rmKey.dvK[2]);
}
inline VOID
D3DRMAnimationSetRotateKey(D3DRMANIMATIONKEY& rmKey,
			   const D3DRMQUATERNION& rmQuat)
{
    rmKey.dvK[0] = rmQuat.s;
    rmKey.dvK[1] = rmQuat.v.x;
    rmKey.dvK[2] = rmQuat.v.y;
    rmKey.dvK[3] = rmQuat.v.z;
}

inline VOID
D3DRMAnimationSetScaleKey(D3DRMANIMATIONKEY& rmKey,
			  const D3DVECTOR& dvVec)
{
    rmKey.dvK[0] = dvVec.x;
    rmKey.dvK[1] = dvVec.y;
    rmKey.dvK[2] = dvVec.z;
}

inline VOID
D3DRMAnimationSetPositionKey(D3DRMANIMATIONKEY& rmKey,
			     const D3DVECTOR& dvVec)
{
    rmKey.dvK[0] = dvVec.x;
    rmKey.dvK[1] = dvVec.y;
    rmKey.dvK[2] = dvVec.z;
}
#endif

#define D3DRMANIMATION_ROTATEKEY 0x01
#define D3DRMANIMATION_SCALEKEY 0x02
#define D3DRMANIMATION_POSITIONKEY 0x03


typedef DWORD D3DRMMAPPING, D3DRMMAPPINGFLAG, *LPD3DRMMAPPING;
static const D3DRMMAPPINGFLAG D3DRMMAP_WRAPU = 1;
static const D3DRMMAPPINGFLAG D3DRMMAP_WRAPV = 2;
static const D3DRMMAPPINGFLAG D3DRMMAP_PERSPCORRECT = 4;

typedef struct _D3DRMVERTEX
{   D3DVECTOR	    position;
    D3DVECTOR	    normal;
    D3DVALUE	    tu, tv;
    D3DCOLOR	    color;
} D3DRMVERTEX, *LPD3DRMVERTEX;

typedef LONG D3DRMGROUPINDEX; /* group indexes begin a 0 */
static const D3DRMGROUPINDEX D3DRMGROUP_ALLGROUPS = -1;

/*
 * Create a color from three components in the range 0-1 inclusive.
 */
extern D3DCOLOR D3DRMAPI	D3DRMCreateColorRGB(D3DVALUE red,
					  D3DVALUE green,
					  D3DVALUE blue);

/*
 * Create a color from four components in the range 0-1 inclusive.
 */
extern D3DCOLOR D3DRMAPI	D3DRMCreateColorRGBA(D3DVALUE red,
						 D3DVALUE green,
						 D3DVALUE blue,
						 D3DVALUE alpha);

/*
 * Get the red component of a color.
 */
extern D3DVALUE 		D3DRMAPI D3DRMColorGetRed(D3DCOLOR);

/*
 * Get the green component of a color.
 */
extern D3DVALUE 		D3DRMAPI D3DRMColorGetGreen(D3DCOLOR);

/*
 * Get the blue component of a color.
 */
extern D3DVALUE 		D3DRMAPI D3DRMColorGetBlue(D3DCOLOR);

/*
 * Get the alpha component of a color.
 */
extern D3DVALUE 		D3DRMAPI D3DRMColorGetAlpha(D3DCOLOR);

/*
 * Add two vectors.  Returns its first argument.
 */
extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorAdd(LPD3DVECTOR d,
					  LPD3DVECTOR s1,
					  LPD3DVECTOR s2);

/*
 * Subtract two vectors.  Returns its first argument.
 */
extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorSubtract(LPD3DVECTOR d,
					       LPD3DVECTOR s1,
					       LPD3DVECTOR s2);
/*
 * Reflect a ray about a given normal.  Returns its first argument.
 */
extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorReflect(LPD3DVECTOR d,
					      LPD3DVECTOR ray,
					      LPD3DVECTOR norm);

/*
 * Calculate the vector cross product.  Returns its first argument.
 */
extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorCrossProduct(LPD3DVECTOR d,
						   LPD3DVECTOR s1,
						   LPD3DVECTOR s2);
/*
 * Return the vector dot product.
 */
extern D3DVALUE 		D3DRMAPI D3DRMVectorDotProduct(LPD3DVECTOR s1,
						 LPD3DVECTOR s2);

/*
 * Scale a vector so that its modulus is 1.  Returns its argument or
 * NULL if there was an error (e.g. a zero vector was passed).
 */
extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorNormalize(LPD3DVECTOR);
#define D3DRMVectorNormalise D3DRMVectorNormalize

/*
 * Return the length of a vector (e.g. sqrt(x*x + y*y + z*z)).
 */
extern D3DVALUE 		D3DRMAPI D3DRMVectorModulus(LPD3DVECTOR v);

/*
 * Set the rotation part of a matrix to be a rotation of theta radians
 * around the given axis.
 */

extern LPD3DVECTOR 	D3DRMAPI D3DRMVectorRotate(LPD3DVECTOR r, LPD3DVECTOR v, LPD3DVECTOR axis, D3DVALUE theta);

/*
 * Scale a vector uniformly in all three axes
 */
extern LPD3DVECTOR	D3DRMAPI D3DRMVectorScale(LPD3DVECTOR d, LPD3DVECTOR s, D3DVALUE factor);

/*
 * Return a random unit vector
 */
extern LPD3DVECTOR	D3DRMAPI D3DRMVectorRandom(LPD3DVECTOR d);

/*
 * Returns a unit quaternion that represents a rotation of theta radians
 * around the given axis.
 */

extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionFromRotation(LPD3DRMQUATERNION quat,
							      LPD3DVECTOR v,
							      D3DVALUE theta);

/*
 * Calculate the product of two quaternions
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionMultiply(LPD3DRMQUATERNION q,
						    	  LPD3DRMQUATERNION a,
						   	  LPD3DRMQUATERNION b);

/*
 * Interpolate between two quaternions
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionSlerp(LPD3DRMQUATERNION q,
						       LPD3DRMQUATERNION a,
						       LPD3DRMQUATERNION b,
						       D3DVALUE alpha);

/*
 * Calculate the matrix for the rotation that a unit quaternion represents
 */
extern void 		D3DRMAPI D3DRMMatrixFromQuaternion(D3DRMMATRIX4D dmMat, LPD3DRMQUATERNION lpDqQuat);

/*
 * Calculate the quaternion that corresponds to a rotation matrix
 */
extern LPD3DRMQUATERNION D3DRMAPI D3DRMQuaternionFromMatrix(LPD3DRMQUATERNION, D3DRMMATRIX4D);

//@@BEGIN_MSINTERNAL
#ifdef BUILD_RLAPI
#ifdef __psx__
#ifndef FIXED_POINT_API
#define FIXED_POINT_API
#endif
#ifndef FIXED_POINT_INTERNAL
#define FIXED_POINT_INTERNAL
#endif
#endif

/* RLRGB and RLRGBA may be used as initialisers for RLColors
 * The int or float values must be in the range 0..1
 */
#define RLRGB(r, g, b) \
    (0xff000000L | ( ((long)((r) * 255)) << 16) | (((long)((g) * 255)) << 8) | (long)((b) * 255))
#define RLRGBA(r, g, b, a) \
    (	(((long)((a) * 255)) << 24) | (((long)((r) * 255)) << 16) \
    |	(((long)((g) * 255)) << 8) | (long)((b) * 255) \
    )

typedef D3DVALUE RLValue;
typedef D3DCOLOR RLColor;
#ifdef FIXED_POINT_API
#ifndef __psx__
#define RLVal(x)		((RLValue)((x) * (double)(1<<16)))
#else
#define RLVal(x)		((RLValue)((x) * 65536))
#endif
#define RLInt(x)		((x) >> 16)
#define RLFloat(x)		((x) / 65536.0)
extern RLValue D3DRMAPI RLDivide(RLValue, RLValue);
extern RLValue D3DRMAPI RLMultiply(RLValue, RLValue);
#define RLMultiply3(a,b,c)	RLMultiply(RLMultiply(a, b), c)
#else
typedef float 		RLValue;
#define RLVal(x)	((RLValue) (x))
#define RLInt(x)	((int)(x))
#define RLFloat(x)	((float) (x))
#define RLDivide(a,b)	((RLValue) ((double) (a) / (double) (b)))
#define RLMultiply(a,b)	((RLValue) ((a) * (b)))
#define RLMultiply3(a,b,c)	((RLValue) ((a) * (b) * (c)))
#endif

/*
 * These types for internal compilation
 */
typedef D3DRECT RLRectangle;
typedef D3DVECTOR RLVector;
typedef D3DRMVECTOR4D RLVector4d;
typedef D3DRMMATRIX4D RLMatrix4d;
typedef D3DRMQUATERNION RLQuaternion;
typedef D3DRMBOX RLBox;
typedef D3DRMWRAPCALLBACK RLWrapCallback;

typedef D3DRMLIGHTTYPE RLLightType;
#define RLLightAmbient D3DRMLIGHT_AMBIENT
#define RLLightPoint D3DRMLIGHT_POINT
#define RLLightSpot D3DRMLIGHT_SPOT
#define RLLightDirectional D3DRMLIGHT_DIRECTIONAL
#define RLLightParallelPoint D3DRMLIGHT_PARALLELPOINT

typedef D3DRMSHADEMODE RLShadeMode;
#define RLShadeFlat D3DRMSHADE_FLAT
#define RLShadeGouraud D3DRMSHADE_GOURAUD
#define RLShadePhong D3DRMSHADE_PHONG
#define RLShadeMask D3DRMSHADE_MASK
#define RLShadeMax D3DRMSHADE_MAX

typedef D3DRMLIGHTMODE RLLightMode;
#define RLLightOff D3DRMLIGHT_OFF
#define RLLightOn D3DRMLIGHT_ON
#define RLLightMask D3DRMLIGHT_MASK
#define RLLightMax D3DRMLIGHT_MAX

typedef D3DRMFILLMODE RLFillMode;
#define RLFillPoints D3DRMFILL_POINTS
#define RLFillWireframe D3DRMFILL_WIREFRAME
#define RLFillSolid D3DRMFILL_SOLID
#define RLFillMask D3DRMFILL_MASK
#define RLFillMax D3DRMFILL_MAX

typedef D3DRMRENDERQUALITY RLRenderQuality;

#define RLRenderWireframe D3DRMRENDER_WIREFRAME
#define RLRenderUnlitflat D3DRMRENDER_UNLITFLAT
#define RLRenderFlat D3DRMRENDER_FLAT
#define RLRenderGouraud D3DRMRENDER_GOURAUD
#define RLRenderPhong D3DRMRENDER_PHONG

typedef D3DRMLIGHTINGFREQUENCY RLLightingFrequency;
#define RLLightNever D3DRMLIGHT_NEVER
#define RLLightOnce D3DRMLIGHT_ONCE
#define RLLightContinually D3DRMLIGHT_CONTINUALLY

typedef D3DRMTEXTUREQUALITY RLTextureQuality;
#define RLTextureNearest D3DRMTEXTURE_NEAREST
#define RLTextureLinear D3DRMTEXTURE_LINEAR
#define RLTextureMipNearest D3DRMTEXTURE_MIPNEAREST
#define RLTextureMipLinear D3DRMTEXTURE_MIPLINEAR
#define RLTextureLinearMipNearest D3DRMTEXTURE_LINEARMIPNEAREST
#define RLTextureLinearMipLinear D3DRMTEXTURE_LINEARMIPLINEAR

typedef D3DRMCOMBINETYPE RLCombineType;
#define RLCombineReplace D3DRMCOMBINE_REPLACE
#define RLCombineBefore D3DRMCOMBINE_BEFORE
#define RLCombineAfter D3DRMCOMBINE_AFTER

typedef D3DCOLORMODEL RLColorModel;
#define RLColorRamp D3DCOLOR_MONO
#define RLColorRGB D3DCOLOR_RGB

typedef D3DRMPALETTEFLAGS RLPaletteFlags;
#define RLPaletteFree D3DRMPALETTE_FREE
#define RLPaletteReadOnly D3DRMPALETTE_READONLY
#define RLPaletteReserved D3DRMPALETTE_RESERVED

typedef D3DRMPALETTEENTRY RLPaletteEntry;
typedef D3DRMIMAGE RLImage;

typedef D3DRMWRAPTYPE RLWrapType;
#define RLWrapFlat D3DRMWRAP_FLAT
#define RLWrapCylinder D3DRMWRAP_CYLINDER
#define RLWrapSphere D3DRMWRAP_SPHERE
#define RLWrapChrome D3DRMWRAP_CHROME
#define RLWrapSheet D3DRMWRAP_SHEET
#define RLWrapBox D3DRMWRAP_BOX

#define RLWireframeCull D3DRMWIREFRAME_CULL
#define RLWireframeHiddenLine D3DRMWIREFRAME_HIDDENLINE

typedef D3DRMPROJECTIONTYPE RLProjectionType;
#define RLProjectPerspective D3DRMPROJECT_PERSPECTIVE
#define RLProjectOrthographic D3DRMPROJECT_ORTHOGRAPHIC
#define RLProjectRightHandPerspective D3DRMPROJECT_RIGHTHANDPERSPECTIVE
#define RLProjectRightHandOrthographic D3DRMPROJECT_RIGHTHANDORTHOGRAPHIC

typedef D3DRMXOFFORMAT RLXOFFormat;
#define RLXOFBinary			D3DRMXOF_BINARY
#define RLXOFCompressed			D3DRMXOF_COMPRESSED
#define RLXOFText			D3DRMXOF_TEXT

#define RLXOFSaveNormals		D3DRMXOFSAVE_NORMALS
#define RLXOFSaveTextureCoordinates	D3DRMXOFSAVE_TEXTURECOORDINATES
#define RLXOFSaveMaterials 		D3DRMXOFSAVE_MATERIALS
#define RLXOFSaveTextureNames		D3DRMXOFSAVE_TEXTURENAMES
#define RLXOFSaveAll			D3DRMXOFSAVE_ALL
#define RLXOFSaveTemplates              D3DRMXOFSAVE_TEMPLATES

typedef D3DRMCOLORSOURCE RLColorSource;
#define RLColorFromFace D3DRMCOLOR_FROMFACE
#define RLColorFromVertex D3DRMCOLOR_FROMVERTEX

typedef D3DRMFRAMECONSTRAINT RLFrameConstraint;
#define RLConstrainZ D3DRMCONSTRAIN_Z
#define RLConstrainY D3DRMCONSTRAIN_Y
#define RLConstrainX D3DRMCONSTRAIN_X

typedef D3DRMMATERIALMODE RLMaterialMode;
#define RLMaterialFromMesh D3DRMMATERIAL_FROMMESH
#define RLMaterialFromParent D3DRMMATERIAL_FROMPARENT
#define RLMaterialFromFrame D3DRMMATERIAL_FROMFRAME

typedef D3DRMFOGMODE RLFogMode;
#define RLFogLinear D3DRMFOG_LINEAR
#define RLFogExponential D3DRMFOG_EXPONENTIAL
#define RLFogExponentialSquared D3DRMFOG_EXPONENTIALSQUARED

#define RLAnimationOpen			D3DRMANIMATION_OPEN
#define RLAnimationClosed		D3DRMANIMATION_CLOSED
#define RLAnimationLinearPosition	D3DRMANIMATION_LINEARPOSITION
#define RLAnimationSplinePosition	D3DRMANIMATION_SPLINEPOSITION
#define RLAnimationScaleAndRotation	D3DRMANIMATION_SCALEANDROTATION
#define RLAnimationPosition		D3DRMANIMATION_POSITION

typedef D3DRMUSERVISUALREASON RLUserVisualReason;
#define RLUserVisualCanSee D3DRMUSERVISUAL_CANSEE
#define RLUserVisualRender D3DRMUSERVISUAL_RENDER

typedef D3DRMMALLOCFUNCTION RLMallocFunction;
typedef D3DRMREALLOCFUNCTION RLReallocFunction;
typedef D3DRMFREEFUNCTION RLFreeFunction;

typedef D3DRMMAPPING RLMapping, RLMappingFlag;
static const RLMapping RLMapWrapU = 1;
static const RLMapping RLMapWrapV = 2;
static const RLMapping RLMapPerspCorrect = 4;

typedef D3DRMVERTEX RLVertex;

typedef D3DRMGROUPINDEX RLGroupIndex;
static const RLGroupIndex RLAllGroups = -1;

#define RLCreateColorRGB	D3DRMCreateColorRGB
#define RLCreateColorRGBA	D3DRMCreateColorRGBA
#define RLColorGetRed		D3DRMColorGetRed
#define RLColorGetGreen		D3DRMColorGetGreen
#define RLColorGetBlue		D3DRMColorGetBlue
#define RLColorGetAlpha		D3DRMColorGetAlpha
#define RLVectorAdd		D3DRMVectorAdd
#define RLVectorSubtract	D3DRMVectorSubtract
#define RLVectorReflect		D3DRMVectorReflect
#define RLVectorCrossProduct	D3DRMVectorCrossProduct
#define RLVectorDotProduct	D3DRMVectorDotProduct
#define RLVectorNormalize	D3DRMVectorNormalize
#define RLVectorNormalise	D3DRMVectorNormalize
#define RLVectorModulus		D3DRMVectorModulus
#define RLVectorRotate		D3DRMVectorRotate
#define RLVectorScale		D3DRMVectorScale
#define RLVectorRandom		D3DRMVectorRandom
#define RLQuaternionFromRotation D3DRMQuaternionFromRotation
#define RLQuaternionMultiply	D3DRMQuaternionMultiply
#define RLQuaternionSlerp	D3DRMQuaternionSlerp
#define RLMatrixFromQuaternion	D3DRMMatrixFromQuaternion
#define RLQuaternionFromMatrix	D3DRMQuaternionFromMatrix
#endif /* BUILD_RLAPI */
//@@END_MSINTERNAL

#if defined(__cplusplus)
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\multimedia\inc\ddrawp.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddraw.h
 *  Content:    DirectDraw include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   24-dec-94  craige  initial implementation
 *   13-jan-95  craige  updated
 *   31-jan-95  craige  and even more ongoing work...
 *   01-mar-95  craige  flags with Get/SetExclusiveMode
 *   07-mar-95  craige  FourCC code stuff
 *   08-mar-95  craige  blt/overlay stretch distinction, bunch of new APIs
 *   11-mar-95  craige  palette stuff
 *   17-mar-95  craige  COM interface
 *   20-mar-95  craige  Get/SetExclusiveMode->Get/SetExclusiveModeOwner,
 *                      flags with CreateSurface and DuplicateSurface
 *   28-mar-95  craige  removed Get/SetColorKey, added FlipToGDISurface to
 *                      IDirectDraw; switched to PALETTEENTRY from RGBQUAD
 *   01-apr-95  craige  happy fun joy updated header file THANK YOU ERIC
 *   06-apr-95  craige  added dwVidMemTotal, dwVidMemFree to DDCAPS
 *   13-apr-95  craige  EricEng's little contribution to our being late
 *   15-apr-95  craige  GetBltStatus, added flag to GetFlipStatus
 *   12-may-95  craige  added GUIDS;DirectDrawEnumerate
 *   19-may-95  craige  added DDSEMO_ALLOWREBOOT
 *   23-may-95  craige  have driver GetCaps return HEL caps; added Flush,
 *                      GetBatchLimit, SetBatchLimit to IDirectDraw
 *   24-may-95  kylej   removed obsolete ZOrder variables
 *   24-may-95  craige  added Restore
 *   28-may-95  craige  added DDCAPS_COLORKEY_HWASSIST; Unicode support
 *   04-jun-95  craige  added IsLost
 *   05-jun-95  craige  removed GetVersion, FreeAllSurfaces, DefWindowProc;
 *                      change GarbageCollect to Compact
 *   06-jun-95  craige  removed GetExclusiveModeOwner; added parm to
 *                      SetExclusiveMode
 *   15-jun-95  craige  new surface interfaces: IDirectDrawSurfaceNotification,
 *                      IDirectDrawSurfaceComposition
 *   19-jun-95  craige  rationalized INVALIDxxx to DDERR_INVALIDOBJECT
 *   20-jun-95  kylej   added DDERR_CANNOTDETACHSURFACE
 *   21-jun-95  craige  added DirectDrawClipper object; removed clipping
 *                      info from surface object
 *   24-jun-95  craige  added DDBLTFAST_xxx flags
 *   27-jun-95  craige  removed Flush,Set/GetBatchLimit; added BltBatch
 *   30-jun-95  kylej   added DDERR_INCOMPATIBLEPRIMARY
 *   30-jun-95  craige  added dest align as well as src
 *   01-jul-95  craige  hide composition & streaming stuff; added DDERR_EXCEPTION
 *   02-jul-95  craige  hide clipper notification stuff; futzed with DDSCAPS
 *                      position in structures
 *   03-jul-95  kylej   changed EnumSurfaces declaration
 *   03-jul-95  craige  added pUnkOuter to all Create fns; added object ptr
 *                      to CreateSurface, removed lpClipList and lpDDSurface
 *                      from surface desc.
 *   05-jul-95  craige  added Initialize members to all interfaces to allow
 *                      for full COM integration
 *   09-jul-95  craige  added DDERR_LOCKEDSURFACES; changed SetExclusiveMode
 *                      to SetCooperativeLevel
 *   10-jul-95  kylej   added mirroring caps and overlay FX flags
 *   12-jul-95  craige  added DDSCAPS_OWNDC
 *   13-jul-95  craige  changed Get/SetOverlayPosition to take LONGs
 *   14-jul-95  craige  added dwFlags to DDOVERLAYFX
 *   15-jul-95  craige  set DDCAPS_NOHARDWARE
 *   15-jul-95  ericeng changed EnumSurface callback param order, BltBatch
 *                      params, moved all Const var references to a consistent
 *                      location, removed failure mode for height alignment
 *   18-jul-95  craige  removed Flush from surface object
 *   27-jul-95  craige  added DDCAPS_BLTCOLORFILL
 *   31-jul-95  craige  added DDCAPS_BANKSWITCHED, validation flags
 *   02-aug-95  craige  added dwMinOverlayStretch/dwMaxOverlayStretch to DDCAPS
 *   10-aug-95  toddla  added DDBLT_WAIT, DDBLTFAST_WAIT, DDLOCK_WAIT, DDFLIP_WAIT
 *   13-aug-95  craige  added dwCaps2 and reserved fields to DDCAPS; added
 *                      DDCAPS2_CERTIFIED; named alpha caps properly;
 *                      flags parm for Flip
 *   13-aug-95  toddla  added DDSCL_DONTHOOKHWND
 *   19-aug-95  ericeng added DDCAPS2_LIVEVIDEO and DDCAPS2_HWCODEC
 *   21-aug-95  craige  mode X support
 *   27-aug-95  craige  bug 742: added DDPCAPS_256
 *                      bug 738: use GUID instead of IID
 *   22-sep-95  craige  bug 1268,1269:  getbltstatus/getflipstatus flags wrong
 *   09-nov-95  colinmc added support for 1, 2 and 4 bit RGB and indexed
 *                      palettes
 *   27-nov-95  colinmc new member to return available vram of a given type
 *                      (determined by DDSCAPS).
 *   05-dec-95  colinmc changed DDSCAPS_TEXTUREMAP => DDSCAPS_TEXTURE for
 *                      consistency with Direct3D
 *   05-dec-95  colinmc added mip-map support
 *   09-dec-95  colinmc added execute buffer support
 *   13-dec-95  colinmc added shared back and z-buffer support
 *   18-dec-95  colinmc added valid caps mask for surface caps
 *   25-dec-95  craige  changed IDirectDrawV2 to IDirectDraw2
 *   31-dec-95  craige  added CLSID_DirectDraw
 *   04-jan-96  colinmc added explicit support for z-buffer clears
 *   12-feb-96  kylej   added  Interface
 *   23-feb-96  kylej   added IDirectDrawSurface2 Interface
 *   01-mar-96  kylej   new ddcaps structure
 *   06-mar-96  kylej   changed HANDLEs to DWORDs
 *   13-mar-96  kylej   added DD_Surface_GetDDInterface in IDirectDrawSurface2
 *   14-mar-96  colinmc added CLSID_DirectDrawClipper and added the clipper
 *                      creation API function back in
 *   21-mar-96  colinmc Bug 13316: Unitialized interfaces
 *   24-mar-96  colinmc Bug 14321: Structure change to allow flippable mip
 *                      map chains with a single call
 *   26-mar-96  colinmc Bug 14470: Compressed surface support
 *   15-apr-96  colinmc Bug 16855: Can't pass NULL to Initialize in C++
 *   19-apr-96  colinmc Bug 18059: News caps bit to flag that you can't do
 *                      2D during 3D.
 *   01-may-96  colinmc Bug 20005: InternalLock does not check for lost
 *                      surfaces
 *   25-jul-96  scottm  Added DDCAPS2_AUTOFLIPOVERLAY,
 *                      DDCAPS2_CANSMOOTHINTERLEAVED,DDCAPS2_CANSMOOTHNONINTERLEAVED
 *   08-oct-96  ketand  Added support for Interleaved Z (aka RGBZ surfaces)
 *   15-nov-96  colinmc Finally retired DDSCAPS_3D and moved
 *                      DDSCAPS_EXECUTEBUFFER to ddrawi.h so DDK users can
 *                      see it.
 *   08-dec-96  colinmc Initial AGP support
 *   13-jan-97 jvanaken Basic support for IDirectDrawSurface3 interface
 *   12-jan-97  colinmc More Win16 lock work
 *   29-jan-97  smac    Updated color control structure
 *   29-jan-97  jeffno  Mode13 support. New surface cap and enum/setmode flags
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   08-mar-97  colinmc Support for DMA model AGP cards
 *   11-mar-97  smac    Obsoleted dwMin/MaxLiveVideoStretch and dwMin/MaxHwCodecStretch fields
 *   11-mar-97  jeffno  Don't allow blts between surfaces from different ddraw gbls
 *   22-mar-97  colinmc Bug 6673: Mechanism to let new applications run against
 *                      old runtimes
 *   23-mar-97  colinmc Bug 6673: Changed structure numbering scheme for
 *                      consistency's sake
 *   24-mar-97  jeffno  Optimized Surfaces
 *   16-sep-97  jeffno  DirectDrawEnumerateEx
 *   30-sep-97  jeffno  IDirectDraw4
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *   31-oct-97 johnstep Persistent-content surfaces for Windows 9x
 *   05-nov-97 jvanaken Support for AlphaBlt and SetSpriteDisplayList
 *   07-nov-97  raymondc Borland compatibility
 *   24-nov-97  t-craigs Added IDirectDrawPalette2
 *   19-dec-97 jvanaken IDDS4::Unlock now takes a pointer to a rectangle.
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DDRAW_INCLUDED__
#define __DDRAW_INCLUDED__

//Disable the nameless union warning when building internally
#undef ENABLE_NAMELESS_UNION_PRAGMA
#ifdef DIRECTX_REDIST
#define ENABLE_NAMELESS_UNION_PRAGMA
#endif

#ifdef ENABLE_NAMELESS_UNION_PRAGMA
#pragma warning(disable:4201)
#endif

/*
 * If you wish an application built against the newest version of DirectDraw
 * to run against an older DirectDraw run time then define DIRECTDRAW_VERSION
 * to be the earlies version of DirectDraw you wish to run against. For,
 * example if you wish an application to run against a DX 3 runtime define
 * DIRECTDRAW_VERSION to be 0x0300.
 */
#ifndef   DIRECTDRAW_VERSION
#define   DIRECTDRAW_VERSION 0x0700
#endif /* DIRECTDRAW_VERSION */

#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown            void
#if !defined( NT_BUILD_ENVIRONMENT ) && !defined(WINNT)
        #define CO_E_NOTINITIALIZED 0x800401F0L
#endif
#endif

#define _FACDD  0x876
#define MAKE_DDHRESULT( code )  MAKE_HRESULT( 1, _FACDD, code )

#ifdef __cplusplus
extern "C" {
#endif

//
// For compilers that don't support nameless unions, do a
//
// #define NONAMELESSUNION
//
// before #include <ddraw.h>
//
#ifndef DUMMYUNIONNAMEN
#if defined(__cplusplus) || !defined(NONAMELESSUNION)
#define DUMMYUNIONNAMEN(n)
#else
#define DUMMYUNIONNAMEN(n)      u##n
#endif
#endif

#ifndef MAKEFOURCC
    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((DWORD)(BYTE)(ch0) | ((DWORD)(BYTE)(ch1) << 8) |   \
                ((DWORD)(BYTE)(ch2) << 16) | ((DWORD)(BYTE)(ch3) << 24 ))
#endif //defined(MAKEFOURCC)

/*
 * FOURCC codes for DX compressed-texture pixel formats
 */
#define FOURCC_DXT1  (MAKEFOURCC('D','X','T','1'))
#define FOURCC_DXT2  (MAKEFOURCC('D','X','T','2'))
#define FOURCC_DXT3  (MAKEFOURCC('D','X','T','3'))
#define FOURCC_DXT4  (MAKEFOURCC('D','X','T','4'))
#define FOURCC_DXT5  (MAKEFOURCC('D','X','T','5'))

/*
 * GUIDS used by DirectDraw objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )

DEFINE_GUID( CLSID_DirectDraw,                  0xD7B70EE0,0x4340,0x11CF,0xB0,0x63,0x00,0x20,0xAF,0xC2,0xCD,0x35 );
DEFINE_GUID( CLSID_DirectDraw7,                 0x3c305196,0x50db,0x11d3,0x9c,0xfe,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( CLSID_DirectDrawClipper,           0x593817A0,0x7DB3,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xb9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDraw,                   0x6C14DB80,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDraw2,                  0xB3A6F3E0,0x2B43,0x11CF,0xA2,0xDE,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirectDraw4,                  0x9c59509a,0x39bd,0x11d1,0x8c,0x4a,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( IID_IDirectDraw7,                  0x15e65ec0,0x3b9c,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b );
DEFINE_GUID( IID_IDirectDrawSurface,            0x6C14DB81,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawSurface2,           0x57805885,0x6eec,0x11cf,0x94,0x41,0xa8,0x23,0x03,0xc1,0x0e,0x27 );
DEFINE_GUID( IID_IDirectDrawSurface3,           0xDA044E00,0x69B2,0x11D0,0xA1,0xD5,0x00,0xAA,0x00,0xB8,0xDF,0xBB );
DEFINE_GUID( IID_IDirectDrawSurface4,           0x0B2B8630,0xAD35,0x11D0,0x8E,0xA6,0x00,0x60,0x97,0x97,0xEA,0x5B );
DEFINE_GUID( IID_IDirectDrawSurface7,           0x06675a80,0x3b9b,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b );
//@@BEGIN_MSINTERNAL
DEFINE_GUID( IID_IDirectDrawSurfaceNew,         0x1bab8e96,0x9cfe,0x4ce3,0xbc,0x72,0xd7,0xe9,0xe9,0x9a,0x21,0x75 );
DEFINE_GUID( CLSID_DirectDrawFactory2,          0xb9dc4790,0x4af1,0x11d1,0x8c,0x4c,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( IID_IDirectDrawFactory2,           0x89b2c488,0x4af4,0x11d1,0x8c,0x4c,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( GUID_DirectDrawSurfaceStream,      0xe043bc46,0x5317,0x11d1,0x8c,0x4d,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID( GUID_DirectDrawPaletteStream,      0x730c7ffc,0x5347,0x11d1,0x8c,0x4d,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
DEFINE_GUID(IID_IDirectDrawOptSurface,          0x51191f1e, 0x4f2b, 0x11d1, 0x8c, 0xc3, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0xa8);
DEFINE_GUID( IID_IDirectDrawPalette2,           0xc03c477e,0x6519,0x11d1,0x8c,0x52,0x00,0xc0,0x4f,0xd9,0x30,0xc5 );
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#ifdef STREAMING
DEFINE_GUID( IID_IDirectDrawSurfaceStreaming,   0x6C14DB82,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
#endif
#ifdef COMPOSITION
DEFINE_GUID( IID_IDirectDrawSurfaceComposition, 0x6C14DB83,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
#endif
//@@END_MSINTERNAL
DEFINE_GUID( IID_IDirectDrawPalette,            0x6C14DB84,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawClipper,            0x6C14DB85,0xA733,0x11CE,0xA5,0x21,0x00,0x20,0xAF,0x0B,0xE5,0x60 );
DEFINE_GUID( IID_IDirectDrawColorControl,       0x4B9F0EE0,0x0D7E,0x11D0,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8 );
DEFINE_GUID( IID_IDirectDrawGammaControl,       0x69C11C3E,0xB46B,0x11D1,0xAD,0x7A,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );

#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
struct IDirectDrawSurfaceComposition;
#endif
#ifdef STREAMING
struct IDirectDrawSurfaceStreaming;
#endif
//@@END_MSINTERNAL
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDirectDraw              FAR *LPDIRECTDRAW;
typedef struct IDirectDraw2             FAR *LPDIRECTDRAW2;
typedef struct IDirectDraw4             FAR *LPDIRECTDRAW4;
typedef struct IDirectDraw7             FAR *LPDIRECTDRAW7;
typedef struct IDirectDrawSurface       FAR *LPDIRECTDRAWSURFACE;
typedef struct IDirectDrawSurface2      FAR *LPDIRECTDRAWSURFACE2;
typedef struct IDirectDrawSurface3      FAR *LPDIRECTDRAWSURFACE3;
typedef struct IDirectDrawSurface4      FAR *LPDIRECTDRAWSURFACE4;
typedef struct IDirectDrawSurface7      FAR *LPDIRECTDRAWSURFACE7;
//@@BEGIN_MSINTERNAL
typedef struct IDirectDrawFactory2      FAR *LPDIRECTDRAWFACTORY2;
typedef struct IDirectDrawOptSurface    FAR *LPDIRECTDRAWOPTSURFACE;
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
typedef struct IDirectDrawSurfaceComposition    FAR *LPDIRECTDRAWSURFACECOMPOSITION;
#endif
#ifdef STREAMING
typedef struct IDirectDrawSurfaceStreaming      FAR *LPDIRECTDRAWSURFACESTREAMING;
#endif
typedef struct IDirectDrawPalette2              FAR *LPDIRECTDRAWPALETTE2;
//@@END_MSINTERNAL
typedef struct IDirectDrawPalette               FAR *LPDIRECTDRAWPALETTE;
typedef struct IDirectDrawClipper               FAR *LPDIRECTDRAWCLIPPER;
typedef struct IDirectDrawColorControl          FAR *LPDIRECTDRAWCOLORCONTROL;
typedef struct IDirectDrawGammaControl          FAR *LPDIRECTDRAWGAMMACONTROL;

typedef struct _DDFXROP                 FAR *LPDDFXROP;
typedef struct _DDSURFACEDESC           FAR *LPDDSURFACEDESC;
typedef struct _DDSURFACEDESC2          FAR *LPDDSURFACEDESC2;
//@@BEGIN_MSINTERNAL
typedef struct _DDOPTSURFACEDESC    FAR *LPDDOPTSURFACEDESC;
//@@END_MSINTERNAL
typedef struct _DDCOLORCONTROL          FAR *LPDDCOLORCONTROL;

/*
 * API's
 */
#if (defined (WIN32) || defined( _WIN32 ) ) && !defined( _NO_COM )
//#if defined( _WIN32 ) && !defined( _NO_ENUM )
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKA)(GUID FAR *, LPSTR, LPSTR, LPVOID);
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKW)(GUID FAR *, LPWSTR, LPWSTR, LPVOID);
    extern HRESULT WINAPI DirectDrawEnumerateW( LPDDENUMCALLBACKW lpCallback, LPVOID lpContext );
    extern HRESULT WINAPI DirectDrawEnumerateA( LPDDENUMCALLBACKA lpCallback, LPVOID lpContext );
    /*
     * Protect against old SDKs
     */
    #if !defined(HMONITOR_DECLARED) && (WINVER < 0x0500)
        #define HMONITOR_DECLARED
        DECLARE_HANDLE(HMONITOR);
    #endif
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKEXA)(GUID FAR *, LPSTR, LPSTR, LPVOID, HMONITOR);
    typedef BOOL (FAR PASCAL * LPDDENUMCALLBACKEXW)(GUID FAR *, LPWSTR, LPWSTR, LPVOID, HMONITOR);
    extern HRESULT WINAPI DirectDrawEnumerateExW( LPDDENUMCALLBACKEXW lpCallback, LPVOID lpContext, DWORD dwFlags);
    extern HRESULT WINAPI DirectDrawEnumerateExA( LPDDENUMCALLBACKEXA lpCallback, LPVOID lpContext, DWORD dwFlags);
    typedef HRESULT (WINAPI * LPDIRECTDRAWENUMERATEEXA)( LPDDENUMCALLBACKEXA lpCallback, LPVOID lpContext, DWORD dwFlags);
    typedef HRESULT (WINAPI * LPDIRECTDRAWENUMERATEEXW)( LPDDENUMCALLBACKEXW lpCallback, LPVOID lpContext, DWORD dwFlags);

    #ifdef UNICODE
        typedef LPDDENUMCALLBACKW           LPDDENUMCALLBACK;
        #define DirectDrawEnumerate         DirectDrawEnumerateW
        typedef LPDDENUMCALLBACKEXW         LPDDENUMCALLBACKEX;
        typedef LPDIRECTDRAWENUMERATEEXW        LPDIRECTDRAWENUMERATEEX;
        #define DirectDrawEnumerateEx       DirectDrawEnumerateExW
    #else
        typedef LPDDENUMCALLBACKA           LPDDENUMCALLBACK;
        #define DirectDrawEnumerate         DirectDrawEnumerateA
        typedef LPDDENUMCALLBACKEXA         LPDDENUMCALLBACKEX;
        typedef LPDIRECTDRAWENUMERATEEXA        LPDIRECTDRAWENUMERATEEX;
        #define DirectDrawEnumerateEx       DirectDrawEnumerateExA
    #endif
    extern HRESULT WINAPI DirectDrawCreate( GUID FAR *lpGUID, LPDIRECTDRAW FAR *lplpDD, IUnknown FAR *pUnkOuter );
    extern HRESULT WINAPI DirectDrawCreateEx( GUID FAR * lpGuid, LPVOID  *lplpDD, REFIID  iid,IUnknown FAR *pUnkOuter );
    extern HRESULT WINAPI DirectDrawCreateClipper( DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter );
#endif
/*
 * Flags for DirectDrawEnumerateEx
 * DirectDrawEnumerateEx supercedes DirectDrawEnumerate. You must use GetProcAddress to
 * obtain a function pointer (of type LPDIRECTDRAWENUMERATEEX) to DirectDrawEnumerateEx.
 * By default, only the primary display device is enumerated.
 * DirectDrawEnumerate is equivalent to DirectDrawEnumerate(,,DDENUM_NONDISPLAYDEVICES)
 */

/*
 * This flag causes enumeration of any GDI display devices which are part of
 * the Windows Desktop
 */
#define DDENUM_ATTACHEDSECONDARYDEVICES     0x00000001L

/*
 * This flag causes enumeration of any GDI display devices which are not
 * part of the Windows Desktop
 */
#define DDENUM_DETACHEDSECONDARYDEVICES     0x00000002L

/*
 * This flag causes enumeration of non-display devices
 */
#define DDENUM_NONDISPLAYDEVICES            0x00000004L

//@@BEGIN_MSINTERNAL
#define DDENUM_VALID                         0x00000007L
//@@END_MSINTERNAL

#define REGSTR_KEY_DDHW_DESCRIPTION     "Description"
#define REGSTR_KEY_DDHW_DRIVERNAME      "DriverName"
#define REGSTR_PATH_DDHW                "Hardware\\DirectDrawDrivers"

#define DDCREATE_HARDWAREONLY           0x00000001l
#define DDCREATE_EMULATIONONLY          0x00000002l

#if defined(WINNT) || !defined(WIN32)
typedef long HRESULT;
#endif

//#ifndef WINNT
typedef HRESULT (FAR PASCAL * LPDDENUMMODESCALLBACK)(LPDDSURFACEDESC, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMMODESCALLBACK2)(LPDDSURFACEDESC2, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK)(LPDIRECTDRAWSURFACE, LPDDSURFACEDESC, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK2)(LPDIRECTDRAWSURFACE4, LPDDSURFACEDESC2, LPVOID);
typedef HRESULT (FAR PASCAL * LPDDENUMSURFACESCALLBACK7)(LPDIRECTDRAWSURFACE7, LPDDSURFACEDESC2, LPVOID);
//#endif

/*
 * Generic pixel format with 8-bit RGB and alpha components
 */
typedef struct _DDARGB
{
    BYTE blue;
    BYTE green;
    BYTE red;
    BYTE alpha;
} DDARGB;

typedef DDARGB FAR *LPDDARGB;

/*
 * This version of the structure remains for backwards source compatibility.
 * The DDARGB structure is the one that should be used for all DirectDraw APIs.
 */
typedef struct _DDRGBA
{
    BYTE red;
    BYTE green;
    BYTE blue;
    BYTE alpha;
} DDRGBA;

typedef DDRGBA FAR *LPDDRGBA;


/*
 * DDCOLORKEY
 */
typedef struct _DDCOLORKEY
{
    DWORD       dwColorSpaceLowValue;   // low boundary of color space that is to
                                        // be treated as Color Key, inclusive
    DWORD       dwColorSpaceHighValue;  // high boundary of color space that is
                                        // to be treated as Color Key, inclusive
} DDCOLORKEY;

typedef DDCOLORKEY FAR* LPDDCOLORKEY;

/*
 * DDBLTFX
 * Used to pass override information to the DIRECTDRAWSURFACE callback Blt.
 */
typedef struct _DDBLTFX
{
    DWORD       dwSize;                         // size of structure
    DWORD       dwDDFX;                         // FX operations
    DWORD       dwROP;                          // Win32 raster operations
    DWORD       dwDDROP;                        // Raster operations new for DirectDraw
    DWORD       dwRotationAngle;                // Rotation angle for blt
    DWORD       dwZBufferOpCode;                // ZBuffer compares
    DWORD       dwZBufferLow;                   // Low limit of Z buffer
    DWORD       dwZBufferHigh;                  // High limit of Z buffer
    DWORD       dwZBufferBaseDest;              // Destination base value
    DWORD       dwZDestConstBitDepth;           // Bit depth used to specify Z constant for destination
    union
    {
        DWORD   dwZDestConst;                   // Constant to use as Z buffer for dest
        LPDIRECTDRAWSURFACE lpDDSZBufferDest;   // Surface to use as Z buffer for dest
    } DUMMYUNIONNAMEN(1);
    DWORD       dwZSrcConstBitDepth;            // Bit depth used to specify Z constant for source
    union
    {
        DWORD   dwZSrcConst;                    // Constant to use as Z buffer for src
        LPDIRECTDRAWSURFACE lpDDSZBufferSrc;    // Surface to use as Z buffer for src
    } DUMMYUNIONNAMEN(2);
    DWORD       dwAlphaEdgeBlendBitDepth;       // Bit depth used to specify constant for alpha edge blend
    DWORD       dwAlphaEdgeBlend;               // Alpha for edge blending
    DWORD       dwReserved;
    DWORD       dwAlphaDestConstBitDepth;       // Bit depth used to specify alpha constant for destination
    union
    {
        DWORD   dwAlphaDestConst;               // Constant to use as Alpha Channel
        LPDIRECTDRAWSURFACE lpDDSAlphaDest;     // Surface to use as Alpha Channel
    } DUMMYUNIONNAMEN(3);
    DWORD       dwAlphaSrcConstBitDepth;        // Bit depth used to specify alpha constant for source
    union
    {
        DWORD   dwAlphaSrcConst;                // Constant to use as Alpha Channel
        LPDIRECTDRAWSURFACE lpDDSAlphaSrc;      // Surface to use as Alpha Channel
    } DUMMYUNIONNAMEN(4);
    union
    {
        DWORD   dwFillColor;                    // color in RGB or Palettized
        DWORD   dwFillDepth;                    // depth value for z-buffer
        DWORD   dwFillPixel;                    // pixel value for RGBA or RGBZ
        LPDIRECTDRAWSURFACE lpDDSPattern;       // Surface to use as pattern
    } DUMMYUNIONNAMEN(5);
    DDCOLORKEY  ddckDestColorkey;               // DestColorkey override
    DDCOLORKEY  ddckSrcColorkey;                // SrcColorkey override
} DDBLTFX;

typedef DDBLTFX FAR* LPDDBLTFX;


//@@BEGIN_MSINTERNAL
/*
 * Structure used for lpDDAlphaBltFX arg to AlphaBlt API call
 */
typedef union _DDALPHABLTFX
{
    DDARGB ddargbScaleFactors;
    DWORD dwFillValue;

} DDALPHABLTFX;

typedef DDALPHABLTFX FAR* LPDDALPHABLTFX;


#ifdef COMPOSITION
/*
 * DDCOMPOSEFX
 * Used to pass override information to the DIRECTDRAWSURFACE callback Compose.
 */
typedef DWORD   (FAR PASCAL *LPCOMPOSECALLBACK)(DWORD);
typedef struct _DDCOMPOSEFX
{
    DWORD       dwSize;                         // size of structure
    DWORD       dwDDFX;                         // FX operations
    DWORD       dwROP;                          // Win32 raster operations
    DWORD       dwDDROP;                        // Raster operations new for DirectDraw
    DWORD       dwRotationAngle;                // Rotation angle for blt
    DWORD       dwZBufferOpCode;                // ZBuffer compares
    DWORD       dwZBufferLow;                   // Low limit of Z buffer
    DWORD       dwZBufferHigh;                  // High limit of Z buffer
    DWORD       dwZBufferBaseDest;              // Destination base value
    DWORD       dwZDestConstBitDepth;           // Bit depth used to specify Z constant for destination
    union
    {
        DWORD   dwZDestConst;                   // Constant to use as Z buffer for dest
        LPDIRECTDRAWSURFACE lpDDSZBufferDest;   // Surface to use as Z buffer for dest
    } DUMMYUNIONNAMEN(1);
    DWORD       dwZSrcConstBitDepth;            // Bit depth used to specify Z constant for source
    union
    {
        DWORD   dwZSrcConst;                    // Constant to use as Z buffer for src
        LPDIRECTDRAWSURFACE lpDDSZBufferSrc;    // Surface to use as Z buffer for src
    } DUMMYUNIONNAMEN(2);
    DWORD       dwAlphaEdgeBlendBitDepth;       // Bit depth used to specify constant for alpha edge blend
    DWORD       dwAlphaEdgeBlend;               // Alpha for edge blending
    DWORD       dwReserved;
    DWORD       dwAlphaDestConstBitDepth;       // Bit depth used to specify alpha constant for destination
    union
    {
        DWORD   dwAlphaDestConst;               // Constant to use as Alpha Channel
        LPDIRECTDRAWSURFACE lpDDSAlphaDest;     // Surface to use as Alpha Channel
    } DUMMYUNIONNAMEN(3);
    DWORD       dwAlphaSrcConstBitDepth;        // Bit depth used to specify alpha constant for source
    union
    {
        DWORD   dwAlphaSrcConst;                // Constant to use as Alpha Channel
        LPDIRECTDRAWSURFACE lpDDSAlphaSrc;      // Surface to use as Alpha Channel
    } DUMMYUNIONNAMEN(4);
    union
    {
        DWORD   dwFillColor;                    // color in RGB or Palettized
        LPDIRECTDRAWSURFACE lpDDSPattern;       // Surface to use as pattern
    } DUMMYUNIONNAMEN(5);
    DDCOLORKEY  ddckDestColorkey;               // DestColorkey override
    DDCOLORKEY  ddckSrcColorkey;                // SrcColorkey override
    DWORD       dwRepeat;                       // how many times to repeat the composition command
    LPCOMPOSECALLBACK   lpfnCallback;           // function to call prior to execution of each compose command
} DDCOMPOSEFX;

typedef DDCOMPOSEFX FAR* LPDDCOMPOSEFX;
#endif
//@@END_MSINTERNAL

/*
 * DDSCAPS
 */
typedef struct _DDSCAPS
{
    DWORD       dwCaps;         // capabilities of surface wanted
} DDSCAPS;

typedef DDSCAPS FAR* LPDDSCAPS;


/*
 * DDOSCAPS
 */
typedef struct _DDOSCAPS
{
    DWORD       dwCaps;         // capabilities of surface wanted
} DDOSCAPS;

typedef DDOSCAPS FAR* LPDDOSCAPS;

/*
 * This structure is used internally by DirectDraw.
//@@BEGIN_MSINTERNAL
 * Don't MSINTERNAL it: it's needed by ddrawi.h and drivers.
//@@END_MSINTERNAL
 */
typedef struct _DDSCAPSEX
{
    DWORD       dwCaps2;
    DWORD       dwCaps3;
    union
    {
        DWORD       dwCaps4;
        DWORD       dwVolumeDepth;
    } DUMMYUNIONNAMEN(1);
} DDSCAPSEX, FAR * LPDDSCAPSEX;

/*
 * DDSCAPS2
 */
typedef struct _DDSCAPS2
{
    DWORD       dwCaps;         // capabilities of surface wanted
//@@BEGIN_MSINTERNAL
union
{
    struct
    {
//@@END_MSINTERNAL
    DWORD       dwCaps2;
    DWORD       dwCaps3;
    union
    {
        DWORD       dwCaps4;
        DWORD       dwVolumeDepth;
    } DUMMYUNIONNAMEN(1);
//@@BEGIN_MSINTERNAL
    };
    DDSCAPSEX   ddsCapsEx;
};
//@@END_MSINTERNAL
} DDSCAPS2;

typedef DDSCAPS2 FAR* LPDDSCAPS2;

/*
 * DDCAPS
 */
#define DD_ROP_SPACE            (256/32)        // space required to store ROP array
/*
 * NOTE: Our choosen structure number scheme is to append a single digit to
 * the end of the structure giving the version that structure is associated
 * with.
 */

/*
 * This structure represents the DDCAPS structure released in DirectDraw 1.0.  It is used internally
 * by DirectDraw to interpret caps passed into ddraw by drivers written prior to the release of DirectDraw 2.0.
 * New applications should use the DDCAPS structure defined below.
 */
typedef struct _DDCAPS_DX1
{
    DWORD       dwSize;                 // size of the DDDRIVERCAPS structure
    DWORD       dwCaps;                 // driver specific capabilities
    DWORD       dwCaps2;                // more driver specific capabilites
    DWORD       dwCKeyCaps;             // color key capabilities of the surface
    DWORD       dwFXCaps;               // driver specific stretching and effects capabilites
    DWORD       dwFXAlphaCaps;          // alpha driver specific capabilities
    DWORD       dwPalCaps;              // palette capabilities
    DWORD       dwSVCaps;               // stereo vision capabilities
    DWORD       dwAlphaBltConstBitDepths;       // DDBD_2,4,8
    DWORD       dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
    DWORD       dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
    DWORD       dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
    DWORD       dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
    DWORD       dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD       dwZBufferBitDepths;             // DDBD_8,16,24,32
    DWORD       dwVidMemTotal;          // total amount of video memory
    DWORD       dwVidMemFree;           // amount of free video memory
    DWORD       dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD       dwCurrVisibleOverlays;  // current number of visible overlays
    DWORD       dwNumFourCCCodes;       // number of four cc codes
    DWORD       dwAlignBoundarySrc;     // source rectangle alignment
    DWORD       dwAlignSizeSrc;         // source rectangle byte size
    DWORD       dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD       dwAlignSizeDest;        // dest rectangle byte size
    DWORD       dwAlignStrideAlign;     // stride alignment
    DWORD       dwRops[DD_ROP_SPACE];   // ROPS supported
    DDSCAPS     ddsCaps;                // DDSCAPS structure has all the general capabilities
    DWORD       dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinLiveVideoStretch;  // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwMaxLiveVideoStretch;  // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwMinHwCodecStretch;    // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwMaxHwCodecStretch;    // OBSOLETE! This field remains for compatability reasons only
    DWORD       dwReserved1;            // reserved
    DWORD       dwReserved2;            // reserved
    DWORD       dwReserved3;            // reserved
} DDCAPS_DX1;

typedef DDCAPS_DX1 FAR* LPDDCAPS_DX1;

/*
 * This structure is the DDCAPS structure as it was in version 2 and 3 of Direct X.
 * It is present for back compatability.
 */
typedef struct _DDCAPS_DX3
{
    DWORD       dwSize;                 // size of the DDDRIVERCAPS structure
    DWORD       dwCaps;                 // driver specific capabilities
    DWORD       dwCaps2;                // more driver specific capabilites
    DWORD       dwCKeyCaps;             // color key capabilities of the surface
    DWORD       dwFXCaps;               // driver specific stretching and effects capabilites
    DWORD       dwFXAlphaCaps;          // alpha driver specific capabilities
    DWORD       dwPalCaps;              // palette capabilities
    DWORD       dwSVCaps;               // stereo vision capabilities
    DWORD       dwAlphaBltConstBitDepths;       // DDBD_2,4,8
    DWORD       dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
    DWORD       dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
    DWORD       dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
    DWORD       dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
    DWORD       dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD       dwZBufferBitDepths;             // DDBD_8,16,24,32
    DWORD       dwVidMemTotal;          // total amount of video memory
    DWORD       dwVidMemFree;           // amount of free video memory
    DWORD       dwMaxVisibleOverlays;   // maximum number of visible overlays
    DWORD       dwCurrVisibleOverlays;  // current number of visible overlays
    DWORD       dwNumFourCCCodes;       // number of four cc codes
    DWORD       dwAlignBoundarySrc;     // source rectangle alignment
    DWORD       dwAlignSizeSrc;         // source rectangle byte size
    DWORD       dwAlignBoundaryDest;    // dest rectangle alignment
    DWORD       dwAlignSizeDest;        // dest rectangle byte size
    DWORD       dwAlignStrideAlign;     // stride alignment
    DWORD       dwRops[DD_ROP_SPACE];   // ROPS supported
    DDSCAPS     ddsCaps;                // DDSCAPS structure has all the general capabilities
    DWORD       dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD       dwReserved1;            // reserved
    DWORD       dwReserved2;            // reserved
    DWORD       dwReserved3;            // reserved
    DWORD       dwSVBCaps;              // driver specific capabilities for System->Vmem blts
    DWORD       dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
    DWORD       dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
    DWORD       dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
    DWORD       dwVSBCaps;              // driver specific capabilities for Vmem->System blts
    DWORD       dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
    DWORD       dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
    DWORD       dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
    DWORD       dwSSBCaps;              // driver specific capabilities for System->System blts
    DWORD       dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
    DWORD       dwSSBFXCaps;            // driver FX capabilities for System->System blts
    DWORD       dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
    DWORD       dwReserved4;            // reserved
    DWORD       dwReserved5;            // reserved
    DWORD       dwReserved6;            // reserved
} DDCAPS_DX3;
typedef DDCAPS_DX3 FAR* LPDDCAPS_DX3;

/*
 * This structure is the DDCAPS structure as it was in version 5 of Direct X.
 * It is present for back compatability.
 */
typedef struct _DDCAPS_DX5
{
/*  0*/ DWORD   dwSize;                 // size of the DDDRIVERCAPS structure
/*  4*/ DWORD   dwCaps;                 // driver specific capabilities
/*  8*/ DWORD   dwCaps2;                // more driver specific capabilites
/*  c*/ DWORD   dwCKeyCaps;             // color key capabilities of the surface
/* 10*/ DWORD   dwFXCaps;               // driver specific stretching and effects capabilites
/* 14*/ DWORD   dwFXAlphaCaps;          // alpha driver specific capabilities
/* 18*/ DWORD   dwPalCaps;              // palette capabilities
/* 1c*/ DWORD   dwSVCaps;               // stereo vision capabilities
/* 20*/ DWORD   dwAlphaBltConstBitDepths;       // DDBD_2,4,8
/* 24*/ DWORD   dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
/* 28*/ DWORD   dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
/* 2c*/ DWORD   dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
/* 30*/ DWORD   dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
/* 34*/ DWORD   dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
/* 38*/ DWORD   dwZBufferBitDepths;             // DDBD_8,16,24,32
/* 3c*/ DWORD   dwVidMemTotal;          // total amount of video memory
/* 40*/ DWORD   dwVidMemFree;           // amount of free video memory
/* 44*/ DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
/* 48*/ DWORD   dwCurrVisibleOverlays;  // current number of visible overlays
/* 4c*/ DWORD   dwNumFourCCCodes;       // number of four cc codes
/* 50*/ DWORD   dwAlignBoundarySrc;     // source rectangle alignment
/* 54*/ DWORD   dwAlignSizeSrc;         // source rectangle byte size
/* 58*/ DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
/* 5c*/ DWORD   dwAlignSizeDest;        // dest rectangle byte size
/* 60*/ DWORD   dwAlignStrideAlign;     // stride alignment
/* 64*/ DWORD   dwRops[DD_ROP_SPACE];   // ROPS supported
/* 84*/ DDSCAPS ddsCaps;                // DDSCAPS structure has all the general capabilities
/* 88*/ DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 8c*/ DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 90*/ DWORD   dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 94*/ DWORD   dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 98*/ DWORD   dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 9c*/ DWORD   dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* a0*/ DWORD   dwReserved1;            // reserved
/* a4*/ DWORD   dwReserved2;            // reserved
/* a8*/ DWORD   dwReserved3;            // reserved
/* ac*/ DWORD   dwSVBCaps;              // driver specific capabilities for System->Vmem blts
/* b0*/ DWORD   dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
/* b4*/ DWORD   dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
/* b8*/ DWORD   dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
/* d8*/ DWORD   dwVSBCaps;              // driver specific capabilities for Vmem->System blts
/* dc*/ DWORD   dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
/* e0*/ DWORD   dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
/* e4*/ DWORD   dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
/*104*/ DWORD   dwSSBCaps;              // driver specific capabilities for System->System blts
/*108*/ DWORD   dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
/*10c*/ DWORD   dwSSBFXCaps;            // driver FX capabilities for System->System blts
/*110*/ DWORD   dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
// Members added for DX5:
/*130*/ DWORD   dwMaxVideoPorts;        // maximum number of usable video ports
/*134*/ DWORD   dwCurrVideoPorts;       // current number of video ports used
/*138*/ DWORD   dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
/*13c*/ DWORD   dwNLVBCaps;               // driver specific capabilities for non-local->local vidmem blts
/*140*/ DWORD   dwNLVBCaps2;              // more driver specific capabilities non-local->local vidmem blts
/*144*/ DWORD   dwNLVBCKeyCaps;           // driver color key capabilities for non-local->local vidmem blts
/*148*/ DWORD   dwNLVBFXCaps;             // driver FX capabilities for non-local->local blts
/*14c*/ DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
} DDCAPS_DX5;
typedef DDCAPS_DX5 FAR* LPDDCAPS_DX5;

typedef struct _DDCAPS_DX6
{
/*  0*/ DWORD   dwSize;                 // size of the DDDRIVERCAPS structure
/*  4*/ DWORD   dwCaps;                 // driver specific capabilities
/*  8*/ DWORD   dwCaps2;                // more driver specific capabilites
/*  c*/ DWORD   dwCKeyCaps;             // color key capabilities of the surface
/* 10*/ DWORD   dwFXCaps;               // driver specific stretching and effects capabilites
/* 14*/ DWORD   dwFXAlphaCaps;          // alpha caps
/* 18*/ DWORD   dwPalCaps;              // palette capabilities
/* 1c*/ DWORD   dwSVCaps;               // stereo vision capabilities
/* 20*/ DWORD   dwAlphaBltConstBitDepths;       // DDBD_2,4,8
/* 24*/ DWORD   dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
/* 28*/ DWORD   dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
/* 2c*/ DWORD   dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
/* 30*/ DWORD   dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
/* 34*/ DWORD   dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
/* 38*/ DWORD   dwZBufferBitDepths;             // DDBD_8,16,24,32
/* 3c*/ DWORD   dwVidMemTotal;          // total amount of video memory
/* 40*/ DWORD   dwVidMemFree;           // amount of free video memory
/* 44*/ DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
/* 48*/ DWORD   dwCurrVisibleOverlays;  // current number of visible overlays
/* 4c*/ DWORD   dwNumFourCCCodes;       // number of four cc codes
/* 50*/ DWORD   dwAlignBoundarySrc;     // source rectangle alignment
/* 54*/ DWORD   dwAlignSizeSrc;         // source rectangle byte size
/* 58*/ DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
/* 5c*/ DWORD   dwAlignSizeDest;        // dest rectangle byte size
/* 60*/ DWORD   dwAlignStrideAlign;     // stride alignment
/* 64*/ DWORD   dwRops[DD_ROP_SPACE];   // ROPS supported
/* 84*/ DDSCAPS ddsOldCaps;             // Was DDSCAPS  ddsCaps. ddsCaps is of type DDSCAPS2 for DX6
/* 88*/ DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 8c*/ DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 90*/ DWORD   dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 94*/ DWORD   dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 98*/ DWORD   dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 9c*/ DWORD   dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* a0*/ DWORD   dwReserved1;            // reserved
/* a4*/ DWORD   dwReserved2;            // reserved
/* a8*/ DWORD   dwReserved3;            // reserved
/* ac*/ DWORD   dwSVBCaps;              // driver specific capabilities for System->Vmem blts
/* b0*/ DWORD   dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
/* b4*/ DWORD   dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
/* b8*/ DWORD   dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
/* d8*/ DWORD   dwVSBCaps;              // driver specific capabilities for Vmem->System blts
/* dc*/ DWORD   dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
/* e0*/ DWORD   dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
/* e4*/ DWORD   dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
/*104*/ DWORD   dwSSBCaps;              // driver specific capabilities for System->System blts
/*108*/ DWORD   dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
/*10c*/ DWORD   dwSSBFXCaps;            // driver FX capabilities for System->System blts
/*110*/ DWORD   dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
/*130*/ DWORD   dwMaxVideoPorts;        // maximum number of usable video ports
/*134*/ DWORD   dwCurrVideoPorts;       // current number of video ports used
/*138*/ DWORD   dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
/*13c*/ DWORD   dwNLVBCaps;               // driver specific capabilities for non-local->local vidmem blts
/*140*/ DWORD   dwNLVBCaps2;              // more driver specific capabilities non-local->local vidmem blts
/*144*/ DWORD   dwNLVBCKeyCaps;           // driver color key capabilities for non-local->local vidmem blts
/*148*/ DWORD   dwNLVBFXCaps;             // driver FX capabilities for non-local->local blts
/*14c*/ DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
// Members added for DX6 release
/*16c*/ DDSCAPS2 ddsCaps;               // Surface Caps
} DDCAPS_DX6;
typedef DDCAPS_DX6 FAR* LPDDCAPS_DX6;

typedef struct _DDCAPS_DX7
{
/*  0*/ DWORD   dwSize;                 // size of the DDDRIVERCAPS structure
/*  4*/ DWORD   dwCaps;                 // driver specific capabilities
/*  8*/ DWORD   dwCaps2;                // more driver specific capabilites
/*  c*/ DWORD   dwCKeyCaps;             // color key capabilities of the surface
/* 10*/ DWORD   dwFXCaps;               // driver specific stretching and effects capabilites
/* 14*/ DWORD   dwFXAlphaCaps;          // alpha driver specific capabilities
/* 18*/ DWORD   dwPalCaps;              // palette capabilities
/* 1c*/ DWORD   dwSVCaps;               // stereo vision capabilities
/* 20*/ DWORD   dwAlphaBltConstBitDepths;       // DDBD_2,4,8
/* 24*/ DWORD   dwAlphaBltPixelBitDepths;       // DDBD_1,2,4,8
/* 28*/ DWORD   dwAlphaBltSurfaceBitDepths;     // DDBD_1,2,4,8
/* 2c*/ DWORD   dwAlphaOverlayConstBitDepths;   // DDBD_2,4,8
/* 30*/ DWORD   dwAlphaOverlayPixelBitDepths;   // DDBD_1,2,4,8
/* 34*/ DWORD   dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
/* 38*/ DWORD   dwZBufferBitDepths;             // DDBD_8,16,24,32
/* 3c*/ DWORD   dwVidMemTotal;          // total amount of video memory
/* 40*/ DWORD   dwVidMemFree;           // amount of free video memory
/* 44*/ DWORD   dwMaxVisibleOverlays;   // maximum number of visible overlays
/* 48*/ DWORD   dwCurrVisibleOverlays;  // current number of visible overlays
/* 4c*/ DWORD   dwNumFourCCCodes;       // number of four cc codes
/* 50*/ DWORD   dwAlignBoundarySrc;     // source rectangle alignment
/* 54*/ DWORD   dwAlignSizeSrc;         // source rectangle byte size
/* 58*/ DWORD   dwAlignBoundaryDest;    // dest rectangle alignment
/* 5c*/ DWORD   dwAlignSizeDest;        // dest rectangle byte size
/* 60*/ DWORD   dwAlignStrideAlign;     // stride alignment
/* 64*/ DWORD   dwRops[DD_ROP_SPACE];   // ROPS supported
/* 84*/ DDSCAPS ddsOldCaps;             // Was DDSCAPS  ddsCaps. ddsCaps is of type DDSCAPS2 for DX6
/* 88*/ DWORD   dwMinOverlayStretch;    // minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 8c*/ DWORD   dwMaxOverlayStretch;    // maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 90*/ DWORD   dwMinLiveVideoStretch;  // minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 94*/ DWORD   dwMaxLiveVideoStretch;  // maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 98*/ DWORD   dwMinHwCodecStretch;    // minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* 9c*/ DWORD   dwMaxHwCodecStretch;    // maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
/* a0*/ DWORD   dwReserved1;            // reserved
/* a4*/ DWORD   dwReserved2;            // reserved
/* a8*/ DWORD   dwReserved3;            // reserved
/* ac*/ DWORD   dwSVBCaps;              // driver specific capabilities for System->Vmem blts
/* b0*/ DWORD   dwSVBCKeyCaps;          // driver color key capabilities for System->Vmem blts
/* b4*/ DWORD   dwSVBFXCaps;            // driver FX capabilities for System->Vmem blts
/* b8*/ DWORD   dwSVBRops[DD_ROP_SPACE];// ROPS supported for System->Vmem blts
/* d8*/ DWORD   dwVSBCaps;              // driver specific capabilities for Vmem->System blts
/* dc*/ DWORD   dwVSBCKeyCaps;          // driver color key capabilities for Vmem->System blts
/* e0*/ DWORD   dwVSBFXCaps;            // driver FX capabilities for Vmem->System blts
/* e4*/ DWORD   dwVSBRops[DD_ROP_SPACE];// ROPS supported for Vmem->System blts
/*104*/ DWORD   dwSSBCaps;              // driver specific capabilities for System->System blts
/*108*/ DWORD   dwSSBCKeyCaps;          // driver color key capabilities for System->System blts
/*10c*/ DWORD   dwSSBFXCaps;            // driver FX capabilities for System->System blts
/*110*/ DWORD   dwSSBRops[DD_ROP_SPACE];// ROPS supported for System->System blts
/*130*/ DWORD   dwMaxVideoPorts;        // maximum number of usable video ports
/*134*/ DWORD   dwCurrVideoPorts;       // current number of video ports used
/*138*/ DWORD   dwSVBCaps2;             // more driver specific capabilities for System->Vmem blts
/*13c*/ DWORD   dwNLVBCaps;               // driver specific capabilities for non-local->local vidmem blts
/*140*/ DWORD   dwNLVBCaps2;              // more driver specific capabilities non-local->local vidmem blts
/*144*/ DWORD   dwNLVBCKeyCaps;           // driver color key capabilities for non-local->local vidmem blts
/*148*/ DWORD   dwNLVBFXCaps;             // driver FX capabilities for non-local->local blts
/*14c*/ DWORD   dwNLVBRops[DD_ROP_SPACE]; // ROPS supported for non-local->local blts
// Members added for DX6 release
/*16c*/ DDSCAPS2 ddsCaps;               // Surface Caps
//@@BEGIN_MSINTERNAL
#ifdef POSTPONED2
/*170*/ DWORD   dwAlphaCaps;            // driver-specific alpha caps for overlays & Vmem->Vmem blts
/*174*/ DWORD   dwSVBAlphaCaps;         // driver-specific alpha capabilities for System->Vmem blts
/*178*/ DWORD   dwVSBAlphaCaps;         // driver-specific alpha capabilities for Vmem->System blts
/*17c*/ DWORD   dwSSBAlphaCaps;         // driver-specific alpha capabilities for System->System blts
/*180*/ DWORD   dwFilterCaps;           // driver-specific filter caps for overlays and Vmem->Vmem blts
/*184*/ DWORD   dwSVBFilterCaps;        // driver-specific filter capabilities for System->Vmem blts
/*188*/ DWORD   dwVSBFilterCaps;        // driver-specific filter capabilities for Vmem->System blts
/*18c*/ DWORD   dwSSBFilterCaps;        // driver-specific filter capabilities for System->System blts
/*190*/ DWORD   dwTransformCaps;        // driver-specific transform caps for overlays & Vmem->Vmem blts
/*194*/ DWORD   dwSVBTransformCaps;     // driver-specific transform capabilities for System->Vmem blts
/*198*/ DWORD   dwVSBTransformCaps;     // driver-specific transform capabilities for Vmem->System blts
/*19c*/ DWORD   dwSSBTransformCaps;     // driver-specific transform capabilities for System->System blts
/*1a0*/ DWORD   dwBltAffineMinifyLimit;   // minification limit for affine-transformed blts
/*1a4*/ DWORD   dwOverlayAffineMinifyLimit; // minification limit for affine-transformed overlays
#endif //POSTPONED2
//@@END_MSINTERNAL
} DDCAPS_DX7;
typedef DDCAPS_DX7 FAR* LPDDCAPS_DX7;


#if DIRECTDRAW_VERSION <= 0x300
    typedef DDCAPS_DX3 DDCAPS;
#elif DIRECTDRAW_VERSION <= 0x500
    typedef DDCAPS_DX5 DDCAPS;
#elif DIRECTDRAW_VERSION <= 0x600
    typedef DDCAPS_DX6 DDCAPS;
#else
    typedef DDCAPS_DX7 DDCAPS;
#endif

typedef DDCAPS FAR* LPDDCAPS;



/*
 * DDPIXELFORMAT
 */
typedef struct _DDPIXELFORMAT
{
    DWORD       dwSize;                 // size of structure
    DWORD       dwFlags;                // pixel format flags
    DWORD       dwFourCC;               // (FOURCC code)
    union
    {
        DWORD   dwRGBBitCount;          // how many bits per pixel
        DWORD   dwYUVBitCount;          // how many bits per pixel
        DWORD   dwZBufferBitDepth;      // how many total bits/pixel in z buffer (including any stencil bits)
        DWORD   dwAlphaBitDepth;        // how many bits for alpha channels
        DWORD   dwLuminanceBitCount;    // how many bits per pixel
        DWORD   dwBumpBitCount;         // how many bits per "buxel", total
        DWORD   dwPrivateFormatBitCount;// Bits per pixel of private driver formats. Only valid in texture
                                        // format list and if DDPF_D3DFORMAT is set
    } DUMMYUNIONNAMEN(1);
    union
    {
        DWORD   dwRBitMask;             // mask for red bit
        DWORD   dwYBitMask;             // mask for Y bits
        DWORD   dwStencilBitDepth;      // how many stencil bits (note: dwZBufferBitDepth-dwStencilBitDepth is total Z-only bits)
        DWORD   dwLuminanceBitMask;     // mask for luminance bits
        DWORD   dwBumpDuBitMask;        // mask for bump map U delta bits
        DWORD   dwOperations;           // DDPF_D3DFORMAT Operations
    } DUMMYUNIONNAMEN(2);
    union
    {
        DWORD   dwGBitMask;             // mask for green bits
        DWORD   dwUBitMask;             // mask for U bits
        DWORD   dwZBitMask;             // mask for Z bits
        DWORD   dwBumpDvBitMask;        // mask for bump map V delta bits
        struct
        {
            WORD    wFlipMSTypes;       // Multisample methods supported via flip for this D3DFORMAT
            WORD    wBltMSTypes;        // Multisample methods supported via blt for this D3DFORMAT
        } MultiSampleCaps;

    } DUMMYUNIONNAMEN(3);
    union
    {
        DWORD   dwBBitMask;             // mask for blue bits
        DWORD   dwVBitMask;             // mask for V bits
        DWORD   dwStencilBitMask;       // mask for stencil bits
        DWORD   dwBumpLuminanceBitMask; // mask for luminance in bump map
    } DUMMYUNIONNAMEN(4);
    union
    {
        DWORD   dwRGBAlphaBitMask;      // mask for alpha channel
        DWORD   dwYUVAlphaBitMask;      // mask for alpha channel
        DWORD   dwLuminanceAlphaBitMask;// mask for alpha channel
        DWORD   dwRGBZBitMask;          // mask for Z channel
        DWORD   dwYUVZBitMask;          // mask for Z channel
    } DUMMYUNIONNAMEN(5);
} DDPIXELFORMAT;

typedef DDPIXELFORMAT FAR* LPDDPIXELFORMAT;

/*
 * DDOVERLAYFX
 */
typedef struct _DDOVERLAYFX
{
    DWORD       dwSize;                         // size of structure
    DWORD       dwAlphaEdgeBlendBitDepth;       // Bit depth used to specify constant for alpha edge blend
    DWORD       dwAlphaEdgeBlend;               // Constant to use as alpha for edge blend
    DWORD       dwReserved;
    DWORD       dwAlphaDestConstBitDepth;       // Bit depth used to specify alpha constant for destination
    union
    {
        DWORD   dwAlphaDestConst;               // Constant to use as alpha channel for dest
        LPDIRECTDRAWSURFACE lpDDSAlphaDest;     // Surface to use as alpha channel for dest
    } DUMMYUNIONNAMEN(1);
    DWORD       dwAlphaSrcConstBitDepth;        // Bit depth used to specify alpha constant for source
    union
    {
        DWORD   dwAlphaSrcConst;                // Constant to use as alpha channel for src
        LPDIRECTDRAWSURFACE lpDDSAlphaSrc;      // Surface to use as alpha channel for src
    } DUMMYUNIONNAMEN(2);
    DDCOLORKEY  dckDestColorkey;                // DestColorkey override
    DDCOLORKEY  dckSrcColorkey;                 // DestColorkey override
    DWORD       dwDDFX;                         // Overlay FX
    DWORD       dwFlags;                        // flags
} DDOVERLAYFX;

typedef DDOVERLAYFX FAR *LPDDOVERLAYFX;

//@@BEGIN_MSINTERNAL
#ifdef POSTPONED2
/*
 * DDSPRITEFX
 */
typedef struct _DDSPRITEFX
{
    DWORD       dwSize;               // sizeof(DDSPRITEFX)
    DWORD       dwDDFX;               // DDSPRITEFX_ (sprite FX) flags
    DDCOLORKEY  ddckDestColorkey;     // DestColorkey override
    DDCOLORKEY  ddckSrcColorkey;      // SrcColorkey override
    DDARGB      ddargbScaleFactors;   // Four 8-bit ARGB scaling factors
    float       fTransform[3][3];     // 3x3 transformation matrix
} DDSPRITEFX;

typedef DDSPRITEFX FAR *LPDDSPRITEFX;

/*
 * Structure that contains the information describing a sprite
 * in the display list that is passed to SetSpriteDisplayList().
 */
typedef struct _DDSPRITE {
    RECT        rcDest;             // destination rectangle
    LPDIRECTDRAWSURFACE7 lpDDSSrc;  // source surface
    RECT        rcSrc;              // source rectangle
    DWORD       dwFlags;            // DDSPRITE_ flags
    DWORD       dwReserved[2];      // reserved
    DDSPRITEFX  ddSpriteFX;         // sprite special FX
} DDSPRITE;

typedef DDSPRITE FAR *LPDDSPRITE;
#endif //POSTPONED2
//@@END_MSINTERNAL

/*
 * DDBLTBATCH: BltBatch entry structure
 */
typedef struct _DDBLTBATCH
{
    LPRECT              lprDest;
    LPDIRECTDRAWSURFACE lpDDSSrc;
    LPRECT              lprSrc;
    DWORD               dwFlags;
    LPDDBLTFX           lpDDBltFx;
} DDBLTBATCH;

typedef DDBLTBATCH FAR * LPDDBLTBATCH;


/*
 * DDGAMMARAMP
 */
typedef struct _DDGAMMARAMP
{
    WORD                red[256];
    WORD                green[256];
    WORD                blue[256];
} DDGAMMARAMP;
typedef DDGAMMARAMP FAR * LPDDGAMMARAMP;

/*
 *  This is the structure within which DirectDraw returns data about the current graphics driver and chipset
 */

#define MAX_DDDEVICEID_STRING           512

typedef struct tagDDDEVICEIDENTIFIER
{
    /*
     * These elements are for presentation to the user only. They should not be used to identify particular
     * drivers, since this is unreliable and many different strings may be associated with the same
     * device, and the same driver from different vendors.
     */
    char    szDriver[MAX_DDDEVICEID_STRING];
    char    szDescription[MAX_DDDEVICEID_STRING];

    /*
     * This element is the version of the DirectDraw/3D driver. It is legal to do <, > comparisons
     * on the whole 64 bits. Caution should be exercised if you use this element to identify problematic
     * drivers. It is recommended that guidDeviceIdentifier is used for this purpose.
     *
     * This version has the form:
     *  wProduct = HIWORD(liDriverVersion.HighPart)
     *  wVersion = LOWORD(liDriverVersion.HighPart)
     *  wSubVersion = HIWORD(liDriverVersion.LowPart)
     *  wBuild = LOWORD(liDriverVersion.LowPart)
     */
#ifdef _WIN32
    LARGE_INTEGER liDriverVersion;      /* Defined for applications and other 32 bit components */
#else
    DWORD   dwDriverVersionLowPart;     /* Defined for 16 bit driver components */
    DWORD   dwDriverVersionHighPart;
#endif


    /*
     * These elements can be used to identify particular chipsets. Use with extreme caution.
     *   dwVendorId     Identifies the manufacturer. May be zero if unknown.
     *   dwDeviceId     Identifies the type of chipset. May be zero if unknown.
     *   dwSubSysId     Identifies the subsystem, typically this means the particular board. May be zero if unknown.
     *   dwRevision     Identifies the revision level of the chipset. May be zero if unknown.
     */
    DWORD   dwVendorId;
    DWORD   dwDeviceId;
    DWORD   dwSubSysId;
    DWORD   dwRevision;

    /*
     * This element can be used to check changes in driver/chipset. This GUID is a unique identifier for the
     * driver/chipset pair. Use this element if you wish to track changes to the driver/chipset in order to
     * reprofile the graphics subsystem.
     * This element can also be used to identify particular problematic drivers.
     */
    GUID    guidDeviceIdentifier;
} DDDEVICEIDENTIFIER, * LPDDDEVICEIDENTIFIER;

typedef struct tagDDDEVICEIDENTIFIER2
{
    /*
     * These elements are for presentation to the user only. They should not be used to identify particular
     * drivers, since this is unreliable and many different strings may be associated with the same
     * device, and the same driver from different vendors.
     */
    char    szDriver[MAX_DDDEVICEID_STRING];
    char    szDescription[MAX_DDDEVICEID_STRING];

    /*
     * This element is the version of the DirectDraw/3D driver. It is legal to do <, > comparisons
     * on the whole 64 bits. Caution should be exercised if you use this element to identify problematic
     * drivers. It is recommended that guidDeviceIdentifier is used for this purpose.
     *
     * This version has the form:
     *  wProduct = HIWORD(liDriverVersion.HighPart)
     *  wVersion = LOWORD(liDriverVersion.HighPart)
     *  wSubVersion = HIWORD(liDriverVersion.LowPart)
     *  wBuild = LOWORD(liDriverVersion.LowPart)
     */
#ifdef _WIN32
    LARGE_INTEGER liDriverVersion;      /* Defined for applications and other 32 bit components */
#else
    DWORD   dwDriverVersionLowPart;     /* Defined for 16 bit driver components */
    DWORD   dwDriverVersionHighPart;
#endif


    /*
     * These elements can be used to identify particular chipsets. Use with extreme caution.
     *   dwVendorId     Identifies the manufacturer. May be zero if unknown.
     *   dwDeviceId     Identifies the type of chipset. May be zero if unknown.
     *   dwSubSysId     Identifies the subsystem, typically this means the particular board. May be zero if unknown.
     *   dwRevision     Identifies the revision level of the chipset. May be zero if unknown.
     */
    DWORD   dwVendorId;
    DWORD   dwDeviceId;
    DWORD   dwSubSysId;
    DWORD   dwRevision;

    /*
     * This element can be used to check changes in driver/chipset. This GUID is a unique identifier for the
     * driver/chipset pair. Use this element if you wish to track changes to the driver/chipset in order to
     * reprofile the graphics subsystem.
     * This element can also be used to identify particular problematic drivers.
     */
    GUID    guidDeviceIdentifier;

    /*
     * This element is used to determine the Windows Hardware Quality Lab (WHQL)
     * certification level for this driver/device pair.
     */
    DWORD   dwWHQLLevel;

} DDDEVICEIDENTIFIER2, * LPDDDEVICEIDENTIFIER2;

/*
 * Flags for the IDirectDraw4::GetDeviceIdentifier method
 */

/*
 * This flag causes GetDeviceIdentifier to return information about the host (typically 2D) adapter in a system equipped
 * with a stacked secondary 3D adapter. Such an adapter appears to the application as if it were part of the
 * host adapter, but is typically physcially located on a separate card. The stacked secondary's information is
 * returned when GetDeviceIdentifier's dwFlags field is zero, since this most accurately reflects the qualities
 * of the DirectDraw object involved.
 */
#define DDGDI_GETHOSTIDENTIFIER         0x00000001L

//@@BEGIN_MSINTERNAL
#define DDGDI_VALID                     0x00000001L
//@@END_MSINTERNAL
/*
 * Macros for interpretting DDEVICEIDENTIFIER2.dwWHQLLevel
 */
#define GET_WHQL_YEAR( dwWHQLLevel ) \
    ( (dwWHQLLevel) / 0x10000 )
#define GET_WHQL_MONTH( dwWHQLLevel ) \
    ( ( (dwWHQLLevel) / 0x100 ) & 0x00ff )
#define GET_WHQL_DAY( dwWHQLLevel ) \
    ( (dwWHQLLevel) & 0xff )


/*
 * callbacks
 */
typedef DWORD   (FAR PASCAL *LPCLIPPERCALLBACK)(LPDIRECTDRAWCLIPPER lpDDClipper, HWND hWnd, DWORD code, LPVOID lpContext );
#ifdef STREAMING
typedef DWORD   (FAR PASCAL *LPSURFACESTREAMINGCALLBACK)(DWORD);
#endif

//@@BEGIN_MSINTERNAL
#ifdef CLIPPER_NOTIFY
/*
 * values passed into the clipper callback
 */
#ifndef WINWATCHNOTIFY_START
    #define WINWATCHNOTIFY_START        0
    #define WINWATCHNOTIFY_STOP         1
    #define WINWATCHNOTIFY_DESTROY      2
    #define WINWATCHNOTIFY_CHANGING     3
    #define WINWATCHNOTIFY_CHANGED      4
#endif
#endif
//@@END_MSINTERNAL

/*
 * INTERACES FOLLOW:
 *      IDirectDraw
 *      IDirectDrawClipper
 *      IDirectDrawPalette
 *      IDirectDrawSurface
 *@@BEGIN_MSINTERNAL
 *      IDirectDrawSurfaceStreaming
 *      IDirectDrawSurfaceComposition
 *      IDirectDrawSurfaceClipperEx
 *              // this would allow multiple clipper objects to be attached
 *              // to the same destination
 *@@END_MSINTERNAL
 */

/*
 * IDirectDraw
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw
DECLARE_INTERFACE_( IDirectDraw, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw_SetDisplayMode(p, a, b, c)      (p)->lpVtbl->SetDisplayMode(p, a, b, c)
#define IDirectDraw_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#else
#define IDirectDraw_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw_AddRef(p)                       (p)->AddRef()
#define IDirectDraw_Release(p)                      (p)->Release()
#define IDirectDraw_Compact(p)                      (p)->Compact()
#define IDirectDraw_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw_SetDisplayMode(p, a, b, c)      (p)->SetDisplayMode(a, b, c)
#define IDirectDraw_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#endif

#endif

#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw2
DECLARE_INTERFACE_( IDirectDraw2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC, LPDIRECTDRAWSURFACE FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE, LPDIRECTDRAWSURFACE FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC, LPVOID, LPDDENUMMODESCALLBACK ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC, LPVOID,LPDDENUMSURFACESCALLBACK ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS, LPDWORD, LPDWORD) PURE;
};
#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw2_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw2_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw2_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw2_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw2_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw2_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw2_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw2_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw2_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw2_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw2_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw2_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw2_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw2_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw2_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw2_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw2_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw2_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw2_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw2_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw2_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw2_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw2_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw2_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#else
#define IDirectDraw2_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw2_AddRef(p)                       (p)->AddRef()
#define IDirectDraw2_Release(p)                      (p)->Release()
#define IDirectDraw2_Compact(p)                      (p)->Compact()
#define IDirectDraw2_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw2_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw2_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw2_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw2_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw2_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw2_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw2_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw2_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw2_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw2_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw2_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw2_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw2_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw2_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw2_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw2_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw2_SetDisplayMode(p, a, b, c, d, e) (p)->SetDisplayMode(a, b, c, d, e)
#define IDirectDraw2_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#define IDirectDraw2_GetAvailableVidMem(p, a, b, c)  (p)->GetAvailableVidMem(a, b, c)
#endif

#endif

#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw4
DECLARE_INTERFACE_( IDirectDraw4, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC2, LPDIRECTDRAWSURFACE4 FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE4, LPDIRECTDRAWSURFACE4 FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC2, LPVOID, LPDDENUMMODESCALLBACK2 ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC2, LPVOID,LPDDENUMSURFACESCALLBACK2 ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE4 FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS2, LPDWORD, LPDWORD) PURE;
    /*** Added in the V4 Interface ***/
    STDMETHOD(GetSurfaceFromDC) (THIS_ HDC, LPDIRECTDRAWSURFACE4 *) PURE;
    STDMETHOD(RestoreAllSurfaces)(THIS) PURE;
    STDMETHOD(TestCooperativeLevel)(THIS) PURE;
    STDMETHOD(GetDeviceIdentifier)(THIS_ LPDDDEVICEIDENTIFIER, DWORD ) PURE;
};
#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw4_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw4_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw4_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw4_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw4_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw4_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw4_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw4_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw4_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw4_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw4_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw4_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw4_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw4_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw4_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw4_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw4_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw4_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw4_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw4_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw4_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw4_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw4_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw4_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#define IDirectDraw4_GetSurfaceFromDC(p, a, b)       (p)->lpVtbl->GetSurfaceFromDC(p, a, b)
#define IDirectDraw4_RestoreAllSurfaces(p)           (p)->lpVtbl->RestoreAllSurfaces(p)
#define IDirectDraw4_TestCooperativeLevel(p)         (p)->lpVtbl->TestCooperativeLevel(p)
#define IDirectDraw4_GetDeviceIdentifier(p,a,b)      (p)->lpVtbl->GetDeviceIdentifier(p,a,b)
#else
#define IDirectDraw4_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw4_AddRef(p)                       (p)->AddRef()
#define IDirectDraw4_Release(p)                      (p)->Release()
#define IDirectDraw4_Compact(p)                      (p)->Compact()
#define IDirectDraw4_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw4_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw4_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw4_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw4_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw4_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw4_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw4_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw4_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw4_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw4_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw4_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw4_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw4_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw4_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw4_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw4_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw4_SetDisplayMode(p, a, b, c, d, e) (p)->SetDisplayMode(a, b, c, d, e)
#define IDirectDraw4_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#define IDirectDraw4_GetAvailableVidMem(p, a, b, c)  (p)->GetAvailableVidMem(a, b, c)
#define IDirectDraw4_GetSurfaceFromDC(p, a, b)       (p)->GetSurfaceFromDC(a, b)
#define IDirectDraw4_RestoreAllSurfaces(p)           (p)->RestoreAllSurfaces()
#define IDirectDraw4_TestCooperativeLevel(p)         (p)->TestCooperativeLevel()
#define IDirectDraw4_GetDeviceIdentifier(p,a,b)      (p)->GetDeviceIdentifier(a,b)
#endif

#endif

#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDraw7
DECLARE_INTERFACE_( IDirectDraw7, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDraw methods ***/
    STDMETHOD(Compact)(THIS) PURE;
    STDMETHOD(CreateClipper)(THIS_ DWORD, LPDIRECTDRAWCLIPPER FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreatePalette)(THIS_ DWORD, LPPALETTEENTRY, LPDIRECTDRAWPALETTE FAR*, IUnknown FAR * ) PURE;
    STDMETHOD(CreateSurface)(THIS_  LPDDSURFACEDESC2, LPDIRECTDRAWSURFACE7 FAR *, IUnknown FAR *) PURE;
    STDMETHOD(DuplicateSurface)( THIS_ LPDIRECTDRAWSURFACE7, LPDIRECTDRAWSURFACE7 FAR * ) PURE;
    STDMETHOD(EnumDisplayModes)( THIS_ DWORD, LPDDSURFACEDESC2, LPVOID, LPDDENUMMODESCALLBACK2 ) PURE;
    STDMETHOD(EnumSurfaces)(THIS_ DWORD, LPDDSURFACEDESC2, LPVOID,LPDDENUMSURFACESCALLBACK7 ) PURE;
    STDMETHOD(FlipToGDISurface)(THIS) PURE;
    STDMETHOD(GetCaps)( THIS_ LPDDCAPS, LPDDCAPS) PURE;
    STDMETHOD(GetDisplayMode)( THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(GetFourCCCodes)(THIS_  LPDWORD, LPDWORD ) PURE;
    STDMETHOD(GetGDISurface)(THIS_ LPDIRECTDRAWSURFACE7 FAR *) PURE;
    STDMETHOD(GetMonitorFrequency)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetScanLine)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetVerticalBlankStatus)(THIS_ LPBOOL ) PURE;
    STDMETHOD(Initialize)(THIS_ GUID FAR *) PURE;
    STDMETHOD(RestoreDisplayMode)(THIS) PURE;
    STDMETHOD(SetCooperativeLevel)(THIS_ HWND, DWORD) PURE;
    STDMETHOD(SetDisplayMode)(THIS_ DWORD, DWORD,DWORD, DWORD, DWORD) PURE;
    STDMETHOD(WaitForVerticalBlank)(THIS_ DWORD, HANDLE ) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetAvailableVidMem)(THIS_ LPDDSCAPS2, LPDWORD, LPDWORD) PURE;
    /*** Added in the V4 Interface ***/
    STDMETHOD(GetSurfaceFromDC) (THIS_ HDC, LPDIRECTDRAWSURFACE7 *) PURE;
    STDMETHOD(RestoreAllSurfaces)(THIS) PURE;
    STDMETHOD(TestCooperativeLevel)(THIS) PURE;
    STDMETHOD(GetDeviceIdentifier)(THIS_ LPDDDEVICEIDENTIFIER2, DWORD ) PURE;
    STDMETHOD(StartModeTest)(THIS_ LPSIZE, DWORD, DWORD ) PURE;
    STDMETHOD(EvaluateMode)(THIS_ DWORD, DWORD * ) PURE;
//@@BEGIN_MSINTERNAL
#ifdef POSTPONED
    STDMETHOD(CreateSurfaceFromStream) (THIS_ IStream *, LPDDSURFACEDESC2, DWORD, LPDIRECTDRAWSURFACE7 *, IUnknown *) PURE;
    STDMETHOD(CreateSurfaceFromFile) (THIS_ BSTR , LPDDSURFACEDESC2, DWORD, LPDIRECTDRAWSURFACE7 *, IUnknown *) PURE;
#endif
//@@END_MSINTERNAL
};
#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw7_QueryInterface(p, a, b)         (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw7_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectDraw7_Release(p)                      (p)->lpVtbl->Release(p)
#define IDirectDraw7_Compact(p)                      (p)->lpVtbl->Compact(p)
#define IDirectDraw7_CreateClipper(p, a, b, c)       (p)->lpVtbl->CreateClipper(p, a, b, c)
#define IDirectDraw7_CreatePalette(p, a, b, c, d)    (p)->lpVtbl->CreatePalette(p, a, b, c, d)
#define IDirectDraw7_CreateSurface(p, a, b, c)       (p)->lpVtbl->CreateSurface(p, a, b, c)
#define IDirectDraw7_DuplicateSurface(p, a, b)       (p)->lpVtbl->DuplicateSurface(p, a, b)
#define IDirectDraw7_EnumDisplayModes(p, a, b, c, d) (p)->lpVtbl->EnumDisplayModes(p, a, b, c, d)
#define IDirectDraw7_EnumSurfaces(p, a, b, c, d)     (p)->lpVtbl->EnumSurfaces(p, a, b, c, d)
#define IDirectDraw7_FlipToGDISurface(p)             (p)->lpVtbl->FlipToGDISurface(p)
#define IDirectDraw7_GetCaps(p, a, b)                (p)->lpVtbl->GetCaps(p, a, b)
#define IDirectDraw7_GetDisplayMode(p, a)            (p)->lpVtbl->GetDisplayMode(p, a)
#define IDirectDraw7_GetFourCCCodes(p, a, b)         (p)->lpVtbl->GetFourCCCodes(p, a, b)
#define IDirectDraw7_GetGDISurface(p, a)             (p)->lpVtbl->GetGDISurface(p, a)
#define IDirectDraw7_GetMonitorFrequency(p, a)       (p)->lpVtbl->GetMonitorFrequency(p, a)
#define IDirectDraw7_GetScanLine(p, a)               (p)->lpVtbl->GetScanLine(p, a)
#define IDirectDraw7_GetVerticalBlankStatus(p, a)    (p)->lpVtbl->GetVerticalBlankStatus(p, a)
#define IDirectDraw7_Initialize(p, a)                (p)->lpVtbl->Initialize(p, a)
#define IDirectDraw7_RestoreDisplayMode(p)           (p)->lpVtbl->RestoreDisplayMode(p)
#define IDirectDraw7_SetCooperativeLevel(p, a, b)    (p)->lpVtbl->SetCooperativeLevel(p, a, b)
#define IDirectDraw7_SetDisplayMode(p, a, b, c, d, e) (p)->lpVtbl->SetDisplayMode(p, a, b, c, d, e)
#define IDirectDraw7_WaitForVerticalBlank(p, a, b)   (p)->lpVtbl->WaitForVerticalBlank(p, a, b)
#define IDirectDraw7_GetAvailableVidMem(p, a, b, c)  (p)->lpVtbl->GetAvailableVidMem(p, a, b, c)
#define IDirectDraw7_GetSurfaceFromDC(p, a, b)       (p)->lpVtbl->GetSurfaceFromDC(p, a, b)
#define IDirectDraw7_RestoreAllSurfaces(p)           (p)->lpVtbl->RestoreAllSurfaces(p)
#define IDirectDraw7_TestCooperativeLevel(p)         (p)->lpVtbl->TestCooperativeLevel(p)
#define IDirectDraw7_GetDeviceIdentifier(p,a,b)      (p)->lpVtbl->GetDeviceIdentifier(p,a,b)
#define IDirectDraw7_StartModeTest(p,a,b,c)        (p)->lpVtbl->StartModeTest(p,a,b,c)
#define IDirectDraw7_EvaluateMode(p,a,b)           (p)->lpVtbl->EvaluateMode(p,a,b)
//@@BEGIN_MSINTERNAL
#define IDirectDraw7_CreateSurfaceFromStream(p, a, b, c, d, e) (p)->lpVtbl->CreateSurfaceFromStream(p, a, b, c, d, e)
#define IDirectDraw7_CreateSurfaceFromFile(p, a, b, c, d, e) (p)->lpVtbl->CreateSurfaceFromFile(p, a, b, c, d, e)
//@@END_MSINTERNAL
#else
#define IDirectDraw7_QueryInterface(p, a, b)         (p)->QueryInterface(a, b)
#define IDirectDraw7_AddRef(p)                       (p)->AddRef()
#define IDirectDraw7_Release(p)                      (p)->Release()
#define IDirectDraw7_Compact(p)                      (p)->Compact()
#define IDirectDraw7_CreateClipper(p, a, b, c)       (p)->CreateClipper(a, b, c)
#define IDirectDraw7_CreatePalette(p, a, b, c, d)    (p)->CreatePalette(a, b, c, d)
#define IDirectDraw7_CreateSurface(p, a, b, c)       (p)->CreateSurface(a, b, c)
#define IDirectDraw7_DuplicateSurface(p, a, b)       (p)->DuplicateSurface(a, b)
#define IDirectDraw7_EnumDisplayModes(p, a, b, c, d) (p)->EnumDisplayModes(a, b, c, d)
#define IDirectDraw7_EnumSurfaces(p, a, b, c, d)     (p)->EnumSurfaces(a, b, c, d)
#define IDirectDraw7_FlipToGDISurface(p)             (p)->FlipToGDISurface()
#define IDirectDraw7_GetCaps(p, a, b)                (p)->GetCaps(a, b)
#define IDirectDraw7_GetDisplayMode(p, a)            (p)->GetDisplayMode(a)
#define IDirectDraw7_GetFourCCCodes(p, a, b)         (p)->GetFourCCCodes(a, b)
#define IDirectDraw7_GetGDISurface(p, a)             (p)->GetGDISurface(a)
#define IDirectDraw7_GetMonitorFrequency(p, a)       (p)->GetMonitorFrequency(a)
#define IDirectDraw7_GetScanLine(p, a)               (p)->GetScanLine(a)
#define IDirectDraw7_GetVerticalBlankStatus(p, a)    (p)->GetVerticalBlankStatus(a)
#define IDirectDraw7_Initialize(p, a)                (p)->Initialize(a)
#define IDirectDraw7_RestoreDisplayMode(p)           (p)->RestoreDisplayMode()
#define IDirectDraw7_SetCooperativeLevel(p, a, b)    (p)->SetCooperativeLevel(a, b)
#define IDirectDraw7_SetDisplayMode(p, a, b, c, d, e) (p)->SetDisplayMode(a, b, c, d, e)
#define IDirectDraw7_WaitForVerticalBlank(p, a, b)   (p)->WaitForVerticalBlank(a, b)
#define IDirectDraw7_GetAvailableVidMem(p, a, b, c)  (p)->GetAvailableVidMem(a, b, c)
#define IDirectDraw7_GetSurfaceFromDC(p, a, b)       (p)->GetSurfaceFromDC(a, b)
#define IDirectDraw7_RestoreAllSurfaces(p)           (p)->RestoreAllSurfaces()
#define IDirectDraw7_TestCooperativeLevel(p)         (p)->TestCooperativeLevel()
#define IDirectDraw7_GetDeviceIdentifier(p,a,b)      (p)->GetDeviceIdentifier(a,b)
#define IDirectDraw7_StartModeTest(p,a,b,c)        (p)->lpVtbl->StartModeTest(a,b,c)
#define IDirectDraw7_EvaluateMode(p,a,b)           (p)->lpVtbl->EvaluateMode(a,b)
//@@BEGIN_MSINTERNAL
#define IDirectDraw7_CreateSurfaceFromStream(p, a, b, c, d, e) (p)->CreateSurfaceFromStream(a, b, c, d, e)
#define IDirectDraw7_CreateSurfaceFromFile(p, a, b, c, d, e) (p)->CreateSurfaceFromFile(a, b, c, d, e)
//@@END_MSINTERNAL
#endif

#endif

//@@BEGIN_MSINTERNAL

/*
 * IDirectDrawFactory2
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawFactory2
DECLARE_INTERFACE_( IDirectDrawFactory2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawFactory2 methods ***/
    STDMETHOD(CreateDirectDraw) (THIS_ GUID * pGUID, HWND hWnd, DWORD dwCoopLevelFlags, DWORD dwReserved, IUnknown *pUnkOuter, struct IDirectDraw4 **ppDirectDraw) PURE;
#ifdef SM_CMONITORS
    STDMETHOD(DirectDrawEnumerate) (THIS_ LPDDENUMCALLBACKEX , LPVOID , DWORD ) PURE;
#else
    STDMETHOD(DirectDrawEnumerate) (THIS_ LPDDENUMCALLBACK , LPVOID , DWORD ) PURE;
#endif
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDraw_QueryInterface(p, a, b)                     (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDraw_AddRef(p)                                   (p)->lpVtbl->AddRef(p)
#define IDirectDraw_Release(p)                                  (p)->lpVtbl->Release(p)
#define IDirectDraw_CreateDirectDraw(p, a, b, c, d, e, f)       (p)->lpVtbl->CreateDirectDraw(p, a, b, c, d, e, f)
#define IDirectDraw_DirectDrawEnumerate(p, a, b, c)             (p)->lpVtbl->DirectDrawEnumerate(p, a, b, c)
#else
#define IDirectDraw_QueryInterface(p, a, b)                     (p)->QueryInterface(a, b)
#define IDirectDraw_AddRef(p)                                   (p)->AddRef()
#define IDirectDraw_Release(p)                                  (p)->Release()
#define IDirectDraw_CreateDirectDraw(p, a, b, c, d, e, f)       (p)->CreateDirectDraw(a, b, c, d, e, f)
#define IDirectDraw_DirectDrawEnumerate(p, a, b, c)             (p)->DirectDrawEnumerate(a, b, c)
#endif

#endif
//@@END_MSINTERNAL

/*
 * IDirectDrawPalette
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawPalette
DECLARE_INTERFACE_( IDirectDrawPalette, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawPalette methods ***/
    STDMETHOD(GetCaps)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD, LPPALETTEENTRY) PURE;
    STDMETHOD(SetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawPalette_QueryInterface(p, a, b)      (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawPalette_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawPalette_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawPalette_GetCaps(p, a)                (p)->lpVtbl->GetCaps(p, a)
#define IDirectDrawPalette_GetEntries(p, a, b, c, d)    (p)->lpVtbl->GetEntries(p, a, b, c, d)
#define IDirectDrawPalette_Initialize(p, a, b, c)       (p)->lpVtbl->Initialize(p, a, b, c)
#define IDirectDrawPalette_SetEntries(p, a, b, c, d)    (p)->lpVtbl->SetEntries(p, a, b, c, d)
#else
#define IDirectDrawPalette_QueryInterface(p, a, b)      (p)->QueryInterface(a, b)
#define IDirectDrawPalette_AddRef(p)                    (p)->AddRef()
#define IDirectDrawPalette_Release(p)                   (p)->Release()
#define IDirectDrawPalette_GetCaps(p, a)                (p)->GetCaps(a)
#define IDirectDrawPalette_GetEntries(p, a, b, c, d)    (p)->GetEntries(a, b, c, d)
#define IDirectDrawPalette_Initialize(p, a, b, c)       (p)->Initialize(a, b, c)
#define IDirectDrawPalette_SetEntries(p, a, b, c, d)    (p)->SetEntries(a, b, c, d)
#endif

#endif

//@@BEGIN_MSINTERNAL
/*
 * IDirectDrawPalette2
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawPalette2
DECLARE_INTERFACE_( IDirectDrawPalette2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawPalette methods ***/
    STDMETHOD(GetCaps)(THIS_ LPDWORD) PURE;
    STDMETHOD(GetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD, LPPALETTEENTRY) PURE;
    STDMETHOD(SetEntries)(THIS_ DWORD,DWORD,DWORD,LPPALETTEENTRY) PURE;
    /*** IDirectDrawPalette2 methods ***/
    STDMETHOD(SetPrivateData)(THIS_ REFGUID, LPVOID, DWORD, DWORD) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID, LPVOID, LPDWORD) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID) PURE;
    STDMETHOD(GetUniquenessValue)(THIS_ LPDWORD) PURE;
    STDMETHOD(ChangeUniquenessValue)(THIS) PURE;
    STDMETHOD(IsEqual)(THIS_ LPDIRECTDRAWPALETTE2) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawPalette2_QueryInterface(p, a, b)      (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawPalette2_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawPalette2_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawPalette2_GetCaps(p, a)                (p)->lpVtbl->GetCaps(p, a)
#define IDirectDrawPalette2_GetEntries(p, a, b, c, d)    (p)->lpVtbl->GetEntries(p, a, b, c, d)
#define IDirectDrawPalette2_Initialize(p, a, b, c)       (p)->lpVtbl->Initialize(p, a, b, c)
#define IDirectDrawPalette2_SetEntries(p, a, b, c, d)    (p)->lpVtbl->SetEntries(p, a, b, c, d)
#define IDirectDrawPalette2_SetPrivateData(p,a,b,c,d)    (p)->lpVtbl->SetPrivateData(p, a, b, c, d)
#define IDirectDrawPalette2_GetPrivateData(p,a,b,c)      (p)->lpVtbl->GetPrivateData(p, a, b, c)
#define IDirectDrawPalette2_FreePrivateData(p, a)        (p)->lpVtbl->FreePrivateData(p, a)
#define IDirectDrawPalette2_GetUniquenessValue(p, a)     (p)->lpVtbl->GetUniquenessValue(p, a)
#define IDirectDrawPalette2_ChangeUniquenessValue(p)     (p)->lpVtbl->ChangeUniquenessValue(p)
#define IDirectDrawPalette2_IsEqual(p, a)                (p)->lpVtbl->IsEqual(p, a)
#else
#define IDirectDrawPalette2_QueryInterface(p, a, b)      (p)->QueryInterface(a, b)
#define IDirectDrawPalette2_AddRef(p)                    (p)->AddRef()
#define IDirectDrawPalette2_Release(p)                   (p)->Release()
#define IDirectDrawPalette2_GetCaps(p, a)                (p)->GetCaps(a)
#define IDirectDrawPalette2_GetEntries(p, a, b, c, d)    (p)->GetEntries(a, b, c, d)
#define IDirectDrawPalette2_Initialize(p, a, b, c)       (p)->Initialize(a, b, c)
#define IDirectDrawPalette2_SetEntries(p, a, b, c, d)    (p)->SetEntries(a, b, c, d)
#define IDirectDrawPalette2_SetPrivateData(p,a,b,c,d)    (p)->SetPrivateData(a, b, c, d)
#define IDirectDrawPalette2_GetPrivateData(p,a,b,c)      (p)->GetPrivateData(a, b, c)
#define IDirectDrawPalette2_FreePrivateData(p, a)        (p)->FreePrivateData(a)
#define IDirectDrawPalette2_GetUniquenessValue(p, a)     (p)->GetUniquenessValue(a)
#define IDirectDrawPalette2_ChangeUniquenessValue(p)     (p)->ChangeUniquenessValue()
#define IDirectDrawPalette2_IsEqual(p, a)                (p)->IsEqual(a)
#endif

#endif
//@@END_MSINTERNAL


/*
 * IDirectDrawClipper
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawClipper
DECLARE_INTERFACE_( IDirectDrawClipper, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawClipper methods ***/
    STDMETHOD(GetClipList)(THIS_ LPRECT, LPRGNDATA, LPDWORD) PURE;
    STDMETHOD(GetHWnd)(THIS_ HWND FAR *) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, DWORD) PURE;
    STDMETHOD(IsClipListChanged)(THIS_ BOOL FAR *) PURE;
    STDMETHOD(SetClipList)(THIS_ LPRGNDATA,DWORD) PURE;
    STDMETHOD(SetHWnd)(THIS_ DWORD, HWND ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawClipper_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawClipper_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawClipper_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawClipper_GetClipList(p, a, b, c)  (p)->lpVtbl->GetClipList(p, a, b, c)
#define IDirectDrawClipper_GetHWnd(p, a)            (p)->lpVtbl->GetHWnd(p, a)
#define IDirectDrawClipper_Initialize(p, a, b)      (p)->lpVtbl->Initialize(p, a, b)
#define IDirectDrawClipper_IsClipListChanged(p, a)  (p)->lpVtbl->IsClipListChanged(p, a)
#define IDirectDrawClipper_SetClipList(p, a, b)     (p)->lpVtbl->SetClipList(p, a, b)
#define IDirectDrawClipper_SetHWnd(p, a, b)         (p)->lpVtbl->SetHWnd(p, a, b)
#else
#define IDirectDrawClipper_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
#define IDirectDrawClipper_AddRef(p)                (p)->AddRef()
#define IDirectDrawClipper_Release(p)               (p)->Release()
#define IDirectDrawClipper_GetClipList(p, a, b, c)  (p)->GetClipList(a, b, c)
#define IDirectDrawClipper_GetHWnd(p, a)            (p)->GetHWnd(a)
#define IDirectDrawClipper_Initialize(p, a, b)      (p)->Initialize(a, b)
#define IDirectDrawClipper_IsClipListChanged(p, a)  (p)->IsClipListChanged(a)
#define IDirectDrawClipper_SetClipList(p, a, b)     (p)->SetClipList(a, b)
#define IDirectDrawClipper_SetHWnd(p, a, b)         (p)->SetHWnd(a, b)
#endif

#endif

/*
 * IDirectDrawSurface and related interfaces
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawSurface
DECLARE_INTERFACE_( IDirectDrawSurface, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#else
#define IDirectDrawSurface_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface_Release(p)                   (p)->Release()
#define IDirectDrawSurface_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#endif

/*
 * IDirectDrawSurface2 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface2
DECLARE_INTERFACE_( IDirectDrawSurface2, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE2) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE2, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE2, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE2) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE2, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE2 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE2,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE2) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface2_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface2_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface2_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface2_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface2_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface2_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface2_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface2_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface2_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface2_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface2_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface2_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface2_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface2_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface2_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface2_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface2_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface2_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface2_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface2_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface2_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface2_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface2_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface2_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface2_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface2_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface2_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface2_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface2_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface2_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface2_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface2_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface2_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface2_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface2_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface2_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface2_GetDDInterface(p,a)          (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface2_PageLock(p,a)                (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface2_PageUnlock(p,a)              (p)->lpVtbl->PageUnlock(p,a)
#else
#define IDirectDrawSurface2_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface2_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface2_Release(p)                   (p)->Release()
#define IDirectDrawSurface2_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface2_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface2_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface2_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface2_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface2_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface2_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface2_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface2_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface2_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface2_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface2_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface2_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface2_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface2_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface2_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface2_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface2_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface2_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface2_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface2_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface2_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface2_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface2_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface2_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface2_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface2_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface2_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface2_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface2_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface2_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface2_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface2_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface2_GetDDInterface(p,a)          (p)->GetDDInterface(a)
#define IDirectDrawSurface2_PageLock(p,a)                (p)->PageLock(a)
#define IDirectDrawSurface2_PageUnlock(p,a)              (p)->PageUnlock(a)
#endif

/*
 * IDirectDrawSurface3 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface3
DECLARE_INTERFACE_( IDirectDrawSurface3, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE3, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE3, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE3) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE3, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS, LPDIRECTDRAWSURFACE3 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE3,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE3) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the V3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC, DWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface3_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface3_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface3_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface3_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface3_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface3_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface3_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface3_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface3_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface3_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface3_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface3_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface3_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface3_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface3_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface3_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface3_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface3_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface3_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface3_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface3_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface3_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface3_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface3_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface3_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface3_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface3_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface3_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface3_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface3_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface3_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface3_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface3_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface3_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface3_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface3_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface3_GetDDInterface(p,a)          (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface3_PageLock(p,a)                (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface3_PageUnlock(p,a)              (p)->lpVtbl->PageUnlock(p,a)
#define IDirectDrawSurface3_SetSurfaceDesc(p,a,b)        (p)->lpVtbl->SetSurfaceDesc(p,a,b)
#else
#define IDirectDrawSurface3_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface3_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface3_Release(p)                   (p)->Release()
#define IDirectDrawSurface3_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface3_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface3_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface3_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface3_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface3_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface3_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface3_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface3_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface3_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface3_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface3_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface3_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface3_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface3_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface3_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface3_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface3_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface3_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface3_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface3_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface3_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface3_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface3_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface3_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface3_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface3_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface3_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface3_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface3_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface3_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface3_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface3_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface3_GetDDInterface(p,a)          (p)->GetDDInterface(a)
#define IDirectDrawSurface3_PageLock(p,a)                (p)->PageLock(a)
#define IDirectDrawSurface3_PageUnlock(p,a)              (p)->PageUnlock(a)
#define IDirectDrawSurface3_SetSurfaceDesc(p,a,b)        (p)->SetSurfaceDesc(a,b)
#endif

/*
 * IDirectDrawSurface4 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface4
DECLARE_INTERFACE_( IDirectDrawSurface4, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE4) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE4, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE4, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE4) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK2) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK2) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE4, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS2, LPDIRECTDRAWSURFACE4 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS2) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC2) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC2,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPRECT) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE4,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE4) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the v3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC2, DWORD) PURE;
    /*** Added in the v4 interface ***/
    STDMETHOD(SetPrivateData)(THIS_ REFGUID, LPVOID, DWORD, DWORD) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID, LPVOID, LPDWORD) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID) PURE;
    STDMETHOD(GetUniquenessValue)(THIS_ LPDWORD) PURE;
    STDMETHOD(ChangeUniquenessValue)(THIS) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface4_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface4_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface4_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface4_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface4_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface4_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface4_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface4_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface4_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface4_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface4_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface4_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface4_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface4_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface4_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface4_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface4_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface4_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface4_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface4_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface4_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface4_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface4_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface4_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface4_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface4_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface4_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface4_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface4_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface4_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface4_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface4_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface4_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface4_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface4_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface4_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface4_GetDDInterface(p,a)          (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface4_PageLock(p,a)                (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface4_PageUnlock(p,a)              (p)->lpVtbl->PageUnlock(p,a)
#define IDirectDrawSurface4_SetSurfaceDesc(p,a,b)        (p)->lpVtbl->SetSurfaceDesc(p,a,b)
#define IDirectDrawSurface4_SetPrivateData(p,a,b,c,d)    (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirectDrawSurface4_GetPrivateData(p,a,b,c)      (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirectDrawSurface4_FreePrivateData(p,a)         (p)->lpVtbl->FreePrivateData(p,a)
#define IDirectDrawSurface4_GetUniquenessValue(p, a)     (p)->lpVtbl->GetUniquenessValue(p, a)
#define IDirectDrawSurface4_ChangeUniquenessValue(p)     (p)->lpVtbl->ChangeUniquenessValue(p)
#else
#define IDirectDrawSurface4_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface4_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface4_Release(p)                   (p)->Release()
#define IDirectDrawSurface4_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface4_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface4_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface4_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface4_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface4_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface4_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface4_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface4_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface4_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface4_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface4_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface4_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface4_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface4_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface4_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface4_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface4_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface4_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface4_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface4_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface4_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface4_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface4_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface4_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface4_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface4_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface4_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface4_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface4_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface4_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface4_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface4_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface4_GetDDInterface(p,a)          (p)->GetDDInterface(a)
#define IDirectDrawSurface4_PageLock(p,a)                (p)->PageLock(a)
#define IDirectDrawSurface4_PageUnlock(p,a)              (p)->PageUnlock(a)
#define IDirectDrawSurface4_SetSurfaceDesc(p,a,b)        (p)->SetSurfaceDesc(a,b)
#define IDirectDrawSurface4_SetPrivateData(p,a,b,c,d)    (p)->SetPrivateData(a,b,c,d)
#define IDirectDrawSurface4_GetPrivateData(p,a,b,c)      (p)->GetPrivateData(a,b,c)
#define IDirectDrawSurface4_FreePrivateData(p,a)         (p)->FreePrivateData(a)
#define IDirectDrawSurface4_GetUniquenessValue(p, a)     (p)->GetUniquenessValue(a)
#define IDirectDrawSurface4_ChangeUniquenessValue(p)     (p)->ChangeUniquenessValue()
#endif

/*
 * IDirectDrawSurface7 and related interfaces
 */
#undef INTERFACE
#define INTERFACE IDirectDrawSurface7
DECLARE_INTERFACE_( IDirectDrawSurface7, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurface methods ***/
    STDMETHOD(AddAttachedSurface)(THIS_ LPDIRECTDRAWSURFACE7) PURE;
    STDMETHOD(AddOverlayDirtyRect)(THIS_ LPRECT) PURE;
    STDMETHOD(Blt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE7, LPRECT,DWORD, LPDDBLTFX) PURE;
    STDMETHOD(BltBatch)(THIS_ LPDDBLTBATCH, DWORD, DWORD ) PURE;
    STDMETHOD(BltFast)(THIS_ DWORD,DWORD,LPDIRECTDRAWSURFACE7, LPRECT,DWORD) PURE;
    STDMETHOD(DeleteAttachedSurface)(THIS_ DWORD,LPDIRECTDRAWSURFACE7) PURE;
    STDMETHOD(EnumAttachedSurfaces)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK7) PURE;
    STDMETHOD(EnumOverlayZOrders)(THIS_ DWORD,LPVOID,LPDDENUMSURFACESCALLBACK7) PURE;
    STDMETHOD(Flip)(THIS_ LPDIRECTDRAWSURFACE7, DWORD) PURE;
    STDMETHOD(GetAttachedSurface)(THIS_ LPDDSCAPS2, LPDIRECTDRAWSURFACE7 FAR *) PURE;
    STDMETHOD(GetBltStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetCaps)(THIS_ LPDDSCAPS2) PURE;
    STDMETHOD(GetClipper)(THIS_ LPDIRECTDRAWCLIPPER FAR*) PURE;
    STDMETHOD(GetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(GetDC)(THIS_ HDC FAR *) PURE;
    STDMETHOD(GetFlipStatus)(THIS_ DWORD) PURE;
    STDMETHOD(GetOverlayPosition)(THIS_ LPLONG, LPLONG ) PURE;
    STDMETHOD(GetPalette)(THIS_ LPDIRECTDRAWPALETTE FAR*) PURE;
    STDMETHOD(GetPixelFormat)(THIS_ LPDDPIXELFORMAT) PURE;
    STDMETHOD(GetSurfaceDesc)(THIS_ LPDDSURFACEDESC2) PURE;
    STDMETHOD(Initialize)(THIS_ LPDIRECTDRAW, LPDDSURFACEDESC2) PURE;
    STDMETHOD(IsLost)(THIS) PURE;
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC2,DWORD,HANDLE) PURE;
    STDMETHOD(ReleaseDC)(THIS_ HDC) PURE;
    STDMETHOD(Restore)(THIS) PURE;
    STDMETHOD(SetClipper)(THIS_ LPDIRECTDRAWCLIPPER) PURE;
    STDMETHOD(SetColorKey)(THIS_ DWORD, LPDDCOLORKEY) PURE;
    STDMETHOD(SetOverlayPosition)(THIS_ LONG, LONG ) PURE;
    STDMETHOD(SetPalette)(THIS_ LPDIRECTDRAWPALETTE) PURE;
    STDMETHOD(Unlock)(THIS_ LPRECT) PURE;
    STDMETHOD(UpdateOverlay)(THIS_ LPRECT, LPDIRECTDRAWSURFACE7,LPRECT,DWORD, LPDDOVERLAYFX) PURE;
    STDMETHOD(UpdateOverlayDisplay)(THIS_ DWORD) PURE;
    STDMETHOD(UpdateOverlayZOrder)(THIS_ DWORD, LPDIRECTDRAWSURFACE7) PURE;
    /*** Added in the v2 interface ***/
    STDMETHOD(GetDDInterface)(THIS_ LPVOID FAR *) PURE;
    STDMETHOD(PageLock)(THIS_ DWORD) PURE;
    STDMETHOD(PageUnlock)(THIS_ DWORD) PURE;
    /*** Added in the v3 interface ***/
    STDMETHOD(SetSurfaceDesc)(THIS_ LPDDSURFACEDESC2, DWORD) PURE;
    /*** Added in the v4 interface ***/
    STDMETHOD(SetPrivateData)(THIS_ REFGUID, LPVOID, DWORD, DWORD) PURE;
    STDMETHOD(GetPrivateData)(THIS_ REFGUID, LPVOID, LPDWORD) PURE;
    STDMETHOD(FreePrivateData)(THIS_ REFGUID) PURE;
    STDMETHOD(GetUniquenessValue)(THIS_ LPDWORD) PURE;
    STDMETHOD(ChangeUniquenessValue)(THIS) PURE;
//@@BEGIN_MSINTERNAL
#ifdef POSTPONED2
    STDMETHOD(AlphaBlt)(THIS_ LPRECT,LPDIRECTDRAWSURFACE7,LPRECT,DWORD,LPDDALPHABLTFX) PURE;
    STDMETHOD(SetSpriteDisplayList)(THIS_ LPDDSPRITE *,DWORD,DWORD,LPDIRECTDRAWSURFACE7,DWORD) PURE;
    STDMETHOD(Resize)(THIS_ DWORD,DWORD,DWORD) PURE;
#endif //POSTPONED2
//@@END_MSINTERNAL
    /*** Moved Texture7 methods here ***/
    STDMETHOD(SetPriority)(THIS_ DWORD) PURE;
    STDMETHOD(GetPriority)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetLOD)(THIS_ DWORD) PURE;
    STDMETHOD(GetLOD)(THIS_ LPDWORD) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawSurface7_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectDrawSurface7_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IDirectDrawSurface7_Release(p)                   (p)->lpVtbl->Release(p)
#define IDirectDrawSurface7_AddAttachedSurface(p,a)      (p)->lpVtbl->AddAttachedSurface(p,a)
#define IDirectDrawSurface7_AddOverlayDirtyRect(p,a)     (p)->lpVtbl->AddOverlayDirtyRect(p,a)
#define IDirectDrawSurface7_Blt(p,a,b,c,d,e)             (p)->lpVtbl->Blt(p,a,b,c,d,e)
#define IDirectDrawSurface7_BltBatch(p,a,b,c)            (p)->lpVtbl->BltBatch(p,a,b,c)
#define IDirectDrawSurface7_BltFast(p,a,b,c,d,e)         (p)->lpVtbl->BltFast(p,a,b,c,d,e)
#define IDirectDrawSurface7_DeleteAttachedSurface(p,a,b) (p)->lpVtbl->DeleteAttachedSurface(p,a,b)
#define IDirectDrawSurface7_EnumAttachedSurfaces(p,a,b)  (p)->lpVtbl->EnumAttachedSurfaces(p,a,b)
#define IDirectDrawSurface7_EnumOverlayZOrders(p,a,b,c)  (p)->lpVtbl->EnumOverlayZOrders(p,a,b,c)
#define IDirectDrawSurface7_Flip(p,a,b)                  (p)->lpVtbl->Flip(p,a,b)
#define IDirectDrawSurface7_GetAttachedSurface(p,a,b)    (p)->lpVtbl->GetAttachedSurface(p,a,b)
#define IDirectDrawSurface7_GetBltStatus(p,a)            (p)->lpVtbl->GetBltStatus(p,a)
#define IDirectDrawSurface7_GetCaps(p,b)                 (p)->lpVtbl->GetCaps(p,b)
#define IDirectDrawSurface7_GetClipper(p,a)              (p)->lpVtbl->GetClipper(p,a)
#define IDirectDrawSurface7_GetColorKey(p,a,b)           (p)->lpVtbl->GetColorKey(p,a,b)
#define IDirectDrawSurface7_GetDC(p,a)                   (p)->lpVtbl->GetDC(p,a)
#define IDirectDrawSurface7_GetFlipStatus(p,a)           (p)->lpVtbl->GetFlipStatus(p,a)
#define IDirectDrawSurface7_GetOverlayPosition(p,a,b)    (p)->lpVtbl->GetOverlayPosition(p,a,b)
#define IDirectDrawSurface7_GetPalette(p,a)              (p)->lpVtbl->GetPalette(p,a)
#define IDirectDrawSurface7_GetPixelFormat(p,a)          (p)->lpVtbl->GetPixelFormat(p,a)
#define IDirectDrawSurface7_GetSurfaceDesc(p,a)          (p)->lpVtbl->GetSurfaceDesc(p,a)
#define IDirectDrawSurface7_Initialize(p,a,b)            (p)->lpVtbl->Initialize(p,a,b)
#define IDirectDrawSurface7_IsLost(p)                    (p)->lpVtbl->IsLost(p)
#define IDirectDrawSurface7_Lock(p,a,b,c,d)              (p)->lpVtbl->Lock(p,a,b,c,d)
#define IDirectDrawSurface7_ReleaseDC(p,a)               (p)->lpVtbl->ReleaseDC(p,a)
#define IDirectDrawSurface7_Restore(p)                   (p)->lpVtbl->Restore(p)
#define IDirectDrawSurface7_SetClipper(p,a)              (p)->lpVtbl->SetClipper(p,a)
#define IDirectDrawSurface7_SetColorKey(p,a,b)           (p)->lpVtbl->SetColorKey(p,a,b)
#define IDirectDrawSurface7_SetOverlayPosition(p,a,b)    (p)->lpVtbl->SetOverlayPosition(p,a,b)
#define IDirectDrawSurface7_SetPalette(p,a)              (p)->lpVtbl->SetPalette(p,a)
#define IDirectDrawSurface7_Unlock(p,b)                  (p)->lpVtbl->Unlock(p,b)
#define IDirectDrawSurface7_UpdateOverlay(p,a,b,c,d,e)   (p)->lpVtbl->UpdateOverlay(p,a,b,c,d,e)
#define IDirectDrawSurface7_UpdateOverlayDisplay(p,a)    (p)->lpVtbl->UpdateOverlayDisplay(p,a)
#define IDirectDrawSurface7_UpdateOverlayZOrder(p,a,b)   (p)->lpVtbl->UpdateOverlayZOrder(p,a,b)
#define IDirectDrawSurface7_GetDDInterface(p,a)          (p)->lpVtbl->GetDDInterface(p,a)
#define IDirectDrawSurface7_PageLock(p,a)                (p)->lpVtbl->PageLock(p,a)
#define IDirectDrawSurface7_PageUnlock(p,a)              (p)->lpVtbl->PageUnlock(p,a)
#define IDirectDrawSurface7_SetSurfaceDesc(p,a,b)        (p)->lpVtbl->SetSurfaceDesc(p,a,b)
#define IDirectDrawSurface7_SetPrivateData(p,a,b,c,d)    (p)->lpVtbl->SetPrivateData(p,a,b,c,d)
#define IDirectDrawSurface7_GetPrivateData(p,a,b,c)      (p)->lpVtbl->GetPrivateData(p,a,b,c)
#define IDirectDrawSurface7_FreePrivateData(p,a)         (p)->lpVtbl->FreePrivateData(p,a)
#define IDirectDrawSurface7_GetUniquenessValue(p, a)     (p)->lpVtbl->GetUniquenessValue(p, a)
#define IDirectDrawSurface7_ChangeUniquenessValue(p)     (p)->lpVtbl->ChangeUniquenessValue(p)
//@@BEGIN_MSINTERNAL
#ifdef POSTPONED2
#define IDirectDrawSurface7_AlphaBlt(p,a,b,c,d,e)        (p)->lpVtbl->AlphaBlt(p,a,b,c,d,e)
#define IDirectDrawSurface7_SetSpriteDisplayList(p,a,b,c,d,e)  (p)->lpVtbl->SetSpriteDisplayList(p,a,b,c,d,e)
#define IDirectDrawSurface7_Resize(p,a,b,c)              (p)->lpVtbl->Resize(p,a,b,c)
#endif //POSTPONED2
//@@END_MSINTERNAL
#define IDirectDrawSurface7_SetPriority(p,a)             (p)->lpVtbl->SetPriority(p,a)
#define IDirectDrawSurface7_GetPriority(p,a)             (p)->lpVtbl->GetPriority(p,a)
#define IDirectDrawSurface7_SetLOD(p,a)                  (p)->lpVtbl->SetLOD(p,a)
#define IDirectDrawSurface7_GetLOD(p,a)                  (p)->lpVtbl->GetLOD(p,a)
#else
#define IDirectDrawSurface7_QueryInterface(p,a,b)        (p)->QueryInterface(a,b)
#define IDirectDrawSurface7_AddRef(p)                    (p)->AddRef()
#define IDirectDrawSurface7_Release(p)                   (p)->Release()
#define IDirectDrawSurface7_AddAttachedSurface(p,a)      (p)->AddAttachedSurface(a)
#define IDirectDrawSurface7_AddOverlayDirtyRect(p,a)     (p)->AddOverlayDirtyRect(a)
#define IDirectDrawSurface7_Blt(p,a,b,c,d,e)             (p)->Blt(a,b,c,d,e)
#define IDirectDrawSurface7_BltBatch(p,a,b,c)            (p)->BltBatch(a,b,c)
#define IDirectDrawSurface7_BltFast(p,a,b,c,d,e)         (p)->BltFast(a,b,c,d,e)
#define IDirectDrawSurface7_DeleteAttachedSurface(p,a,b) (p)->DeleteAttachedSurface(a,b)
#define IDirectDrawSurface7_EnumAttachedSurfaces(p,a,b)  (p)->EnumAttachedSurfaces(a,b)
#define IDirectDrawSurface7_EnumOverlayZOrders(p,a,b,c)  (p)->EnumOverlayZOrders(a,b,c)
#define IDirectDrawSurface7_Flip(p,a,b)                  (p)->Flip(a,b)
#define IDirectDrawSurface7_GetAttachedSurface(p,a,b)    (p)->GetAttachedSurface(a,b)
#define IDirectDrawSurface7_GetBltStatus(p,a)            (p)->GetBltStatus(a)
#define IDirectDrawSurface7_GetCaps(p,b)                 (p)->GetCaps(b)
#define IDirectDrawSurface7_GetClipper(p,a)              (p)->GetClipper(a)
#define IDirectDrawSurface7_GetColorKey(p,a,b)           (p)->GetColorKey(a,b)
#define IDirectDrawSurface7_GetDC(p,a)                   (p)->GetDC(a)
#define IDirectDrawSurface7_GetFlipStatus(p,a)           (p)->GetFlipStatus(a)
#define IDirectDrawSurface7_GetOverlayPosition(p,a,b)    (p)->GetOverlayPosition(a,b)
#define IDirectDrawSurface7_GetPalette(p,a)              (p)->GetPalette(a)
#define IDirectDrawSurface7_GetPixelFormat(p,a)          (p)->GetPixelFormat(a)
#define IDirectDrawSurface7_GetSurfaceDesc(p,a)          (p)->GetSurfaceDesc(a)
#define IDirectDrawSurface7_Initialize(p,a,b)            (p)->Initialize(a,b)
#define IDirectDrawSurface7_IsLost(p)                    (p)->IsLost()
#define IDirectDrawSurface7_Lock(p,a,b,c,d)              (p)->Lock(a,b,c,d)
#define IDirectDrawSurface7_ReleaseDC(p,a)               (p)->ReleaseDC(a)
#define IDirectDrawSurface7_Restore(p)                   (p)->Restore()
#define IDirectDrawSurface7_SetClipper(p,a)              (p)->SetClipper(a)
#define IDirectDrawSurface7_SetColorKey(p,a,b)           (p)->SetColorKey(a,b)
#define IDirectDrawSurface7_SetOverlayPosition(p,a,b)    (p)->SetOverlayPosition(a,b)
#define IDirectDrawSurface7_SetPalette(p,a)              (p)->SetPalette(a)
#define IDirectDrawSurface7_Unlock(p,b)                  (p)->Unlock(b)
#define IDirectDrawSurface7_UpdateOverlay(p,a,b,c,d,e)   (p)->UpdateOverlay(a,b,c,d,e)
#define IDirectDrawSurface7_UpdateOverlayDisplay(p,a)    (p)->UpdateOverlayDisplay(a)
#define IDirectDrawSurface7_UpdateOverlayZOrder(p,a,b)   (p)->UpdateOverlayZOrder(a,b)
#define IDirectDrawSurface7_GetDDInterface(p,a)          (p)->GetDDInterface(a)
#define IDirectDrawSurface7_PageLock(p,a)                (p)->PageLock(a)
#define IDirectDrawSurface7_PageUnlock(p,a)              (p)->PageUnlock(a)
#define IDirectDrawSurface7_SetSurfaceDesc(p,a,b)        (p)->SetSurfaceDesc(a,b)
#define IDirectDrawSurface7_SetPrivateData(p,a,b,c,d)    (p)->SetPrivateData(a,b,c,d)
#define IDirectDrawSurface7_GetPrivateData(p,a,b,c)      (p)->GetPrivateData(a,b,c)
#define IDirectDrawSurface7_FreePrivateData(p,a)         (p)->FreePrivateData(a)
#define IDirectDrawSurface7_GetUniquenessValue(p, a)     (p)->GetUniquenessValue(a)
#define IDirectDrawSurface7_ChangeUniquenessValue(p)     (p)->ChangeUniquenessValue()
//@@BEGIN_MSINTERNAL
#ifdef POSTPONED2
#define IDirectDrawSurface7_AlphaBlt(p,a,b,c,d,e)        (p)->AlphaBlt(a,b,c,d,e)
#define IDirectDrawSurface7_SetSpriteDisplayList(p,a,b,c,d,e)  (p)->SetSpriteDisplayList(a,b,c,d,e)
#define IDirectDrawSurface7_Resize(p,a,b,c)              (p)->Resize(a,b,c)
#endif //POSTPONED2
//@@END_MSINTERNAL
#define IDirectDrawSurface7_SetPriority(p,a)             (p)->SetPriority(a)
#define IDirectDrawSurface7_GetPriority(p,a)             (p)->GetPriority(a)
#define IDirectDrawSurface7_SetLOD(p,a)                  (p)->SetLOD(a)
#define IDirectDrawSurface7_GetLOD(p,a)                  (p)->GetLOD(a)
#endif

//@@BEGIN_MSINTERNAL
/*
 * IDirectDrawOptSurface
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawOptSurface
DECLARE_INTERFACE_( IDirectDrawOptSurface, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawOptSurface methods ***/
    STDMETHOD(GetOptSurfaceDesc)(THIS_ LPDDOPTSURFACEDESC) PURE;
    STDMETHOD(LoadUnoptimizedSurf)(THIS_ LPDIRECTDRAWSURFACE4) PURE;
    STDMETHOD(CopyOptimizedSurf)(THIS_ LPDIRECTDRAWOPTSURFACE) PURE;
    STDMETHOD(Unoptimize)(THIS_ LPDDSURFACEDESC2, LPDIRECTDRAWSURFACE4, IUnknown FAR *) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawOptSurface_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawOptSurface_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawOptSurface_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawOptSurface_GetOptSurfaceDesc(p,a)   (p)->lpVtbl->GetOptSurfaceDesc(p,a)
#define IDirectDrawOptSurface_LoadUnoptimizedSurf(p,a) (p)->lpVtbl->LoadUnoptimizedSurf(p,a)
#define IDirectDrawOptSurface_CopyOptimizedSurf(p,a)   (p)->lpVtbl->CopyOptimizedSurf(p,a)
#define IDirectDrawOptSurface_Unoptimize(p,a,b)        (p)->lpVtbl->Unoptimize(p,a,b)
#else  //!defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawOptSurface_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
#define IDirectDrawOptSurface_AddRef(p)                (p)->AddRef()
#define IDirectDrawOptSurface_Release(p)               (p)->Release()
#define IDirectDrawOptSurface_GetOptSurfaceDesc(p,a)   (p)->GetOptSurfaceDesc(a)
#define IDirectDrawOptSurface_LoadUnoptimizedSurf(p,a) (p)->LoadUnoptimizedSurf(a)
#define IDirectDrawOptSurface_CopyOptimizedSurf(p,a)   (p)->CopyOptimizedSurf(p,a)
#define IDirectDrawOptSurface_Unoptimize(p,a,b)        (p)->Unoptimize(a,b)
#endif //!defined(__cplusplus) || defined(CINTERFACE)

#endif //defined( _WIN32 ) && !defined( _NO_COM )
//@@END_MSINTERNAL


/*
 * IDirectDrawColorControl
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawColorControl
DECLARE_INTERFACE_( IDirectDrawColorControl, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawColorControl methods ***/
    STDMETHOD(GetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
    STDMETHOD(SetColorControls)(THIS_ LPDDCOLORCONTROL) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawColorControl_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawColorControl_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawColorControl_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawColorControl_GetColorControls(p, a)   (p)->lpVtbl->GetColorControls(p, a)
#define IDirectDrawColorControl_SetColorControls(p, a)   (p)->lpVtbl->SetColorControls(p, a)
#else
#define IDirectDrawColorControl_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
#define IDirectDrawColorControl_AddRef(p)                (p)->AddRef()
#define IDirectDrawColorControl_Release(p)               (p)->Release()
#define IDirectDrawColorControl_GetColorControls(p, a)   (p)->GetColorControls(a)
#define IDirectDrawColorControl_SetColorControls(p, a)   (p)->SetColorControls(a)
#endif

#endif


/*
 * IDirectDrawGammaControl
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawGammaControl
DECLARE_INTERFACE_( IDirectDrawGammaControl, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawGammaControl methods ***/
    STDMETHOD(GetGammaRamp)(THIS_ DWORD, LPDDGAMMARAMP) PURE;
    STDMETHOD(SetGammaRamp)(THIS_ DWORD, LPDDGAMMARAMP) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IDirectDrawGammaControl_QueryInterface(p, a, b)  (p)->lpVtbl->QueryInterface(p, a, b)
#define IDirectDrawGammaControl_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IDirectDrawGammaControl_Release(p)               (p)->lpVtbl->Release(p)
#define IDirectDrawGammaControl_GetGammaRamp(p, a, b)    (p)->lpVtbl->GetGammaRamp(p, a, b)
#define IDirectDrawGammaControl_SetGammaRamp(p, a, b)    (p)->lpVtbl->SetGammaRamp(p, a, b)
#else
#define IDirectDrawGammaControl_QueryInterface(p, a, b)  (p)->QueryInterface(a, b)
#define IDirectDrawGammaControl_AddRef(p)                (p)->AddRef()
#define IDirectDrawGammaControl_Release(p)               (p)->Release()
#define IDirectDrawGammaControl_GetGammaRamp(p, a, b)    (p)->GetGammaRamp(a, b)
#define IDirectDrawGammaControl_SetGammaRamp(p, a, b)    (p)->SetGammaRamp(a, b)
#endif

#endif


//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
#undef INTERFACE
#define INTERFACE IDirectDrawSurfaceComposition
DECLARE_INTERFACE_( IDirectDrawSurfaceComposition, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurfaceComposition methods ***/
    STDMETHOD(AddSurfaceDependency)(THIS_ LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(Compose)(THIS_ LPRECT,LPDIRECTDRAWSURFACE,LPRECT,DWORD,LPDDCOMPOSEFX) PURE;
    STDMETHOD(DeleteSurfaceDependency)(THIS_ DWORD,LPDIRECTDRAWSURFACE) PURE;
    STDMETHOD(DestLock)(THIS) PURE;
    STDMETHOD(DestUnlock)(THIS) PURE;
    STDMETHOD(EnumSurfaceDependencies)(THIS_ LPVOID,LPDDENUMSURFACESCALLBACK) PURE;
    STDMETHOD(GetCompositionOrder)(THIS_ LPDWORD) PURE;
    STDMETHOD(SetCompositionOrder)(THIS_ DWORD) PURE;
};
#endif

#ifdef STREAMING
#undef INTERFACE
#define INTERFACE IDirectDrawSurfaceStreaming
DECLARE_INTERFACE_( IDirectDrawSurfaceStreaming, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirectDrawSurfaceStreaming methods ***/
    STDMETHOD(Lock)(THIS_ LPRECT,LPDDSURFACEDESC,DWORD,HANDLE) PURE;
    STDMETHOD(SetNotificationCallback)(THIS_ DWORD,LPSURFACESTREAMINGCALLBACK) PURE;
    STDMETHOD(Unlock)(THIS_ LPVOID) PURE;
};
#endif
//@@END_MSINTERNAL

#endif

//@@BEGIN_MSINTERNAL
#ifdef CLIPPER_NOTIFY
/*
 * DIRECTDRAWCLIPPER FLAGS
 */
#define DDCLIPPER_WATCHWINDOW   0x00000001l
#endif
//@@END_MSINTERNAL

/*
 * DDSURFACEDESC
 */
typedef struct _DDSURFACEDESC
{
    DWORD               dwSize;                 // size of the DDSURFACEDESC structure
    DWORD               dwFlags;                // determines what fields are valid
    DWORD               dwHeight;               // height of surface to be created
    DWORD               dwWidth;                // width of input surface
    union
    {
        LONG            lPitch;                 // distance to start of next line (return value only)
        DWORD           dwLinearSize;           // Formless late-allocated optimized surface size
    } DUMMYUNIONNAMEN(1);
    DWORD               dwBackBufferCount;      // number of back buffers requested
    union
    {
        DWORD           dwMipMapCount;          // number of mip-map levels requested
        DWORD           dwZBufferBitDepth;      // depth of Z buffer requested
        DWORD           dwRefreshRate;          // refresh rate (used when display mode is described)
    } DUMMYUNIONNAMEN(2);
    DWORD               dwAlphaBitDepth;        // depth of alpha buffer requested
//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
    DWORD               dwCompositionOrder;     // blt order for the surface, 0 is background
#else
//@@END_MSINTERNAL
    DWORD               dwReserved;             // reserved
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL
    LPVOID              lpSurface;              // pointer to the associated surface memory
    DDCOLORKEY          ddckCKDestOverlay;      // color key for destination overlay use
    DDCOLORKEY          ddckCKDestBlt;          // color key for destination blt use
    DDCOLORKEY          ddckCKSrcOverlay;       // color key for source overlay use
    DDCOLORKEY          ddckCKSrcBlt;           // color key for source blt use
    DDPIXELFORMAT       ddpfPixelFormat;        // pixel format description of the surface
    DDSCAPS             ddsCaps;                // direct draw surface capabilities
} DDSURFACEDESC;

/*
 * DDSURFACEDESC2
 */
typedef struct _DDSURFACEDESC2
{
    DWORD               dwSize;                 // size of the DDSURFACEDESC structure
    DWORD               dwFlags;                // determines what fields are valid
    DWORD               dwHeight;               // height of surface to be created
    DWORD               dwWidth;                // width of input surface
    union
    {
        LONG            lPitch;                 // distance to start of next line (return value only)
        DWORD           dwLinearSize;           // Formless late-allocated optimized surface size
    } DUMMYUNIONNAMEN(1);
    union
    {
        DWORD           dwBackBufferCount;      // number of back buffers requested
        DWORD           dwDepth;                // the depth if this is a volume texture 
    } DUMMYUNIONNAMEN(5);
    union
    {
        DWORD           dwMipMapCount;          // number of mip-map levels requestde
                                                // dwZBufferBitDepth removed, use ddpfPixelFormat one instead
        DWORD           dwRefreshRate;          // refresh rate (used when display mode is described)
        DWORD           dwSrcVBHandle;          // The source used in VB::Optimize
    } DUMMYUNIONNAMEN(2);
    DWORD               dwAlphaBitDepth;        // depth of alpha buffer requested
//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
    DWORD               dwCompositionOrder;     // blt order for the surface, 0 is background
#else
//@@END_MSINTERNAL
    DWORD               dwReserved;             // reserved
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL
    LPVOID              lpSurface;              // pointer to the associated surface memory
    union
    {
        DDCOLORKEY      ddckCKDestOverlay;      // color key for destination overlay use
        DWORD           dwEmptyFaceColor;       // Physical color for empty cubemap faces
    } DUMMYUNIONNAMEN(3);
    DDCOLORKEY          ddckCKDestBlt;          // color key for destination blt use
    DDCOLORKEY          ddckCKSrcOverlay;       // color key for source overlay use
    DDCOLORKEY          ddckCKSrcBlt;           // color key for source blt use
    union
    {
        DDPIXELFORMAT   ddpfPixelFormat;        // pixel format description of the surface
        DWORD           dwFVF;                  // vertex format description of vertex buffers
    } DUMMYUNIONNAMEN(4);
    DDSCAPS2            ddsCaps;                // direct draw surface capabilities
    DWORD               dwTextureStage;         // stage in multitexture cascade
} DDSURFACEDESC2;

/*
 * ddsCaps field is valid.
 */
#define DDSD_CAPS               0x00000001l     // default

/*
 * dwHeight field is valid.
 */
#define DDSD_HEIGHT             0x00000002l

/*
 * dwWidth field is valid.
 */
#define DDSD_WIDTH              0x00000004l

/*
 * lPitch is valid.
 */
#define DDSD_PITCH              0x00000008l

/*
 * dwBackBufferCount is valid.
 */
#define DDSD_BACKBUFFERCOUNT    0x00000020l

/*
 * dwZBufferBitDepth is valid.  (shouldnt be used in DDSURFACEDESC2)
 */
#define DDSD_ZBUFFERBITDEPTH    0x00000040l

/*
 * dwAlphaBitDepth is valid.
 */
#define DDSD_ALPHABITDEPTH      0x00000080l

//@@BEGIN_MSINTERNAL
#ifdef COMPOSITION
/*
 * dwCompositionOrder is valid.
 */
#define DDSD_COMPOSITIONORDER   0x00000100l
#endif
//@@END_MSINTERNAL

/*
 * lpSurface is valid.
 */
#define DDSD_LPSURFACE          0x00000800l

/*
 * ddpfPixelFormat is valid.
 */
#define DDSD_PIXELFORMAT        0x00001000l

/*
 * ddckCKDestOverlay is valid.
 */
#define DDSD_CKDESTOVERLAY      0x00002000l

/*
 * ddckCKDestBlt is valid.
 */
#define DDSD_CKDESTBLT          0x00004000l

/*
 * ddckCKSrcOverlay is valid.
 */
#define DDSD_CKSRCOVERLAY       0x00008000l

/*
 * ddckCKSrcBlt is valid.
 */
#define DDSD_CKSRCBLT           0x00010000l

/*
 * dwMipMapCount is valid.
 */
#define DDSD_MIPMAPCOUNT        0x00020000l

 /*
  * dwRefreshRate is valid
  */
#define DDSD_REFRESHRATE        0x00040000l

/*
 * dwLinearSize is valid
 */
#define DDSD_LINEARSIZE         0x00080000l

/*
 * dwTextureStage is valid
 */
#define DDSD_TEXTURESTAGE       0x00100000l
/*
 * dwFVF is valid
 */
#define DDSD_FVF                0x00200000l
/*
 * dwSrcVBHandle is valid
 */
#define DDSD_SRCVBHANDLE        0x00400000l

/*
 * dwDepth is valid
 */
#define DDSD_DEPTH              0x00800000l

/*
 * All input fields are valid.
 */
#define DDSD_ALL                0x00fff9eel

/*
 * DDOPTSURFACEDESC
 */
typedef struct _DDOPTSURFACEDESC
{
    DWORD       dwSize;             // size of the DDOPTSURFACEDESC structure
    DWORD       dwFlags;            // determines what fields are valid
    DDSCAPS2    ddSCaps;            // Common caps like: Memory type
    DDOSCAPS    ddOSCaps;           // Common caps like: Memory type
    GUID        guid;               // Compression technique GUID
    DWORD       dwCompressionRatio; // Compression ratio
} DDOPTSURFACEDESC;

/*
 * guid field is valid.
 */
#define DDOSD_GUID                  0x00000001l

/*
 * dwCompressionRatio field is valid.
 */
#define DDOSD_COMPRESSION_RATIO     0x00000002l

/*
 * ddSCaps field is valid.
 */
#define DDOSD_SCAPS                 0x00000004l

/*
 * ddOSCaps field is valid.
 */
#define DDOSD_OSCAPS                0x00000008l

/*
 * All input fields are valid.
 */
#define DDOSD_ALL                   0x0000000fl

/*
 * The surface's optimized pixelformat is compressed
 */
#define DDOSDCAPS_OPTCOMPRESSED                 0x00000001l

/*
 * The surface's optimized pixelformat is reordered
 */
#define DDOSDCAPS_OPTREORDERED                  0x00000002l

/*
 * The opt surface is a monolithic mipmap
 */
#define DDOSDCAPS_MONOLITHICMIPMAP              0x00000004l

/*
 * The valid Surf caps:
 * #define DDSCAPS_SYSTEMMEMORY                 0x00000800l
 * #define DDSCAPS_VIDEOMEMORY          0x00004000l
 * #define DDSCAPS_LOCALVIDMEM          0x10000000l
 * #define DDSCAPS_NONLOCALVIDMEM       0x20000000l
 */
#define DDOSDCAPS_VALIDSCAPS            0x30004800l

/*
 * The valid OptSurf caps
 */
#define DDOSDCAPS_VALIDOSCAPS           0x00000007l


/*
 * DDCOLORCONTROL
 */
typedef struct _DDCOLORCONTROL
{
    DWORD               dwSize;
    DWORD               dwFlags;
    LONG                lBrightness;
    LONG                lContrast;
    LONG                lHue;
    LONG                lSaturation;
    LONG                lSharpness;
    LONG                lGamma;
    LONG                lColorEnable;
    DWORD               dwReserved1;
} DDCOLORCONTROL;


/*
 * lBrightness field is valid.
 */
#define DDCOLOR_BRIGHTNESS              0x00000001l

/*
 * lContrast field is valid.
 */
#define DDCOLOR_CONTRAST                0x00000002l

/*
 * lHue field is valid.
 */
#define DDCOLOR_HUE                     0x00000004l

/*
 * lSaturation field is valid.
 */
#define DDCOLOR_SATURATION              0x00000008l

/*
 * lSharpness field is valid.
 */
#define DDCOLOR_SHARPNESS               0x00000010l

/*
 * lGamma field is valid.
 */
#define DDCOLOR_GAMMA                   0x00000020l

/*
 * lColorEnable field is valid.
 */
#define DDCOLOR_COLORENABLE             0x00000040l


//@@BEGIN_MSINTERNAL
/*
 * DDMODEDESC
 */
typedef struct _DDMODEDESC
{
    DWORD               dwSize;                 // size of structure
    DWORD               dwFlags;                // enumeration flags
    DWORD               dwMonitorFrequency;     // frequency of monitor in mode
    DDSURFACEDESC       ddsdSurfaceDesc;        // surface being enumerated
} DDMODEDESC;

typedef DDMODEDESC FAR* LPDDMODEDESC;
//@@END_MSINTERNAL

/*============================================================================
 *
 * Direct Draw Capability Flags
 *
 * These flags are used to describe the capabilities of a given Surface.
 * All flags are bit flags.
 *
 *==========================================================================*/

/****************************************************************************
 *
 * DIRECTDRAWSURFACE CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * This bit is reserved. It should not be specified.
 */
//@@BEGIN_MSINTERNAL
/*
 * In a previous life this bit used to be DDSCAPS_3D. This is now very
 * obsolete.
 */
//@@END_MSINTERNAL
#define DDSCAPS_RESERVED1                       0x00000001l

/*
 * Indicates that this surface contains alpha-only information.
 * (To determine if a surface is RGBA/YUVA, the pixel format must be
 * interrogated.)
 */
#define DDSCAPS_ALPHA                           0x00000002l

/*
 * Indicates that this surface is a backbuffer.  It is generally
 * set by CreateSurface when the DDSCAPS_FLIP capability bit is set.
 * It indicates that this surface is THE back buffer of a surface
 * flipping structure.  DirectDraw supports N surfaces in a
 * surface flipping structure.  Only the surface that immediately
 * precedeces the DDSCAPS_FRONTBUFFER has this capability bit set.
 * The other surfaces are identified as back buffers by the presence
 * of the DDSCAPS_FLIP capability, their attachment order, and the
 * absence of the DDSCAPS_FRONTBUFFER and DDSCAPS_BACKBUFFER
 * capabilities.  The bit is sent to CreateSurface when a standalone
 * back buffer is being created.  This surface could be attached to
 * a front buffer and/or back buffers to form a flipping surface
 * structure after the CreateSurface call.  See AddAttachments for
 * a detailed description of the behaviors in this case.
 */
#define DDSCAPS_BACKBUFFER                      0x00000004l

/*
 * Indicates a complex surface structure is being described.  A
 * complex surface structure results in the creation of more than
 * one surface.  The additional surfaces are attached to the root
 * surface.  The complex structure can only be destroyed by
 * destroying the root.
 */
#define DDSCAPS_COMPLEX                         0x00000008l

/*
 * Indicates that this surface is a part of a surface flipping structure.
 * When it is passed to CreateSurface the DDSCAPS_FRONTBUFFER and
 * DDSCAP_BACKBUFFER bits are not set.  They are set by CreateSurface
 * on the resulting creations.  The dwBackBufferCount field in the
 * DDSURFACEDESC structure must be set to at least 1 in order for
 * the CreateSurface call to succeed.  The DDSCAPS_COMPLEX capability
 * must always be set with creating multiple surfaces through CreateSurface.
 */
#define DDSCAPS_FLIP                            0x00000010l

/*
 * Indicates that this surface is THE front buffer of a surface flipping
 * structure.  It is generally set by CreateSurface when the DDSCAPS_FLIP
 * capability bit is set.
 * If this capability is sent to CreateSurface then a standalonw front buffer
 * is created.  This surface will not have the DDSCAPS_FLIP capability.
 * It can be attached to other back buffers to form a flipping structure.
 * See AddAttachments for a detailed description of the behaviors in this
 * case.
 */
#define DDSCAPS_FRONTBUFFER                     0x00000020l

/*
 * Indicates that this surface is any offscreen surface that is not an overlay,
 * texture, zbuffer, front buffer, back buffer, or alpha surface.  It is used
 * to identify plain vanilla surfaces.
 */
#define DDSCAPS_OFFSCREENPLAIN                  0x00000040l

/*
 * Indicates that this surface is an overlay.  It may or may not be directly visible
 * depending on whether or not it is currently being overlayed onto the primary
 * surface.  DDSCAPS_VISIBLE can be used to determine whether or not it is being
 * overlayed at the moment.
 */
#define DDSCAPS_OVERLAY                         0x00000080l

/*
 * Indicates that unique DirectDrawPalette objects can be created and
 * attached to this surface.
 */
#define DDSCAPS_PALETTE                         0x00000100l

/*
 * Indicates that this surface is the primary surface.  The primary
 * surface represents what the user is seeing at the moment.
 */
#define DDSCAPS_PRIMARYSURFACE                  0x00000200l

//@@BEGIN_MSINTERNAL
/*
 * Indicates that this surface is the primary surface for the left eye.
 * The primary surface for the left eye represents what the user is seeing
 * at the moment with the users left eye.  When this surface is created the
 * DDSCAPS_PRIMARYSURFACE represents what the user is seeing with the users
 * right eye.
 */
#define DDSCAPS_PRIMARYSURFACELEFT              0x00000400l
//the zero-def'n is just to fix build issues... could be deleted when all dependencies are deleted (gdi kdexts may be only one)
//@@END_MSINTERNAL

/*
 * This flag used to be DDSCAPS_PRIMARYSURFACELEFT, which is now
 * obsolete.
 */
#define DDSCAPS_RESERVED3               0x00000400l
//@@BEGIN_MSINTERNAL
#if 0
//@@END_MSINTERNAL
#define DDSCAPS_PRIMARYSURFACELEFT              0x00000000l
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL

/*
 * Indicates that this surface memory was allocated in system memory
 */
#define DDSCAPS_SYSTEMMEMORY                    0x00000800l

/*
 * Indicates that this surface can be used as a 3D texture.  It does not
 * indicate whether or not the surface is being used for that purpose.
 */
#define DDSCAPS_TEXTURE                         0x00001000l

/*
 * Indicates that a surface may be a destination for 3D rendering.  This
 * bit must be set in order to query for a Direct3D Device Interface
 * from this surface.
 */
#define DDSCAPS_3DDEVICE                        0x00002000l

/*
 * Indicates that this surface exists in video memory.
 */
#define DDSCAPS_VIDEOMEMORY                     0x00004000l

/*
 * Indicates that changes made to this surface are immediately visible.
 * It is always set for the primary surface and is set for overlays while
 * they are being overlayed and texture maps while they are being textured.
 */
#define DDSCAPS_VISIBLE                         0x00008000l

/*
 * Indicates that only writes are permitted to the surface.  Read accesses
 * from the surface may or may not generate a protection fault, but the
 * results of a read from this surface will not be meaningful.  READ ONLY.
 */
#define DDSCAPS_WRITEONLY                       0x00010000l

/*
 * Indicates that this surface is a z buffer. A z buffer does not contain
 * displayable information.  Instead it contains bit depth information that is
 * used to determine which pixels are visible and which are obscured.
 */
#define DDSCAPS_ZBUFFER                         0x00020000l

/*
 * Indicates surface will have a DC associated long term
 */
#define DDSCAPS_OWNDC                           0x00040000l

/*
 * Indicates surface should be able to receive live video
 */
#define DDSCAPS_LIVEVIDEO                       0x00080000l

/*
 * Indicates surface should be able to have a stream decompressed
 * to it by the hardware.
 */
#define DDSCAPS_HWCODEC                         0x00100000l

/*
 * Surface is a ModeX surface.
 *
 */
#define DDSCAPS_MODEX                           0x00200000l

/*
 * Indicates surface is one level of a mip-map. This surface will
 * be attached to other DDSCAPS_MIPMAP surfaces to form the mip-map.
 * This can be done explicitly, by creating a number of surfaces and
 * attaching them with AddAttachedSurface or by implicitly by CreateSurface.
 * If this bit is set then DDSCAPS_TEXTURE must also be set.
 */
#define DDSCAPS_MIPMAP                          0x00400000l

/*
 * This bit is reserved. It should not be specified.
 */
//@@BEGIN_MSINTERNAL
/*
 * This bit is reserved for execute buffer surfaces. These surface are not
 * API visible and so this bit shows as reserved externally. However, driver
 * writers do need this bit so the correct definition of DDSCAPS_EXECUTEBUFFER
 * appears in ddraw.h.
 *
 * NOTE: Do not reassign this bit to a new surface capability. It is assigned
 * to an in-use cap: DDSCAPS_EXECUTEBUFFER
 */
//@@END_MSINTERNAL
#define DDSCAPS_RESERVED2                       0x00800000l

//@@BEGIN_MSINTERNAL
#ifdef SHAREDZ

/*
 * Indicates that this Z buffer surface can be shared with other DirectDraw
 * applications. This does not necessarily mean that this surface is
 * currently being shared with other processes but only that it can be. If
 * this bit is set then DDSCAPS_ZBUFFER must also be set.
 */
#define DDSCAPS_SHAREDZBUFFER                   0x01000000l

/*
 * Indicates that this backbuffer surface can be shared with other DirectDraw
 * applications. This does not necessarily mean that this surface is
 * currently being shared with other processes but only that it can be. If
 * this bit is set than DDSCAPS_BACKBUFFER must also be set (it may also be
 * set if a backbuffer is being created implicitly with as past of a complex
 * flippable chain).
 */
#define DDSCAPS_SHAREDBACKBUFFER                0x02000000l

#endif
//@@END_MSINTERNAL

/*
 * Indicates that memory for the surface is not allocated until the surface
 * is loaded (via the Direct3D texture Load() function).
 */
#define DDSCAPS_ALLOCONLOAD                     0x04000000l

/*
 * Indicates that the surface will recieve data from a video port.
 */
#define DDSCAPS_VIDEOPORT                       0x08000000l

/*
 * Indicates that a video memory surface is resident in true, local video
 * memory rather than non-local video memory. If this flag is specified then
 * so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
 * DDSCAPS_NONLOCALVIDMEM.
 */
#define DDSCAPS_LOCALVIDMEM                     0x10000000l

/*
 * Indicates that a video memory surface is resident in non-local video
 * memory rather than true, local video memory. If this flag is specified
 * then so must DDSCAPS_VIDEOMEMORY. This flag is mutually exclusive with
 * DDSCAPS_LOCALVIDMEM.
 */
#define DDSCAPS_NONLOCALVIDMEM                  0x20000000l

/*
 * Indicates that this surface is a standard VGA mode surface, and not a
 * ModeX surface. (This flag will never be set in combination with the
 * DDSCAPS_MODEX flag).
 */
#define DDSCAPS_STANDARDVGAMODE                 0x40000000l

/*
 * Indicates that this surface will be an optimized surface. This flag is
 * currently only valid in conjunction with the DDSCAPS_TEXTURE flag. The surface
 * will be created without any underlying video memory until loaded.
 */
#define DDSCAPS_OPTIMIZED                       0x80000000l


//@@BEGIN_MSINTERNAL
#ifdef SHAREDZ
#define DDSCAPS_VALID                           0xffffffffl
#else
#define DDSCAPS_VALID                           0xfcffffffl
#endif
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
/*
 * Indicates that this surface will not lose its contents when the physical
 * surface memory is lost. Upon restoring surface memory, contents will be
 * restored.
 */
#define DDSCAPS2_PERSISTENTCONTENTS             0x00000001L
//@@END_MSINTERNAL

/*
 * This bit is reserved
 */
#define DDSCAPS2_RESERVED4                      0x00000002L
#define DDSCAPS2_HARDWAREDEINTERLACE            0x00000000L

/*
 * Indicates to the driver that this surface will be locked very frequently
 * (for procedural textures, dynamic lightmaps, etc). Surfaces with this cap
 * set must also have DDSCAPS_TEXTURE. This cap cannot be used with
 * DDSCAPS2_HINTSTATIC and DDSCAPS2_OPAQUE.
 */
#define DDSCAPS2_HINTDYNAMIC                    0x00000004L

/*
 * Indicates to the driver that this surface can be re-ordered/retiled on
 * load. This operation will not change the size of the texture. It is
 * relatively fast and symmetrical, since the application may lock these
 * bits (although it will take a performance hit when doing so). Surfaces
 * with this cap set must also have DDSCAPS_TEXTURE. This cap cannot be
 * used with DDSCAPS2_HINTDYNAMIC and DDSCAPS2_OPAQUE.
 */
#define DDSCAPS2_HINTSTATIC                     0x00000008L

/*
 * Indicates that the client would like this texture surface to be managed by the
 * DirectDraw/Direct3D runtime. Surfaces with this cap set must also have
 * DDSCAPS_TEXTURE set.
 */
#define DDSCAPS2_TEXTUREMANAGE                  0x00000010L

/*
 * These bits are reserved for internal use */
#define DDSCAPS2_RESERVED1                      0x00000020L
#define DDSCAPS2_RESERVED2                      0x00000040L

/*
 * Indicates to the driver that this surface will never be locked again.
 * The driver is free to optimize this surface via retiling and actual compression.
 * All calls to Lock() or Blts from this surface will fail. Surfaces with this
 * cap set must also have DDSCAPS_TEXTURE. This cap cannot be used with
 * DDSCAPS2_HINTDYNAMIC and DDSCAPS2_HINTSTATIC.
 */
#define DDSCAPS2_OPAQUE                         0x00000080L

/*
 * Applications should set this bit at CreateSurface time to indicate that they
 * intend to use antialiasing. Only valid if DDSCAPS_3DDEVICE is also set.
 */
#define DDSCAPS2_HINTANTIALIASING               0x00000100L


/*
 * This flag is used at CreateSurface time to indicate that this set of
 * surfaces is a cubic environment map
 */
#define DDSCAPS2_CUBEMAP                        0x00000200L

/*
 * These flags preform two functions:
 * - At CreateSurface time, they define which of the six cube faces are
 *   required by the application.
 * - After creation, each face in the cubemap will have exactly one of these
 *   bits set.
 */
#define DDSCAPS2_CUBEMAP_POSITIVEX              0x00000400L
#define DDSCAPS2_CUBEMAP_NEGATIVEX              0x00000800L
#define DDSCAPS2_CUBEMAP_POSITIVEY              0x00001000L
#define DDSCAPS2_CUBEMAP_NEGATIVEY              0x00002000L
#define DDSCAPS2_CUBEMAP_POSITIVEZ              0x00004000L
#define DDSCAPS2_CUBEMAP_NEGATIVEZ              0x00008000L

/*
 * This macro may be used to specify all faces of a cube map at CreateSurface time
 */
#define DDSCAPS2_CUBEMAP_ALLFACES ( DDSCAPS2_CUBEMAP_POSITIVEX |\
                                    DDSCAPS2_CUBEMAP_NEGATIVEX |\
                                    DDSCAPS2_CUBEMAP_POSITIVEY |\
                                    DDSCAPS2_CUBEMAP_NEGATIVEY |\
                                    DDSCAPS2_CUBEMAP_POSITIVEZ |\
                                    DDSCAPS2_CUBEMAP_NEGATIVEZ )


/*
 * This flag is an additional flag which is present on mipmap sublevels from DX7 onwards
 * It enables easier use of GetAttachedSurface rather than EnumAttachedSurfaces for surface
 * constructs such as Cube Maps, wherein there are more than one mipmap surface attached
 * to the root surface.
 * This caps bit is ignored by CreateSurface
 */
#define DDSCAPS2_MIPMAPSUBLEVEL                 0x00010000L

/* This flag indicates that the texture should be managed by D3D only */
#define DDSCAPS2_D3DTEXTUREMANAGE               0x00020000L

/* This flag indicates that the managed surface can be safely lost */
#define DDSCAPS2_DONOTPERSIST                   0x00040000L

/* indicates that this surface is part of a stereo flipping chain */
#define DDSCAPS2_STEREOSURFACELEFT              0x00080000L

//@@BEGIN_MSINTERNAL
/* Used to indicate that the texture manager is creating a videomemory
 * surface that shouldn't have an associated D3D texture object.
 */
#define DDSCAPS2_DONOTCREATED3DTEXOBJECT        0x00100000L
//@@END_MSINTERNAL

/*
 * Indicates that the surface is a volume.
 * Can be combined with DDSCAPS_MIPMAP to indicate a multi-level volume
 */
#define DDSCAPS2_VOLUME                         0x00200000L

/*
 * Indicates that the surface may be locked multiple times by the application.
 * This cap cannot be used with DDSCAPS2_OPAQUE.
 */
#define DDSCAPS2_NOTUSERLOCKABLE                0x00400000L

/*
 * Indicates that the vertex buffer data can be used to render points and
 * point sprites.
 */
#define DDSCAPS2_POINTS                         0x00800000L

/*
 * Indicates that the vertex buffer data can be used to render rt pactches.
 */
#define DDSCAPS2_RTPATCHES                      0x01000000L

/*
 * Indicates that the vertex buffer data can be used to render n patches.
 */
#define DDSCAPS2_NPATCHES                       0x02000000L

/*
 * This bit is reserved for internal use 
 */
#define DDSCAPS2_RESERVED3                      0x04000000L

//@@BEGIN_MSINTERNAL
/*
 * Indicates that the surface contains interlaced data that should be
 * deinterlaced when displayed.
 */
#define DDSCAPS2_DEINTERLACE                    0x08000000L
//@@END_MSINTERNAL

/*
 * Indicates that the contents of the backbuffer do not have to be preserved
 * the contents of the backbuffer after they are presented.
 */
#define DDSCAPS2_DISCARDBACKBUFFER              0x10000000L

/*
 * Indicates that all surfaces in this creation chain should be given an alpha channel.
 * This flag will be set on primary surface chains that may have no explicit pixel format
 * (and thus take on the format of the current display mode).
 * The driver should infer that all these surfaces have a format having an alpha channel.
 * (e.g. assume D3DFMT_A8R8G8B8 if the display mode is x888.)
 */
#define DDSCAPS2_ENABLEALPHACHANNEL             0x20000000L


/*
 * This is a mask that indicates the set of bits that may be set
 * at createsurface time to indicate number of samples per pixel
 * when multisampling
 */
#define DDSCAPS3_MULTISAMPLE_MASK               0x0000001FL

//@@BEGIN_MSINTERNAL
#define DDSCAPS2_VALID                          0x3ffffffeL
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#define DDSCAPS3_VALID                          DDSCAPS3_MULTISAMPLE_MASK
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#define DDSCAPS4_VALID                          0x00000000L
//@@END_MSINTERNAL

 /****************************************************************************
 *
 * DIRECTDRAW DRIVER CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Display hardware has 3D acceleration.
 */
#define DDCAPS_3D                       0x00000001l

/*
 * Indicates that DirectDraw will support only dest rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundaryDest boundaries of the surface, respectively.
 * READ ONLY.
 */
#define DDCAPS_ALIGNBOUNDARYDEST        0x00000002l

/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeDest multiples, respectively.  READ ONLY.
 */
#define DDCAPS_ALIGNSIZEDEST            0x00000004l
/*
 * Indicates that DirectDraw will support only source rectangles that are aligned
 * on DIRECTDRAWCAPS.dwAlignBoundarySrc boundaries of the surface, respectively.
 * READ ONLY.
 */
#define DDCAPS_ALIGNBOUNDARYSRC         0x00000008l

/*
 * Indicates that DirectDraw will support only source rectangles  whose sizes in
 * BYTEs are DIRECTDRAWCAPS.dwAlignSizeSrc multiples, respectively.  READ ONLY.
 */
#define DDCAPS_ALIGNSIZESRC             0x00000010l

/*
 * Indicates that DirectDraw will create video memory surfaces that have a stride
 * alignment equal to DIRECTDRAWCAPS.dwAlignStride.  READ ONLY.
 */
#define DDCAPS_ALIGNSTRIDE              0x00000020l

/*
 * Display hardware is capable of blt operations.
 */
#define DDCAPS_BLT                      0x00000040l

/*
 * Display hardware is capable of asynchronous blt operations.
 */
#define DDCAPS_BLTQUEUE                 0x00000080l

/*
 * Display hardware is capable of color space conversions during the blt operation.
 */
#define DDCAPS_BLTFOURCC                0x00000100l

/*
 * Display hardware is capable of stretching during blt operations.
 */
#define DDCAPS_BLTSTRETCH               0x00000200l

/*
 * Display hardware is shared with GDI.
 */
#define DDCAPS_GDI                      0x00000400l

/*
 * Display hardware can overlay.
 */
#define DDCAPS_OVERLAY                  0x00000800l

/*
 * Set if display hardware supports overlays but can not clip them.
 */
#define DDCAPS_OVERLAYCANTCLIP          0x00001000l

/*
 * Indicates that overlay hardware is capable of color space conversions during
 * the overlay operation.
 */
#define DDCAPS_OVERLAYFOURCC            0x00002000l

/*
 * Indicates that stretching can be done by the overlay hardware.
 */
#define DDCAPS_OVERLAYSTRETCH           0x00004000l

/*
 * Indicates that unique DirectDrawPalettes can be created for DirectDrawSurfaces
 * other than the primary surface.
 */
#define DDCAPS_PALETTE                  0x00008000l

/*
 * Indicates that palette changes can be syncd with the veritcal refresh.
 */
#define DDCAPS_PALETTEVSYNC             0x00010000l

/*
 * Display hardware can return the current scan line.
 */
#define DDCAPS_READSCANLINE             0x00020000l

//@@BEGIN_MSINTERNAL
/*
 * Display hardware has stereo vision capabilities.  DDSCAPS_PRIMARYSURFACELEFT
 * can be created.
 */
#define DDCAPS_STEREOVIEW               0x00040000l
//@@END_MSINTERNAL

/*
 * This flag used to bo DDCAPS_STEREOVIEW, which is now obsolete
 */
#define DDCAPS_RESERVED1                0x00040000l

/*
 * Display hardware is capable of generating a vertical blank interrupt.
 */
#define DDCAPS_VBI                      0x00080000l

/*
 * Supports the use of z buffers with blt operations.
 */
#define DDCAPS_ZBLTS                    0x00100000l

/*
 * Supports Z Ordering of overlays.
 */
#define DDCAPS_ZOVERLAYS                0x00200000l

/*
 * Supports color key
 */
#define DDCAPS_COLORKEY                 0x00400000l

/*
 * Supports alpha surfaces
 */
#define DDCAPS_ALPHA                    0x00800000l

/*
 * colorkey is hardware assisted(DDCAPS_COLORKEY will also be set)
 */
#define DDCAPS_COLORKEYHWASSIST         0x01000000l

/*
 * no hardware support at all
 */
#define DDCAPS_NOHARDWARE               0x02000000l

/*
 * Display hardware is capable of color fill with bltter
 */
#define DDCAPS_BLTCOLORFILL             0x04000000l

/*
 * Display hardware is bank switched, and potentially very slow at
 * random access to VRAM.
 */
#define DDCAPS_BANKSWITCHED             0x08000000l

/*
 * Display hardware is capable of depth filling Z-buffers with bltter
 */
#define DDCAPS_BLTDEPTHFILL             0x10000000l

/*
 * Display hardware is capable of clipping while bltting.
 */
#define DDCAPS_CANCLIP                  0x20000000l

/*
 * Display hardware is capable of clipping while stretch bltting.
 */
#define DDCAPS_CANCLIPSTRETCHED         0x40000000l

/*
 * Display hardware is capable of bltting to or from system memory
 */
#define DDCAPS_CANBLTSYSMEM             0x80000000l


 /****************************************************************************
 *
 * MORE DIRECTDRAW DRIVER CAPABILITY FLAGS (dwCaps2)
 *
 ****************************************************************************/

/*
 * Display hardware is certified
 */
#define DDCAPS2_CERTIFIED              0x00000001l

/*
 * Driver cannot interleave 2D operations (lock and blt) to surfaces with
 * Direct3D rendering operations between calls to BeginScene() and EndScene()
 */
#define DDCAPS2_NO2DDURING3DSCENE       0x00000002l

/*
 * Display hardware contains a video port
 */
#define DDCAPS2_VIDEOPORT               0x00000004l

/*
 * The overlay can be automatically flipped according to the video port
 * VSYNCs, providing automatic doubled buffered display of video port
 * data using an overlay
 */
#define DDCAPS2_AUTOFLIPOVERLAY         0x00000008l

/*
 * Overlay can display each field of interlaced data individually while
 * it is interleaved in memory without causing jittery artifacts.
 */
#define DDCAPS2_CANBOBINTERLEAVED       0x00000010l

/*
 * Overlay can display each field of interlaced data individually while
 * it is not interleaved in memory without causing jittery artifacts.
 */
#define DDCAPS2_CANBOBNONINTERLEAVED    0x00000020l

/*
 * The overlay surface contains color controls (brightness, sharpness, etc.)
 */
#define DDCAPS2_COLORCONTROLOVERLAY     0x00000040l

/*
 * The primary surface contains color controls (gamma, etc.)
 */
#define DDCAPS2_COLORCONTROLPRIMARY     0x00000080l

/*
 * RGBZ -> RGB supported for 16:16 RGB:Z
 */
#define DDCAPS2_CANDROPZ16BIT           0x00000100l

/*
 * Driver supports non-local video memory.
 */
#define DDCAPS2_NONLOCALVIDMEM          0x00000200l

/*
 * Dirver supports non-local video memory but has different capabilities for
 * non-local video memory surfaces. If this bit is set then so must
 * DDCAPS2_NONLOCALVIDMEM.
 */
#define DDCAPS2_NONLOCALVIDMEMCAPS      0x00000400l

/*
 * Driver neither requires nor prefers surfaces to be pagelocked when performing
 * blts involving system memory surfaces
 */
#define DDCAPS2_NOPAGELOCKREQUIRED      0x00000800l

/*
 * Driver can create surfaces which are wider than the primary surface
 */
#define DDCAPS2_WIDESURFACES            0x00001000l

/*
 * Driver supports bob without using a video port by handling the
 * DDFLIP_ODD and DDFLIP_EVEN flags specified in Flip.
 */
#define DDCAPS2_CANFLIPODDEVEN          0x00002000l

/*
 * Driver supports bob using hardware
 */
#define DDCAPS2_CANBOBHARDWARE          0x00004000l

/*
 * Driver supports bltting any FOURCC surface to another surface of the same FOURCC
 */
#define DDCAPS2_COPYFOURCC              0x00008000l

//@@BEGIN_MSINTERNAL
/*
 * Driver supports optimized surfaces
 */
#define DDCAPS2_OPTIMIZEDSURFACES       0x00010000l
//@@END_MSINTERNAL

/*
 * Driver supports loadable gamma ramps for the primary surface
 */
#define DDCAPS2_PRIMARYGAMMA            0x00020000l
//@@BEGIN_MSINTERNAL
/*
 * This cap was meant to be used for driver managed textures, but they were broken
 * in DX 6.x. The cap was reintroduced in DX7 as 0x00800000l. However, 0x00040000l
 * cannot be reassigned to anything else since it causes bad things to happen in
 * the D3D 6.x runtime (snene 11/12/98).
 */
#define DDCAPS2_NEVERNEVERUSE           0x00040000l
//@@END_MSINTERNAL

/*
 * Driver can render in windowed mode.
 */
#define DDCAPS2_CANRENDERWINDOWED       0x00080000l

/*
 * A calibrator is available to adjust the gamma ramp according to the
 * physical display properties so that the result will be identical on
 * all calibrated systems.
 */
#define DDCAPS2_CANCALIBRATEGAMMA       0x00100000l

/*
 * Indicates that the driver will respond to DDFLIP_INTERVALn flags
 */
#define DDCAPS2_FLIPINTERVAL            0x00200000l

/*
 * Indicates that the driver will respond to DDFLIP_NOVSYNC
 */
#define DDCAPS2_FLIPNOVSYNC             0x00400000l

/*
 * Driver supports management of video memory, if this flag is ON,
 * driver manages the texture if requested with DDSCAPS2_TEXTUREMANAGE on
 * DirectX manages the texture if this flag is OFF and surface has DDSCAPS2_TEXTUREMANAGE on
 */
#define DDCAPS2_CANMANAGETEXTURE        0x00800000l

/*
 * The Direct3D texture manager uses this cap to decide whether to put managed
 * surfaces in non-local video memory. If the cap is set, the texture manager will
 * put managed surfaces in non-local vidmem. Drivers that cannot texture from
 * local vidmem SHOULD NOT set this cap.
 */
#define DDCAPS2_TEXMANINNONLOCALVIDMEM  0x01000000l

/*
 * Indicates that the driver supports DX7 type of stereo in at least one mode (which may
 * not necessarily be the current mode). Applications should use IDirectDraw7 (or higher)
 * ::EnumDisplayModes and check the DDSURFACEDESC.ddsCaps.dwCaps2 field for the presence of
 * DDSCAPS2_STEREOSURFACELEFT to check if a particular mode supports stereo. The application
 * can also use IDirectDraw7(or higher)::GetDisplayMode to check the current mode.
 */
#define DDCAPS2_STEREO                  0x02000000L

/*
 * This caps bit is intended for internal DirectDraw use.
 * -It is only valid if DDCAPS2_NONLOCALVIDMEMCAPS is set.
 * -If this bit is set, then DDCAPS_CANBLTSYSMEM MUST be set by the driver (and
 *  all the assoicated system memory blt caps must be correct).
 * -It implies that the system->video blt caps in DDCAPS also apply to system to
 *  nonlocal blts. I.e. the dwSVBCaps, dwSVBCKeyCaps, dwSVBFXCaps and dwSVBRops
 *  members of DDCAPS (DDCORECAPS) are filled in correctly.
 * -Any blt from system to nonlocal memory that matches these caps bits will
 *  be passed to the driver.
 *
 * NOTE: This is intended to enable the driver itself to do efficient reordering
 * of textures. This is NOT meant to imply that hardware can write into AGP memory.
 * This operation is not currently supported.
 */
#define DDCAPS2_SYSTONONLOCAL_AS_SYSTOLOCAL   0x04000000L

/*
 * was DDCAPS2_PUREHAL
 */
#define DDCAPS2_RESERVED1                     0x08000000L

/*
 * Driver supports management of video memory, if this flag is ON,
 * driver manages the resource if requested with DDSCAPS2_TEXTUREMANAGE on
 * DirectX manages the resource if this flag is OFF and surface has DDSCAPS2_TEXTUREMANAGE on
 */
#define DDCAPS2_CANMANAGERESOURCE             0x10000000L

/*
 * Driver supports dynamic textures. This will allow the application to set
 * D3DUSAGE_DYNAMIC (DDSCAPS2_HINTDYNAMIC for drivers) at texture create time.
 * Video memory dynamic textures WILL be lockable by applications. It is
 * expected that these locks will be very efficient (which implies that the
 * driver should always maintain a linear copy, a pointer to which can be
 * quickly handed out to the application).
 */
#define DDCAPS2_DYNAMICTEXTURES               0x20000000L

//@@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * DIRECTDRAW ALPHA CAPABILITY FLAGS (for DDCAPS members dwAlphaCaps,
 *   dwSVBAlphaCaps, dwVSBAlphaCaps, and dwSSBAlphaCaps)
 *
 ****************************************************************************/

/*
 * Driver supports blitting of surfaces that contain alpha information
 * in the pixel format.
 */
#define DDALPHACAPS_BLTALPHAPIXELS              0x00000001l

/*
 * Driver performs saturated arithmetic when alpha-blending for a blit.
 * This prevents the dest pixels' color components from overflowing.
 */
#define DDALPHACAPS_BLTSATURATE                 0x00000002l

/*
 * Driver can perform alpha blitting with pixels in premultiplied-
 * alpha format (color components stored in each pixel have been
 * premultiplied by the pixel's alpha component).
 */
#define DDALPHACAPS_BLTPREMULT                  0x00000004l

/*
 * Driver can perform alpha blitting with pixels in NON-premultiplied-
 * alpha format (color components NOT premultiplied by alpha component).
 */
#define DDALPHACAPS_BLTNONPREMULT               0x00000008l

/*
 * Driver can perform one-factor ARGB scaling of source pixels
 * during a blit.
 */
#define DDALPHACAPS_BLTARGBSCALE1F              0x00000010l

/*
 * Driver can perform two-factor ARGB scaling of source pixels
 * during a blit.
 */
#define DDALPHACAPS_BLTARGBSCALE2F              0x00000020l

/*
 * Driver can perform four-factor ARGB scaling of source pixels
 * during a blit.
 */
#define DDALPHACAPS_BLTARGBSCALE4F              0x00000040l

/*
 * Driver can do an alpha-blended color fill of a dest surface.
 */
#define DDALPHACAPS_BLTALPHAFILL                0x00000080l

/*
 * Driver can handle source alpha channel and ARGB scaling at the same time.
 */
#define DDALPHACAPS_BLTALPHAANDARGBSCALING      0x00000100l

/*
 * Driver supports overlays with surfaces that contain alpha information
 * in the pixel format.
 */
#define DDALPHACAPS_OVERLAYALPHAPIXELS          0x00010000l

/*
 * Driver performs saturated arithmetic to prevent the color
 * components in an alpha-blended overlay from overflowing.
 */
#define DDALPHACAPS_OVERLAYSATURATE             0x00020000l

/*
 * Driver can do alpha-blended overlays with pixels in premultiplied-
 * alpha format (color components stored in each pixel have been
 * premultiplied by the pixel's alpha component).
 */
#define DDALPHACAPS_OVERLAYPREMULT              0x00040000l

/*
 * Driver can do alpha-blended overlays with pixels in NON-premultiplied-
 * alpha format (color components NOT premultiplied by alpha component).
 */
#define DDALPHACAPS_OVERLAYNONPREMULT           0x00080000l

/*
 * Driver can perform one-factor ARGB scaling of source pixels
 * for an overlay.
 */
#define DDALPHACAPS_OVERLAYARGBSCALE1F          0x00100000l

/*
 * Driver can perform two-factor ARGB scaling of source pixels
 * for an overlay.
 */
#define DDALPHACAPS_OVERLAYARGBSCALE2F          0x00200000l

/*
 * Driver can perform four-factor ARGB scaling of source pixels
 * for an overlay.
 */
#define DDALPHACAPS_OVERLAYARGBSCALE4F          0x00400000l

/*
 * Driver can handle alpha blending and dest color keying at the same time.
 */
#define DDALPHACAPS_OVERLAYALPHAANDKEYDEST      0x00800000l

/*
 * Driver can handle source alpha channel and ARGB scaling at the same time.
 */
#define DDALPHACAPS_OVERLAYALPHAANDARGBSCALING  0x01000000l
//@@END_MSINTERNAL


/****************************************************************************
 *
 * DIRECTDRAW FX ALPHA CAPABILITY FLAGS
//@@BEGIN_MSINTERNAL
 * -- These are obsolete.  They are for the obsolete dwFXAlphaCaps member in DDCAPS_DX1/3/5.
//@@END_MSINTERNAL
 *
 ****************************************************************************/

/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAEDGEBLEND         0x00000001l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAPIXELS            0x00000002l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value
 * becomes more transparent as the alpha value increases.  (0 is opaque.)
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHAPIXELSNEG         0x00000004l

/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.  The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHASURFACES          0x00000008l

/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)  This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Blt.
 */
#define DDFXALPHACAPS_BLTALPHASURFACESNEG       0x00000010l

/*
 * Supports alpha blending around the edge of a source color keyed surface.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAEDGEBLEND     0x00000020l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value becomes
 * more opaque as the alpha value increases.  (0 is transparent.)
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAPIXELS        0x00000040l

/*
 * Supports alpha information in the pixel format.  The bit depth of alpha
 * information in the pixel format can be 1,2,4, or 8.  The alpha value
 * becomes more transparent as the alpha value increases.  (0 is opaque.)
 * This flag can only be set if DDCAPS_ALPHA is set.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHAPIXELSNEG     0x00000080l

/*
 * Supports alpha only surfaces.  The bit depth of an alpha only surface can be
 * 1,2,4, or 8.  The alpha value becomes more opaque as the alpha value increases.
 * (0 is transparent.)
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHASURFACES      0x00000100l

/*
 * The depth of the alpha channel data can range can be 1,2,4, or 8.
 * The NEG suffix indicates that this alpha channel becomes more transparent
 * as the alpha value increases. (0 is opaque.)  This flag can only be set if
 * DDCAPS_ALPHA is set.
 * For Overlays.
 */
#define DDFXALPHACAPS_OVERLAYALPHASURFACESNEG   0x00000200l

#if DIRECTDRAW_VERSION < 0x0600
#endif  //DIRECTDRAW_VERSION

//@@BEGIN_MSINTERNAL
/****************************************************************************
 *
 * DIRECTDRAW FILTER CAPABILITY FLAGS (for DDCAPS members dwFilterCaps,
 *   dwSVBFilterCaps, dwVSBFilterCaps, and dwSSBFilterCaps)
 *
 ****************************************************************************/

/*
 * Driver can do filtering of source pixels for an alpha blit to improve
 * quality of image that is stretched or shrunk to fit dest rect.
 */
#define DDFILTCAPS_BLTQUALITYFILTER             0x00000001l

/*
 * Driver can disable filtering for an alpha blit.  This may be necessary to
 * preserve color key values in an image that is stretched or shrunk.
 */
#define DDFILTCAPS_BLTCANDISABLEFILTER          0x00000002l

/*
 * When filtering, driver can treat pixels bordering source rectangle as
 * transparent in order to smoothly blend source image onto dest image.
 */
#define DDFILTCAPS_BLTTRANSPBORDER              0x00000004l


/****************************************************************************
 *
 * DIRECTDRAW TRANSFORM CAPABILITY FLAGS (for DDCAPS members dwTransformCaps,
 *   dwSVBTransformCaps, dwVSBTransformCaps, and dwSSBTransformCaps)
 *
 ****************************************************************************/

/*
 * Driver can do an affine-transformed blit.
 */
#define DDTFRMCAPS_BLTAFFINETRANSFORM           0x00000001l

/*
 * Driver can do an affine-transformed overlay.
 */
#define DDTFRMCAPS_OVERLAYAFFINETRANSFORM       0x00000002l
//@@END_MSINTERNAL


/****************************************************************************
 *
 * DIRECTDRAW FX CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Uses arithmetic operations to stretch and shrink surfaces during blt
 * rather than pixel doubling techniques.  Along the Y axis.
 */
#define DDFXCAPS_BLTARITHSTRETCHY       0x00000020l

/*
 * Uses arithmetic operations to stretch during blt
 * rather than pixel doubling techniques.  Along the Y axis. Only
 * works for x1, x2, etc.
 */
#define DDFXCAPS_BLTARITHSTRETCHYN      0x00000010l

/*
 * Supports mirroring left to right in blt.
 */
#define DDFXCAPS_BLTMIRRORLEFTRIGHT     0x00000040l

/*
 * Supports mirroring top to bottom in blt.
 */
#define DDFXCAPS_BLTMIRRORUPDOWN        0x00000080l

/*
 * Supports arbitrary rotation for blts.
 */
#define DDFXCAPS_BLTROTATION            0x00000100l

/*
 * Supports 90 degree rotations for blts.
 */
#define DDFXCAPS_BLTROTATION90          0x00000200l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKX             0x00000400l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKXN            0x00000800l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKY             0x00001000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.
 */
#define DDFXCAPS_BLTSHRINKYN            0x00002000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHX            0x00004000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHXN           0x00008000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHY            0x00010000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for blts.
 */
#define DDFXCAPS_BLTSTRETCHYN           0x00020000l

/*
 * Uses arithmetic operations to stretch and shrink surfaces during
 * overlay rather than pixel doubling techniques.  Along the Y axis
 * for overlays.
 */
#define DDFXCAPS_OVERLAYARITHSTRETCHY   0x00040000l

/*
 * Uses arithmetic operations to stretch surfaces during
 * overlay rather than pixel doubling techniques.  Along the Y axis
 * for overlays. Only works for x1, x2, etc.
 */
#define DDFXCAPS_OVERLAYARITHSTRETCHYN  0x00000008l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKX         0x00080000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKXN        0x00100000l

/*
 * DirectDraw supports arbitrary shrinking of a surface along the
 * y axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKY         0x00200000l

/*
 * DirectDraw supports integer shrinking (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSHRINKYN        0x00400000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHX        0x00800000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the x axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHXN       0x01000000l

/*
 * DirectDraw supports arbitrary stretching of a surface along the
 * y axis (horizontal direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHY        0x02000000l

/*
 * DirectDraw supports integer stretching (1x,2x,) of a surface
 * along the y axis (vertical direction) for overlays.
 */
#define DDFXCAPS_OVERLAYSTRETCHYN       0x04000000l

/*
 * DirectDraw supports mirroring of overlays across the vertical axis
 */
#define DDFXCAPS_OVERLAYMIRRORLEFTRIGHT 0x08000000l

/*
 * DirectDraw supports mirroring of overlays across the horizontal axis
 */
#define DDFXCAPS_OVERLAYMIRRORUPDOWN    0x10000000l

/*
 * DirectDraw supports deinterlacing of overlay surfaces
 */
#define DDFXCAPS_OVERLAYDEINTERLACE		0x20000000l

/*
 * Driver can do alpha blending for blits.
 */
#define DDFXCAPS_BLTALPHA               0x00000001l

//@@BEGIN_MSINTERNAL
/*
 * Driver can do geometric transformations (or warps) for blits.
 */
#define DDFXCAPS_BLTTRANSFORM           0x00000002l
//@@END_MSINTERNAL

/*
 * Driver can do surface-reconstruction filtering for warped blits.
 */
#define DDFXCAPS_BLTFILTER              DDFXCAPS_BLTARITHSTRETCHY

/*
 * Driver can do alpha blending for overlays.
 */
#define DDFXCAPS_OVERLAYALPHA           0x00000004l

//@@BEGIN_MSINTERNAL
/*
 * Driver can do geometric transformations (or warps) for overlays.
 */
#define DDFXCAPS_OVERLAYTRANSFORM       0x20000000l
//@@END_MSINTERNAL

/*
 * Driver can do surface-reconstruction filtering for warped overlays.
 */
#define DDFXCAPS_OVERLAYFILTER          DDFXCAPS_OVERLAYARITHSTRETCHY

/****************************************************************************
 *
 * DIRECTDRAW STEREO VIEW CAPABILITIES
 *
 ****************************************************************************/

/*
 * This flag used to be DDSVCAPS_ENIGMA, which is now obsolete
 */

#define DDSVCAPS_RESERVED1              0x00000001l

/*
 * This flag used to be DDSVCAPS_FLICKER, which is now obsolete
 */
#define DDSVCAPS_RESERVED2              0x00000002l

/*
 * This flag used to be DDSVCAPS_REDBLUE, which is now obsolete
 */
#define DDSVCAPS_RESERVED3              0x00000004l

/*
 * This flag used to be DDSVCAPS_SPLIT, which is now obsolete
 */
#define DDSVCAPS_RESERVED4              0x00000008l

/*
 * The stereo view is accomplished with switching technology
 */

#define DDSVCAPS_STEREOSEQUENTIAL       0x00000010L



/****************************************************************************
 *
 * DIRECTDRAWPALETTE CAPABILITIES
 *
 ****************************************************************************/

/*
 * Index is 4 bits.  There are sixteen color entries in the palette table.
 */
#define DDPCAPS_4BIT                    0x00000001l

/*
 * Index is onto a 8 bit color index.  This field is only valid with the
 * DDPCAPS_1BIT, DDPCAPS_2BIT or DDPCAPS_4BIT capability and the target
 * surface is in 8bpp. Each color entry is one byte long and is an index
 * into destination surface's 8bpp palette.
 */
#define DDPCAPS_8BITENTRIES             0x00000002l

/*
 * Index is 8 bits.  There are 256 color entries in the palette table.
 */
#define DDPCAPS_8BIT                    0x00000004l

/*
 * Indicates that this DIRECTDRAWPALETTE should use the palette color array
 * passed into the lpDDColorArray parameter to initialize the DIRECTDRAWPALETTE
 * object.
 * This flag is obsolete. DirectDraw always initializes the color array from
 * the lpDDColorArray parameter. The definition remains for source-level
 * compatibility.
 */
#define DDPCAPS_INITIALIZE              0x00000000l

/*
 * This palette is the one attached to the primary surface.  Changing this
 * table has immediate effect on the display unless DDPSETPAL_VSYNC is specified
 * and supported.
 */
#define DDPCAPS_PRIMARYSURFACE          0x00000010l

/*
 * This palette is the one attached to the primary surface left.  Changing
 * this table has immediate effect on the display for the left eye unless
 * DDPSETPAL_VSYNC is specified and supported.
 */
#define DDPCAPS_PRIMARYSURFACELEFT      0x00000020l

/*
 * This palette can have all 256 entries defined
 */
#define DDPCAPS_ALLOW256                0x00000040l

/*
 * This palette can have modifications to it synced with the monitors
 * refresh rate.
 */
#define DDPCAPS_VSYNC                   0x00000080l

/*
 * Index is 1 bit.  There are two color entries in the palette table.
 */
#define DDPCAPS_1BIT                    0x00000100l

/*
 * Index is 2 bit.  There are four color entries in the palette table.
 */
#define DDPCAPS_2BIT                    0x00000200l

/*
 * The peFlags member of PALETTEENTRY denotes an 8 bit alpha value
 */
#define DDPCAPS_ALPHA                   0x00000400l

//@@BEGIN_MSINTERNAL
#define DDPCAPS_VALID                   0x000007ffl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWPALETTE SETENTRY CONSTANTS
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
/*
 * Palette changes take effect immediately.
 */
#define DDPSETPAL_IMMEDIATE             0x00000000l     // default

/*
 * Palette changes should take effect during the vertical blank to avoid
 * palette tearing.
 */
#define DDPSETPAL_VSYNC                 0x00000002l
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWPALETTE GETENTRY CONSTANTS
 *
 ****************************************************************************/

/* 0 is the only legal value */

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SETPRIVATEDATA CONSTANTS
 *
 ****************************************************************************/

/*
 * The passed pointer is an IUnknown ptr. The cbData argument to SetPrivateData
 * must be set to sizeof(IUnknown*). DirectDraw will call AddRef through this
 * pointer and Release when the private data is destroyed. This includes when
 * the surface or palette is destroyed before such priovate data is destroyed.
 */
#define DDSPD_IUNKNOWNPOINTER           0x00000001L

/*
 * Private data is only valid for the current state of the object,
 * as determined by the uniqueness value.
 */
#define DDSPD_VOLATILE                  0x00000002L

//@@BEGIN_MSINTERNAL
#define DDSPD_VALID                     0x00000003L
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SETPALETTE CONSTANTS
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
/*
 * Palette change takes effect immediately.
 */
#define DDSETPAL_IMMEDIATE              0x00000000l     // default

/*
 * Palette change should take effect during the vertical blank to avoid
 * palette tearing.
 */
#define DDSETPAL_VSYNC                  0x00000002l
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW BITDEPTH CONSTANTS
 *
 * NOTE:  These are only used to indicate supported bit depths.   These
 * are flags only, they are not to be used as an actual bit depth.   The
 * absolute numbers 1, 2, 4, 8, 16, 24 and 32 are used to indicate actual
 * bit depths in a surface or for changing the display mode.
 *
 ****************************************************************************/

/*
 * 1 bit per pixel.
 */
#define DDBD_1                  0x00004000l

/*
 * 2 bits per pixel.
 */
#define DDBD_2                  0x00002000l

/*
 * 4 bits per pixel.
 */
#define DDBD_4                  0x00001000l

/*
 * 8 bits per pixel.
 */
#define DDBD_8                  0x00000800l

/*
 * 16 bits per pixel.
 */
#define DDBD_16                 0x00000400l

/*
 * 24 bits per pixel.
 */
#define DDBD_24                 0X00000200l

/*
 * 32 bits per pixel.
 */
#define DDBD_32                 0x00000100l

/****************************************************************************
 *
 * DIRECTDRAWSURFACE SET/GET COLOR KEY FLAGS
 *
 ****************************************************************************/

/*
 * Set if the structure contains a color space.  Not set if the structure
 * contains a single color key.
 */
#define DDCKEY_COLORSPACE       0x00000001l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for blt operations.
 */
#define DDCKEY_DESTBLT          0x00000002l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a destination color key for overlay operations.
 */
#define DDCKEY_DESTOVERLAY      0x00000004l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for blt operations.
 */
#define DDCKEY_SRCBLT           0x00000008l

/*
 * Set if the structure specifies a color key or color space which is to be
 * used as a source color key for overlay operations.
 */
#define DDCKEY_SRCOVERLAY       0x00000010l

//@@BEGIN_MSINTERNAL
#define DDCKEY_VALID            0x0000001fl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW COLOR KEY CAPABILITY FLAGS
 *
 ****************************************************************************/

/*
 * Supports transparent blting using a color key to identify the replaceable
 * bits of the destination surface for RGB colors.
 */
#define DDCKEYCAPS_DESTBLT                      0x00000001l

/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for RGB colors.
 */
#define DDCKEYCAPS_DESTBLTCLRSPACE              0x00000002l

/*
 * Supports transparent blting using a color space to identify the replaceable
 * bits of the destination surface for YUV colors.
 */
#define DDCKEYCAPS_DESTBLTCLRSPACEYUV           0x00000004l

/*
 * Supports transparent blting using a color key to identify the replaceable
 * bits of the destination surface for YUV colors.
 */
#define DDCKEYCAPS_DESTBLTYUV                   0x00000008l

/*
 * Supports overlaying using colorkeying of the replaceable bits of the surface
 * being overlayed for RGB colors.
 */
#define DDCKEYCAPS_DESTOVERLAY                  0x00000010l

/*
 * Supports a color space as the color key for the destination for RGB colors.
 */
#define DDCKEYCAPS_DESTOVERLAYCLRSPACE          0x00000020l

/*
 * Supports a color space as the color key for the destination for YUV colors.
 */
#define DDCKEYCAPS_DESTOVERLAYCLRSPACEYUV       0x00000040l

/*
 * Supports only one active destination color key value for visible overlay
 * surfaces.
 */
#define DDCKEYCAPS_DESTOVERLAYONEACTIVE         0x00000080l

/*
 * Supports overlaying using colorkeying of the replaceable bits of the
 * surface being overlayed for YUV colors.
 */
#define DDCKEYCAPS_DESTOVERLAYYUV               0x00000100l

/*
 * Supports transparent blting using the color key for the source with
 * this surface for RGB colors.
 */
#define DDCKEYCAPS_SRCBLT                       0x00000200l

/*
 * Supports transparent blting using a color space for the source with
 * this surface for RGB colors.
 */
#define DDCKEYCAPS_SRCBLTCLRSPACE               0x00000400l

/*
 * Supports transparent blting using a color space for the source with
 * this surface for YUV colors.
 */
#define DDCKEYCAPS_SRCBLTCLRSPACEYUV            0x00000800l

/*
 * Supports transparent blting using the color key for the source with
 * this surface for YUV colors.
 */
#define DDCKEYCAPS_SRCBLTYUV                    0x00001000l

/*
 * Supports overlays using the color key for the source with this
 * overlay surface for RGB colors.
 */
#define DDCKEYCAPS_SRCOVERLAY                   0x00002000l

/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for RGB colors.
 */
#define DDCKEYCAPS_SRCOVERLAYCLRSPACE           0x00004000l

/*
 * Supports overlays using a color space as the source color key for
 * the overlay surface for YUV colors.
 */
#define DDCKEYCAPS_SRCOVERLAYCLRSPACEYUV        0x00008000l

/*
 * Supports only one active source color key value for visible
 * overlay surfaces.
 */
#define DDCKEYCAPS_SRCOVERLAYONEACTIVE          0x00010000l

/*
 * Supports overlays using the color key for the source with this
 * overlay surface for YUV colors.
 */
#define DDCKEYCAPS_SRCOVERLAYYUV                0x00020000l

/*
 * there are no bandwidth trade-offs for using colorkey with an overlay
 */
#define DDCKEYCAPS_NOCOSTOVERLAY                0x00040000l


/****************************************************************************
 *
 * DIRECTDRAW PIXELFORMAT FLAGS
 *
 ****************************************************************************/

/*
 * The surface has alpha channel information in the pixel format.
 */
#define DDPF_ALPHAPIXELS                        0x00000001l

/*
 * The pixel format contains alpha only information
 */
#define DDPF_ALPHA                              0x00000002l

/*
 * The FourCC code is valid.
 */
#define DDPF_FOURCC                             0x00000004l

/*
 * The surface is 4-bit color indexed.
 */
#define DDPF_PALETTEINDEXED4                    0x00000008l

/*
 * The surface is indexed into a palette which stores indices
 * into the destination surface's 8-bit palette.
 */
#define DDPF_PALETTEINDEXEDTO8                  0x00000010l

/*
 * The surface is 8-bit color indexed.
 */
#define DDPF_PALETTEINDEXED8                    0x00000020l

/*
 * The RGB data in the pixel format structure is valid.
 */
#define DDPF_RGB                                0x00000040l

/*
 * The surface will accept pixel data in the format specified
 * and compress it during the write.
 */
#define DDPF_COMPRESSED                         0x00000080l

/*
 * The surface will accept RGB data and translate it during
 * the write to YUV data.  The format of the data to be written
 * will be contained in the pixel format structure.  The DDPF_RGB
 * flag will be set.
 */
#define DDPF_RGBTOYUV                           0x00000100l

/*
 * pixel format is YUV - YUV data in pixel format struct is valid
 */
#define DDPF_YUV                                0x00000200l

/*
 * pixel format is a z buffer only surface
 */
#define DDPF_ZBUFFER                            0x00000400l

/*
 * The surface is 1-bit color indexed.
 */
#define DDPF_PALETTEINDEXED1                    0x00000800l

/*
 * The surface is 2-bit color indexed.
 */
#define DDPF_PALETTEINDEXED2                    0x00001000l

/*
 * The surface contains Z information in the pixels
 */
#define DDPF_ZPIXELS                            0x00002000l

/*
 * The surface contains stencil information along with Z
 */
#define DDPF_STENCILBUFFER                      0x00004000l

/*
 * Premultiplied alpha format -- the color components have been
 * premultiplied by the alpha component.
 */
#define DDPF_ALPHAPREMULT                       0x00008000l

//@@BEGIN_MSINTERNAL
/*
 * Empty surface
 */
#define DDPF_EMPTYSURFACE                       0x00010000l
//@@END_MSINTERNAL

/*
 * Luminance data in the pixel format is valid.
 * Use this flag for luminance-only or luminance+alpha surfaces,
 * the bit depth is then ddpf.dwLuminanceBitCount.
 */
#define DDPF_LUMINANCE                          0x00020000l

/*
 * Luminance data in the pixel format is valid.
 * Use this flag when hanging luminance off bumpmap surfaces,
 * the bit mask for the luminance portion of the pixel is then
 * ddpf.dwBumpLuminanceBitMask
 */
#define DDPF_BUMPLUMINANCE                      0x00040000l

/*
 * Bump map dUdV data in the pixel format is valid.
 */
#define DDPF_BUMPDUDV                           0x00080000l

//@@BEGIN_MSINTERNAL
/*
 * This DDPF flag is used by drivers to signify that this format is new and may be
 * a candidate for hiding from certain applications
 * KEEP THIS DEFINITION IN SYNC WITH THAT OF DDPF_NOVEL_TEXTURE_FORMAT IN DDRAWI.H
 */
#define DDPF_RESERVED1                          0x00100000l


/*
 * This DDPF flag indicates a DX8 style texture list entry.
 * Keep this definition in sync with DDPF_D3DFORMAT in DDRAWI.H
 */
#define DDPF_RESERVED2                          0x00200000l

//@@END_MSINTERNAL

/*===========================================================================
 *
 *
 * DIRECTDRAW CALLBACK FLAGS
 *
 *
 *==========================================================================*/

/****************************************************************************
 *
 * DIRECTDRAW ENUMSURFACES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate all of the surfaces that meet the search criterion.
 */
#define DDENUMSURFACES_ALL                      0x00000001l

/*
 * A search hit is a surface that matches the surface description.
 */
#define DDENUMSURFACES_MATCH                    0x00000002l

/*
 * A search hit is a surface that does not match the surface description.
 */
#define DDENUMSURFACES_NOMATCH                  0x00000004l

/*
 * Enumerate the first surface that can be created which meets the search criterion.
 */
#define DDENUMSURFACES_CANBECREATED             0x00000008l

/*
 * Enumerate the surfaces that already exist that meet the search criterion.
 */
#define DDENUMSURFACES_DOESEXIST                0x00000010l

//@@BEGIN_MSINTERNAL
#define DDENUMSURFACES_VALID                    0x0000001fl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW SETDISPLAYMODE FLAGS
 *
 ****************************************************************************/

/*
 * The desired mode is a standard VGA mode
 */
#define DDSDM_STANDARDVGAMODE                   0x00000001l

//@@BEGIN_MSINTERNAL
#define DDSDM_VALID                             0x00000001l
//@@END_MSINTERNAL


/****************************************************************************
 *
 * DIRECTDRAW ENUMDISPLAYMODES FLAGS
 *
 ****************************************************************************/

/*
 * Enumerate Modes with different refresh rates.  EnumDisplayModes guarantees
 * that a particular mode will be enumerated only once.  This flag specifies whether
 * the refresh rate is taken into account when determining if a mode is unique.
 */
#define DDEDM_REFRESHRATES                      0x00000001l

/*
 * Enumerate VGA modes. Specify this flag if you wish to enumerate supported VGA
 * modes such as mode 0x13 in addition to the usual ModeX modes (which are always
 * enumerated if the application has previously called SetCooperativeLevel with the
 * DDSCL_ALLOWMODEX flag set).
 */
#define DDEDM_STANDARDVGAMODES                  0x00000002L

//@@BEGIN_MSINTERNAL
#define DDEDM_VALID                             0x00000003l
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW SETCOOPERATIVELEVEL FLAGS
 *
 ****************************************************************************/

/*
 * Exclusive mode owner will be responsible for the entire primary surface.
 * GDI can be ignored. used with DD
 */
#define DDSCL_FULLSCREEN                        0x00000001l

/*
 * allow CTRL_ALT_DEL to work while in fullscreen exclusive mode
 */
#define DDSCL_ALLOWREBOOT                       0x00000002l

/*
 * prevents DDRAW from modifying the application window.
 * prevents DDRAW from minimize/restore the application window on activation.
 */
#define DDSCL_NOWINDOWCHANGES                   0x00000004l

/*
 * app wants to work as a regular Windows application
 */
#define DDSCL_NORMAL                            0x00000008l

/*
 * app wants exclusive access
 */
#define DDSCL_EXCLUSIVE                         0x00000010l

//@@BEGIN_MSINTERNAL
/*
 * dont hook window proc, only valid for non-exclusive
 */
#define DDSCL_DONTHOOKHWND                      0x00000020l
//@@END_MSINTERNAL

/*
 * app can deal with non-windows display modes
 */
#define DDSCL_ALLOWMODEX                        0x00000040l

/*
 * this window will receive the focus messages
 */
#define DDSCL_SETFOCUSWINDOW                    0x00000080l

/*
 * this window is associated with the DDRAW object and will
 * cover the screen in fullscreen mode
 */
#define DDSCL_SETDEVICEWINDOW                   0x00000100l

/*
 * app wants DDRAW to create a window to be associated with the
 * DDRAW object
 */
#define DDSCL_CREATEDEVICEWINDOW                0x00000200l

/*
 * App explicitly asks DDRAW/D3D to be multithread safe. This makes D3D
 * take the global crtisec more frequently.
 */
#define DDSCL_MULTITHREADED                     0x00000400l

/*
 * App specifies that it would like to keep the FPU set up for optimal Direct3D
 * performance (single precision and exceptions disabled) so Direct3D
 * does not need to explicitly set the FPU each time. This is assumed by
 * default in DirectX 7. See also DDSCL_FPUPRESERVE
 */
#define DDSCL_FPUSETUP                          0x00000800l

/*
 * App specifies that it needs either double precision FPU or FPU exceptions
 * enabled. This makes Direct3D explicitly set the FPU state eah time it is
 * called. Setting the flag will reduce Direct3D performance. The flag is
 * assumed by default in DirectX 6 and earlier. See also DDSCL_FPUSETUP
 */
#define DDSCL_FPUPRESERVE                          0x00001000l

//@@BEGIN_MSINTERNAL
/*
 * Used to flag a call from the DX8 thunk layer, which we use to modify
 * msg loop behaviour.
 */
#define DDSCL_DX8APP                               0x00002000l
//@@END_MSINTERNAL

//@@BEGIN_MSINTERNAL
#define DDSCL_VALID                                0x00003FFFl
//@@END_MSINTERNAL

/****************************************************************************
 *
 * DIRECTDRAW BLT FLAGS
 *
 ****************************************************************************/

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the destination surface as the alpha channel for this blt.
 */
#define DDBLT_ALPHADEST                         0x00000001l

/*
 * Use the dwConstAlphaDest field in the DDBLTFX structure as the alpha channel
 * for the destination surface for this blt.
 */
#define DDBLT_ALPHADESTCONSTOVERRIDE            0x00000002l

/*
 * The NEG suffix indicates that the destination surface becomes more
 * transparent as the alpha value increases. (0 is opaque)
 */
#define DDBLT_ALPHADESTNEG                      0x00000004l

/*
 * Use the lpDDSAlphaDest field in the DDBLTFX structure as the alpha
 * channel for the destination for this blt.
 */
#define DDBLT_ALPHADESTSURFACEOVERRIDE          0x00000008l

/*
 * Use the dwAlphaEdgeBlend field in the DDBLTFX structure as the alpha channel
 * for the edges of the image that border the color key colors.
 */
#define DDBLT_ALPHAEDGEBLEND                    0x00000010l

/*
 * Use the alpha information in the pixel format or the alpha channel surface
 * attached to the source surface as the alpha channel for this blt.
 */
#define DDBLT_ALPHASRC                          0x00000020l

/*
 * Use the dwConstAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDBLT_ALPHASRCCONSTOVERRIDE             0x00000040l

/*
 * The NEG suffix indicates that the source surface becomes more transparent
 * as the alpha value increases. (0 is opaque)
 */
#define DDBLT_ALPHASRCNEG                       0x00000080l

/*
 * Use the lpDDSAlphaSrc field in the DDBLTFX structure as the alpha channel
 * for the source for this blt.
 */
#define DDBLT_ALPHASRCSURFACEOVERRIDE           0x00000100l

/*
 * Do this blt asynchronously through the FIFO in the order received.  If
 * there is no room in the hardware FIFO fail the call.
 */
#define DDBLT_ASYNC                             0x00000200l

/*
 * Uses the dwFillColor field in the DDBLTFX structure as the RGB color
 * to fill the destination rectangle on the destination surface with.
 */
#define DDBLT_COLORFILL                         0x00000400l

/*
 * Uses the dwDDFX field in the DDBLTFX structure to specify the effects
 * to use for the blt.
 */
#define DDBLT_DDFX                              0x00000800l

/*
 * Uses the dwDDROPS field in the DDBLTFX structure to specify the ROPS
 * that are not part of the Win32 API.
 */
#define DDBLT_DDROPS                            0x00001000l

/*
 * Use the color key associated with the destination surface.
 */
#define DDBLT_KEYDEST                           0x00002000l

/*
 * Use the dckDestColorkey field in the DDBLTFX structure as the color key
 * for the destination surface.
 */
#define DDBLT_KEYDESTOVERRIDE                   0x00004000l

/*
 * Use the color key associated with the source surface.
 */
#define DDBLT_KEYSRC                            0x00008000l

/*
 * Use the dckSrcColorkey field in the DDBLTFX structure as the color key
 * for the source surface.
 */
#define DDBLT_KEYSRCOVERRIDE                    0x00010000l

/*
 * Use the dwROP field in the DDBLTFX structure for the raster operation
 * for this blt.  These ROPs are the same as the ones defined in the Win32 API.
 */
#define DDBLT_ROP                               0x00020000l

/*
 * Use the dwRotationAngle field in the DDBLTFX structure as the angle
 * (specified in 1/100th of a degree) to rotate the surface.
 */
#define DDBLT_ROTATIONANGLE                     0x00040000l

/*
 * Z-buffered blt using the z-buffers attached to the source and destination
 * surfaces and the dwZBufferOpCode field in the DDBLTFX structure as the
 * z-buffer opcode.
 */
#define DDBLT_ZBUFFER                           0x00080000l

/*
 * Z-buffered blt using the dwConstDest Zfield and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the destination.
 */
#define DDBLT_ZBUFFERDESTCONSTOVERRIDE          0x00100000l

/*
 * Z-buffered blt using the lpDDSDestZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the destination.
 */
#define DDBLT_ZBUFFERDESTOVERRIDE               0x00200000l

/*
 * Z-buffered blt using the dwConstSrcZ field and the dwZBufferOpCode field
 * in the DDBLTFX structure as the z-buffer and z-buffer opcode respectively
 * for the source.
 */
#define DDBLT_ZBUFFERSRCCONSTOVERRIDE           0x00400000l

/*
 * Z-buffered blt using the lpDDSSrcZBuffer field and the dwZBufferOpCode
 * field in the DDBLTFX structure as the z-buffer and z-buffer opcode
 * respectively for the source.
 */
#define DDBLT_ZBUFFERSRCOVERRIDE                0x00800000l

/*
 * wait until the device is ready to handle the blt
 * this will cause blt to not return DDERR_WASSTILLDRAWING
 */
#define DDBLT_WAIT                              0x01000000l

/*
 * Uses the dwFillDepth field in the DDBLTFX structure as the depth value
 * to fill the destination rectangle on the destination Z-buffer surface
 * with.
 */
#define DDBLT_DEPTHFILL                         0x02000000l

//@@BEGIN_MSINTERNAL
//Turns on ddbltfx.dwZDestConstBitDepth as a write mask for zbuffer clears (so as not to
//clobber the stencil or vice versa). This is VERY internal only. Fielded only by the HEL
#define DDBLT_DEPTHFILLWRITEMASK                0x04000000l
//@@END_MSINTERNAL

/*
 * wait until the device is ready to handle the blt
 * this will cause blt to not return DDERR_WASSTILLDRAWING
 */
#define DDBLT_DONOTWAIT                         0x08000000l

/*
 * These flags indicate a presentation blt (i.e. a bl