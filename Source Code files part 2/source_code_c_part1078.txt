
	 break;

      case 4:
	 if ( descr_trace & 0x04 )
	    {
	    high_base = high_base & 0x1f;
	    fprintf(trace_file, "(%04x)P:%1d DPL:%1d TYPE:%25s SELECTOR:%4x OFFSET:%4x WD:%2x\n",
	       i, p, dpl, output_name, low_base, limit, high_base);
	    }
	 break;

      case 5:
	 if ( descr_trace & 0x08 )
	    {
	    fprintf(trace_file, "(%04x)P:%1d DPL:%1d TYPE:%25s TSS SELECTOR:%4x\n",
	       i, p, dpl, output_name, low_base);
	    }
	 break;

      case 6:
	 if ( descr_trace & 0x10 )
	    {
	    base = ((high_limit & 0xff00) << 16) |
		   (high_base << 16 ) |
		   low_base;
	    tlimit = ((high_limit & 0xf) << 16) | limit;
	    if ( high_limit & 0x80 )
	       tlimit = tlimit << 12 | 0xfff;
	    fprintf(trace_file, "(%04x)P:%1d DPL:%1d %s TYPE:%25s BASE:%08x LIMIT:%08x A:%1d\n",
	       i, p, dpl, (high_limit & 0x40) ? "Big": "   ", output_name, base, tlimit, a);
	    }
	 break;

      case 7:
	 if ( descr_trace & 0x20 )
	    {
	    base = ((high_limit & 0xff00) << 16) |
		   (high_base << 16 ) |
		   low_base;
	    tlimit = ((high_limit & 0xf) << 16) | limit;
	    if ( high_limit & 0x80 )
	       tlimit = tlimit << 12 | 0xfff;
	    fprintf(trace_file, "(%04x)P:%1d DPL:%1d %s TYPE:%25s BASE:%08x LIMIT:%08x A:%1d\n",
	       i, p, dpl, (high_limit & 0x40) ? "Big": "   ", output_name, base, tlimit, a);
	    }
	 break;

      case 8:
	 if ( descr_trace & 0x04 )
	    {
	    high_base = high_base & 0xf;
	    tlimit = (high_limit << 16) | limit;
	    fprintf(trace_file, "(%04x)P:%1d DPL:%1d TYPE:%25s SELECTOR:%04x OFFSET:%08x DW:%2x\n",
	       i, p, dpl, output_name, low_base, tlimit, high_base);
	    }
	 break;

      case 9:
	 if ( descr_trace & 0x08 )
	    {
	    tlimit = (high_limit << 16) | limit;
	    fprintf(trace_file, "(%04x)P:%1d DPL:%1d TYPE:%25s SELECTOR:%04x OFFSET:%08x\n",
	       i, p, dpl, output_name, low_base, tlimit);
	    }
	 break;
	 }
      }
   }
#endif /* PM */

/*
   Dump Readable String.
 */
dump_string IFN4(IU16, selector, LIN_ADDR, offset, LIN_ADDR, len, long, mode)

#ifdef DOCUMENTATION
long selector;   /* Selector:Offset to start address for dump */
long offset;     /*                    "                      */
long len;        /* Nr. bytes to dump */
long mode;       /* =1 Simple byte string dump */
                 /* =2 Dump every other byte starting with first */
                 /* =3 Dump every other byte starting with second */
#endif	/* DOCUMENTATION */

   {
   int i;
   int pc = 0;
   half_word value;
   LIN_ADDR addr;

   addr = eff_addr(selector, offset);

   for ( i = 0; i < len; i++ )
      {
      /* Get next byte to be shown */
      switch ( mode )
	 {
      case 1:
	 value = sas_hw_at(addr+i);
	 break;

      case 2:
	 value = sas_hw_at(addr+i);
	 i++;
	 break;

      case 3:
	 i++;
	 value = sas_hw_at(addr+i);
	 break;
	 }

      /* Filter out the unprintable */
      if ( iscntrl(value) )
	 value = '.';

      /* Print it */
      fprintf(trace_file, "%c", value);
      /* With a line feed every eighty characters */
      if ( ++pc == 80 )
	 {
	 fprintf(trace_file, "\n");
	 pc = 0;
	 }
      }

   /* Print final line feed if needed */
   if ( pc )
      fprintf(trace_file, "\n");
   }


/* Do pretty printing for page table entry */
LOCAL void dump_page_table_entries IFN3(int, first_index, int, last_index, IU32, entry)
{
	if (first_index == last_index)
		fprintf(trace_file, "%03x      %08x ", first_index, entry);
	else
		fprintf(trace_file, "%03x..%03x %08x ", first_index, last_index, entry);

	if ( entry & 1 )
	{
		/* Present */
		fprintf(trace_file, "%08x %c %c %c %c.\n",
			entry & 0xfffff000,
			(entry & 0x40) ? 'D' : ' ',
			(entry & 0x20) ? 'A' : ' ',
			(entry & 0x04) ? 'U' : 'S',
			(entry & 0x02) ? 'W' : 'R');
	}
#ifndef	CCPU
	else if ((((entry >> 9) & 7) == 6) && Sas.IsPageInstanceData(entry))
	{
		/* Not Present, but Windows instance data */
		fprintf(trace_file, "Not Present, Instance data\n");
	}
#endif /* CCPU */
	else
	{
		/* Not Present */
		fprintf(trace_file, "Not Present.\n");
	}
}


LOCAL void dump_page_table IFN2(
   IS32, cs,	/* Physical address to dump table from */
   IS32, len	/* Entry Number (0-3ff) to dump, else dump all */
)
{
#ifdef CPU_40_STYLE
	PHY_ADDR addr;
	int start, end;
	int i;
	IU32 entry;
	
	/* Special case tell them Page Directory Base Register contents */
	if ( cs == 0 )
	{
		fprintf(trace_file,
			"Page Directory Base Register = %08x.\n", getCR3());
		return;
	}
	
	if ( len < 0 || len > 1023  )
	{
		/* dump whole table */
		start = 0;
		end = 1024;
		addr = (PHY_ADDR)cs;
	}
	else
	{
		/* dump just one entry */
		start = len;
		end = len + 1;
		addr = (PHY_ADDR)(cs + (start * 4));
	}
	
	disable_bkpt = 1;
	
	i = start;
	while (i < end)
	{
		IU32 next_entry;
		PHY_ADDR next_addr;
		IU32 next_i;

		/* Get next Page Table Entry */
		entry = sas_PR32(addr);
		next_addr = addr+4;
		for (next_i = i+1; next_i < end;)
		{
			next_entry = sas_PR32(next_addr);
			if (next_entry != entry)
				break;
			next_addr += 4;
			next_i++;
		}
		if (next_i < end)
		{
			/* We exited early, entry at next_i is different */
			dump_page_table_entries(i, next_i - 1, entry);
			i = next_i;
			addr = next_addr;
		}
		else
		{
			dump_page_table_entries(i, end - 1, entry);
			break;
		}
	}
	
	disable_bkpt = 0;
#endif /* CPU_40_STYLE */
}

LOCAL void show_phys_addr IFN1(LIN_ADDR, lin)
{
	IU32 dir, tbl;
	PHY_ADDR addr, pde, pte;
	/* Split linear address (lin) into DIR, TBL and OFFSET components */
	
	dir = (lin >> 22) & 0x3ff;
	tbl = (lin >> 12) & 0x3ff;
	fprintf(trace_file,
		"LinearAddress %08x => Directory %03x Table %03x Offset %03x.\n",
		lin,
		dir,
		tbl,
		lin & 0xfff);
#ifdef	CPU_40_STYLE
	addr = (getCR3() & ~0x3ff) + (dir * 4);
	disable_bkpt = 1;
	pde = sas_PR32(addr);
	disable_bkpt = 0;
	fprintf(trace_file, "  Directory entry @ %08p ", addr);
	dump_page_table_entries(dir, dir, pde);
	if (pde & 1)
	{
		addr = (pde & ~0xfff) + (tbl * 4);
		disable_bkpt = 1;
		pte = sas_PR32(addr);
		disable_bkpt = 0;
		fprintf(trace_file, "  Table entry     @ %08p ", addr);
		dump_page_table_entries(tbl, tbl, pte);
		if (pte & 1)
		{
			fprintf(trace_file, "  Final Physical Address %08x\n", (pte & ~0xfff) + (lin & 0xfff));
		}
	}
#endif /* CPU_40_STYLE */
}

LOCAL void guess_lin_phys IFN1(PHY_ADDR, phys)
{
	IU32 dir, tbl, pdbr;
	PHY_ADDR addr, pde, pte;
	int nPrinted = 0;
	/* Guess linear address(es) from given phys address */

	fprintf(trace_file,
		"Phys addr @ %08x could be linear address(es)\n",
		phys);
#ifdef	CPU_40_STYLE
	pdbr = getCR3() & ~0xFFF;
	for (dir = 0; dir <= 0x3ff; dir++)
	{
		addr = pdbr + (dir * 4);

		disable_bkpt = 1;
		pde = sas_PR32(addr);
		disable_bkpt = 0;
		if (pde & 1)
		{
			for (tbl = 0; tbl <= 0x3ff; tbl++)
			{
				addr = (pde & ~0xfff) + (tbl * 4);
				disable_bkpt = 1;
				pte = sas_PR32(addr);
				disable_bkpt = 0;
				if ((pte & 1) && ((pte ^ phys) <= 0xfff))
				{
					fprintf(trace_file, "%08x ",
						(dir << 22) + (tbl << 12) + (phys & 0xFFF));
					if (nPrinted++ == 8)
					{
						fprintf(trace_file, "\n");
						nPrinted = 0;
					}
				}
			}
		}
	}
	if (nPrinted)
	{
		fprintf(trace_file, "\n");
	}
#endif /* CPU_40_STYLE */
}

LOCAL void guess_lin_pte IFN1(PHY_ADDR, pte_addr)
{
	IU32 dir, tbl, pdbr;
	PHY_ADDR addr, pde, pte;
	int nPrinted = 0;
	/* Guess linear address(es) from given PTE address */
	
	fprintf(trace_file,
		"PTE @ %08x could be defining linear address(es)\n",
		pte_addr);
#ifdef	CPU_40_STYLE
	pdbr = getCR3() & ~0xFFF;
	for (dir = 0; dir <= 0x3ff; dir++)
	{
		addr = pdbr + (dir * 4);

		disable_bkpt = 1;
		pde = sas_PR32(addr);
		disable_bkpt = 0;
		if ((pde & 1) && ((pde ^ pte_addr) <= 0xfff))
		{
			fprintf(trace_file, "%05x000 ", (dir << 10) + ((pte_addr & 0xFFF) >> 2));
			if (nPrinted++ == 8)
			{
				fprintf(trace_file, "\n");
				nPrinted = 0;
			}
		}
	}
	if (nPrinted)
	{
		fprintf(trace_file, "\n");
	}
#endif /* CPU_40_STYLE */
}

LOCAL	void	dump_phys_bytes IFN2(IS32, cs, IS32, len)
   {
#ifdef CPU_40_STYLE
   int i, j, x, y;

   if (len < 0)
      len = 1;

   x = len % 16;
   y = len / 16;

   for (i=0;i<y;i++)
      {
      fprintf(trace_file,"%08lx:", cs);
      for (j=0;j<16;j++)
	 {
	 fprintf(trace_file," %02x", sas_PR8((PHY_ADDR)(cs + j)));
	 }
      fprintf(trace_file,"\n");
      cs += 16;
      }

   if(x != 0)
      fprintf(trace_file,"%08lx:", cs);

   for (j=0;j<x;j++)
      {
      fprintf(trace_file," %02x", sas_PR8((PHY_ADDR)(cs + j)));
      }
   fprintf(trace_file,"\n");
#endif /* CPU_40_STYLE */
   }

LOCAL	void	dump_bytes IFN3(IU16, cs, LIN_ADDR, ip, LIN_ADDR, len)
{
half_word val[MAX_TABLE];
int i, j, k, x, y;
	if ((len == 0) || (len == YODA_LEN_UNSPECIFIED))
		return;
	if(len > MAX_TABLE)
		len = MAX_TABLE;
	disable_bkpt = 1;
	sas_loads(eff_addr(cs,ip), val, len);
	disable_bkpt = 0;
	x = len % 16;
	y = len / 16;
	k = 0;
	for (i=0;i<y;i++) {
		fprintf(trace_file,"%04lx:%04lx", cs, ip);
		for (j=0;j<16;j++)
			fprintf(trace_file," %02x", val[k++]);
		fprintf(trace_file,"\n");
		ip += 16;
	}
	if(x != 0)
		fprintf(trace_file,"%04lx:%04lx", cs, ip);
	for (i=0;i<x;i++)
		fprintf(trace_file," %02x", val[k++]);
	fprintf(trace_file,"\n");
}

LOCAL	void	dump_words IFN3(IU16, cs, LIN_ADDR, ip, LIN_ADDR, len)
{
int i;
word val;

	disable_bkpt = 1;
	for (i=0;i<len;i++) {
		if (i%8 == 0) fprintf(trace_file,"%04lx:%04lx", cs, ip);
		val = sas_w_at(eff_addr(cs,ip));
		ip += 2;
		fprintf(trace_file," %04x", val);
		if (i%8 == 7) fprintf(trace_file,"\n");
	}
	if (i%8 != 7) fprintf(trace_file,"\n");
	disable_bkpt = 0;
}

LOCAL	void	dump_dwords IFN3(IU16, cs, LIN_ADDR, ip, LIN_ADDR, len)
{
int i;
IU32 val;

	disable_bkpt = 1;
	for (i=0;i<len;i++) {
		if (i%8 == 0) fprintf(trace_file,"%04lx:%04lx", cs, ip);
		val = sas_dw_at(eff_addr(cs,ip));
		ip += 4;
		fprintf(trace_file," %08x", val);
		if (i%8 == 7) fprintf(trace_file,"\n");
	}
	if (i%8 != 7) fprintf(trace_file,"\n");
	disable_bkpt = 0;
}

LOCAL void init_br_regentry IFN3(BR_REG, regst, char *, str, SIZE_SPECIFIER, size)
{
	br_regdescs[regst].regnum = regst;
	strcpy(br_regdescs[regst].regname, str);
	br_regdescs[regst].size = size;
}

LOCAL void init_br_structs IFN0()
{
	int loop;

	init_br_regentry(br_regAX,"AX",SIXTEEN_BIT);
	init_br_regentry(br_regBX,"BX",SIXTEEN_BIT);
	init_br_regentry(br_regCX,"CX",SIXTEEN_BIT);
	init_br_regentry(br_regDX,"DX",SIXTEEN_BIT);
	init_br_regentry(br_regCS,"CS",SIXTEEN_BIT);
	init_br_regentry(br_regDS,"DS",SIXTEEN_BIT);
	init_br_regentry(br_regES,"ES",SIXTEEN_BIT);
	init_br_regentry(br_regSS,"SS",SIXTEEN_BIT);
	init_br_regentry(br_regSI,"SI",SIXTEEN_BIT);
	init_br_regentry(br_regDI,"DI",SIXTEEN_BIT);
	init_br_regentry(br_regSP,"SP",SIXTEEN_BIT);
	init_br_regentry(br_regBP,"BP",SIXTEEN_BIT);
#ifdef SPC386
	init_br_regentry(br_regEAX,"EAX",THIRTY_TWO_BIT);
	init_br_regentry(br_regEBX,"EBX",THIRTY_TWO_BIT);
	init_br_regentry(br_regECX,"ECX",THIRTY_TWO_BIT);
	init_br_regentry(br_regEDX,"EDX",THIRTY_TWO_BIT);
	init_br_regentry(br_regFS,"FS",SIXTEEN_BIT);
	init_br_regentry(br_regGS,"GS",SIXTEEN_BIT);
	init_br_regentry(br_regESI,"ESI",THIRTY_TWO_BIT);
	init_br_regentry(br_regEDI,"EDI",THIRTY_TWO_BIT);
	init_br_regentry(br_regESP,"ESP",THIRTY_TWO_BIT);
	init_br_regentry(br_regEBP,"EBP",THIRTY_TWO_BIT);
#endif
	init_br_regentry(br_regAH,"AH",EIGHT_BIT);
	init_br_regentry(br_regBH,"BH",EIGHT_BIT);
	init_br_regentry(br_regCH,"CH",EIGHT_BIT);
	init_br_regentry(br_regDH,"DH",EIGHT_BIT);
	init_br_regentry(br_regAL,"AL",EIGHT_BIT);
	init_br_regentry(br_regBL,"BL",EIGHT_BIT);
	init_br_regentry(br_regCL,"CL",EIGHT_BIT);
	init_br_regentry(br_regDL,"DL",EIGHT_BIT);

	free_br_regs = &br_regs[0];
	head_br_regs = NULL;

	for (loop=0;loop<(NUM_BR_ENTRIES-1);loop++)
	{
		br_regs[loop].next = &br_regs[loop+1];
		br_regs[loop].handle = loop;
	}
	br_regs[NUM_BR_ENTRIES-1].next = NULL;
	br_structs_initted = TRUE;
}

LOCAL void	set_reg_break IFN3(char*, regstr, IU32,minv, IU32,maxv)
{
	BOOL found;
	BR_REGENTRY *brp;
	USHORT regn;

	if (!br_structs_initted)
		init_br_structs();

	if (free_br_regs == NULL)
	{
		printf("We have run out of register breakpoint entries, try deleting some.\n");
		return;
	}

	found = FALSE;
	regn = 0;
	while (!found && (regn <= br_regDL))
	{
		if (strcmp(br_regdescs[regn].regname,regstr) == 0)
			found = TRUE;
		else
			regn++;
	}

	if (!found)
	{
		printf("unknown register '%s'\n",regstr);
		return;
	}

	brp = free_br_regs;
	free_br_regs = free_br_regs->next;

	brp->next = head_br_regs;
	head_br_regs = brp;

	switch(br_regdescs[regn].size) {
	case EIGHT_BIT :
		brp->minval = minv & 0xff;
		brp->maxval = maxv & 0xff;
		break;

	case SIXTEEN_BIT :
		brp->minval = minv & 0xffff;
		brp->maxval = maxv & 0xffff;
		break;

	case THIRTY_TWO_BIT :
		brp->minval = minv & 0xff;
		brp->maxval = maxv & 0xff;
		break;
	}


	brp->regnum = br_regdescs[regn].regnum;
}

LOCAL	void	clear_reg_break IFN1(char *, regstr)
{
	BOOL found;
	BR_REGENTRY *brp, *last_brp;
	BR_REG regn;
	USHORT dhandle;

	if (strcmp(regstr,"all")==0)
	{
		init_br_structs();
		return;
	}
	
	dhandle = atoi(regstr);

	if (!br_structs_initted || (head_br_regs == NULL))
	{
		printf("no reg breakpoints to clear\n");
		init_br_structs();
		return;
	}

	found = FALSE;
	regn = 0;
	while (!found && (regn <= br_regDL))
	{
		if (strcmp(br_regdescs[regn].regname,regstr) == 0)
			found = TRUE;
		else
			regn++;
	}

	if (found)
	{
		printf("clearing all breakpoints for register '%s'\n",regstr);
		brp = head_br_regs;
		last_brp = NULL;
		while(brp != NULL)
		{
			if (brp->regnum == regn)
			{
				if (last_brp == NULL)
					head_br_regs = brp->next;
				else
					last_brp->next = brp->next;
				brp->next = free_br_regs;
				free_br_regs = brp;
			}
			else
			{
				last_brp = brp;
				brp = brp->next;
			}
		}
	}
	else
	{
		brp = head_br_regs;
		last_brp = NULL;
		while(!found && (brp != NULL))
		{
			if (brp->handle == dhandle)
				found = TRUE;
			else
			{
				last_brp = brp;
				brp = brp->next;
			}
		}
	
		if (!found)
		{
			printf("breakpoint handle %d is not currently active\n",dhandle);
			return;
		}
	
		if (last_brp == NULL)
			head_br_regs = brp->next;
		else
			last_brp->next = brp->next;
		brp->next = free_br_regs;
		free_br_regs = brp;
	}
}

LOCAL	void	print_reg_break IFN0()
{
	BR_REGENTRY *brp;

	if (!br_structs_initted)
	{
		printf("no reg breakpoints to print\n");
		init_br_structs();
		return;
	}

	brp = head_br_regs;
	while(brp != NULL)
	{
		printf("%d:	break if %s is ",brp->handle, br_regdescs[brp->regnum].regname);

		if (brp->minval == brp->maxval)
		{
			printf("%#x\n",brp->minval);
		}
		else
		{
			printf("between %#x and %#x\n",brp->minval,brp->maxval);
		}
		brp = brp->next;
	}
}

LOCAL	BOOL	check_reg_break IFN0()
{
	BR_REGENTRY *brp;
	USHORT val;

	if (!br_structs_initted)
	{
		init_br_structs();
		return(FALSE);
	}

	brp = head_br_regs;
	while(brp != NULL)
	{
		switch(brp->regnum)
		{
		case br_regAX:
			val = getAX();
			break;
		case br_regBX:
			val = getBX();
			break;
		case br_regCX:
			val = getCX();
			break;
		case br_regDX:
			val = getDX();
			break;
		case br_regCS:
			val = getCS();
			break;
		case br_regDS:
			val = getDS();
			break;
		case br_regES:
			val = getES();
			break;
		case br_regSS:
			val = getSS();
			break;
		case br_regSI:
			val = getSI();
			break;
		case br_regDI:
			val = getDI();
			break;
		case br_regSP:
			val = getSP();
			break;
		case br_regBP:
			val = getBP();
			break;
		case br_regAH:
			val = getAH();
			break;
		case br_regBH:
			val = getBH();
			break;
		case br_regCH:
			val = getCH();
			break;
		case br_regDH:
			val = getDH();
			break;
		case br_regAL:
			val = getAL();
			break;
		case br_regBL:
			val = getBL();
			break;
		case br_regCL:
			val = getCL();
			break;
		case br_regDL:
			val = getDL();
			break;
#ifdef SPC386
		case br_regEAX:
			val = getEAX();
			break;
		case br_regEBX:
			val = getEBX();
			break;
		case br_regECX:
			val = getECX();
			break;
		case br_regEDX:
			val = getEDX();
			break;
		case br_regFS:
			val = getFS();
			break;
		case br_regGS:
			val = getGS();
			break;
		case br_regESI:
			val = getESI();
			break;
		case br_regEDI:
			val = getEDI();
			break;
		case br_regESP:
			val = getESP();
			break;
		case br_regEBP:
			val = getEBP();
			break;

#endif /* SPC386 */
		}
		if ((val >= brp->minval) && (val <= brp->maxval))
		{
			printf("register `%s` contains %x !!\n",br_regdescs[brp->regnum].regname,val);
			return(TRUE);
		}
		brp = brp->next;
	}
	return(FALSE);
}

LOCAL	void	set_inst_break IFN5(IU16, cs, LIN_ADDR, ip, LIN_ADDR, len, LIN_ADDR, stop,long, temp)
{
    BPTS *ptr, *freeslot;
    unsigned int i;

    /* Scan used slots for vacant slot */
    for (ptr = freeslot = (BPTS *)0, i = inst_break_count; i--;)
    {
	if (inst[i].valid)
	{
	    /* What if a break range encloses this trace address ? */
	    if (inst[i].cs == cs && inst[i].ip == ip)
		return;
	}
	else
	    /* Keep a record of earliest vacant slot */
	    ptr = inst + i;
    }

    if (!ptr)
    {
	/* No match and no freed slot try for a new one */
	if (inst_break_count >= MAX_TABLE)
	{
	    printf("Location watch table full !!!\n");
	    return;
	}

	/* Next unused slot */
	ptr = inst + inst_break_count++;
    }

    ptr->cs = cs;
    ptr->ip = ip;
    ptr->len = len;
    ptr->start_addr = eff_addr(cs,ip);
    ptr->end_addr = ptr->start_addr + len - 1;
    ptr->stop = stop;	
    ptr->temp = temp;
    ptr->valid = 1;
}

/* Tim did this
set_data_break_bytes IFN4(IS32, cs, LIN_ADDR, ip, LIN_ADDR, len, LIN_ADDR, stop)
{
BPTS *ptr;
	if(data_bytes_break_count >= MAX_TABLE) {
		printf("Location watch table full !!!\n");
		return;
	}
	ptr = &data_bytes[data_bytes_break_count++];
	ptr->cs = cs;
	ptr->ip = ip;
	if (len==0)
		len=1;
	ptr->len = len;
	ptr->start_addr = eff_addr(cs,ip);
	ptr->end_addr = ptr->start_addr + len - 1;
	ptr->stop = stop;	
}
*/

/*
 * set_opcode_break
 *
 * Consider the two byte opcode 0f ab.  The user will have typed 0fab,
 * but when we do our compare against the instruction stream, the 0f will
 * come first, and hence be the LS byte.  Hence we need to swap things.
 * This is nothing to do with host-endianness or BACK_M!
 * This code may not be the prettiest, but I think it's safe.
 */

LOCAL	void	set_opcode_break IFN2(IU32, opcode, IU32, stop)
{
	if(opcode_break_count >= MAX_TABLE) {
		printf("Opcode breakpoint watch table full !!!\n");
		return;
	}
	if (opcode <= 0xff) {
		opcode_breaks[opcode_break_count].mask = 0xff;
		opcode_breaks[opcode_break_count].op = opcode;
	} else if (opcode <= 0xffff) {
		opcode_breaks[opcode_break_count].mask = 0xffff;
		opcode_breaks[opcode_break_count].op =
			((opcode & 0xff00) >> 8) +
			((opcode & 0xff) << 8);
	} else if (opcode <= 0xffffff) {
		opcode_breaks[opcode_break_count].mask = 0xffffff;
		opcode_breaks[opcode_break_count].op =
			((opcode & 0xff0000) >> 16) +
			((opcode & 0xff00)) +
			((opcode & 0xff) << 16);
	} else if (opcode <= 0xffffffff) {
		opcode_breaks[opcode_break_count].mask = 0xffffffff;
		opcode_breaks[opcode_break_count].op =
			((opcode & 0xff000000) >> 24) +
			((opcode & 0xff0000) >> 8) +
			((opcode & 0xff00) << 8) +
			((opcode & 0xff) << 24);
	}
	if (stop)
	    opcode_breaks[opcode_break_count].stop = 1;
	else
	if ((opcode_breaks[opcode_break_count].op & 0xff) == 0xcd)
	    opcode_breaks[opcode_break_count].stop = 2;
	else
	    opcode_breaks[opcode_break_count].stop = 0;
	opcode_break_count++;
}

/*
** called by yoda command bintx <int> <ah>
** set up interrupt number and ah value to break upon
*/
LOCAL	void	set_int_break IFN2(IU8, interrupt_number, IU8, ah )
{
	printf( "Interrupt breakpoint: INT:%lx AH:%lx\n", interrupt_number, ah );
	if(int_break_count >= MAX_TABLE) {
		printf("Interrupt breakpoint watch table full !!!\n");
		return;
	}
	int_breaks[int_break_count][0] = interrupt_number;
	int_breaks[int_break_count][1] = ah;
printf( "i_b[%x] [0]=%lx [1]=%lx\n",
int_break_count, int_breaks[int_break_count][0], int_breaks[int_break_count][1] );
	++int_break_count;
}

LOCAL	void	set_access_break IFN1(int, port)
{
        if(access_break_count >= MAX_TABLE) {
                printf("Access breakpoint table full !!!\n");
                return;
        }
        access_breaks[access_break_count++] = port;
}

/*
** Break on write to specified address range
** Currently allow only one of these breaks as have to store the complete data range.
*/
LOCAL	void	set_host_address_break IFN3(LIN_ADDR, cs, LIN_ADDR, len, LIN_ADDR, stop)

#ifdef DOCUMENTATION
long cs;		/* start address */
long len;		/* length to check */
long stop;		/* stop or trace when changed */
#endif	/* DOCUMENTATION */

{
DATA_BPTS *ptr;
int i;
IU8 *old, *now;

	if(host_address_break_count >= MAX_TABLE_BREAK_WORDS) {
		printf("BREAK on HOST ADDRESS change table full !!\n" );
		return;
	}
	if( len > MAX_BREAK_WORD_RANGE ){
		printf( "Range too big. More training you require.\n" );
		return;
	}
	ptr = &host_addresses[host_address_break_count++];
	ptr->cs = cs;
	ptr->ip = 0;
	ptr->stop = stop;
	ptr->len = len;

	/*
	 * saves Host address and data, will look for a change after every instruction
	 */

	ptr->data_addr = cs;
	now = (IU8 *)ptr->data_addr;
	old = (IU8 *)&ptr->old_value[0];
	for( i=0; i<len; i++ ){
		old[ i ] = now[ i ];
	}
	printf( "Break on host address change set from %lx length %x\n", ptr->data_addr, ptr->len );
}

/*
** Break on write to specified address range
** Currently allow only one of these breaks as have to store the complete data range.
*/
LOCAL	void	set_data_break_words IFN3(LIN_ADDR, cs, LIN_ADDR, len, LIN_ADDR, stop)

#ifdef DOCUMENTATION
long cs;		/* start address */
long len;		/* length to check */
long stop;		/* stop or trace when changed */
#endif	/* DOCUMENTATION */

{
DATA_BPTS *ptr;
int i;

	if(data_words_break_count >= MAX_TABLE_BREAK_WORDS) {
		printf("BREAK on WORD CHANGE table full !!\n" );
		return;
	}
	if( len > MAX_BREAK_WORD_RANGE ){
		printf( "Range too big. More training you require.\n" );
		return;
	}
	ptr = &data_words[data_words_break_count++];
	ptr->stop = stop;
	if (len==0)
		len=1;
	ptr->len = len;

	/*
	 * saves Intel 32-bit address and data, will look for a change after every instruction
	 */

	ptr->data_addr = cs;
	ptr->cs = cs;
	for( i=0; i<len; i++ ){
		ptr->old_value[i] = sas_w_at( (ptr->data_addr)+(i * 2) ) ;
	}
	printf( "Break on word change set from %lx length %lx\n", ptr->data_addr, ptr->len );
}

LOCAL	void	print_inst_break IFN0()
{
int i;
BPTS *ptr;

	for (i=0;i<inst_break_count;i++) {
		ptr = &inst[i];
		printf("%04lx:%04lx+%04lx %lx\n", ptr->cs, ptr->ip, ptr->len,
			ptr->stop);
	}
}

print_data_break_bytes IFN0()
{
int i;
BPTS *ptr;

	for (i=0;i<data_bytes_break_count;i++) {
		ptr = &data_bytes[i];
		printf("%04lx:%04lx+%04lx %lx\n", ptr->cs, ptr->ip, ptr->len,
			ptr->stop);
	}
}

LOCAL	void	print_host_address_breaks IFN0()
{
int i;
DATA_BPTS *ptr;

	for (i=0;i<host_address_break_count;i++) {
		int j;
		IU8 *old;

		ptr = &host_addresses[i];
		old = (IU8 *)&ptr->old_value[0];
		printf("host address change break Len=%04lx", ptr->len );
		for (j = 0; j < ptr->len; j++)
		{
			if ((j & 0x1f) == 0)
				printf("\n\t%08p:", ptr->data_addr + j);
			printf(" %02x", old[ j ]);
		}
		printf("\n");
	}
}

LOCAL	void	print_data_break_words IFN0()
{
int i;
DATA_BPTS *ptr;

	for (i=0;i<data_words_break_count;i++) {
		ptr = &data_words[i];
		printf("Word change break %08lx Len=%04lx\n", ptr->data_addr, ptr->len);
	}
}

LOCAL	void	print_opcode_break IFN0()
{
int i;

	printf("Note instruction streams are reversed\n");
	for (i=0;i<opcode_break_count;i++)
		printf("%04lx\n", opcode_breaks[i].op);
}

/*
** prints the intx break points set by the "bintx" command
*/
LOCAL	void	print_int_break IFN0()
{
	int i;
	for( i=0; i < int_break_count; i++ )
		printf( "int:%lx AH:%lx\n", int_breaks[i][0], int_breaks[i][1] );
}

LOCAL	void	print_access_break IFN0()
{
int i;

	for(i=0;i<access_break_count;i++)
		printf("%04x\n", access_breaks[i]);
}

valid_for_compress IFN2(word, cs, word, ip)
{
	double_word ea;

	ea = ((((double_word)cs)<<4)+((double_word)ip));
	if (ct_no_rom){
		return ((ea < 0xF0000) || (ea >= 0x100000) );
	}else{
		return (1);
	}
}

#if defined(CPU_40_STYLE) && defined(SYNCH_TIMERS)
#ifdef CCPU
#define GLOBAL_PigSynchCount	PigSynchCount
extern IUH PigSynchCount;
#endif	/* !CCPU */
#endif /* CPU_40_STYLE && SYNCH_TIMERS */

#if defined(CPU_40_STYLE) && defined(SYNCH_TIMERS)
LOCAL void ct_get_regs IFN1(IU32 *, regs)
{
	/* Pseudo-hex digits 0 1 2 3 4 5 6 7 8 9 : ; < = > ?  */
	/*   represent       0 1 2 3 4 5 6 7 8 9 A B C D E F  */

					/* +ve -ve */
	/* already written EIP */	/*  `   @  */
	/* already written CS  */	/*  a   A  */
	*regs++ = getDS();		/*  b   B  */
	*regs++ = getES();		/*  c   C  */
	*regs++ = getSS();		/*  d   D  */
	*regs++ = getTR_SELECTOR();	/*  e   E  */
	*regs++ = getLDT_SELECTOR();	/*  f   F  */
	*regs++ = getGDT_BASE();	/*  g   G  */
	*regs++ = getIDT_BASE();	/*  h   H  */
	*regs++ = getEAX();		/*  i   I  */
	*regs++ = getEBX();		/*  j   J  */
	*regs++ = getECX();		/*  k   K  */
	*regs++ = getEDX();		/*  l   L  */
	*regs++ = getESI();		/*  m   M  */
	*regs++ = getEDI();		/*  n   N  */
	*regs++ = getESP();		/*  o   O  */
	*regs++ = getEBP();		/*  p   P  */
	*regs++ = getCR0();		/*  q   R  */
	*regs++ = getFS();		/*  r   R  */
	*regs++ = getGS();		/*  s   S  */
	*regs++ = getCR3(); /* PDBR */	/*  t   T  */
	*regs++ = getCR2(); /* PFLA */	/*  u   U  */
	*regs++ = GLOBAL_PigSynchCount;	/*  w   W  */
	*regs++ = host_q_ev_get_count();/*  x   X  */
	*regs++ = getEFLAGS() & 0xFFFFF72A;/*   Y  */
					/*  z   Z  */
					/*  {   [  */
					/*  |   \  */
					/*  }   ]  */
					/*  ~   ^  */
}
#endif /* CPU_40_STYLE && SYNCH_TIMERS */

#if defined(CPU_40_STYLE) && defined(SYNCH_TIMERS)
LOCAL IBOOL ct_show_reg_diffs IFN4(FILE *, f, IU32 *, good_regs, IU32 *, bad_regs, IU32 *, old_regs)
{
	IBOOL problem = FALSE;
#define test4(name)				\
    {						\
	if (*good_regs != *bad_regs)		\
	{					\
		fprintf(f, "Register %-6s: should be     %04x is     %04x", name, *good_regs, *bad_regs);	\
		if (*bad_regs == *old_regs)	\
			fprintf(f, " (did not change)\n");	\
		else				\
			fprintf(f, " (previous value was %04x)\n", *old_regs);	\
		problem = TRUE;			\
	}					\
	good_regs++;				\
	bad_regs++;				\
	old_regs++;				\
    }
#define test8(name)				\
    {						\
	if (*good_regs != *bad_regs)		\
	{					\
		fprintf(f, "Register %-6s: should be %08x is %08x", name, *good_regs, *bad_regs);	\
		if (*bad_regs == *old_regs)	\
			fprintf(f, " (did not change)\n");	\
		else				\
			fprintf(f, " (previous value was %08x)\n", *old_regs);	\
		problem = TRUE;			\
	}					\
	good_regs++;				\
	bad_regs++;				\
	old_regs++;				\
    }

	/* The order of the items is defined by ct_get_regs() */
	test8("EIP");
	test4("CS");
	test4("DS");
	test4("ES");
	test4("SS");
	test4("TR");
	test4("LDT");
	test8("GDT_BASE");
	test8("IDT_BASE");
	test8("EAX");
	test8("EBX");
	test8("ECX");
	test8("EDX");
	test8("ESI");
	test8("EDI");
	test8("ESP");
	test8("EBP");
	test8("CR0");

	test4("FS");
	test4("GS");
	test8("PDBR");
	test8("PFLA");
	test8("Synchs");
	test8("QevCtr");
	test8("FLAGS&");
	return (problem);
}
#endif /* CPU_40_STYLE && SYNCH_TIMERS */


#define MAX_REGS ('`' - '@')
LOCAL IU32 *ct_next, *ct_last;

LOCAL void ct_initialise IFN0()
{
#if defined(CPU_40_STYLE) && defined(SYNCH_TIMERS)
	SAVED IU32 regs_a[MAX_REGS], regs_b[MAX_REGS];
	int i;

	for (i = 0; i < MAX_REGS; i++)
	{
		regs_a[i] = regs_b[i] = 0;
	}
	ct_next = regs_b;
	ct_last = regs_a;
	ct_line_num = 0;
#endif /* CPU_40_STYLE && SYNCH_TIMERS */
}

#if defined(CPU_40_STYLE) && defined(SYNCH_TIMERS)
LOCAL void ct_make_line IFN3(char *, line, IU32 *, old, IU32 *, new)
{
	IUH diff;
	int i;

	for (i = 0; i < MAX_REGS; i++, old++, new++)
	{
		if (*new == *old)
			continue;
		if (*new > *old)
		{
			if (i == 0)
				; /* This is the usual optimised case -- we use '\n' */
			else
				*line++ = '`' + i;
			diff = *new - *old;
		}
		else
		{
			*line++ = '@' + i;
			diff = *old - *new;
		}
		while (diff)
		{
			/* Dump line as "human" readable pseudo-hex
			 * -- i.e. we dont care that this is backwards
			 */
			*line++ = (diff & 0xf) + '0';
			diff >>= 4;
		}
	}
	*line++ = '\n';
	*line = '\0';
}
#endif /* CPU_40_STYLE && SYNCH_TIMERS */


/* This is the decryption algorithm for the gobblygook produced by the function
 * above. Trust us, it will reconstruct the register set so they can be printed
 * if an error occurs!
 */
#if defined(CPU_40_STYLE) && defined(SYNCH_TIMERS)
LOCAL void ct_read_line IFN3(char *, line, IU32 *, old, IU32 *, new)
{
	IUH diff;
	int i;

	for (i = 0; i < MAX_REGS; i++, old++, new++)
	{
		IBOOL pos;
		IUH val;  /* MUST be unsigned */
		int shift;

		*new = *old;

		if ((*line == '\n') || (*line == 0))
			continue; /* All the rest are the same */

		if ((i == 0) && ((*line - '0') <= 0xF))
		{
			/* A special optimisation for the most common case IP+... */

			pos = TRUE;
			/* Point line at the imaginary '`' which was optimised
			 * when the line was written.
			 */
			line--;
		}
		else if (*line == ('`' + i))
			pos = TRUE;
		else if (*line == ('@' + i))
			pos = FALSE;
		else
			continue;

		/* reverse the pseudo-hex "printing" */
		shift = 0;
		diff = *++line - '0';
		while ((val = (*++line - '0')) <= 0xF)
		{
			shift += 4;
			diff += (val << shift);
		}
		if (pos)
			*new += diff;
		else
			*new -= diff;
	}
}
#endif /* CPU_40_STYLE && SYNCH_TIMERS */


int     tpending = 0;
/*
 * EOR
 */
/*
 * Here it is, check_I, probably one of the most grotty, hacked around functions
 * ever written.  I've (Mike) made an attempt to speed it up a bit, by doing
 * things like vastly reducing the number of accesses to sas (which can be
 * VERY expensive on a 386, and checking whether a for loop needs executing
 * before it starts (might save that variable initialisation!)
 *
 * Please think before you add anything that might slow it down...
 */

#define ACCESS8 ((opcode32 & 0xff00) >> 8)

void check_I IFN0()
{
IU32 i, j;
LIN_ADDR addr;
BPTS *ptr;
DATA_BPTS *dptr;
half_word temp_opcode;
IU16 check_I_cs;
LIN_ADDR check_I_ip;
IU32 opcode32;
IU32 current_opcode;

    /*
     * The guts of the automatic file compare
     */

#if defined(CPU_40_STYLE) && defined(SYNCH_TIMERS)
    if (compress_stream || compare_stream)
    {
	char buff[(MAX_REGS*(1+8))+2];
	IU32 *tmp;

	ct_line_num++;
	if ((ct_line_num & 0xfffff) == 0)
	{
		/* Say still working every 1,000,000 instructions. */
		printf(".");
		fflush(stdout);
	}
	if (ct_line_num <= compare_skip)
	{
		char junk[(MAX_REGS*(1+8))+2];

		/* Junk the line, we wre not there yet... */
		if (fgets(junk, sizeof(junk), compare_stream) == NULL)
		{
			printf("End of compare file at instruction %ld.\n", ct_line_num);
			fclose(compare_stream);
			compare_stream = (FILE *)0;
			compare_skip = 0;
			force_yoda();
		}
		if (ct_line_num == compare_skip)
		{
			char junk[(MAX_REGS*(1+8))+2];

			/* Now set up the last from the current state. */
			ct_last[0] = GetInstructionPointer();
			ct_last[1] = getCS();
			ct_get_regs(&ct_last[2]);
			printf("Compare skip point reached, checking enabled...\n");
		}
		return;
	}
	check_I_cs = getCS();
	check_I_ip = GetInstructionPointer();

	ct_next[0] = check_I_ip;
	ct_next[1] = check_I_cs;
	
	ct_get_regs(&ct_next[2]);
	ct_make_line(buff, ct_last, ct_next);

	if (compress_stream)
		fprintf(compress_stream, "%s", buff);
	if (compare_stream)
	{
		char from_trace[(MAX_REGS*(1+8))+2];

		if (fgets(from_trace, sizeof(from_trace), compare_stream) == NULL)
		{
			printf("End of compare file at instruction %ld.\n", ct_line_num);
			fclose(compare_stream);
			compare_stream = (FILE *)0;
			compare_skip = 0;
			force_yoda();
		}
		else
		if (strcmp(buff, from_trace) != 0)
		{
			IU32 ct_fixup[MAX_REGS];

			ct_read_line(from_trace, ct_last, ct_fixup);

			if (ct_show_reg_diffs(stdout, ct_fixup, ct_next, ct_last))
			{
				printf("\nCompress trace does not match at line %ld.\n", ct_line_num);
				/* Force us to agree, else we will fail all future lines! */
				ct_read_line(from_trace, ct_last, ct_next);

				fflush(compress_stream);
				force_yoda();
				/* It is believed (honest guv) that there is sufficient
				 * information in ct_last[] and prev to "correct" the
				 * registers. I.e We can get into Win/E if it kills us!
				 * It is just necessary to copy ct_fixup to ct_next
				 * and stomp on the registers that differ!
				 */
				ct_make_line(from_trace, ct_last, ct_next);
			}
		}	
		
	}	
	tmp = ct_next;
	ct_next = ct_last;
	ct_last = tmp;
	if ((ct_line_num == compare_break) || (ct_line_num == compress_break))
	{
		printf("\ncompare/compress instruction break encountered\n");
		fflush(compress_stream);
		force_yoda();
	}
    }
#endif /* CPU_40_STYLE && SYNCH_TIMERS */

    /*
     * EOR
     */

    check_I_cs = getCS();
    check_I_ip = GetInstructionPointer();
    addr = eff_addr(check_I_cs, check_I_ip);

#ifdef PCLABS_STATS
    log_stats(addr, sas_hw_at(addr), sas_hw_at(addr+1), sas_hw_at(addr+2));
    return;
#endif

    /* Lets get the next 4 bytes of code */

    opcode32 = sas_dw_at(addr);
    temp_opcode = opcode32 & 0xff;

#ifdef NPX
    if (compress_npx) {
	if (((temp_opcode == 0x26 || temp_opcode == 0x2e || temp_opcode == 0x36 || temp_opcode == 0x3e) &&
	    (ACCESS8 >= 0xd8 && ACCESS8 <= 0xdf)) || (temp_opcode >= 0xd8 && temp_opcode <= 0xdf))
	{
	    do_compress_npx(compress_npx);
	}
    }
#endif	/* NPX */

    /*
     * EOR
     */
    if(inst_mix_count)
	add_inst_mix();

	 if (back_trace_flags)
		 btrace(back_trace_flags);

#ifdef MUST_BLOCK_TIMERS
    if (timer_blocked)
    {
		host_graphics_tick();
    }
#endif /* MUST_BLOCK_TIMERS */

    if (head_br_regs != NULL)
    {
	if (check_reg_break())
		vader = 1;
    }

    host_yoda_check_I_extensions();

    if (vader)
    {
	force_yoda();
	vader = 0;
	set_last_address(check_I_cs, check_I_ip);
	return;
    }

    if ((temp_opcode >= 0xE4) && (temp_opcode <= 0xEF)) {
        if(temp_opcode == 0xE4 || temp_opcode == 0xE5 || temp_opcode == 0xE6 || temp_opcode == 0xE7){
	    /* get port from next argument */
	    for (i=0;i<access_break_count;i++){
		    if((access_breaks[i] < 0x100) && (access_breaks[i] == ACCESS8)){
			    force_yoda();
			    set_last_address(check_I_cs, check_I_ip);
			    return;
		    }
	    }
	}
	else if(temp_opcode == 0xEC || temp_opcode == 0xED || temp_opcode == 0xEE || temp_opcode == 0xEF){
	    /* get port from DX */
	    for (i=0;i<access_break_count;i++){
		    if(access_breaks[i] == getDX()){
			    force_yoda();
			    set_last_address(check_I_cs, check_I_ip);
			    return;
		    }
	    }
	}
    }

    if (int_break_count) {
	/*
	** Check for "bintx" breakpoints.
	*/
	IU8 val;

	val = getAH();
	for( i=0; i < int_break_count; i++ ){
    		if( temp_opcode == 0xCC || temp_opcode == 0xCD || temp_opcode == 0xCF ){
			if((int_breaks[i][0] == sas_hw_at(addr+1)) && (int_breaks[i][1]==val)){
				printf( "BINTX break\n" );
				force_yoda();
				set_last_address(check_I_cs, check_I_ip);
				return;
			}
		}
	}
    }

	/*
	** Check for "btf" breakpoint.
	*/
	if (tf_break_enabled && getTF()){
		printf( "BTF break\n" );
		force_yoda();
		set_last_address(check_I_cs, check_I_ip);
		return;
	}

	/*
	** Check for "bse" breakpoint.
	*/
	if (bse_seg != -1 && last_seg != bse_seg && check_I_cs == bse_seg){
		printf( "Break on entry to segment 0x%04x.\n", bse_seg);
		force_yoda();
		last_seg = check_I_cs;
		set_last_address(check_I_cs, check_I_ip);
		return;
	}
	last_seg = check_I_cs;

    /*
    ** Check for NPX opcode break/tracepoints
    */
    if	(bNPX && (
		    (
	 		(temp_opcode == 0x26 ||
			temp_opcode == 0x2e ||
			temp_opcode == 0x36 ||
			temp_opcode == 0x3e) &&
			(ACCESS8 >= 0xd8 && ACCESS8 <= 0xdf)
		    ) ||
		    (temp_opcode == 0x9b)
		      ||
		    (temp_opcode >= 0xd8 && temp_opcode <= 0xdf)
		)
	)
    {
	{
		if( bNPX_stop )
			force_yoda();
		else
			trace("", trace_type);
		set_last_address(check_I_cs, check_I_ip);
		return;
	}
    }

    if (opcode_break_count) {
	/*
	** Check for opcode breakpoints: 8, 16, 24 or 32 bits.
	*/
	for (i = 0; i < opcode_break_count; i++) {

	    /*
	    ** Check the current opcode against the set of requested break opcodes.
	    ** When "b286-2" mode is ON we get a bit more selective.
	    ** This mode breaks upon instructions that do exist on an 8088 but behave
	    ** differently on an 80286.
	    ** These opcodes are:
	    **       0x54 - push sp, pushes decremented sp
	    **       0xd2 and 0xd3 - shift/rotate only uses low 5 bits of shift count in CL
	    **	 0xf6 and 0xf7 - idiv does not cause exception if quotient 80 or 8000
	    ** Attempt to break when one of these opcodes will behave differently not just when
	    ** they are used because there are lots and lots of shifts and rotates.
	    */

	    if ((opcode32 & opcode_breaks[i].mask) == opcode_breaks[i].op){
		    current_opcode = opcode_breaks[i].op;
		    if( b286_2 ){
			    /*
			    ** Is it a b286_2 group opcode ?
			    */
			    switch( current_opcode ){
			    case 0xd2:
			    case 0xd3:
				    /* shift/rotate */
				    if( (getCL()) > 31 ){
					    /*
					    ** either stop at yoda prompt or print out trace info
					    */
					    if( b286_2_stop )
						    force_yoda();
					    else
						    trace("", trace_type);
					    set_last_address(check_I_cs, check_I_ip);
				    }
				    return;
			    case 0xf6:	/* IDIV byte */
				    if( (getAL()) == 0x80 ){
					    if( b286_2_stop )
						    force_yoda();
					    else
						    trace("", trace_type);
					    set_last_address(check_I_cs, check_I_ip);
				    }
				    return;
			    case 0xf7:	/* IDIV word */
				    if( (getAX()) == 0x8000 ){
					    if( b286_2_stop )
						    force_yoda();
					    else
						    trace("", trace_type);
					    set_last_address(check_I_cs, check_I_ip);
				    }
				    return;
			    case 0x54:	/* PUSH SP */
				    if( b286_2_stop )
					    force_yoda();
				    else
					    trace("", trace_type);
				    set_last_address(check_I_cs, check_I_ip);
				    return;
			    default:
				    /*
				    ** Was not a b286-2 instruction so carry on.
				    */
				    break;
			    } /* end SWITCH */
		    }
		    if( b286_1 ){
			    switch( current_opcode ){
			    case 0x60 : /* push all */
			    case 0x61 : /* pop all */
			    case 0x62 : /* bound */
			    case 0x63 : /* arpl */
			    case 0x64 : /* illegal */
			    case 0x65 : /* illegal */
			    case 0x66 : /* illegal */
			    case 0x67 : /* illegal */
			    case 0x68 : /* push imm w */
			    case 0x69 : /* imul imm w */
			    case 0x6a : /* push imm b */
			    case 0x6b : /* imul imm b */
			    case 0x6c : /* ins b */
			    case 0x6d : /* ins w */
			    case 0x6e : /* outs b*/
			    case 0x6f : /* outs w */
			    case 0xc0 : /* shift imm b */
			    case 0xc1 : /* shift imm w */
			    case 0xc8 : /* enter */
			    case 0xc9 : /* leave */
			    case 0x0f : /* protected mode prefix */
			    case 0xf36c : /* rep prefix for ins and outs */
			    case 0xf36d : /* rep prefix for ins and outs */
			    case 0xf36e : /* rep prefix for ins and outs */
			    case 0xf36f : /* rep prefix for ins and outs */
			    case 0x54 : /* push sp, should not really be in this section but is rarely used */
				    if( b286_2_stop )
					    force_yoda();
				    else
					    trace("", trace_type);
				    set_last_address(check_I_cs, check_I_ip);
				    return;
			    default:
				    /*
				    ** Was not a b286-1 instruction so carry on.
				    */
				    break;
			    } /* end SWITCH */
		    }
#ifdef SPC386
		    if (((current_opcode & 0xffff) == 0x20cd)
			&& getPE() && CsIsBig(check_I_cs))
		    {
			    IU16 service;
			    LIN_ADDR nextip;
			    char *name;
			    struct VMM_services *vmm_ptr;

			    /* This is a Windows VMM call break */

			    nextip = GetInstructionPointer();
			    nextip += dasm((char *)-1, check_I_cs, check_I_ip, 0);
			    service = sas_w_at(effective_addr(check_I_cs, nextip));
			    for (vmm_ptr = VMM_services; vmm_ptr->name; vmm_ptr++)
			    {
				    if (vmm_ptr->value == service)
					    break;
			    }
			    printf("Windows VMM Call %04x %s\n", service, vmm_ptr->name);
		    }
#endif /* SPC386 */
		    /*
		    ** A normal break on opcode so lets break then.
		    */
		    if (opcode_breaks[i].stop == 1)
			force_yoda();
		    else
		    {
			int dbs = disable_bkpt;
			disable_bkpt = 1;
			trace("", trace_type);
			if (opcode_breaks[i].stop == 2)
			{
			    LIN_ADDR nextip;

#ifdef SPC386
			    nextip = GetInstructionPointer();
				    nextip += dasm((char *)-1, (word)getCS(), getEIP(), 0);
#else /* SPC386 */
			    nextip = dasm((char *)-1, (word)1, (word)getCS(), (word)getIP(), (word)1);
#endif /* SPC386 */
			    set_inst_break(getCS(), nextip, 1, 0, 1);
			    disable_timer = 0;
			}
			disable_bkpt = dbs;
		    }
		    set_last_address(check_I_cs, check_I_ip);
		    return;
	    }
	}
    }

    if (int_breakpoint && (temp_opcode == 0xCC || temp_opcode == 0xCD || temp_opcode == 0xCE))
    {
	force_yoda();
	set_last_address(check_I_cs, check_I_ip);
	return;
    }

	if(step_count != -1)
		if(step_count <= 1) {
			disable_bkpt = 0;
			step_count = -1;
			force_yoda();
			set_last_address(check_I_cs, check_I_ip);
			return;
		}	
		else
			step_count--;

	for (i=0;i<inst_break_count;i++) {
		ptr = &inst[i];
		if (!(ptr->valid)) continue;
		if(check_I_cs == ptr->cs && check_I_ip == ptr->ip) {
			if(ptr->stop == 1) {
				if (ptr->temp)
				{
					ptr->valid = 0;
					ptr->temp = 0;
					if (ptr++ == &inst[inst_break_count])
						inst_break_count--;
				}
				force_yoda();
				set_last_address(check_I_cs, check_I_ip);
				return;
			}
			else {
				disable_bkpt = 1;
				trace("", trace_type);
				disable_bkpt = 0;
				set_last_address(check_I_cs, check_I_ip);
				return;
			}
		}
	}

	/*
	** Looking for change at address in HOST space over specified range.
	*/

   if (host_address_break_count) {
	for (i=0;i<host_address_break_count;i++) {
		IU8 *old, *now;
		dptr = &host_addresses[i];

		old = (IU8 *)&dptr->old_value[0];
		now = (IU8 *)dptr->data_addr;
		if (memcmp(old, now, dptr->len) != 0)
		{
			for( j=0; j < dptr->len; j++ ){
				if( old[ j ] != now[ j ] ){
					printf( "host address change at %08p old:%2x new:%2x\n",
					       (IU8 *)((dptr->data_addr)+j),
					       old[ j ],
					       now[ j ]
					       );
				}
			}
			if(dptr->stop) {
				force_yoda();
			}
			else {
				disable_bkpt = 1;
				trace("", trace_type);
				disable_bkpt = 0;
			}
			for( j=0; j < dptr->len; j++ )
				old[ j ] = now[ j ];
			set_last_address(check_I_cs, check_I_ip);
			return;
		}
	}
    }

    if (data_words_break_count) {
	for (i=0;i<data_words_break_count;i++) {
		IBOOL changed = FALSE;

		dptr = &data_words[i];
		for( j=0; j < dptr->len; j++ ){
			if( dptr->old_value[ j ] != sas_w_at( dptr->data_addr + (j * 2)) ){
				printf( "Word change at %lx old:%x new:%x\n",
					(LIN_ADDR)((dptr->data_addr)+(j*2)),
 					dptr->old_value[ j ],
					sas_w_at( (dptr->data_addr)+(j*2) )
				);
				changed = TRUE;
			}
		}
		if (changed) {
			if (dptr->stop) {
				force_yoda();
			}
			else {
				disable_bkpt = 1;
				trace("", trace_type);
				disable_bkpt = 0;
			}
			for( j=0; j < dptr->len; j++ )
				dptr->old_value[ j ] = sas_w_at( (dptr->data_addr)+(j*2) );
			set_last_address(check_I_cs, check_I_ip);
			return;
		}
	}
    }
	if(verbose)
		trace("Instruction Trace", trace_type);

	set_last_address(check_I_cs, check_I_ip);
#if defined(A2CPU) || defined(GISP_CPU)
        if (!fast)
        {
			cpu_interrupt (CPU_YODA_INT, 0);
        }
#endif
}

#ifdef DELTA
void    delta_check_I IFN0()
{
    delta_prompt = 1;
    check_I();
    delta_prompt = 0;
}
#endif /* DELTA */


void check_D IFN2(LIN_ADDR, addr, IS32, len)
{
int i;
BPTS *ptr;
	if(disable_bkpt == 1)
		return;
	for (i=0;i<data_bytes_break_count;i++) {
		ptr = &data_bytes[i];
		if ((addr <= ptr->end_addr && addr >= ptr->start_addr ) ||
		    ((addr + len) <= ptr->end_addr && (addr + len) >= ptr->start_addr ) ||
		    (addr < ptr->start_addr && (addr + len) > ptr->end_addr ))  {
			printf("Mem Address : %08x+%04x b\n", addr, len);
			if(ptr->stop == 1)
				force_yoda();
			else {
				disable_bkpt = 1;
				trace("", trace_type);
				disable_bkpt = 0;
			}
		}
	}
/*	for (i=0;i<data_words_break_count;i++) {
		ptr = &data_words[i];
		if(ptr->end_addr > addr && ptr->start_addr <= addr + len) {
			printf("Mem Address : %08x+%04x w\n", addr,len);
			if(ptr->stop == 1)
				force_yoda();
			else {
				disable_bkpt = 1;
				trace("", trace_type);
				disable_bkpt = 0;
			}
		}
	}*/
}

LOCAL	void	print_inst_mix IFN1(int, key)
{
    int i /*,y*/;

#ifndef SFELLOW
    if (out_stream == NULL)
	out_stream = stdout;
#endif /* !SFELLOW */

    if (key != 0)
        printf("Opcode %x has been called %d times\n", key, inst_mix[key]);
    else
    {
        fprintf(trace_file, "Instruction Mix Dump Start:\n");
        for(i = 0; i < INST_MIX_LENGTH; i++)
          if(inst_mix[i] != 0)
            fprintf(trace_file, "%05x %d\n", i, inst_mix[i]);
        fprintf(trace_file, "Instruction Mix Dump End:\n");
    }
}

LOCAL	void	add_inst_mix IFN0()
{
    LIN_ADDR addr;
    addr = eff_addr( getCS(), GetInstructionPointer() );
    inst_mix[(sas_hw_at(addr) << 8) + sas_hw_at(addr + 1)]++;
}

LOCAL	void	cga_test IFN0()
{
#ifdef SFELLOW
	printf(SfNotImp);
#else /* SFELLOW */
    /*
     * Write test pattern to cga
     */

    sys_addr addr;
    char str[80];
    int num_it, j, bytes, mode;
    char ch;

    addr = 0xb8000L;

    printf("Number of iterations: ");
    gets(str);
    sscanf(str,"%d", &num_it);

    if (num_it == 0)
    {
  	reset();
    }
    else
    {
        printf("Number of bytes per write: ");
        gets(str);
        sscanf(str,"%d", &bytes);

   	if (bytes == 1)
	{
            printf("Use single byte function ? [y/n]: ");
            gets(str);
            sscanf(str,"%c", &ch);

     	    if (ch == 'Y' || ch == 'y')
	        mode = 0;
	    else
	        mode = 1;
	}
	else
	    mode = 1;

	setAH(0);
        setAL(4);
        bop(BIOS_VIDEO_IO);

	switch (mode)
	{
	case 0: for(j = 0; j < num_it; j++)
        	{
	    	    addr = 0xb8000L;
            	    sas_fills(addr, 0, 0x4000);
  	    	    addr = addr + 0x2000;

	    	    addr = 0xb8000L;
            	    sas_fills(addr, 0x55, 0x4000);
  	    	    addr = addr + 0x2000;

	    	    addr = 0xb8000L;
            	    sas_fills(addr, 0xff, 0x4000);
  	    	    addr = addr + 0x2000;
       	        }
		break;
	case 1: for(j = 0; j < num_it; j++)
        	{
	    	    addr = 0xb8000L;
            	    sas_fills(addr, 0, 0x4000);
  	    	    addr = addr + 0x2000;

	    	    addr = 0xb8000L;
            	    sas_fills(addr, 0x55, 0x4000);
  	    	    addr = addr + 0x2000;

	    	    addr = 0xb8000L;
            	    sas_fills(addr, 0xff, 0x4000);
  	    	    addr = addr + 0x2000;
       	        }
	        break;
	}
    }
#endif /* SFELLOW */
}

/*
 * Back trace mode
 * set up info to go into back trace cyclic buffer
 * print current back trace buffer
 */

LOCAL	void	do_back_trace IFN0()
{
char	ans[81];
char	file[80];

	printf("back trace: regs, inst, code, flags, CS:IP, print, status, zero ");

#ifdef DELTA
	printf( "last_dest_addr " );
#endif /* DELTA */

	printf( "\n" );
	printf("Enter: r/i/c/f/C/p/s/Z/l/F ? ");
	gets(ans);
	switch (ans[0]) {
		case 'r': back_trace_flags |= DUMP_REG; break;
		case 'i': back_trace_flags |= DUMP_INST; break;
		case 'c': back_trace_flags |= DUMP_CODE; break;
		case 'f': back_trace_flags |= DUMP_FLAGS; break;
		case 'C': back_trace_flags |= DUMP_CSIP; break;
		case 'p': print_back_trace(); break;
		case 's': printf("back trace flags:%x\n", back_trace_flags);
			 if (back_trace_flags & DUMP_REG) printf ("registers\n");
			 if (back_trace_flags & DUMP_INST) printf ("instructions\n");
			 if (back_trace_flags & DUMP_CODE) printf ("code\n");
			 if (back_trace_flags & DUMP_FLAGS) printf ("flags\n");
			 if (back_trace_flags & DUMP_CSIP) printf ("CS:IP\n");
			 break;
		case 'Z': back_trace_flags = 0; break;
		case 'F':
#ifdef SFELLOW
			printf("F option is not supported on Stringfellows.\n");
#else /* SFELLOW */
	        	printf("file to be written to ? ");
		        gets(file);
        		file_back_trace(file);
#endif /* SFELLOW */
        		break;

#ifdef DELTA
      		case 'l': back_trace_flags |= LAST_DEST; break;
#endif /* DELTA */

		default : printf("bad choice\n");
	}
}

intr IFN0()
{
    /* Control-C has been typed !! */

    vader = 1;
}

yoda_intr IFN1(int, signo)
{
#if	defined(CPU_40_STYLE) && !defined(CCPU)

	EnterDebug("Intr");

#endif	/* CPU_40_STYLE && !CCPU */

#ifndef SFELLOW
    printf("Intercepted signal %d\n", signo);
#endif /* !SFELLOW */

	if (trace_file != stdout)
		printf("Output is redirected to a file\n");

	force_yoda();

#if	defined(CPU_40_STYLE) && !defined(CCPU)

	LeaveDebug();

#endif	/* CPU_40_STYLE && !CCPU */
}

#ifdef NPX
LOCAL	void	do_compress_npx IFN1(FILE *, fp)
{
	int	ip = eff_addr(getCS(), GetInstructionPointer() );
	int	i;
	extern  CHAR   *host_get_287_reg_as_string IPT2(int, reg_no, BOOL, in_nex);
	extern	ULONG	get_287_sp IPT0();
	extern	USHORT	get_287_tag_word IPT0();
	extern	ULONG	get_287_status_word IPT0();
	extern	ULONG	get_287_control_word IPT0();

	ULONG	sw287 = get_287_status_word () | ((get_287_sp() & 0x7) << 11);
	ULONG	cw287 = get_287_control_word ();
	ULONG	tw287 = get_287_tag_word();

        double  register_287;
	char buff[256];

#ifdef SPC386
	dasm(buff, (word)getCS(), (IU32)GetInstructionPointer(), SIXTEEN_BIT);
#else
	dasm((char *)0,(word)0,(word)getCS(), (word)GetInstructionPointer(), (word)1);
#endif /* SPC386 */
	fprintf(fp,"%sc%04x s%04x t%04x", buff, cw287, sw287, tw287);
	for (i=0;i<8;i++)
		fprintf(fp," %s", host_get_287_reg_as_string(i, FALSE));
	fprintf(fp,"\n");
}
#endif	/* NPX */

GLOBAL void	da_block IFN3(IU16, cs, LIN_ADDR, ip, LIN_ADDR, len)
{
	LIN_ADDR loop, loop1;
	half_word ch;
	LIN_ADDR addr;

	if ((len == 0) || (len == YODA_LEN_UNSPECIFIED)) {
		len=0x100;
		if ((cs==0) && (ip==0)) {
			cs=last_da_cs;
			ip=last_da_ip;
		}
	}
	addr = eff_addr(cs,ip);
	if (len >= 16) {
		for (loop=0; loop<=(len-16); loop+=16) {
			if (loop != len) {
				fprintf(trace_file,"%04x:%04x  ",cs,ip+loop);
			}
			for (loop1=0;loop1<16;loop1++) {
				fprintf(trace_file,"%02x ",sas_hw_at(addr+loop+loop1));
			}
			fprintf(trace_file,"   ");
			for (loop1=0;loop1<16;loop1++) {
				ch=sas_hw_at(addr+loop+loop1);
				if ((ch < 32) || (ch >127)) {
					fprintf(trace_file,".");
				} else {
					fprintf(trace_file,"%c",ch);
				}
			}
			if ((loop+16)<len) {
				fprintf(trace_file,"\n");
			}
		}
		len -= loop;
		ip += loop;
		addr = eff_addr(cs,ip);
	}
	if (len >0) {
		fprintf(trace_file,"%04x:%04x  ",cs,ip);
		for (loop=0;loop<len;loop++) {
			fprintf(trace_file,"%02x ",sas_hw_at(addr+loop));
		}
		for (;loop<16;loop++) {
			fprintf(trace_file,"   ");
		}
		fprintf(trace_file,"   ");
		for (loop=0;loop<len;loop++) {
			ch=sas_hw_at(addr+loop);
			if ((ch < 32) || (ch >127)) {
				fprintf(trace_file,".");
			} else {
				fprintf(trace_file,"%c",ch);
			}
		}
	}
	fprintf(trace_file,"\n");
	ip += len;
	if (ip & 0xf0000L) {
		cs += ((ip & 0xf0000L)>>4);
		ip &= 0xffff;
	}
	cs &= 0xffff;
	last_da_cs=cs;
	last_da_ip=ip;
}
#endif /* nPROD */


/*----------------------------------------------------------------------*/
/*		PCLABS STATS						*/
/*----------------------------------------------------------------------*/
#ifdef PCLABS_STATS

#define N 0
#define Y 1

LOCAL UTINY single_byte_instruction[256] = {
/* 0 */	N,N,N,N,	Y,Y,Y,Y,	N,N,N,N,	Y,Y,Y,N,
/* 1 */	N,N,N,N,	Y,Y,Y,Y,	N,N,N,N,	Y,Y,Y,Y,
/* 2 */	N,N,N,N,	Y,Y,Y,Y,	N,N,N,N,	Y,Y,Y,Y,
/* 3 */	N,N,N,N,	Y,Y,Y,Y,	N,N,N,N,	Y,Y,Y,Y,

/* 4 */	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,
/* 5 */	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,
/* 6 */	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,
/* 7 */	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,

/* 8 */	N,N,N,N,	N,N,N,N,	N,N,N,N,	N,N,N,N,
/* 9 */	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,
/* A */	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,
/* B */	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,

/* C */	Y,Y,Y,Y,	N,N,N,N,	Y,Y,Y,Y,	Y,Y,Y,Y,
/* D */	N,N,N,N,	Y,Y,Y,Y,	N,N,N,N,	N,N,N,N,
/* E */	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,	Y,Y,Y,Y,
/* F */	Y,Y,Y,Y,	Y,Y,N,N,	Y,Y,Y,Y,	Y,Y,N,N };

FILE *stats_file;

LOCAL ULONG instr_counts[0x10000];
LOCAL ULONG zerof_instr_counts[0x10000];

LOCAL ULONG es_prefixes;
LOCAL ULONG ss_prefixes;
LOCAL ULONG ds_prefixes;
LOCAL ULONG cs_prefixes;
LOCAL ULONG rep_prefixes;
LOCAL ULONG repe_prefixes;
LOCAL ULONG lock_prefixes;

LOCAL BOOL  was_a_conditional_jump;
LOCAL BOOL  was_a_0f;
LOCAL ULONG previous_addr;
LOCAL ULONG previous_index;


LOCAL BOOL is_it_a_conditional_jump IFN1(ULONG, b1)
{
    if (b1 >= 0x70 && b1 <= 0x7f)
	return (TRUE);
    if (b1 >= 0xe0 && b1 <= 0xe3)
	return (TRUE);
    return (FALSE);
}


LOCAL log_stats IFN4(LIN_ADDR, addr, ULONG, b1, ULONG, b2, ULONG, b3)
{
    BOOL is_a_conditional_jump, is_a_0f;
    ULONG index;

    addr = getCS_BASE() + GetInstructionPointer();

    b1 &= 0xff;
    b2 &= 0xff;
    b3 &= 0xff;

   /* determine instruction key */
   /* ------------------------- */

    is_a_0f = FALSE;
    if (b1 == 0x0f)
    {
	/* 0f case */
	/* ------- */

	is_a_0f = TRUE;
	is_a_conditional_jump = FALSE;
        index = (b2 << 8) | b3;
    }
    else if (b1 == 0x26 || b1 == 0x36 || b1 == 0x2E || b1 == 0x3E ||
             b1 == 0xF2 || b1 == 0xF3 || b1 == 0xF0)
    {
	/* prefix case */
	/* ----------- */

	is_a_conditional_jump = is_it_a_conditional_jump(b2);
	if (single_byte_instruction[b2])
	    index = b2 << 8;
	else
	    index = (b2 << 8) | b3;
	switch (b1)
	{
	    case 0x26:
		es_prefixes++;
		break;

	    case 0x36:
		ss_prefixes++;
		break;

	    case 0x2E:
		ds_prefixes++;
		break;

	    case 0x3E:
		cs_prefixes++;
		break;

	    case 0xF2:
		rep_prefixes++;
		break;

	    case 0xF3:
		repe_prefixes++;
		break;

	    case 0xF0:
		lock_prefixes++;
		break;
	}
    }
    else
    {
	/* non prefix case */
	/* --------------- */

	is_a_conditional_jump = is_it_a_conditional_jump(b1);
	if (single_byte_instruction[b1])
	    index = b1 << 8;
	else
	    index = (b1 << 8) | b2;
    }

    if (was_a_conditional_jump)
    {
	if (addr != (previous_addr + 2))
	    previous_index++;
    }
    if (was_a_0f)
        zerof_instr_counts[previous_index]++;
    else
        instr_counts[previous_index]++;
    previous_index = index;
    previous_addr  = addr;
    was_a_conditional_jump = is_a_conditional_jump;
    was_a_0f = is_a_0f;
}


LOCAL clear_stats IFN0()
{
    ULONG i;
    for (i = 0; i < 0x10000; i++)
    {
	instr_counts[i] = 0;
	zerof_instr_counts[i] = 0;
    }

    es_prefixes = 0;
    ss_prefixes = 0;
    ds_prefixes = 0;
    cs_prefixes = 0;
    rep_prefixes = 0;
    repe_prefixes = 0;
    lock_prefixes = 0;
    was_a_conditional_jump = FALSE;
    was_a_0f = FALSE;
}


struct DISPLAY_COMMAND {
    ULONG	command;
    ULONG	from;
    ULONG	to;
    ULONG	number;
    char	*string;
    char	*group;
};

LOCAL char *previous_group;

#define RANGE	1
#define LOCK	2
#define REPNZ	3
#define REP	4
#define SELMEM	5
#define SELREG	6
#define POINT	7
#define ALLMEM	8
#define ALLREG	9
#define ALL	10
#define SEL5	11
#define ES_PREFIX 	12
#define CS_PREFIX 	13
#define SS_PREFIX 	14
#define DS_PREFIX 	15
#define USE_NORMAL	16
#define USE_ZEROF	17
#define SELALL		18
#define FPINVALID	19

LOCAL struct DISPLAY_COMMAND commands[] = {

    	POINT,	0x7001,	0,	112,	"JO_Ib",	"jcc_Taken",
    	POINT,	0x7101,	0,	113,	"JNO_Ib",	"jcc_Taken",
    	POINT,	0x7201,	0,	114,	"JC_Ib",	"jcc_Taken",
    	POINT,	0x7301,	0,	115,	"JNC_Ib",	"jcc_Taken",
    	POINT,	0x7401,	0,	116,	"JZ_Ib",	"jcc_Taken",
    	POINT,	0x7501,	0,	117,	"JNZ_Ib",	"jcc_Taken",
    	POINT,	0x7601,	0,	118,	"JBE_Ib",	"jcc_Taken",
    	POINT,	0x7701,	0,	119,	"JNBE_Ib",	"jcc_Taken",
    	POINT,	0x7801,	0,	120,	"JS_Ib",	"jcc_Taken",
    	POINT,	0x7901,	0,	121,	"JNS_Ib",	"jcc_Taken",
    	POINT,	0x7A01,	0,	122,	"JP_Ib",	"jcc_Taken",
    	POINT,	0x7B01,	0,	123,	"JNP_Ib",	"jcc_Taken",
    	POINT,	0x7C01,	0,	124,	"JL_Ib",	"jcc_Taken",
    	POINT,	0x7D01,	0,	125,	"JNL_Ib",	"jcc_Taken",
    	POINT,	0x7E01,	0,	126,	"JLE_Ib",	"jcc_Taken",
    	POINT,	0x7F01,	0,	127,	"JNLE_Ib",	"jcc_Taken",
	LOCK,	0,	0,	240,	"LOCK_prefix",	"jcc_Taken",
	REPNZ,	0,	0,	242,	"REPNZ_prefix",	"jcc_Taken",
	REP,	0,	0,	243,	"REP_prefix",	"jcc_Taken",

    	POINT,	0x7000,	0x7000,	112,	"JO_Ib",	"jcc_Ntaken",
    	POINT,	0x7100,	0x7100,	113,	"JNO_Ib",	"jcc_Ntaken",
    	POINT,	0x7200,	0x7200,	114,	"JC_Ib",	"jcc_Ntaken",
    	POINT,	0x7300,	0x7300,	115,	"JNC_Ib",	"jcc_Ntaken",
    	POINT,	0x7400,	0x7400,	116,	"JZ_Ib",	"jcc_Ntaken",
    	POINT,	0x7500,	0x7500,	117,	"JNZ_Ib",	"jcc_Ntaken",
    	POINT,	0x7600,	0x7600,	118,	"JBE_Ib",	"jcc_Ntaken",
    	POINT,	0x7700,	0x7700,	119,	"JNBE_Ib",	"jcc_Ntaken",
    	POINT,	0x7800,	0x7800,	120,	"JS_Ib",	"jcc_Ntaken",
    	POINT,	0x7900,	0x7900,	121,	"JNS_Ib",	"jcc_Ntaken",
    	POINT,	0x7A00,	0x7A00,	122,	"JP_Ib",	"jcc_Ntaken",
    	POINT,	0x7B00,	0x7B00,	123,	"JNP_Ib",	"jcc_Ntaken",
    	POINT,	0x7C00,	0x7C00,	124,	"JL_Ib",	"jcc_Ntaken",
    	POINT,	0x7D00,	0x7D00,	125,	"JNL_Ib",	"jcc_Ntaken",
    	POINT,	0x7E00,	0x7E00,	126,	"JLE_Ib",	"jcc_Ntaken",
    	POINT,	0x7F00,	0x7F00,	127,	"JNLE_Ib",	"jcc_Ntaken",

	POINT,	0xE900,	0xE900,	233,	"JMPn_Iw",	"jump",
	POINT,	0xEB00,	0xEB00,	235,	"JMPn_Ib",	"jump",

	SELMEM,	0xFF00,	0x20,	660,	"JMPn_EA",	"jump_in",
	SELREG,	0xFF00,	0x20,	660,	"JMPn_EA",	"jump_in_r",
	POINT,	0xE800,	0,	232,	"CALLn_Iw",	"call",
	SELMEM,	0xFF00,	0x10,	658,	"CALLn_EA",	"call_in",
	SELREG,	0xFF00,	0x10,	658,	"CALLn_EA",	"call_in_r",
	POINT,	0xC200,	0,	194,	"RET_Is",	"ret",
	POINT,	0xC300,	0,	195,	"RETn",		"ret",

	POINT,	0xE001,	0,	224,	"LOOPNZb_Ib",	"loop/jcx_Taken",
	POINT,	0xE101,	0,	225,	"LOOPNb_Ib",	"loop/jcx_Taken",
	POINT,	0xE201,	0,	226,	"LOOP_Ib",	"loop/jcx_Taken",
	POINT,	0xE301,	0,	227,	"JCXZb_Ib",	"loop/jcx_Taken",
	
	POINT,	0xE000,	0,	224,	"LOOPNZb_Ib",	"loop/jcx_NTaken",
	POINT,	0xE100,	0,	225,	"LOOPNb_Ib",	"loop/jcx_NTaken",
	POINT,	0xE200,	0,	226,	"LOOP_Ib",	"loop/jcx_NTaken",
	POINT,	0xE300,	0,	227,	"JCXZb_Ib",	"loop/jcx_NTaken",
	
	ALLMEM,	0x8800,	0,	136,	"MOVb_R_EA",	"mov_r,m",
	ALLMEM,	0x8900,	0,	137,	"MOVw_R_EA",	"mov_r,m",
	POINT,	0xA200,	0,	162,	"MOVb_AL_EA",	"mov_r,m",
	POINT,	0xA300,	0,	163,	"MOVb_AX_EA",	"mov_r,m",

	ALLREG,	0x8600,	0,	134,	"XCHGb_EA_R",	"mov_r,r",
	ALLREG,	0x8700,	0,	135,	"XCHGw_EA_R",	"mov_r,r",
	ALLREG,	0x8800,	0,	136,	"MOVb_R_EA",	"mov_r,r",
	ALLREG,	0x8900,	0,	137,	"MOVw_R_EA",	"mov_r,r",
	ALLREG,	0x8A00,	0,	138,	"MOVb_EA_R",	"mov_r,r",
	ALLREG,	0x8B00,	0,	139,	"MOVw_EA_R",	"mov_r,r",
	POINT,	0x9100,	0,	145,	"XCHG_CX_AX",	"mov_r,r",
	POINT,	0x9200,	0,	146,	"XCHG_DX_AX",	"mov_r,r",
	POINT,	0x9300,	0,	147,	"XCHG_BX_AX",	"mov_r,r",
	POINT,	0x9400,	0,	148,	"XCHG_SP_AX",	"mov_r,r",
	POINT,	0x9500,	0,	149,	"XCHG_BP_AX",	"mov_r,r",
	POINT,	0x9600,	0,	150,	"XCHG_SI_AX",	"mov_r,r",
	POINT,	0x9700,	0,	151,	"XCHG_DI_AX",	"mov_r,r",

	ALLMEM,	0x8600,	0,	134,	"XCHGb_EA_R",	"mov_m,r",
	ALLMEM,	0x8700,	0,	135,	"XCHGw_EA_R",	"mov_m,r",
	ALLMEM,	0x8A00,	0,	138,	"MOVb_EA_R",	"mov_m,r",
	ALLMEM,	0x8B00,	0,	139,	"MOVw_EA_R",	"mov_m,r",
	POINT,	0xA000,	0,	160,	"MOVb_EA_AL",	"mov_m,r",
	POINT,	0xA100,	0,	161,	"MOVw_EA_AX",	"mov_m,r",

	POINT,	0xB000,	0,	176,	"MOVb_Ib_AL",	"mov_i,r",
	POINT,	0xB100,	0,	177,	"MOVb_Ib_CL",	"mov_i,r",
	POINT,	0xB200,	0,	178,	"MOVb_Ib_DL",	"mov_i,r",
	POINT,	0xB300,	0,	179,	"MOVb_Ib_BL",	"mov_i,r",
	POINT,	0xB400,	0,	180,	"MOVb_Ib_AH",	"mov_i,r",
	POINT,	0xB500,	0,	181,	"MOVb_Ib_CH",	"mov_i,r",
	POINT,	0xB600,	0,	182,	"MOVb_Ib_DH",	"mov_i,r",
	POINT,	0xB700,	0,	183,	"MOVb_Ib_BH",	"mov_i,r",
	POINT,	0xB800,	0,	184,	"MOVw_Iw_AX",	"mov_i,r",
	POINT,	0xB900,	0,	185,	"MOVw_Iw_CX",	"mov_i,r",
	POINT,	0xBA00,	0,	186,	"MOVw_Iw_DX",	"mov_i,r",
	POINT,	0xBB00,	0,	187,	"MOVw_Iw_BX",	"mov_i,r",
	POINT,	0xBC00,	0,	188,	"MOVw_Iw_SP",	"mov_i,r",
	POINT,	0xBD00,	0,	189,	"MOVw_Iw_BP",	"mov_i,r",
	POINT,	0xBE00,	0,	190,	"MOVw_Iw_SI",	"mov_i,r",
	POINT,	0xBF00,	0,	191,	"MOVw_Iw_DI",	"mov_i,r",
	SELREG,	0xC600,	0,	198,	"MOVb_Ib_EA",	"mov_i,r",
	SELREG,	0xC700,	0,	199,	"MOVw_Iw_EA",	"mov_i,r",

	SELMEM,	0xC600,	0,	198,	"MOVb_Ib_EA",	"mov_i,m",
	SELMEM,	0xC700,	0,	199,	"MOVw_Iw_EA",	"mov_i,m",

	POINT,	0x5000,	0,	80,	"PUSHw_AX",	"push_r",
	POINT,	0x5100,	0,	81,	"PUSHw_CX",	"push_r",
	POINT,	0x5200,	0,	82,	"PUSHw_DX",	"push_r",
	POINT,	0x5300,	0,	83,	"PUSHw_BX",	"push_r",
	POINT,	0x5400,	0,	84,	"PUSHw_SP",	"push_r",
	POINT,	0x5500,	0,	85,	"PUSHw_BP",	"push_r",
	POINT,	0x5600,	0,	86,	"PUSHw_SI",	"push_r",
	POINT,	0x5700,	0,	87,	"PUSHw_DI",	"push_r",
	SELREG,	0xFF00,	0x30,	662,	"PUSHw_EA",	"push_r",

	SELMEM,	0xFF00,	0x30,	662,	"PUSHw_EA",	"push_m",

	POINT,	0x6800,	0,	104,	"PUSHw_Iw",	"push_i",
	POINT,	0x6A00,	0,	106,	"PUSHb_Ib",	"push_i",

	POINT,	0x5800,	0,	88,	"POPw_AX",	"pop_r",
	POINT,	0x5900,	0,	89,	"POPw_CX",	"pop_r",
	POINT,	0x5A00,	0,	90,	"POPw_DX",	"pop_r",
	POINT,	0x5B00,	0,	91,	"POPw_BX",	"pop_r",
	POINT,	0x5C00,	0,	92,	"POPw_SP",	"pop_r",
	POINT,	0x5D00,	0,	93,	"POPw_BP",	"pop_r",
	POINT,	0x5E00,	0,	94,	"POPw_SI",	"pop_r",
	POINT,	0x5F00,	0,	95,	"POPw_DI",	"pop_r",
	SELREG,	0x8F00,	0x0,	143,	"POPw_EA",	"pop_r",

	SELMEM,	0x8F00,	0x0,	143,	"POPw_EA",	"pop_m",

	ALLMEM,	0x3800,	0,	56,	"CMPb_R_EA",	"cmp_m,r",
	ALLMEM,	0x3900,	0,	57,	"CMPw_R_EA",	"cmp_m,r",
	ALLMEM,	0x3A00,	0,	58,	"CMPb_EA_R",	"cmp_m,r",
	ALLMEM,	0x3B00,	0,	59,	"CMPw_EA_R",	"cmp_m,r",
	ALLMEM, 0x8400,	0,	132,	"TESTb_R_EA",	"cmp_m,r",
	ALLMEM, 0x8500,	0,	133,	"TESTw_R_EA",	"cmp_m,r",

	ALLREG,	0x3800,	0,	56,	"CMPb_R_EA",	"cmp_r,r",
	ALLREG,	0x3900,	0,	57,	"CMPw_R_EA",	"cmp_r,r",
	ALLREG,	0x3A00,	0,	58,	"CMPb_EA_R",	"cmp_r,r",
	ALLREG,	0x3B00,	0,	59,	"CMPw_EA_R",	"cmp_r,r",
	ALLREG, 0x8400,	0,	132,	"TESTb_R_EA",	"cmp_r,r",
	ALLREG, 0x8500,	0,	133,	"TESTw_R_EA",	"cmp_r,r",

	POINT,	0x3C00,	0,	60,	"CMPb_Ib_AL",	"cmp_i,r",
	POINT,	0x3D00,	0,	61,	"CMPw_Iw_AX",	"cmp_i,r",
	POINT,	0xA800,	0,	168,	"TESTb_Ib_AL",	"cmp_i,r",
	POINT,	0xA900,	0,	169,	"TESTw_Iw_AX",	"cmp_i,r",
	SELREG,	0x8000,	0x38,	519,	"CMPb_Ib_EA",	"cmp_i,r",
	SELREG,	0x8100,	0x38,	527,	"CMPw_Iw_EA",	"cmp_i,r",
	SELREG,	0x8300,	0x38,	543,	"CMPw_Ib_EA",	"cmp_i,r",
	SELREG,	0xF600,	0x0,	632,	"TESTb_Ib_EA",	"cmp_i,r",
	SELREG,	0xF700,	0x0,	640,	"TESTw_Iw_EA",	"cmp_i,r",

	SELMEM,	0x8000,	0x38,	519,	"CMPb_Ib_EA",	"cmp_i,m",
	SELMEM,	0x8100,	0x38,	527,	"CMPw_Iw_EA",	"cmp_i,m",
	SELMEM,	0x8300,	0x38,	543,	"CMPw_Ib_EA",	"cmp_i,m",
	SELMEM,	0xF600,	0x0,	632,	"TESTb_Ib_EA",	"cmp_i,m",
	SELMEM,	0xF700,	0x0,	640,	"TESTw_Iw_EA",	"cmp_i,m",
	
	ALLMEM,	0x0200,	0,	2,	"ADDb_EA_R",	"alu_m,r",
	ALLMEM,	0x0300,	0,	3,	"ADDw_EA_R",	"alu_m,r",
	ALLMEM,	0x0A00,	0,	10,	"ORb_EA_R",	"alu_m,r",
	ALLMEM,	0x0B00,	0,	11,	"ORw_EA_R",	"alu_m,r",
	ALLMEM,	0x1200,	0,	18,	"ADCb_EA_R",	"alu_m,r",
	ALLMEM,	0x1300,	0,	19,	"ADCw_EA_R",	"alu_m,r",
	ALLMEM,	0x1A00,	0,	26,	"SBBb_EA_R",	"alu_m,r",
	ALLMEM,	0x1B00,	0,	27,	"SBBw_EA_R",	"alu_m,r",
	ALLMEM,	0x2200,	0,	34,	"ANDb_EA_R",	"alu_m,r",
	ALLMEM,	0x2300,	0,	35,	"ANDw_EA_R",	"alu_m,r",
	ALLMEM,	0x2A00,	0,	42,	"SUBb_EA_R",	"alu_m,r",
	ALLMEM,	0x2B00,	0,	43,	"SUBw_EA_R",	"alu_m,r",
	ALLMEM,	0x3200,	0,	50,	"XORb_EA_R",	"alu_m,r",
	ALLMEM,	0x3300,	0,	51,	"XORw_EA_R",	"alu_m,r",
	
	ALLREG,	0x0000,	0,	0,	"ADDb_R_EA",	"alu_r,r",
	ALLREG,	0x0100,	0,	1,	"ADDw_R_EA",	"alu_r,r",
	ALLREG,	0x0200,	0,	2,	"ADDb_EA_R",	"alu_r,r",
	ALLREG,	0x0300,	0,	3,	"ADDw_EA_R",	"alu_r,r",
	ALLREG,	0x0800,	0,	8,	"ORb_R_EA",	"alu_r,r",
	ALLREG,	0x0900,	0,	9,	"ORw_R_EA",	"alu_r,r",
	ALLREG,	0x0A00,	0,	10,	"ORb_EA_R",	"alu_r,r",
	ALLREG,	0x0B00,	0,	11,	"ORw_EA_R",	"alu_r,r",
	ALLREG,	0x1000,	0,	16,	"ADCb_R_EA",	"alu_r,r",
	ALLREG,	0x1100,	0,	17,	"ADCw_R_EA",	"alu_r,r",
	ALLREG,	0x1200,	0,	18,	"ADCb_EA_R",	"alu_r,r",
	ALLREG,	0x1300,	0,	19,	"ADCw_EA_R",	"alu_r,r",
	ALLREG,	0x1800,	0,	24,	"SBBb_R_EA",	"alu_r,r",
	ALLREG,	0x1900,	0,	25,	"SBBw_R_EA",	"alu_r,r",
	ALLREG,	0x1A00,	0,	26,	"SBBb_EA_R",	"alu_r,r",
	ALLREG,	0x1B00,	0,	27,	"SBBw_EA_R",	"alu_r,r",
	ALLREG,	0x2000,	0,	32,	"ANDb_R_EA",	"alu_r,r",
	ALLREG,	0x2100,	0,	33,	"ANDw_R_EA",	"alu_r,r",
	ALLREG,	0x2200,	0,	34,	"ANDb_EA_R",	"alu_r,r",
	ALLREG,	0x2300,	0,	35,	"ANDw_EA_R",	"alu_r,r",
	ALLREG,	0x2800,	0,	40,	"SUBb_R_EA",	"alu_r,r",
	ALLREG,	0x2900,	0,	41,	"SUBw_R_EA",	"alu_r,r",
	ALLREG,	0x2A00,	0,	42,	"SUBb_EA_R",	"alu_r,r",
	ALLREG,	0x2B00,	0,	43,	"SUBw_EA_R",	"alu_r,r",
	ALLREG,	0x3000,	0,	48,	"XORb_R_EA",	"alu_r,r",
	ALLREG,	0x3100,	0,	49,	"XORw_R_EA",	"alu_r,r",
	ALLREG,	0x3200,	0,	50,	"XORb_EA_R",	"alu_r,r",
	ALLREG,	0x3300,	0,	51,	"XORw_EA_R",	"alu_r,r",

	ALLMEM,	0x0000,	0,	0,	"ADDb_R_EA",	"alu_r,m",
	ALLMEM,	0x0100,	0,	1,	"ADDw_R_EA",	"alu_r,m",
	ALLMEM,	0x0800,	0,	8,	"ORb_R_EA",	"alu_r,m",
	ALLMEM,	0x0900,	0,	9,	"ORw_R_EA",	"alu_r,m",
	ALLMEM,	0x1000,	0,	16,	"ADCb_R_EA",	"alu_r,m",
	ALLMEM,	0x1100,	0,	17,	"ADCw_R_EA",	"alu_r,m",
	ALLMEM,	0x1800,	0,	24,	"SBBb_R_EA",	"alu_r,m",
	ALLMEM,	0x1900,	0,	25,	"SBBw_R_EA",	"alu_r,m",
	ALLMEM,	0x2000,	0,	32,	"ANDb_R_EA",	"alu_r,m",
	ALLMEM,	0x2100,	0,	33,	"ANDw_R_EA",	"alu_r,m",
	ALLMEM,	0x2800,	0,	40,	"SUBb_R_EA",	"alu_r,m",
	ALLMEM,	0x2900,	0,	41,	"SUBw_R_EA",	"alu_r,m",
	ALLMEM,	0x3000,	0,	48,	"XORb_R_EA",	"alu_r,m",
	ALLMEM,	0x3100,	0,	49,	"XORw_R_EA",	"alu_r,m",

	POINT,	0x0400,	0,	4,	"ADDb_Ib_AL",	"alu_i,r",
	POINT,	0x0500,	0,	5,	"ADDw_Iw_AX",	"alu_i,r",
	POINT,	0x0C00,	0,	12,	"ORb_Ib_AL",	"alu_i,r",
	POINT,	0x0D00,	0,	13,	"ORw_Iw_AX",	"alu_i,r",
	POINT,	0x1400,	0,	20,	"ADCb_Ib_AL",	"alu_i,r",
	POINT,	0x1500,	0,	21,	"ADCw_Iw_AX",	"alu_i,r",
	POINT,	0x1C00,	0,	28,	"SBBb_Ib_AL",	"alu_i,r",
	POINT,	0x1D00,	0,	29,	"SBBw_Iw_AX",	"alu_i,r",
	POINT,	0x2400,	0,	36,	"ANDb_Ib_AL",	"alu_i,r",
	POINT,	0x2500,	0,	37,	"ANDw_Iw_AX",	"alu_i,r",
	POINT,	0x2C00,	0,	44,	"SUBb_Ib_AL",	"alu_i,r",
	POINT,	0x2D00,	0,	45,	"SUBw_Iw_AX",	"alu_i,r",
	POINT,	0x3400,	0,	52,	"XORb_Ib_AL",	"alu_i,r",
	POINT,	0x3500,	0,	53,	"XORw_Iw_AX",	"alu_i,r",
	SELREG,	0x8000,	0x0,	512,	"ADDb_Ib_EA",	"alu_i,r",
	SELREG,	0x8000,	0x8,	513,	"ORb_Ib_EA",	"alu_i,r",
	SELREG,	0x8000,	0x10,	514,	"ADCb_Ib_EA",	"alu_i,r",
	SELREG,	0x8000,	0x18,	515,	"SBBb_Ib_EA",	"alu_i,r",
	SELREG,	0x8000,	0x20,	516,	"ANDb_Ib_EA",	"alu_i,r",
	SELREG,	0x8000,	0x28,	517,	"SUBb_Ib_EA",	"alu_i,r",
	SELREG,	0x8000,	0x30,	518,	"XORb_Ib_EA",	"alu_i,r",
	SELREG,	0x8100,	0x0,	520,	"ADDw_Iw_EA",	"alu_i,r",
	SELREG,	0x8100,	0x8,	521,	"ORw_Iw_EA",	"alu_i,r",
	SELREG,	0x8100,	0x10,	522,	"ADCw_Iw_EA",	"alu_i,r",
	SELREG,	0x8100,	0x18,	523,	"SBBw_Iw_EA",	"alu_i,r",
	SELREG,	0x8100,	0x20,	524,	"ANDw_Iw_EA",	"alu_i,r",
	SELREG,	0x8100,	0x28,	525,	"SUBw_Iw_EA",	"alu_i,r",
	SELREG,	0x8100,	0x30,	526,	"XORw_Iw_EA",	"alu_i,r",
	SELREG,	0x8300,	0x0,	536,	"ADDw_Ib_EA",	"alu_i,r",
	SELREG,	0x8300,	0x8,	537,	"ORw_Ib_EA",	"alu_i,r",
	SELREG,	0x8300,	0x10,	538,	"ADCw_Ib_EA",	"alu_i,r",
	SELREG,	0x8300,	0x18,	539,	"SBBw_Ib_EA",	"alu_i,r",
	SELREG,	0x8300,	0x20,	540,	"ANDw_Ib_EA",	"alu_i,r",
	SELREG,	0x8300,	0x28,	541,	"SUBw_Ib_EA",	"alu_i,r",
	SELREG,	0x8300,	0x30,	542,	"XORw_Ib_EA",	"alu_i,r",

	SELMEM,	0x8000,	0x0,	512,	"ADDb_Ib_EA",	"alu_i,m",
	SELMEM,	0x8000,	0x8,	513,	"ORb_Ib_EA",	"alu_i,m",
	SELMEM,	0x8000,	0x10,	514,	"ADCb_Ib_EA",	"alu_i,m",
	SELMEM,	0x8000,	0x18,	515,	"SBBb_Ib_EA",	"alu_i,m",
	SELMEM,	0x8000,	0x20,	516,	"ANDb_Ib_EA",	"alu_i,m",
	SELMEM,	0x8000,	0x28,	517,	"SUBb_Ib_EA",	"alu_i,m",
	SELMEM,	0x8000,	0x30,	518,	"XORb_Ib_EA",	"alu_i,m",
	SELMEM,	0x8100,	0x0,	520,	"ADDw_Iw_EA",	"alu_i,m",
	SELMEM,	0x8100,	0x8,	521,	"ORw_Iw_EA",	"alu_i,m",
	SELMEM,	0x8100,	0x10,	522,	"ADCw_Iw_EA",	"alu_i,m",
	SELMEM,	0x8100,	0x18,	523,	"SBBw_Iw_EA",	"alu_i,m",
	SELMEM,	0x8100,	0x20,	524,	"ANDw_Iw_EA",	"alu_i,m",
	SELMEM,	0x8100,	0x28,	525,	"SUBw_Iw_EA",	"alu_i,m",
	SELMEM,	0x8100,	0x30,	526,	"XORw_Iw_EA",	"alu_i,m",
	SELMEM,	0x8300,	0x0,	536,	"ADDw_Ib_EA",	"alu_i,m",
	SELMEM,	0x8300,	0x8,	537,	"ORw_Ib_EA",	"alu_i,m",
	SELMEM,	0x8300,	0x10,	538,	"ADCw_Ib_EA",	"alu_i,m",
	SELMEM,	0x8300,	0x18,	539,	"SBBw_Ib_EA",	"alu_i,m",
	SELMEM,	0x8300,	0x20,	540,	"ANDw_Ib_EA",	"alu_i,m",
	SELMEM,	0x8300,	0x28,	541,	"SUBw_Ib_EA",	"alu_i,m",
	SELMEM,	0x8300,	0x30,	542,	"XORw_Ib_EA",	"alu_i,m",
	
	POINT,	0x4000,	0,	64,	"INCw_AX",	"alu_r",
	POINT,	0x4100,	0,	65,	"INCw_CX",	"alu_r",
	POINT,	0x4200,	0,	66,	"INCw_DX",	"alu_r",
	POINT,	0x4300,	0,	67,	"INCw_BX",	"alu_r",
	POINT,	0x4400,	0,	68,	"INCw_SP",	"alu_r",
	POINT,	0x4500,	0,	69,	"INCw_BP",	"alu_r",
	POINT,	0x4600,	0,	70,	"INCw_SI",	"alu_r",
	POINT,	0x4700,	0,	71,	"INCw_DI",	"alu_r",
	POINT,	0x4800,	0,	72,	"DECw_AX",	"alu_r",
	POINT,	0x4900,	0,	73,	"DECw_CX",	"alu_r",
	POINT,	0x4A00,	0,	74,	"DECw_DX",	"alu_r",
	POINT,	0x4B00,	0,	75,	"DECw_BX",	"alu_r",
	POINT,	0x4C00,	0,	76,	"DECw_SP",	"alu_r",
	POINT,	0x4D00,	0,	77,	"DECw_BP",	"alu_r",
	POINT,	0x4E00,	0,	78,	"DECw_SI",	"alu_r",
	POINT,	0x4F00,	0,	79,	"DECw_DI",	"alu_r",
	POINT,	0x9800,	0,	152,	"CBW",		"alu_r",
	POINT,	0x9900,	0,	153,	"CBD",		"alu_r",
	SELREG,	0xF600,	0x10,	634,	"NOTb_EA",	"alu_r",
	SELREG,	0xF600,	0x18,	635,	"NEGb_EA",	"alu_r",
	SELREG,	0xF700,	0x10,	642,	"NOTw_EA",	"alu_r",
	SELREG,	0xF700,	0x18,	643,	"NEGw_EA",	"alu_r",
	SELREG,	0xFE00,	0x0,	648,	"INCb_EA",	"alu_r",
	SELREG,	0xFE00,	0x8,	649,	"DECb_EA",	"alu_r",
	SELREG,	0xFF00,	0x0,	656,	"INCw_EA",	"alu_r",
	SELREG,	0xFF00,	0x8,	657,	"DECw_EA",	"alu_r",

	SELMEM,	0xF600,	0x10,	634,	"NOTb_EA",	"alu_m",
	SELMEM,	0xF600,	0x18,	635,	"NEGb_EA",	"alu_m",
	SELMEM,	0xF700,	0x10,	642,	"NOTw_EA",	"alu_m",
	SELMEM,	0xF700,	0x18,	643,	"NEGw_EA",	"alu_m",
	SELMEM,	0xFE00,	0x0,	648,	"INCb_EA",	"alu_m",
	SELMEM,	0xFE00,	0x8,	649,	"DECb_EA",	"alu_m",
	SELMEM,	0xFF00,	0x0,	656,	"INCw_EA",	"alu_m",
	SELMEM,	0xFF00,	0x8,	657,	"DECw_EA",	"alu_m",

	ALL,	0x8D00,	0,	141,	"LEAw_EA_R",	"lea",

	POINT,	0x9000,	0,	144,	"NOP",		"nop",

	ALL,	0x6900,	0,	105,	"IMULw_EA_Iw_R","mul",
	ALL,	0x6B00,	0,	107,	"IMULb_EA_Ib_R","mul",
	SELALL,	0xF600,	0x20,	636,	"MULb_EA",	"mul",
	SELALL,	0xF600,	0x28,	637,	"IMULb_EA",	"mul",
	SELALL,	0xF700,	0x20,	644,	"MULw_EA",	"mul",
	SELALL,	0xF700,	0x28,	645,	"IMULw_EA",	"mul",

	SELALL,	0xF600,	0x30,	638,	"DIVb_EA",	"div",
	SELALL,	0xF600,	0x38,	639,	"IDIVb_EA",	"div",
	SELALL,	0xF700,	0x30,	646,	"DIVw_EA",	"div",
	SELALL,	0xF700,	0x38,	647,	"IDIVw_EA",	"div",
	
	POINT,	0x2700,	0,	39,	"DAA",		"ascii/dec",
	POINT,	0x2F00,	0,	47,	"DAS",		"ascii/dec",
	POINT,	0x3700,	0,	55,	"AAA",		"ascii/dec",
	POINT,	0x3F00,	0,	63,	"AAS",		"ascii/dec",
	POINT,	0xD400,	0,	212,	"AAM",		"ascii/dec",
	POINT,	0xD500,	0,	213,	"AAD",		"ascii/dec",
	
	SELALL,	0xD000,	0x00,	600,	"ROLb_1_EA",	"sh_rot_1",
	SELALL,	0xD000,	0x08,	601,	"RORb_1_EA",	"sh_rot_1",
	SELALL,	0xD000,	0x20,	604,	"SHLb_1_EA",	"sh_rot_1",
	SELALL,	0xD000,	0x28,	605,	"SHRb_1_EA",	"sh_rot_1",
	SELALL,	0xD000,	0x38,	607,	"SARb_1_EA",	"sh_rot_1",
	SELALL,	0xD100,	0x00,	608,	"ROLw_1_EA",	"sh_rot_1",
	SELALL,	0xD100,	0x08,	609,	"RORw_1_EA",	"sh_rot_1",
	SELALL,	0xD100,	0x20,	612,	"SHLw_1_EA",	"sh_rot_1",
	SELALL,	0xD100,	0x28,	613,	"SHRw_1_EA",	"sh_rot_1",
	SELALL,	0xD100,	0x38,	615,	"SARw_1_EA",	"sh_rot_1",

	SELALL,	0xC000,	0x00,	568,	"ROLb_Ib_EA",	"sh_rot_i",
	SELALL,	0xC000,	0x08,	569,	"RORb_Ib_EA",	"sh_rot_i",
	SELALL,	0xC000,	0x20,	572,	"SHLb_Ib_EA",	"sh_rot_i",
	SELALL,	0xC000,	0x28,	573,	"SHRb_Ib_EA",	"sh_rot_i",
	SELALL,	0xC000,	0x38,	575,	"SARb_Ib_EA",	"sh_rot_i",
	SELALL,	0xC100,	0x00,	576,	"ROLw_Ib_EA",	"sh_rot_i",
	SELALL,	0xC100,	0x08,	577,	"RORw_Ib_EA",	"sh_rot_i",
	SELALL,	0xC100,	0x20,	580,	"SHLw_Ib_EA",	"sh_rot_i",
	SELALL,	0xC100,	0x28,	581,	"SHRw_Ib_EA",	"sh_rot_i",
	SELALL,	0xC100,	0x38,	583,	"SARw_Ib_EA",	"sh_rot_i",

	SELALL,	0xD200,	0x00,	616,	"ROLb_CL_EA",	"sh_rot_cl",
	SELALL,	0xD200,	0x08,	617,	"RORb_CL_EA",	"sh_rot_cl",
	SELALL,	0xD200,	0x20,	620,	"SHLb_CL_EA",	"sh_rot_cl",
	SELALL,	0xD200,	0x28,	621,	"SHRb_CL_EA",	"sh_rot_cl",
	SELALL,	0xD200,	0x38,	623,	"SARb_CL_EA",	"sh_rot_cl",
	SELALL,	0xD300,	0x00,	624,	"ROLw_CL_EA",	"sh_rot_cl",
	SELALL,	0xD300,	0x08,	625,	"RORw_CL_EA",	"sh_rot_cl",
	SELALL,	0xD300,	0x20,	628,	"SHLw_CL_EA",	"sh_rot_cl",
	SELALL,	0xD300,	0x28,	629,	"SHRw_CL_EA",	"sh_rot_cl",
	SELALL,	0xD300,	0x38,	631,	"SARw_CL_EA",	"sh_rot_cl",

	SELALL,	0xD000,	0x10,	602,	"RCLb_1_EA",	"sh_rot_c_1",
	SELALL,	0xD000,	0x18,	603,	"RCRb_1_EA",	"sh_rot_c_1",
	SELALL,	0xD100,	0x10,	610,	"RCLw_1_EA",	"sh_rot_c_1",
	SELALL,	0xD100,	0x18,	611,	"RCRw_1_EA",	"sh_rot_c_1",

	SELALL,	0xC000,	0x10,	570,	"RCLb_Ib_EA",	"sh_rot_c_i",
	SELALL,	0xC000,	0x18,	571,	"RCRb_Ib_EA",	"sh_rot_c_i",
	SELALL,	0xC100,	0x10,	578,	"RCLw_Ib_EA",	"sh_rot_c_i",
	SELALL,	0xC100,	0x18,	579,	"RCRw_Ib_EA",	"sh_rot_c_i",

	SELALL,	0xD200,	0x10,	618,	"RCLb_CL_EA",	"sh_rot_c_cl",
	SELALL,	0xD200,	0x18,	619,	"RCRb_CL_EA",	"sh_rot_c_cl",
	SELALL,	0xD300,	0x10,	626,	"RCLw_CL_EA",	"sh_rot_c_cl",
	SELALL,	0xD300,	0x18,	627,	"RCRw_CL_EA",	"sh_rot_c_cl",

	POINT,	0xCC00,	0,	204,	"INT_3",	"int",
	POINT,	0xCD00,	0,	205,	"INT_TYPE",	"int",
	POINT,	0xCE00,	0,	206,	"INTO",		"int",
	POINT,	0xCF00,	0,	207,	"IRETf",	"int",
	
	POINT,	0x9E00,	0,	158,	"SAHF",		"flag",
	POINT,	0x9F00,	0,	159,	"LAHF",		"flag",
	POINT,	0xF500,	0,	245,	"CMC",		"flag",
	POINT,	0xF800,	0,	248,	"CLC",		"flag",
	POINT,	0xF900,	0,	249,	"STC",		"flag",
	POINT,	0xFC00,	0,	252,	"CLD",		"flag",
	POINT,	0xFD00,	0,	253,	"STD",		"flag",

	SELALL,	0xD800,	0x00,	688,	"FADDs_EA",	"fp",
	SELALL,	0xD800,	0x08,	689,	"FMULs_EA",	"fp",
	SELALL,	0xD800,	0x10,	690,	"FCOMs_EA",	"fp",
	SELALL,	0xD800,	0x18,	691,	"FCOMPs_EA",	"fp",
	SELALL,	0xD800,	0x20,	692,	"FSUBs_EA",	"fp",
	SELALL,	0xD800,	0x28,	693,	"FSUBRs_EA",	"fp",
	SELALL,	0xD800,	0x30,	694,	"FDIVs_EA",	"fp",
	SELALL,	0xD800,	0x38,	695,	"FDIVRs_EA",	"fp",

	SEL5,	0xD800,	0xC0,	696,	"FADD_Si_S0",	"fp",
	SEL5,	0xD800,	0xC8,	697,	"FMUL_Si_S0",	"fp",
	SEL5,	0xD800,	0xD0,	698,	"FCOM_Si_S0",	"fp",
	SEL5,	0xD800,	0xD8,	699,	"FCOMP_Si_S0",	"fp",
	SEL5,	0xD800,	0xE0,	700,	"FSUB_Si_S0",	"fp",
	SEL5,	0xD800,	0xE8,	701,	"FSUBR_Si_S0",	"fp",
	SEL5,	0xD800,	0xF0,	702,	"FDIV_Si_S0",	"fp",
	SEL5,	0xD800,	0xF8,	703,	"FDIVR_Si_S0",	"fp",

	SELALL,	0xDA00,	0x00,	704,	"FIADDs_EA",	"fp",
	SELALL,	0xDA00,	0x08,	705,	"FIMULs_EA",	"fp",
	SELALL,	0xDA00,	0x10,	706,	"FICOMs_EA",	"fp",
	SELALL,	0xDA00,	0x18,	707,	"FICOMPs_EA",	"fp",
	SELALL,	0xDA00,	0x20,	708,	"FISUBs_EA",	"fp",
	SELALL,	0xDA00,	0x28,	709,	"FISUBRs_EA",	"fp",
	SELALL,	0xDA00,	0x30,	710,	"FIDIVs_EA",	"fp",
	SELALL,	0xDA00,	0x38,	711,	"FIDIVRs_EA",	"fp",

	FPINVALID,0,	0,	712,	"FP_INVALID",	"fp",

	POINT,	0xDED9,	0,	713,	"FUCOMPP",	"fp",
	
	SELALL,	0xDB00,	0x00,	720,	"FILDs_EA",	"fp",
	SELALL,	0xDB00,	0x10,	722,	"FISTs_EA",	"fp",
	SELALL,	0xDB00,	0x18,	723,	"FISTPs_EA",	"fp",
	SELALL,	0xDB00,	0x28,	725,	"FLDer_EA",	"fp",
	SELALL,	0xDB00,	0x38,	727,	"FSTPer_EA",	"fp",

	POINT,	0xDBE0,	0,	728,	"FENI_1",	"fp",
	POINT,	0xDBE1,	0,	729,	"FDISI_2",	"fp",
	POINT,	0xDBE2,	0,	730,	"FCLEX",	"fp",
	POINT,	0xDBE3,	0,	731,	"FINIT",	"fp",
	POINT,	0xDBE4,	0,	732,	"FSETPM",	"fp",

	SELALL,	0xDC00,	0x00,	736,	"FADDl_EA",	"fp",
	SELALL,	0xDC00,	0x08,	737,	"FMULl_EA",	"fp",
	SELALL,	0xDC00,	0x10,	738,	"FCOMl_EA",	"fp",
	SELALL,	0xDC00,	0x18,	739,	"FCOMPl_EA",	"fp",
	SELALL,	0xDC00,	0x20,	740,	"FSUBl_EA",	"fp",
	SELALL,	0xDC00,	0x28,	741,	"FSUBRl_EA",	"fp",
	SELALL,	0xDC00,	0x30,	742,	"FDIVl_EA",	"fp",
	SELALL,	0xDC00,	0x38,	743,	"FDIVRl_EA",	"fp",

	SEL5,	0xDC00,	0xC0,	744,	"FADD_S0_Si",	"fp",
	SEL5,	0xDC00,	0xC8,	745,	"FMUL_S0_Si",	"fp",
	SEL5,	0xDC00,	0xD0,	746,	"FCOM_2_S0_Si","fp",
	SEL5,	0xDC00,	0xD8,	747,	"FCOMP_3_S0_Si","fp",
	SEL5,	0xDC00,	0xE0,	748,	"FSUB_S0_Si",	"fp",
	SEL5,	0xDC00,	0xE8,	749,	"FSUBR_S0_Si",	"fp",
	SEL5,	0xDC00,	0xF0,	750,	"FDIV_S0_Si",	"fp",
	SEL5,	0xDC00,	0xF8,	751,	"FDIVR_S0_Si",	"fp",
		
	SELALL,	0xDD00,	0x00,	752,	"FLDl_EA",	"fp",
	SELALL,	0xDD00,	0x10,	754,	"FSTl_EA",	"fp",
	SELALL,	0xDD00,	0x18,	755,	"FSTPl_EA",	"fp",
	SELALL,	0xDD00,	0x20,	756,	"FRSTOR_EA",	"fp",
	SELALL,	0xDD00,	0x30,	758,	"FSAVE_EA",	"fp",
	SELALL,	0xDD00,	0x38,	759,	"FSTSW_EA",	"fp",

	SEL5,	0xDD00,	0xC0,	760,	"FFREE_Si",	"fp",
	SEL5,	0xDD00,	0xC8,	761,	"FXCH_4_Si_S0",	"fp",
	SEL5,	0xDD00,	0xD0,	762,	"FSTl_Si",	"fp",
	SEL5,	0xDD00,	0xD8,	763,	"FSTPl_Si",	"fp",
	
	SELALL,	0xDE00,	0x00,	768,	"FIADDw_EA",	"fp",
	SELALL,	0xDE00,	0x08,	769,	"FIMULw_EA",	"fp",
	SELALL,	0xDE00,	0x10,	770,	"FICOMw_EA",	"fp",
	SELALL,	0xDE00,	0x18,	771,	"FICOMPw_EA",	"fp",
	SELALL,	0xDE00,	0x20,	772,	"FISUBw_EA",	"fp",
	SELALL,	0xDE00,	0x28,	773,	"FISUBRw_EA",	"fp",
	SELALL,	0xDE00,	0x30,	774,	"FIDIVw_EA",	"fp",
	SELALL,	0xDE00,	0x38,	775,	"FIDIVRw_EA",	"fp",
	
	SEL5,	0xDE00,	0xC0,	776,	"FADDP_Si_S0",	"fp",
	SEL5,	0xDE00,	0xC8,	777,	"FMULP_Si_S0",	"fp",
	SEL5,	0xDE00,	0xD0,	778,	"FCOMP_5_Si_S0","fp",
	POINT,	0xDED9,	0,	779,	"FCOMPP_Si_S0",	"fp",
	SEL5,	0xDE00,	0xE0,	780,	"FSUBRP_Si_S0",	"fp",
	SEL5,	0xDE00,	0xE8,	781,	"FSUBP_Si_S0",	"fp",
	SEL5,	0xDE00,	0xF0,	782,	"FDIVRP_Si_S0",	"fp",
	SEL5,	0xDE00,	0xF8,	783,	"FDIVP_Si_S0",	"fp",
	
	SELALL,	0xDF00,	0x00,	784,	"FILDw_EA",	"fp",
	SELALL,	0xDF00,	0x10,	786,	"FISTw_EA",	"fp",
	SELALL,	0xDF00,	0x18,	787,	"FISTPw_EA",	"fp",
	SELALL,	0xDF00,	0x20,	788,	"FBLD_EA",	"fp",
	SELALL,	0xDF00,	0x28,	789,	"FILDl_EA",	"fp",
	SELALL,	0xDF00,	0x30,	790,	"FBSTP_EA",	"fp",
	SELALL,	0xDF00,	0x38,	791,	"FISTPl_EA",	"fp",

	SEL5,	0xDF00,	0xC0,	792,	"FFREE_6_Si",	"fp",
	SEL5,	0xDF00,	0xC8,	793,	"FXCH_7_S0_Si",	"fp",
	SEL5,	0xDF00,	0xD0,	794,	"FSTP_8_Si","fp",
	SEL5,	0xDF00,	0xD8,	795,	"FSTP_9_Si","fp",
	POINT,	0xDFE0,	0,	796,	"FSTSW_AX",	"fp",

	SELALL,	0xD900,	0x00,	800,	"FLDs_EA",	"fp",
	SELALL,	0xD900,	0x10,	802,	"FSTs_EA",	"fp",
	SELALL,	0xD900,	0x18,	803,	"FSTPs_EA",	"fp",
	SELALL,	0xD900,	0x20,	804,	"FLDENV_EA",	"fp",
	SELALL,	0xD900,	0x28,	805,	"FLDCW_EA",	"fp",
	SELALL,	0xD900,	0x30,	806,	"FSTENV_EA",	"fp",
	SELALL,	0xD900,	0x38,	807,	"FSTCW_EA",	"fp",

	SEL5,	0xD900,	0xC0,	808,	"FLD_Si",	"fp",
	SEL5,	0xD900,	0xC8,	809,	"FXCH_Si_S0",	"fp",
	POINT,	0xD9D0,	0,	810,	"FNOP",		"fp",
	SEL5,	0xD900,	0xD8,	811,	"FSTP_1_Si",	"fp",
	POINT,	0xD9E0,	0,	812,	"FCHS",		"fp",
	POINT,	0xD9E1,	0,	813,	"FABS",		"fp",
	POINT,	0xD9E4,	0,	814,	"FTST",		"fp",
	POINT,	0xD9E5,	0,	815,	"FXAM",		"fp",
	POINT,	0xD9E8,	0,	816,	"FLD1",		"fp",
	POINT,	0xD9E9,	0,	817,	"FLDL2T",	"fp",
	POINT,	0xD9EA,	0,	818,	"FLDL2E",	"fp",
	POINT,	0xD9EB,	0,	819,	"FLDLPI",	"fp",
	POINT,	0xD9EC,	0,	820,	"FLDLG2",	"fp",
	POINT,	0xD9ED,	0,	821,	"FLDLN2",	"fp",
	POINT,	0xD9EE,	0,	822,	"FLDZ",		"fp",
	POINT,	0xD9F0,	0,	824,	"F2XM1",	"fp",
	POINT,	0xD9F1,	0,	825,	"FYL2X",	"fp",
	POINT,	0xD9F2,	0,	826,	"FPTAN",	"fp",
	POINT,	0xD9F3,	0,	827,	"FPATAN",	"fp",
	POINT,	0xD9F4,	0,	828,	"FXTRACT",	"fp",
	POINT,	0xD9F5,	0,	829,	"FPREM1",	"fp",
	POINT,	0xD9F6,	0,	830,	"FDECSTP",	"fp",
	POINT,	0xD9F7,	0,	831,	"FINCSTP",	"fp",
	POINT,	0xD9F8,	0,	832,	"FPREM",	"fp",
	POINT,	0xD9F9,	0,	833,	"FYL2XP1",	"fp",
	POINT,	0xD9FA,	0,	834,	"FSQRT",	"fp",
	POINT,	0xD9FB,	0,	835,	"FSINCOS",	"fp",
	POINT,	0xD9FC,	0,	836,	"FRNDINT",	"fp",
	POINT,	0xD9FD,	0,	837,	"F_SCALE",	"fp",
	POINT,	0xD9FE,	0,	838,	"FSIN",		"fp",
	POINT,	0xD9FF,	0,	839,	"FCOS",		"fp",

	POINT,	0x9B00,	0,	155,	"FWAIT",	"fwait",

	POINT,	0xA400,	0,	164,	"MOVSb",	"movs",
	POINT,	0xA500,	0,	165,	"MOVSw",	"movs",

	POINT,	0xA600,	0,	166,	"CMPSb",	"cmps",
	POINT,	0xA700,	0,	167,	"CMPSw",	"cmps",

	POINT,	0xAE00,	0,	174,	"SCASb",	"scas",
	POINT,	0xAF00,	0,	175,	"SCASw",	"scas",

	POINT,	0xAA00,	0,	170,	"STOSb",	"stos",
	POINT,	0xAB00,	0,	171,	"STOSw",	"stos",

	POINT,	0xAC00,	0,	172,	"LODSb",	"lods",
	POINT,	0xAD00,	0,	173,	"LODSw",	"lods",

	POINT,	0x6C00,	0,	108,	"INSb",		"ins",
	POINT,	0x6D00,	0,	109,	"INSw",		"ins",

	POINT,	0x6E00,	0,	110,	"OUTSb",	"outs",
	POINT,	0x6F00,	0,	111,	"OUTSw",	"outs",

	POINT,	0xD700,	0,	215,	"XLATb",	"xlat",

	POINT,	0xEA00,	0,	234,	"JMPf_Ip",	"jmp_far",

	POINT,	0x9A00,	0,	154,	"CALLf_Ip",	"call_far",

	POINT,	0xCA00,	0,	202,	"RETf_Is",	"ret_far",
	POINT,	0xCB00,	0,	203,	"RETf",		"ret_far",

	SELMEM,	0xFF00,	0x28,	661,	"JMPf_EA",	"jmp_far_in",

	SELMEM,	0xFF00,	0x18,	659,	"CALLf_EA",	"call_far_in",

	POINT,	0x0600,	0,	6,	"PUSH_ES",	"push_s",
	POINT,	0x0E00,	0,	14,	"PUSH_CS",	"push_s",
	POINT,	0x1600,	0,	22,	"PUSH_SS",	"push_s",
	POINT,	0x1E00,	0,	30,	"PUSH_DS",	"push_s",

	POINT,	0x0700,	0,	6,	"POP_ES",	"pop_s",
	POINT,	0x1700,	0,	22,	"POP_SS",	"pop_s",
	POINT,	0x1F00,	0,	30,	"POP_DS",	"pop_s",

	SELREG,	0x8C00,	0x00,	544,	"MOVw_ES_EA",	"mov_s,r",
	SELREG,	0x8C00,	0x08,	545,	"MOVw_CS_EA",	"mov_s,r",
	SELREG,	0x8C00,	0x10,	546,	"MOVw_SS_EA",	"mov_s,r",
	SELREG,	0x8C00,	0x18,	547,	"MOVw_DS_EA",	"mov_s,r",

	SELREG,	0x8E00,	0x00,	552,	"MOVw_EA_ES",	"mov_r,s",
	SELREG,	0x8E00,	0x10,	554,	"MOVw_EA_SS",	"mov_r,s",
	SELREG,	0x8E00,	0x18,	555,	"MOVw_EA_DS",	"mov_r,s",

	SELMEM,	0x8E00,	0x00,	552,	"MOVw_EA_ES",	"mov_m,s",
	SELMEM,	0x8E00,	0x10,	554,	"MOVw_EA_SS",	"mov_m,s",
	SELMEM,	0x8E00,	0x18,	555,	"MOVw_EA_DS",	"mov_m,s",

	SELMEM,	0x8C00,	0x00,	999,	"MOVw_ES_EA",	"mov_s,m",
	SELMEM,	0x8C00,	0x08,	999,	"MOVw_CS_EA",	"mov_s,m",
	SELMEM,	0x8C00,	0x10,	999,	"MOVw_SS_EA",	"mov_s,m",
	SELMEM,	0x8C00,	0x18,	999,	"MOVw_DS_EA",	"mov_s,m",

	ALLMEM,	0xC400,	0,	196,	"LESw_EA_R",	"mov_m,p",
	ALLMEM,	0xC500,	0,	197,	"LDSw_EA_R",	"mov_m,p",

	POINT,	0xC800,	0,	200,	"ENTER",	"enter",
	POINT,	0xC900,	0,	201,	"LEAVE",	"leave",

	POINT,	0xE400,	0,	228,	"INb_Ib_AL",	"io",
	POINT,	0xE500,	0,	229,	"INw_Iw_AX",	"io",
	POINT,	0xE600,	0,	230,	"OUTb_Ib_AL",	"io",
	POINT,	0xE700,	0,	231,	"OUTw_Iw_AX",	"io",
	POINT,	0xEC00,	0,	236,	"INb_DX_AL",	"io",
	POINT,	0xED00,	0,	237,	"INw_DX_AX",	"io",
	POINT,	0xEE00,	0,	238,	"OUTb_DX_AL",	"io",
	POINT,	0xEF00,	0,	239,	"OUTw_DX_AX",	"io",

	POINT,	0x9C00,	0,	156,	"PUSHF",	"VM_sensitive",
	POINT,	0x9D00,	0,	157,	"POPF",		"VM_sensitive",
	POINT,	0xFA00,	0,	250,	"CLI",		"VM_sensitive",
	POINT,	0xFB00,	0,	251,	"STI",		"VM_sensitive",

	ES_PREFIX,0,	0,	38,	"ES_prefix",	"other86",
	DS_PREFIX,0,	0,	46,	"DS_prefix",	"other86",
	SS_PREFIX,0,	0,	54,	"SS_prefix",	"other86",
	CS_PREFIX,0,	0,	62,	"CS_prefix",	"other86",
	POINT,	0x6000,	0,	96,	"PUSHA",	"other86",
	POINT,	0x6100,	0,	97,	"POPA",		"other86",
	ALLMEM,	0x6200,	0,	98,	"BOUND",	"other86",

	POINT,	0x6300,	0,	99,	"ARPL",		"other286",

	USE_ZEROF,0,	0,	0,	"",		"",

	ALL,	0x0200,	0,	258,	"LARw_EA_R",	"other286",
	ALL,	0x0300,	0,	259,	"LSLw_EA_R",	"other286",
	ALL,	0x0600,	0,	262,	"CLTS",		"other286",
	SELALL,	0x0000,	0x00,	664,	"SLDTw_EA",	"other286",
	SELALL,	0x0000,	0x08,	665,	"STRw_EA",	"other286",
	SELALL,	0x0000,	0x10,	666,	"LLDTw_EA",	"other286",
	SELALL,	0x0000,	0x18,	667,	"LTRw_EA",	"other286",
	SELALL,	0x0000,	0x20,	668,	"VERRw_EA",	"other286",
	SELALL,	0x0000,	0x28,	669,	"VERWw_EA",	"other286",
	SELALL,	0x0100,	0x00,	672,	"SGDTw_EA",	"other286",
	SELALL,	0x0100,	0x08,	673,	"SIDTw_EA",	"other286",
	SELALL,	0x0100,	0x10,	674,	"LGDTw_EA",	"other286",
	SELALL,	0x0100,	0x18,	675,	"LIDTw_EA",	"other286",
	SELALL,	0x0100,	0x20,	676,	"SMSWw_EA",	"other286",
	SELALL,	0x0100,	0x30,	678,	"LMSWw_EA",	"other286",
	ALL,	0x0500,	0,	999,	"LOADALL",	"other286",

	USE_NORMAL,0,	0,	0,	"",		"",

    	RANGE,	0x7000,	0x7001,	112,	"JO_Ib",	".jcc",
    	RANGE,	0x7100,	0x7101,	113,	"JNO_Ib",	".jcc",
    	RANGE,	0x7200,	0x7201,	114,	"JC_Ib",	".jcc",
    	RANGE,	0x7300,	0x7301,	115,	"JNC_Ib",	".jcc",
    	RANGE,	0x7400,	0x7401,	116,	"JZ_Ib",	".jcc",
    	RANGE,	0x7500,	0x7501,	117,	"JNZ_Ib",	".jcc",
    	RANGE,	0x7600,	0x7601,	118,	"JBE_Ib",	".jcc",
    	RANGE,	0x7700,	0x7701,	119,	"JNBE_Ib",	".jcc",
    	RANGE,	0x7800,	0x7801,	120,	"JS_Ib",	".jcc",
    	RANGE,	0x7900,	0x7901,	121,	"JNS_Ib",	".jcc",
    	RANGE,	0x7A00,	0x7A01,	122,	"JP_Ib",	".jcc",
    	RANGE,	0x7B00,	0x7B01,	123,	"JNP_Ib",	".jcc",
    	RANGE,	0x7C00,	0x7C01,	124,	"JL_Ib",	".jcc",
    	RANGE,	0x7D00,	0x7D01,	125,	"JNL_Ib",	".jcc",
    	RANGE,	0x7E00,	0x7E01,	126,	"JLE_Ib",	".jcc",
    	RANGE,	0x7F00,	0x7F01,	127,	"JNLE_Ib",	".jcc",
	
	RANGE,	0xE000,	0xE001,	224,	"LOOPNZb_Ib",	".loop",
	RANGE,	0xE100,	0xE101,	225,	"LOOPNb_Ib",	".loop",
	RANGE,	0xE200,	0xE201,	226,	"LOOP_Ib",	".loop",
	RANGE,	0xE300,	0xE301,	227,	"JCXZb_Ib",	".loop",

	POINT,	0x9A00,	0,	154,	"CALLf_Ip",	".genT",
	POINT,	0xC200,	0,	194,	"RET_Is",	".genT",
	POINT,	0xC300,	0,	195,	"RETn",		".genT",
	POINT,	0xCA00,	0,	202,	"RETf_Is",	".genT",
	POINT,	0xCB00,	0,	203,	"RETf",		".genT",
	POINT,	0xCC00,	0,	204,	"INT_3",	".genT",
	POINT,	0xCD00,	0,	205,	"INT_TYPE",	".genT",
	POINT,	0xCE00,	0,	206,	"INTO",		".genT",
	POINT,	0xCF00,	0,	207,	"IRETf",	".genT",
	POINT,	0xE800,	0,	232,	"CALLn_Iw",	".genT",
	POINT,	0xE900,	0xE900,	233,	"JMPn_Iw",	".genT",
	POINT,	0xEA00,	0,	234,	"JMPf_Ip",	".genT",
	POINT,	0xEB00,	0xEB00,	235,	"JMPn_Ib",	".genT",
	SELALL,	0xFF00,	0x10,	658,	"CALLn_EA",	".genT",
	SELMEM,	0xFF00,	0x18,	659,	"CALLf_EA",	".genT",
	SELALL,	0xFF00,	0x20,	660,	"JMPn_EA",	".genT",
	SELMEM,	0xFF00,	0x28,	661,	"JMPf_EA",	".genT",

	0,	0,	0,	0,	"",		""};

LOCAL print_stats IFN0()
{
    ULONG i, j, total, sub_total, super_total, command, from, to, item;
    char *group;
    ULONG *counts_array;

    previous_group = "";
    counts_array = &instr_counts[0];
    item = 0;
    total = 0;
    super_total = 0;
    while (commands[item].command != 0)
    {
	command = commands[item].command;
	from = commands[item].from;
	to   = commands[item].to;
	group = commands[item].group;
	switch (command)
	{
	    case USE_NORMAL:
		counts_array = &instr_counts[0];
		break;

	    case USE_ZEROF:
		counts_array = &zerof_instr_counts[0];
		break;

	    case RANGE:
		sub_total = 0;
		for (i = from; i <= to; i++)
		    sub_total += counts_array[i];
		break;

	    case ES_PREFIX:
		sub_total = es_prefixes;
		break;

	    case CS_PREFIX:
		sub_total = cs_prefixes;
		break;

	    case SS_PREFIX:
		sub_total = ss_prefixes;
		break;

	    case DS_PREFIX:
		sub_total = ds_prefixes;
		break;

	    case LOCK:
		sub_total = lock_prefixes;
		break;

	    case REPNZ:
		sub_total = repe_prefixes;
		break;

	    case REP:
		sub_total = rep_prefixes;
		break;

	    case POINT:
		sub_total = counts_array[from];
		break;

	    case SELMEM:
		sub_total = 0;
		for (i = 0; i < 192; i++)
		    if ((i & 0x38) == to)
			sub_total += counts_array[from + i];
		break;

	    case ALLMEM:
		sub_total = 0;
		for (i = 0; i < 192; i++)
		    sub_total += counts_array[from + i];
		break;

	    case SELREG:
		sub_total = 0;
		for (i = 192; i < 256; i++)
		    if ((i & 0x38) == to)
			sub_total += counts_array[from + i];
		break;

	    case SELALL:
		sub_total = 0;
		for (i = 0; i < 256; i++)
		    if ((i & 0x38) == to)
			sub_total += counts_array[from + i];
		break;

	    case SEL5:
		sub_total = 0;
		for (i = 0; i < 256; i++)
		    if ((i & 0xF8) == to)
			sub_total += counts_array[from + i];
		break;

	    case ALLREG:
		sub_total = 0;
		for (i = 192; i < 256; i++)
		    sub_total += counts_array[from + i];
		break;

	    case ALL:
		sub_total = 0;
		for (i = 0; i < 256; i++)
		    sub_total += counts_array[from + i];
		break;

	    case FPINVALID:
		sub_total = 0;
		break;

	    default:
		printf("Unknown command\n");
	}

#if 0
	switch (command)
	{
	    case RANGE:
		for (i = from; i <= to; i++)
		    counts_array[i] = 0;
		break;

	    case POINT:
		counts_array[from] = 0;
		break;

	    case SELMEM:
		for (i = 0; i < 192; i++)
		    if ((i & 0x38) == to)
			counts_array[from + i] = 0;
		break;

	    case ALLMEM:
		for (i = 0; i < 192; i++)
		    counts_array[from + i] = 0;
		break;

	    case SELREG:
		for (i = 192; i < 256; i++)
		    if ((i & 0x38) == to)
			counts_array[from + i] = 0;
		break;

	    case SELALL:
		for (i = 0; i < 256; i++)
		    if ((i & 0x38) == to)
			counts_array[from + i] = 0;
		break;

	    case SEL5:
		for (i = 0; i < 256; i++)
		    if ((i & 0xF8) == to)
			counts_array[from + i] = 0;
		break;

	    case ALLREG:
		for (i = 192; i < 256; i++)
		    counts_array[from + i] = 0;
		break;

	    case ALL:
		for (i = 0; i < 256; i++)
		    counts_array[from + i] = 0;
		break;

	    default:
		printf("Unknown command\n");
	}
#endif

	if (command != USE_NORMAL && command != USE_ZEROF)
	{
	    if (strcmp(group, previous_group) != 0)
	    {
		if (item != 0)
		    fprintf(stats_file, "%s TOTAL = %d\n", previous_group, total);
		super_total += total;
		total = 0;
	        fprintf(stats_file, "\n%s\n", group);
	        previous_group = group;
	    }
	    total += sub_total;
	    fprintf(stats_file,"\t%d\t%-20s%d\n", commands[item].number,
				     commands[item].string,
			 	     sub_total);
	}

	item++;
    }
    fprintf(stats_file,"%s TOTAL = %d\n", previous_group, total);
    fprintf(stats_file,"\nGRAND TOTAL = %d\n", super_total);

#if 0
    for (i = 0; i < 0x10000; i++)
    {
	if (instr_counts[i])
	    printf("%d normals at %x\n", instr_counts[i], i);
	if (zerof_instr_counts[i])
	    printf("%d zerofs at %x\n", zerof_instr_counts[i], i);
    }
#endif
}

LOCAL char stats_file_name[20];
LOCAL ULONG stats_file_number;

GLOBAL start_pclabs IFN0()
{
    IMPORT int tick_multiple;
    do_condition_checks = 1;
    tick_multiple = 10;
    clear_stats();
    sprintf(&stats_file_name[0], "stats.%d", ++stats_file_number);
    stats_file = fopen(&stats_file_name[0], "w");
}


GLOBAL print_pclabs IFN0()
{
    IMPORT int tick_multiple;
    do_condition_checks = 0;
    tick_multiple = 0;
    print_stats();
    fclose(stats_file);
}

#endif /* PCLABS STATS */

/* extra functions called in FmDebug.c which support suspension and resumption
	of a separate filter process. BCN 3406 */
GLOBAL yoda_suspend_filter_process IFN0 ()
{
#ifdef host_suspend_filter_process
	host_suspend_filter_process();
#endif
}

GLOBAL yoda_resume_filter_process IFN0 ()
{
#ifdef	host_resume_filter_process
	host_resume_filter_process();
#endif
}

GLOBAL yoda_kill_filter_process IFN0 ()
{
#ifdef	host_kill_filter_process
	host_kill_filter_process();
#endif
}
#endif /* YODA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\disks\floppy.c ===
#if defined(NEC_98)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#endif // NEC_98
#include "insignia.h"
#include "host_def.h"

extern void host_simulate();

/*
 * SoftPC Revision 3.0
 *
 *
 * Title	: Secondary SFD BIOS floppy diskette functions
 *
 *
 * Description	: This module defines the functions that the DISKETTE_IO
 *		  operating system call switches to on the value of AH:
 *
 *		  (AH=00H) reset the floppy diskette system
 *
 *		  (AH=01H) return the status of the floppy diskette system
 *
 *		  (AH=02H) read sectors from a floppy diskette
 *
 *		  (AH=03H) write sectors to a floppy diskette
 *
 *		  (AH=04H) verify sectors on a floppy diskette
 *
 *		  (AH=05H) format a track on a floppy diskette
 *
 *		  (AH=06H)
 *		     to    invalid
 *		  (AH=07H)
 *
 *		  (AH=08H) return floppy diskette system parameters
 *
 *		  (AH=09H)
 *		     to    invalid
 *		  (AH=14H)
 *
 *		  (AH=15H) return floppy diskette drive parameters
 *
 *		  (AH=16H) return floppy diskette drive change line status
 *
 *		  (AH=17H) set media density for a format operation
 *
 *		  (AH=18H) set media type for a format operation
 *
 *
 * Author	: Ross Beresford
 *
 *
 * Notes	: For a detailed description of the IBM Floppy Disk Adaptor,
 *		  and the INTEL Controller chips refer to the following
 *		  documents:
 *
 *		  - IBM PC/XT Technical Reference Manual
 *				(Section 1-109 Diskette Adaptor)
 *		  - INTEL Microsystems Components Handbook
 *				(Section 6-52 DMA Controller 8237A)
 *		  - INTEL Microsystems Components Handbook
 *				(Section 6-478 FDC 8272A)
 *
 * Mods:
 *      Tim September 1991. nec_term() changed two error code returns.
 * 	Helps Dos give correct error messages when no floppy in drive.
 */

/*
 *	
 *		#    #    ##       #     #####   ####
 *		#    #   #  #      #       #    #
 *		#    #  #    #     #       #     ####
 *		# ## #  ######     #       #         #
 *		##  ##  #    #     #       #    #    #
 *		#    #  #    #     #       #     ####
 *	
 * READ THIS: IMPORTANT NOTICE ABOUT WAITS
 *
 * The motor and head settle time waits etc used to be done
 * using a busy wait loop in a sub-CPU: this was what the
 * waitf() call was for, and this accurately emulated what
 * the real BIOS does.
 *
 * It was certainly a bad thing, however, as most
 * floppies we support are "soft" in the sense that
 * their underlying driver automatically waits for motor
 * start-up etc (examples are the slave, virtual, and
 * empty drive, and the real drive on the VAX ports).
 *
 * How should we deal with the few drives where we must
 * actually wait the correct time for motor start-up etc
 * before doing reads, writes, formats etc? The low
 * density BIOS relies on the GFI real diskette server
 * waiting for motor start-up in the driver itself (see
 * for example sun3_wang.c and ip32_flop.c). For the
 * moment the high density BIOS will do the same: it
 * might be better, however, for new GFI level functions
 * to be added to explicitly wait for driver events.
 */


/*
 * static char SccsID[]="@(#)floppy.c	1.22 09/19/94 Copyright Insignia Solutions Ltd.";
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_FLOPPY.seg"
#endif

#include <stdio.h>
#if defined(NEC_98)
#include <stdlib.h>
#endif //NEC_98
#include TypesH

#include "xt.h"
#include CpuH
#include "sas.h"
#include "ios.h"
#include "bios.h"
#include "dma.h"
#include "config.h"
#include "fla.h"
#include "gfi.h"
#include "equip.h"
#include "floppy.h"
#include "trace.h"
#include "debug.h"
#include "tape_io.h"
#include "cmos.h"
#include "cmosbios.h"
#include "rtc_bios.h"

#if defined(NEC_98)
#include <ntdddisk.h>

/*
**      DA/UA table definition
**      WARNING!! keep the following defines synchronized with floppy_i.c
*/
typedef struct {
        CHAR    DeviceName[29];
        UCHAR   Daua;
        UINT    FloppyNum;
        UINT    FdiskNum;
} DAUATBL;

extern DAUATBL  DauaTable[];

/*
**      Last accessed Track Number Table
**      WARNING!! keep the following defines synchronized with floppy_i.c
*/
typedef struct {
        UCHAR   cylinder;
        UCHAR   head;
} ACCESSTRACK;

extern ACCESSTRACK LastAccess[];

/*
**      Definition function
*/
MEDIA_TYPE GetFormatMedia IPT2( BYTE, daua, WORD, PhyBytesPerSec );
NTSTATUS FloppyOpenHandle IPT3( int, drive, PIO_STATUS_BLOCK, io_status_block, PHANDLE, fd);
NTSTATUS GetGeometry IPT3( HANDLE, fd, PIO_STATUS_BLOCK, io_status_block, PDISK_GEOMETRY, disk_geometry);
ULONG CalcActualLength IPT4( ULONG, RestCylLen, ULONG, RestTrkLen, BOOL*, fOverData, int, LogDrv);
void SetErrorCode IPT1( NTSTATUS, status );
void fl_disk_recal IPT1(int, drive);
void fl_disk_sense IPT1(int, drive);
void fl_disk_read_id IPT1(int, drive);
void SetSenseStatusHi IPT2( UCHAR, st3, PBYTE, ah_status);
void GetFdcStatus IPT2( HANDLE, fd, UCHAR, *st3 );
BOOL CheckDmaBoundary IPT3( UINT, segment, UINT, offset, UINT, length);
BOOL CheckDriveMode IPT1( HANDLE, fd );
BOOL Check144Mode IPT1( HANDLE, fd );
BOOL Check1MbInterface IPT1( int, drive );

extern int ConvToLogical IPT1( UINT, daua );
extern void SetDiskBiosCarryFlag IPT1( UINT, flag);

#endif // NEC_98

/*
 *	Definition of the diskette operation function jump table
 */

#if defined(NEC_98)
void ((*(fl_fnc_tab[FL_JUMP_TABLE_SIZE])) IPT1(int, drive)) =
{
        fl_fnc_err,
        fl_disk_verify,         // ah=x1h       verify sectors on a floppy diskette
        fl_fnc_err,
        fl_fnc_err,
        fl_disk_sense,          // ah=x4h       sense condition of floppy drive
        fl_disk_write,          // ah=x5h       write sectors to a floppy diskette
        fl_disk_read,           // ah=x6h       read sectors from a floppy diskette
        fl_disk_recal,          // ah=x7h       recalibrate floppy head
        fl_fnc_err,
        fl_fnc_err,
        fl_disk_read_id,        // ah=xAh       read id information from a floppy diskette
        fl_fnc_err,
        fl_fnc_err,
        fl_disk_format,         // ah=xDh       format a track on a floppy diskette
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
        fl_fnc_err,
};
#else  // !NEC_98
void ((*(fl_fnc_tab[FL_JUMP_TABLE_SIZE])) IPT1(int, drive)) =
{
	fl_disk_reset,
	fl_disk_status,
	fl_disk_read,
	fl_disk_write,
	fl_disk_verify,
	fl_disk_format,
	fl_fnc_err,
	fl_fnc_err,
	fl_disk_parms,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_fnc_err,
	fl_disk_type,
	fl_disk_change,
	fl_format_set,
	fl_set_media,
};
#endif // !NEC_98

#ifdef NTVDM
extern UTINY number_of_floppy;
#endif    /* NTVDM */

/*
 *	Functions defined later
 */

LOCAL half_word get_parm IPT1(int, index);
LOCAL cmos_type IPT2(int, drive, half_word *, type);
LOCAL wait_int IPT0();
LOCAL void nec_output IPT1(half_word, byte_value);
LOCAL results IPT0();
LOCAL void send_spec IPT0();
LOCAL void setup_end IPT1(int, sectors_transferred);
LOCAL void rd_wr_vf IPT3(int, drive, FDC_CMD_BLOCK *, fcbp, half_word, dma_type);
LOCAL void translate_new IPT1(int, drive);
LOCAL void fmt_init IPT1(int, drive);
LOCAL med_change IPT1(int, drive);
LOCAL chk_lastrate IPT1(int, drive);
LOCAL void send_rate IPT1(int, drive);
LOCAL fmtdma_set IPT0();
LOCAL void nec_init IPT2(int, drive, FDC_CMD_BLOCK *, fcbp);
LOCAL nec_term IPT0();
LOCAL dr_type_check IPT3(half_word, drive_type, word *, seg_ptr,
	word *, off_ptr);
LOCAL read_dskchng IPT1(int, drive);
LOCAL void setup_state IPT1(int, drive);
LOCAL setup_dbl IPT1(int, drive);
LOCAL dma_setup IPT1(half_word, dma_mode);
LOCAL void rwv_com IPT2(word, md_segment, word, md_offset);
LOCAL retry IPT1(int, drive);
LOCAL void dstate IPT1(int, drive);
LOCAL num_trans IPT0();
LOCAL void motor_on IPT1(int, drive);
LOCAL seek IPT2(int, drive, int, track);
LOCAL read_id IPT2(int, drive, int, head);
LOCAL turn_on IPT1(int, drive);
LOCAL void waitf IPT1(long, time);
LOCAL recal IPT1(int, drive);
LOCAL chk_stat_2 IPT0();

#if defined(NEC_98)
#define FLS_NORMAL_END          0x00
#define FLS_READY               0x00
#define FLS_WRITE_PROTECTED     0x10
#define FLS_DMA_BOUNDARY        0x20
#define FLS_END_OF_CYLINDER     0x30
#define FLS_EQUIPMENT_CHECK     0x40
#define FLS_OVER_RUN            0x50
#define FLS_NOT_READY           0x60
#define FLS_ERROR               0x80
#define FLS_TIME_OUT            0x90
#define FLS_DATA_ERROR          0xA0
#define FLS_BAD_CYLINDER        0xD0
#define FLS_MISSING_ID          0xE0

#define FLS_DOUBLE_SIDE         (1 << 0)
#define FLS_DETECTION_AI        (1 << 1)
#define FLS_HIGH_DENSITY        (1 << 2)
#define FLS_2MODE               (1 << 3)
#define FLS_AVAILABLE_1PT44MB   ((1 << 3)|(1 << 2))

#define FLP_VERIFY      0x01
#define FLP_SENSE       0x04
#define FLP_WRITE       0x05
#define FLP_READ        0x06
#define FLP_RECALIBRATE 0x07
#define FLP_READ_ID     0x0A
#define FLP_FORMAT      0x0D

#define MEDIA_IS_FLOPPY (1 << 4)
#define OP_MULTI_TRACK  (1 << 7)
#define OP_SEEK         (1 << 4)
#define OP_MFM_MODE     (1 << 6)
#define OP_NEW_SENSE    (1 << 7)
#define OP_SENSE2       ((1 << 7)|(1 << 6))

#define ST3_READY               (1 << 5)
#define ST3_WRITE_PROTECT       (1 << 6)
#define ST3_DOUBLE_SIDE         (1 << 3)

#define MEDIA_2D_DA     0x50

//----- Add-Start <93.12.28> Bug-Fix -----------------------------------
#define DEFAULT_PATTERN 0xe5
//----- Add-End --------------------------------------------------------

#endif // NEC_98
/*
 *	This macro defines the normal behaviour of the FDC after a reset.
 *	Sending a series of sense interrupt status commands following a
 *	reset, for each drive in the correct order, should elicit the
 *	expected result in ST0.
 */

#define	expected_st0(drive)	(ST0_INTERRUPT_CODE_0 | ST0_INTERRUPT_CODE_1 | drive)

LOCAL	UTINY	fl_nec_status[8];

#define LOAD_RESULT_BLOCK	sas_loads(BIOS_FDC_STATUS_BLOCK, fl_nec_status,\
					sizeof(fl_nec_status))

LOCAL BOOL rate_unitialised = TRUE;

/*
 *	Definition of the external functions
 */



/* reports whether drive is high density, replaces old test for dual card
which assumed high density a or b implied high density a, which it doesn't
now we can have two drives of any 3.5 / 5.25 combination */

LOCAL BOOL high_density IFN1(int, drive)
{
	half_word drive_type;

	if (cmos_type(drive, &drive_type) == FAILURE)
		return(FALSE);
	switch (drive_type)
	{
		case GFI_DRIVE_TYPE_12:
		case GFI_DRIVE_TYPE_144:
		case GFI_DRIVE_TYPE_288:
			return(TRUE);
		default:
			return(FALSE);
	}
}

void fl_disk_reset IFN1(int, drive)
{
#ifndef NEC_98
	/*
	 *	Reset the FDC and all drives. "drive" is not significant
	 *
	 *	Register inputs:	
	 *		none
	 *	Register outputs:
	 *		AH	diskette status
	 *		CF	status flag
	 */
	half_word motor_status, diskette_dor_reg, diskette_status;

	/*
	 *	Switch on interrupt enable and clear the reset bit in the
	 *	DOR to do the reset, then restore the reset bit
	 */

	sas_load(MOTOR_STATUS, &motor_status);
	diskette_dor_reg = (motor_status << 4) | (motor_status >> 4);
	diskette_dor_reg &= ~DOR_RESET;
	diskette_dor_reg |= DOR_INTERRUPTS;
	outb(DISKETTE_DOR_REG, diskette_dor_reg);

	diskette_dor_reg |= DOR_RESET;
	outb(DISKETTE_DOR_REG, diskette_dor_reg);

	/*
	 *	Set SEEK_STATUS up to force a recalibrate on all drives
	 */

	sas_store(SEEK_STATUS, 0);


	/*
	 *	Check FDC responds as expected, viz: a drive ready
	 *	transition for each drive potentially installed; if
	 *	not, then there is an error in the FDC.
	 */

	if (wait_int() == FAILURE)
	{
		/*
		 *	Problem with the FDC
		 *
		 * The reset implied by the outb(DISKETTE_DOR_REG) above
		 * should trigger a hardware interrupt, and the wait_int
		 * should have detected and processed it.
		 */
		always_trace0("FDC failed to interrupt after a reset - HW interrupts broken?");

		sas_load(FLOPPY_STATUS, &diskette_status);
		diskette_status |= FS_FDC_ERROR;
		sas_store(FLOPPY_STATUS, diskette_status);
	}
	else
	{
		for(drive = 0; drive < MAX_DISKETTES; drive++)
		{
			nec_output(FDC_SENSE_INT_STATUS);

			if (    (results() == FAILURE)
			     || (get_r3_ST0(fl_nec_status) != expected_st0(drive)))
			{
				/*
				 *	Problem with the FDC
				 */
				sas_load(FLOPPY_STATUS, &diskette_status);
				diskette_status |= FS_FDC_ERROR;
				sas_store(FLOPPY_STATUS, diskette_status);

				always_trace1("diskette_io: FDC error - drive %d moribund after reset", drive);
				break;
			}
		}


		/*
		 *	If all drives OK, send the specify command to the
		 *	FDC
		 */

		if (drive == MAX_DISKETTES)
			send_spec();
	}


	/*
	 *	Return, without setting sectors transferred
	 */

	setup_end(IGNORE_SECTORS_TRANSFERRED);
#endif // !NEC_98
}

void fl_disk_status IFN1(int, drive)
{
	/*
	 *	Set the diskette status, and return without setting
	 *	sectors transferred. "drive" is not significant
	 *
	 *	Register inputs:	
	 *		AH	diskette status
	 *	Register outputs:
	 *		AH	diskette status
	 *		CF	status flag
	 */
	UNUSED(drive);
	
	sas_store(FLOPPY_STATUS, getAH());
	setup_end(IGNORE_SECTORS_TRANSFERRED);
}

void fl_disk_read IFN1(int, drive)
{
#if defined(NEC_98)
        /*
         *      Read sectors from the diskette in "drive"
         *
         *      Register inputs:
         *              AH      command code & operation mode
         *              AL      DA/UA
         *              BX      data length in bytes
         *              DH      head number
         *              DL      sector number
         *              CH      sector length (N)
         *              CL      cylinder number
         *              ES:BP   buffer address
         *      Register outputs:
         *              AH      diskette status
         *              CF      status flag
         */
        HANDLE  fd;
        DISK_GEOMETRY   disk_geometry;
        NTSTATUS    status;
        IO_STATUS_BLOCK io_status_block;
        UINT ReqSectors;
        int LogDrv;
        ULONG TrackLength,RestCylLen,RestTrkLen,ActReadLen,ActReadSec,RemainReadLen;
        BOOL fOverRead;
        BYTE fHeadChng;
        host_addr inbuf;
        sys_addr pdata;
        UCHAR st3;
        LARGE_INTEGER StartOffset,LItemp;

        /*
        **      check drive number validation
        */
        if( drive > MAX_FLOPPY )
        {
                setAH(FLS_EQUIPMENT_CHECK);
                SetDiskBiosCarryFlag(1);
                return;
        }

        /*
        **      check DMA boundary
        */
        if( !CheckDmaBoundary( getES(), getBP(), getBX() ) )
        {
                setAH(FLS_DMA_BOUNDARY);
                SetDiskBiosCarryFlag(1);
                return;
        }

        status = FloppyOpenHandle(drive,&io_status_block,&fd);

        if(!NT_SUCCESS(status))
        {
                SetErrorCode(status);
                return;
        }

        status = GetGeometry(fd,&io_status_block,&disk_geometry);

        if(!NT_SUCCESS(status))
        {
                NtClose(fd);
                SetErrorCode(status);
                return;
        }

//----- Add-Start <94.01.15> Bug-Fix -----------------------------------
        /*
        **      convert from DA/UA to logical drive number (0 based)
        */
        LogDrv = ConvToLogical( getAL() );

        /*
        **      check whether the specified sector length is valid.
        **      If specified sector length is not equal to actual sector
        **      length, then error returned.
        */
        if( (WORD)(128l << getCH()) != (WORD)disk_geometry.BytesPerSector )
        {
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_NONEXISTENT_SECTOR);
                return;
        }
//----- Add-End --------------------------------------------------------

        /*
        **      get read sectors
        */
        if( getBX() != 0 )
                ReqSectors = getBX() / (128 << getCH());
        else
                ReqSectors = (UINT)(0x10000l / (LONG)(128 << getCH()));

//----- Del-Start <94.01.15> Bug-Fix -----------------------------------
//      /*
//      **      convert from DA/UA to logical drive number (0 based)
//      */
//      LogDrv = ConvToLogical( getAL() );
//----- Del-End --------------------------------------------------------

        /*
        **      check read size
        */
        if( ReqSectors == 0 )
        {
                /*
                **      If request length is less than physical bytes/sector,
                **      then we do not perform to read.
                */
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                setAH(FLS_NORMAL_END);
                SetDiskBiosCarryFlag(0);
                return;
        }

        /*
        **      check sector range
        */
        if( (getDL() < 1) || (getDL() > (int)disk_geometry.SectorsPerTrack) )
        {
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_NONEXISTENT_SECTOR);
                return;
        }

        TrackLength = disk_geometry.SectorsPerTrack * disk_geometry.BytesPerSector;

        //      RestTrkLen = TrackLength - (SectorNo.(DL) - 1) * BytesPerSector
        RestTrkLen = (disk_geometry.SectorsPerTrack - (ULONG)getDL() + 1) * disk_geometry.BytesPerSector;

        //      case HeadNo = 0:        RestCylLen = RestTrkLen + TrackLength
        //      case HeadNo = 1:        RestCylLen = RestTrkLen
//----- Chg-Start <93.12.27> Bug-Fix -----------------------------------
//      if( getAH() & OP_SEEK )
//              RestCylLen = RestTrkLen + ( !(getDH() & 0x01) ? 1l : 0l ) * TrackLength;
//      else
//              RestCylLen = RestTrkLen + ( (LastAccess[LogDrv].head == 0) ? 1l : 0l ) * TrackLength;
//----------------------------------------------------------------------
        if( !( getDH() & 0x01 ) )
                RestCylLen = RestTrkLen + TrackLength;
        else
                RestCylLen = RestTrkLen;
//----- Chg-End --------------------------------------------------------

        /*
        **      calcurate length which is read actually
        */
        ActReadLen = CalcActualLength( RestCylLen, RestTrkLen, &fOverRead, LogDrv);
        ActReadSec = ActReadLen / disk_geometry.BytesPerSector;

        /*
        **      check multi track read
        */
        if( getAH() & OP_MULTI_TRACK )
        {
//----- Chg-Start <93.12.27> Bug-Fix -----------------------------------
//              if( getAH() & OP_SEEK )
//              {
//                      if( (getDH() & 0x01) == 0 )
//                      {
//                              if( ActReadLen > RestTrkLen )
//                              {
//                                      RemainReadLen = ActReadLen - RestTrkLen;
//                                      ActReadLen = RestTrkLen;
//                                      fHeadChng = 1;
//                              }
//                              else
//                              {
//                                      RemainReadLen = 0;
//                                      fHeadChng = 0;
//                              }
//                      }
//                      else
//                      {
//                              RemainReadLen = 0;
//                              fHeadChng = 0;
//                      }
//              }
//              else
//              {
//                      if( LastAccess[LogDrv].head == 0 )
//                      {
//                              if( ActReadLen > RestTrkLen )
//                              {
//                                      RemainReadLen = ActReadLen - RestTrkLen;
//                                      ActReadLen = RestTrkLen;
//                                      fHeadChng = 1;
//                              }
//                              else
//                              {
//                                      RemainReadLen = 0;
//                                      fHeadChng = 0;
//                              }
//                      }
//                      else
//                      {
//                              RemainReadLen = 0;
//                              fHeadChng = 0;
//                      }
//              }
//----------------------------------------------------------------------
                if( (getDH() & 0x01) == 0 )
                {
                        if( ActReadLen > RestTrkLen )
                        {
                                RemainReadLen = ActReadLen - RestTrkLen;
                                ActReadLen = RestTrkLen;
                                fHeadChng = 1;
                        }
                        else
                        {
                                RemainReadLen = 0;
                                fHeadChng = 0;
                        }
                }
                else
                {
                        RemainReadLen = 0;
                        fHeadChng = 0;
                }
//----- Chg-End --------------------------------------------------------
        }
        else
        {
                RemainReadLen = 0;
                fHeadChng = 0;
        }

        /* read to where ? */
        pdata = effective_addr ( getES (), getBP () );

        if ( !(inbuf = (host_addr)sas_transbuf_address (pdata, ActReadLen)) )
        {
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_UNSUCCESSFUL);
                return;
        }

        /*
        **      calculate reading start offset on "drive".
        **
        **      StartOffset = ( ( CylinderNo. * TracksPerCylinder + HeadNo. ) * SectorsPerTrack
        **                      + SectorNo. ) * BytesPerSector
        */
        if( getAH() & OP_SEEK )
        {
                //      temp = CylinderNo. * TracksPerCylinder
                LItemp = RtlConvertUlongToLargeInteger( (ULONG)getCL() );
                StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//              //      temp += HeadNo.
//              LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDH() & 0x01) );
//              StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
        }
        else
        {
                //      temp = CylinderNo. * TracksPerCylinder
                LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].cylinder );
                StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//              //      temp += HeadNo.
//              LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].head );
//              StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
        }
//----- Add-Start <93.12.27> Bug-Fix -----------------------------------
        //      temp += HeadNo.
        LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDH() & 0x01) );
        StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Add-End --------------------------------------------------------
        //      temp *= SectorsPerTrack
        StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.SectorsPerTrack);
        //      temp += SectorNo.
        LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDL() - 1) );
        StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
        //      StartOffset = temp * BytesPerSector
        StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.BytesPerSector);

        /*
        **      now, go reading
        */
        status = NtReadFile(    fd,
                                0,
                                NULL,
                                NULL,
                                &io_status_block,
                                (PVOID)inbuf,
                                ActReadLen,
                                &StartOffset,
                                NULL
                                );

        /*
        **      save track number
        */
        if( getAH() & OP_SEEK )
        {
                LastAccess[LogDrv].cylinder = getCL();
                LastAccess[LogDrv].head = getDH() & 0x01;
        }

        if (!NT_SUCCESS(status))
        {
                NtClose(fd);
                SetErrorCode(status);
                return;
        }

        /* now store what we read */
        sas_stores_from_transbuf (pdata, inbuf, ActReadLen);

        /*
        **      if specified reading data from head 0 to 1,
        **      then perform to read remaining data.
        */
        if( fHeadChng )
        {
                /*
                **      read to where ?
                **      note: It has been already proved that buffer is not round
                **            dma boundary.
                */
                pdata = effective_addr ( getES(), (WORD)(getBP()+(WORD)ActReadLen) );

                if ( !(inbuf = (host_addr)sas_transbuf_address (pdata, RemainReadLen)) )
                {
                        NtClose(fd);
                        SetErrorCode((NTSTATUS)STATUS_UNSUCCESSFUL);
                        return;
                }

                /*
                **      calculate start offset to read remaining data on "drive".
                **
                **      StartOffset = ( ( CylinderNo. * TracksPerCylinder + HeadNo. ) * SectorsPerTrack
                **                      + SectorNo. ) * BytesPerSector
                **
                **      note: It is to be reading operation from head 1 & sector 1
                **            that remaining data exist.
                */
                if( getAH() & OP_SEEK )
                {
                        //      temp = CylinderNo. * TracksPerCylinder
                        LItemp = RtlConvertUlongToLargeInteger( (ULONG)getCL() );
                        StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//                      //      temp += HeadNo.( = 1 )
//                      LItemp = RtlConvertUlongToLargeInteger( 1l );
//                      StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
                }
                else
                {
                        //      temp = CylinderNo. * TracksPerCylinder
                        LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].cylinder );
                        StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//                      //      temp += HeadNo.( = 1 )
//                      LItemp = RtlConvertUlongToLargeInteger( 1l );
//                      StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
                }
//----- Add-Start <93.12.27> Bug-Fix -----------------------------------
                //      temp += HeadNo.( = 1 )
                LItemp = RtlConvertUlongToLargeInteger( 1l );
                StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Add-End --------------------------------------------------------
                //      temp *= SectorsPerTrack
                StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.SectorsPerTrack);
                //      temp += SectorNo.( = 0 )
                LItemp = RtlConvertUlongToLargeInteger( 0l );
                StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
                //      StartOffset = temp * BytesPerSector
                StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.BytesPerSector);

                /*
                **      now, read remaining data
                */
                status = NtReadFile(    fd,
                                        0,
                                        NULL,
                                        NULL,
                                        &io_status_block,
                                        (PVOID)inbuf,
                                        RemainReadLen,
                                        &StartOffset,
                                        NULL
                                        );

                /*
                **      save current head number
                */
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = (getDH() & 0x01) + fHeadChng;
                }
                else
                        LastAccess[LogDrv].head += fHeadChng;

                if (!NT_SUCCESS(status))
                {
                        NtClose(fd);
                        SetErrorCode(status);
                        return;
                }

                /* now store what we read */
                sas_stores_from_transbuf (pdata, inbuf, RemainReadLen);
        }

        NtClose( fd );

        if( !fOverRead )
        {
                setAH(FLS_NORMAL_END);
                SetDiskBiosCarryFlag(0);
        }
        else
        {
                setAH(FLS_END_OF_CYLINDER);
                SetDiskBiosCarryFlag(1);
        }

#else  // !NEC_98
	/*
	 *	Read sectors from the diskette in "drive"
	 *
	 *	Register inputs:	
	 *		DH	head number
	 *		CH	track number
	 *		CL	sector number
	 *		AL	number of sectors
	 *		ES:BX	buffer address
	 *	Register outputs:
	 *		AL	number of sectors read
	 *		AH	diskette status
	 *		CF	status flag
	 */
	half_word motor_status;
	FDC_CMD_BLOCK fdc_cmd_block[MAX_COMMAND_LEN];

	/*
	 *	Not a write operation
	 */
	
	sas_load(MOTOR_STATUS, &motor_status);
	motor_status &= ~MS_WRITE_OP;
	sas_store(MOTOR_STATUS, motor_status);


	/*
	 *	Fill in skeleton FDC command block and use generic
	 *	diskette transfer function to do the read
	 */

        put_c0_cmd(fdc_cmd_block, FDC_READ_DATA);
        put_c0_skip(fdc_cmd_block, 1);
        put_c0_MFM(fdc_cmd_block, 1);
        put_c0_MT(fdc_cmd_block, 1);
	rd_wr_vf(drive, fdc_cmd_block, BIOS_DMA_READ);
#endif // !NEC_98
}

void fl_disk_write IFN1(int, drive)
{
#if defined(NEC_98)
        /*
         *      Write sectors to the diskette in "drive"
         *
         *      Register inputs:
         *              AH      command code & operation mode
         *              AL      DA/UA
         *              BX      data length in bytes
         *              DH      head number
         *              DL      sector number
         *              CH      sector length (N)
         *              CL      cylinder number
         *              ES:BP   buffer address
         *      Register outputs:
         *              AH      diskette status
         *              CF      status flag
         */
        HANDLE  fd;
        DISK_GEOMETRY   disk_geometry;
        NTSTATUS    status;
        IO_STATUS_BLOCK io_status_block;
        UINT ReqSectors;
        int LogDrv;
        ULONG TrackLength,RestCylLen,RestTrkLen,ActWriteLen,ActWriteSec,RemainWriteLen;
        BOOL fOverWrite;
        BYTE fHeadChng;
        host_addr outbuf;
        sys_addr pdata;
        UCHAR st3;
        LARGE_INTEGER StartOffset,LItemp;

        /*
        **      check drive number validation
        */
        if( drive > MAX_FLOPPY )
        {
                setAH(FLS_EQUIPMENT_CHECK);
                SetDiskBiosCarryFlag(1);
                return;
        }

        /*
        **      check DMA boundary
        */
        if( !CheckDmaBoundary( getES(), getBP(), getBX()) )
        {
                setAH(FLS_DMA_BOUNDARY);
                SetDiskBiosCarryFlag(1);
                return;
        }

        status = FloppyOpenHandle(drive,&io_status_block,&fd);

        if(!NT_SUCCESS(status))
        {
                SetErrorCode(status);
                return;
        }

        status = GetGeometry(fd,&io_status_block,&disk_geometry);

        if(!NT_SUCCESS(status))
        {
                NtClose(fd);
                SetErrorCode(status);
                return;
        }

//----- Add-Start <94.01.15> Bug-Fix -----------------------------------
        /*
        **      convert from DA/UA to logical drive number (0 based)
        */
        LogDrv = ConvToLogical( getAL() );

        /*
        **      check whether the specified sector length is valid.
        **      If specified sector length is not equal to actual sector
        **      length, then error returned.
        */
        if( (WORD)(128l << getCH()) != (WORD)disk_geometry.BytesPerSector )
        {
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_NONEXISTENT_SECTOR);
                return;
        }
//----- Add-End --------------------------------------------------------

        /*
        **      get write sectors
        */
        if( getBX() != 0 )
                ReqSectors = getBX() / (128 << getCH());
        else
                ReqSectors = (UINT)(0x10000l / (LONG)(128 << getCH()));

//----- Del-Start <94.01.15> Bug-Fix ------------------------------------
//      /*
//      **      convert from DA/UA to logical drive number (0 based)
//      */
//      LogDrv = ConvToLogical( getAL() );
//----- Del-End ---------------------------------------------------------

        /*
        **      check write size
        */
        if( ReqSectors == 0 )
        {
                /*
                **      If request length is less than physical bytes/sector,
                **      then we do not perform to read.
                */
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                setAH(FLS_NORMAL_END);
                SetDiskBiosCarryFlag(0);
                return;
        }

        /*
        **      check sector range
        */
        if( (getDL() < 1) || (getDL() > (int)(disk_geometry.SectorsPerTrack)) )
        {
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_NONEXISTENT_SECTOR);
                return;
        }

        TrackLength = disk_geometry.SectorsPerTrack * disk_geometry.BytesPerSector;

        //      RestTrkLen = TrackLength - (SectorNo.(DL) - 1) * BytesPerSector
        RestTrkLen = (disk_geometry.SectorsPerTrack - (ULONG)getDL() + 1) * disk_geometry.BytesPerSector;

        //      case HeadNo = 0:        ResCylLen = ResTrkLen + TrkLength
        //      case HeadNo = 1:        ResCylLen = RestTrkLen
//----- Chg-Start <93.12.27> Bug-Fix -----------------------------------
//      if( getAH() & OP_SEEK )
//              RestCylLen = RestTrkLen + ( !(getDH() & 0x01) ? 1l : 0l ) * TrackLength;
//      else
//              RestCylLen = RestTrkLen + ( (LastAccess[LogDrv].head == 0) ? 1l : 0l ) * TrackLength;
//----------------------------------------------------------------------
        if( !( getDH() & 0x01 ) )
                RestCylLen = RestTrkLen + TrackLength;
        else
                RestCylLen = RestTrkLen;
//----- Chg-End --------------------------------------------------------

        /*
        **      calcurate length which is written actually
        */
        ActWriteLen = CalcActualLength( RestCylLen, RestTrkLen, &fOverWrite, LogDrv);
        ActWriteSec = ActWriteLen / disk_geometry.BytesPerSector;

        /*
        **      check multi track write
        */
        if( getAH() & OP_MULTI_TRACK )
        {
//----- Chg-Start <93.12.27> Bug-Fix -----------------------------------
//              if( getAH() & OP_SEEK )
//              {
//                      if( (getDH() & 0x01) == 0 )
//                      {
//                              if( ActWriteLen > RestTrkLen )
//                              {
//                                      RemainWriteLen = ActWriteLen - RestTrkLen;
//                                      ActWriteLen = RestTrkLen;
//                                      fHeadChng = 1;
//                              }
//                              else
//                              {
//                                      RemainWriteLen = 0;
//                                      fHeadChng = 0;
//                              }
//                      }
//                      else
//                      {
//                              RemainWriteLen = 0;
//                              fHeadChng = 0;
//                      }
//              }
//              else
//              {
//                      if( LastAccess[LogDrv].head == 0 )
//                      {
//                              if( ActWriteLen > RestTrkLen )
//                              {
//                                      RemainWriteLen = ActWriteLen - RestTrkLen;
//                                      ActWriteLen = RestTrkLen;
//                                      fHeadChng = 1;
//                              }
//                              else
//                              {
//                                      RemainWriteLen = 0;
//                                      fHeadChng = 0;
//                              }
//                      }
//                      else
//                      {
//                              RemainWriteLen = 0;
//                              fHeadChng = 0;
//                      }
//              }
//----------------------------------------------------------------------
                if( (getDH() & 0x01) == 0 )
                {
                        if( ActWriteLen > RestTrkLen )
                        {
                                RemainWriteLen = ActWriteLen - RestTrkLen;
                                ActWriteLen = RestTrkLen;
                                fHeadChng = 1;
                        }
                        else
                        {
                                RemainWriteLen = 0;
                                fHeadChng = 0;
                        }
                }
                else
                {
                        RemainWriteLen = 0;
                        fHeadChng = 0;
                }
//----- Chg-End --------------------------------------------------------
        }
        else
        {
                RemainWriteLen = 0;
                fHeadChng = 0;
        }

        /* write from where ? */
        pdata = effective_addr (getES (), getBP ());

        if (!(outbuf = (host_addr)sas_transbuf_address (pdata, ActWriteLen)))
        {
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_UNSUCCESSFUL);
                return;
        }

        /* load our stuff to the transfer buffer */
        sas_loads_to_transbuf (pdata, outbuf, ActWriteLen);

        /*
        **      calculate writing start offset on "drive".
        **
        **      StartOffset = ( ( CylinderNo. * TracksPerCylinder + HeadNo. ) * SectorsPerTrack
        **                      + SectorNo. ) * BytesPerSector
        */
        if( getAH() & OP_SEEK )
        {
                //      temp = CylinderNo. * TracksPerCylinder
                LItemp = RtlConvertUlongToLargeInteger( (ULONG)getCL() );
                StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//              //      temp += HeadNo.
//              LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDH() & 0x01) );
//              StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
        }
        else
        {
                //      temp = CylinderNo. * TracksPerCylinder
                LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].cylinder);
                StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//              //      temp += HeadNo.
//              LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].head );
//              StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-end --------------------------------------------------------
        }
//----- Add-Start <93.12.27> Bug-Fix -----------------------------------
        //      temp += HeadNo.
        LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDH() & 0x01) );
        StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Add-End --------------------------------------------------------
        //      temp *= SectorsPerTrack
        StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.SectorsPerTrack);
        //      temp += SectorNo.
        LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDL() - 1) );
        StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
        //      StartOffset = temp * BytesPerSector
        StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.BytesPerSector);

        /*
        **      now, go writing
        */
        status = NtWriteFile(   fd,
                                0,
                                NULL,
                                NULL,
                                &io_status_block,
                                (PVOID)outbuf,
                                ActWriteLen,
                                &StartOffset,
                                NULL
                                );

        /*
        **      save track number
        */
        if( getAH() & OP_SEEK )
        {
                LastAccess[LogDrv].cylinder = getCL();
                LastAccess[LogDrv].head = getDH() & 0x01;
        }

        if (!NT_SUCCESS(status))
        {
                NtClose(fd);
                SetErrorCode(status);
                return;
        }

        /*
        **      if specified writing data from head 0 to 1,
        **      then perform to write remaining data.
        */
        if( fHeadChng )
        {
                /*
                **      write from where ?
                **      note: It has been already proved that buffer is not round
                **            dma boundary.
                */
                pdata = effective_addr ( getES(), (WORD)(getBP()+(WORD)ActWriteLen) );

                if (!(outbuf = (host_addr)sas_transbuf_address (pdata, RemainWriteLen)))
                {
                        NtClose(fd);
                        SetErrorCode((NTSTATUS)STATUS_UNSUCCESSFUL);
                        return;
                }

                /* load our stuff to the transfer buffer */
                sas_loads_to_transbuf (pdata, outbuf, RemainWriteLen);

                /*
                **      calculate start offset to write remaining data on "drive".
                **
                **      StartOffset = ( ( CylinderNo. * TracksPerCylinder + HeadNo. ) * SectorsPerTrack
                **                      + SectorNo. ) * BytesPerSector
                **
                **      note: It is to be writing operation from head 1 & sector 1
                **            that remaining data exist.
                */
                if( getAH() & OP_SEEK )
                {
                        //      temp = CylinderNo. * TracksPerCylinder
                        LItemp = RtlConvertUlongToLargeInteger( (ULONG)getCL() );
                        StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//                      //      temp += HeadNo.( = 1 )
//                      LItemp = RtlConvertUlongToLargeInteger( 1l );
//                      StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
                }
                else
                {
                        //      temp = CylinderNo. * TracksPerCylinder
                        LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].cylinder );
                        StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//                      //      temp += HeadNo.( = 1 )
//                      LItemp = RtlConvertUlongToLargeInteger( 1l );
//                      StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
                }
//----- Add-Start <93.12.27> Bug-Fix -----------------------------------
                //      temp += HeadNo.( = 1 )
                LItemp = RtlConvertUlongToLargeInteger( 1l );
                StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Add-End --------------------------------------------------------
                //      temp *= SectorsPerTrack
                StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.SectorsPerTrack);
                //      temp += SectorNo.( = 0 )
                LItemp = RtlConvertUlongToLargeInteger( 0l );
                StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
                //      StartOffset = temp * BytesPerSector
                StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.BytesPerSector);

                /*
                **      now, write remaining data
                */
                status = NtWriteFile(   fd,
                                        0,
                                        NULL,
                                        NULL,
                                        &io_status_block,
                                        (PVOID)outbuf,
                                        RemainWriteLen,
                                        &StartOffset,
                                        NULL
                                        );

                /*
                **      save current head number
                */
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = (getDH() & 0x01) + fHeadChng;
                }
                else
                        LastAccess[LogDrv].head += fHeadChng;

                if (!NT_SUCCESS(status))
                {
                        NtClose(fd);
                        SetErrorCode(status);
                        return;
                }

        }

        NtClose( fd );

        if( !fOverWrite )
        {
                setAH(FLS_NORMAL_END);
                SetDiskBiosCarryFlag(0);
        }
        else
        {
                setAH(FLS_END_OF_CYLINDER);
                SetDiskBiosCarryFlag(1);
        }

#else  // !NEC_98
	/*
	 *	Write sectors to the diskette in "drive"
	 *
	 *	Register inputs:	
	 *		DH	head number
	 *		CH	track number
	 *		CL	sector number
	 *		AL	number of sectors
	 *		ES:BX	buffer address
	 *	Register outputs:
	 *		AL	number of sectors written
	 *		AH	diskette status
	 *		CF	status flag
	 */
	half_word motor_status;
	FDC_CMD_BLOCK fdc_cmd_block[MAX_COMMAND_LEN];

	/*
	 *	A write operation
	 */
	
	sas_load(MOTOR_STATUS, &motor_status);
	motor_status |= MS_WRITE_OP;
	sas_store(MOTOR_STATUS, motor_status);


	/*
	 *	Fill in skeleton FDC command block and use generic
	 *	diskette transfer function to do the write
	 */

        put_c1_cmd(fdc_cmd_block, FDC_WRITE_DATA);
	put_c1_pad(fdc_cmd_block, 0);
	put_c1_MFM(fdc_cmd_block, 1);
	put_c1_MT(fdc_cmd_block, 1);
	rd_wr_vf(drive, fdc_cmd_block, BIOS_DMA_WRITE);
#endif // !NEC_98
}

void fl_disk_verify IFN1(int, drive)
{
#if defined(NEC_98)
        /*
         *      Verify sectors in the diskette in "drive"
         *
         *      Register inputs:
         *              AH      command code & operation mode
         *              AL      DA/UA
         *              BX      data length in bytes
         *              DH      head number
         *              DL      sector number
         *              CH      sector length (N)
         *              CL      cylinder number
         *              ES:BP   buffer address
         *      Register outputs:
         *              AH      diskette status
         *              CF      status flag
         */
        HANDLE  fd;
        DISK_GEOMETRY   disk_geometry;
        NTSTATUS    status;
        IO_STATUS_BLOCK io_status_block;
        UINT ReqSectors;
        int LogDrv;
        ULONG TrackLength,RestCylLen,RestTrkLen,ActVerifyLen,ActVerifySec,RemainVerifyLen;
        BOOL fOverVerify;
        BYTE fHeadChng;
        UCHAR st3;
        PVOID temp_buffer;
        LARGE_INTEGER StartOffset, LItemp;

        /*
        **      check drive number validation
        */
        if( drive > MAX_FLOPPY )
        {
                setAH(FLS_EQUIPMENT_CHECK);
                SetDiskBiosCarryFlag(1);
                return;
        }

        /*
        **      check DMA boundary
        */
        if( !CheckDmaBoundary( getES(), getBP(), getBX()) )
        {
                setAH(FLS_DMA_BOUNDARY);
                SetDiskBiosCarryFlag(1);
                return;
        }

        status = FloppyOpenHandle(drive,&io_status_block,&fd);

        if(!NT_SUCCESS(status))
        {
                SetErrorCode(status);
                return;
        }

        status = GetGeometry(fd,&io_status_block,&disk_geometry);

        if(!NT_SUCCESS(status))
        {
                NtClose(fd);
                SetErrorCode(status);
                return;
        }

//----- Add-Start <94.01.15> Bug-Fix -----------------------------------
        /*
        **      convert from DA/UA to logical drive number (0 based)
        */
        LogDrv = ConvToLogical( getAL() );

        /*
        **      check whether the specified sector length is valid.
        **      If specified sector length is not equal to actual sector
        **      length, then error returned.
        */
        if( (WORD)(128l << getCH()) != (WORD)disk_geometry.BytesPerSector )
        {
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_NONEXISTENT_SECTOR);
                return;
        }
//----- Add-End --------------------------------------------------------

        /*
        **      get verify sectors
        */
        if( getBX() != 0 )
                ReqSectors = getBX() / (128 << getCH());
        else
                ReqSectors = (UINT)(0x10000l / (LONG)(128 << getCH()));

//----- Del-Start <94.01.15> Bug-Fix -----------------------------------
//      /*
//      **      convert from DA/UA to logical drive number (0 based)
//      */
//      LogDrv = ConvToLogical( getAL() );
//----- Del-End --------------------------------------------------------

        /*
        **      check verify size
        */
        if( ReqSectors == 0 )
        {
                /*
                **      If request length is less than physical bytes/sector,
                **      then we do not perform to read.
                */
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                setAH(FLS_NORMAL_END);
                SetDiskBiosCarryFlag(0);
                return;
        }

        /*
        **      check sector range
        */
        if( (getDL() < 1) || (getDL() > (int)(disk_geometry.SectorsPerTrack)) )
        {
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_NONEXISTENT_SECTOR);
                return;
        }

        TrackLength = disk_geometry.SectorsPerTrack * disk_geometry.BytesPerSector;

        //      RestTrkLen = TrackLength - (SectorNo.(DL) - 1) * BytesPerSector
        RestTrkLen = (disk_geometry.SectorsPerTrack - (ULONG)getDL() + 1) * disk_geometry.BytesPerSector;

        //      case HeadNo = 0:        ResCylLen = ResTrkLen + TrkLength
        //      case HeadNo = 1:        ResCylLen = RestTrkLen
//----- Chg-Start <93.12.27> Bug-Fix -----------------------------------
//      if( getAH() & OP_SEEK )
//              RestCylLen = RestTrkLen + ( !(getDH() & 0x01) ? 1l : 0l ) * TrackLength;
//      else
//              RestCylLen = RestTrkLen + ( (LastAccess[LogDrv].head == 0) ? 1l : 0l ) * TrackLength;
//----------------------------------------------------------------------
        if( !( getDH() & 0x01 ) )
                RestCylLen = RestTrkLen + TrackLength;
        else
                RestCylLen = RestTrkLen;
//----- Chg-End --------------------------------------------------------

        /*
        **      calcurate length which is verified actually
        */
        ActVerifyLen = CalcActualLength( RestCylLen, RestTrkLen, &fOverVerify, LogDrv);
        ActVerifySec = ActVerifyLen / disk_geometry.BytesPerSector;

        /*
        **      check multi track verify
        */
        if( getAH() & OP_MULTI_TRACK )
        {
//----- Chg-Start <93.12.27> Bug-Fix -----------------------------------
//              if( getAH() & OP_SEEK )
//              {
//                      if( (getDH() & 0x01) == 0 )
//                      {
//                              if( ActVerifyLen > RestTrkLen )
//                              {
//                                      RemainVerifyLen = ActVerifyLen - RestTrkLen;
//                                      ActVerifyLen = RestTrkLen;
//                                      fHeadChng = 1;
//                              }
//                              else
//                              {
//                                      RemainVerifyLen = 0;
//                                      fHeadChng = 0;
//                              }
//                      }
//                      else
//                      {
//                              RemainVerifyLen = 0;
//                              fHeadChng = 0;
//                      }
//              }
//              else
//              {
//                      if( LastAccess[LogDrv].head == 0 )
//                      {
//                              if( ActVerifyLen > RestTrkLen )
//                              {
//                                      RemainVerifyLen = ActVerifyLen - RestTrkLen;
//                                      ActVerifyLen = RestTrkLen;
//                                      fHeadChng = 1;
//                              }
//                              else
//                              {
//                                      RemainVerifyLen = 0;
//                                      fHeadChng = 0;
//                              }
//                      }
//                      else
//                      {
//                              RemainVerifyLen = 0;
//                              fHeadChng = 0;
//                      }
//              }
//----------------------------------------------------------------------
                if( (getDH() & 0x01) == 0 )
                {
                        if( ActVerifyLen > RestTrkLen )
                        {
                                RemainVerifyLen = ActVerifyLen - RestTrkLen;
                                ActVerifyLen = RestTrkLen;
                                fHeadChng = 1;
                        }
                        else
                        {
                                RemainVerifyLen = 0;
                                fHeadChng = 0;
                        }
                }
                else
                {
                        RemainVerifyLen = 0;
                        fHeadChng = 0;
                }
//----- Chg-End --------------------------------------------------------
        }
        else
        {
                RemainVerifyLen = 0;
                fHeadChng = 0;
        }

        /*
        **      allocate temporary buffer for verify operation
        */
        if( (temp_buffer=malloc( ActVerifyLen )) == NULL )
        {
                NtClose(fd);
                SetErrorCode((NTSTATUS)STATUS_UNSUCCESSFUL);
                return;
        }

        /*
        **      calculate verifying start offset on "drive".
        **
        **      StartOffset = ( ( CylinderNo. * TracksPerCylinder + HeadNo. ) * SectorsPerTrack
        **                      + SectorNo. ) * BytesPerSector
        */
        if( getAH() & OP_SEEK )
        {
                //      temp = CylinderNo. * TracksPerCylinder
                LItemp = RtlConvertUlongToLargeInteger( (ULONG)getCL() );
                StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//              //      temp += HeadNo.
//              LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDH() & 0x01) );
//              StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
        }
        else
        {
                //      temp = CylinderNo. * TracksPerCylinder
                LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].cylinder );
                StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//              //      temp += HeadNo.
//              LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].head );
//              StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
        }
//----- Add-Start <93.12.27> Bug-Fix -----------------------------------
        //      temp += HeadNo.
        LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDH() & 0x01) );
        StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Add-End --------------------------------------------------------
        //      temp *= SectorsPerTrack
        StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.SectorsPerTrack);
        //      temp += SectorNo.
        LItemp = RtlConvertUlongToLargeInteger( (ULONG)(getDL() - 1) );
        StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
        //      StartOffset = temp * BytesPerSector
        StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.BytesPerSector);

        /*
        **      now, go reading for verify
        */
        status = NtReadFile(    fd,
                                0,
                                NULL,
                                NULL,
                                &io_status_block,
                                (PVOID)temp_buffer,
                                ActVerifyLen,
                                &StartOffset,
                                NULL
                                );

        /*
        **      save track number
        */
        if( getAH() & OP_SEEK )
        {
                LastAccess[LogDrv].cylinder = getCL();
                LastAccess[LogDrv].head = getDH() & 0x01;
        }

        if (!NT_SUCCESS(status))
        {
                free(temp_buffer);
                NtClose(fd);
                SetErrorCode(status);
                return;
        }

        free(temp_buffer);

        /*
        **      if specified verifying data from head 0 to 1,
        **      then perform to verify remaining data.
        */
        if( fHeadChng )
        {
                /*
                **      read to where ?
                **      allocate temporary buffer for verify operation
                **      note: It has been already proved that buffer is not round
                **            dma boundary.
                */
                if( (temp_buffer=malloc( RemainVerifyLen )) == NULL )
                {
                        NtClose(fd);
                        SetErrorCode((NTSTATUS)STATUS_UNSUCCESSFUL);
                        return;
                }

                /*
                **      calculate start offset to verify remaining data on "drive".
                **
                **      StartOffset = ( ( CylinderNo. * TracksPerCylinder + HeadNo. ) * SectorsPerTrack
                **                      + SectorNo. ) * BytesPerSector
                **
                **      note: It is to be verifying operation from head 1 & sector 1
                **            that remaining data exist.
                */
                if( getAH() & OP_SEEK )
                {
                        //      temp = CylinderNo. * TracksPerCylinder
                        LItemp = RtlConvertUlongToLargeInteger( (ULONG)getCL() );
                        StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//                      //      temp += HeadNo.( = 1 )
//                      LItemp = RtlConvertUlongToLargeInteger( 1l );
//                      StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
                }
                else
                {
                        //      temp = CylinderNo. * TracksPerCylinder
                        LItemp = RtlConvertUlongToLargeInteger( (ULONG)LastAccess[LogDrv].cylinder );
                        StartOffset = RtlExtendedIntegerMultiply( LItemp, (ULONG)disk_geometry.TracksPerCylinder);
//----- Del-Start <93.12.27> Bug-Fix -----------------------------------
//                      //      temp += HeadNo.( = 1 )
//                      LItemp = RtlConvertUlongToLargeInteger( 1l );
//                      StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Del-End --------------------------------------------------------
                }
//----- Add-Start <93.12.27> Bug-Fix -----------------------------------
                //      temp += HeadNo.( = 1 )
                LItemp = RtlConvertUlongToLargeInteger( 1l );
                StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
//----- Add-End --------------------------------------------------------
                //      temp *= SectorsPerTrack
                StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.SectorsPerTrack);
                //      temp += SectorNo.( = 0 )
                LItemp = RtlConvertUlongToLargeInteger( 0l );
                StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
                //      StartOffset = temp * BytesPerSector
                StartOffset = RtlExtendedIntegerMultiply( StartOffset, (ULONG)disk_geometry.BytesPerSector);

                /*
                **      now, go reading for verify remaining data
                */
                status = NtReadFile(    fd,
                                        0,
                                        NULL,
                                        NULL,
                                        &io_status_block,
                                        (PVOID)temp_buffer,
                                        RemainVerifyLen,
                                        &StartOffset,
                                        NULL
                                        );

                /*
                **      save current head number
                */
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = (getDH() & 0x01) + fHeadChng;
                }
                else
                        LastAccess[LogDrv].head += fHeadChng;

                if (!NT_SUCCESS(status))
                {
                        free(temp_buffer);
                        NtClose(fd);
                        SetErrorCode(status);
                        return;
                }

                free(temp_buffer);
        }

        NtClose( fd );

        if( !fOverVerify )
        {
                setAH(FLS_NORMAL_END);
                SetDiskBiosCarryFlag(0);
        }
        else
        {
                setAH(FLS_END_OF_CYLINDER);
                SetDiskBiosCarryFlag(1);
        }

#else  // !NEC_98
	/*
	 *	Verify sectors in the diskette in "drive"
	 *
	 *	Register inputs:	
	 *		DH	head number
	 *		CH	track number
	 *		CL	sector number
	 *		AL	number of sectors
	 *	Register outputs:
	 *		AL	number of sectors verified
	 *		AH	diskette status
	 *		CF	status flag
	 */
	half_word motor_status;
	FDC_CMD_BLOCK fdc_cmd_block[MAX_COMMAND_LEN];

	
	/*
	 *	Not a write operation
	 */

	sas_load(MOTOR_STATUS, &motor_status);
	motor_status &= ~MS_WRITE_OP;
	sas_store(MOTOR_STATUS, motor_status);


	/*
	 *	Fill in skeleton FDC command block and use generic
	 *	diskette transfer function to do the verify
	 */

	put_c0_cmd(fdc_cmd_block, FDC_READ_DATA);
	put_c0_skip(fdc_cmd_block, 1);
	put_c0_MFM(fdc_cmd_block, 1);
	put_c0_MT(fdc_cmd_block, 1);
	rd_wr_vf(drive, fdc_cmd_block, BIOS_DMA_VERIFY);
#endif // !NEC_98
}

/*
** The low level 3.5 inch floppy format wants to know these params.
** For the funny format function.
** Have a look at hp_flop3.c FDC_FORMAT_TRACK bit.
*/
LOCAL int f_cyl, f_head, f_sector, f_N;
void GetFormatParams IFN4(int *, c, int *, h, int *, s, int *, n)
{
	*c = f_cyl;
	*h = f_head;
	*s = f_sector;
	*n = f_N;
}

void fl_disk_format IFN1(int, drive)
{
#if defined(NEC_98)
        /*
         *      Format the diskette in "drive"
         *
         *      Register inputs:
         *              AH      command code & operation mode
         *              AL      DA/UA
         *              BX      DTL buffer length in byte
         *              DH      head number
         *              CH      sector length (N)
         *              CL      cylinder number
         *              ES:BP   address fields for the track
         *      Register outputs:
         *              AH      diskette status
         *              CF      status flag
         */
        HANDLE  fd;
        DISK_GEOMETRY   disk_geometry;
        NTSTATUS    status;
        MEDIA_TYPE media_type;
        IO_STATUS_BLOCK io_status_block;
        int LogDrv;
        FORMAT_PARAMETERS format_param;
        BYTE daua;
        WORD PhyBytesPerSec,bad_track;
//----- Add-Start <93.12.28> Bug-Fix -----------------------------------
        ULONG TrackLength;
        PBYTE temp_buffer;
        BYTE PatternData;
        ULONG i;
        LARGE_INTEGER StartOffset,LItemp;
//----- Add-End --------------------------------------------------------

        /*
        **      check drive number validation
        */
        if( drive > MAX_FLOPPY )
        {
                setAH(FLS_EQUIPMENT_CHECK);
                SetDiskBiosCarryFlag(1);
                return;
        }

        /*
        **      check DMA boundary
        */
        if( !CheckDmaBoundary( getES(), getBP(), getBX()) )
        {
                setAH(FLS_DMA_BOUNDARY);
                SetDiskBiosCarryFlag(1);
                return;
        }

        /*
        **      check FM mode
        */
        if( !( getAH() & OP_MFM_MODE ) )
        {
                setAH(FLS_MISSING_ID);
                SetDiskBiosCarryFlag(1);
                return;
        }

//----- Add-Start <94.01.15> Bug-Fix -----------------------------------
        /*
        **      convert from DA/UA to logical drive number (0 based)
        */
        LogDrv = ConvToLogical( getAL() );

        /*
        **      check whether the specified sector length is valid.
        **      If specified sector length is greater than 2048,
        **      then error returned.
        */
        if( getCH() > 4 )
        {
                if( getAH() & OP_SEEK )
                {
                        LastAccess[LogDrv].cylinder = getCL();
                        LastAccess[LogDrv].head = getDH() & 0x01;
                }
//----- Del-Start <94.01.17> Bug-Fix -----------------------------------
//              NtClose(fd);
//----- Del-End --------------------------------------------------------
                SetErrorCode((NTSTATUS)STATUS_NONEXISTENT_SECTOR);
                return;
        }
//----- Add-End --------------------------------------------------------

        /*
        **      get requested media type
        */
        daua = (BYTE)getAL();
        PhyBytesPerSec = (WORD)( 128 << getCH() );
        if( (media_type = GetFormatMedia( daua, PhyBytesPerSec)) == Unknown )
        {
                setAH(FLS_EQUIPMENT_CHECK);
                SetDiskBiosCarryFlag(1);
                return;
        }

        status = FloppyOpenHandle(drive,&io_status_block,&fd);

        if(!NT_SUCCESS(status))
        {
                SetErrorCode(status);
                return;
        }

        /*
        **      set up format parameter
        */
//----- Del-Start <94.01.15> Bug-Fix -----------------------------------
//      LogDrv = ConvToLogical( getAL() );
//----- Del-End --------------------------------------------------------
        format_param.MediaType = media_type;
//----- Chg-Start <93.12.27> Bug-Fix -----------------------------------
//      if( getAH() & OP_SEEK )
//      {
//              format_param.StartCylinderNumber =
//              format_param.EndCylinderNumber   = (DWORD)getCL();
//              format_param.StartHeadNumber     =
//              format_param.EndHeadNumber       = (DWORD)( getDH() & 0x01 );
//      }
//      else
//      {
//              format_param.StartCylinderNumber =
//              format_param.EndCylinderNumber   = (DWORD)LastAccess[LogDrv].cylinder;
//              format_param.StartHeadNumber     =
//              format_param.EndHeadNumber       = (DWORD)LastAccess[LogDrv].head;
//      }
//----------------------------------------------------------------------
        if( getAH() & OP_SEEK )
        {
                format_param.StartCylinderNumber =
                format_param.EndCylinderNumber   = (DWORD)getCL();
        }
        else
        {
                format_param.StartCylinderNumber =
                format_param.EndCylinderNumber   = (DWORD)LastAccess[LogDrv].cylinder;
        }
        format_param.StartHeadNumber     =
        format_param.EndHeadNumber       = (DWORD)( getDH() & 0x01 );
//----- Chg-End --------------------------------------------------------

        status = NtDeviceIoControlFile( fd,
                                        0,
                                        NULL,
                                        NULL,
                                        &io_status_block,
                                        IOCTL_DISK_FORMAT_TRACKS,
                                        (PVOID)&format_param,
                                        sizeof(FORMAT_PARAMETERS),
                                        (PVOID)&bad_track,
                                        sizeof(bad_track)
                                        );

//----- Add-Start <93.12.29> Bug-Fix -----------------------------------
        /*
        **      save accessed cylinder number
        */
        if( getAH() & OP_SEEK )
        {
                LastAccess[LogDrv].cylinder = (UCHAR)format_param.EndCylinderNumber;
                LastAccess[LogDrv].head = (UCHAR)format_param.EndHeadNumber;
        }
//----- Add-End --------------------------------------------------------

        if(!NT_SUCCESS(status))
        {
                NtClose(fd);
                SetErrorCode(status);
                return;
        }

//----- Del-Start <93.12.28> Bug-Fix -----------------------------------
//      if( getAH() & OP_SEEK )
//      {
//              LastAccess[LogDrv].cylinder = (UCHAR)format_param.EndCylinderNumber;
//              LastAccess[LogDrv].head = (UCHAR)format_param.EndHeadNumber;
//      }
//----- Del-End --------------------------------------------------------

//----- Add-Start <93.12.28> Bug-Fix -----------------------------------
        /*
        **      if specified pattern data is different default
        **      pattern (E5H), then write specified pattern data
        **      to the track.
        */
        if( (PatternData = getDL()) != DEFAULT_PATTERN )
        {
                /*
                **      detection track length
                */
                switch( media_type )
                {
#if 1                                                                    // NEC 941110
                        case F5_1Pt23_1024:     TrackLength = 8l * 1024l;// NEC 941110
#else                                                                    // NEC 941110
                        case F5_1Pt2_1024:      TrackLength = 8l * 1024l;
#endif                                                                   // NEC 941110
                                                break;
                        case F3_1Pt44_512:      TrackLength = 18l * 512l;
                                                break;
                        case F5_1Pt2_512:       TrackLength = 15l * 512l;
                                                break;

                        case F3_720_512:        TrackLength = 9l * 512l;
                        default:                break;
                }

                /*
                **      allocate temporary buffer for writing pattern data
                */
                if( (temp_buffer=(PBYTE)malloc( TrackLength )) == NULL )
                {
                        NtClose(fd);
                        SetErrorCode((NTSTATUS)STATUS_UNSUCCESSFUL);
                        return;
                }

                /*
                **      fill temporary buffer with pattern data
                */
                for( i=0; i<TrackLength; i++)
                        temp_buffer[i] = PatternData;

                /*
                **      calculate writing start offset on "drive".
                **
                **      StartOffset = ( CylinderNo. * 2 + HeadNo. ) * SectorsPerTrack * BytesPerSector
                **                  = ( CylinderNo. * 2 + HeadNo. ) * TrackLength
                */
                //      temp = CylinderNo. * TracksPerCylinder( = 2 )
                LItemp = RtlConvertUlongToLargeInteger( (ULONG)format_param.EndCylinderNumber );
                StartOffset = RtlExtendedIntegerMultiply( LItemp, 2l );
                //      temp += HeadNo.
                LItemp = RtlConvertUlongToLargeInteger( (ULONG)format_param.EndHeadNumber );
                StartOffset = RtlLargeIntegerAdd( StartOffset, LItemp);
                //      StartOffset = temp * TrackLength
                StartOffset = RtlExtendedIntegerMultiply( StartOffset, TrackLength );

                /*
                **      now, write pattern data
                */
                status = NtWriteFile(   fd,
                                        0,
                                        NULL,
                                        NULL,
                                        &io_status_block,
                                        (PVOID)temp_buffer,
                                        TrackLength,
                                        &StartOffset,
                                        NULL
                                        );

                /*
                **      note: we have already saved last accessed
                **            cylinder number.
                */

                if(!NT_SUCCESS(status))
                {
                        free((PVOID)temp_buffer);
                        NtClose(fd);
                        SetErrorCode(status);
                        return;
                }
        }
//----- Add-End --------------------------------------------------------

        NtClose(fd);
        setAH(FLS_NORMAL_END);
        SetDiskBiosCarryFlag(0);

#else  // !NEC_98
	/*
	 *	Format the diskette in "drive"
	 *
	 *	Register inputs:	
	 *		DH	head number
	 *		CH	track number
	 *		CL	sector number
	 *		AL	number of sectors
	 *		ES:BX	address fields for the track
	 *	Register outputs:
	 *		AH	diskette status
	 *		CF	status flag
	 */
	FDC_CMD_BLOCK fdc_cmd_block[MAX_COMMAND_LEN];
	half_word motor_status;

	/*
	** Set up format params so hp_flop3.c can find out what they are when
	** the format is about to happen.
	** cylinder, head, sector and Number of sectors.
	*/
	f_cyl = getCH();
	f_head = getDH();
	f_sector = getCL();
	f_N = getAL();

	/*
	 *	Establish the default format for the size of drive, unless
	 *	this has already been set up via previous calls to
	 *	diskette_io()
	 */

	translate_new(drive);
	fmt_init(drive);

	/*
	 *	A write operation
	 */

	sas_load(MOTOR_STATUS, &motor_status);
	motor_status |= MS_WRITE_OP;
	sas_store(MOTOR_STATUS, motor_status);


	/*
	 *	Don't proceed with the format if a DUAL card is installed
	 *	and the media has been changed
	 */

	if ((! high_density(drive)) || (med_change(drive) == SUCCESS))
	{

		/*
		 *	Send the specify command to the FDC, and establish
		 *	the data rate if necessary
		 */

		send_spec();
		if (chk_lastrate(drive) != FAILURE)
			send_rate(drive);

		/*
		 *	Prepare for DMA transfer that will do the format
		 */

		if (fmtdma_set() != FAILURE)
		{

			/*
			 *	Seek to the required track, and initialise
			 *	the FDC for the format
			 */

                        put_c3_cmd(fdc_cmd_block, FDC_FORMAT_TRACK);
			put_c3_pad1(fdc_cmd_block, 0);
			put_c3_MFM(fdc_cmd_block, 1);
			put_c3_pad(fdc_cmd_block, 0);
			nec_init(drive, fdc_cmd_block);


			/*
			 *	Send the remainder of the format
			 *	parameters to the FDC
			 */

			nec_output(get_parm(DT_N_FORMAT));
			nec_output(get_parm(DT_LAST_SECTOR));
			nec_output(get_parm(DT_FORMAT_GAP_LENGTH));
			nec_output(get_parm(DT_FORMAT_FILL_BYTE));


			/*
			 *	Complete the FDC command
			 */

			(void )nec_term();
		}
	}


	/*
	 *	Return without setting sectors transferred
	 */

	translate_old(drive);
	setup_end(IGNORE_SECTORS_TRANSFERRED);

#endif // !NEC_98
}

void fl_fnc_err IFN1(int, drive)
{
	/*
	 *	This routine sets the diskette status when an illegal
	 *	function number or drive number is passed to diskette_io();
	 *	"drive" is not significant
	 *
	 *	Register inputs:	
	 *		none
	 *	Register outputs:
	 *		AH	diskette status
	 *		CF	status flag
	 */
	UNUSED(drive);
	
#if defined(NEC_98)
        /*
        **      Invalid command is normal end.
        */
        setAH(FLS_NORMAL_END);
        SetDiskBiosCarryFlag(0);

#else  // NEC_98
	setAH(FS_BAD_COMMAND);
	sas_store(FLOPPY_STATUS, FS_BAD_COMMAND);
	setCF(1);
#endif // !NEC_98
}

void fl_disk_parms IFN1(int, drive)
{
	/*
	 *	Return the drive parameters
	 *
	 *	Register inputs:	
	 *		none
	 *	Register outputs:
	 *		CL	sectors/track
	 *		CH	maximum track number
	 *		BL	drive type
	 *		BH	0
	 *		DL	number of diskette drives
	 *		DH	maximum head number
	 *		ES:DI	parameter table address
	 *		AX	0
	 *		CF	0
	 */
	half_word disk_state, drive_type;
	half_word parameter;
	word segment, offset;
	EQUIPMENT_WORD equip_flag;


	/*
	 *	Set up number of diskette drives attached
	 */

	translate_new(drive);
	setBX(0);
	sas_loadw(EQUIP_FLAG, &equip_flag.all);
	if (equip_flag.bits.diskette_present == 0)
		setDL(0);
	else
		setDL((UCHAR)(equip_flag.bits.max_diskette + 1));


	/*
	 *	Set up drive dependent parameters
	 */

#ifdef NTVDM
	if (    (equip_flag.bits.diskette_present == 1)
	     && (drive < number_of_floppy))
#else
	if (    (equip_flag.bits.diskette_present == 1)
	     && (drive < MAX_FLOPPY))
#endif /* NTVDM */
	{

		if (! high_density(drive))
		{

			/*
			 *	Set up sectors/track, drive type and
			 *	maximum track number
			 */

			setCL(9);
			sas_load(FDD_STATUS+drive, &disk_state);
			if ((disk_state & DC_80_TRACK) == 0)
			{
				drive_type = GFI_DRIVE_TYPE_360;
				setCH(MAXIMUM_TRACK_ON_360);
			}
			else
			{
				drive_type = GFI_DRIVE_TYPE_720;
				setCH(MAXIMUM_TRACK_ON_720);
			}
			setBX(drive_type);


			/*
			 *	Set up maximum head and parameter table
			 *	address, return OK
			 */

			setDH(1);
			(void )dr_type_check(drive_type, &segment, &offset);
			setDI(offset);
			setES(segment);
			translate_old(drive);
			setAX(0);
			setCF(0);
			return;
		}


		/*
		 *	Dual card present: set maximum head number and
		 *	try to establish a parameter table entry for
		 *	the drive
		 */

		setDH(1);

		if (    cmos_type(drive, &drive_type) != FAILURE
		     && drive_type != GFI_DRIVE_TYPE_NULL
		     && dr_type_check(drive_type, &segment, &offset) != FAILURE)
		{


			/*
			 *	Set parameters from parameter table
			 */

			setBL(drive_type);
			sas_load(effective_addr(segment,offset)
					+ DT_LAST_SECTOR, &parameter);
			setCL(parameter);
			sas_load(effective_addr(segment,offset)
					+ DT_MAXIMUM_TRACK, &parameter);
			setCH(parameter);
			setDI(offset);
			setES(segment);
			translate_old(drive);
			setAX(0);
			setCF(0);
			return;
		}

		/*
		 *	Establish drive type from status
		 */

		sas_load(FDD_STATUS+drive, &disk_state);
		if ((disk_state & FS_MEDIA_DET) != 0)
		{
			switch(disk_state & RS_MASK)
			{
			case RS_250:
				if ((disk_state & DC_80_TRACK) == 0)
					drive_type = GFI_DRIVE_TYPE_360;
				else
					drive_type = GFI_DRIVE_TYPE_144;
				break;
			case RS_300:
				drive_type = GFI_DRIVE_TYPE_12;
				break;
			case RS_1000:
				drive_type = GFI_DRIVE_TYPE_288;
				break;
			default:
				drive_type = GFI_DRIVE_TYPE_144;
				break;
			}
			(void )dr_type_check(drive_type, &segment, &offset);


			/*
			 *	Set parameters from parameter table
			 */

			setBL(drive_type);
			sas_load(effective_addr(segment,offset)
				+ DT_LAST_SECTOR, &parameter);
			setCL(parameter);
			sas_load(effective_addr(segment,offset)
				+ DT_MAXIMUM_TRACK, &parameter);
			setCH(parameter);
			setDI(offset);
			setES(segment);
			translate_old(drive);
			setAX(0);
			setCF(0);
			return;
		}
	}


	/*
	 *	Arrive here if "drive" is invalid or if its type
	 *	could not be determined
	 */

	setCX(0);
	setDH(0);
	setDI(0);
	setES(0);
	translate_old(drive);
	setAX(0);
	setCF(0);
	return;
}

void fl_disk_type IFN1(int, drive)
{
	/*
	 *	Return the diskette drive type for "drive"
	 *
	 *	Register inputs:	
	 *		none
	 *	Register outputs:
	 *		AH	drive type
	 *		CF	0
	 */
	half_word disk_state;
	EQUIPMENT_WORD equip_flag;

	note_trace1( GFI_VERBOSE, "floppy:fl_disk_type():drive=%x:", drive );
	if (high_density(drive))
	{
		/*
		 *	Dual card present: set type if "drive" valid
		 */
		note_trace0( GFI_VERBOSE, "floppy:fl_disk_type():DUAL CARD" );

		translate_new(drive);

		sas_load(FDD_STATUS+drive, &disk_state);
		if (disk_state == 0)
			setAH(DRIVE_IQ_UNKNOWN);
		else if ((disk_state & DC_80_TRACK) != 0)
			setAH(DRIVE_IQ_CHANGE_LINE);
		else
			setAH(DRIVE_IQ_NO_CHANGE_LINE);
		translate_old(drive);
	}
	else
	{
		note_trace0( GFI_VERBOSE,"floppy:fl_disk_type():NO DUAL CARD" );
		/*
		 *	Set no change line support if "drive" valid
		 */
		sas_loadw(EQUIP_FLAG, &equip_flag.all);
		if (equip_flag.bits.diskette_present)
			setAH(DRIVE_IQ_NO_CHANGE_LINE);
		else
			setAH(DRIVE_IQ_UNKNOWN);
	}

	setCF(0);

#ifndef PROD
switch( getAH() ){
case DRIVE_IQ_UNKNOWN: note_trace0( GFI_VERBOSE, "unknown drive\n" ); break;
case DRIVE_IQ_CHANGE_LINE: note_trace0( GFI_VERBOSE, "change line\n" ); break;
case DRIVE_IQ_NO_CHANGE_LINE: note_trace0( GFI_VERBOSE, "no change line\n" ); break;
default: note_trace0( GFI_VERBOSE, "bad AH return value\n" ); break;
}
#endif

}

void fl_disk_change IFN1(int, drive)
{
	/*
	 *	Return the state of the disk change line for "drive"
	 *
	 *	Register inputs:	
	 *		none
	 *	Register outputs:
	 *		AH	diskette status
	 *		CF	status flag
	 */
	half_word disk_state, diskette_status;

	note_trace1( GFI_VERBOSE, "floppy:fl_disk_change(%d)", drive);
	if (! high_density(drive))
	{
		/*
		 *	Only dual card supports change line, so call
		 *	the error function
		 */
		fl_fnc_err(drive);
	}
	else
	{
		translate_new(drive);
		sas_load(FDD_STATUS+drive, &disk_state);
		if (disk_state != 0)
		{
			/*
			 *	If "drive" is high density, check for
			 * 	a disk change
			 */
			if (    ((disk_state & DC_80_TRACK) == 0)
			     || (read_dskchng(drive) != SUCCESS))
			{
				sas_load(FLOPPY_STATUS, &diskette_status);
				diskette_status = FS_MEDIA_CHANGE;
				sas_store(FLOPPY_STATUS, diskette_status);
			}
		}
		else
		{
			/*
			 *	"drive" is invalid
			 */
			sas_load(FLOPPY_STATUS, &diskette_status);
			diskette_status |= FS_TIME_OUT;
			sas_store(FLOPPY_STATUS, diskette_status);
		}


		/*
		 *	Return without setting sectors transferred
		 */

		translate_old(drive);
		setup_end(IGNORE_SECTORS_TRANSFERRED);
	}
}

void fl_format_set IFN1(int, drive)
{
	/*
	 *	Establish type of media to be used for subsequent format
	 *	operation
	 *
	 *	Register inputs:	
	 *		AL	media type
	 *	Register outputs:
	 *		AH	diskette status
	 *		CF	status flag
	 */
	half_word media_type = getAL(), disk_state, diskette_status;

	translate_new(drive);
	sas_load(FDD_STATUS+drive, &disk_state);
	disk_state &= ~(FS_MEDIA_DET | FS_DOUBLE_STEP | RS_MASK);
	sas_store(FDD_STATUS+drive, disk_state);

	if (media_type == MEDIA_TYPE_360_IN_360)
	{
		/*
		 *	Need to set low data rate
		 */
		disk_state |= (FS_MEDIA_DET | RS_250);
		sas_store(FDD_STATUS+drive, disk_state);
	}
	else
	{
		if (high_density(drive))
		{

			/*
			 *	Need to check for media change
			 */

			(void )med_change(drive);
			sas_load(FLOPPY_STATUS, &diskette_status);
			if (diskette_status == FS_TIME_OUT)
			{
				/*
				 *	Return without setting sectors
				 *	transferred
				 */
				translate_old(drive);
				setup_end(IGNORE_SECTORS_TRANSFERRED);
				return;
			}
		}

		switch(media_type)
		{
		case	MEDIA_TYPE_360_IN_12:
			/*
			 *	Need to set low density and double step
			 */
			disk_state |= (FS_MEDIA_DET | FS_DOUBLE_STEP | RS_300);
			sas_store(FDD_STATUS+drive, disk_state);
			break;
		case	MEDIA_TYPE_12_IN_12:
			/*
			 *	Need to set high density
			 */
			disk_state |= (FS_MEDIA_DET | RS_500);
			sas_store(FDD_STATUS+drive, disk_state);
			break;
		case	MEDIA_TYPE_720_IN_720:
			/*
			 *	Set 300kbs data rate if multi-format
			 *	supported on drive, otherwise 250kbs
			 */
			if (    ((disk_state & DC_DETERMINED) != 0)
			     && ((disk_state & DC_MULTI_RATE) != 0))
				disk_state |= (FS_MEDIA_DET | RS_300);
			else
				disk_state |= (FS_MEDIA_DET | RS_250);
			sas_store(FDD_STATUS+drive, disk_state);
			break;

		default:
			/*
			 *	Unsupported media type
			 */
			sas_load(FLOPPY_STATUS, &diskette_status);
			diskette_status = FS_BAD_COMMAND;
			sas_store(FLOPPY_STATUS, diskette_status);
			break;
		}
	}

	/*
	 *	Return without setting sectors transferred
	 */

	translate_old(drive);
	setup_end(IGNORE_SECTORS_TRANSFERRED);
}

void fl_set_media IFN1(int, drive)
{
	/*
	 *	Set the type of media and data rate to be used in the
	 *	subsequent format operation
	 *
	 *	Register inputs:	
	 *		CH	maximum track number
	 *		CL	sectors/track
	 *	Register outputs:
	 *		ES:DI	parameter table address
	 *		AH	diskette status
	 *		CF	status flag
	 */
	half_word max_track = getCH(), sectors = getCL();
	half_word dt_max_track, dt_sectors;
	half_word drive_type, diskette_status, disk_state, data_rate;
	half_word dt_drive_type;
	half_word lastrate;
	word md_segment, md_offset;
#ifdef NTVDM
	sys_addr dt_start = dr_type_addr;
	sys_addr dt_end = dr_type_addr + DR_CNT * DR_SIZE_OF_ENTRY;
#else
	sys_addr dt_start = DR_TYPE_ADDR;
	sys_addr dt_end = DR_TYPE_ADDR + DR_CNT * DR_SIZE_OF_ENTRY;
#endif
	sys_addr md_table;

	translate_new(drive);
	
	/*
	 *	Check for a media change on drives with a change line
	 */

	sas_load(FDD_STATUS+drive, &disk_state);
	if ((disk_state & DC_80_TRACK) != 0)
	{
		(void )med_change(drive);

		sas_load(FLOPPY_STATUS, &diskette_status);
		if (diskette_status == FS_TIME_OUT)
		{
			/*
			 *	Return without setting sectors
			 *	transferred
			 */
			translate_old(drive);
			setup_end(IGNORE_SECTORS_TRANSFERRED);
			return;
		}

		sas_store(FLOPPY_STATUS, FS_OK);
	}

	/*
	 *	Search the parameter table for the correct entry
	 */

	if (cmos_type(drive, &drive_type) == FAILURE)
	{
		sas_store(FLOPPY_STATUS, FS_MEDIA_NOT_FOUND);
	}
	else if (drive_type != 0)
	{
		if (dr_type_check(drive_type, &md_segment, &md_offset) == FAILURE)
		{
			sas_store(FLOPPY_STATUS, FS_MEDIA_NOT_FOUND);
		}
		else
		{
			/*
			 *	Try to find the parameter table entry which
			 *	has both the right drive type and matches
			 *	the max sector and max track numbers
			 */
			while (dt_start < dt_end)
			{
				sas_load(dt_start, &dt_drive_type);
				if ((dt_drive_type & ~DR_WRONG_MEDIA) == drive_type)
				{
					sas_loadw(dt_start+sizeof(half_word), &md_offset);
					md_table = effective_addr(md_segment, md_offset);

					sas_load(md_table + DT_LAST_SECTOR, &dt_sectors);
					sas_load(md_table + DT_MAXIMUM_TRACK, &dt_max_track);
					if (dt_sectors == sectors && dt_max_track == max_track)
						break;
				}

				dt_start += DR_SIZE_OF_ENTRY;
			}

			if (dt_start >= dt_end)
			{
				/*
				 *	Failed to find an entry
				 */
				sas_store(FLOPPY_STATUS, FS_MEDIA_NOT_FOUND);
			}
			else
			{
				/*
				 *	Update disk state and store
				 *	parameter table address
				 */

				sas_load(md_table+DT_DATA_TRANS_RATE, &data_rate);
				if (data_rate == RS_300)
					data_rate |= FS_DOUBLE_STEP;

				data_rate |= FS_MEDIA_DET;
				sas_load(FDD_STATUS+drive, &disk_state);

/*	CHECK - IN CASE OF 2 DRIVES
 * check last rate against the new data rate set
 * in the status byte. If they differ
 * set BIOS RATE STATUS byte to reflect old rate status
 * for this drive as it may have been altered by an
 * access to the other drive. This may result in a call
 * to send_rate not being performed because the old
 * rate status (possibly for the other drive) matching the
 * new data rate for this drive, when actually the last rate
 * attempted for this drive was different. Thus the
 * controller for this drive is at an old rate (for low
 * density say) and we are assuming it has been previously
 * set to the updated (high) state when it has not!
 * In all this will ensure the updated data rate being sent
 * for the drive concerned !
 */
				if ((disk_state & RS_MASK) != (data_rate & RS_MASK))
				{
					sas_load(RATE_STATUS, &lastrate);
					/*LINTIGNORE*/
					lastrate &= ~RS_MASK;
					lastrate |= disk_state & RS_MASK;
					sas_store(RATE_STATUS, lastrate);
				}
				
				disk_state &= ~(FS_MEDIA_DET | FS_DOUBLE_STEP | RS_MASK);
				disk_state |= data_rate;
				sas_store(FDD_STATUS+drive, disk_state);

				setES(md_segment);
				setDI(md_offset);
			}
		}
	}

	/*
	 *	Return without setting sectors transferred
	 */

	translate_old(drive);
	setup_end(IGNORE_SECTORS_TRANSFERRED);
}

LOCAL dr_type_check IFN3(half_word, drive_type, word *, seg_ptr, word *, off_ptr)
{
	/*
	 *	Return the address of the first parameter table entry
	 *	that matches "drive_type"
	 */
	half_word dt_drive_type;
	sys_addr dt_start, dt_end;

#ifdef NTVDM
	*seg_ptr = dr_type_seg;

	dt_start = dr_type_addr;
	dt_end = dr_type_addr + DR_CNT * DR_SIZE_OF_ENTRY;
#else
	*seg_ptr = DISKETTE_IO_1_SEGMENT;

	dt_start = DR_TYPE_ADDR;
	dt_end = DR_TYPE_ADDR + DR_CNT * DR_SIZE_OF_ENTRY;
#endif  /* NTVDM */

	while (dt_start < dt_end)
	{
		sas_load(dt_start, &dt_drive_type);
		if (dt_drive_type == drive_type)
		{
			sas_loadw(dt_start+sizeof(half_word), off_ptr);
			return(SUCCESS);
		}

		dt_start += DR_SIZE_OF_ENTRY;
	}

	return(FAILURE);
}

LOCAL void send_spec IFN0()
{
	/*
	 *	Send a specify command to the FDC using data from the
	 *	parameter table pointed to by @DISK_POINTER
	 */
	nec_output(FDC_SPECIFY);
	nec_output(get_parm(DT_SPECIFY1));
	nec_output(get_parm(DT_SPECIFY2));
}

LOCAL void send_spec_md IFN2(word, segment, word, offset)
{
	/*
	 *	Send a specify command to the FDC using data from the
	 *	parameter table pointed to by "segment" and "offset"
 	 */
	half_word parameter;
	
	nec_output(FDC_SPECIFY);
	sas_load(effective_addr(segment, offset+DT_SPECIFY1), &parameter);
	nec_output(parameter);
	sas_load(effective_addr(segment, offset+DT_SPECIFY2), &parameter);
	nec_output(parameter);
}

LOCAL void translate_new IFN1(int, drive)
{
	/*
	 *	Translates diskette state locations from compatible
	 *	mode to new architecture
	 */
	half_word hf_cntrl, disk_state;

	sas_load(DRIVE_CAPABILITY, &hf_cntrl);

#ifdef NTVDM
	if (high_density(drive) && (drive < number_of_floppy))
#else
	if (high_density(drive) && (drive < MAX_FLOPPY))
#endif /* NTVDM */
	{
		sas_load(FDD_STATUS+drive, &disk_state);
		if (disk_state == 0)
		{
			/*
			 *	Try to establish drive capability
			 */
			drive_detect(drive);
		}
		else
		{
			/*
			 *	Copy drive capability bits
			 */
			hf_cntrl >>= (drive << 2);
			hf_cntrl &= DC_MASK;
			disk_state &= ~DC_MASK;
			disk_state |= hf_cntrl;
			sas_store(FDD_STATUS+drive, disk_state);
		}
	}
}

void translate_old IFN1(int, drive)
{
	/*
	 *	Translates diskette state locations from new
	 *	architecture to compatible mode
	 */
	half_word hf_cntrl, disk_state, mode, drive_type;
	int shift_count = drive << 2;

	sas_load(DRIVE_CAPABILITY, &hf_cntrl);
	sas_load(FDD_STATUS+drive, &disk_state);

#ifdef NTVDM
	if (high_density(drive) && (drive < number_of_floppy) && (disk_state != 0))
#else
	if (high_density(drive) && (drive < MAX_FLOPPY) && (disk_state != 0))
#endif  /* NTVDM */

	{
		/*
		 *	Copy drive capability bits
		 */
		if ((hf_cntrl & (DC_MULTI_RATE << shift_count)) == 0)
		{
			hf_cntrl &= ~(DC_MASK << shift_count);
			hf_cntrl |= (disk_state & DC_MASK) << shift_count;
			sas_store(DRIVE_CAPABILITY, hf_cntrl);
		}

		/*
		 *	Copy media type bits
		 */

		switch (disk_state & RS_MASK)
		{
		case RS_500:
			/*
			 *	Drive should be a 1.2M
			 */
			if (    (cmos_type(drive, &drive_type) != FAILURE)
			     && (drive_type == GFI_DRIVE_TYPE_12))
			{
				mode = FS_12_IN_12;
				if ((disk_state & FS_MEDIA_DET) != 0)
					mode = media_determined(mode);
			}
			else
			{
				mode = FS_DRIVE_SICK;
			}
			break;

		case RS_300:
			/*
			 *	Should be double-stepping for 360K floppy
			 *	in 1.2M drive
			 */
			mode = FS_360_IN_12;
			if ((disk_state & FS_DOUBLE_STEP) != 0)
			{
				if ((disk_state & FS_MEDIA_DET) != 0)
					mode = media_determined(mode);
			}
			else
			{
				mode = FS_DRIVE_SICK;
			}
			break;

		case RS_250:
			/*
			 *	Should be 360K floppy in 360K drive,
			 *	ie 250kbs and 40 track
			 */
			if ((disk_state & DC_80_TRACK) == 0)
			{
				mode = FS_360_IN_360;
				if ((disk_state & FS_MEDIA_DET) != 0)
					mode = media_determined(mode);
			}
			else
			{
				mode = FS_DRIVE_SICK;
			}
			break;

		case RS_1000:
			/*
			 *	Drive should be a 2.88M
			 */
			if (    (cmos_type(drive, &drive_type) != FAILURE)
			     && (drive_type == GFI_DRIVE_TYPE_288))
			{
				mode = FS_288_IN_288;
				if ((disk_state & FS_MEDIA_DET) != 0)
					mode = media_determined(mode);
			}
			else
			{
				mode = FS_DRIVE_SICK;
			}
			break;

		default:
			/*
			 *	Weird data rate
			 */
			mode = FS_DRIVE_SICK;
			break;
		}

		disk_state &= ~DC_MASK;
		disk_state |= mode;
		sas_store(FDD_STATUS+drive, disk_state);
	}
}

LOCAL void rd_wr_vf IFN3(int, drive, FDC_CMD_BLOCK *, fcbp, half_word, dma_type)
{
	/*
	 *	Common read, write and verify; main loop for data rate
	 *	retries
	 */
	half_word data_rate, dt_data_rate, drive_type, dt_drive_type;
	half_word disk_state;
	sys_addr dt_start, dt_end;
	int sectors_transferred;
	word md_segment, md_offset;
	/*
	 *	Establish initial data rate, then loop through each
	 *	possible data rate
	 */
	translate_new(drive);
	setup_state(drive);
	while ((! high_density(drive)) || med_change(drive) == SUCCESS)
	{
		sas_load(FDD_STATUS+drive, &disk_state);
		data_rate = (half_word)(disk_state & RS_MASK);
		if (cmos_type(drive, &drive_type) != FAILURE)
		{
			/*
			 *	Check CMOS value against what is really
			 *	known about the drive
			 */
			/*
			 * The original code here had a very bad case of "Bad-C"
			 * if-if-else troubles, but replacing the code with
			 * the switch statement originally intended breaks
			 * 5.25" floppies. I have removed the redundant bits
			 * of the code, but BEWARE - there is a another
			 * fault somewhere to cancel out this one!
			 * William Roberts - 9/2/93
			 */
			if (drive_type == GFI_DRIVE_TYPE_360)
			{
				if ((disk_state & DC_80_TRACK) != 0)
				{
					drive_type = GFI_DRIVE_TYPE_12;
				}
		     /* else if (drive_type == GFI_DRIVE_TYPE_12) ... */
			}

			/*
			** dr_type_check() looks for the first matching drive
			** value in the small table and returns a
			** pointer to the coresponding entry in the big
			** parameter table.
			** The segment is used later on but the offset is
			** determined by a subsequent search of the table below.
			** These table live in ROM (see bios2.rom) fe00:c80
			*/
			if (    (drive_type != GFI_DRIVE_TYPE_NULL)
			     && (dr_type_check(drive_type, &md_segment, &md_offset) != FAILURE))
			{
				/*
				 *	Try to find parameter table entry with
				 *	right drive type and current data rate
				 */
#ifdef NTVDM
				dt_start = dr_type_addr;
				dt_end = dr_type_addr + DR_CNT * DR_SIZE_OF_ENTRY;
#else
				dt_start = DR_TYPE_ADDR;
				dt_end = DR_TYPE_ADDR + DR_CNT * DR_SIZE_OF_ENTRY;
#endif /* NTVDM */
				while (dt_start < dt_end)
				{
					/*
					** get drive type from table
					*/
					sas_load(dt_start, &dt_drive_type);
					if ((dt_drive_type & ~DR_WRONG_MEDIA) == drive_type)
					{
						/*
						** get data rate from table
						*/
						sas_loadw(dt_start+sizeof(half_word), &md_offset);
						sas_load(effective_addr(md_segment, md_offset) + DT_DATA_TRANS_RATE, &dt_data_rate);
						/*
						** if table rate matches that
						** selected by setup_state()
						** then try current table entry
						** parameters.
						*/
						if (data_rate == dt_data_rate)
							break;
					}

					dt_start += DR_SIZE_OF_ENTRY;
				}
				if (dt_start >= dt_end)
				{
					/*
					 *	Assume media matches drive
					 */
#ifdef NTVDM
					md_segment = dr_type_seg;
					md_offset = dr_type_off;
					if ((disk_state & DC_80_TRACK) == 0)
						md_offset += MD_TBL1_OFFSET;
					else
						md_offset += MD_TBL3_OFFSET;
#else
					md_segment = DISKETTE_IO_1_SEGMENT;
					if ((disk_state & DC_80_TRACK) == 0)
						md_offset = MD_TBL1_OFFSET;
					else
						md_offset = MD_TBL3_OFFSET;
#endif  /* NTVDM */
						
				}
			}
			else
			{
				/*
				 *	Assume media matches drive
				 */
#ifdef NTVDM
				md_segment = dr_type_seg;
				md_offset = dr_type_off;
				if ((disk_state & DC_80_TRACK) == 0)
					md_offset += MD_TBL1_OFFSET;
				else
					md_offset += MD_TBL3_OFFSET;
#else
				md_segment = DISKETTE_IO_1_SEGMENT;
				if ((disk_state & DC_80_TRACK) == 0)
					md_offset = MD_TBL1_OFFSET;
				else
					md_offset = MD_TBL3_OFFSET;
#endif	/* NTVDM */
			}
		}
		else
		{
			/*
			 *	Assume media matches drive
			 */
#ifdef NTVDM
			md_segment = dr_type_seg;
			md_offset = dr_type_off;
			if ((disk_state & DC_80_TRACK) == 0)
				md_offset += MD_TBL1_OFFSET;
			else
				md_offset += MD_TBL3_OFFSET;
#else
			md_segment = DISKETTE_IO_1_SEGMENT;
			if ((disk_state & DC_80_TRACK) == 0)
				md_offset = MD_TBL1_OFFSET;
			else
				md_offset = MD_TBL3_OFFSET;
#endif /* NTVDM */
		}

		/*
		 *	Send a specify command to the FDC; change the
		 *	rate if it has been updated
		 */
		send_spec_md(md_segment, md_offset);
		if (chk_lastrate(drive) != FAILURE)
			send_rate(drive);

		/*
		 *	Decide whether double stepping is required for
		 *	the data rate currently being tried
		 */

		if (setup_dbl(drive) != FAILURE)
		{
			if (dma_setup(dma_type) == FAILURE)
			{
				translate_old(drive);
				setup_end(IGNORE_SECTORS_TRANSFERRED);
				return;
			}

			/*
			 *	Attempt the transfer
			 */
			nec_init(drive, fcbp);
			rwv_com(md_segment, md_offset);
			(void )nec_term();
		}

		/*
		** Will select next data rate in range specified by
		** setup_state() and try again.
		** When there are no more rates give up.
		*/
		if (retry(drive) == SUCCESS)
			break;
	}

	/*
	 *	Determine the current drive state and return, setting
	 *	the number of sectors actually transferred
	 */
	dstate(drive);
	sectors_transferred = num_trans();
	translate_old(drive);
	setup_end(sectors_transferred);
}

LOCAL void setup_state IFN1(int, drive)
{
#ifndef NEC_98
	half_word	drive_type;	/* Floppy unit type specified by CMOS */

	/*
	 *	Initialises start and end data rates
	 */
	half_word disk_state, start_rate, end_rate, lastrate;

	if (high_density(drive))
	{
		sas_load(FDD_STATUS+drive, &disk_state);
#ifndef NTVDM
		if ((disk_state & FS_MEDIA_DET) == 0)
		{

			/*
			 *	Set up first and last data rates to
			 *	try
			 */
			if (    ((disk_state & DC_DETERMINED) != 0)
			     && ((disk_state & DC_MULTI_RATE) == 0) )
			{
				/* not a multi-rate drive */
				start_rate = end_rate = RS_250;
			}
			else
			{
				/* multi-rate drive */
/*
 * The real BIOS always sets up start_rate=500 and end_rate=300
 * If we attempt this then some bug (not yet found) will cause the following
 * sequence to fail (5.25") low density read followed by high density read.
 * This gives rate transitions 500 -> 250 -> 300 -> 500 ...
 * Read the drive type from CMOS and adjust the start and end rates to match.
 * The CMOS drive type is set up during cmos_post() by calling config_inquire().
*/
if( cmos_type( drive, &drive_type ) != FAILURE ){
	switch( drive_type ){
		case GFI_DRIVE_TYPE_360:
		case GFI_DRIVE_TYPE_12:
			start_rate = RS_300;	/* different to Real BIOS */
			end_rate   = RS_500;
			break;
		case GFI_DRIVE_TYPE_720:
		case GFI_DRIVE_TYPE_144:
			start_rate = RS_500;	/* same as Real BIOS */
			end_rate   = RS_300;
			break;
/*
 * We don't know what the real BIOS does here.  These values work
 * fine.  Any code in rd_wr_vf that gets confused will drop out to
 * default high density values if neither of the following two
 * rates work.
 */

		case GFI_DRIVE_TYPE_288:
			start_rate = RS_1000;
			end_rate   = RS_300;
			break;
		default:
			always_trace1( "setup_state(): Bad Drive from CMOS:%x",
			                drive_type );
			break;
	}
}else{
	always_trace0( "setup_state(): CMOS read failure: Drive Type" );
}

                        }

#else /* NTVDM */

		if ((disk_state & FS_MEDIA_DET) == 0)
		{

    if( cmos_type( drive, &drive_type ) != FAILURE ){
	switch( drive_type ){
		case GFI_DRIVE_TYPE_360:
		case GFI_DRIVE_TYPE_720:
			start_rate =
			end_rate = RS_250;
			break;

		case GFI_DRIVE_TYPE_12:
			start_rate = RS_300;	/* different to Real BIOS */
			end_rate   = RS_500;
			break;
		case GFI_DRIVE_TYPE_144:
			start_rate = RS_500;	/* same as Real BIOS */
			end_rate   = RS_250;
			break;
/*
 * We don't know what the real BIOS does here.  These values work
 * fine.  Any code in rd_wr_vf that gets confused will drop out to
 * default high density values if neither of the following two
 * rates work.
 */

		case GFI_DRIVE_TYPE_288:
			start_rate = RS_1000;
			end_rate   = RS_300;
			break;
		default:
			always_trace1( "setup_state(): Bad Drive from CMOS:%x",
			                drive_type );
			break;
	}
    }else{
	always_trace0( "setup_state(): CMOS read failure: Drive Type" );
    }

#endif /* NTVDM */

			/*
			 *	Set up disk state with current data
			 *	rate; clear double stepping, which
			 *	may be re-established by a call to
			 *	setup_dbl()
			 */
			disk_state &= ~(RS_MASK | FS_DOUBLE_STEP);
			disk_state |= start_rate;
			sas_store(FDD_STATUS+drive, disk_state);

			/*
			 *	Store final rate to try in rate data
			 */
			sas_load(RATE_STATUS, &lastrate);
			lastrate &= ~(RS_MASK >> 4);
			lastrate |= (end_rate >> 4);
			sas_store(RATE_STATUS, lastrate);
		}
	}
#endif // !NEC_98
}

LOCAL void fmt_init IFN1(int, drive)
{
#ifndef NEC_98
	/*
	 *	If the media type has not already been set up, establish
	 *	the default media type for the drive type
	 */
	half_word disk_state, drive_type;

	if (high_density(drive))
	{
		sas_load(FDD_STATUS+drive, &disk_state);
		if ((disk_state & FS_MEDIA_DET) == 0)
		{
			if (    (cmos_type(drive, &drive_type) != FAILURE)
			     && (drive_type != 0))
			{
				disk_state &= ~(FS_MEDIA_DET | FS_DOUBLE_STEP | RS_MASK);
				switch(drive_type)
				{
				case GFI_DRIVE_TYPE_360:
					disk_state |= (FS_MEDIA_DET | RS_250);
					break;
				case GFI_DRIVE_TYPE_12:
				case GFI_DRIVE_TYPE_144:
					disk_state |= (FS_MEDIA_DET | RS_500);
					break;
				case GFI_DRIVE_TYPE_288:
					disk_state |= (FS_MEDIA_DET | RS_1000);
					break;
				case GFI_DRIVE_TYPE_720:
					if ((disk_state & (DC_DETERMINED|DC_MULTI_RATE))
							== (DC_DETERMINED|DC_MULTI_RATE))
						disk_state |= (FS_MEDIA_DET | RS_300);
					else
						disk_state |= (FS_MEDIA_DET | RS_250);
					break;
				default:
					disk_state = 0;
					break;
				}
			}
			else
			{
				disk_state = 0;
			}
			sas_store(FDD_STATUS+drive, disk_state);
		}
	}
#endif // !NEC_98
}

LOCAL med_change IFN1(int, drive)
{
#ifndef NEC_98
	/*
	 *	Checks for media change, resets media change,
	 *	checks media change again
	 */
	half_word disk_state, motor_status;
	
	if (high_density(drive))
	{
		if (read_dskchng(drive) == SUCCESS)
			return(SUCCESS);

		/*
		 *	Media has been changed - set media state to
		 *	undetermined
		 */
		sas_load(FDD_STATUS+drive, &disk_state);
		disk_state &= ~FS_MEDIA_DET;
		sas_store(FDD_STATUS+drive, disk_state);

		/*
		 *	Start up the motor, since opening the
		 *	door may have turned the motor off
		 */
		sas_load(MOTOR_STATUS, &motor_status);
		motor_status &= ~(1 << drive);
		sas_store(MOTOR_STATUS, motor_status);
		motor_on(drive);

		/*
		 *	This sequence of seeks should reset the
		 *	disk change line, if the door is left
		 *	alone
		 */
		fl_disk_reset(drive);
		(void )seek(drive, 1);
		(void )seek(drive, 0);

		/*
		 *	If disk change line still active, assume drive
		 *	is empty or door has been left open
		 */
		if (read_dskchng(drive) == SUCCESS)
			sas_store(FLOPPY_STATUS, FS_MEDIA_CHANGE);
		else
			sas_store(FLOPPY_STATUS, FS_TIME_OUT);
	}
	return(FAILURE);
#endif // !NEC_98
}

LOCAL void send_rate IFN1(int, drive)
{
#ifndef NEC_98
	/*
	 *	Update the data rate for "drive"
	 */
	half_word lastrate, disk_state;

	if (high_density(drive))
	{

		/*
		 *	Update the adapter data rate
		 */
		sas_load(RATE_STATUS, &lastrate);
		lastrate &= ~RS_MASK;
		sas_load(FDD_STATUS+drive, &disk_state);
		disk_state &= RS_MASK;
		lastrate |= disk_state;
		sas_store(RATE_STATUS, lastrate);

		/*
		 *	Establish the new data rate for the drive via
		 *	the floppy adapter
		 */

		outb(DISKETTE_DCR_REG, (IU8)(disk_state >> 6));
	}
#endif // !NEC_98
}

LOCAL chk_lastrate IFN1(int, drive)
{
	/*
	 *	Reply whether the adapter data rate is different to
	 *	the disk state data rate
	 */
	half_word lastrate, disk_state;

	if (rate_unitialised)
	{
		rate_unitialised = FALSE;
		return(SUCCESS);
	}
	
	sas_load(RATE_STATUS, &lastrate);
	sas_load(FDD_STATUS+drive, &disk_state);
	return((lastrate & RS_MASK) != (disk_state & RS_MASK)
			? SUCCESS : FAILURE);
}

LOCAL dma_setup IFN1(half_word, dma_mode)
{
#ifndef NEC_98
	/*
	 *	This routine sets up the DMA for read/write/verify
	 *	operations
	 */
	DMA_ADDRESS dma_address;
	reg byte_count;

	/*
	 *	Disable interrupts
	 */

	setIF(0);

	/*
	 *	Set up the DMA adapter's internal state and mode
	 */

	outb(DMA_CLEAR_FLIP_FLOP, dma_mode);
	outb(DMA_WRITE_MODE_REG, dma_mode);

	/*
	 *	Output the address to the DMA adapter as a page address
	 *	and 16 bit offset
	 */
	if (dma_mode == BIOS_DMA_VERIFY)
		dma_address.all = 0;
	else
		dma_address.all = effective_addr(getES(), getBX());
	outb(DMA_CH2_ADDRESS, dma_address.parts.low);
	outb(DMA_CH2_ADDRESS, dma_address.parts.high);
	outb(DMA_FLA_PAGE_REG, dma_address.parts.page);

	/*
	 *	Calculate the number of bytes to be transferred from the
	 *	number of sectors, and the sector size. Subtract one
	 *	because the DMA count must wrap to 0xFFFF before it
	 *	stops
	 */

	byte_count.X = ((unsigned int)getAL() << (7 + get_parm(DT_N_FORMAT))) - 1;
	outb(DMA_CH2_COUNT, byte_count.byte.low);
	outb(DMA_CH2_COUNT, byte_count.byte.high);

	/*
	 *	Enable interrupts
	 */

	setIF(1);

	/*
	 *	Set up diskette channel for the operation, checking
	 *	for wrapping of the bottom 16 bits of the address
	 */

	outb(DMA_WRITE_ONE_MASK_BIT, DMA_DISKETTE_CHANNEL);
	if (((long)dma_address.words.low + (long)byte_count.X) > 0xffff)
	{
		sas_store(FLOPPY_STATUS, FS_DMA_BOUNDARY);
		return(FAILURE);
	}

	return(SUCCESS);
#endif // !NEC_98
}

LOCAL fmtdma_set IFN0()
{
#ifndef NEC_98
	/*
	 *	This routine sets up the DMA for format operations
	 */
	DMA_ADDRESS dma_address;
	reg byte_count;

	/*
	 *	Disable interrupts
	 */

	setIF(0);

	/*
	 *	Set up the DMA adapter's internal state and mode
	 */

	outb(DMA_CLEAR_FLIP_FLOP, BIOS_DMA_WRITE);
	outb(DMA_WRITE_MODE_REG, BIOS_DMA_WRITE);

	/*
	 *	Output the address to the DMA adapter as a page address
	 *	and 16 bit offset
	 */
	dma_address.all = effective_addr(getES(), getBX());
	outb(DMA_CH2_ADDRESS, dma_address.parts.low);
	outb(DMA_CH2_ADDRESS, dma_address.parts.high);
	outb(DMA_FLA_PAGE_REG, dma_address.parts.page);

	/*
	 *	Calculate the number of bytes to be transferred from the
	 *	number of sectors per track, given that 4 bytes (C,H,R,N)
	 *	are needed to define each sector's address mark. Subtract
	 *	one because the DMA count must wrap to 0xFFFF before it
	 *	stops
	 */

	byte_count.X = ((unsigned int)get_parm(DT_LAST_SECTOR) << 2) - 1;
	outb(DMA_CH2_COUNT, byte_count.byte.low);
	outb(DMA_CH2_COUNT, byte_count.byte.high);

	/*
	 *	Enable interrupts
	 */

	setIF(1);

	/*
	 *	Set up diskette channel for the operation, checking
	 *	for wrapping of the bottom 16 bits of the address
	 */

#ifndef NTVDM
	/* we don't have to worry about this on NT */
	outb(DMA_WRITE_ONE_MASK_BIT, DMA_DISKETTE_CHANNEL);
	if (((long)dma_address.words.low + (long)byte_count.X) > 0xffff)
	{
		sas_store(FLOPPY_STATUS, FS_DMA_BOUNDARY);
		return(FAILURE);
	}
#endif

	return(SUCCESS);
#endif // !NEC_98
}

LOCAL void nec_init IFN2(int, drive, FDC_CMD_BLOCK *, fcbp)
{
	/*
	 *	This routine seeks to the requested track and
	 *	initialises the FDC for the read/write/verify
	 *	operation.
	 */

	motor_on(drive);
	if (seek(drive, (int)getCH()) != FAILURE)
	{
		nec_output(fcbp[0]);
		put_c2_head(fcbp, getDH());
		put_c2_drive(fcbp, drive);
		put_c2_pad1(fcbp, 0);
		nec_output(fcbp[1]);
	}
}

LOCAL void rwv_com IFN2(word, md_segment, word, md_offset)
{
	/*
	 *	This routine send read/write/verify parameters to the
	 *	FDC
	 */
	half_word md_gap;

	/*
	 *	Output track number, head number and sector number
	 */
	nec_output(getCH());
	nec_output(getDH());
	nec_output(getCL());

	/*
	 *	Output bytes/sector and sectors/track
	 */
	nec_output(get_parm(DT_N_FORMAT));
	nec_output(get_parm(DT_LAST_SECTOR));

	/*
	 *	Output gap length
	 */
	sas_load(effective_addr(md_segment, md_offset)+DT_GAP_LENGTH, &md_gap);
	nec_output(md_gap);

	/*
	 *	 Output data length
	 */
	nec_output(get_parm(DT_DTL));
}

LOCAL nec_term IFN0()
{
	/*
	 *	This routine waits for the operation then interprets
	 *	the results from the FDC
	 */
	half_word diskette_status;
	int wait_int_result;

	wait_int_result = wait_int();
	if (results() != FAILURE && wait_int_result != FAILURE)
	{
		/*
		 *	Result phase completed
		 */
		if ((get_r0_ST0(fl_nec_status) &
			(ST0_INTERRUPT_CODE_0 | ST0_INTERRUPT_CODE_1)) != 0)
		{
			/*
			 *	Command did not terminate normally
			 */
			sas_load(FLOPPY_STATUS, &diskette_status);
			if ((get_r0_ST0(fl_nec_status) & ST0_INTERRUPT_CODE_0)
								== 0)
			{
				/*
				 *	Problem with the FDC
				 */
				diskette_status |= FS_FDC_ERROR;

				always_trace0("diskette_io: FDC error - emetic command");
			}
			else
			{
				/*
				 *	Abnormal termination - set
				 *	diskette status up accordingly
				 */
				if (get_r0_ST1(fl_nec_status) &
						ST1_END_OF_CYLINDER)
				{
					diskette_status |= FS_SECTOR_NOT_FOUND;
				}
				else if (get_r0_ST1(fl_nec_status) &
						ST1_DATA_ERROR)
				{
					diskette_status |= FS_CRC_ERROR;
				}
				else if (get_r0_ST1(fl_nec_status) &
						ST1_OVERRUN)
				{
					diskette_status |= FS_DMA_ERROR;
				}
				else if (get_r0_ST1(fl_nec_status) &
						ST1_NO_DATA)
				{
					diskette_status |= FS_FDC_ERROR; /* Tim Sept 91, was FS_SECTOR_NOT_FOUND */
				}
				else if (get_r0_ST1(fl_nec_status) &
						ST1_NOT_WRITEABLE)
				{
					diskette_status |= FS_WRITE_PROTECTED;
				}
				else if (get_r0_ST1(fl_nec_status) &
						ST1_MISSING_ADDRESS_MARK)
				{
					diskette_status |= FS_BAD_ADDRESS_MARK;
				}
				else
				{
					/*
					 *	Problem with the FDC
					 */
					diskette_status |= FS_TIME_OUT; /* Tim Sept 91, was FS_FDC_ERROR */
					always_trace0("diskette_io: FDC error - perverted result");
				}
			}
			sas_store(FLOPPY_STATUS, diskette_status);
		}
	}
	sas_load(FLOPPY_STATUS, &diskette_status);
	return((diskette_status == FS_OK) ? SUCCESS : FAILURE);
}

LOCAL void dstate IFN1(int, drive)
{
	/*
	 *	Determine the drive state after a successful operation
	 */
	half_word diskette_status, disk_state, drive_type;

	if (high_density(drive))
	{
		sas_load(FLOPPY_STATUS, &diskette_status);
		if (diskette_status == 0)
		{
			/*
			 *	Command successful, both media and drive
			 *	are now determined
			 */
			sas_load(FDD_STATUS+drive, &disk_state);
			disk_state |= FS_MEDIA_DET;
			if ((disk_state & DC_DETERMINED) == 0)
			{
				if (    ((disk_state & RS_MASK) == RS_250)
				     && (cmos_type(drive, &drive_type) != FAILURE)
				     && (drive_type != GFI_DRIVE_TYPE_144)
				     && (drive_type != GFI_DRIVE_TYPE_288) )
				{
					/*
					 *	No multi-format capability
					 */
					disk_state &= ~DC_MULTI_RATE;
					disk_state |= DC_DETERMINED;
				}
				else
				{
					/*
					 *	Multi-format capability
					 */
					disk_state |= (DC_DETERMINED | DC_MULTI_RATE);
				}
			}
			sas_store(FDD_STATUS+drive, disk_state);
		}
	}
}

LOCAL retry IFN1(int, drive)
{
	/*
	 *	Determines whether a retry is necessary. If retry is
	 *	required then state information is updated for retry
	 */
	half_word diskette_status, disk_state, data_rate, lastrate;

	sas_load(FLOPPY_STATUS, &diskette_status);
	if (diskette_status != FS_OK && diskette_status != FS_TIME_OUT)
	{
		sas_load(FDD_STATUS+drive, &disk_state);	
		if ((disk_state & FS_MEDIA_DET) == 0)
		{
			sas_load(RATE_STATUS, &lastrate);
			if ((data_rate = (half_word)((disk_state & RS_MASK))) !=
					((lastrate << 4) & RS_MASK))
			{
				/*
				 *	Last command failed, the media
				 *	is still unknown, and there are
				 *	more data rates to check, so set
				 *	up next data rate
				 */
				data_rate = next_rate(data_rate);
			
				/*
				 *	Reset state and go for retry
				 */
				disk_state &= ~(RS_MASK | FS_DOUBLE_STEP);
				disk_state |= data_rate;
				sas_store(FDD_STATUS+drive, disk_state);	
				sas_store(FLOPPY_STATUS, FS_OK);
				return(FAILURE);
			}
		}
	}

	/*
	 *	Retry not worthwhile
	 */
	return(SUCCESS);
}

LOCAL num_trans IFN0()
{
	/*
	 *	This routine calculates the number of sectors that
	 *	were actually transferred to/from the diskette
	 */
	half_word diskette_status;
	int sectors_per_track, sectors_transferred = 0;

	sas_load(FLOPPY_STATUS, &diskette_status);
	if (diskette_status == 0)
	{
		/*
		 *	Number of sectors = final sector - initial sector
		 */
		LOAD_RESULT_BLOCK;
		sectors_transferred = get_r0_sector(fl_nec_status) - getCL();

		/*
		 *	Adjustments for spanning heads or tracks
		 */
		sectors_per_track = (int)get_parm(DT_LAST_SECTOR);
		LOAD_RESULT_BLOCK;
		if (get_r0_head(fl_nec_status) != getDH())
			sectors_transferred += sectors_per_track;
		else if (get_r0_cyl(fl_nec_status) != getCH())
			sectors_transferred += (sectors_per_track * 2);
	}

	return(sectors_transferred);
}

LOCAL void setup_end IFN1(int, sectors_transferred)
{
	/*
	 *	Restore MOTOR_COUNT to parameter provided in table;
	 *	set return status values and sectors transferred,
	 *	where applicable
	 */
	half_word diskette_status;

	sas_store(MOTOR_COUNT, get_parm(DT_MOTOR_WAIT));

	sas_load(FLOPPY_STATUS, &diskette_status);
	setAH(diskette_status);
	if (diskette_status != 0)
	{
		/*
		 *	Operation failed
		 */
		if (sectors_transferred != IGNORE_SECTORS_TRANSFERRED)
			setAL(0);
		setCF(1);
	}
	else
	{
		/*
		 *	Operation succeeded
		 */
		if (sectors_transferred != IGNORE_SECTORS_TRANSFERRED)
			setAL((UCHAR)(sectors_transferred));
		setCF(0);
	}
}

LOCAL setup_dbl IFN1(int, drive)
{
	/*
	 *	Check whether media requires to be double-stepped to
	 *	be read at the current data rate
	 */
	half_word disk_state;
	int track, max_track;
	
	if (high_density(drive))
	{
		sas_load(FDD_STATUS+drive, &disk_state);
		if ((disk_state & FS_MEDIA_DET) == 0)
		{
			/*
			 *	First check track 0 to get out quickly if
			 *	the media is unformatted
			 */
			sas_store(SEEK_STATUS, 0);
			motor_on(drive);
			(void )seek(drive, 0);
			if (read_id(drive, 0) != FAILURE)
			{

				/*
				 *	Try reading ids from cylinder 2 to
				 *	the last cylinder on both heads. If
				 *	the putative track number disagrees
				 *	with what is on the disk, then
				 *	double stepping is required
				 */
				if ((disk_state & DC_80_TRACK) == 0)
					max_track = 0x50;
				else
					max_track = 0xa0;

				for (track = 4; track < max_track; track++)
				{
					/* ensure motor stays on */
					sas_store(MOTOR_COUNT, MC_MAXIMUM);

					sas_store(FLOPPY_STATUS, FS_OK);
					(void )seek(drive, track/2);
					if (read_id(drive, track%2) == SUCCESS)
					{
						LOAD_RESULT_BLOCK;
						sas_store(FDD_TRACK+drive,
  						    get_r0_cyl(fl_nec_status));
						if ((track/2) !=
					 	    get_r0_cyl(fl_nec_status))
						{
							disk_state |= FS_DOUBLE_STEP;
							sas_store(FDD_STATUS+drive, disk_state);
						}
						return(SUCCESS);
					}
				}
			}
			return(FAILURE);
		}
	}

	return(SUCCESS);
}

LOCAL read_id IFN2(int, drive, int, head)
{
	/*
	 *	Perform the read id function
	 */
	FDC_CMD_BLOCK fdc_cmd_block[MAX_COMMAND_LEN];

        put_c4_cmd(fdc_cmd_block, FDC_READ_ID);
	put_c4_pad1(fdc_cmd_block, 0);
	put_c4_MFM(fdc_cmd_block, 1);
	put_c4_pad(fdc_cmd_block, 0);
	nec_output(fdc_cmd_block[0]);

	put_c4_drive(fdc_cmd_block, drive);
	put_c4_head(fdc_cmd_block, head);
	put_c4_pad2(fdc_cmd_block, 0);
	nec_output(fdc_cmd_block[1]);
	
	return(nec_term());
}

LOCAL cmos_type IFN2(int, drive, half_word *, type)
{
	/*	
	 *	Returns diskette type from the soft CMOS
	 */
	half_word cmos_byte;

	/*
	 *	Check the CMOS battery and checksum
	 */
	cmos_byte = cmos_read(CMOS_DIAG);
	if ((cmos_byte & (BAD_CKSUM|BAD_BAT)) != 0)
		return(FAILURE);

	/*
	 *	Read the CMOS diskette drive type byte and return
	 *	the nibble for the drive requested. The types for
	 *	drive 0 and 1 are given in the high and low nibbles
	 *	respectively.
	 */
	cmos_byte = cmos_read(CMOS_DISKETTE);
	if (drive == 0)
		cmos_byte >>= 4;
	*type = cmos_byte & 0xf;

	return(SUCCESS);
}

LOCAL half_word get_parm IFN1(int, index)
{
	/*
	 *	Return the byte in the current diskette parameter table
	 *	offset by "index"
	 */
	half_word value;
	word segment, offset;

	sas_loadw(DISK_POINTER_ADDR, &offset);
	sas_loadw(DISK_POINTER_ADDR + 2, &segment);

	sas_load(effective_addr(segment, offset+index), &value);

#ifndef PROD
        {
                char *parm_name = "Unknown???";

#define DT_PARM_NAME(x,y)       case x: parm_name = y; break;

                switch (index) {
                DT_PARM_NAME(DT_SPECIFY1,"SPECIFY1");
                DT_PARM_NAME(DT_SPECIFY2,"SPECIFY2");
                DT_PARM_NAME(DT_MOTOR_WAIT,"MOTOR_WAIT");
                DT_PARM_NAME(DT_N_FORMAT,"N_FORMAT");
                DT_PARM_NAME(DT_LAST_SECTOR,"LAST_SECTOR");
                DT_PARM_NAME(DT_GAP_LENGTH,"GAP_LENGTH");
                DT_PARM_NAME(DT_DTL,"DTL");
                DT_PARM_NAME(DT_FORMAT_GAP_LENGTH,"FORMAT_GAP_LENGTH");
                DT_PARM_NAME(DT_FORMAT_FILL_BYTE,"FORMAT_FILL_BYTE");
                DT_PARM_NAME(DT_HEAD_SETTLE,"HEAD_SETTLE");
                DT_PARM_NAME(DT_MOTOR_START,"MOTOR_START");
                DT_PARM_NAME(DT_MAXIMUM_TRACK,"MAXIMUM_TRACK");
                DT_PARM_NAME(DT_DATA_TRANS_RATE,"DATA_TRANS_RATE");
                }

        note_trace5(FLOPBIOS_VERBOSE,
		"diskette_io:get_parm(%04x:%04x+%02x) %s=%02x)",
                 segment, offset, index, parm_name, value);
        }
#endif /* PROD */

	return(value);
}

LOCAL void motor_on IFN1(int, drive)
{
	/*
	 *	Turn motor on and wait for motor start up time
	 */
	double_word time_to_wait;

	/*
	 *	If motor was previously off - wait for the start-up time
	 */
	if (turn_on(drive) != FAILURE)
	{
		/*
		 *	Notify OS that BIOS is about to wait for motor
		 *	start up
		 */
#ifndef	JOKER
		word savedAX, savedCX, savedDX, savedCS, savedIP;

		translate_old(drive);

		savedAX = getAX();
		savedCS = getCS();
		savedIP = getIP();

		setAH(INT15_DEVICE_BUSY);
		setAL(INT15_DEVICE_FLOPPY_MOTOR);
#ifdef NTVDM
		setCS(int15_seg);
		setIP(int15_off);
#else
		setCS(RCPU_INT15_SEGMENT);
		setIP(RCPU_INT15_OFFSET);
#endif /* NTVDM */

		host_simulate();

		setAX(savedAX);
		setCS(savedCS);
		setIP(savedIP);

		translate_new(drive);

		/*
		 *	Quit if operating system handled wait and motor
		 *	is still on
		 */
		if (getCF() && turn_on(drive) == FAILURE)
			return;
		
#endif	/* JOKER */

		/*
		 *	Get time to wait in 1/8 second units - minimum
		 *	wait time 1 second
		 */
		if ((time_to_wait = get_parm(DT_MOTOR_START)) < WAIT_A_SECOND)
			time_to_wait = WAIT_A_SECOND;

		/*
		 *	Convert time to wait into microseconds
		 */

		time_to_wait *= 125000L;

		/* at this point the real BIOS sets CX,DX to time_to_wait;
		   we don't actually need to wait at all, so request
		   the minimum length wait */

#ifndef	JOKER

		/*
		 *	Ask OS to do wait
		 */
		savedAX = getAX();
		savedCX = getCX();
		savedDX = getDX();
		savedCS = getCS();
		savedIP = getIP();

		setAH(INT15_WAIT);
		setCX(0);
		setDX(1);
#ifdef NTVDM
		setCS(int15_seg);
		setIP(int15_off);
#else
		setCS(RCPU_INT15_SEGMENT);
		setIP(RCPU_INT15_OFFSET);
#endif /* NTVDM */

		host_simulate();

		setAX(savedAX);
		setCX(savedCX);
		setDX(savedDX);
		setCS(savedCS);
		setIP(savedIP);

		/*
		 *	Quit if wait succeeded
		 */
		if (!getCF())
			return;
		
#endif	/* JOKER */

		/*
		 *	Need to do fixed wait locally
		 */
		waitf(time_to_wait);
	}
}

LOCAL turn_on IFN1(int, drive)
{
#ifndef NEC_98
	/*
	 *	Turn motor on and return wait state
	 */
	half_word motor_status, drive_select_desired, motor_on_desired;
	half_word drive_select, status_desired, old_motor_on, new_motor_on;
	half_word diskette_dor_reg;

	/*
	 *	Disable interrupts
	 */
	setIF(0);

	/*
	 *	Make sure the motor stays on as long as possible
	 */
	sas_store(MOTOR_COUNT, MC_MAXIMUM);

	/*
	 *	Get existing and desired drive select and motor on
	 */
	sas_load(MOTOR_STATUS, &motor_status);
	drive_select = (half_word)(motor_status & MS_DRIVE_SELECT_MASK);
	drive_select_desired = (drive << 4);
	motor_on_desired = (1 << drive);

	if (    (drive_select != drive_select_desired)
	     || ((motor_on_desired & motor_status) == 0))
	{
		/*
		 *	Store desired motor status
		 */
		status_desired = motor_on_desired | drive_select_desired;
		old_motor_on = (half_word)(motor_status & MS_MOTOR_ON_MASK);
		motor_status &= ~MS_DRIVE_SELECT_MASK;
		motor_status |= status_desired;
		sas_store(MOTOR_STATUS, motor_status);

		/*
		 *	Switch on motor of selected drive via a write
		 *	to the floppy adapter's Digital Output Register
		 */
		new_motor_on = (half_word)(motor_status & MS_MOTOR_ON_MASK);
		setIF(1);
		diskette_dor_reg = motor_status << 4;
		diskette_dor_reg |= (motor_status & MS_DRIVE_SELECT_MASK) >> 4;
		diskette_dor_reg |= (DOR_INTERRUPTS | DOR_RESET);
		outb(DISKETTE_DOR_REG, diskette_dor_reg);

		/*
		 *	Flag success only if the motor was switched on,
		 *	and not just reselected
		 */
		if (new_motor_on != old_motor_on)
			return(SUCCESS);
	}

	/*
	 *	Enable interrupts
	 */
	setIF(1);
	return(FAILURE);
#endif // !NEC_98
}

LOCAL void hd_wait IFN1(int, drive)
{
	/*
	 *	Wait for head settle time
	 */
	half_word motor_status, disk_state;
	word time_to_wait;
#ifndef	JOKER
	word savedAX, savedCX, savedDX, savedCS, savedIP;
#endif

	/*
	 *	Get head settle time; for write operations, the minimum
	 *	head settle times may need to be enforced
	 */
	time_to_wait = get_parm(DT_HEAD_SETTLE);
	sas_load(MOTOR_STATUS, &motor_status);
	if ((motor_status & MS_WRITE_OP) != 0)
	{
		if (time_to_wait == 0)
		{
			/*
			 *	Use minimum wait times according to the
			 *	media type
			 */
			sas_load(FDD_STATUS+drive, &disk_state);
			if ((disk_state & RS_MASK) == RS_250)
				time_to_wait = HEAD_SETTLE_360;
			else
				time_to_wait = HEAD_SETTLE_12;
		}
	}
	else if (time_to_wait == 0)
		return;

	/*
	 *	Convert time to wait into microseconds
	 */

	time_to_wait *= 1000;

	/* at this point the real BIOS sets CX,DX to time_to_wait;
	   we don't actually need to wait at all, so request
	   a zero length wait */

#ifndef	JOKER

	/*
	 *	Ask OS to do wait
	 */
	savedAX = getAX();
	savedCX = getCX();
	savedDX = getDX();
	savedCS = getCS();
	savedIP = getIP();

	setAH(INT15_WAIT);
	setCX(0);
	setDX(1);

#ifdef NTVDM
	setCS(int15_seg);
	setIP(int15_off);
#else
	setCS(RCPU_INT15_SEGMENT);
	setIP(RCPU_INT15_OFFSET);
#endif /* NTVDM */

	host_simulate();

	setAX(savedAX);
	setCX(savedCX);
	setDX(savedDX);
	setCS(savedCS);
	setIP(savedIP);

	/*
	 *	Quit if wait succeeded
	 */
	if (!getCF())
		return;

#endif	/* JOKER */

	/*
	 *	Need to do fixed wait locally
	 */
	waitf(time_to_wait);
}

LOCAL void nec_output IFN1(half_word, byte_value)
{
#ifndef NEC_98
	/*
	 *	This routine sends a byte to the FDC after testing for
	 *	correct direction and controller ready. If the FDC does
	 *	not respond after a few tries, it is assumed that there
	 *	is a bug in our FDC emulation
	 */
	half_word diskette_status_reg;
	int count;

	/*
	 *	Wait for ready and correct direction
	 */
	count = 0;
	do
	{
		if (count++ >= FDC_TIME_OUT)
		{
			always_trace0("diskette_io: FDC error - input repletion");
			return;
		}
		inb(DISKETTE_STATUS_REG, &diskette_status_reg);
	} while ((diskette_status_reg & (DSR_RQM | DSR_DIO)) != DSR_RQM);

	/*
	 *	Output the byte
	 */
	outb(DISKETTE_DATA_REG, byte_value);

	/*
	 *	Do fixed wait for FDC update cycle time
	 */
	waitf(FDC_SETTLE);
#endif // !NEC_98
}

LOCAL seek IFN2(int, drive, int, track)
{
	/*
	 *	This routine will move the head on the named drive
	 *	to the named track. If the drive has not been accessed
	 *	since the drive reset command was issued, the drive
	 *	will be recalibrated
	 */
	half_word seek_status, disk_track, disk_state;
	FDC_CMD_BLOCK fdc_cmd_block[MAX_COMMAND_LEN];
	int status;

	note_trace2(FLOPBIOS_VERBOSE, "diskette_io:seek(drive=%d,track=%d)",
							drive, track);

	/*
	 *	Check if recalibration required before seek
	 */
	sas_load(SEEK_STATUS, &seek_status);
	if ((seek_status & (1 << drive)) == 0)
	{
		/*
		 *	Update the seek status and recalibrate
		 */
		sas_store(SEEK_STATUS, (IU8)(seek_status | (1 << drive)));
		if (recal(drive) != SUCCESS)
		{
			sas_store(FLOPPY_STATUS, FS_OK);
			if (recal(drive) == FAILURE)
				return(FAILURE);
		}

		/*
		 *	Drive will now be at track 0
		 */
		sas_store(FDD_TRACK+drive, 0);
		if (track == 0)
		{
			/*
			 *	No need to seek
			 */
			hd_wait(drive);
			return(SUCCESS);
		}
	}

	/*
	 *	Allow for double stepping
	 */
	sas_load(FDD_STATUS+drive, &disk_state);
	if ((disk_state & FS_DOUBLE_STEP) != 0)
		track *= 2;

	/*
	 *	Update current track number
	 */
	sas_load(FDD_TRACK+drive, &disk_track);
	if (disk_track == track)
	{
		/*
		 *	No need to seek
		 */
		return(SUCCESS);
	}
	sas_store(FDD_TRACK+drive, (IU8)track);

	/*
	 *	Do the seek and check the results
	 */
        put_c8_cmd(fdc_cmd_block, FDC_SEEK);
	put_c8_pad(fdc_cmd_block, 0);
	nec_output(fdc_cmd_block[0]);
	put_c8_drive(fdc_cmd_block, drive);
	put_c8_head(fdc_cmd_block, 0);
	put_c8_pad1(fdc_cmd_block, 0);
	nec_output(fdc_cmd_block[1]);
	put_c8_new_cyl(fdc_cmd_block, ((unsigned char)track));
	nec_output(fdc_cmd_block[2]);
	status = chk_stat_2();

	/*
	 *	Wait for head settle time
	 */
	hd_wait(drive);
	return(status);
}

LOCAL recal IFN1(int, drive)
{
	/*
	 *	Send recalibrate drive command to the FDC and check the
	 *	results
 	 */
	FDC_CMD_BLOCK fdc_cmd_block[MAX_COMMAND_LEN];

	note_trace1(FLOPBIOS_VERBOSE, "diskette_io:recal(drive=%d)", drive);

	put_c5_cmd(fdc_cmd_block, FDC_RECALIBRATE);
	put_c5_pad(fdc_cmd_block, 0);
	nec_output(fdc_cmd_block[0]);
	put_c5_drive(fdc_cmd_block, drive);
	put_c5_pad1(fdc_cmd_block, 0);
	nec_output(fdc_cmd_block[1]);
	return(chk_stat_2());
}

LOCAL chk_stat_2 IFN0()
{
	/*
	 *	This routine handles the interrupt received after
	 *	recalibrate, seek or reset to the adapter. The
	 *	interrupt is waited for, the interrupt status
	 *	sensed, and the result returned to the caller
	 */
	half_word diskette_status;

	/*
	 *	Check for interrupt
	 */
	if (wait_int() != FAILURE)
	{
		/*
		 *	Sense the interrupt and check the results
		 */
		nec_output(FDC_SENSE_INT_STATUS);
		if (results() != FAILURE)
		{

			if ((get_r3_ST0(fl_nec_status) & (ST0_SEEK_END | ST0_INTERRUPT_CODE_0))
				!= (ST0_SEEK_END | ST0_INTERRUPT_CODE_0))
			{
				return(SUCCESS);
			}
		
			/*
			 *	Abnormal termination of command
			 */
			sas_load(FLOPPY_STATUS, &diskette_status);
			diskette_status |= FS_SEEK_ERROR;
			sas_store(FLOPPY_STATUS, diskette_status);
		}
	}

	return(FAILURE);
}

LOCAL wait_int IFN0()
{
	/*
	 *	Check whether an interrupt occurred; if it did, return
	 *	SUCCESS; if there was a time out return FAILURE
	 */
	half_word seek_status, diskette_status;
#ifndef	JOKER
	word savedAX, savedCS, savedIP;

	/*
	 *	Enable interrupts
	 */

	setIF(1);	

	/*
	 *	Notify OS that BIOS is about to "wait" for a
	 *	diskette interrupt. Any pending diskette
	 *	interrupt will be serviced here, so there's
	 *	no need for a subsequent sub-cpu call to
	 *	wait for the interrupt
	 *
 	 *	[[WTR - is this true, we do do 2 host_simulates...? ]]
	 */
	savedAX = getAX();
	savedCS = getCS();
	savedIP = getIP();

	setAH(INT15_DEVICE_BUSY);
	setAL(INT15_DEVICE_FLOPPY);

#ifdef NTVDM
	setCS(int15_seg);
	setIP(int15_off);
#else
	setCS(RCPU_INT15_SEGMENT);
	setIP(RCPU_INT15_OFFSET);
#endif  /* NTVDM */

	host_simulate();

	setAX(savedAX);
	setCS(savedCS);
	setIP(savedIP);

	/*
	 *	Call sub-cpu to do the "wait" for interrupt, saving
	 *	registers that would otherwise be corrupted
	 */
#ifdef FLOPPIES_KEEP_TRYING
   try_again:
#endif
	savedCS = getCS();
	savedIP = getIP();

#ifdef NTVDM
	setCS(wait_int_seg);
	setIP(wait_int_off);
#else
	setCS(RCPU_WAIT_INT_SEGMENT);
	setIP(RCPU_WAIT_INT_OFFSET);
#endif /* NTVDM */

	host_simulate();

	setCS(savedCS);
	setIP(savedIP);


#else	/* JOKER */


	/* Since we can't have a recursive CPU call, we'd be
	** well stuffed but for the fact that the default diskette
	** interrupt on SoftPC is actually a BOP which calls the "C"
	** function diskette_int() in "floppy_io.c". So most, if not
	** all, of the action takes place on the host side anyway.
	**
	** FieldFloppyInterrupts() simply checks if an interrupt
	** was generated, and does what the diskette_int() does,
	** but without the recursive CPU call.
	*/

	FieldFloppyInterrupts();

#endif	/* JOKER */


	/*
	 *	Check for success, or time out
	 */
	sas_load(SEEK_STATUS, &seek_status);
	if ((seek_status & SS_INT_OCCURRED) == 0)
	{

#ifdef FLOPPIES_KEEP_TRYING
		extern IBOOL fdc_interrupt_pending;

		/* If the CPU is very slow, or interrupt emulation
		 * has changed for the worst, then the low-priority
		 * floppy interrupt may not get through in the execution
	 	 * of the instructions allotted. This code looks at a
		 * global variable maintained by fla.c, which says whether
		 * or not the ICA has an un-processed diskette interrupt
		 * pending.
		 */
		if (fdc_interrupt_pending) {
			always_trace0("fdc_interrupt_pending, so try again");
			goto try_again;
		}
#endif /* FLOPPIES_KEEP_TRYING */

		sas_load(FLOPPY_STATUS, &diskette_status);
		diskette_status |= FS_TIME_OUT;
		sas_store(FLOPPY_STATUS, diskette_status);
		return(FAILURE);
	}
	else
	{
		seek_status &= ~SS_INT_OCCURRED;
		sas_store(SEEK_STATUS, seek_status);
		return(SUCCESS);
	}
}

LOCAL results IFN0()
{
#ifndef NEC_98

	/*
	 *	This routine will read anything that the FDC controller
	 *	returns following an interrupt
	 */
	half_word diskette_status_reg, diskette_status;
	int count;
	UTINY	val;

	/*
	 *	Wait for ready and direction
	 */
	count = 0;
	do
	{
		if (count++ >= FDC_TIME_OUT)
		{
			/*
			 *	Expect to return here when there is a
			 *	time out (not an FDC error)
			 */
			sas_load(FLOPPY_STATUS, &diskette_status);
			diskette_status |= FS_TIME_OUT;
			sas_store(FLOPPY_STATUS, diskette_status);

			LOAD_RESULT_BLOCK;
			return(FAILURE);
		}
		inb(DISKETTE_STATUS_REG, &diskette_status_reg);
	} while ((diskette_status_reg & (DSR_RQM | DSR_DIO))
						!= (DSR_RQM | DSR_DIO));

	/*
	 *	Extract the results from the FDC
	 */
	count = 0;
	do
	{
		/*
		 *	Read a byte of result data
		 */
		inb(DISKETTE_DATA_REG, &val);
		sas_store( BIOS_FDC_STATUS_BLOCK + count, val );
		count++;

		/*
		 *	Do fixed wait for FDC update cycle time
		 */
		waitf(FDC_SETTLE);

		/*
		 *	Check for further result bytes
		 */
		inb(DISKETTE_STATUS_REG, &diskette_status_reg);
	} while ((diskette_status_reg & FDC_BUSY) && (count < MAX_RESULT_LEN));

	LOAD_RESULT_BLOCK;
	if ((diskette_status_reg & FDC_BUSY) && (count == MAX_RESULT_LEN))
	{
		/*
		 *	Problem with the FDC
		 */
		sas_load(FLOPPY_STATUS, &diskette_status);
		diskette_status |= FS_FDC_ERROR;
		sas_store(FLOPPY_STATUS, diskette_status);

		always_trace0("diskette_io: FDC error - output overdose");
		return(FAILURE);
	}

	return(SUCCESS);
#endif // !NEC_98
}

LOCAL read_dskchng IFN1(int, drive)
{
#ifndef NEC_98
	/*
	 *	Reads the state of the disk change line for "drive"
	 */
	half_word diskette_dir_reg;

	/*
	 *	Switch to the required drive
	 */
	motor_on(drive);

	/*
	 *	Read the diskette changed bit from the Digital Input
	 *	register
	 */
	inb(DISKETTE_DIR_REG, &diskette_dir_reg);
	return(((diskette_dir_reg & DIR_DISKETTE_CHANGE) != 0) ? FAILURE : SUCCESS);
#endif // !NEC_98
}

void drive_detect IFN1(int, drive)
{
	/*
	 *	Determines whether drive is 80 or 40 tracks
	 *	and updates state information accordingly
 	 */
	half_word disk_state;
	int track;

	/*
	 *	This method of determining the number of tracks on the
	 *	drive depends on seeking to a track that lies beyond the
	 *	last track of a 40 track drive, but is valid on an 80
	 *	track drive.
	 *
	 *	At this point the real track number on a 40 track drive
	 *	will be out of step with what the FDC thinks it is.
	 *
	 *	By seeking downwards to track 0, and observing when a
	 *	sense drive status reports that the drive is really at
	 *	track 0, a 40 and 80 track drive can be distinguished.
	 */
	note_trace1( GFI_VERBOSE, "drive_detect():start: DRIVE %x", drive );
	motor_on(drive);
	if (    (recal(drive) == SUCCESS)
             && (seek(drive, FDD_CLONK_TRACK) == SUCCESS))
	{
		track = FDD_JUDDER_TRACK + 1;
		do
		{
			if (--track < 0)
			{
				/*
				 *	40 track drive
				 */
				note_trace0( GFI_VERBOSE,
				             "drive_detect(): 40 TRACK" );
				sas_load(FDD_STATUS+drive, &disk_state);
				disk_state |= (DC_DETERMINED | FS_MEDIA_DET | RS_250);
				sas_store(FDD_STATUS+drive, disk_state);
				return;
			}

			if (seek(drive, track) != SUCCESS)
			{
				always_trace0( "drive_detect(): FAILURE" );
				return;
			}

			nec_output(FDC_SENSE_DRIVE_STATUS);
			nec_output((half_word)drive);
			(void )results();
		} while (get_r2_ST3_track_0(fl_nec_status) != 1);

		/*
		 *	Drive reports that it is at track 0; what does
		 *	the FDC think?
		 */
		if (track != 0)
		{
			note_trace0( GFI_VERBOSE, "drive_detect(): 40 TRACK" );
			/*
			 *	Must be a 40 track drive
			 */
			sas_load(FDD_STATUS+drive, &disk_state);
			disk_state |= (DC_DETERMINED | FS_MEDIA_DET | RS_250);
			sas_store(FDD_STATUS+drive, disk_state);
			return;
		}
		else
		{
			/*
			 *	Must be an 80 track drive
			 */
			note_trace0( GFI_VERBOSE, "drive_detect(): 80 TRACK" );
			sas_load(FDD_STATUS+drive, &disk_state);
			disk_state |= DC_80_TRACK;
			sas_store(FDD_STATUS+drive, disk_state);
			return;
		}
	}
}

LOCAL void waitf IFN1(long, time)
{
	UNUSED(time);
	/*
	 *	Fixed wait of "time" microseconds
	 */
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

void fl_diskette_setup IFN0()
{
	/*
	 *	Identify what types of drives are installed in the system
	 *	and initialise the diskette BIOS state variables to known
	 *	values. Do not change declaration of rtc_wait to rtc_wait_flag
	 *	as there is a macro (yes MACRO!!) of the same name declared in
	 *	rtc_bios.h.
	 */
	half_word rtc_wait, lastrate;
	int drive;

	/*
	 *	Disable RTC wait function
	 */
	sas_load(RTC_WAIT_FLAG_ADDR, &rtc_wait);
	rtc_wait |= 1;
	sas_store(RTC_WAIT_FLAG_ADDR, rtc_wait);

	/*
	 *	Initialise other variables in the diskette data
	 *	area
	 */
	sas_storew(FDD_STATUS, 0);
	sas_storew(FDD_STATUS+1, 0);	/* drive b as well */
	sas_load(RATE_STATUS, &lastrate);
	rate_unitialised = TRUE;
	lastrate &= ~(RS_MASK | (RS_MASK >> 4));
	lastrate |= RS_MASK;
	sas_store(RATE_STATUS, lastrate);
	sas_store(SEEK_STATUS, 0);
	sas_store(MOTOR_COUNT, 0);
	sas_store(MOTOR_STATUS, 0);
	sas_store(FLOPPY_STATUS, 0);

	/*
	 *	Try to determine the type of each drive
	 */
	for (drive = 0; drive < MAX_FLOPPY; drive++)
	{
		drive_detect(drive);

		
		translate_old(drive);
	}
	
	/*
	 *	Force an immediate recalibrate
	 */
	sas_store(SEEK_STATUS, 0);

	/*
	 *	Enable RTC wait function
	 */
	sas_load(RTC_WAIT_FLAG_ADDR, &rtc_wait);
	rtc_wait &= ~1;
	sas_store(RTC_WAIT_FLAG_ADDR, rtc_wait);

	/*
	 *	Return without setting sectors transferred
	 */
	setup_end(IGNORE_SECTORS_TRANSFERRED);
}
#if defined(NEC_98)

NTSTATUS FloppyOpenHandle IFN3( int, drive,
                           PIO_STATUS_BLOCK, io_status_block,
                           PHANDLE, fd)
{

    PUNICODE_STRING unicode_string;
    ANSI_STRING ansi_string;
    OBJECT_ATTRIBUTES   floppy_obj;
    int drv;            // logical drive number
    NTSTATUS status;

    /*
    **  get device name
    */
    for( drv=0; drv<MAX_FLOPPY; drv++)
    {
        if(DauaTable[drv].FloppyNum == (UINT)drive)
                break;
    }
    if( drv == MAX_FLOPPY )
    {
        status = STATUS_UNSUCCESSFUL;
        return status;
    }

    RtlInitAnsiString( &ansi_string, DauaTable[drv].DeviceName);

    unicode_string =  &NtCurrentTeb()->StaticUnicodeString;

    status = RtlAnsiStringToUnicodeString(unicode_string,
                                          &ansi_string,
                                          FALSE
                                          );
    if ( !NT_SUCCESS(status) )
        return status;

    InitializeObjectAttributes(
                               &floppy_obj,
                               unicode_string,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    // this call will fail if the current user is not
    // the administrator or the volume is locked by other process.
    status = NtOpenFile(
                        fd,
                        FILE_READ_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                        &floppy_obj,
                        io_status_block,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                        );

    return status;

}

void SetErrorCode IFN1( NTSTATUS, status )
{

        switch( status )
        {
                case STATUS_IO_TIMEOUT:
                case STATUS_TIMEOUT:
                                        setAH(FLS_TIME_OUT);
                                        break;
                case STATUS_UNRECOGNIZED_MEDIA:
                case STATUS_NONEXISTENT_SECTOR:
                case STATUS_END_OF_FILE:
                case STATUS_FLOPPY_ID_MARK_NOT_FOUND:
                case STATUS_FLOPPY_WRONG_CYLINDER:
                                        setAH(FLS_MISSING_ID);
                                        break;
                case STATUS_DEVICE_DATA_ERROR:
                case STATUS_CRC_ERROR:
                                        setAH(FLS_DATA_ERROR);
                                        break;
                case STATUS_DATA_OVERRUN:
                                        setAH(FLS_OVER_RUN);
                                        break;
                case STATUS_MEDIA_WRITE_PROTECTED:
                                        setAH(FLS_WRITE_PROTECTED);
                                        break;
                case STATUS_DEVICE_NOT_READY:
                case STATUS_NO_MEDIA_IN_DEVICE:
                                        setAH(FLS_NOT_READY);
                                        break;
                default:                setAH(FLS_ERROR);
                                        break;
        }
        SetDiskBiosCarryFlag(1);
}

NTSTATUS GetGeometry IFN3(  HANDLE, fd,
                        PIO_STATUS_BLOCK, io_status_block,
                        PDISK_GEOMETRY, disk_geometry)
{
        NTSTATUS status;

    // get geomerty information, the caller wants this
        status = NtDeviceIoControlFile(fd,
                                        0,
                                        NULL,
                                        NULL,
                                        io_status_block,
                                        IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        NULL,
                                        0,
                                        (PVOID)disk_geometry,
                                        sizeof (DISK_GEOMETRY)
                                        );
        return status;
}

ULONG CalcActualLength IFN4( ULONG, RestCylLen, ULONG, RestTrkLen, BOOL*, fOverData, int, LogDrv)
{
        ULONG ActOpLen;
        ULONG PhyBytesPerSec;

        /*
        **      get requested length
        */
        ActOpLen = (ULONG)getBX();
        PhyBytesPerSec = 128 << (ULONG)getCH();
//----- Chg-Start <93.12.27> Bug-Fix -----------------------------------
//      if( (getAH() & OP_SEEK) ? ((getDH() & 0x01) == 0) : (LastAccess[LogDrv].head == 0) )
//----------------------------------------------------------------------
        if( !( getDH() & 0x01 ) )
//----- Chg-End --------------------------------------------------------
        {
                if( getAH() & OP_MULTI_TRACK )
                {
                        if( ActOpLen > RestCylLen )
                        {
                                ActOpLen = RestCylLen;
                                *fOverData = TRUE;
                        }
                        else
                        {
                                ActOpLen = (ActOpLen / PhyBytesPerSec) * PhyBytesPerSec;
                                *fOverData = FALSE;
                        }
                }
                else
                {
                        if( ActOpLen > RestTrkLen )
                        {
                                ActOpLen = RestTrkLen;
                                *fOverData = TRUE;
                        }
                        else
                        {
                                ActOpLen = (ActOpLen / PhyBytesPerSec) * PhyBytesPerSec;
                                *fOverData = FALSE;
                        }
                }
        }
        else
        {
                if( ActOpLen > RestTrkLen )
                {
                        ActOpLen = RestTrkLen;
                        *fOverData = TRUE;
                }
                else
                {
                        ActOpLen = (ActOpLen / PhyBytesPerSec) * PhyBytesPerSec;
                        *fOverData = FALSE;
                }
        }

        return ActOpLen;

}

BOOL CheckDmaBoundary IFN3( UINT, segment, UINT, offset, UINT, length)
{

        ULONG EffectStart;
        ULONG EffectEnd;

        EffectStart = ((ULONG)segment << 4) + (ULONG)offset;
        if( length == 0 )
                EffectEnd = EffectStart + (64l * 1024l);
        else
                EffectEnd = EffectStart + length;

        /*
        **      Check Bank Boundary.
        **
        **      note:if length equal to 64KB ,then buffer is across surely
        **           bank boundary.
        */
        if( length != 0 )
        {
                if( (EffectStart & 0xffff0000l) != (EffectEnd & 0xffff0000l) )
                        return FALSE;
        }
        else
        {
                if( (EffectStart & 0x0000ffffl) != 0x00000000l )
                        return FALSE;
        }

        /*
        **      check segment wrap around
        **
        **      note: if length equal to 64kb, then buffer is surely
        **            to wrap around.
        */
        if( length != 0 )
        {
                if( ((ULONG)offset + (ULONG)length) > 0x10000l )
                        return FALSE;
        }

        return TRUE;

}

void fl_disk_recal IFN1( int, drive)
{
        /*
         *      recalibrate head in "drive"
         *
         *      Register inputs:
         *              AH      command code
         *              AL      DA/UA
         *      Register outputs:
         *              AH      diskette status
         *              CF      status flag
         */

        WORD savedBX,savedCX,savedDX,savedES,savedBP;
        BYTE AHstatus, SecLenN;
        int LogDrv;
        NTSTATUS status;
        IO_STATUS_BLOCK io_status_block;
        HANDLE fd;
        DISK_GEOMETRY disk_geometry;

        /*
        **      check drive number validation
        */
        if( drive > MAX_FLOPPY )
        {
                setAH(FLS_EQUIPMENT_CHECK);
                SetDiskBiosCarryFlag(1);
                return;
        }

        LogDrv = ConvToLogical( (UINT)getAL() );

        status = FloppyOpenHandle(drive,&io_status_block,&fd);

        if(!NT_SUCCESS(status))
        {
                SetErrorCode(status);
                AHstatus = getAH();
                if( (AHstatus != FLS_EQUIPMENT_CHECK) && (AHstatus != FLS_TIME_OUT) )
                {
                        /*
                        **      Assume that the head is moved to track 0.
                        */
                        LastAccess[LogDrv].cylinder =
                        LastAccess[LogDrv].head     = 0;
                        SetErrorCode((NTSTATUS)STATUS_SUCCESS);
                }
                return;
        }

        status = GetGeometry(fd,&io_status_block,&disk_geometry);

        if(!NT_SUCCESS(status))
        {
                NtClose(fd);
                SetErrorCode(status);
                AHstatus = getAH();
                if( (AHstatus != FLS_EQUIPMENT_CHECK) && (AHstatus != FLS_TIME_OUT) )
                {
                        /*
                        **      Assume that the head is moved to track 0.
                        */
                        LastAccess[LogDrv].cylinder =
                        LastAccess[LogDrv].head     = 0;
                        SetErrorCode((NTSTATUS)STATUS_SUCCESS);
                }
                return;
        }

        NtClose( fd );

        savedBX = getBX();
        savedCX = getCX();
        savedDX = getDX();
        savedES = getES();
        savedBP = getBP();

        setAX( (WORD)( ( (WORD)getAX() & 0x00ff ) | 0xd100 ) );
        setBX( (WORD)disk_geometry.BytesPerSector );
        setCL( 0 );
        setDH( 0 );
        setDL( 1 );

        for( SecLenN=0; disk_geometry.BytesPerSector > 128; SecLenN++)
                disk_geometry.BytesPerSector /= 2;

        setCH( SecLenN );
        setES( 0x0000 );
        setBP( 0x0000 );

        fl_disk_verify( drive );

        AHstatus = getAH();
        if( (getCF() == 1) && ( (AHstatus != FLS_EQUIPMENT_CHECK)&&
                                (AHstatus != FLS_TIME_OUT) ) )
        {
                setAH(FLS_NORMAL_END);
                SetDiskBiosCarryFlag(0);
        }

        /*
        **      Assume that the head is moved to track 0.
        */
        LastAccess[LogDrv].cylinder =
        LastAccess[LogDrv].head     = 0;

        setBX(savedBX);
        setCX(savedCX);
        setDX(savedDX);
        setES(savedES);
        setBP(savedBP);
}

void fl_disk_sense IFN1( int, drive)
{
        /*
         *      sense condition in "drive"
         *
         *      Register inputs:
         *              AH      command code & operation mode
         *              AL      DA/UA
         *      Register outputs:
         *              AH      diskette status
         *              CF      status flag
         */
        UCHAR status_st3 = 0;
        BOOL fFixedMode;
        BOOL f1Pt44Mode;
        BYTE ah_status;
        HANDLE fd;
        IO_STATUS_BLOCK io_status_block;
        NTSTATUS status;
        DISK_GEOMETRY DiskGeometry;
        PVOID temp_buffer;
        LARGE_INTEGER StartOffset;
        int LogDrv;

        /*
        **      check drive number validation
        */
        if( drive > MAX_FLOPPY )
        {
                setAH(FLS_EQUIPMENT_CHECK);
                SetDiskBiosCarryFlag(1);
                return;
        }

        /*
        **      convert from DA/UA to logical drive number (0 based)
        */
        LogDrv = ConvToLogical( getAL() );

        status = FloppyOpenHandle(drive,&io_status_block,&fd);

        if(!NT_SUCCESS(status))
        {
                SetErrorCode(status);
                return;
        }

        /*
        **      check whether drive is fixed mode, and 1.44MB media
        **      id available.
        */
        fFixedMode = CheckDriveMode( fd );
        f1Pt44Mode = Check144Mode( fd );

        /*
        **      get drive parameter for dummy reaad
        */
        status = GetGeometry(fd,&io_status_block,&DiskGeometry);

        if(!NT_SUCCESS(status))
        {
                NtClose(fd);
                ah_status = getAH();
                SetErrorCode(status);

                if( (ah_status & OP_SENSE2) == OP_SENSE2 )
                {
                        if( f1Pt44Mode )
                                setAH( (BYTE)(getAH() | FLS_AVAILABLE_1PT44MB) );
                        else
                                setAH( (BYTE)(getAH() & ~FLS_AVAILABLE_1PT44MB) );
                }
                else if ( (ah_status & OP_NEW_SENSE) == OP_NEW_SENSE )
                {
                        if ( !fFixedMode )
                                setAH( (BYTE)(getAH() | FLS_2MODE) );
                        else
                                setAH( (BYTE)(getAH() & ~FLS_2MODE) );
                }

                return;
        }

        /*
        **      get FDC status
        */
        GetFdcStatus( fd, &status_st3 );

        NtClose( fd );

        if( (getAH() & OP_SENSE2) == OP_SENSE2 )
        {
                /*
                **      operate SENSE2(ah=c4h) command
                */

                SetSenseStatusHi( status_st3, &ah_status);

                if( f1Pt44Mode )
                        ah_status |= FLS_AVAILABLE_1PT44MB;
                else
                        ah_status &= ~FLS_AVAILABLE_1PT44MB;
        }
        else if( getAH() & OP_NEW_SENSE )
        {
                /*
                **      operate NewSENSE(ah=84h) command
                */

                SetSenseStatusHi( status_st3, &ah_status);

                if( fFixedMode )
                    ah_status &= ~(FLS_2MODE | FLS_HIGH_DENSITY | FLS_DETECTION_AI);
                else
                {
                    ah_status |= FLS_2MODE;
                    if( Check1MbInterface( drive ) )
                        ah_status &= ~(FLS_HIGH_DENSITY | FLS_DETECTION_AI);
                    else
                    {
                        ah_status &= FLS_DETECTION_AI;
                        ah_status |= FLS_HIGH_DENSITY;
                    }
                }
        }
        else
                /*
                **      operate SENSE(ah=04h) command
                */
                SetSenseStatusHi( status_st3, &ah_status);

        setAH(ah_status);
        if( ah_status >= FLS_DMA_BOUNDARY )
                SetDiskBiosCarryFlag(1);
        else
                SetDiskBiosCarryFlag(0);
        return;
}

void fl_disk_read_id IFN1( int, drive)
{
        /*
         *      read id information in "drive"
         *
         *      Register inputs:
         *              AH      command code & operation mode
         *              AL      DA/UA
         *              CL      cylinder number
         *              DH      head number
         *      Register outputs:
         *              AH      diskette status
         *              CF      status flag
         */
        HANDLE  fd;
        DISK_GEOMETRY   disk_geometry;
        NTSTATUS    status;
        IO_STATUS_BLOCK io_status_block;
        int LogDrv;
        word savedAX;
        UCHAR SecLenN = 0;
        LARGE_INTEGER SpcfydCylNo;

        /*
        **      check drive number validation
        */
        if( drive > MAX_FLOPPY )
        {
                setAH(FLS_EQUIPMENT_CHECK);
                SetDiskBiosCarryFlag(1);
                return;
        }

        status = FloppyOpenHandle(drive,&io_status_block,&fd);

        if(!NT_SUCCESS(status))
        {
                SetErrorCode(status);
                return;
        }

        status = GetGeometry(fd,&io_status_block,&disk_geometry);

        if(!NT_SUCCESS(status))
        {
                NtClose(fd);
                SetErrorCode(status);
                return;
        }

        NtClose( fd );

//----- Chg-Start <93.12.29> Bug-Fix ---------------------------------
//      /*
//      **      recalibrate
//      */
//      savedAX = getAX();
//      setAH(FLP_RECALIBRATE);
//      fl_disk_recal( drive );
//      setAX( savedAX );
//
//      LogDrv = ConvToLogical( getAL() );
//      LastAccess[LogDrv].cylinder = 0;
//      LastAccess[LogDrv].head = 0;
//
//      /*
//      **      check cylinder number validation
//      */
//      SpcfydCylNo = RtlConvertUlongToLargeInteger( (ULONG)getCL() );
//      if( RtlLargeIntegerGreaterThanOrEqualTo( SpcfydCylNo, disk_geometry.Cylinders ) )
//      {
//              SetErrorCode( (NTSTATUS)STATUS_NONEXISTENT_SECTOR );
//              return;
//      }
//--------------------------------------------------------------------

        LogDrv = ConvToLogical( getAL() );

        if( getAH() & OP_SEEK )
        {
                /*
                **      check cylinder number validation
                */
                SpcfydCylNo = RtlConvertUlongToLargeInteger( (ULONG)getCL() );
                if( RtlLargeIntegerGreaterThanOrEqualTo( SpcfydCylNo, disk_geometry.Cylinders ) )
                {
                        SetErrorCode( (NTSTATUS)STATUS_NONEXISTENT_SECTOR );
                        return;
                }
        }

        if( getAH() & OP_SEEK )
        {
                LastAccess[LogDrv].cylinder = getCL();
                LastAccess[LogDrv].head = getDH() & 0x01;
        }

        setCL( LastAccess[LogDrv].cylinder );
        setDH( LastAccess[LogDrv].head );
//----- Chg-End ------------------------------------------------------

        /*
        **      calculate sector length N
        */
        for( SecLenN=0; disk_geometry.BytesPerSector > 128; SecLenN++)
                disk_geometry.BytesPerSector /= 2;

        setCH( SecLenN );
        setDL( (BYTE)disk_geometry.SectorsPerTrack );
        setAH( FLS_NORMAL_END );
        SetDiskBiosCarryFlag(0);

}

void SetSenseStatusHi IFN2( UCHAR, st3, PBYTE, ah_status)
{

        if( st3 & ST3_WRITE_PROTECT )
                *ah_status = FLS_WRITE_PROTECTED;
        else if( st3 & ST3_READY )
                *ah_status = FLS_READY;

        if( st3 & ST3_DOUBLE_SIDE )
                *ah_status |= FLS_DOUBLE_SIDE;

}

BOOL CheckDriveMode IFN1( HANDLE, fd )
{

        BOOL fFixedMode;
        BOOL f2HD = FALSE;
        BOOL f2DD = FALSE;
        DISK_GEOMETRY   disk_geometry[20];
        ULONG   media_types;
        NTSTATUS    status;
        IO_STATUS_BLOCK io_status_block;

        status = NtDeviceIoControlFile(fd,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &io_status_block,
                                       IOCTL_DISK_GET_MEDIA_TYPES,
                                       NULL,
                                       0L,
                                       (PVOID)&disk_geometry,
                                       sizeof(disk_geometry)
                                       );

        if (!NT_SUCCESS(status))
        {
            fFixedMode = TRUE;
            return fFixedMode;
        }

        media_types = io_status_block.Information / sizeof(DISK_GEOMETRY);

        for (; media_types != 0; media_types--)
        {
                switch (disk_geometry[media_types - 1].MediaType)
                {
                        case F3_1Pt2_512:                                // NEC 970620
                        case F5_1Pt2_512:
                        case F3_1Pt44_512:
#if 1                                                                    // NEC 941110
                        case F3_1Pt23_1024:                              // NEC 970620
                        case F5_1Pt23_1024:                              // NEC 941110
#else                                                                    // NEC 941110
                        case F5_1Pt2_1024:
#endif                                                                   // NEC 941110
                                f2HD = TRUE;
                                break;
                        case F3_720_512:
                        case F5_720_512:                                 // NEC 970620
                        case F3_640_512:
                        case F5_640_512:                                 // NEC 970620
                                f2DD = TRUE;
                        default:
                                break;
                }
        }

        if( (f2HD == TRUE) && (f2DD == TRUE) )
                fFixedMode = FALSE;
        else
                fFixedMode = TRUE;

        return fFixedMode;
}

BOOL Check144Mode IFN1( HANDLE, fd )
{

        BOOL f144Mode;
        DISK_GEOMETRY   disk_geometry[20];
        ULONG   media_types;
        NTSTATUS    status;
        IO_STATUS_BLOCK io_status_block;

        status = NtDeviceIoControlFile(fd,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &io_status_block,
                                       IOCTL_DISK_GET_MEDIA_TYPES,
                                       NULL,
                                       0L,
                                       (PVOID)&disk_geometry,
                                       sizeof(disk_geometry)
                                       );

        if (!NT_SUCCESS(status))
        {
            f144Mode = FALSE;
            return f144Mode;
        }

        media_types = io_status_block.Information / sizeof(DISK_GEOMETRY);

        f144Mode = FALSE;

        for (; media_types != 0; media_types--)
        {
                switch (disk_geometry[media_types - 1].MediaType)
                {
                        case F3_1Pt44_512:
                                f144Mode = TRUE;
                        default:
                                break;
                }
        }

        return f144Mode;

}

BOOL Check1MbInterface IFN1( int, drive )
{

        half_word disk_equip2;
        UINT daua;
        int LogDrv;

        /*
        **      get system common area
        */
        sas_load( BIOS_NEC98_DISK_EQUIP2, &disk_equip2);

        daua = getAL();
        LogDrv = ConvToLogical( daua );

        if( disk_equip2 & ( 1 << (DauaTable[LogDrv].FloppyNum+4) ) )
                return FALSE;
        else
                return TRUE;

}

MEDIA_TYPE GetFormatMedia IFN2( BYTE, daua, WORD, PhyBytesPerSec )
{

        MEDIA_TYPE media_type;
        BYTE da;

        da = daua & 0xf0;
        switch( PhyBytesPerSec )
        {
#if 1                                                           // NEC 941110
                case 1024:      media_type = F5_1Pt23_1024;     // NEC 941110
#else                                                           // NEC 941110
                case 1024:      media_type = F5_1Pt2_1024;
#endif                                                          // NEC 941110
                                break;
                case 512:       if( da == 0x30 )
                                        media_type = F3_1Pt44_512;
                                else if( da == 0x90 )
                                        media_type = F5_1Pt2_512;
                                else
                                        media_type = F3_720_512;
                                break;
                case 256:
                case 128:

                default:        media_type = Unknown;
                                break;
        }

        return media_type;
}

void    GetFdcStatus IFN2( HANDLE, fd, UCHAR, *st3 )
{
        IO_STATUS_BLOCK io_status_block;

        /*
        **      get FDC status
        */
        NtDeviceIoControlFile(  fd,
                                0,
                                NULL,
                                NULL,
                                &io_status_block,
                                IOCTL_DISK_SENSE_DEVICE,
                                NULL,
                                0,
                                (PVOID)st3,
                                sizeof (UCHAR)
                                );
}

#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\disks\fdisk.c ===
#include "insignia.h"
#include "host_def.h"

/*
 * INSIGNIA (SUB)MODULE SPECIFICATION -----------------------------
 *
 *
 * THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE CUSTOMER, THE
 * CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST NOT BE DISCLOSED TO ANY
 * OTHER PARTIES  WITHOUT THE EXPRESS AUTHORISATION FROM THE DIRECTORS OF
 * INSIGNIA SOLUTIONS LTD.
 *
 *
 * DOCUMENT 		:
 *
 * RELATED DOCS		: WD2010-05 datasheet WD11C00C-22 (RMAC) eng.spec
 * (Intel 82062 ... very similar to WD2010) IBM PC XT286 tech.ref
 *
 * DESIGNER		: Jerry Kramskoy
 *
 * REVISION HISTORY	: First version		: 14-Sep-88.
 *
 * SUBMODULE NAME		: fdisk
 *
 * SOURCE FILE NAME	: fdisk.c
 *
 * PURPOSE			: emulate fixed disk controller and sector buffer
 * manager components of AT dual card.
 *
 * SccsID = @(#)fdisk.c	1.35 08/31/93 Copyright Insignia Solutions Ltd.
 *
 *
 * [1.INTERMODULE INTERFACE SPECIFICATION]
 *
 * [1.0 INCLUDE FILE NEEDED TO ACCESS THIS INTERFACE FROM OTHER SUBMODULES]
 *
 * INCLUDE FILE : fdisk.gi
 *
 * [1.1    INTERMODULE EXPORTS]
 *
 * PROCEDURES() :	fdisk_inb((io_addr)port, (unsigned char *)value)
 * (uchar)fdisk_read_dir((io_addr)port, (unsigned char *)value) (void)
 * fdisk_outb((io_addr)port, (unsigned char )value)
 * fdisk_inw((io_addr)port, (unsigned short *)value) (void)
 * fdisk_outw((io_addr)port,(unsigned short)value) (void)
 * (void) fdisk_reset() (int)  fdisk_physattach((int)driveno, (char
 * *)name) (void) fdisk_physdetach((int)driveno) (void) fdisk_ioattach()
 * (void) fdisk_iodetach()
 *
 * DATA 	     :	none
 *
 * -------------------------------------------------------------------------
 * [1.2 DATATYPES FOR [1.1] (if not basic C types)]
 *
 * STRUCTURES/TYPEDEFS/ENUMS:
 *
 * -------------------------------------------------------------------------
 * [1.3 INTERMODULE IMPORTS] (not o/s objects or standard libs)
 *
 * PROCEDURES() : 	none
 *
 * DATA 	     : 	none
 *
 * -------------------------------------------------------------------------
 *
 * [1.4 DESCRIPTION OF INTERMODULE INTERFACE]
 *
 * [1.4.1 IMPORTED OBJECTS]
 *
 * FILES ACCESSED    :	disk image file(s) for C: (and D:)
 *
 * DEVICES ACCESSED  :	none
 *
 * SIGNALS CAUGHT	  :	none
 *
 * SIGNALS ISSUED	  :	none
 *
 *
 * [1.4.2 EXPORTED OBJECTS]
 * =========================================================================
 * PROCEDURE	  : 	fdisk_inb((io_addr)port, (unsigned char *)value)
 * fdisk_outb((io_addr)port, (unsigned char)value)
 *
 * PURPOSE		  : 	i/o space read (write) of a taskfile register these
 * should be byte accesses.
 *
 * fdisk_inw((io_addr)port, (unsigned short *)value) fdisk_outw((io_addr)port,
 * (unsigned short)value)
 *
 * PURPOSE		  : 	i/o space read (write) of next index into sector
 * buffer. (for port 1f0). Not normal usage for accessing taskfile.
 *
 *
 * PARAMETERS
 *
 * port	  : 	the i/o address to read. Taskfile addresses are (hex): (1f0)
 * -	data register (see fdisk_inw) 1f1	-	error register 1f2
 * -	sector count register 1f3	-	sector number register 1f4
 * -	cylinder low register 1f5	-	cylinder high register 1f6
 * -	drive/head register 1f7	-	status register
 *
 * value	  :	(pointer to) byte (short) to receive the value contained in
 * the specified register.
 *
 * GLOBALS		  :	none.
 *
 * RETURNED VALUE	  : 	copy of returned value (inb, inw)
 *
 * DESCRIPTION	  : 	this procedure returns the contents of the specified
 * register, having called any active state machine (which may update the
 * status). Each disk command has a corresponding state machine, which gets
 * initialised when the command is issued, and subsequently called as the
 * command progresses. Only those commands involving data transfer between
 * the host (cpu) and the adaptor can cause multiple calls to the state
 * machine
 *
 * ERROR INDICATIONS :	none
 *
 * ERROR RECOVERY	  :	none
 * =========================================================================
 * PROCEDURE	  : 	(unsigned char) fdisk_read_dir((io_addr)port,
 * (unsigned char *)value)
 *
 * PURPOSE		  : 	return the value of the 7 bits in the fixed disk
 * register pertinent to the fixed disk. (cooperates with floppy)
 *
 * PARAMETERS	  :	as per fdisk_inb()
 *
 * GLOBALS		  :	the taskfile
 *
 * RETURNED VALUE	  : 	value of digital input register (at port 0x3f7)
 *
 * DESCRIPTION	  : 	obvious
 *
 * ERROR INDICATIONS :	none
 *
 * ERROR RECOVERY	  :	none
 *
 * =========================================================================
 * PROCEDURE	  : 	fdisk_ioattach() fdisk_iodetach()
 *
 * PURPOSE		  : 	attach/detach the fixed disk components to the
 * io-subsytem. plug/unplug the configured drives to the disk controller (if
 * any). Patches drive parameter block table entries 0 and 1 in system ROM.
 *
 * PARAMETERS	  :	none
 *
 * GLOBALS		  :	the drive structure [fd, wiredup members]
 *
 * RETURNED VALUE	  : 	none
 *
 * DESCRIPTION	  : 	attaches/detaches to ios as usual. For the drive(s),
 * the drive structure is used to see whether the disk image(s) are opened or
 * non-existent. Based on existence, drive structure indicates plugged
 * in/unplugged. On attach, disk parameter block table entries 1 and 2 (entry
 * 1 for drive type 1 is used for the C drive (drive 0), and entry 2 for
 * drive type 2 is used for the D drive (drive 1)) are edited to reflect the
 * #.of cylinders available.
 *
 * ERROR INDICATIONS :	none
 *
 * ERROR RECOVERY	  :	none
 * =========================================================================
 * PROCEDURE	  : 	fdisk_physattach(driveno, name)
 * fdisk_physdetach(driveno)
 *
 * PURPOSE		  : 	validate and attach host resource(s) for drive(s)
 * /detach host resource(s).
 *
 * PARAMETERS	  : driveno		-	0 (drive 0 (C:)) or	1
 * (drive 1 (D:)) name		-	pointer to string for hard disk file
 * name. If null string, then the indicated drive is taken to not exist.
 *
 * GLOBALS		  :	the drive structure [fd, maxcyl members]
 *
 * RETURNED VALUE	  : 	none
 *
 * DESCRIPTION	  : 	for attaching, use host validation procedure to
 * validate and open the specified drive image (if not the null string, else
 * mark as no drive available). Use the #.of cylinders returned by the
 * validation to set the max.cylinder number (= #.cyls - 1) into the drive
 * structure for the drive.
 *
 * ERROR INDICATIONS :	none
 *
 * ERROR RECOVERY	  :	none
 *
 * =========================================================================
 * PROCEDURE	  : 	fdisk_reset()
 *
 * PURPOSE		  : 	power up the disk subsystem.
 *
 * PARAMETERS	  :	none
 *
 * GLOBALS		  :	the taskfile
 *
 * RETURNED VALUE	  : 	none
 *
 * DESCRIPTION	  : 	sets registers etc. to their powered-up, pre-POST
 * values.
 *
 * ERROR INDICATIONS :	none
 *
 * ERROR RECOVERY	  :	none
 *
 *
 * =========================================================================
 * [3.INTERMODULE INTERFACE DECLARATIONS]
 * =========================================================================
 *
 * [3.1 INTERMODULE IMPORTS]
 */
IMPORT	int	soft_reset;

/* [3.1.1 #INCLUDES]                                                    */

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_HDA.seg"
#endif

#include <stdio.h>
#include TypesH
#include StringH
#include "xt.h"
#include "trace.h"
#include CpuH
#include "error.h"
#include "config.h"
#include "ios.h"
#include "ica.h"
#include "dsktrace.h"
#include "debug.h"
#include "sas.h"
#include "quick_ev.h"

/* [3.1.2 DECLARATIONS]                                                 */

/* [3.2 INTERMODULE EXPORTS]						 */
#include "fdisk.h"


/*
 * 5.MODULE INTERNALS   :   (not visible externally, global internally)]
 *
 * [5.1 LOCAL DECLARATIONS]
 */

/* [5.1.1 #DEFINES]							 */

/*
 * task file ports (9 registers accessed via 7 ports)
 */
#define TFBASE		0x1f0

#define	TFERROR		0x1f1
#define	TFPCMP		0x1f1
#define	TFSCOUNT	0x1f2
#define	TFSNUM		0x1f3
#define	TFCYLLO		0x1f4
#define	TFCYLHI		0x1f5
#define	TFDRVHD		0x1f6
#define	TFSTATUS	0x1f7
#define	TFCMD		0x1f7

/*
 * task file indices ... the 7 ports map out to 9 registers (by using the
 * read/write io signal) arbitrarily set the write precomp register and the
 * command registers at indices 8 and 9
 */
#define	WDERROR		1
#define	WDSCOUNT	2
#define	WDSNUM		3
#define	WDCYLLO		4
#define	WDCYLHI		5
#define	WDDRVHD		6
#define	WDSTAT		7
#define	WDPCMP		8
#define	WDCMD		9

/*
 * wd2010 command register bits.
 */
#define WDCMD_I 0x08
#define WDCMD_M 0x04
#define WDCMD_L 0x02
#define WDCMD_T 0x01

/*
 * command decoding constants, where bits 7-4 of command are non-unique
 */
#define	DIAG_OR_PARMS	9
#define	DIAG		0
#define	PARMS		1

/*
 * wd2010 status register bits
 */
#define	WDSTATBUSY		0x80
#define	WDSTATDRDY		0x40
#define	WDSTATWFAULT		0x20
#define	WDSTATSEEKCOMPLETE	0x10
#define	WDSTATDRQ		0x08
#define	WDSTATDC		0x04
#define	WDSTATCIP		0x02
#define	WDSTATERROR		0x01

/*
 * wd2010 error register bits (bits 0,1,6,7 never get set for this emulation
 * ... since these reflect bad ECC etc.)
 */
#define	WDERRNOID		0x10
#define	WDERRABORT		0x04

/*
 * io signal
 */
#define	IOREAD		0
#define	IOWRITE		~IOREAD

/*
 * interrupt line value
 */
#define	IRQDEASSERT	0
#define	IRQCLEAR	1
#define 	IRQASSERT	~IRQDEASSERT

/*
 * state control for disk commands
 */
#define	START		1	/* new command		 */
#define	CONTINUE	2	/* command in progress	 */
#define	BRDY		3	/* sector buffer ready 	 */
#define	BCR		4	/* clear sector buffer counter */

#define	IDMISMATCH	~0	/* bad seek		 */

/* [5.1.2 TYPEDEF, STRUCTURE, ENUM DECLARATIONS]			 */

/*
 * following describes the disk geometry for a drive, and the file descriptor
 * for the disk image.
 */
typedef struct _drvinfo
{
	long            driveid;
	long            physattached;
	long            maxhead;
	long            maxcyl;
	long            maxsect;
	long            nsecspertrack;
	long            nbytespercyl;
	long            nbytespertrack;
	long            wiredup;
	long            curoffset;
}               drvinfo_;


/* [5.1.3 PROCEDURE() DECLARATIONS]					 */

#ifdef ANSI
static void     restore(int);
static void     seek(int);
static void     rsector(int);
static void     wsector(int);
static void     format(int);
static void     rverify(int);
static void     diagnose(int);
static void     setparams(int);
static void     bad(int);
static void     irq(int);
static void     rmac(unsigned short *, int);
static long     dosearchid(void);
static void     doseek(void);
static int      disktobuffer(long);
static int      buffertodisk(long);
#else
static void     restore();
static void     seek();
static void     rsector();
static void     wsector();
static void     format();
static void     rverify();
static void     diagnose();
static void     setparams();
static void     bad();
static void     irq();
static void     rmac();
static long     dosearchid();
static void     doseek();
static int      disktobuffer();
static int      buffertodisk();
#endif				/* ANSI */

/*
 * -----------------------------------------------------------------------
 * [5.2 LOCAL DEFINITIONS]
 *
 * [5.2.1 INTERNAL DATA DEFINITIONS
 */

/*
 * dual card can support 2 drives max.
 */
static drvinfo_ drives[2];

/*
 * pointer to the currently selected drive. (gets set up whenever the
 * drive/head register in the taskfile gets written to)
 */
static drvinfo_ *pseldrv;

/*
 * the fixed disk register (write only, 0x3f6)
 */
static unsigned char fixeddiskreg;

/*
 * the digital input register .. reflects state of head and drive selected
 */
static unsigned char digipreg;

/*
 * the wd2010 taskfile (element [0] is pad byte) ... 9 registers + dummy to
 * allow direct table indexing
 */
LOCAL unsigned char taskfile[10];

/*
 * command dispatch ... based on bits 7-4 of command register as index.
 */
LOCAL void     (*dispatch[]) IPT1(int, state) =
{
	bad,
	restore,
	rsector,
	wsector,
	rverify,
	format,
	bad,
	seek,
	bad,
	bad,			/* further decoded	 */
	bad,
	bad,
	bad,
	bad,
	bad,
	bad,
};

/*
 * if a command is in progress, this points to the state machine for that
 * command
 */
LOCAL void     (*activecmd) IPT1(int, state);

/*
 * sector buffer variables
 */
static unsigned char sectindx;
static unsigned short sectbuffer[256];

/* [5.2.2 INTERNAL PROCEDURE DEFINITIONS]				 */

/*
 * ==========================================================================
 * FUNCTION	:	dosearchid() PURPOSE		:	simulate
 * searching for <cyl,hd,sec> id field. If out of range for configured
 * geometry, return failure, else return appropriate file offset into disk
 * image. N.B This assumes that ALL TRACKS have been FORMATTED WITH SECTOR
 * ID's 1-#.sectors per track). EXTERNAL OBJECTS:	drive info for
 * selected drive; taskfile. RETURN VALUE	:	-1 if bad parameters
 * for command else file offset (from byte 0) into hard disk image. INPUT
 * PARAMS	: RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL long
dosearchid IFN0()
{
	long            head;
	long            cylinder;
	long            sector;

	/*
	 * head ok? (heads numbered from 0 - maxhead)
	 */
	head = taskfile[WDDRVHD] & 0xf;

	if (head > 7 && !(fixeddiskreg & 0x8))
		return IDMISMATCH;

	if (head > pseldrv->maxhead)
		return IDMISMATCH;

	/*
	 * sector ok? (assumes all tracks have been formatted with sector ids
	 * 1 - nsecspertrack which is DOS standard)
	 */
	sector = taskfile[WDSNUM];

	if (sector > pseldrv->nsecspertrack || sector <= 0)
		return IDMISMATCH;

	/*
	 * cylinder ok? (we've imposed an artificial limit on the maximum
	 * cylinder number based upon the file size)
	 */
	cylinder = ((unsigned long) taskfile[WDCYLHI] << 8) +
		(unsigned long) taskfile[WDCYLLO];
	if (cylinder > pseldrv->maxcyl)
		return IDMISMATCH;

	return (cylinder * pseldrv->nbytespercyl + head *
		pseldrv->nbytespertrack + (sector - 1L) * 512L);
}

/*
 * ==========================================================================
 * FUNCTION	:	updateposregs() PURPOSE		:	update the
 * sector count and number registers. if this produces a track or cylinder
 * transfer, then update the head/cylinder registers. This is a guestimate of
 * what the WD1015 micro is doing when it handles these situations, and
 * programs the WD2010. EXTERNAL OBJECTS: RETURN VALUE	: INPUT  PARAMS	:
 * RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
updateposregs IFN0()
{
	(taskfile[WDSCOUNT])--;
	if (++taskfile[WDSNUM] > pseldrv->nsecspertrack)
	{
		int             head;
		int             cylinder;

		/*
		 * start at sector 1 of next track
		 */
		taskfile[WDSNUM] = 1;
		head = taskfile[WDDRVHD] & 0xf;
		if (++head > pseldrv->maxhead)
		{

			/*
			 * need to select next cylinder and use head 0.
			 */
			taskfile[WDDRVHD] &= 0xf0;

			cylinder = ((unsigned int) taskfile[WDCYLHI] << 8) + taskfile[WDCYLLO];
			taskfile[WDCYLLO] = (++cylinder) & 0xff;
			taskfile[WDCYLHI] = cylinder >> 8;
		} else
		{

			/*
			 * select next head to read next track
			 */
			taskfile[WDDRVHD] &= 0xf0;
			taskfile[WDDRVHD] |= head;
			if (head > 7)
				fixeddiskreg |= 8;
		}
	}
}

/*
 * ==========================================================================
 * FUNCTION	:	doseek() PURPOSE		:	'seek' to
 * requested cylinder. if requested drive not wired up, then drive will not
 * be ready. (and seek will be incomplete). If cylinder exceeds max. get
 * drive ready and seek complete, but will get 'id not found' when the track
 * gets accessed. EXTERNAL OBJECTS: RETURN VALUE	: INPUT  PARAMS	:
 * RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
doseek IFN0()
{

	/*
	 * the drive ready status will be set up when the drive/head register
	 * gets written to. here, just set the seek complete bit in the
	 * status register appropriately
	 */
	if (taskfile[WDSTAT] & WDSTATDRDY)
	{
		dt0(DHW | HWXINFO, 0, "\t\t+SC\n")
		taskfile[WDSTAT] |= WDSTATSEEKCOMPLETE;
	} else
	{
		dt0(DHW | HWXINFO, 0, "\t\t-SC\n")
			taskfile[WDSTAT] &= ~WDSTATSEEKCOMPLETE;
	}
}

/*
 * ==========================================================================
 * FUNCTION	:	restore() PURPOSE		: EXTERNAL OBJECTS:
 * RETURN VALUE	: INPUT  PARAMS	:	state	-	START or CONTINUE
 * RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
restore IFN1(int, state)
{
	UNUSED(state);
	dt0(DHW | HWXINFO, 0, "\tRESTORE cmd\n")
		doseek();
	if (!(taskfile[WDSTAT] & WDSTATDRDY))
	{
		taskfile[WDSTAT] |= WDSTATERROR;
		taskfile[WDERROR] = WDERRABORT;
		dt0(DHW | HWXINFO, 0, "\t\t+ERROR,err=abort\n")
	}
	dt0(DHW | HWXINFO, 0, "\t\t-BUSY -CIP\n")
		taskfile[WDSTAT] &= ~WDSTATBUSY;
	taskfile[WDSTAT] &= ~WDSTATCIP;
	rmac((unsigned short *) 0, BCR);
	irq(IRQASSERT);
}

/*
 * ==========================================================================
 * FUNCTION	:	seek() PURPOSE		:	emulate seek command.
 * Just sets up appropriate status changes (error condition possibly)
 * EXTERNAL OBJECTS: RETURN VALUE	: INPUT  PARAMS	:	state	-
 * START or CONTINUE RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
seek IFN1(int, state)
{
	UNUSED(state);
	dt0(DHW | HWXINFO, 0, "\tSEEK cmd\n")

		doseek();

	/*
	 * if drive not ready, error
	 */
	if (!(taskfile[WDSTAT] & WDSTATDRDY))
	{
		dt0(DHW | HWXINFO, 0, "\t\t+ERROR,err=abort\n")
			taskfile[WDSTAT] |= WDSTATERROR;
		taskfile[WDERROR] = WDERRABORT;
	}
	/*
	 * deassert 'busy' and 'command in progress'; reset the sector buffer
	 * counter; issue interrupt
	 */
	dt0(DHW | HWXINFO, 0, "\t\t-BUSY -CIP\n")
		taskfile[WDSTAT] &= ~WDSTATBUSY;
	taskfile[WDSTAT] &= ~WDSTATCIP;
	rmac((unsigned short *) 0, BCR);
	irq(IRQASSERT);
}

/*
 * ==========================================================================
 * FUNCTION	:	rsector() PURPOSE		:	emulate read
 * command. EXTERNAL OBJECTS: RETURN VALUE	: INPUT  PARAMS	:	state
 * -	START or CONTINUE or BRDY RETURN PARAMS   :
 * ==========================================================================
 */

LOCAL void
fdisk_pause IFN1(long, junk)
{
	UNUSED(junk);
	(*activecmd) (CONTINUE);
}

LOCAL void
rsector IFN1(int, state)
{
	static int      s;
	long            offset;

	if (state == START)
	{
		dt0(DHW | HWXINFO, 0, "\tREAD cmd\n")
			s = 0;
	}
	while (1)
		switch (s)
		{
		case 0:
			doseek();
			if (!(taskfile[WDSTAT] & WDSTATDRDY))
			{
				dt0(DHW | HWXINFO, 0, "\t\t(drv not ready)set err=abort\n")
					taskfile[WDERROR] |= WDERRABORT;
				s = 3;
				continue;
			}
			s = 1;
		case 1:
			if ((offset = dosearchid()) == IDMISMATCH)
			{
				dt0(DHW | HWXINFO, 0, "\t\tset err=abort,noid\n")
					taskfile[WDERROR] = WDERRNOID | WDERRABORT;
				s = 3;
				continue;

			}
			s = 2;
		case 2:
			rmac((unsigned short *) 0, BCR);

			/*
			 * disk controller transfers disk data to sector
			 * buffer
			 */
			if (!disktobuffer(offset))
			{
				dt0(DHW | HWXINFO, 0, "\t\tset err=abort,noid\n")
					taskfile[WDERROR] = WDERRNOID | WDERRABORT;
				s = 3;
				continue;

			}
			rmac((unsigned short *) 0, BCR);
			updateposregs();

			/*
			 * at this point, tell the host to unload the sector
			 * buffer, and wait for BRDY signal from sector
			 * buffer when unloaded. (this will occur once host
			 * has done 256 inw's or equivalent)
			 */
			taskfile[WDSTAT] |= WDSTATDRQ;
			taskfile[WDSTAT] &= ~WDSTATBUSY;
			dt0(DHW | HWXINFO, 0, "\t\t+DRQ -BUSY\n")

				if (taskfile[WDSCOUNT]
			/* && (taskfile[WDCMD] & WDCMD_M) ??? M=1 case ??? */
				)
			{
				/* more sectors to come */
				irq(IRQASSERT);
				s = 30;
			} else
			{
				/* last sector done */
				irq(IRQASSERT);
				s = 31;
			}
			return;
		case 3:

			/*
			 * flag error in status register
			 */
			taskfile[WDSTAT] |= WDSTATERROR;
			taskfile[WDSTAT] |= WDSTATDRQ;
			taskfile[WDSTAT] &= ~WDSTATBUSY;
			dt0(DHW | HWXINFO, 0, "\t\t+DRQ +ERROR -BUSY\n")
				irq(IRQASSERT);
			s = 31;
			return;
		case 30:

			/*
			 * wait for buffer ready signal from sector buffer
			 */
			if (state == BRDY)
			{
				taskfile[WDSTAT] &= ~WDSTATDRQ;
				taskfile[WDSTAT] |= WDSTATBUSY;
				dt0(DHW | HWXINFO, 0, "\t\t-DRQ +BUSY\n")
					irq(IRQDEASSERT);
				/*
				 * Give CPU chance to run while we find the
				 * next disk sector. In particular the BIOS
				 * can read the disk status register before
				 * we raise the next interrupt. This is
				 * crucial as reading the disk status
				 * register deasserts the interrupt.
				 */
				add_q_event_i(fdisk_pause, HOST_FDISK_DELAY_1, 0);
				s = 32;
			}
			return;
		case 31:
			if (state == BRDY)
			{
				taskfile[WDSTAT] &= ~WDSTATDRQ;
				taskfile[WDSTAT] &= ~WDSTATCIP;
				dt0(DHW | HWXINFO, 0, "\t\t-DRQ -CIP\n")
					irq(IRQDEASSERT);
				rmac((unsigned short *) 0, BCR);
			}
			return;
		case 32:
			s = 1;
			continue;
		}
}

/*
 * ==========================================================================
 * FUNCTION	:	wsector() PURPOSE		:	handle the
 * 'write' command. EXTERNAL OBJECTS: RETURN VALUE	: INPUT  PARAMS	:
 * state	-	START or CONTINUE or BRDY RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
wsector IFN1(int, state)
{
	static int      s;
	long            offset;

	if (state == START)
	{
		dt0(DHW | HWXINFO, 0, "\tWRITE cmd\n")
			s = 0;
	}
	while (1)
		switch (s)
		{
		case 0:

			/*
			 * tell host to fill sector buffer
			 */
			dt0(DHW | HWXINFO, 0, "\t\t+DRQ\n")
				taskfile[WDSTAT] |= WDSTATDRQ;
			s = 1;
			return;
		case 1:

			/*
			 * wait for sector buffer to be filled by host (don't
			 * issue IRQ first time around)
			 */
			if (state == BRDY)
			{
				dt0(DHW | HWXINFO, 0, "\t\t-DRQ\n")
					taskfile[WDSTAT] &= ~WDSTATDRQ;
				s = 2;
				continue;
			}
			return;
		case 2:

			/*
			 * check drive is ready, and can find sector to write
			 * to.
			 */
			doseek();
			if (!(taskfile[WDSTAT] & WDSTATDRDY))
			{
				dt0(DHW | HWXINFO, 0, "\t\t(drv not ready)err=abort\n")
					taskfile[WDERROR] |= WDERRABORT;
				s = 10;
				continue;
			} else
			{
				if ((offset = dosearchid()) == IDMISMATCH)
				{
					dt0(DHW | HWXINFO, 0, "\t\terr=abort,noid\n")
						taskfile[WDERROR] = WDERRNOID | WDERRABORT;
					s = 10;
					continue;

				}
				s = 3;
				continue;
			}
		case 3:
			rmac((unsigned short *) 0, BCR);

			/*
			 * disk controller transfers sector buffer to disk
			 */
			if (!buffertodisk(offset))
			{

				/*
				 * any errors we report as missing ID
				 */
				dt0(DHW | HWXINFO, 0, "\t\terr=abort,noid\n")
					taskfile[WDERROR] = WDERRNOID | WDERRABORT;
				s = 10;
				continue;

			}
			rmac((unsigned short *) 0, BCR);
			updateposregs();
			if (taskfile[WDSCOUNT])
			{

				/*
				 * more to go ... tell host to fill sector
				 * buffer again
				 */
				dt0(DHW | HWXINFO, 0, "\t\t+DRQ\n")
					taskfile[WDSTAT] |= WDSTATDRQ;
				irq(IRQASSERT);
				s = 4;
				return;
			} else
				/*
				 * all done
				 */
				s = 11;
			continue;
		case 4:

			/*
			 * wait for sector buffer to be filled by host
			 */
			if (state == BRDY)
			{
				dt0(DHW | HWXINFO, 0, "\t\t-DRQ\n")
					taskfile[WDSTAT] &= ~WDSTATDRQ;

				/*
				 * prepare for next sector
				 */
				s = 2;
				continue;
			}
			return;
		case 10:
			dt0(DHW | HWXINFO, 0, "\t\tset ERROR\n")
				taskfile[WDSTAT] |= WDSTATERROR;
		case 11:
			dt0(DHW | HWXINFO, 0, "\t\t-BUSY -CIP\n")
			taskfile[WDSTAT] &= ~WDSTATBUSY;
			taskfile[WDSTAT] &= ~WDSTATCIP;
			irq(IRQASSERT);
			rmac((unsigned short *) 0, BCR);
			return;
		}
}

/*
 * ==========================================================================
 * FUNCTION	:	format() PURPOSE		:	handle the
 * 'format' command. almost a 'dummy' command, but needs to make host write
 * to sector buffer. EXTERNAL OBJECTS: RETURN VALUE	: INPUT  PARAMS	:
 * state	-	START or CONTINUE or BRDY RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
format IFN1(int, state)
{
	static int      s;

	if (state == START)
	{
		dt0(DHW | HWXINFO, 0, "\tFORMAT cmd\n")
			s = 0;
	}
	while (1)
		switch (s)
		{
		case 0:

			/*
			 * initialise sector buffer tell application to write
			 * to sector buffer
			 */
			rmac((unsigned short *) 0, BCR);
			dt0(DHW | HWXINFO, 0, "\t\t+DRQ\n")
				taskfile[WDSTAT] |= WDSTATDRQ;
			s = 1;
			return;
		case 1:

			/*
			 * wait for sector buffer to fill
			 */
			if (state == BRDY)
			{

				/*
				 * no more data, thanks.
				 */
				doseek();
				dt0(DHW | HWXINFO, 0, "\t\t-DRQ\n")
					taskfile[WDSTAT] &= ~WDSTATDRQ;
				if (!(taskfile[WDSTAT] & WDSTATDRDY))
				{

					/*
					 * formatting thin air!
					 */
					s = 2;
					continue;
				} else
				{
					int             cylinder;

					cylinder = ((unsigned int) taskfile[WDCYLHI] << 8)
						+ taskfile[WDCYLLO];
					if (cylinder > pseldrv->maxcyl)

						/*
						 * formatting the spindle!
						 */
						s = 2;
					else
						s = 3;
					continue;
				}
			}
			return;
		case 2:
			dt0(DHW | HWXINFO, 0, "\t\t+ERROR,err=abort")
				taskfile[WDERROR] |= WDERRABORT;
			taskfile[WDSTAT] |= WDSTATERROR;
			s = 3;
		case 3:
			irq(IRQASSERT);
			dt0(DHW | HWXINFO, 0, "\t\t-BUSY -CIP")
				taskfile[WDSTAT] &= ~WDSTATBUSY;
			taskfile[WDSTAT] &= ~WDSTATCIP;
			rmac((unsigned short *) 0, BCR);
			return;
		}
}

/*
 * ==========================================================================
 * FUNCTION	:	rverify() PURPOSE		:	handle the
 * 'read verify' command. .. basically a dummy command. EXTERNAL OBJECTS:
 * RETURN VALUE	: INPUT  PARAMS	:	state	-	START or CONTINUE
 * RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
rverify IFN1(int, state)
{

	UNUSED(state);
	/*
	 * if drive not ready, error
	 */
	dt0(DHW | HWXINFO, 0, "\tREAD VERIFY cmd\n")
		doseek();
	if (!(taskfile[WDSTAT] & WDSTATDRDY))
	{
		dt0(DHW | HWXINFO, 0, "\t\t+ERROR,err=abort\n")
			taskfile[WDSTAT] |= WDSTATERROR;
		taskfile[WDERROR] = WDERRABORT;
	}
	/*
	 * deassert 'busy' and 'command in progress'; reset the sector buffer
	 * counter; issue interrupt
	 */
	dt0(DHW | HWXINFO, 0, "\t\t-BUSY -CIP\n")
		taskfile[WDSTAT] &= ~WDSTATBUSY;
	taskfile[WDSTAT] &= ~WDSTATCIP;
	rmac((unsigned short *) 0, BCR);
	irq(IRQASSERT);
}

/*
 * ==========================================================================
 * FUNCTION	:	diagnose() PURPOSE		:	handle the
 * 'diagnostics' command. EXTERNAL OBJECTS: RETURN VALUE	: INPUT
 * PARAMS	:	state	-	START or CONTINUE RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
diagnose IFN1(int, state)
{
	UNUSED(state);
	dt0(DHW | HWXINFO, 0, "\tDIAGNOSTICS cmd\n")

	/*
	 * flag diagnostics as successful
	 */
		dt0(DHW | HWXINFO, 0, "\t\terr=1\n")
		taskfile[WDERROR] = 1;

	/*
	 * deassert 'busy' and 'command in progress'; reset the sector buffer
	 * counter; issue interrupt
	 */
	dt0(DHW | HWXINFO, 0, "\t\t-BUSY -CIP\n")
		taskfile[WDSTAT] &= ~WDSTATBUSY;
	taskfile[WDSTAT] &= ~WDSTATCIP;
	rmac((unsigned short *) 0, BCR);
	irq(IRQASSERT);
}

/*
 * ==========================================================================
 * FUNCTION	:	setparams() PURPOSE		:	handle the
 * 'set parameters' command. EXTERNAL OBJECTS:	task file. drives. RETURN
 * VALUE	: INPUT  PARAMS	:	state	-	START or CONTINUE
 * RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
setparams IFN1(int, state)
{

	UNUSED(state);
	
	dt0(DHW | HWXINFO, 0, "\tSET PARAMETERS cmd\n")

	/*
	 * legal head values are 0 to (nheads-1)
	 */
		pseldrv->maxhead = taskfile[WDDRVHD] & 0xf;

	/*
	 * legal sector ids are 1 to nsecspertrack
	 */
	pseldrv->nsecspertrack = taskfile[WDSCOUNT];

	/*
	 * calculate some geometry constants ... the dual card is set up for
	 * 512 byte sectors.
	 */
	pseldrv->nbytespertrack = pseldrv->nsecspertrack * 512L;
	pseldrv->nbytespercyl = pseldrv->nbytespertrack * (pseldrv->maxhead + 1L);


	/*
	 * deassert 'busy' and 'command in progress'; reset the sector buffer
	 * counter; issue interrupt
	 */
	dt0(DHW | HWXINFO, 0, "\t\t-BUSY,-CIP,+SC\n")
		taskfile[WDSTAT] &= ~WDSTATBUSY;
	taskfile[WDSTAT] &= ~WDSTATCIP;
	taskfile[WDSTAT] |= WDSTATSEEKCOMPLETE;
	rmac((unsigned short *) 0, BCR);
	irq(IRQASSERT);
}

/*
 * ==========================================================================
 * FUNCTION	:	bad() PURPOSE		:	handle unrecognised
 * disk commands EXTERNAL OBJECTS: RETURN VALUE	: INPUT  PARAMS	:	state
 * -	START or CONTINUE RETURN PARAMS   :
 * ==========================================================================
 */
LOCAL void
bad IFN1(int, state)
{
	UNUSED(state);
	
	dt0(DHW | HWXINFO, 0, "\tBAD cmd\n")

		taskfile[WDSTAT] |= WDSTATERROR;
	taskfile[WDSTAT] &= ~WDSTATBUSY;
	taskfile[WDSTAT] &= ~WDSTATCIP;
	taskfile[WDERROR] = WDERRABORT;
	dt0(DHW | HWXINFO, 0, "\t\t-BUSY -CIP +ERROR;err=abort\n")
		rmac((unsigned short *) 0, BCR);
	irq(IRQASSERT);
}

/*
 * ==========================================================================
 * FUNCTION	:	wd2010() PURPOSE		:	main
 * procedure for the disk controller component of the dual card. This does
 * NOT handle sector buffer accesses. EXTERNAL OBJECTS:	taskfile,sectbuf.
 * RETURN VALUE	: INPUT  PARAMS	:	taskindx	-	index into
 * taskfile value		-	pointer to byte value io
 * 	IOREAD or IOWRITE RETURN PARAMS   :	*value		-	set
 * if IOWRITE
 * ==========================================================================
 */
LOCAL void
wd2010 IFN3(int, taskindx, half_word *, value, int, io)
{

	/*
	 * ignore any task file writes if command in progress (unless new
	 * command)
	 */
	if ((taskfile[WDSTAT] & WDSTATCIP) &&
	    io == IOWRITE && taskindx != WDCMD)
	{
		dt0(DHW | HWXINFO, 0, "\tcommand in progress .. write ignored\n")
			return;
	}
	if (io == IOREAD)
	{

		/*
		 * deassert the interrupt request line.
		 */
		if (taskindx == WDSTAT)
			irq(IRQDEASSERT);

		/*
		 * if a command is in progress, then use this poll as an
		 * excuse to kick the controller again.
		 */
		if (taskfile[WDSTAT] & WDSTATCIP)
			(*activecmd) (CONTINUE);



		/*
		 * for the status register, return the WD2010 status. The
		 * real maccoy actually returns the RMAC's status which
		 * differs from the WD2010 in usage of bit 1. For the WD2010,
		 * this is the 'command in progress' status. For the RMAC,
		 * this is derived from the Index signal returned from the
		 * drive. Since this gives the appearance of being randomish,
		 * (unless being explicitly examined over a long period of
		 * time), just use the WD2010 value.
		 */
		*value = taskfile[taskindx];

		return;
	}
	/*
	 * must be writing to task file and no command is in progress.
	 */
	taskfile[taskindx] = *value;
	if (taskindx == WDCMD)
	{
		int             cmd, drdy;

		/*
		 * deassert interrupt request, clear error register, set
		 * 'command in progress' and busy. maintain same status of
		 * drive ready signal.
		 */
		irq(IRQDEASSERT);
		taskfile[WDERROR] = 0;
		drdy = taskfile[WDSTAT] & WDSTATDRDY;
		if (drdy)
		{
			dt0(DHW | HWXINFO, 0, "\t\t+CIP -WF -SC -DRQ -DC -ERROR +BUSY +DRDY\n")
		} else
		{
			dt0(DHW | HWXINFO, 0, "\t\t+CIP -WF -SC -DRQ -DC -ERROR +BUSY -DRDY\n")
		}
		taskfile[WDSTAT] = WDSTATCIP | WDSTATBUSY | drdy;

		/*
		 * decode the command
		 */
		cmd = *value >> 4;
		if (cmd == DIAG_OR_PARMS)
		{
			if ((*value & 0xf) == DIAG)
				activecmd = diagnose;
			else if ((*value & 0xf) == PARMS)
				activecmd = setparams;
			else
				activecmd = bad;
		} else
			activecmd = dispatch[cmd];

		/*
		 * and start the command off
		 */
		(*activecmd) (START);
	} else if (taskindx == WDDRVHD)
	{

		/*
		 * digital input register reflects head select lines
		 */
		digipreg = (taskfile[WDDRVHD] & 0xf) >> 2;

		if (taskfile[WDDRVHD] & 0x10)
		{

			/*
			 * drive 1 selected
			 */
			digipreg |= 2;

			/*
			 * second drive selected. does it exist?
			 */
			if (!drives[1].wiredup)
			{
				/* no */
				pseldrv = (drvinfo_ *) 0;
				taskfile[WDSTAT] &= ~WDSTATDRDY;
				dt0(DHW | HWXINFO, 0, "\t\t-DRDY\n")
			} else
			{
				/* yes */
				pseldrv = &drives[1];
				taskfile[WDSTAT] |= WDSTATDRDY;
				dt0(DHW | HWXINFO, 0, "\t\t+DRDY\n")
			}
		} else
		{

			/*
			 * first drive selected
			 */

			/*
			 * drive 1 selected
			 */
			digipreg |= 1;

			if (!drives[0].wiredup)
			{
				/* no */
				pseldrv = (drvinfo_ *) 0;
				taskfile[WDSTAT] &= ~WDSTATDRDY;
				dt0(DHW | HWXINFO, 0, "\t\t-DRDY\n")
			} else
			{
				/* yes */
				pseldrv = drives;
				taskfile[WDSTAT] |= WDSTATDRDY;
				dt0(DHW | HWXINFO, 0, "\t\t+DRDY\n")
			}
		}
	}
}

/*
 * ==========================================================================
 * FUNCTION	:	irq() PURPOSE		:	assert/deassert the
 * fixed disk interrupt line EXTERNAL OBJECTS: RETURN VALUE	: INPUT
 * PARAMS	:	line	-	IRQCLEAR,IRQASSERT or IRQDEASSERT
 * RETURN PARAMS   :
 * ==========================================================================
 */

void disk_int_call_back IFN1(long, junk)
{
	UNUSED(junk);
	ica_hw_interrupt (1,6,1);
}

LOCAL void
irq IFN1(int, line)
{
	static int      intrq = IRQDEASSERT;
	switch (line)
	{
	case IRQCLEAR:
		dt0(DHW | INTRUPT, 0, "\t\t** -IRQ\n")
			intrq = IRQDEASSERT;
		break;
	case IRQASSERT:
		if (intrq != IRQASSERT)
		{
			dt0(DHW | INTRUPT, 0, "\t\t** +IRQ\n")

				intrq = IRQASSERT;

			/*
			 * check interrupts not masked out
			 */
			if (!(fixeddiskreg & 2))
				add_q_event_i (disk_int_call_back, HOST_FDISK_DELAY_2, 0);
		}
		break;
	case IRQDEASSERT:
		if (intrq == IRQASSERT)
		{
			dt0(DHW | INTRUPT, 0, "\t\t** -IRQ\n")

				intrq = IRQDEASSERT;

			/* JOKER always wants to deassert the real ICA line */
#ifndef	JOKER
			if (!(fixeddiskreg & 2))
#endif
				ica_clear_int(1, 6);
		}
	}
}

/*
 * ==========================================================================
 * FUNCTION	:	rmac() PURPOSE		:	emulate the buffer
 * manager and controller (WD11C00C-22 (RMAC)) which looks after the sector
 * buffer. EXTERNAL OBJECTS: RETURN VALUE	: INPUT  PARAMS	:	value
 * -	pointer to short to write/read with buffer. sig	-	READ,WRITE or
 * BCR (BCR resets the buffer index .. simulates the BCR pulse) RETURN PARAMS
 * :
 * ==========================================================================
 */
LOCAL void
rmac IFN2(USHORT *, value, int, sig)
{

	switch (sig)
	{
	case BCR:
		dt0(DHW | HWXINFO, 0, "\t\tBCR raised to sector buffer\n")
			sectindx = 0;
		return;
	case IOWRITE:
		sectbuffer[sectindx] = *value;
		break;
	case IOREAD:
		*value = sectbuffer[sectindx];
	}
	if (!++sectindx)
	{
		if (activecmd)
		{
			dt0(DHW | HWXINFO, 0, "\t\t++sector buffer raises BRDY\n")
				(*activecmd) (BRDY);
		}
	}
}

/*
 * ==========================================================================
 * FUNCTION	:	disktobuffer() PURPOSE		:	read a sector
 * from disk image into sector buffer EXTERNAL OBJECTS:	drive structure
 * RETURN VALUE    :	0 	-	error reading file ~0	-	ok.
 * INPUT  PARAMS	:	offset	-	file offset (from 0)
 * ==========================================================================
 */
#define ONESECTOR	1

LOCAL int
disktobuffer IFN1(long, offset)
{
	dt1(DHW | HWXINFO,0,
	    "\t\tdisk data(offset %lx(hex)) -> sector buffer\n", offset)
		return host_fdisk_rd(pseldrv->driveid, offset, ONESECTOR, (char *) sectbuffer);
}

/*
 * ==========================================================================
 * FUNCTION	:	buffertodisk() PURPOSE		:	write the
 * sector buffer to disk image EXTERNAL OBJECTS:	drive structure
 * RETURN VALUE    :	0 	-	error reading file ~0	-	ok.
 * INPUT  PARAMS	:	offset	-	file offset (from 0)
 * ==========================================================================
 */
LOCAL int
buffertodisk IFN1(long, offset)
{
	dt1(DHW | HWXINFO,0,
	    "\t\tsector buffer -> disk (offset %lx(hex))\n", offset)

		return host_fdisk_wt(pseldrv->driveid, offset, ONESECTOR, (char *) sectbuffer);
}

/*
 * 7.INTERMODULE INTERFACE IMPLEMENTATION :
 *
 * [7.1 INTERMODULE DATA DEFINITIONS]
 */
/*
 * [7.2 INTERMODULE PROCEDURE DEFINITIONS]
 */

GLOBAL UTINY fdisk_read_dir IFN2(io_addr, port, UTINY *,value)
{
		switch (port)
	{
	case 0x3f7:
		*value = digipreg;
		dt1(DHW | PORTIO, 0, "read of DIR returns %x(hex)\n", (unsigned) *value)
			break;
	default:
		break;
	}
		return *value;
}

GLOBAL VOID fdisk_inb IFN2(io_addr, port, UTINY *,value)
{
	dt0(DHW, 0, "(\n")

	if (taskfile[WDSTAT] & WDSTATBUSY)
	{
		/* Controller is busy. Return status register contents. */
		*value = taskfile[WDSTAT];
		dt1(DHW | PORTIO, 0, "inb on port %x(hex) - controller busy\n", port)

		/*
		 * deassert the interrupt request line.
		 */
		if ((port - TFBASE) == WDSTAT)
			irq(IRQDEASSERT);

	}
	else
		switch (port)
		{
			case TFBASE:

				/*
		 		 * sector buffer must be accessed only in 16 bit quantities
		 		 */
#ifndef PROD
				printf("(fdisk_inb()) inb on sector buffer ignored!\n");
#endif
				break;
			default:
				dt1(DHW | PORTIO, 0, "inb on port %x(hex)\n", port)

				wd2010(port - TFBASE, value, IOREAD);

				dt1(DHW | PORTIO, 0, "returns %x(hex)\n", (unsigned) *value)
		}
	dt0(DHW, 0, ")\n")
}

GLOBAL VOID fdisk_inw IFN2(io_addr, port, USHORT *, value)
{
#ifdef	JOKER
	/* This is the only way JOKER talks to disks, since
	** Ade's fast disk bios is currently infeasible.
	** Hence, speed is of interest here!
	*/
	if (port == TFBASE)
	{
		/* For speed, JOKER doesn't bother with calling rmac(IOREAD). */

		*value = HostWordToIntelWord(sectbuffer[sectindx]);

		if (!++sectindx)	/* sectindx is a byte value -- wraparound? */
		{
			if (activecmd)
			{
				(*activecmd) (BRDY);
			}
		}
	}

#else	/* JOKER */

#ifdef BIGEND
	unsigned short  temp;
#endif
		switch (port)
	{
	case TFBASE:

#ifdef LITTLEND
			rmac(value, IOREAD);
#endif

#ifdef BIGEND
		rmac(&temp, IOREAD);
		*value = ((temp << 8) & 0xff00) | (temp >> 8);
#endif

#if 0
		dt1(DHW | PORTIO, 0, "inw on sector buffer returns %x(hex)\n", *value)
#else
		dt1(DHW | PORTIO, INW_TRACE_HNDL, "inw on sector buffer", *value)
#endif
			break;
	default:
		/*
		 * task file registers must be accessed as byte quantities
		 */
		dt1(DHW | PORTIO, 0, "inw on port %x(hex) ignored!\n",
		    (unsigned) port)
			break;
	}
#endif	/* JOKER */
}


GLOBAL VOID fdisk_outb IFN2(io_addr, port, UTINY, value)
{
#ifndef NEC_98
	dt0(DHW, 0, "(\n")
		switch (port)
	{
	case TFBASE:

		/*
		 * byte access to sector buffer is not a good idea
		 */
#ifndef PROD
		printf("(disk_outb()) outb to sector buffer ignored\n!");
#endif
		break;
	case TFPCMP:
		dt2(DHW | PORTIO, 0, "outb to port %x(hex),val %x(hex)\n",
		    (unsigned) port, (unsigned) value)

			wd2010(WDPCMP, &value, IOWRITE);

		dt0(DHW | PORTIO, 0, "\n")
			break;
	case TFCMD:
		dt2(DHW | PORTIO, 0, "outb to port %x(hex),val %x(hex)\n",
		    (unsigned) port, (unsigned) value)

			wd2010(WDCMD, &value, IOWRITE);

		dt0(DHW | PORTIO, 0, "\n")
			break;
	case DISKETTE_FDISK_REG:

		/*
		 * Fixed disk register
		 */
		dt2(DHW | PORTIO, 0, "outb to port %x(hex),val %x(hex)\n",
		    (unsigned) port, (unsigned) value)

			if ((fixeddiskreg & 0x4) && !(value & 0x4))
			{
				/* Turn reset off */
				taskfile[WDSTAT] = WDSTATDRDY | WDSTATSEEKCOMPLETE;
				/* Error register in diagnostic mode */
				taskfile[WDERROR] = 0x01; /* No errors */
				/* Reset rest of taskfile */
				taskfile[WDSCOUNT] = taskfile[WDSNUM] = 0x01;
				taskfile[WDCYLLO] = taskfile[WDCYLHI] = taskfile[WDDRVHD] = 0;
			}

			fixeddiskreg = value;

			if (fixeddiskreg & 0x4)
			{
				/* Enable reset fixed disk function */
				taskfile[WDSTAT] = WDSTATBUSY | WDSTATDC | WDSTATERROR;
			}
		break;
	default:
		dt2(DHW | PORTIO, 0, "outb to port %x(hex),val %x(hex)\n",
		    (unsigned) port, (unsigned) value)

			wd2010(port - TFBASE, &value, IOWRITE);
		dt0(DHW | PORTIO, 0, "\n")
	}
	dt0(DHW, 0, ")\n")
#endif // !NEC_98
}

GLOBAL VOID fdisk_outw IFN2(io_addr, port, USHORT, value)
{
#ifdef BIGEND
	unsigned short  temp;
#endif
		switch (port)
	{
	case TFBASE:
#if 0
		dt1(DHW | PORTIO, 0, "outw to sector buffer, val %x(hex)\n",
		    (unsigned) value)
#else
		dt1(DHW | PORTIO, OUTW_TRACE_HNDL, "outw to sector buffer",
		    (unsigned) value)
#endif

#ifdef LITTLEND
			rmac(&value, IOWRITE);
#endif

#ifdef BIGEND
		temp = ((value << 8) & 0xff00) | (value >> 8);
		rmac(&temp, IOWRITE);
#endif

			break;
	default:
		/*
		 * task file registers must be accessed as byte quantities
		 */
		dt1(DHW | PORTIO, 0, "outw to port %x(hex) ignored!\n",
		    (unsigned) port)
			break;
	}
}

GLOBAL VOID fdisk_ioattach IFN0()
{
#ifndef NEC_98
	unsigned short  ncyls;
	unsigned char   nheads;
	unsigned char   nsects;
	io_addr         p;

	/*
	 * attach to io subsystem
	 */
	io_define_in_routines (HDA_ADAPTOR, fdisk_inb,  fdisk_inw,  0, 0);
	io_define_out_routines(HDA_ADAPTOR, fdisk_outb, fdisk_outw, 0, 0);
	/*
	 * attach taskfile
	 */
	for (p = DISK_PORT_START; p <= DISK_PORT_END; p++)
		io_connect_port(p, HDA_ADAPTOR, IO_READ_WRITE);

	/*
	 * attach Fixed disk register
	 */
	io_connect_port(DISKETTE_FDISK_REG, HDA_ADAPTOR, IO_WRITE);

	if (drives[0].physattached)
	{

		/*
		 * indicate drive is wired up to controller
		 */
		drives[0].wiredup = ~0;

		/*
		 * patch 'ROM' table for drive type 0 with appropriate number
		 * of cylinders
		 */
		ncyls = (unsigned short)(drives[0].maxcyl + 1);
		nheads = (unsigned char)(drives[0].maxhead + 1);
		nsects = (unsigned char)(drives[0].maxsect + 1);
#ifdef REAL_ROM
		host_write_enable((DPB0 & (~0xfff)), (DPB0 & (~0xfff)) + 0x1000);
#endif
		patch_rom(DPB0, (unsigned char) (ncyls & 0xff));
		patch_rom(DPB0+1, (unsigned char) (ncyls >> 8));
		patch_rom(DPB0+2, nheads);
		patch_rom(DPB0+0xe, nsects);
#ifdef REAL_ROM
		host_write_protect((DPB0 & (~0xfff)), (DPB0 & (~0xfff)) + 0x1000);
#endif
		dt1(DHW | IOAD, 0, "drive 0 wiredup, total cyls %d\n",
		    (unsigned) ncyls)
	}
	if (drives[1].physattached)
	{

		/*
		 * indicate drive is wired up to controller
		 */
		drives[1].wiredup = ~0;

		/*
		 * patch 'ROM' table for drive type 0 with appropriate number
		 * of cylinders
		 */
		ncyls = (unsigned short)(drives[1].maxcyl + 1);
		nheads = (unsigned char)(drives[1].maxhead + 1);
		nsects = (unsigned char)(drives[1].maxsect + 1);
#ifdef REAL_ROM
		host_write_enable((DPB1 & (~0xfff)), (DPB1 & (~0xfff)) + 0x1000);
#endif
		patch_rom(DPB1, (unsigned char)(ncyls & 0xff));
		patch_rom(DPB1 + 1, (unsigned char)((ncyls >> 8)));
		patch_rom(DPB1+2, nheads);
		patch_rom(DPB1+0xe, nsects);
#ifdef REAL_ROM
		host_write_protect((DPB1 & (~0xfff)), (DPB1 & (~0xfff)) + 0x1000);
#endif
		dt1(DHW | IOAD, 0, "drive 1 wiredup, total cyls %d\n",
		    (unsigned) ncyls)
	}
#endif // !NEC_98
}

GLOBAL VOID fdisk_iodetach IFN0()
{
#ifndef NEC_98
	io_addr         p;

	/*
	 * detach from io subsystem
	 */
	for (p = DISK_PORT_START; p <= DISK_PORT_END; p++)
		io_disconnect_port(p, HDA_ADAPTOR);

	io_disconnect_port(DISKETTE_FDISK_REG, HDA_ADAPTOR);

	if (drives[0].physattached)
	{

		/*
		 * indicate not wired up ... reset table in ROM to indicate
		 * 'bad drive type'
		 */
		drives[0].wiredup = 0;
#ifdef REAL_ROM
		host_write_enable((DPB0 & (~0xfff)), (DPB0 & (~0xfff)) + 0x1000);
#endif
		patch_rom(DPB0, 0);
		patch_rom(DPB0 + 1, 0);
		patch_rom(DPB0 + 2, 0);
		patch_rom(DPB0 + 0xe, 0);
#ifdef REAL_ROM
		host_write_protect((DPB0 & (~0xfff)), (DPB0 & (~0xfff)) + 0x1000);
#endif
		dt0(DHW | IOAD, 0, "drive 0 unplugged\n")
	}
	if (drives[1].physattached)
	{

		/*
		 * indicate not wired up ... reset table in ROM to indicate
		 * 'bad drive type'
		 */
		drives[1].wiredup = 0;
#ifdef REAL_ROM
		host_write_enable((DPB1 & (~0xfff)), (DPB1 & (~0xfff)) + 0x1000);
#endif
		patch_rom(DPB1, 0);
		patch_rom(DPB1 + 1, 0);
		patch_rom(DPB1 + 2, 0);
		patch_rom(DPB1 + 0xe, 0);
#ifdef REAL_ROM
		host_write_protect((DPB1 & (~0xfff)), (DPB1 & (~0xfff)) + 0x1000);
#endif
		dt0(DHW | IOAD, 0, "drive 1 unplugged\n")
	}
#endif // !NEC_98
}

GLOBAL VOID fdisk_physattach IFN1(int,driveno)
{
	int             invalid = 0;
	int             ncyls;
	int             nheads;
	int             nsects;

	drives[driveno].driveid = driveno;
	drives[driveno].physattached = 0;

	if (!*((CHAR *) config_inquire((IU8)(C_HARD_DISK1_NAME + driveno), NULL)))
		return;

	/*
	 * configuration specifies a disk image file ... validate it
	 */
	 host_fdisk_get_params(driveno, &ncyls, &nheads, &nsects);

	/*
	 * set maximum available cylinder value (this is
	 * artificial. The real controller on an AT does not
	 * have this knowledge ... it fails on ID matching if
	 * it seeks to a non-existent cylinder
	 */
	drives[driveno].nsecspertrack = nsects;
	drives[driveno].nbytespertrack = nsects * 512L;
	drives[driveno].nbytespercyl = drives[driveno].nbytespertrack * nheads;
	drives[driveno].maxcyl = --ncyls;
	drives[driveno].maxhead = --nheads;
	drives[driveno].maxsect = --nsects;
	drives[driveno].physattached = ~0;

	fast_disk_bios_attach(driveno);
}

#ifdef macintosh

GLOBAL VOID fdisk_physdetach IFN1(int,driveno)
{
	if (drives[driveno].physattached)
	{
		host_fdisk_close(driveno);

		drives[driveno].physattached = 0;

		fast_disk_bios_detach (driveno);

		dt0(DHW|PAD, 0, "drive %d closed\n")
	}
}
#endif /* macintosh */

GLOBAL VOID fdisk_reset IFN0()
{
	taskfile[WDERROR] = 0;
	taskfile[WDSCOUNT] = 0;
	taskfile[WDSNUM] = 0;
	taskfile[WDCYLLO] = 0;
	taskfile[WDCYLHI] = 0;
	taskfile[WDDRVHD] = 0;

	/*
	 * show drive 1 selected ... head 0 selected
	 */
	digipreg = 1;

	/*
	 * show drive is ready if available
	 */
	if (drives[0].wiredup)
	{
		taskfile[WDSTAT] = WDSTATDRDY | WDSTATSEEKCOMPLETE;

		/*
		 * reposition file pointer for drive 0 at beginning of file
		 */
		host_fdisk_seek0(0);
	} else
		taskfile[WDSTAT] = 0;

	if (drives[1].wiredup)

		/*
		 * reposition file pointer for drive 1 at beginning of file
		 */
	host_fdisk_seek0(1);

	/*
	 * initialise sector buffer
	 */
	rmac((unsigned short *) 0, BCR);
}


GLOBAL VOID hda_init IFN0()
{
	fdisk_iodetach();
	fast_disk_bios_detach(0);
	fast_disk_bios_detach(1);

	fdisk_physattach(0);
	fdisk_physattach(1);
	fdisk_ioattach();
	fdisk_reset();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\disks\fla.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Version 2.0
 *
 * Title	: Floppy Disk Adaptor Emulator
 *
 * Description	: The following functions are defined in this module:
 *
 *		  fla_init()		Initialise the fla
 *		  fla_inb()		Read byte from port
 *		  fla_outb()		Write byte to port
 *
 *		  The actual interface to the device that is acting as
 *		  a floppy diskette (ie virtual file, slave PC or device
 *		  driver for real diskette) is handled by the GFI layer.
 *		  Hence the job of the FLA is to package up the command
 *		  and pass it to GFI and simulate the result phase once
 *		  GFI has executed the command.
 *
 *		  This module provides the Bios and CPU with an emulation
 *		  of the entire Diskette Adaptor Card including the
 *		  Intel 8272A FDC and the Digital Ouput Register.
 *
 * Author	: Henry Nash / Jim Hatfield
 *
 * Notes	: For a detailed description of the IBM Floppy Disk Adaptor
 *		  and the INTEL Controller chip refer to the following
 *		  documents:
 *
 *		  - IBM PC/XT Technical Reference Manual
 *				(Section 1-109 Diskette Adaptor)
 *		  - INTEL Microsystems Components Handbook
 *				(Section 6-478 FDC 8272A)
 *
 *		  The interaction of the Sense Interrupt Status command with
 *		  the Recalibrate and Seek commands and with chip reset is
 *		  very complex. The FDC chip does NOT behave as its spec sheets
 *		  say in some situations. We do the best we can here. If all
 *		  Seek and Recalibrate commands on a drive are followed by
 *		  Sense Interrupt Status before any other command to that
 *		  drive then all should be OK.
 *
 */

#ifdef SCCSID
static char SccsID[]="@(#)fla.c	1.18 07/06/94 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_FLOPPY.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "ica.h"
#include "ios.h"
#include "fla.h"
#include "config.h"
#include "gfi.h"
#include "trace.h"
#include "debug.h"
#include "fdisk.h"
#include "quick_ev.h"

/*
 * ============================================================================
 * Global data
 * ============================================================================
 */

/*
 * The flag indicating that the FLA is busy and cannot accept asynchronous
 * commands (eg motor off).
 */

boolean fla_busy = TRUE;	/* busy until initialised */
boolean fla_ndma = FALSE;

/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */

/*
 * Static forward declarations.
 */
static void fdc_ndma_bufmgr_wt IPT1(half_word, value);
static void fla_atomicxqt IPT0();
static void fla_ndmaxqt IPT0();
static void fla_ndma_bump_sectid IPT0();

/*
 * The command and result blocks that are used to communicate to the GFI
 * layer. The result block is filled in by gfi during the execution phase.
 */

static FDC_CMD_BLOCK    fdc_command_block[MAX_COMMAND_LEN];
static FDC_RESULT_BLOCK fdc_result_block[MAX_RESULT_LEN];

#define FDC_INVALID_CMD	0x80			/* Status after bad command */
#define FDC_NORMAL_TERMINATION 0

/*
 * The FLA supports the FDC status register.
 */

static half_word fdc_status;			

/*
 * The FLA holds the current active (if any) command in the following byte.
 * This is used as an index into the FDC command data structure.
 */

static half_word fdc_current_command;

/*
 * The FLA has an output interrupt line which is gated by a bit in the DOR.
 */

static half_word fdc_int_line;

/*
 * The FLA knows when a Sense Interrupt Status is permitted.
 */

static struct {
	half_word full;			/* Slot occupied	*/
	half_word res[2];		/* Result phase		*/
	      } fdc_sis_slot[4];	/* One for each drive	*/

/*
 * The FLA is responsible for maintaining the command and result phases
 * of the FDC.  Two variables hold the current pointer into the stack
 * of command and result registers.
 */

static half_word fdc_command_count;
static half_word fdc_result_count;

/*
 * The FLA will emulate non-DMA 8088 <==> FDC data transfers, but only allow DMA mode
 * transfers to actually be sent to the GFI (potentially the back end of the SCSI might
 * re-map this again).
 * The following variable reflects whether the FDC has been put into non-DMA mode
 * from the 8088 program's point of view
 */


/* The following sector buffer is used for non_dma transfers */

#ifdef macintosh
char *fla_ndma_buffer; /* so that host_init can 'see' it to malloc() it. */
#else
static char fla_ndma_buffer[8192];
#endif
static int fla_ndma_buffer_count;
static int fla_ndma_sector_size;

/*
 * The FLA stores the IBM Digital Output Register internally
 */

#ifdef BIT_ORDER1
typedef union {
	 	half_word all;
		struct {
			 HALF_WORD_BIT_FIELD motor_3_on:1;
			 HALF_WORD_BIT_FIELD motor_2_on:1;
			 HALF_WORD_BIT_FIELD motor_1_on:1;
			 HALF_WORD_BIT_FIELD motor_0_on:1;
			 HALF_WORD_BIT_FIELD interrupts_enabled:1;
			 HALF_WORD_BIT_FIELD not_reset:1;
			 HALF_WORD_BIT_FIELD drive_select:2;
		       } bits;
	      } DOR;
#endif

#ifdef BIT_ORDER2
typedef union {
	 	half_word all;
		struct {
			 HALF_WORD_BIT_FIELD drive_select:2;
			 HALF_WORD_BIT_FIELD not_reset:1;
			 HALF_WORD_BIT_FIELD interrupts_enabled:1;
			 HALF_WORD_BIT_FIELD motor_0_on:1;
			 HALF_WORD_BIT_FIELD motor_1_on:1;
			 HALF_WORD_BIT_FIELD motor_2_on:1;
			 HALF_WORD_BIT_FIELD motor_3_on:1;
		       } bits;
	      } DOR;
#endif

DOR dor;
static IU8 drive_selected = 0;	/* Device last used. */
		
/* Centralised handling of connection to ICA, so that very slow
 * CPUs can find out if there is a floppy interrupt pending (see
 * wait_int() in floppy.c). There is some confusion in the code anyway,
 * because the fdc_int_line would appear to be the wire from the
 * fdc to the ica, but the code doesn't quite manage to use it in
 * this way.
 */

GLOBAL IBOOL fdc_interrupt_pending = FALSE;

LOCAL void fla_clear_int IFN0()
{
	/* if (fdc_int_line && dor.bits.interrupts_enabled) */

	if (fdc_interrupt_pending) {
		ica_clear_int(0, CPU_DISKETTE_INT);
	}

	fdc_int_line = 0;
	fdc_interrupt_pending = FALSE;
}

LOCAL void fla_hw_interrupt IFN0()
{
	ica_hw_interrupt(0, CPU_DISKETTE_INT, 1);
	fdc_interrupt_pending = TRUE;

	/* We would like to set fdc_int_line in this routine,
	 * but this wouldn't match the existing code. In particular
	 * there are calls which don't seem to include setting the
	 * fdc_int_line, and a call which sets up a quick_event to
	 * interrupt the ICA but which sets the fdc_int_line
	 * immediately.
	 */
}

/*
 * ============================================================================
 * External functions
 * ============================================================================
 */

/* This procedure is called from the host specific rfloppy routines
 * as an equivalent to dma_enquire, when the intel program has selected
 * non-dma mode for the FDC (via the SPECIFY command)
 */

void fla_ndma_enquire IFN1(int *,transfer_count)
{
	*transfer_count = fla_ndma_buffer_count;
}

/* This procedure is called from the host specific rfloppy routines
 * when it wants to transfer diskette data read from the diskette to
 * the 'non-dma buffer' (equivalent of dma_request). The Intel program will be fed from this non-dma buffer.
 */

void fla_ndma_req_wt IFN2(char *,buf,int,n)
{
	char *p = fla_ndma_buffer;

	fla_ndma_buffer_count = n;
	while(n--)
		*p++ = *buf++;
}

/* This procedure is called from the host specific rfloppy routines
 * when it wants data destined for the diskette
 */

void fla_ndma_req_rd IFN2(char *,buf,int,n)
{
	char *p = fla_ndma_buffer;

	while (n--)
		*buf++ = *p++;
}


void fla_inb IFN2(io_addr, port, half_word *,value)
{
#ifndef NEC_98


    note_trace0_no_nl(FLA_VERBOSE, "fla_inb() ");
    fla_busy = TRUE;

    if (port == DISKETTE_STATUS_REG)
    {
	*value = fdc_status;

	/*
	 * After a read of this register assert the RQM bit,
	 * unless the 'not_reset' line is held low!
	 */

	if (dor.bits.not_reset)
	    fdc_status |= FDC_RQM;
    }
    else
    if (port == DISKETTE_DATA_REG)
    {
	/*
	 * Make sure the 'not reset' line in the DOR is high
	 */

	if (!dor.bits.not_reset)
	{
            note_trace0_no_nl(FLA_VERBOSE, "<chip frozen!>");
	    *value = 0;
	    return;
	}

	/*
	 * Make sure that the RQM bit is up
	 */

	if (!(fdc_status & FDC_RQM))
	{
            note_trace0_no_nl(FLA_VERBOSE, "<no RQM!>");
	    *value = 0;
	    return;
	}

	/*
	 * Make sure that the DIO bit is up
	 */

	if (!(fdc_status & FDC_DIO))
	{
            note_trace0_no_nl(FLA_VERBOSE, "<no DIO!>");
	    *value = 0;
	    return;
	}

	/*
	 * The first byte of the result phase will clear the INT line
	 */

	if (fdc_result_count == 0)
		fla_clear_int();

	/*
	 * Read the result bytes out of the result block one at a time.
	 */

	*value = fdc_result_block[fdc_result_count++];

	if (fdc_result_count >= gfi_fdc_description[fdc_current_command].result_bytes)
	{
	    /*
	     * End of result phase - clear BUSY and DIO bits of status reg
	     */

	    fdc_status     &= ~FDC_BUSY;
	    fdc_status     &= ~FDC_DIO;
	    fdc_result_count    = 0;
	}

	/*
	 * After a read of the data register de-assert the RQM bit
	 */

	fdc_status &= ~FDC_RQM;
    }

    else if (port == DISKETTE_DIR_REG)
    {
	/*
	 * On the DUAL card, the bottom 7 bits of this register are
	 * supplied by the fixed disk adapter ...
	 */
	fdisk_read_dir(port, value);

	/*
	 * ... the top bit comes from the floppy disk adapter
	 */
	if (gfi_change(drive_selected))
	    *value |= DIR_DISKETTE_CHANGE;
	else
	    *value &= ~DIR_DISKETTE_CHANGE;
    }
    else if (port == DISKETTE_ID_REG)
    {
	/*
	** Do we have a Dual Card ?
	** This is an important question for the floppy BIOS.
	** If a Dual Card exists then the BIOS will do data rate changes
	** supporting hi and lo density media, without a Dual Card the BIOS
	** assumes that lo density media is always present.
	** I imagine this is because a "real" PC has limited floppy device
	** options and a hi density 3.5 inch unit will only exist with a
	** dual card.
	** This is not the case for SoftPC, any combination of floppy devices
	** seems to be quite OK.
	** I will try pretending we have a Dual Card whenever a high denisty
	** unit is present on A or B.
	*/
	switch( gfi_drive_type(0) ){
		case GFI_DRIVE_TYPE_12:
		case GFI_DRIVE_TYPE_144:
		case GFI_DRIVE_TYPE_288:
			*value = DUAL_CARD_ID; break;
		case GFI_DRIVE_TYPE_360:
		case GFI_DRIVE_TYPE_720:
		case GFI_DRIVE_TYPE_NULL:
			switch( gfi_drive_type(1) ){
				case GFI_DRIVE_TYPE_12:
				case GFI_DRIVE_TYPE_144:
				case GFI_DRIVE_TYPE_288:
					*value = DUAL_CARD_ID; break;
				case GFI_DRIVE_TYPE_360:
				case GFI_DRIVE_TYPE_720:
				case GFI_DRIVE_TYPE_NULL:
	    				*value = 0; break;
				default:
					always_trace0("ERROR: bad drive type");
					break;
			}
			break;
		default:
			always_trace0( "ERROR: Bad drive type." );
			break;
	}
#ifndef PROD
	if( *value==DUAL_CARD_ID ){
		note_trace0( FLA_VERBOSE, "Dual Card\n" );
	}else{
		note_trace0( FLA_VERBOSE, "No Dual Card\n" );
	}
#endif
    }
    else
    {
	*value = 0;
        note_trace0_no_nl(FLA_VERBOSE, "<unknown port>");
    }

    note_trace2(FLA_VERBOSE, " port %x, returning %x", port, *value);
    fla_busy = FALSE;


#endif // !NEC_98
}


void fla_outb IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
    int i;
    DOR new_dor;


    note_trace2_no_nl(FLA_VERBOSE, "fla_outb(): port %x, value %x ", port, value);
    fla_busy = TRUE;



    if (port == DISKETTE_STATUS_REG)
    {
        note_trace0(FLA_VERBOSE, "<write on status reg>");
    }

    else if (port == DISKETTE_DCR_REG)
    {
		/*
		** Send the specified data rate to the floppy using the new
		** style gfi_high() function that now has a data rate parameter.
		*/
		note_trace2( FLA_VERBOSE,
		             "fla_outb:DCR:port=%x value=%x set data rate",
		             port, value );
		gfi_high(dor.bits.drive_select, value);
    }
    else if (port == DISKETTE_DATA_REG)
    {
	/*
	 * Make sure the 'not reset' line in the DOR is high
	 */

	if (!dor.bits.not_reset)
	{
            note_trace0_no_nl(FLA_VERBOSE, "<chip frozen!>");
	    return;
	}

	/*
	 * Make sure that the RQM bit is up
	 */

	if (!(fdc_status & FDC_RQM))
	{
            note_trace0_no_nl(FLA_VERBOSE, "<no RQM!>");
	    return;
	}

	/*
	 * Make sure that the DIO bit is down
	 */

	if (fdc_status & FDC_DIO)
	{
            note_trace0_no_nl(FLA_VERBOSE, "<DIO set!>");
	    return;
	}

        note_trace0(FLA_VERBOSE, "");

	/*
	 * Output to the data register: must be programming up a command or issuing
	 * a data byte for a non-dma disk write.
	 * If the BUSY flag isn't set then it's the first byte.
     	 */

	if (!(fdc_status & FDC_BUSY))
	{
	    fdc_current_command = value & FDC_COMMAND_MASK;
	    fdc_command_count   = 0;
	    fdc_status         |= FDC_BUSY;
	}

	if (!(fdc_status & FDC_NDMA))
	/* programming up a command
	 */
	{
	    if (gfi_fdc_description[fdc_current_command].cmd_bytes == 0)
	    {
	        /*
    	         * Invalid command or Sense Int Status.
	         * If Sense Int Status, try to find some result phase data,
	         * else treat as an invalid command. In either case go
	         * straight into the result phase.
	         * Sense Int Status also clears Drive Busy bits and the INT line.
	         */

	        if (fdc_current_command == FDC_SENSE_INT_STATUS)
	        {
		    for (i = 0; i < 4; i++)
		        if (fdc_sis_slot[i].full)
		    	    break;

		    if (i < 4)	/* Found one!	*/
		    {
		        fdc_sis_slot[i].full = 0;
		        fdc_result_block[0] = fdc_sis_slot[i].res[0];
		        fdc_result_block[1] = fdc_sis_slot[i].res[1];

		    	fla_clear_int();		/* Clear INT line */

		        fdc_status &= ~(1 << i);	/* Clear Drive Busy */
		    }
		    else
		    {
		        fdc_command_block[0] = 0;
		        fdc_result_block[0]  = FDC_INVALID_CMD;
		    }
	        }
	        else
	        {
		    fdc_command_block[0] = 0;
		    fdc_result_block[0]  = FDC_INVALID_CMD;
	        }

	        fdc_status     |= FDC_DIO;
	    }
	    else
	    {
	        fdc_command_block[fdc_command_count++] = value;
	        if (fdc_command_count >= gfi_fdc_description[fdc_current_command].cmd_bytes)
	        {
	        /* n.b; the field 'dma_required' is a misnomer ... it
	         * strictly should be 'data_required'
	         */
                    if (!(gfi_fdc_description[fdc_current_command].dma_required))
		        fla_atomicxqt();
	            else
	            {
		        if (!fla_ndma)
		    	    fla_atomicxqt();
		        else
			    fla_ndmaxqt();
                    }
	        }
	    }
	}
	else
	/* receiving a non-dma data byte
	 */
	{
	    /* pass written byte to buffer manager
	     */
	    fdc_ndma_bufmgr_wt (value);
	    if (!fdc_int_line && dor.bits.interrupts_enabled)
                fla_hw_interrupt();
	}


	/*
	 * On write of the data register de-assert the RQM bit
	 */

	fdc_status &= ~FDC_RQM;
    }

    else
    if (port == DISKETTE_DOR_REG)
    {
        note_trace0(FLA_VERBOSE, "");

  	new_dor.all = value;
	if (!new_dor.bits.not_reset)
	{
	    dor.all = new_dor.all;
	    dor.bits.motor_0_on = 0;
	    dor.bits.motor_1_on = 0;
	    dor.bits.motor_2_on = 0;
	    dor.bits.motor_3_on = 0;
	    fdc_status         &= ~FDC_RQM;
	    fdc_int_line        = 0;
	}
	else
	{
	    if (!dor.bits.not_reset && new_dor.bits.not_reset)
	    {
	        /*
	         * Reset the FLA and GFI (and hence the real device).
	         * It is assumed that GFI reset will stop all drive motors.
		 * After the reset check to see if we need to turn any drive on.
		 *
		 * Note that reset effectively has a result phase since GFI
		 * will execute a Sense Interrupt Status command after it.
	         */
		
		gfi_reset(fdc_result_block, new_dor.bits.drive_select);

		fdc_status = FDC_RQM;
		fdc_command_count = 0;
		fdc_result_count  = 0;

		for (i = 0; i < 4; i++)
		{
		    fdc_sis_slot[i].full   = 1;
		    fdc_sis_slot[i].res[0] = 0xC0 + i;	/* Empirically	*/
		    fdc_sis_slot[i].res[1] = 0;
		}

		fdc_int_line      = 1;
	    }

	    /*
	     * There are three ways in which an interrupt may be generated:
	     *
	     * 1) The not_reset line goes low to high when the enable_ints
	     *	  line is high.
	     *
	     * 2) The enable_ints line goes low to high when the INT line
	     *	  is high.
	     *
	     * 3) Both of the above!
	     */

	    if ((!dor.bits.not_reset && new_dor.bits.not_reset && new_dor.bits.interrupts_enabled)
	      ||(fdc_int_line && !dor.bits.interrupts_enabled && new_dor.bits.interrupts_enabled))
		    fla_hw_interrupt();

	    /*
	     * If any drive motor bits have changed then issue GFI calls
	     */

	    if (!dor.bits.motor_0_on && new_dor.bits.motor_0_on)
	        gfi_drive_on(0);
	    else
	    if (dor.bits.motor_0_on && !new_dor.bits.motor_0_on)
	        gfi_drive_off(0);

	    if (!dor.bits.motor_1_on && new_dor.bits.motor_1_on)
	        gfi_drive_on(1);
	    else
	    if (dor.bits.motor_1_on && !new_dor.bits.motor_1_on)
	        gfi_drive_off(1);

	    if (!dor.bits.motor_2_on && new_dor.bits.motor_2_on)
	        gfi_drive_on(2);
	    else
	    if (dor.bits.motor_2_on && !new_dor.bits.motor_2_on)
	        gfi_drive_off(2);

	    if (!dor.bits.motor_3_on && new_dor.bits.motor_3_on)
	        gfi_drive_on(3);
	    else
	    if (dor.bits.motor_3_on && !new_dor.bits.motor_3_on)
	        gfi_drive_off(3);

	    /* Only store drive_select if actively used. */
	    if (new_dor.bits.motor_0_on || new_dor.bits.motor_1_on)
	    {
		drive_selected = new_dor.bits.drive_select;
	    }
	    dor.all = new_dor.all;	
	}
    }

#ifndef PROD
    else
        note_trace0(FLA_VERBOSE, "<unknown port>");
#endif

    fla_busy = FALSE;


#endif // !NEC_98
}


void trap_ndma IFN0()
{
        if (get_type_cmd(fdc_command_block) == FDC_SPECIFY)
        {
            if (get_c6_ND(fdc_command_block))
            {

                fla_ndma = TRUE;
                put_c6_ND(fdc_command_block, 0);
                note_trace0(FLA_VERBOSE, "DISABLING NON_DMA FDC REQ>");
            }
            else
                fla_ndma = FALSE;
        }
}

LOCAL	void fla_int_call_back IFN1(long,junk)
{
	UNUSED(junk);
	fla_hw_interrupt();
}

#ifdef NTVDM

void fdc_command_completed (UTINY drive, half_word fdc_command)
{

    if (gfi_fdc_description[fdc_command].int_required) {
	if (!fdc_int_line && dor.bits.interrupts_enabled)
	    add_q_event_i(fla_int_call_back, HOST_FLA_DELAY, 0);
	fdc_int_line = 1;
    }

    /*
     * If the command issued was Seek or Recalibrate, save
     * the GFI result phase ready for Sense Int Status.
     * Set the Drive Busy line (cleared by SIS).
     * Any other command clears the SIS slot.
     */

    if (fdc_command == FDC_SEEK || fdc_command == FDC_RECALIBRATE) {
	fdc_sis_slot[drive].full = 1;
	fdc_sis_slot[drive].res[0] = fdc_result_block[0];
	fdc_sis_slot[drive].res[1] = fdc_result_block[1];
	fdc_status |= (1 << drive);
    }
    else
	fdc_sis_slot[drive].full = 0;

    /*
     * If there is no result phase then go back to READY.
     */

    if (gfi_fdc_description[fdc_command].result_bytes == 0)
	fdc_status &= ~FDC_BUSY;
    else
	fdc_status |= FDC_DIO;
}

/*
 * This routine will 'automatically' execute the current FDC command.
 * The GFI layer will actually perform the command/execution/result phases
 * and return any result block. The Intel program.
 */

static void fla_atomicxqt IFN0()
{
	int ret_stat;
	UTINY drive;

	/*
	 * Call GFI to execute the command
	 */
	drive = get_type_drive(fdc_command_block);
	trap_ndma();

	ret_stat = gfi_fdc_command(fdc_command_block, fdc_result_block);
	if (ret_stat != SUCCESS)
	{
	    /*
	     * GFI failed due to timeout or protocol error - so we will
	     * fake up a real timeout by not generating an interrupt.
	     */
/* we created a new thread to simulate the fdc while something is wrong.
 * here we don't want to turn the busy signal off until we have a reset
 *	    fdc_status	   &= ~FDC_BUSY;
 *	    fdc_status	   &= ~FDC_DIO;
 */
            note_trace1(FLA_VERBOSE, "fla_outb(): <gfi returns error %x>",
                        ret_stat);
	}
	else
	    fdc_command_completed(drive, fdc_current_command);
}

#else    /* NTVDM */

/*
 * This routine will 'automatically' execute the current FDC command.
 * The GFI layer will actually perform the command/execution/result phases
 * and return any result block. The Intel program.
 */

static void fla_atomicxqt IFN0()
{
	int ret_stat;
	int drive;

	/*
	 * Call GFI to execute the command
	 */

	trap_ndma();

	ret_stat = gfi_fdc_command(fdc_command_block, fdc_result_block);
	if (ret_stat != SUCCESS)
	{
	    /*
	     * GFI failed due to timeout or protocol error - so we will
	     * fake up a real timeout by not generating an interrupt.
	     */

	    fdc_status     &= ~FDC_BUSY;
	    fdc_status     &= ~FDC_DIO;

            note_trace1(FLA_VERBOSE, "fla_outb(): <gfi returns error %x>",
                        ret_stat);
	}
	else
	{
	    /*
	     * Command was successful, generate an interrupt if enabled.
	     */

	    if (gfi_fdc_description[fdc_current_command].int_required)
	    {
		if (!fdc_int_line && dor.bits.interrupts_enabled) {
			add_q_event_i(fla_int_call_back, HOST_FLA_DELAY, 0);
		}
		fdc_int_line = 1;
	    }

	    /*
	     * If the command issued was Seek or Recalibrate, save
	     * the GFI result phase ready for Sense Int Status.
	     * Set the Drive Busy line (cleared by SIS).
	     * Any other command clears the SIS slot.
	     */

	    drive = get_type_drive(fdc_command_block);

	    if (fdc_current_command == FDC_SEEK || fdc_current_command == FDC_RECALIBRATE)
	    {
		fdc_sis_slot[drive].full = 1;
		fdc_sis_slot[drive].res[0] = fdc_result_block[0];
		fdc_sis_slot[drive].res[1] = fdc_result_block[1];
		fdc_status |= (1 << drive);
	    }
	    else
		fdc_sis_slot[drive].full = 0;

    	    /*
     	     * If there is no result phase then go back to READY.
	     */

	    if (gfi_fdc_description[fdc_current_command].result_bytes == 0)
		fdc_status &= ~FDC_BUSY;
	    else
		fdc_status |= FDC_DIO;
	}
}
#endif    /* NTVDM */


static void fdc_request_write_data_to_cpu IFN0()
{
	if (!fdc_int_line && dor.bits.interrupts_enabled)
            fla_hw_interrupt();
}


static void fdc_request_read_data_from_cpu IFN0()
{
	if (!fdc_int_line && dor.bits.interrupts_enabled)
            fla_hw_interrupt();
}


/* Prepare for processor data requests.
 * i.e; based upon the current command, establish the minimum number of bytes
 * likely to be involved in a transfer, based upon the N parameter.
 * Set the fla_ndma_byte_count global appropriately. Set the ndma buffer
 * count to zero, forcing a real command read to occur the first time
 * the Intel program tries to read/write data to the FDC during its
 * non-dma execution phase.
 * Issue the first interrupt, and set FDC status register to mirror this
 * and set non-dma bit in status register
 */

static void fla_ndmaxqt IFN0()
{
	int n;
        static int fla_ndma_sectsize[] = {128,256,512,1024,2048,4096,8192};

        note_trace0(FLA_VERBOSE, "DOING FLA_NDMAXQT");

        /* set the non-dma bit in the status register ...
         * this clears at the end of the execution phase
         */

        fdc_status |= FDC_NDMA;

        fla_ndma_buffer_count = 0;

        switch (gfi_fdc_description[fdc_current_command].cmd_class)
        {
        case 0:         /* sector read(s)                               */

                n = get_c0_N(fdc_command_block);
                if (n)
                        fla_ndma_sector_size = fla_ndma_sectsize[n];
                else
                        fla_ndma_sector_size = get_c0_DTL(fdc_command_block);

                /* kick of the execution phase by issuing
                 * an interrupt
                 */

                fdc_request_write_data_to_cpu();

                break;

        case 1:         /* sector write(s)                              */

                n = get_c0_N(fdc_command_block);
                if (n)
                        fla_ndma_sector_size = fla_ndma_sectsize[n];
                else
                        fla_ndma_sector_size = get_c0_DTL(fdc_command_block);


                /* kick of the execution phase by issuing
                 * an interrupt
                 */

                fdc_request_read_data_from_cpu();

                break;

        case 2:         /* track read                                   */
                always_trace0("\n FLA ... non-dma read track unimplemented");
                break;

        case 3:         /* format track                                 */
                always_trace0("\n FLA ... non-dma format unimplemented");
                break;

        default:
                always_trace0("\n FLA ... unexpected command for non-dma");
        }
}


/*
 * peek a quick look at the 'first' sector involved in this current
 * FDC command, to establish whether abnormal termination would have occurred * with the non-DMA transfer, and flag accordingly
 */

void fla_ndma_sector_peep IFN1(int *,all_clear)
/* all_clear ----->                = 0 --> time out
                                 * = 1 --> sector good
                                 * = 2 --> abnormal termination
                                 */
{
        int true_command, status;

        /* build a 'read data' command using all current command
         * parameters.
         */

        true_command = get_type_cmd(fdc_command_block);
        put_type_cmd(fdc_command_block, FDC_READ_DATA);

        status = gfi_fdc_command(fdc_command_block, fdc_result_block);

	fla_ndma_buffer_count = 0;

        /* repair the command block
         */

        put_type_cmd(fdc_command_block, true_command);

        *all_clear = 0;

        if (status == SUCCESS)
        {
                if (get_r1_ST0_int_code(fdc_result_block) == FDC_NORMAL_TERMINATION)
                        *all_clear = 1;
                else
                        *all_clear = 2;
        }

}

/* This routine emulates the execution phase for sector writes
 * ... Here we buffer up data destined for the diskette on a
 * 'per sector' basis (the 'sector' size being determined by the
 * 'N' parameter (or possibly the 'DTL' parameter (if N=0)) specified
 * within the FDC command block. If the buffer is empty, the equivalent
 * read command is issued to the GFI layer, mainly to determine whether
 * the sector is kosher.
 */

static void fdc_ndma_bufmgr_wt IFN1(half_word, value)
{
	int status;
	int all_clear;

        note_trace1(FLA_VERBOSE,
                    "FDC_NDMA_BUFMGR_WT called .. buffered byte = %x",
                    (unsigned int) value);

	/*
	 * empty buffer!! if so, read the sector first to see if it exists, etc.
	 */

	if (fla_ndma_buffer_count == 0)
	{
		fla_ndma_sector_peep(&all_clear);
		switch (all_clear)
		{
		case 0:		/* FDC dead */
			fdc_status &= ~FDC_BUSY;
			fdc_status &= ~FDC_DIO;
			return;
		case 1:		/* FDC cooking */
			/* ... increment the sector id (as the controller
			 * would do given half a chance!!
			 */
			fla_ndma_bump_sectid();
			break;
		case 2: 	/* FDC does not like command parameters
				 * if it doesn't ... neither do i !!
				 */
			if (!fdc_int_line && dor.bits.interrupts_enabled)
			    fla_hw_interrupt();
			fdc_status &= ~FDC_NDMA;
			fdc_status |= FDC_DIO;
			return;
		}
	}

	/* is there room in the buffer ? ... flush out if not
	 * and recurse.
	 */

	if (fla_ndma_buffer_count == fla_ndma_sector_size)
	{
		/* do the command ... the GFI layler will call 'fla_ndma_req_rd'
		 * to get the data in this full buffer
		 */

		status = gfi_fdc_command(fdc_command_block, fdc_result_block);

		/* reset the buffer */

		fla_ndma_buffer_count = 0;

		if (status != SUCCESS)
		{
			fdc_status &= ~FDC_BUSY;
			fdc_status &= ~FDC_DIO;
		}
		else
		{
			if (get_r1_ST0_int_code(fdc_result_block) == FDC_NORMAL_TERMINATION)
			fdc_ndma_bufmgr_wt(value);
			else
			{
				if (!fdc_int_line && dor.bits.interrupts_enabled)
				    fla_hw_interrupt();
				fdc_status &= ~FDC_NDMA;
				fdc_status |= FDC_DIO;
			}
		}
	}
	else
		fla_ndma_buffer[fla_ndma_buffer_count++] = value;

}


static void fla_ndma_bump_sectid IFN0()
{
	int i;

	i = get_c0_sector(fdc_command_block) + 1;
	put_c0_sector(fdc_command_block, ((unsigned char)i));
}

static void fla_ndma_unbump_sectid IFN0()
{
	int i;

	i = get_c0_sector(fdc_command_block) - 1;
	put_c0_sector(fdc_command_block, ((unsigned char)i));
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * function will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

void fla_init IFN0()
{
#ifndef NEC_98
    io_addr i;

    note_trace0(FLA_VERBOSE, "fla_init() called");

    /*
     * Set up the IO chip select logic for this adaptor
     * Assume that the DOR comes up with all bits zero.
     */

    io_define_inb(FLA_ADAPTOR, fla_inb);
    io_define_outb(FLA_ADAPTOR, fla_outb);

    /*
     * For the DUAL card, one of the registers must be left
     * for the hard disk adapter to connect to
     */

    for(i = DISKETTE_PORT_START; i <= DISKETTE_PORT_END; i++)
    {
	if (i != DISKETTE_FDISK_REG)
	    io_connect_port(i, FLA_ADAPTOR, IO_READ_WRITE);
    }

    fla_busy = TRUE;

    fdc_status        = 0;
    fdc_command_count = 0;
    fdc_result_count  = 0;
    fdc_int_line      = 0;
    dor.all           = 0;

    fla_ndma = FALSE;
    fla_busy = FALSE;
#endif // !NEC_98
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\disks\gfi.c ===
#include "insignia.h"
#include "host_def.h"

/*
 * SoftPC Version 2.0
 *
 * Title	: Generic Floppy Interface (GFI)
 *
 * Description	: GFI is a layer that insulates the Floppy Adaptor (FLA)
 *		  from the type of device that is attached to VPC.  It
 *		  supports the slave PC, Virtual Diskette and a real
 *		  device attached to the host.
 *
 *		  GFI provides a suite of functions which can
 *		  be called to action Floppy commands.  GFI will
 *		  route these to the current resident device.
 *
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 *
 * Mods: (r3.2) : The system directory /usr/include/sys is not available
 *                on a Mac running Finder and MPW. Bracket references to
 *                such include files by "#ifdef macintosh <Mac file> #else
 *                <Unix file> #endif".
 */

#ifdef SCCSID
static char SccsID[]="@(#)gfi.c	1.16 08/03/93 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_FLOPPY.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "ios.h"
#include "bios.h"
#include "error.h"
#include "config.h"
#include "trace.h"
#include "fla.h"
#include "gfi.h"
#include "gfitest.h"
#include "error.h"
#include "debug.h"

/*
 * ============================================================================
 * External definitions
 * ============================================================================
 */

/*
 * The command/result phases of the FDC are described in the following database.
 *
 * The structure contains
 *
 *	- number of command bytes
 *	- number of result bytes
 *	- number of GFI result bytes
 *	- command class
 *	- result class
 *	- if dma is required
 *	- if an interrupt is generated
 *
 * A command byte count of 0 indicates a command that is handled by the FLA
 * itself and not passed to GFI.
 *
 * Note that Sense Interrupt Status is not considered a generic GFI command
 * but as a terminating command for the seek and recalibrate commands.
 * These two commands now have "result" phases as far as gfi is concerned
 * since the gfi level will ensure that a Sense Interrupt Status is performed
 * to provide the result phase.
 */

FDC_DATA_ENTRY gfi_fdc_description[] =
{
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 9, 7, 7, 2, 0, TRUE,	TRUE  },	/* read track */
	{ 3, 0, 0, 6, 0, FALSE,	FALSE },	/* specify */
	{ 2, 1, 1, 7, 2, FALSE,	FALSE },	/* sense drive status */
	{ 9, 7, 7, 1, 0, TRUE,	TRUE  },	/* write data */
	{ 9, 7, 7, 0, 0, TRUE,	TRUE  },	/* read data */
	{ 2, 0, 2, 5, 0, FALSE,	TRUE  },	/* recalibrate */
	{ 0, 2, 2, 0, 3, FALSE,	FALSE },	/* sense int status  */
	{ 9, 7, 7, 1, 0, TRUE,	TRUE  },	/* write deleted data */
	{ 2, 7, 7, 4, 0, FALSE,	TRUE  },	/* read ID */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 9, 7, 7, 0, 0, TRUE,	TRUE  },	/* read deleted data */
	{ 6, 7, 7, 3, 0, TRUE,	TRUE  },	/* format track */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 3, 0, 2, 8, 3, FALSE,	TRUE  },	/* seek */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 9, 7, 7, 0, 0, TRUE,	TRUE  },	/* scan equal */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 9, 7, 7, 0, 0, TRUE,	TRUE  },	/* scan equal */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 9, 7, 7, 0, 0, TRUE,	TRUE  },	/* scan equal */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
	{ 0, 1, 1, 0, 4, FALSE,	FALSE },	/* invalid */
};

/*
 * The function table that is built by the init function of the
 * individual GFI servers.
 */

GFI_FUNCTION_ENTRY gfi_function_table[MAX_DISKETTES];


/*
 * ============================================================================
 * External functions
 * ============================================================================
 */

GLOBAL SHORT gfi_fdc_command
IFN2(FDC_CMD_BLOCK *,command_block,FDC_RESULT_BLOCK *,result_block)
{
    /*
     * The main FDC command.  Route to the correct module.
     */

    int i;
    int ret_stat = SUCCESS;

#ifndef PROD
    if (io_verbose & GFI_VERBOSE)
	gfi_test_command(command_block, result_block);
#endif

    if (get_type_cmd(command_block) == FDC_SPECIFY)
    {
	/*
	 * A specify command relates to all drives so call each in turn.
 	 * Not that even the empty drive allows specifies.
	 */

	for (i = 0; i < MAX_DISKETTES; i++)
	{
            put_type_drive(command_block, i);
	    /* some host floppies like to know the correct drive number */
	    (*gfi_function_table[i].command_fn)(command_block, result_block);
	}
    }
    else
 	/*
	 * All other commands specify the drive in the command.
   	 */

	ret_stat = (*gfi_function_table[get_type_drive(command_block)].command_fn)(command_block, result_block);

    return((SHORT)ret_stat);
}


GLOBAL SHORT gfi_drive_on IFN1(UTINY,drive)
{
#ifndef PROD
    if (io_verbose & GFI_VERBOSE)
	gfi_test_drive_on(drive);
#endif

    /*
     * Route to the correct module.
     */

    return((*gfi_function_table[drive].drive_on_fn)(drive));
}

GLOBAL SHORT gfi_drive_off IFN1(UTINY,drive)
{
#ifndef PROD
    if (io_verbose & GFI_VERBOSE)
	gfi_test_drive_off(drive);
#endif

    /*
     * Route to the correct module.
     */

    return((*gfi_function_table[drive].drive_off_fn)(drive));
}


GLOBAL SHORT gfi_reset IFN2(FDC_RESULT_BLOCK *,result_block, UTINY, drive)
{
    /*
     * Reset the specified drive.
     */

#ifndef PROD
    if (io_verbose & GFI_VERBOSE)
	gfi_test_reset(result_block);
#endif

    /*
     * Reset the appropriate drive.
     */

    (*gfi_function_table[drive].reset_fn)(result_block, drive);

    /*
     * The result phase returns the data for a subsequent Sense Interrupt
     * Status, and should contain a "termination due to state change".
     */

    put_r3_ST0(result_block, 0);
    put_r1_ST0_int_code(result_block, 3);
    put_r3_PCN(result_block, 0);

    return(SUCCESS);
}

/*
** Set the specified datarate.
*/
GLOBAL SHORT gfi_high IFN2(UTINY,drive,half_word,datarate)
{
#ifndef PROD
    if (io_verbose & GFI_VERBOSE)
        gfi_test_high(drive);
#endif

    /*
     * Route to the correct module.
     */

    return((*gfi_function_table[drive].high_fn)(drive,datarate));
}


GLOBAL SHORT gfi_drive_type IFN1(UTINY,drive)
{
#ifndef PROD
    if (io_verbose & GFI_VERBOSE)
        gfi_test_drive_type(drive);
#endif

    /*
     * Route to the correct module.
     */

    return((*gfi_function_table[drive].drive_type_fn)(drive));
}

GLOBAL SHORT gfi_change IFN1(UTINY,drive)
{
#ifndef PROD
    if (io_verbose & GFI_VERBOSE)
        gfi_test_change(drive);
#endif

    /*
     * Route to the correct module.
     */

    return((*gfi_function_table[drive].change_fn)(drive));
}

GLOBAL SHORT
gfi_floppy_valid
IFN4(UTINY, hostID, ConfigValues *,vals, NameTable *,table, CHAR *,err)
{
	UNUSED(table);
#ifdef SLAVEPC
	if (hostID == C_SLAVEPC_DEVICE)
		return host_slave_port_validate(host_expand_environment_vars(
			vals->string), err);
#endif /* SLAVEPC */

	return host_gfi_rdiskette_valid(hostID, vals, err);
}

GLOBAL VOID
gfi_floppy_change IFN2(UTINY, hostID, BOOL, apply)
{
#ifdef SLAVEPC
	if (hostID == C_SLAVEPC_DEVICE)
	{
		gfi_slave_change(hostID, apply);
		return;
	}
#endif /* SLAVEPC */

	host_gfi_rdiskette_change(hostID, apply);
}

GLOBAL SHORT
gfi_floppy_active IFN3(UTINY, hostID, BOOL, active, CHAR *,err)
{
#ifdef SLAVEPC
	if (hostID == C_SLAVEPC_DEVICE)
		return gfi_slave_active(hostID, active, err);
#endif /* SLAVEPC */

	return host_gfi_rdiskette_active(hostID, active, err);
}

GLOBAL VOID
gfi_attach_adapter IFN2(UTINY, adapter, BOOL, attach)
{
#ifdef SLAVEPC
	if (host_runtime_inquire(C_FLOPPY_SERVER) == GFI_SLAVE_SERVER)
	{
		if (adapter == 1)
			return;	/* No B adapter for slave PC */

		/* First cleaup the other possible adapters */
		if (config_get_active(C_FLOPPY_A_DEVICE))
			config_activate(C_FLOPPY_A_DEVICE, FALSE);
#ifdef FLOPPY_B
		if (config_get_active(C_FLOPPY_B_DEVICE))
			config_activate(C_FLOPPY_B_DEVICE, FALSE);
#endif /* FLOPPY_B */

		/* Activate the SLAVEPC device handler */
		config_activate(C_SLAVEPC_DEVICE, attach);
		return;
	}
	/* Must be a GFI_REAL_DISKETTE_SERVER */
	if (config_get_active(C_SLAVEPC_DEVICE))
		config_activate(C_SLAVEPC_DEVICE, FALSE);
#endif /* SLAVEPC */

	config_activate((UTINY)(C_FLOPPY_A_DEVICE + adapter), attach);
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * function will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

/*
 * Initialize the GFI module.  Fill the function table with the GFI
 * "empty" server module (which will cause a timeout when accessed).
 */

GLOBAL VOID gfi_init IFN0()
{
	int i;

	host_runtime_set(C_FLOPPY_SERVER, GFI_REAL_DISKETTE_SERVER);

	for (i = 0; i < MAX_DISKETTES; i++)
		gfi_empty_active((UTINY)(C_FLOPPY_A_DEVICE+i),TRUE,NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\disks\floppy_i.c ===
#if defined(NEC_98)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#endif // NEC_98
#include "insignia.h"
#include "host_def.h"

extern void host_simulate();
/*
 * SoftPC Revision 3.0
 *
 *
 * Title	: Primary SFD BIOS floppy diskette functions
 *
 *
 * Description	: This module defines the floppy diskette BIOS functions
 *		  that are invoked directly from BOP instructions:
 *
 *		  diskette_io()		floppy diskette access functions
 *
 *		  diskette_post()	floppy diskette POST function
 *
 *		  diskette_int()	floppy diskette interrupt handler
 *
 *
 * Author	: Ross Beresford
 *
 *
 * Notes	:
 *
 */


/*
 * static char SccsID[]="@(#)floppy_io.c	1.14 03/02/94 Copyright Insignia Solutions Ltd.";
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_FLOPPY.seg"
#endif

#include <stdio.h>
#include TypesH
#include "xt.h"
#include "bios.h"
#include "ios.h"
#include CpuH
#include "error.h"
#include "config.h"
#include "gfi.h"
#include "fla.h"
#include "sas.h"
#include "floppy.h"
#include "equip.h"
#include "trace.h"
#include "ica.h"
#include "debug.h"

#include "tape_io.h"
#if defined(NEC_98)
#include <winioctl.h>
#endif // NEC_98

#ifdef NTVDM
extern UTINY number_of_floppy;

#endif	/* NTVDM */

#if defined(NEC_98)
#define FLS_NORMAL_END          0x00
#define FLS_READY               0x00
#define FLS_WRITE_PROTECTED     0x10
#define FLS_DMA_BOUNDARY        0x20
#define FLS_END_OF_CYLINDER     0x30
#define FLS_EQUIPMENT_CHECK     0x40
#define FLS_OVER_RUN            0x50
#define FLS_NOT_READY           0x60
#define FLS_ERROR               0x80
#define FLS_TIME_OUT            0x90
#define FLS_DATA_ERROR          0xA0
#define FLS_BAD_CYLINDER        0xD0
#define FLS_MISSING_ID          0xE0

#define FLS_DOUBLE_SIDE         (1 << 0)
#define FLS_DETECTION_AI        (1 << 1)
#define FLS_HIGH_DENSITY        (1 << 2)
#define FLS_2MODE               (1 << 3)
#define FLS_AVAILABLE_1PT44MB   ((1 << 3)|(1 << 2))

#define FLP_FNC_ERR     0x00
#define FLP_VERIFY      0x01
#define FLP_SENSE       0x04
#define FLP_WRITE       0x05
#define FLP_READ        0x06
#define FLP_RECALIBRATE 0x07
#define FLP_READ_ID     0x0A
#define FLP_FORMAT      0x0D

#define MEDIA_IS_FLOPPY (1 << 4)
#define OP_MULTI_TRACK  (1 << 7)
#define OP_SEEK         (1 << 4)
#define OP_MFM_MODE     (1 << 6)
#define OP_NEW_SENSE    (1 << 7)
#define OP_SENSE2       ((1 << 7)|(1 << 6))

#define ST3_READY               (1 << 5)
#define ST3_WRITE_PROTECT       (1 << 6)
#define ST3_DOUBLE_SIDE         (1 << 3)

#define MEDIA_2D_DA     0x50

/*
**      Drive DA/UA Table for 98 Disk Bios
*/
typedef struct {
        CHAR    DeviceName[29];
        UCHAR   Daua;
        UINT    FloppyNum;
        UINT    FdiskNum;
} DAUATBL;

DAUATBL DauaTable[MAX_FLOPPY];

/*
**      Last accessed Track Number Table
*/
typedef struct {
        UCHAR   cylinder;
        UCHAR   head;
} ACCESSTRACK;

ACCESSTRACK LastAccess[MAX_FLOPPY];

/*
**      Definition
*/
#define FDISK_DA        0xA0
#define FLOPPY_DA       0x90

/*
**      Functions defined later
**/
void    SetDauaTable IPT0();
BOOL    CheckFatSystem IPT1( BYTE, drive);
BOOL    CheckIfsSystem IPT1( BYTE, drive);
BOOL    CheckFloppy IPT1( BYTE, drive);
int     ConvToPhysical IPT2( UINT, daua, UINT, base );
int     ConvToLogical IPT1( UINT, daua );
void    SetDiskBiosCarryFlag IPT1( UINT, flag);
LOCAL HANDLE DosDriveOpen IPT1(BYTE, drive);

extern  void fl_disk_recal IPT1(int, drive);

#endif // NEC_98
#ifndef	PROD
/*
 *	Internal functions (for tracing)
 */

static void rwvf_dump(op)
int	op;
{
#if defined(NEC_98)

        fprintf(trace_file, "(DA/UA=0x%02x,head=%d,cyl=%d,sec=%d,secl=%d,len=%d,addr=%x:%x",
                getAL(), getDH()&0x01, getCL(), getDL(), getCH(), getBX(), getES(), getBP());

#else  // !NEC_98
	fprintf(trace_file, "(drive=%d,head=%d,track=%d,sec=%d,nsecs=%d",
		getDL(), getDH(), getCH(), getCL(), getAL());
	if (op != FL_DISK_VERF)
		fprintf(trace_file, ",addr=%x:%x", getES(), getBX());
#endif // !NEC_98
	fprintf(trace_file, ")\n");
}


static void call_dump(op)
int op;
{
	half_word diskette_status;

#if defined(NEC_98)
        switch(op & 0x0f)
        {
        case    FLP_VERIFY:
                fprintf(trace_file, "diskette_io:VERIFY");
                rwvf_dump(op);
                break;
        case    FLP_SENSE:
                fprintf(trace_file, "diskette_io:SENSE(DA/UA=0x%02x)\n", getAL());
                break;
        case    FLP_WRITE:
                fprintf(trace_file, "diskette_io:WRITE");
                rwvf_dump(op);
                break;
        case    FLP_READ:
                fprintf(trace_file, "diskette_io:READ");
                rwvf_dump(op);
                break;
        case    FLP_RECALIBRATE:
                fprintf(trace_file, "diskette_io:RECALIBRATE(DA/UA=0x%02x)\n", getAL());
                break;
        case    FLP_READ_ID:
                fprintf(trace_file,
                        "diskette_io:READ_ID(DA/UA=0x%02x,head=%d,cyl=%d)\n",
                                getAL(), getDH()&0x01, getCL());
                break;
        case    FLP_FORMAT:
                fprintf(trace_file, "diskette_io:FORMAT(DA/UA=0x%02x,head=%d,cyl=%d,pad=0x%x,secl=%d,len=%d,addr=%x:%x",
                        getAL(), getDH()&0x01, getCL(), getDL(), getCH(), getBX(), getES(), getBP());
                break;
        default:
                fprintf(trace_file, "diskette_io:UNRECOGNISED(op=0x%x)\n", op);
                break;
        }
#else  // !NEC_98
	switch(op)
	{
	case	FL_DISK_RESET:
		fprintf(trace_file, "diskette_io:RESET()\n");
		break;
	case	FL_DISK_STATUS:
		fprintf(trace_file, "diskette_io:STATUS");
		sas_load(FLOPPY_STATUS, &diskette_status);
		fprintf(trace_file, "(status=0x%x)\n", diskette_status);
		break;
	case	FL_DISK_READ:
		fprintf(trace_file, "diskette_io:READ");
		rwvf_dump(op);
		break;
	case	FL_DISK_WRITE:
		fprintf(trace_file, "diskette_io:WRITE");
		rwvf_dump(op);
		break;
	case	FL_DISK_VERF:
		fprintf(trace_file, "diskette_io:VERIFY");
		rwvf_dump(op);
		break;
	case	FL_DISK_FORMAT:
		fprintf(trace_file, "diskette_io:FORMAT");
		rwvf_dump(op);
		break;
	case	FL_DISK_PARMS:
		fprintf(trace_file, "diskette_io:PARAMS(drive=%d)\n", getDL());
		break;
	case	FL_DISK_TYPE:
		fprintf(trace_file, "diskette_io:TYPE(drive=%d)\n", getDL());
		break;
	case	FL_DISK_CHANGE:
		fprintf(trace_file, "diskette_io:CHANGE(drive=%d)\n", getDL());
		break;
	case	FL_FORMAT_SET:
		fprintf(trace_file,
			"diskette_io:SET_FORMAT(drive=%d,type=", getDL());
		switch(getAL())
		{
		case MEDIA_TYPE_360_IN_360:
			fprintf(trace_file, "360K media in 360K drive)\n");
			break;
		case MEDIA_TYPE_360_IN_12:
			fprintf(trace_file, "360K media in 1.2M drive)\n");
			break;
		case MEDIA_TYPE_12_IN_12:
			fprintf(trace_file, "1.2M media in 1.2M drive)\n");
			break;
		case MEDIA_TYPE_720_IN_720:
			fprintf(trace_file, "720K media in 720K drive)\n");
			break;
		case MEDIA_TYPE_720_IN_144:
			fprintf(trace_file, "720K media in 1.44M drive)\n");
			break;
		case MEDIA_TYPE_144_IN_144:
			fprintf(trace_file, "1.44M media in 1.44M drive)\n");
			break;
		default:
			fprintf(trace_file, "SILLY)\n");
			break;
		}
		break;
	case	FL_SET_MEDIA:
		fprintf(trace_file,
			"diskette_io:SET_MEDIA(drive=%d,tracks=%d,sectors=%d)\n",
			getDL(), getCH(), getCL());
		break;
	
	default:
		fprintf(trace_file, "diskette_io:UNRECOGNISED(op=0x%x)\n", op);
		break;
	}
#endif // !NEC_98
}


static void gen_dump()
{
	int status = getAH();

	fprintf(trace_file, "status=");
#if defined(NEC_98)
        if(status & FLS_DOUBLE_SIDE)
        {
                fprintf(trace_file, "FLS_DOUBLE_SIDE|");
                if((status & 0xf0) == FLS_READY)
                {
                        fprintf(trace_file, "FLS_READY");
                        return;
                }
        }
        switch(status & 0xf0)
        {
        case FLS_NORMAL_END:
                fprintf(trace_file, "FLS_NORMAL_END");
                break;
        case FLS_WRITE_PROTECTED:
                fprintf(trace_file, "FLS_WRITE_PROTECTED");
                break;
        case FLS_DMA_BOUNDARY:
                fprintf(trace_file, "FLS_DMA_BOUNDARY");
                break;
        case FLS_END_OF_CYLINDER:
                fprintf(trace_file, "FLS_END_OF_CYLINDER");
                break;
        case FLS_EQUIPMENT_CHECK:
                fprintf(trace_file, "FLS_EQUIPMENT_CHECK");
                break;
        case FLS_OVER_RUN:
                fprintf(trace_file, "FLS_OVER_RUN");
                break;
        case FLS_NOT_READY:
                fprintf(trace_file, "FLS_NOT_READY");
                break;
        case FLS_ERROR:
                fprintf(trace_file, "FLS_ERROR");
                break;
        case FLS_TIME_OUT:
                fprintf(trace_file, "FLS_TIME_OUT");
                break;
        case FLS_DATA_ERROR:
                fprintf(trace_file, "FLS_DATA_ERROR");
                break;
        case FLS_BAD_CYLINDER:
                fprintf(trace_file, "FLS_BAD_CYLINDER");
                break;
        case FLS_MISSING_ID:
                fprintf(trace_file, "FLS_MISSING_ID");
                break;
        default:
                fprintf(trace_file, "SILLY");
                break;
        }
#else  // !NEC_98
	if (status & FS_CRC_ERROR)
		fprintf(trace_file, "FS_CRC_ERROR|");
	if (status & FS_FDC_ERROR)
		fprintf(trace_file, "FS_FDC_ERROR|");
	if (status & FS_SEEK_ERROR)
		fprintf(trace_file, "FS_SEEK_ERROR|");
	if (status & FS_TIME_OUT)
		fprintf(trace_file, "FS_TIME_OUT|");
	switch (status & 0xf)
	{
	case FS_OK:
		fprintf(trace_file, "FS_OK");
		break;
	case FS_BAD_COMMAND:
		fprintf(trace_file, "FS_BAD_COMMAND");
		break;
	case FS_BAD_ADDRESS_MARK:
		fprintf(trace_file, "FS_BAD_ADDRESS_MARK");
		break;
	case FS_WRITE_PROTECTED:
		fprintf(trace_file, "FS_WRITE_PROTECTED");
		break;
	case FS_SECTOR_NOT_FOUND:
		fprintf(trace_file, "FS_SECTOR_NOT_FOUND");
		break;
	case FS_MEDIA_CHANGE:
		fprintf(trace_file, "FS_MEDIA_CHANGE");
		break;
	case FS_DMA_ERROR:
		fprintf(trace_file, "FS_DMA_ERROR");
		break;
	case FS_DMA_BOUNDARY:
		fprintf(trace_file, "FS_DMA_BOUNDARY");
		break;
	case FS_MEDIA_NOT_FOUND:
		fprintf(trace_file, "FS_MEDIA_NOT_FOUND");
		break;
	default:
		fprintf(trace_file, "SILLY");
		break;
	}
#endif // !NEC_98
	fprintf(trace_file, ")\n");
}


static void return_dump(op)
int op;
{
	fprintf(trace_file, "diskette_io:RETURN(");
#if defined(NEC_98)
        switch(op & 0x0f)
        {
        case    FLP_VERIFY:
        case    FLP_SENSE:
        case    FLP_WRITE:
        case    FLP_READ:
        case    FLP_RECALIBRATE:
        case    FLP_FORMAT:
                gen_dump();
                break;
        case    FLP_READ_ID:
                fprintf(trace_file,"C=%d,H=%d,R=%d,N=%d,",
                        getCL(), getDH()&0x01, getDL(), getCH());
                gen_dump();
                break;
        default:
                break;
        }
#else  // !NEC_98
	switch(op)
	{
	case	FL_DISK_TYPE:
		switch(getAH())
		{
		case DRIVE_IQ_UNKNOWN:
			fprintf(trace_file, "ABSENT");
			break;
		case DRIVE_IQ_NO_CHANGE_LINE:
			fprintf(trace_file, "NO CHANGE LINE");
			break;
		case DRIVE_IQ_CHANGE_LINE:
			fprintf(trace_file, "CHANGE LINE");
			break;
		case DRIVE_IQ_RESERVED:
			fprintf(trace_file, "RESERVED");
			break;
		default:
			fprintf(trace_file, "SILLY");
			break;
		}
		fprintf(trace_file, ")\n");
		break;
	case	FL_DISK_PARMS:
		fprintf(trace_file, "addr=%x:%x,tracks=%d,sectors=%d,heads=%d,drives=%d,type=",
			getES(), getDI(), getCH(), getCL(), getDH(), getDL());
		switch(getBL())
		{
		case GFI_DRIVE_TYPE_NULL:
			fprintf(trace_file, "NULL,");
			break;
		case GFI_DRIVE_TYPE_360:
			fprintf(trace_file, "360K,");
			break;
		case GFI_DRIVE_TYPE_12:
			fprintf(trace_file, "1.2M,");
			break;
		case GFI_DRIVE_TYPE_720:
			fprintf(trace_file, "720K,");
			break;
		case GFI_DRIVE_TYPE_144:
			fprintf(trace_file, "1.44M,");
			break;
		case GFI_DRIVE_TYPE_288:
			fprintf(trace_file, "2.88M,");
			break;
		default:
			fprintf(trace_file, "SILLY,");
			break;
		}
		gen_dump();
		break;
	case	FL_SET_MEDIA:
		fprintf(trace_file, "addr=%x:%x,", getES(), getDI());
		gen_dump();
		break;
	case	FL_DISK_READ:
	case	FL_DISK_WRITE:
	case	FL_DISK_VERF:
	case	FL_DISK_FORMAT:
		fprintf(trace_file, "nsecs=%d,", getAL());
		gen_dump();
		break;
	case	FL_DISK_CHANGE:
	case	FL_DISK_RESET:
	case	FL_DISK_STATUS:
	case	FL_FNC_ERR:
	case	FL_FORMAT_SET:
		gen_dump();
		break;
	default:
		break;
	}
#endif // !NEC_98
}
#endif /* nPROD */


void diskette_io()
{
#if defined(NEC_98)
        /*
         *      Check for valid call and use secondary functions to
         *      perform the required operation
         *
         *      Register inputs:
         *              AH      operation required
         *              AL      DA/UA
         */
        int op = getAH(), drive = getAL();
        int op2;
        UINT PrevPopUp_Mode;
#else  // !NEC_98
	/*
	 *	Check for valid call and use secondary functions to
	 *	perform the required operation
	 *
	 *	Register inputs:
	 *		AH	operation required
	 *		DL	drive number
	 */
	half_word diskette_status;
	int op = getAH(), drive = getDL();
#endif // !NEC_98

#ifndef	PROD
	if (io_verbose & FLOPBIOS_VERBOSE)
		call_dump(op);
#endif

#if defined(NEC_98)
        /*
        **      Convert from DA/UA to physical drive number(0 based).
        */
        drive = ConvToPhysical(drive,FLOPPY_DA);

        /*
        **      set up error pop up mode on occuring critical error.
        */
        PrevPopUp_Mode = SetErrorMode( SEM_FAILCRITICALERRORS );

#endif // NEC_98
#ifndef	JOKER
	/*
	 *	Enable interrupts
	 */

	setIF(1);	
#endif	/* JOKER */

	/*
	 *	Check operation required, using known invalid function
	 *	if operation is out of range
	 */

#if defined(NEC_98)
        op2 = op & 0x0f;
        if (!fl_operation_in_range(op2))
                op = FLP_FNC_ERR;
#else  // !NEC_98
	if (!fl_operation_in_range(op))
		op = FL_FNC_ERR;
#endif // !NEC_98

	/*
	 *	If the drive number is applicable in the operation, check it
	 */

#ifndef NEC_98
	if (op != FL_DISK_RESET && op != FL_DISK_STATUS && op != FL_DISK_PARMS)
#ifdef NTVDM
		if (drive >= number_of_floppy)
#else
		if (drive >= MAX_FLOPPY)
#endif /* NTVDM */
			op = FL_FNC_ERR;
#endif // !NEC_98


#ifndef NEC_98
	/*
	 *	Save previous diskette status, initialise current diskette
	 *	status to OK
	 */

	sas_load(FLOPPY_STATUS, &diskette_status);
	setAH(diskette_status);
	sas_store(FLOPPY_STATUS, FS_OK);
#endif // !NEC_98

	/*
	 *	Do the operation
	 */

#if defined(NEC_98)
        (*fl_fnc_tab[op & 0x0f])(drive);
#else  // !NEC_98
	(*fl_fnc_tab[op])(drive);
#endif // !NEC_98


#if defined(NEC_98)
        /*
        **      reset error pop up mode.
        */
        SetErrorMode( PrevPopUp_Mode );
#endif // NEC_98

#ifndef	PROD
	if (io_verbose & FLOPBIOS_VERBOSE)
		return_dump(op);
#endif
}


#ifndef	JOKER		/* Floppies handled v. weirdly on JOKER */

void diskette_int()
{
	/*
	 * The diskette interrupt service routine.  Mark the Seek Status to say
	 * the interrupt has occurred and terminate the interrupt.
	 */
	half_word seek_status;
	word savedAX, savedCS, savedIP;

	note_trace0(FLOPBIOS_VERBOSE, "diskette_int()");
	sas_load(SEEK_STATUS, &seek_status);
	sas_store(SEEK_STATUS, (IU8)(seek_status | SS_INT_OCCURRED));

	outb(ICA0_PORT_0, END_INTERRUPT);

	/*
	 *	Enable interrupts
	 */

	setIF(1);	

	/*
	 *	Notify OS that BIOS has completed a "wait" for
	 *	a diskette interrupt
	 */
	savedAX = getAX();
	savedCS = getCS();
	savedIP = getIP();

	setAH(INT15_INTERRUPT_COMPLETE);
	setAL(INT15_DEVICE_FLOPPY);
#ifdef NTVDM
	setCS(int15_seg);
	setIP(int15_off);
#else
	setCS(RCPU_INT15_SEGMENT);
	setIP(RCPU_INT15_OFFSET);
#endif /* NTVDM */

	host_simulate();

	setAX(savedAX);
	setCS(savedCS);
	setIP(savedIP);
}

#endif	/* ndef JOKER */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

void diskette_post()
{
	/*
	 *	This routine performs the diskette BIOS initialisation
	 *	functionality in the POST.
	 */
#if defined(NEC_98)
        CHAR i;
        UINT PrevPopUp_Mode;
#else  // !NEC_98
	half_word diskette_id_reg, hf_cntrl, interrupt_mask;
#ifndef NTVDM
	half_word disk_state;
#endif
	EQUIPMENT_WORD equip_flag;
#endif // !NEC_98

	note_trace0(FLOPBIOS_VERBOSE, "diskette_post()");

#if defined(NEC_98)
        /*
        **      Set up error pop up mode on critical error.
        */
        PrevPopUp_Mode = SetErrorMode( SEM_FAILCRITICALERRORS );

        /*
        **      Set up DA/UA table for converting
        **      from DA/UA to physical drive number
        */
        SetDauaTable();

        /*
        **      Perform recalibarate to all floppy drive
        */
        for( i=0; i<MAX_FLOPPY; i++)
                LastAccess[i].cylinder = LastAccess[i].head = 0;

        /*
        **      Reset error pop up mode.
        */
        SetErrorMode( PrevPopUp_Mode );
#else  // !NEC_98
	/*
	 *	Set the diskette data rate to 250 kbs (low density)
	 */

	outb(DISKETTE_DCR_REG, DCR_RATE_250);

	/*
	 *	If there are any diskettes installed, check whether
	 *	they are accessed via a DUAL card or the old-style
	 *	adapter card
	 */

	sas_loadw(EQUIP_FLAG, &equip_flag.all);
	if (equip_flag.bits.diskette_present)
	{
		/*
		 *	Enable diskette interrupts
		 */

		inb(ICA0_PORT_1, &interrupt_mask);
		interrupt_mask &= ~(1 << CPU_DISKETTE_INT);
		outb(ICA0_PORT_1, interrupt_mask);

		/*
		 *	If a DUAL diskette/fixed disk adapter is fitted,
		 *	set the drive indicator for drive 0 accordingly
		 */

		inb(DISKETTE_ID_REG, &diskette_id_reg);
		sas_load(DRIVE_CAPABILITY, &hf_cntrl);
		hf_cntrl &= ~DC_DUAL;
		if ((diskette_id_reg & IDR_ID_MASK) == DUAL_CARD_ID)
			hf_cntrl |= DC_DUAL;
		sas_store(DRIVE_CAPABILITY, hf_cntrl);

#ifndef NTVDM	/* prevent floppies showing up in bios data area */
		/*
		 *	Setup the diskette BIOS state according to the
		 *	types of drives installed
		 */
		fl_diskette_setup();

		/*
		 *	If a second drive was discovered, update the
		 *	equipment flag accordingly
		 */

		sas_load(FDD_STATUS+1, &disk_state);
		if (disk_state != 0)
		{
			sas_loadw(EQUIP_FLAG, &equip_flag.all);
			equip_flag.bits.max_diskette = 1;
			sas_storew(EQUIP_FLAG, equip_flag.all);
		}
#endif  /* NTVDM */
	}
#endif // !NEC_98
}

#if defined(NEC_98)

void SetDauaTable IFN0()
{

    DWORD  DriveMask;
    CHAR   Drive = 0;
    CHAR   achRoot[] = "A:\\";
    CHAR   numFlop = 0;
    CHAR   numFdisk = 0;
    CHAR   FloppyUnits = 0;
    CHAR   i;
    CHAR   FlopDevName[] = "\\Device\\Floppy?";
    CHAR   FdiskDevName[] = "\\\\.\\?:";

    /*
    **  initialize DA/UA table
    **/
    for( i=0; i<MAX_FLOPPY; i++)
    {
        DauaTable[i].Daua = 0x00;
        DauaTable[i].FloppyNum = DauaTable[i].FdiskNum = (UINT)~0;
    }

    /*
    **  Get bit mask table of logical drive map
    **/
    DriveMask = GetLogicalDrives();

    while (DriveMask != 0)
    {

        // first, the drive must be valid
        if (DriveMask & 1)
        {
            achRoot[0] = Drive + 'A';

            // second, the drive must be a hard disk(fixed)
            if ( GetDriveType(achRoot) == DRIVE_FIXED )
            {
                // third, the drive must be a FAT
                if( CheckFatSystem(Drive) )
                {
                    DauaTable[Drive].Daua = FDISK_DA + numFdisk;
                    DauaTable[Drive].FdiskNum = numFdisk;
                    /*
                    **  Physicai device name will get actually
                    **  when perform bios command.
                    */
                    FdiskDevName[4] = numFdisk + 'A';
                    strcpy( DauaTable[Drive].DeviceName, FdiskDevName);
                    numFdisk++;
                }
                else if( CheckIfsSystem(Drive) )
                // IFS drive is recognized as Dos Drive too.
                    numFdisk++;
            }
            else if (GetDriveType(achRoot) == DRIVE_REMOVABLE )
            {
                /*
                **      Set DA/UA and physical device name to table.
                */
                if(CheckFloppy(Drive))
                {
                        DauaTable[Drive].Daua = FLOPPY_DA + numFlop;
                        DauaTable[Drive].FloppyNum = FloppyUnits;
                        FlopDevName[14] = FloppyUnits + '0';
                        strcpy( DauaTable[Drive].DeviceName, FlopDevName);
                        FloppyUnits++;
                }
                numFlop++;
            }
        }
        /*
        **      continue to next drive check.
        */
        DriveMask >>= 1;
        Drive++;
    }
}

BOOL CheckFatSystem IFN1( BYTE, drive)
{
    PUNICODE_STRING unicode_string;
    ANSI_STRING ansi_string;
    NTSTATUS status;
    OBJECT_ATTRIBUTES   floppy_obj;
    IO_STATUS_BLOCK io_status_block;
    HANDLE  fd;
    PARTITION_INFORMATION   partition_info;
    CHAR nt_device_name[] = "\\DosDevices\\?:";

    nt_device_name[12] = drive + 'A';
    RtlInitAnsiString( &ansi_string, nt_device_name);

    unicode_string =  &NtCurrentTeb()->StaticUnicodeString;

    status = RtlAnsiStringToUnicodeString(unicode_string,
                                          &ansi_string,
                                          FALSE
                                          );
    if ( !NT_SUCCESS(status) )
        return FALSE;

    InitializeObjectAttributes(
                               &floppy_obj,
                               unicode_string,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );
    // this call will fail if the current user is not
    // the administrator or the volume is locked by other process.
    status = NtOpenFile(
                        &fd,
                        FILE_READ_DATA | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                        &floppy_obj,
                        &io_status_block,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                        );

    if (!NT_SUCCESS(status))
        return FALSE;

    // get partition information to make sure this partition is a FAT
    status = NtDeviceIoControlFile(fd,
                                   0,
                                   NULL,
                                   NULL,
                                   &io_status_block,
                                   IOCTL_DISK_GET_PARTITION_INFO,
                                   NULL,
                                   0,
                                   &partition_info,
                                   sizeof (PARTITION_INFORMATION)
                                   );

    if (!NT_SUCCESS(status)) {
        NtClose(fd);
        return FALSE;
    }

    // check whether file system is FAT.
    if (partition_info.PartitionType != PARTITION_HUGE &&
        partition_info.PartitionType != PARTITION_FAT_16 &&
        partition_info.PartitionType != PARTITION_FAT_12)
       {
       NtClose(fd);
       return FALSE;
    }

    NtClose(fd);
    return TRUE;
}

BOOL CheckIfsSystem IFN1( BYTE, drive)
{
    PUNICODE_STRING unicode_string;
    ANSI_STRING ansi_string;
    NTSTATUS status;
    OBJECT_ATTRIBUTES   floppy_obj;
    IO_STATUS_BLOCK io_status_block;
    HANDLE  fd;
    PARTITION_INFORMATION   partition_info;
    CHAR nt_device_name[] = "\\DosDevices\\?:";

    nt_device_name[12] = drive + 'A';
    RtlInitAnsiString( &ansi_string, nt_device_name);

    unicode_string =  &NtCurrentTeb()->StaticUnicodeString;

    status = RtlAnsiStringToUnicodeString(unicode_string,
                                          &ansi_string,
                                          FALSE
                                          );
    if ( !NT_SUCCESS(status) )
        return FALSE;

    InitializeObjectAttributes(
                               &floppy_obj,
                               unicode_string,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );
    // this call will fail if the current user is not
    // the administrator or the volume is locked by other process.
    status = NtOpenFile(
                        &fd,
                        FILE_READ_DATA | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                        &floppy_obj,
                        &io_status_block,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                        );

    if (!NT_SUCCESS(status))
        return FALSE;

    // get partition information to make sure this partition is a FAT
    status = NtDeviceIoControlFile(fd,
                                   0,
                                   NULL,
                                   NULL,
                                   &io_status_block,
                                   IOCTL_DISK_GET_PARTITION_INFO,
                                   NULL,
                                   0,
                                   &partition_info,
                                   sizeof (PARTITION_INFORMATION)
                                   );

    if (!NT_SUCCESS(status)) {
        NtClose(fd);
        return FALSE;
    }

    // check whether file system is IFS.
    if (partition_info.PartitionType != PARTITION_IFS )
    {
       NtClose(fd);
       return FALSE;
    }

    NtClose(fd);
    return TRUE;
}

BOOL CheckFloppy IFN1( BYTE, drive)
{
        HANDLE  fd;
        DISK_GEOMETRY   disk_geometry[20];
        ULONG   media_types;
        CHAR DeviceName[] = "\\\\.\\A:";
        NTSTATUS    status;
        IO_STATUS_BLOCK io_status_block;

        if((fd = DosDriveOpen(drive)) == NULL)
                return FALSE;

        status = NtDeviceIoControlFile(fd,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &io_status_block,
                                       IOCTL_DISK_GET_MEDIA_TYPES,
                                       NULL,
                                       0L,
                                       (PVOID)&disk_geometry,
                                       sizeof(disk_geometry)
                                       );
        if (!NT_SUCCESS(status))
        {
            NtClose(fd);
            return FALSE;
        }
        NtClose(fd);

        media_types = io_status_block.Information / sizeof(DISK_GEOMETRY);

        for (; media_types != 0; media_types--)
        {
                switch (disk_geometry[media_types - 1].MediaType)
                {
                        case Unknown:
                        case RemovableMedia:
                        case FixedMedia:
                        case F3_128Mb_512:
                                return FALSE;
                        default:
                                continue;
                                break;
                }
        }
        return TRUE;
}

int ConvToPhysical IFN2( UINT, daua, UINT, base )
{
        int drive = 0;
        int i;

        for( i=0; i<MAX_FLOPPY; i++)
        {
                /*
                **      first, check whether drive type is validate
                */
                if( (DauaTable[i].Daua & 0xf0) == (UCHAR)base )
                {
                        /*
                        **      second, check unit address
                        */
                        if( (DauaTable[i].Daua & 0x0f) == ((UCHAR)daua & 0x0f) )
                                break;
                        drive++;
                }
        }

        /*
        **      target is found ?
        */
        if( i != MAX_FLOPPY )
                return drive;
        else
                return MAX_FLOPPY+1;

}

int ConvToLogical IFN1( UINT, daua )
{
        UINT BaseDa;
        int i;

        if( daua & MEDIA_IS_FLOPPY )
                BaseDa = FLOPPY_DA;
        else
                BaseDa = FDISK_DA;

        for( i=0; i<MAX_FLOPPY; i++)
        {
                if( ((DauaTable[i].Daua & 0xf0) == (UCHAR)BaseDa) &&
                        ((DauaTable[i].Daua & 0x0f) == ((UCHAR)daua & 0x0f)) )
                        break;
        }
        return i;
}

LOCAL HANDLE DosDriveOpen IFN1(BYTE, drive)
{

    CHAR NtDeviceName[] = "\\DosDevices\\A:";
    PUNICODE_STRING Unicode;
    ANSI_STRING DeviceNameA;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES   FloppyObj;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE  fd;

    NtDeviceName[12] += drive;

    RtlInitAnsiString( &DeviceNameA, NtDeviceName);

    Unicode = &NtCurrentTeb()->StaticUnicodeString;

    Status = RtlAnsiStringToUnicodeString(Unicode,
                                          &DeviceNameA,
                                          FALSE
                                          );
    if ( !NT_SUCCESS(Status) )
        return NULL;


    InitializeObjectAttributes(
                               &FloppyObj,
                               Unicode,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );
    Status = NtOpenFile(
                        &fd,
                        (ACCESS_MASK) FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                        &FloppyObj,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE
                        );

    if (!NT_SUCCESS(Status))
        return NULL;
    else
        return fd;

}

void    SetDiskBiosCarryFlag IFN1( UINT, flag)
{
        word flag_reg;

        if( flag == 0 )
        {
                sas_loadw(effective_addr(getSS(), getSP()) + 4, &flag_reg);
                sas_storew(effective_addr(getSS(), getSP()) + 4, (word)(flag_reg & ~FLG_CARRY));
        }
        else
        {
                sas_loadw(effective_addr(getSS(), getSP()) + 4, &flag_reg);
                sas_storew(effective_addr(getSS(), getSP()) + 4, (word)(flag_reg | FLG_CARRY));
        }

}
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\disks\gfi_ibm.c ===
#include "insignia.h"
#include "host_def.h"
#ifdef SLAVEPC

/* max size of packet with headers and trailers */
#define MEGAPKTPLUS 1040

/*
 * VPC-XT Revision 1.0
 *
 * Title	: Client Remote Procedure Call Library for FDC, FDD
 *
 * Description	: Interface to RS232 link to slave IBM PC. Packages
 *		  up diskette requests, calls the remote procedure 
 *		  on the PC, and returns the results.
 *
 * Author	: Jerry Kramskoy
 *
 * Notes	: 
 */

/* from gfi_sflop.c */
extern int megapkt;

#include <stdio.h>
#include TypesH

#include "xt.h"
#include "config.h"
#include "gfi.h"
#include "gfisflop.h"
#include "host.h"
#include "error.h"
#include "trace.h"
#include "fla.h"
#include "debug.h"

#ifdef SEGMENTATION
/*
 * The following #define specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SLAVE_FLOPPY.seg"
#endif

/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */
#ifdef SCCSID
static char SccsID[]="@(#)gfi_IBM.c	1.9 8/10/92 Copyright Insignia Solutions Ltd.";
#endif

/*
 * ============================================================================
 * External functions 
 * ============================================================================
 */

/*
** Set the diskete data rate.
** 2 send paramaters: Command ID and data rate.
** 1 result parameter: Command ID.
*/
datarate( drate, status )
unsigned char drate;
int *status;
{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

	*status = LINERR;
	cmd_pkt[0] = DATARATE;
	cmd_pkt[1] = drate;
	if (!host_rpc_action(2, cmd_pkt, &res_len, res_pkt))
		if (res_len == 1 && res_pkt[0] == DATARATE)
			*status = FDCSUCCESS;
	return(0);
}
/*
** Get the drive type.
** 1 send paramater: Command ID.
** 2 result parameters: Command ID and disk type.
*/
drivetype( drive, dtype, status )
int drive;
unsigned char *dtype;
int *status;
{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

	*status = LINERR;
	cmd_pkt[0] = DRIVETYPE;
	cmd_pkt[1] = (unsigned char)drive;
	if (!host_rpc_action(2, cmd_pkt, &res_len, res_pkt))
		if (res_len == 2 && res_pkt[0] == DRIVETYPE){
			*status = FDCSUCCESS;
			*dtype = res_pkt[1];
		}
	return(0);
}
/*
** Get the diskette change status.
** 1 send paramater: Command ID.
** 2 result parameters: Command ID and changed.
*/
diskchange( drive, changed, status )
int drive, *changed, *status;
{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

	*status = LINERR;
	cmd_pkt[0] = DISKCHANGE;
	cmd_pkt[1] = (unsigned char)drive;
	if (!host_rpc_action(2, cmd_pkt, &res_len, res_pkt))
		if (res_len == 2 && res_pkt[0] == DISKCHANGE){
			*status = FDCSUCCESS;
			*changed = (int) res_pkt[1];
		}
	return(0);
}

	clrintflag(status)
	int *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

	   *status = LINERR;
	   cmd_pkt[0] = CLRINTFLAG;
	   if (!host_rpc_action(1, cmd_pkt, &res_len, res_pkt))
	       if (res_len == 1 && res_pkt[0] == CLRINTFLAG)
	           *status = FDCSUCCESS;
	   return(0);
	}




	login(status)
	int *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

	   *status = LINERR;
	   cmd_pkt[0] = LOGIN;
	   if (!host_rpc_reset())
	       if (!host_rpc_action(1, cmd_pkt, &res_len, res_pkt))
	           if (res_len == 1 && res_pkt[0] == LOGIN)
		       *status = FDCSUCCESS;
	   return(0);
	}



	logout(status)
	int *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

	   cmd_pkt[0] = LOGOUT;
	   *status = LINERR;
	   if (!host_rpc_action(1, cmd_pkt, &res_len, res_pkt))
	       if (res_len == 1 && res_pkt[0] == LOGOUT)
		   *status = FDCSUCCESS;
	   return(0);
	}





	wt_dma_controller(ndma, dirn, status)
	int ndma, dirn, *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len, err;
	unsigned char *pkt_ptr;
	   unsigned short lndma;
	   err = 1;
	   if (ndma >= 0 && ndma <= 0xffff)
	   {
	       err = 0;
	       *status = LINERR;
	       lndma = (unsigned short) ndma;
	       pkt_ptr = (unsigned char *) &lndma;
	       cmd_pkt[0] = WTDMA;
#ifdef	BIGEND
	       /* Bigendian e.g. mc68000 */
	       cmd_pkt[1] = *pkt_ptr;
	       cmd_pkt[2] = *(pkt_ptr+1);
#else
	       /* Little endian e.g. VAX */
	       cmd_pkt[1] = *(pkt_ptr+1);
	       cmd_pkt[2] = *pkt_ptr;
#endif
	       cmd_pkt[3] = (unsigned char) dirn;
	       if (!host_rpc_action(4, cmd_pkt, &res_len, res_pkt))
	           if (res_len == 1 && res_pkt[0] == WTDMA)
		       *status = FDCSUCCESS;
	   }
	   return(err);
	}





	wt_digital_output_register(dorbyte, block, status)
	unsigned char dorbyte;
	int block, *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

	   *status = LINERR;
	   cmd_pkt[0] = WTDOR;
	   cmd_pkt[1] = dorbyte;
	   cmd_pkt[2] = (unsigned char) block;
	   if (!host_rpc_action(3, cmd_pkt, &res_len, res_pkt))
	       if (res_len == 2 && res_pkt[0] == WTDOR)
		   *status = (int) res_pkt[1];
	   return(0);
	}





	test_interrupt(intstate, status)
	int *intstate, *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

	   *status = LINERR;
	   cmd_pkt[0] = TESTINT;
	   if (!host_rpc_action(1, cmd_pkt, &res_len, res_pkt))
	       if (res_len == 2 && res_pkt[0] == TESTINT)
		   {
		       *intstate = (int) res_pkt[1];
		       *status = FDCSUCCESS;
		   }
	   return(0);
	}


	wt_floppy_disk_controller(ncom, command, block, delay, status)
	unsigned char *command;
	int ncom, block, *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len, err;
	unsigned char *pkt_ptr;
	int	i;

#ifndef PROD
	if( io_verbose & GFI_VERBOSE )
	{
		fprintf(trace_file,"gfi_IBM: cmd ");
		for( i = 0; i < ncom; i++ )
			fprintf(trace_file,"%x ",*(command + i) );
		fprintf(trace_file,"\n");
	}
#endif
	   err = 1;
	   if (ncom > 0 && ncom < 10)
	   {
	       err = 0;
	       *status = LINERR;
	       cmd_pkt[0] = WTFDC;
	       cmd_pkt[1] = (unsigned char) ncom;
	       cmd_pkt[2] = (unsigned char) block;
	       cmd_pkt[3] = (unsigned char) delay;
	       pkt_ptr = &cmd_pkt[4];
	       for (i=0; i<ncom; i++)
		   *pkt_ptr++ = *command++;
	       if (!host_rpc_action(4+ncom, cmd_pkt, &res_len, res_pkt))
	           if (res_len == 2 && res_pkt[0] == WTFDC)
		       *status = (int) res_pkt[1];
	   }
           return(err);
	}




	rd_floppy_disk_controller(nres, result, status)
	int *nres, *status;
        unsigned char *result;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;
	unsigned char *pkt_ptr;
	int	i;

	    *status = LINERR;
	    cmd_pkt[0] = RDFDC;
	    if (!host_rpc_action(1, cmd_pkt, &res_len, res_pkt))
	        if (res_len >= 3 && res_pkt[0] == RDFDC)
		{
		    *nres = res_pkt[2];
		    if (*nres>=0 && *nres<8)
		    {
		        *status = res_pkt[1];
		        pkt_ptr = &res_pkt[3];
		        for (i=0; i< *nres; i++)
			    *result++ = *pkt_ptr++;
		    }
		}
#ifndef PROD
	if( io_verbose & GFI_VERBOSE )
	{
		fprintf(trace_file,"gfi_IBM: res ");
		for( i = 0; i < *nres; i++ )
			fprintf(trace_file,"%x ",*(result - *nres + i) );
		fprintf(trace_file,"\n");

	}
#endif
	    return(0);
	}






static unsigned char *q;  /* spare ptr */

	wt_disk_buffer(ndwt, diskdata, ioff, status)
	unsigned char *diskdata;
	int ndwt, ioff, *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len, err;
	unsigned char *pkt_ptr;
	int	i;

	   unsigned short lioff, nndwt;
	   err = 1;
	   if (ndwt <= megapkt)
	   {
	       err = 0;
	       *status = LINERR;
	       cmd_pkt[0] = WTDISKB;

		nndwt = (unsigned short) ndwt;
                q = (unsigned char *) &nndwt;

	       lioff = (unsigned short) ioff;
	       pkt_ptr = (unsigned char *) &lioff;
#ifdef	BIGEND
	       /* Bigendian e.g. mc68000 */
                cmd_pkt[1] = *q++;
                cmd_pkt[2] = *q;
                cmd_pkt[3] = *pkt_ptr++;
                cmd_pkt[4] = *pkt_ptr;
#else
	       /* Little endian e.g. VAX */
                cmd_pkt[1] = *(q+1);
                cmd_pkt[2] = *q;
                cmd_pkt[3] = *(pkt_ptr+1);
                cmd_pkt[4] = *pkt_ptr;
#endif
	       pkt_ptr = &cmd_pkt[5];
	       for (i=0; i<ndwt; i++)
		   *pkt_ptr++ = *diskdata++;

	       if (!host_rpc_action(5+ndwt, cmd_pkt, &res_len, res_pkt))
	           if (res_len == 1 && res_pkt[0] == WTDISKB)
		       *status = FDCSUCCESS;
	   }
           return(err);
	}






	rd_disk_buffer(ndrd, diskdata, ioff, status)
	unsigned char *diskdata;
	int ndrd, ioff, *status;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;
	unsigned char *pkt_ptr;
	int	i;
	    unsigned short lioff, nndrd;
	    *status = LINERR;
	    cmd_pkt[0] = RDDISKB;

	    nndrd = (unsigned short) ndrd;
            q = (unsigned char *) &nndrd;
	    lioff = (unsigned short) ioff;
	    pkt_ptr = (unsigned char *) &lioff;
#ifdef	BIGEND
	    /* Bigendian e.g. mc68000 */
        cmd_pkt[1] = *q++;
        cmd_pkt[2] = *q;
        cmd_pkt[3] = *pkt_ptr++;
        cmd_pkt[4] = *pkt_ptr;
#else
       /* Little endian e.g. VAX */
        cmd_pkt[1] = *(q+1);
        cmd_pkt[2] = *q;
        cmd_pkt[3] = *(pkt_ptr+1);
        cmd_pkt[4] = *pkt_ptr;
#endif
	    if (!host_rpc_action(5, cmd_pkt, &res_len, res_pkt))
            {
	        if (res_len == ndrd+1 && res_pkt[0] == RDDISKB)
		{
	            *status = FDCSUCCESS;
	    	    pkt_ptr = &res_pkt[1];
	    	    for (i=0; i<ndrd; i++)
		        *diskdata++ = *pkt_ptr++;
		}
		else
		{
                    always_trace1( "host_rpc_action():BAD LENGTH:%x", res_len );
		}
            }
            else
            {
                always_trace0( "host_rpc_action():FAILED" );
            }
           return(0);
	}




	printPC(string, status)
	int *status;
	char *string;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len, err;
	int	i;

	    err = 1;
	    if ((i = strlen(string)) <= 100)
	    {
		err = 0;
                *status = LINERR;
		cmd_pkt[0] = PRINTSTRING;
		cmd_pkt[1] = (unsigned char) i;
		strcpy(&cmd_pkt[2], string);
		if (!host_rpc_action(3+i, cmd_pkt, &res_len, res_pkt))
		    if (res_len == 1 && res_pkt[0] == PRINTSTRING)
			*status = FDCSUCCESS;
	    }
	    return(err);
	}





	flagPC(nflags, flags, status)
	int nflags, *status;
	unsigned char *flags;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len, err;
	unsigned char *pkt_ptr;
	int	i;

	    err = 1;
	    if (nflags > 0 && nflags <= MAXFLAGS)
	    {
		err = 0;
		*status = LINERR;
		cmd_pkt[0] = IBMFLAGS;
		cmd_pkt[1] = (unsigned char) nflags;
		pkt_ptr = &cmd_pkt[2];
	        for (i=0; i<nflags; i++)
		    *pkt_ptr++ = *flags++;
		if (!host_rpc_action(2+nflags, cmd_pkt, &res_len, res_pkt))
		    if (res_len == 1 && res_pkt[0] == IBMFLAGS)
			*status = FDCSUCCESS;
	    }
	}




	sflagPC(flagindx, mask, status)
	int *status;
	unsigned char flagindx, mask;
	{
	unsigned char res_pkt[MEGAPKTPLUS];
	unsigned char cmd_pkt[MEGAPKTPLUS];
	int res_len;

		*status = LINERR;
		cmd_pkt[0] = SIBMFLAG;
		cmd_pkt[1] = flagindx;
		cmd_pkt[2] = mask;
		if (!host_rpc_action(3, cmd_pkt, &res_len, res_pkt))
		    if (res_len == 1 && res_pkt[0] == SIBMFLAG)
			*status = FDCSUCCESS;
	}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\disks\gfi_test.c ===
#include "insignia.h"
#include "host_def.h"
#ifndef PROD
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Generic Floppy Interface Test Module
 *
 * Description	: This module acts as a pseudo GFI diskette server, simply
 *		  tracing out the calls made and returning success.  
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 *
 * Mods: (r3.2) : The system directory /usr/include/sys is not available
 *                on a Mac running Finder and MPW. Bracket references to
 *                such include files by "#ifdef macintosh <Mac file> #else
 *                <Unix file> #endif".
 */

#ifdef SCCSID
static char SccsID[]="@(#)gfi_test.c	1.9 08/03/93 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_TEST_FLOPPY.seg"
#endif


/*
 *    O/S include files.
 */
#endif /* not PROD */
#include <stdio.h>
#include TypesH
#ifndef PROD

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "bios.h"
#include "config.h"
#include "ios.h"
#include "trace.h"
#include "fla.h"
#include "gfi.h"
#include "gfitest.h"


/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */

static void print_cmd();

/*
 * ============================================================================
 * External functions
 * ============================================================================
 */


int gfi_test_command(command_block, result_block)
FDC_CMD_BLOCK *command_block;
FDC_RESULT_BLOCK *result_block;
{

    UNUSED(result_block);
	
    fprintf(trace_file, "GFI: Command received - ");
    switch(get_c0_cmd(command_block))
    {
    case FDC_READ_TRACK   	: fprintf(trace_file, "Read a track\n");
				  print_cmd(command_block);
				  break;

    case FDC_SPECIFY 		: fprintf(trace_file, "Specify\n");
				  print_cmd(command_block);
				  break;

    case FDC_SENSE_DRIVE_STATUS	: fprintf(trace_file, "Sense Drive Status\n");
				  print_cmd(command_block);
				  break;

    case FDC_WRITE_DATA	    	: fprintf(trace_file, "Write Data\n");
				  print_cmd(command_block);
				  break;

    case FDC_READ_DATA    	: fprintf(trace_file, "Read Data\n");
				  print_cmd(command_block);
				  break;

    case FDC_RECALIBRATE 	: fprintf(trace_file, "Recalibrate\n");
				  print_cmd(command_block);
				  break;

    case FDC_SENSE_INT_STATUS	: fprintf(trace_file, "<Illegal call> Sense Interrupt Status\n");
				  break;

    case FDC_WRITE_DELETED_DATA : fprintf(trace_file, "Write Deleted Data\n");
				  print_cmd(command_block);
				  break;

    case FDC_READ_ID    	: fprintf(trace_file, "Read ID\n");
				  print_cmd(command_block);
				  break;

    case FDC_READ_DELETED_DATA  : fprintf(trace_file, "Read Deleted Data\n");
				  print_cmd(command_block);
				  break;

    case FDC_FORMAT_TRACK    	: fprintf(trace_file, "Format a track\n");
				  print_cmd(command_block);
				  break;

    case FDC_SEEK    		: fprintf(trace_file, "Seek\n");
				  print_cmd(command_block);
				  break;

    case FDC_SCAN_EQUAL		: fprintf(trace_file, "Scan Equal\n");
				  print_cmd(command_block);
				  break;

    case FDC_SCAN_LOW_OR_EQUAL  : fprintf(trace_file, "Scan Low or Equal\n");
				  print_cmd(command_block);
				  break;

    case FDC_SCAN_HIGH_OR_EQUAL : fprintf(trace_file, "Scan High or Equal\n");
				  print_cmd(command_block);
				  break;

    default			: fprintf(trace_file, "Unknown command %x\n", get_c0_cmd(command_block));
				  break;
    }

    return(SUCCESS);
}


int gfi_test_drive_on(drive)
int drive;
{
    fprintf(trace_file, "GFI: Drive on command - drive %x\n", drive);

    return(SUCCESS);
}

int gfi_test_drive_off(drive)
int drive;
{
    fprintf(trace_file, "GFI: Drive off command - drive %x\n", drive);

    return(SUCCESS);
}

int gfi_test_high(drive)
int drive;
{
    fprintf(trace_file, "GFI: Set high density command - drive %x\n", drive);

    return(SUCCESS);
}

int gfi_test_drive_type(drive)
int drive;
{
    fprintf(trace_file, "GFI: Drive type command - drive %x\n", drive);

    return(GFI_DRIVE_TYPE_360);
}

int gfi_test_change(drive)
int drive;
{
    fprintf(trace_file, "GFI: Disk changed command - drive %x\n", drive);

    return(TRUE);
}

int gfi_test_reset(result_block)
FDC_RESULT_BLOCK *result_block;
{
    UNUSED(result_block);
	
	fprintf(trace_file, "GFI: Reset command\n");

    return(SUCCESS);
}


/*
 * ============================================================================
 * Internal functions
 * ============================================================================
 */

static void print_cmd(cmd_block)
FDC_CMD_BLOCK *cmd_block;
{
    switch(gfi_fdc_description[get_type_cmd(cmd_block)].cmd_class)
    {
    case 0 : fprintf(trace_file, "MT: %x    MFM: %x    Skip: %x    Head: %x    Drive: %x\n",
		    get_c0_MT(cmd_block), get_c0_MFM(cmd_block), 
		    get_c0_skip(cmd_block), 
		    get_c0_head(cmd_block), get_c0_drive(cmd_block));
	     fprintf(trace_file, "Cyl: %x   Hd: %x     Sec: %x     N: %x       EOT: %x     GPL: %x    DTL: %x\n",
		    get_c0_cyl(cmd_block), get_c0_hd(cmd_block), 
		    get_c0_sector(cmd_block), get_c0_N(cmd_block),
		    get_c0_EOT(cmd_block), get_c0_GPL(cmd_block), 
		    get_c0_DTL(cmd_block));
	     break;

    case 1 : fprintf(trace_file, "MT: %x    MFM: %x    Head: %x    Drive: %x\n",
		    get_c1_MT(cmd_block), get_c1_MFM(cmd_block), 
		    get_c1_head(cmd_block), get_c1_drive(cmd_block));
	     fprintf(trace_file, "Cyl: %x   Hd: %x     Sec: %x     N: %x       EOT: %x     GPL: %x    DTL: %x\n",
		    get_c1_cyl(cmd_block), get_c1_hd(cmd_block),
		    get_c1_sector(cmd_block), get_c1_N(cmd_block), 
		    get_c1_EOT(cmd_block), get_c1_GPL(cmd_block),
		    get_c1_DTL(cmd_block));
	     break;

    case 2 : fprintf(trace_file, "MFM: %x   Head: %x    Drive: %x\n",
		    get_c2_MFM(cmd_block), get_c2_head(cmd_block),
		    get_c2_drive(cmd_block));
	     fprintf(trace_file, "Cyl: %x   Hd: %x     Sec: %x     N: %x       EOT: %x     GPL: %x    DTL: %x\n",
		    get_c2_cyl(cmd_block), get_c2_hd(cmd_block),
		    get_c2_sector(cmd_block), get_c2_N(cmd_block),
		    get_c2_EOT(cmd_block), get_c2_GPL(cmd_block),
		    get_c2_DTL(cmd_block));
	     break;

    case 3 : fprintf(trace_file, "MFM: %x   Head: %x    Drive: %x\n",
		    get_c3_MFM(cmd_block), get_c3_head(cmd_block),
		    get_c3_drive(cmd_block));
	     fprintf(trace_file, "N: %x     SC: %x      GPL: %x    Fill: %x\n",
		    get_c3_N(cmd_block), get_c3_SC(cmd_block),
		    get_c3_GPL(cmd_block), get_c3_filler(cmd_block));
	     break;

    case 4 : fprintf(trace_file, "MFM: %x   Head: %x    Drive: %x\n",
		    get_c4_MFM(cmd_block), get_c4_head(cmd_block),
		    get_c4_drive(cmd_block));
	     break;

    case 5 : fprintf(trace_file, "Drive: %x\n", get_c5_drive(cmd_block));
	     break;

    case 6 : fprintf(trace_file, "SRT: %x   HUT: %x     HLT: %x     ND: %x\n",
		    get_c6_SRT(cmd_block), get_c6_HUT(cmd_block),
		    get_c6_HLT(cmd_block), get_c6_ND(cmd_block));
	     break;

    case 7 : fprintf(trace_file, "Head: %x    Drive: %x\n",
		    get_c7_head(cmd_block), get_c7_drive(cmd_block));
	     break;

    case 8 : fprintf(trace_file, "Head: %x    Drive: %x    New cyl: %x\n",
		    get_c8_head(cmd_block), get_c8_drive(cmd_block),
		    get_c8_new_cyl(cmd_block));
	     break;

    }
}
#endif /* nPROD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\disks\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=disks
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=$(SOFTPC_TREE)\host\inc;$(SOFTPC_TREE)\base\inc

SOURCES=floppy.c      \
    ..\floppy_i.c    \
    ..\diskbios.c    \
    ..\fdisk.c       \
    ..\fla.c \
    ..\gfi.c \
    ..\gfi_ibm.c     \
    ..\gfi_mpty.c    \
    ..\gfi_sflp.c    \
    ..\gfi_test.c

!INCLUDE $(SOFTPC_TREE)\obj.vdm\CDEFINE.INC
!INCLUDE $(SOFTPC_TREE)\base\condincl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\disks\gfi_sflp.c ===
#include "insignia.h"
#include "host_def.h"
/*[
	Name:		gfi_sflop.c
	Derived From:	2.0 gfi_sflop.c
	Author:		Jerry Kramskoy
	Created On:	Unknown
	Sccs ID:	@(#)gfi_sflop.c	1.16 08/14/92
	Purpose:
		Interface between FLA and the IBM PC. The PC acts as a server
		for remote procedure calls from the base product to access
		the 8272A controller.
	Notes:	Invalid FDC commands should be trapped by FLA

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/
#ifdef SLAVEPC

/* bigger than max pkt so as to accom extra header chars*/
#define MEGAPKTPLUS 1040

USHORT megapkt = 512;        /* packet size should be in range 120 < mega < 1024 */

#include <stdio.h>
#include TypesH
#include TimeH

#include "xt.h"
#include "bios.h"
#include "timeval.h"
#include "config.h"
#include "timer.h"
#include "dma.h"
#include "gfi.h"
#include "gfisflop.h"
#include "host.h"
#include "error.h"
#include "trace.h"
#include "fla.h"
#include "debug.h"

#ifdef SEGMENTATION
/*
 * The following #define specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SLAVE_FLOPPY.seg"
#endif

/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */
#undef  NO

#define DMA_DISKETTE_CHANNEL	2
#define NO	                2
#define MRD                     1
#define MWT	                0


/*
 * FDC command definitions
 * =======================
 */

typedef struct {
		int comid;		/* FDC command numbers */
		int dma;		/* see below */
   		int intstatus;		/* see below */
   		int delay;		/* delay needed */
		int n_resblk;		/* number of result bytes */
 		int n_comblk;		/* number of command bytes */
		} FDC_CMD_INFO;

/*
 * dma flag
 *     = NO  ... no dma for this command
 *     = MRD ... dma read (mem -> FDC)
 *     = MWT ... dma write (FDC -> mem)
 */

/* interrupt status
 *    = 0 ... command does not generate an interrupt.
 *    = 1 ... command does generate interrupt which is cleared by 
 *	      reading the FDC
 *    = 2 ... command generates an interrupt ... a sense interrupt command
 *	      must be issued to get the FDC results and re-enable further
 *	      command input to the FDC
 */

FDC_CMD_INFO fdc_cmd_info[] = {
/*
 *	  com_id	dma	intstatus	n_resblk
 *	  				delay		n_comblk
 */
	{ RDDATA,	MWT,	1,	0,	7,	9	},
	{ RDDELDATA,	MWT,	1,	0,	7,	9	},
	{ WTDATA,	MRD,	1,	0,	7,	9	},
	{ WTDELDATA,	MRD,	1,	0,	7,	9	},
	{ RDTRACK,	MWT,	1,	0,	7,	9	},
	{ RDID,		NO,	1,	0,	7,	2	},
	{ FMTTRACK,	MRD,	1,	0,	7,	6	},
	{ SCANEQ,	MRD,	1,	0,	7,	9	},
	{ SCANLE,	MRD,	1,	0,	7,	9	},
	{ SCANHE,	MRD,	1,	0,	7,	9	},
	{ RECAL,	NO,	2,	0,	2,	2	},
	{ SENSINT,	NO,	0,	0,	2,	1	},
	{ SPECIFY,	NO,	0,	1,	0,	3	},
	{ SENSDRIVE,	NO,	0,	0,	1,	2	},
	{ SEEK,		NO,	2,	0,	2,	3	},
};

#define	MAX_FDC_CMD	sizeof(fdc_cmd_info)/sizeof(fdc_cmd_info[0])

LOCAL UTINY sensint = 8;
LOCAL half_word channel = DMA_DISKETTE_CHANNEL;

LOCAL SHORT gfi_slave_drive_off IPT1( UTINY, drive );
LOCAL SHORT gfi_slave_drive_on IPT1( UTINY, drive );
LOCAL SHORT gfi_slave_change_line IPT1( UTINY, drive );
LOCAL SHORT gfi_slave_drive_type IPT1( UTINY, drive );
LOCAL SHORT gfi_slave_high IPT2( UTINY, drive, half_word, n);
LOCAL SHORT gfi_slave_reset IPT2( FDC_RESULT_BLOCK *, res, UTINY, drive );
LOCAL SHORT gfi_slave_command IPT2( FDC_CMD_BLOCK *, ip, FDC_RESULT_BLOCK *, res);
LOCAL wt_diskdata IPT2(unsigned int,n,int *,status);
LOCAL void cominfo IPT2(FDC_CMD_BLOCK *,cmd_block,FDC_CMD_INFO *,cmd_info);

LOCAL BOOL slave_opened;
LOCAL UTINY slave_type[MAX_DISKETTES];
LOCAL SHORT old_a_type, old_b_type;

/*
 * ============================================================================
 * External functions 
 * ============================================================================
 */
GLOBAL void gfi_slave_change IFN2(UTINY, hostID, BOOL, apply)
{
	int status;

	UNUSED(hostID);
	
	if (apply && slave_opened)
	{
		logout(&status);
		host_runtime_set(C_FLOPPY_SERVER, GFI_REAL_DISKETTE_SERVER);
		host_rpc_close();
		slave_opened = FALSE;
	}
}


GLOBAL SHORT gfi_slave_active IFN3(UTINY, hostID, BOOL, active, CHAR *, err)
{
	GFI_FUNCTION_ENTRY *tabP;
	int status;
	SHORT result;
	UTINY i;
	BOOL slaveServer;

	UNUSED(hostID);
	UNUSED(err);
	
	slaveServer = (host_runtime_inquire(C_FLOPPY_SERVER)==GFI_SLAVE_SERVER);
	if (active)
	{
		CHAR *slaveName = host_expand_environment_vars((CHAR *)
			config_inquire(C_SLAVEPC_DEVICE, NULL));
			
		if (!*slaveName)
		{
			if (slaveServer)
			{
				gfi_empty_active(hostID,TRUE,err);
			}
			config_set_active(C_SLAVEPC_DEVICE, FALSE);
			return C_CONFIG_OP_OK;
		}
		
		/*
		 * When SoftPC has already started talking to SlavePC just
		 * return that the open operation is ok, no need to attempt
		 * to re-open the link.  Maintain the flag telling us
		 * whether SlavePC is attached.
		 */
		if (!slave_opened)
		{
			if ( result = host_rpc_open(slaveName) )
				return result;		/* failed to open */
			else
			{
				if (!host_rpc_reset())
				{
					login(&status);
					if (status != SUCCESS)
					{
						host_rpc_close();
						return EG_SLAVEPC_NO_LOGIN;
					}
				}
				else
				{
					host_rpc_close();
					return EG_SLAVEPC_NO_RESET;
				}
			} 
		}

		slave_opened = TRUE;

		if (!slaveServer)
			return C_CONFIG_OP_OK;

		for ( i = 0; i < MAX_DISKETTES; i ++)
		{
			if (gfi_slave_drive_type(i) == GFI_DRIVE_TYPE_NULL)
				continue;

			tabP = &gfi_function_table[i];
			tabP->command_fn	= gfi_slave_command;
			tabP->drive_on_fn	= gfi_slave_drive_on;
			tabP->drive_off_fn	= gfi_slave_drive_off;
			tabP->reset_fn		= gfi_slave_reset;
			tabP->high_fn		= gfi_slave_high;
			tabP->drive_type_fn	= gfi_slave_drive_type;
			tabP->change_fn		= gfi_slave_change_line;
		}
	}
	else	/* detach the floppy */
	{
		gfi_slave_drive_type(0);
		gfi_slave_drive_type(1);

		if (slave_opened)
		{
			logout(&status);

			status = host_rpc_close();
			slave_opened = FALSE;
		}

		assert0(!status,  "gfi_sfloppy: host_rpc_close() failed\n");

		if (!slaveServer)
			return C_CONFIG_OP_OK;

		for ( i = 0; i < MAX_DISKETTES; i ++)
			gfi_empty_active(C_FLOPPY_A_DEVICE+i,TRUE,err);

		gfi_function_table[0].drive_type_fn = gfi_slave_drive_type;

		if (slave_type[1] != GFI_DRIVE_TYPE_NULL)
			gfi_function_table[1].drive_type_fn =
				gfi_slave_drive_type;
	}

	return C_CONFIG_OP_OK;
}

/****************************** on *****************************
 * purpose
 *	provide interface to slave PC for turning on drive motor
 ***************************************************************
 */
LOCAL SHORT
gfi_slave_drive_on IFN1(UTINY, drive)
{
   int status;
   static unsigned char DRIVE_A_ON = 0x1c;
   static unsigned char DRIVE_B_ON = 0x2d;

   note_trace1( GFI_VERBOSE, "GFI-slavefloppy: DRIVE %x ON", drive );
#ifndef PROD
#endif
   timer_int_enabled = 0;
   if( drive==0 )
       wt_digital_output_register(DRIVE_A_ON, 0, &status);
   else if( drive==1 )
       wt_digital_output_register(DRIVE_B_ON, 0, &status);
   else
       always_trace0( "gfi_slave_drive_on(): ERROR: bad drive parameter" );
   timer_int_enabled = 1;
   return(SUCCESS);
}





/****************************** off *****************************
 * purpose
 *	provide interface to slave PC for turning off drive motor
 ****************************************************************
 */
LOCAL SHORT
gfi_slave_drive_off IFN1(UTINY, drive)
{
   int status;
   static unsigned char DRIVE_A_OFF = 0xc;
   static unsigned char DRIVE_B_OFF = 0xd;

   note_trace1( GFI_VERBOSE, "GFI-slavefloppy: DRIVE %x OFF", drive );
#ifndef PROD
#endif
   timer_int_enabled = 0;
   if( drive==0 )
       wt_digital_output_register(DRIVE_A_OFF, 0, &status);
   else if( drive==1 )
       wt_digital_output_register(DRIVE_B_OFF, 0, &status);
   else
       always_trace0( "gfi_slave_drive_off(): ERROR: bad drive parameter" );
   timer_int_enabled = 1;
   return(SUCCESS);
}

/***************************** high ****************************
 * purpose
 *	provide interface to slave PC for selecting specified data rate
 ***************************************************************
 */
LOCAL SHORT
gfi_slave_high IFN2(UTINY, drive, half_word, rate)
{
int	status;

	UNUSED(drive);
	
	switch( rate ){
		case 0: datarate( DCR_RATE_500, &status ); break;
		case 1: datarate( DCR_RATE_300, &status ); break;
		case 2: datarate( DCR_RATE_250, &status ); break;
		default:
			always_trace0("ERROR:gfi_slave_high(): bad rate value");
			break;
	}
	if( status != SUCCESS )
		always_trace0( "ERROR: gfi_slave_high()" );
	return(status);
}


/************************** drive type *************************
 * purpose
 *	provide interface to slave PC for returning drive type
 ***************************************************************
 */
LOCAL SHORT
gfi_slave_drive_type IFN1(UTINY, drive)
{
	int	status;
	unsigned char	dtype;

	/*
	 * Return the last drive type if the slave device is
	 * not currently opened.
	 */
	if (!slave_opened)
		return (slave_type[drive]);

	note_trace1( GFI_VERBOSE, "gfi_slave_drive_type(): drive %x", drive );
	drivetype( drive, &dtype, &status );
	note_trace2( GFI_VERBOSE, "dtype=%x status=%x", dtype, status );
#ifndef PROD
	switch( dtype )
	{
		case GFI_DRIVE_TYPE_NULL:
			note_trace0( GFI_VERBOSE, "Bad drive" );
			break;
		case GFI_DRIVE_TYPE_360:
			note_trace0( GFI_VERBOSE, "360k" );
			break;
		case GFI_DRIVE_TYPE_12:
			note_trace0( GFI_VERBOSE, "1.2M" );
			break;
		case GFI_DRIVE_TYPE_720:
			note_trace0( GFI_VERBOSE, "720k" );
			break;
		case GFI_DRIVE_TYPE_144:
			note_trace0( GFI_VERBOSE, "1.44M" );
			break;
		default: always_trace0( "Unrecognised drive value" );
			break;
	}
#endif /* !PROD */

	if ( status != SUCCESS )
		always_trace0( "ERROR: gfi_slave_drive_type()" );

	slave_type[drive] = dtype;
	return dtype;
	/* return(GFI_DRIVE_TYPE_360); */
}

/************************* diskette change *********************
 * purpose
 *	provide interface to slave PC for diskette change notification
 ***************************************************************
 */
LOCAL SHORT
gfi_slave_change_line IFN1(UTINY, drive)
{
	int	status, changed;

	diskchange( drive, &changed, &status );
	note_trace2( GFI_VERBOSE, "drive %x %s",
	             drive, changed ? "CHANGED" : "NOT CHANGED" );
	if( changed!=1 && changed!=0 )
		always_trace1( "ERROR: gfi_slave_change_line(): bad value:%x", changed );
	if( status != SUCCESS )
		always_trace0( "ERROR: gfi_slave_change_line()" );
	return( changed );
}



/****************************** reset *****************************
 * purpose
 *	provide interface to slave PC for resetting the FDC
 ******************************************************************
 */
LOCAL SHORT
gfi_slave_reset IFN2(FDC_RESULT_BLOCK *, r, UTINY, drive)
{
   int status, i;
   static unsigned char DRIVE_RESET = 0x08;
   static unsigned char DRIVE_A_OFF = 0x0c;
   static unsigned char DRIVE_B_OFF = 0x0d;
   static unsigned char RECALIBRATE[] = {7, 0};
   unsigned char res[10];
   unsigned char drive_off;
   int nres;

	note_trace1( GFI_VERBOSE, "GFI-slavefloppy: Reset command drive %x", drive );
#ifndef PROD
#endif
	if( drive==0 )
		drive_off = DRIVE_A_OFF;
	else if( drive==1 )
		drive_off = DRIVE_B_OFF;
	else
		always_trace0( "gfi_slave_reset(): ERROR: bad drive parameter");

   clrintflag(&status);
   if (status != FDCSUCCESS)
       return(status);
   wt_digital_output_register(DRIVE_RESET, 0, &status);
   if (status == FDCSUCCESS)
   {
       timer_int_enabled = 0;
       wt_digital_output_register(drive_off, 1, &status);
       timer_int_enabled = 1;
       if (status == FDCSUCCESS)
       {
           wt_floppy_disk_controller(1,&sensint,0, 0, &status);
	   if (status == FDCSUCCESS)
	   {
	       rd_floppy_disk_controller(&nres, res, &status);
	       if (status == FDCSUCCESS)
	       {
		   for (i=0; i<nres; i++)
		       r[i] = res[i];
#ifndef PROD
#endif
/*    
		   gfi_slave_drive_on();
		   gfi_slave_command(RECALIBRATE, res);
		   gfi_slave_drive_off();
 */
	       }
	       else
		   always_trace1("RESET error 3, status = %x", status);
	   }
	   else
	       always_trace1("RESET error 2, status = %x", status);
       }
       else
	   always_trace1("RESET error 1, status = %x", status);
   }
   else
       always_trace1("RESET error 1, status = %x", status);
}

/*
** A macro to tell us something when something goes wrong
*/
#define failure(i)	always_trace0( "failed" ); return( i );

/**************************** command *****************************
 * purpose
 *	provide interface to slave PC for performing FDC commands
 ******************************************************************
 */

LOCAL SHORT
gfi_slave_command
          IFN2(FDC_CMD_BLOCK *, c, FDC_RESULT_BLOCK *,r)
{
   FDC_CMD_INFO info;
   sys_addr dummy;
   word ndma;
   int err, status, nres;
   unsigned int nXfer;

   err = 0;

   note_trace1( GFI_VERBOSE, "GFI-slavefloppy: Command %x", get_type_cmd(c));
#ifndef PROD
#endif

   cominfo(c,&info);
   if (info.comid == -1)
   {
	failure(LOGICAL);
   }

/*
 * determine how much data is needed for this command
 * in case we are doing DMA or 'pseudo-nonDMA'
 */

   if (!fla_ndma)
   {
   	dma_enquire(channel, &dummy, &ndma);
	nXfer = ndma+1;
   }
   else
   {
	fla_ndma_enquire(&nXfer);
	ndma = nXfer-1;
   }
   note_trace3( GFI_VERBOSE, "Bytes to transfer nXfer=%x ndma=%x mode=%s",
                nXfer, ndma, fla_ndma ? "NON-DMA" : "DMA" );

/*
 * set up the slave PC's disk buffer
 * with any data to be read by the FDC
 */

   if (info.dma == MRD)
       if (wt_diskdata(nXfer,  &status))
       {
	   failure(LOGICAL);
       }
       else
       {
	   if (status != FDCSUCCESS)
           {
	       failure(PROTOCOL);
           }
       }

/*
 * set up the DMA controller for the transfer
 */

   if (info.dma != NO)
       if (wt_dma_controller((unsigned int) ndma, info.dma, &status))
       {
           failure(LOGICAL);
       }
       else
          if (status != FDCSUCCESS)
          {
	      failure(PROTOCOL);
          }


/* 
 * issue the FDC command. Block the slavePC from 
 * returning until an interrupt or timeout
 * (provided the command is meant to interrupt!!)
 */

   clrintflag(&status);
   if (status != FDCSUCCESS)
   {
       failure(PROTOCOL);
   }

   if (wt_floppy_disk_controller(info.n_comblk, c, info.intstatus, 
		info.delay, &status))
   {
       failure(LOGICAL);
   }
   else
       if (status != FDCSUCCESS)
       {
           failure(PROTOCOL);
       }




/*
 * issue a sense interrupt command if required
 */

   if (info.intstatus == 2)
       if (wt_floppy_disk_controller(1, &sensint, 0, 0, &status))
       {
           failure(LOGICAL);
       }
       else
           if (status != FDCSUCCESS)
           {
               failure(PROTOCOL);
           }


/* delay if needed
 */

    if (info.delay)
    {
        timer_int_enabled = 0;
        timer_int_enabled = 1;
    }


/*
 * read the FDC results
 */

   if (info.n_resblk)
       if (rd_floppy_disk_controller(&nres, r, &status))
       {
	   failure(LOGICAL);
       }
       else
	   if (status != FDCSUCCESS)
           {
	       failure(PROTOCOL);
           }
	   else
   	       if (nres != info.n_resblk)
	       {
#ifndef	PROD
		   printf("result block discrepancy !!!\n");
#endif
       		   failure(PROTOCOL);
	       }


/* dump out results 
 */
#ifndef PROD
#endif

/*
 * read back any data from
 * the diskette
 */

   if (info.dma == MWT && !(r[1] & 4))
   {
       if (rd_diskdata(nXfer,  &status))
       {
	   failure(LOGICAL);
       }
       else
	   if (status != FDCSUCCESS)
           {
	       failure(PROTOCOL);
           }
   }


   return(0);
}


/*
 * ============================================================================
 * Internal functions
 * ============================================================================
 */






/******************************* wt_diskdata *********************************
 */
LOCAL wt_diskdata IFN2(unsigned int,n,int *,status)
{
   char diskdata[MEGAPKTPLUS];
   word nbytes, ln;
   int ioff;

   ln = (word) n;
   ioff = 0;
   while (ln > 0)
   {
      nbytes = (ln > megapkt)? megapkt: ln;
      dma_request(channel, diskdata, nbytes);
      if (wt_disk_buffer(nbytes, diskdata, ioff, status))
	  return(1);
      else
    	if (*status != FDCSUCCESS)
	      break;
      ln -= nbytes;
      ioff += nbytes;
   }
   return(0);
}





/******************************* rd_diskdata *********************************
 */
rd_diskdata(n, status)
unsigned int  n;
int *status;

{
   char diskdata[1024];
   word nbytes, ln;
   int ioff;
   int errors=0;

   ln = (word) n;
   ioff = 0;
   note_trace1( GFI_VERBOSE, "Reading 0x%x bytes...", n );
   while (ln > 0)
   {
      nbytes = (ln > megapkt)? megapkt: ln;
      if (rd_disk_buffer(nbytes, diskdata, ioff, status)){
	  return(1);
      }
      dma_request(channel, diskdata, nbytes);
      if (*status != FDCSUCCESS){
          ++errors;
          break;
      }
      ln -= nbytes;
      ioff += nbytes;
   }
#ifndef PROD
   if( errors>0 ){
      note_trace3( GFI_VERBOSE,
                   "Read 0x%x bytes of 0x%x with errors=%d",ioff , n, errors );
   }else
      note_trace1( GFI_VERBOSE, "Read 0x%x bytes OK", ioff );
#endif
   return(0);
}


/****************************** cominfo *************************************
 */

LOCAL void cominfo IFN2(FDC_CMD_BLOCK *,cmd_block,FDC_CMD_INFO *,cmd_info)
{
    int i;

    for (i = 0; i < MAX_FDC_CMD; i++)
	if (fdc_cmd_info[i].comid == get_c0_cmd(cmd_block))
	    break;

    if (i >= MAX_FDC_CMD)
	cmd_info->comid = -1;
    else if (fdc_cmd_info[i].comid == SENSINT)
	cmd_info->comid = -2;
    else
	*cmd_info = fdc_cmd_info[i];
}
#endif /* SLAVEPC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\dos\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=dos
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=$(SOFTPC_TREE)\host\inc;$(SOFTPC_TREE)\base\inc

SOURCES=..\emm_mngr.c

!INCLUDE $(SOFTPC_TREE)\obj.vdm\CDEFINE.INC
!INCLUDE $(SOFTPC_TREE)\base\condincl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\disks\gfi_mpty.c ===
#include "insignia.h"
#include "host_def.h"

/*
 * SoftPC Version 2.0
 *
 * Title	: Generic Floppy Interface Empty Module
 *
 * Description	: This module acts as a pseudo GFI diskette server, in the
 *		  case when the diskette in question does not physically exist
 *		  (eg accessing drive B: on a one drive system).
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 *
 * Mods: (r3.2) : The system directory /usr/include/sys is not available
 *                on a Mac running Finder and MPW. Bracket references to
 *                such include files by "#ifdef macintosh <Mac file> #else
 *                <Unix file> #endif".
 */

#ifdef SCCSID
static char SccsID[]="@(#)gfi_empty.c	1.13 08/03/93 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #define specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_FLOPPY.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "bios.h"
#include "ios.h"
#include "trace.h"
#include "config.h"
#include "fla.h"
#include "gfi.h"
#include "trace.h"
#include "debug.h"


/* Routines called via vector table. These are all local now;
** The prototype typedefs are defined in gfi.h which is now th. only
** base floppy header file needed.        GM.
*/

LOCAL SHORT gfi_empty_drive_on
	IPT1( UTINY, drive );
LOCAL SHORT gfi_empty_drive_off
	IPT1( UTINY, drive );
LOCAL SHORT gfi_empty_change
	IPT1( UTINY, drive );
LOCAL SHORT gfi_empty_drive_type
	IPT1( UTINY, drive );
LOCAL SHORT gfi_empty_high
	IPT2( UTINY, drive, half_word, n);
LOCAL SHORT gfi_empty_reset
	IPT2( FDC_RESULT_BLOCK *, res, UTINY, drive );
LOCAL SHORT gfi_empty_command
	IPT2( FDC_CMD_BLOCK *, ip, FDC_RESULT_BLOCK *, res );
LOCAL VOID gfi_empty_init
	IPT1( UTINY, drive );


/*
 * ============================================================================
 * External functions
 * ============================================================================
 */


/********************************************************/

/* Turn the empty floppy on and off. This forms an orthogonal interface
** with the host/generic floppy module which also has a XXX_active() func.
** 'Activating' the empty floppy means de-activating the real/slave one,
** and vice versa.
**
** NB: This is for SoftPC (gfi); the actual closing/opening must still be
** done in your floppy code! Also note that deactivating the empty floppy
** means activating the host one, but this is never done like that.
**                               GM.
*/

GLOBAL SHORT
gfi_empty_active IFN3(UTINY, hostID, BOOL, active, CHAR *, err)
{
UTINY drive = hostID - C_FLOPPY_A_DEVICE;

UNUSED( active );
UNUSED( err );

        gfi_empty_init(drive);
        return(C_CONFIG_OP_OK);
}

/********************************************************/


LOCAL VOID gfi_empty_init IFN1(UTINY,drive)
{
    /*
     * Initialise the floppy on the required drive:
     *
     *      0  - Drive A
     *      1  - Drive B
     */

    gfi_function_table[drive].command_fn	= gfi_empty_command;
    gfi_function_table[drive].drive_on_fn	= gfi_empty_drive_on;
    gfi_function_table[drive].drive_off_fn	= gfi_empty_drive_off;
    gfi_function_table[drive].reset_fn		= gfi_empty_reset;
    gfi_function_table[drive].high_fn		= gfi_empty_high;
    gfi_function_table[drive].drive_type_fn	= gfi_empty_drive_type;
    gfi_function_table[drive].change_fn		= gfi_empty_change;
}

/********************************************************/

LOCAL SHORT
gfi_empty_command
	IFN2(FDC_CMD_BLOCK *, command_block, FDC_RESULT_BLOCK *,result_block)
{
   int ret_stat = FAILURE;
   half_word D;

   /* Clear result status registers */
   put_r0_ST0 (result_block, 0);
   put_r0_ST1 (result_block, 0);
   put_r0_ST2 (result_block, 0);

   switch (get_type_cmd (command_block))
      {
   case FDC_READ_DATA:
#ifndef	PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf (trace_file, "\tGFI-empty: Read Data Command \n");
#endif
      break;

   case FDC_WRITE_DATA:
#ifndef	PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf (trace_file,"\tGFI-empty: Write Data Command\n");	
#endif
      break;

   case FDC_READ_TRACK:
#ifndef	PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf(trace_file,"\tGFI-empty: Read Track Command \n");
#endif
      break;

   case FDC_SPECIFY:
#ifndef	PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf(trace_file, "\tGFI-empty: Specify command\n");
#endif
      break;

   case FDC_READ_ID:
#ifndef PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf(trace_file, "\tGFI-empty: read id command\n");
#endif
      break;

   case FDC_RECALIBRATE:
#ifndef	PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf (trace_file, "\tGFI-empty: Recalibrate command\n");
#endif
      /* Controller tries 77 pulses to get drive to head 0,
	 but fails, so we set Equipment Check */
      D = get_c5_drive(command_block);
      put_r1_ST0_unit(result_block, D);
      put_r1_ST0_equipment(result_block, 1);
      put_r1_ST0_seek_end(result_block, 1);
      put_r1_ST0_int_code(result_block, 1);
      ret_stat = SUCCESS;
      break;

   case FDC_SENSE_DRIVE_STATUS:
#ifndef	PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf (trace_file, "\tGFI-empty: Sense Drive Status command\n");
#endif
      break;

   case FDC_SEEK:
#ifndef	PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf(trace_file, "\tGFI-empty: Seek command\n");
#endif
      break;

   case FDC_FORMAT_TRACK:
#ifndef	PROD
      if (io_verbose & GFI_VERBOSE)
	 fprintf(trace_file, "\tGFI-empty: Format Track command\n");
#endif
      break;

#ifndef	PROD
   default:
      if (io_verbose & GFI_VERBOSE)
	 fprintf(trace_file, "GFI-empty: Unimplemented command, type %x\n",
	                      get_type_cmd (command_block));
#endif
      }

   return ((SHORT)ret_stat);
   }


LOCAL SHORT gfi_empty_drive_on IFN1(UTINY,drive)
{
#ifdef PROD
	UNUSED(drive);
#endif
    note_trace1(GFI_VERBOSE, "GFI-Empty: Drive on command - drive %x", drive);
    return(SUCCESS);
}

LOCAL SHORT gfi_empty_drive_off IFN1(UTINY,drive)
{
#ifdef PROD
	UNUSED(drive);
#endif
    note_trace1(GFI_VERBOSE, "GFI-Empty: Drive off command - drive %x", drive);
    return(SUCCESS);
}

LOCAL SHORT gfi_empty_high IFN2(UTINY,drive, half_word, rate)
{
	UNUSED(rate);
#ifdef PROD
	UNUSED(drive);
#endif
	
    note_trace1(GFI_VERBOSE, "GFI-Empty: Set high density command - drive %x",
                drive);
    return(FAILURE);
}


LOCAL SHORT gfi_empty_drive_type IFN1(UTINY,drive)
{
#ifdef PROD
	UNUSED(drive);
#endif
    note_trace1(GFI_VERBOSE, "GFI-Empty: Drive type command - drive %x", drive);
    return( GFI_DRIVE_TYPE_NULL );
}

LOCAL SHORT gfi_empty_change IFN1(UTINY,drive)
{
#ifdef PROD
	UNUSED(drive);
#endif
	note_trace1(GFI_VERBOSE, "GFI-Empty: Disk changed command - drive %x", drive);
    return(TRUE);
}


LOCAL SHORT gfi_empty_reset IFN2(FDC_RESULT_BLOCK *,result_block,UTINY, drive)
{
	UNUSED(drive);
	
	note_trace0(GFI_VERBOSE, "GFI-Empty: Reset command");

    /*
     * Fake up the Sense Interrupt Status result phase.  We don't know the
     * Present Cylinder No, so leave as zero.
     */

    put_r3_ST0(result_block, 0);
    put_r3_PCN(result_block, 0);

    return(SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\dos\emm_mngr.c ===
#include "insignia.h"
#include "host_def.h"
/*			INSIGNIA MODULE SPECIFICATION
			-----------------------------
SccsID		: @(#)emm_mngr.c	1.24 08/31/93 Copyright Insignia Solutions Ltd.
FILE NAME	: emm_mngr.c
MODULE NAME	: 'Middle layer' of Expanded Memory Manager

	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER	: J.P.Box
DATE		: April '88

PURPOSE		: Contains all the routines that communicate with
		the arrays and data structures that hold the
		necessary Expanded Memory Manager Data.


The Following Routines are defined:
		1. init_expanded_memory()
		2. free_expanded_memory()
		3. get_new_handle()
		4. free_handle()
		5. reallocate_handle()
		6. handle_ok()
		7. set_no_pages()
		8. set_EM_pageno()
		9. set_map()
		10. set_name()
		11. get_no_pages()
		12. get_EM_pageno()
		13. get_map()
		14. get_name()
		15. alloc_page()
		16. free_page()
		17. map_page()
		18. unmap_page()
		19. map_saved()
		20. save_map()
		21. restore_map()
		22. copy_exchange_data()
		23. page_status()
	The following routines just return variables to the top layer				
		24. get_total_pages()
		25. get_unallocated_pages()
		26. get_base_address()
		27. get_total_handles()
		28. get_total_open_handles()
		29. get_no_phys_pages()
		30. get_page_seg()
		31. get_map_size()

=========================================================================

AMMENDMENTS	:

=========================================================================
*/


#ifdef LIM

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_LIM.seg"
#endif



#include <stdio.h>
#include <string.h>
#include <malloc.h>

#include TypesH

#include "xt.h"
#include CpuH
#include "sas.h"
#include "host_emm.h"
#include "emm.h"
#include "gmi.h"
#include "debug.h"
#ifndef PROD
#include "trace.h"
#endif
#include "timer.h"

#ifdef NTVDM
#include "error.h"
#endif	/* NTVDM */

typedef enum
{
	BYTE_OP,
	WORD_OP,
	STR_OP
} MM_LIM_op_type;

#ifdef NTVDM
/*	Local Variables			*/
static long
	handle[MAX_NO_HANDLES],		/* Array containing unique ID's	*/
					/* for each handle, these are	*/
					/* usually pointers, but this 	*/
					/* is host dependant		*/
	backfill;			/* backfill memory size 	*/
static unsigned short
	total_pages = 0,		/* no. of EM pages available	*/
	unallocated_pages = 0,		/* no. of unallocated EM pages	*/
	total_handles,			/* no of handles available	*/
	total_open_handles,		/* no. of allocated handles	*/
	*EM_page_mapped_array = NULL,	/* EMM page mapped array	*/
	*EM_page_mapped = NULL,		/* Expanded Memory pages	*/
					/* currently mapped in		*/
	page_offset,			/* offset in handle data at 	*/
					/* which page numbers start	*/
	map_size,			/* no of bytes rq'd to store map*/
	no_phys_pages = 0,		/* no. of phys. pages available	*/
	no_altreg_sets = 0;		/* no of alternative reg sets	*/
static unsigned short
	physical_page[MAX_NO_PAGES];	/* array containing segment	*/
					/* addresses of physical pages	*/

static unsigned short
	EM_start, EM_end;
static IU8
	* altreg_alloc_mask;		/* altref allocate mask */
static unsigned short
	next_free_altreg_set,		/* next free altreg set #, 0 based */
	free_altreg_sets,		/* number of free altreg */
	active_altreg_set = 0;		/* current active alt reg set	*/
static char
	name[NAME_LENGTH];		/* for storing handle name	*/

#define GET_EM_PAGE_MAPPED_PTR(set)	(EM_page_mapped_array + \
					(set * no_phys_pages))

/* get emm parameters, initialize housekeeping structures and
 *  reserve page frames.
 */

boolean lim_page_frame_init(PLIM_CONFIG_DATA lim_config_data)
{
    int 	i;
    unsigned short altreg_alloc_mask_size;  /* altreg allocation mask array size */

    no_phys_pages = get_lim_page_frames(physical_page, lim_config_data);

    /* The first 4 pages must be continuous and locate above 640KB
     * (the EMM primary page frame(physical pages 0, 1, 2 and 3)).
     * It is then followed by other pages located above 640KB and then
     * pages below 640KB(back fill)
     */
    if (!no_phys_pages)
	return FALSE;

    no_altreg_sets = lim_config_data->total_altreg_sets;
    backfill = lim_config_data->backfill;


    /* each mapping register set has no_phys_pages pages */
    EM_page_mapped_array = (unsigned short *)host_malloc(no_phys_pages * no_altreg_sets *
				   sizeof(short));
    if (EM_page_mapped_array == NULL) {
	host_error(EG_MALLOC_FAILURE, ERR_CONT, "");
	return FALSE;
    }
    /* one bit for each altreg set */
    altreg_alloc_mask_size = (no_altreg_sets + 7) / 8;
    altreg_alloc_mask = (unsigned char *)host_malloc(altreg_alloc_mask_size);
    if (altreg_alloc_mask == NULL) {
	host_free(EM_page_mapped_array);
	host_error(EG_MALLOC_FAILURE, ERR_CONT, "");
	return FALSE;
    }

    /* all altreg sets are free at this moment */
    for (i = 0; i < altreg_alloc_mask_size; i++)
	altreg_alloc_mask[i] = 0;

    next_free_altreg_set = 0;
    free_altreg_sets = no_altreg_sets;
    return TRUE;
}
#else


/*	Local Variables			*/
static long
#ifdef	macintosh
	*handle;
#else
	handle[MAX_NO_HANDLES];		/* Array containing unique ID's	*/
					/* for each handle, these are	*/
					/* usually pointers, but this 	*/
					/* is host dependant		*/
#endif /* !macintosh */

static short
	total_pages = 0,		/* no. of EM pages available	*/
	unallocated_pages = 0,		/* no. of unallocated EM pages	*/
	total_handles,			/* no of handles available	*/
	total_open_handles,		/* no. of allocated handles	*/
	EM_page_mapped[MAX_NO_PAGES],	/* Expanded Memory pages	*/
					/* currently mapped in		*/
	page_offset,			/* offset in handle data at 	*/
					/* which page numbers start	*/
	map_size,			/* no of bytes rq'd to store map*/
	no_phys_pages;			/* no. of phys. pages available	*/

static unsigned int
	EM_start,			/* start segment for EM mapping	*/
	EM_end;			/* 1st segment past end of EM	*/

static unsigned short
	physical_page[MAX_NO_PAGES];	/* array containing segment	*/
					/* addresses of physical pages	*/

static char
	name[NAME_LENGTH];		/* for storing handle name	*/

#endif

/*
===========================================================================

FUNCTION	: init_expanded_memory

PURPOSE		: This routine calls the routine to allocate the expanded
		memory pages and then sets up the arrays and variables that
		are used by the Expanded Memory Manager(EMM).

RETURNED STATUS	: SUCCESS - manager initialised succesfully
		  FAILURE - Failure to allocate space for Expanded Memory
		  	    pages.

DESCRIPTION	:

=========================================================================
*/
GLOBAL int init_expanded_memory IFN2(int, size, 	/* size of area in megabytes */
				     int, mem_limit	/* limit of conventional memory
							 * 256, 512 or 640KB */ )

{	
	short
		pages_above_640,	/* no of mappable locations	*/
		pages_below_640,	/*  available either side of 640*/
		EM_page_no,		/* page no. within exp. memory	*/
		physical_page_no;	/* page no. within map region	*/
	unsigned short
		base;			/* start segment of mappable 	*/
					/* memory below 640 KB		*/

	int	i, j;			/* loop counters		*/


	if (!no_phys_pages)
	    return FAILURE;

	/* get space for expanded memory pages	*/

	if(host_initialise_EM((short)size) != SUCCESS)
	{
#ifdef NTVDM
	    host_error(EG_EXPANDED_MEM_FAILURE, ERR_QU_CO, NULL);
#endif	/* NTVDM */
	    return(FAILURE);
	}

#ifdef	macintosh
	if (!handle)
	{
		handle = (long *)host_malloc(MAX_NO_HANDLES*sizeof(long));
	}
#endif	/* macintosh */

	/* Initialise EMM variables	*/

#ifndef NTVDM
	EM_start = 0xd000;
	EM_end   = 0xe000;
#else
	EM_start = physical_page[0];
	EM_end =  physical_page[0] + EMM_PAGE_SIZE * 4;
#endif
	total_pages = unallocated_pages = size * 0x100000 / EMM_PAGE_SIZE;

	/* always allow max handles (Used to be 32 handles/Meg expanded mem) */
	total_handles = MAX_NO_HANDLES;
	total_open_handles = 0;
	for(i = 0; i < total_handles; i++)
		handle[i] = (long) NULL;

#ifdef NTVDM
	map_size = no_phys_pages * NSIZE;
	page_offset = MAP_OFFSET + map_size;	
	pages_below_640 = (SHORT)(backfill / EMM_PAGE_SIZE);
	pages_above_640 = no_phys_pages - pages_below_640;

	/* initialize active mapping register to set 0 */
	EM_page_mapped = EM_page_mapped_array;
	allocate_altreg_set(&active_altreg_set);

	for (i = 0; i < no_phys_pages; i++)
	    EM_page_mapped[i] = (unsigned short)EMPTY;

	if (get_new_handle(0) != 0)
	    return FAILURE;
	set_no_pages(0, 0);
#else

	pages_above_640 = (effective_addr(EM_end,0) - effective_addr(EM_start,0)) / EMM_PAGE_SIZE;
	pages_below_640 = ((640 - mem_limit) * 1024) / EMM_PAGE_SIZE;
	no_phys_pages = pages_above_640 + pages_below_640;

	map_size = no_phys_pages * NSIZE;
	page_offset = MAP_OFFSET + map_size;	

	/*
	 * set up addresses and mapping status of physical pages
	 */
	for( i = 0; i < pages_above_640; i++ )
	{
		physical_page[i] = EM_start + (i * EMM_PAGE_SIZE >> 4);
		EM_page_mapped[i] = EMPTY;
	}
	base = mem_limit * 64;

	for(i = pages_above_640, j = 0; i < no_phys_pages; i++)
	{
		physical_page[i] = base + (j++ * EMM_PAGE_SIZE >> 4);
		EM_page_mapped[i] = EMPTY;
	}
	/*
	 * Allocate handle 0 with any pages required for back filling
	 */
	if(get_new_handle(pages_below_640) != 0)
		return(FAILURE);

	for(i = 0, physical_page_no = pages_above_640; i < pages_below_640; i++)
	{
		if((EM_page_no = alloc_page()) == FAILURE)
			return (FAILURE);

		set_EMpage_no(0, i, EM_page_no);

		if(map_page(EM_page_no, physical_page_no++) == FAILURE)
			return(FAILURE);
	}
	set_no_pages(0, pages_below_640);
#endif	/* NTVDM */

	/*
	 *	Set up necessary variables in Top level EMM function code
	 */
	reset_emm_funcs();

	/*
	** Map the address space taken up by LIM to RAM.
	** Without LIM it would be ROM.
	** The range seems to be fixed at segment D000 to F000.
	** Assumed that AT's have GMI and XT's do not.
	** XT's can use the old fashioned memset calls in
	** delta:manager:init_struc.c
	*/
#ifdef NTVDM
	/* every physical page must be connected as RAM */
	for (i = 0; i < pages_above_640; i++)
	    sas_connect_memory(effective_addr(physical_page[i], 0),
			       effective_addr(physical_page[i], EMM_PAGE_SIZE - 1),
			       SAS_RAM
			       );
#else

	sas_connect_memory(effective_addr(EM_start,0) , effective_addr(EM_end,0) -1 , SAS_RAM );
#endif

	sure_note_trace3(LIM_VERBOSE,"initialised EMM, total pages= %#x, pages above 640= %#x, pages below 640 = %#x",no_phys_pages, pages_above_640, pages_below_640);

	return(SUCCESS);
}

/*
===========================================================================

FUNCTION	: free_expanded_memory

PURPOSE		: This routine calls frees all memory allocated for the
		expanded memory manager and resets the variables that
		are used by the Expanded Memory Manager(EMM).

RETURNED STATUS	: SUCCESS -

DESCRIPTION	: If total_pages = 0, this indicates that expanded
		memory hasn't been initialised, so the routine simply
		does nothing and returns.

=========================================================================
*/
GLOBAL void free_expanded_memory IFN0()

{	
	short 	handle_no;

	if(total_pages == 0)
		return;

	/* free space allocated for each handle	*/

	handle_no = 0;
	while(total_open_handles > 0)
	{
		while(!handle_ok(handle_no))
			handle_no++;

		free_handle(handle_no++);
	}
	/*
	 *	Free space for expanded memory pages
	 */
	host_deinitialise_EM();

	total_pages = 0;

	return;
}

/*
===========================================================================

FUNCTION	: get_new_handle()

PURPOSE		: Finds the next free handle no., allocates storage space
		for recording the EMM data associated with this handle,
		and stores the 'storage ID' in the handle array.

RETURNED STATUS	: SUCCESS - new handle allocated successfully
		 FAILURE - Error occurred in trying to allocate storage
		           space for handle data

DESCRIPTION	: see emm.h for a description of space required for
		 storing handle data e.g. PAGE_OFFSET & NSIZE


=========================================================================
*/
GLOBAL short get_new_handle IFN1(short, no_pages)	/* No.of pages to store in handle */

{
	unsigned short	i;			/* loop count */
	short	handle_no;
	int	data_size;		/* no. of bytes of data storage */
	long	storage_ID;		/* host dependant storage	*/
					/* identifier, usually a ptr.	*/

	sure_note_trace2(LIM_VERBOSE,"new handle request, current total handles= %d, pages requested = %d",total_handles, no_pages);

	handle_no = 0;

	do
		if (handle[handle_no] == (long) NULL)
			break;
	while(++handle_no < total_handles);

	if(handle_no >= total_handles)
		return(FAILURE);

	data_size = page_offset + (no_pages * NSIZE);

	if ((storage_ID = host_allocate_storage(data_size)) == (long) NULL)
		return(FAILURE);

	handle[handle_no] = storage_ID;

	for (i=0 ; i < no_phys_pages ; i++) {
		set_map_no(handle_no, (unsigned char)i, FREE);
	}

	total_open_handles++;

	sure_note_trace1(LIM_VERBOSE,"allocation OK, return handle=%d",handle_no);

	return(handle_no);
}

/*
===========================================================================

FUNCTION	: free_handle

PURPOSE		: frees the storage space allocated to the handle number.
		  Decrements the handles open count

RETURNED STATUS	: SUCCESS - space freed
		  FAILURE - unable to free space

DESCRIPTION	:

=========================================================================
*/
GLOBAL int free_handle IFN1(short, handle_no)	/* No.of handle to be freed */

{
	long	storage_ID;		/* host dependant storage	*/
					/* identifier, usually a ptr.	*/

	sure_note_trace2(LIM_VERBOSE, "free handle %d request, total handles = %d",handle_no, total_handles);

	storage_ID = handle[handle_no];

	if(host_free_storage(storage_ID) != SUCCESS)
		return(FAILURE);	

	handle[handle_no] = (long) NULL;

	total_open_handles--;

	return(SUCCESS);
}

/*
===========================================================================

FUNCTION	: reallocate_handle

PURPOSE		: changes the number of pages allocated to a given handle

RETURNED STATUS	: SUCCESS - handle reallocated
		  FAILURE - unable to get space for new handle data

DESCRIPTION	:

=========================================================================
*/
GLOBAL int reallocate_handle IFN3(short, handle_no, 	/* handle to be reallocated */
				  short, old_page_count,/* current pages in handle  */
				  short, new_page_count)/* required pages for handle*/

{
	long	storage_ID;		/* host dependant storage	*/
					/* identifier, usually a ptr.	*/

	short	size,			/* size of handle data area	*/
		new_size;		/* size of new handle data area	*/


	size = page_offset + (old_page_count * NSIZE);
	new_size = page_offset + (new_page_count * NSIZE);
	storage_ID = handle[handle_no];

	sure_note_trace3(LIM_VERBOSE,"reallocate pages for handle %d, old size=%#x, new size= %#x",handle_no, size, new_size);

	if((storage_ID = host_reallocate_storage(storage_ID, size, new_size)) ==
		(long) NULL)
		return(FAILURE);	

	handle[handle_no] = storage_ID;

	return(SUCCESS);
}

/*
===========================================================================

FUNCTION	: handle_ok

PURPOSE		: checks to see if the handle no. is valid - this should
		be called before every routine that uses a handle number
		to retrieve or set data in the handle data area

RETURNED STATUS	: TRUE	- Handle no. is valid
		FALSE	- Handle no. is invalid

DESCRIPTION	:

=========================================================================
*/
GLOBAL boolean handle_ok IFN1(short, handle_no)

{
#ifdef NTVDM
/* some *** applicaitons feed us a negtive handle number. Catch it and
   throw it to the hell*/

    if ((unsigned short)handle_no >= (unsigned short)total_handles) {
#else
	if(handle_no >= total_handles   ||   handle_no < 0) {
#endif

		sure_note_trace1(LIM_VERBOSE,"invalid handle %d",handle_no);
		return(FALSE);
	}

	if(handle[handle_no] == (long) NULL){
		sure_note_trace1(LIM_VERBOSE,"invalid handle %d",handle_no);
		return(FALSE);
	}

	return(TRUE);
}

/*
===========================================================================

FUNCTION	: set_no_pages

PURPOSE		: sets the no of pages variable in the specified handle

RETURNED STATUS	:

DESCRIPTION	:

=========================================================================
*/
GLOBAL void set_no_pages IFN2(short, handle_no, short, no_pages)

{
	long	storage_ID;		/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	byte	*ptr;			/* pointer to storage area	*/

	storage_ID = handle[handle_no];		
	ptr = USEBLOCK(storage_ID);

	*(short *)ptr = no_pages;

	FORGETBLOCK(storage_ID)

	return;
}

/*
===========================================================================

FUNCTION	: set_EMpage_no

PURPOSE		: sets Expanded Memory page that is used for the specified
		logical page into the handle data storage area

RETURNED STATUS	:

DESCRIPTION	:

=========================================================================
*/
GLOBAL void set_EMpage_no IFN3(short, handle_no,
			       short, logical_page_no,
			       short, EM_page_no)

{
	long	storage_ID;		/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	byte	*ptr;			/* pointer to storage area	*/

	storage_ID = handle[handle_no];

	ptr = USEBLOCK(storage_ID);
	/*
	 * offset pointer to correct position
	 */

	ptr += (page_offset +(logical_page_no * NSIZE));
	*(short *)ptr = EM_page_no;

	FORGETBLOCK(storage_ID)

	return;
}

/*
===========================================================================

FUNCTION	: set_map_no

PURPOSE		: sets Expanded Memory page number in the map section of
		the handle data storage area

RETURNED STATUS	:

DESCRIPTION	:

=========================================================================
*/
GLOBAL void set_map_no IFN3(short, handle_no,
			    unsigned char, physical_page_no,
			    short, EM_page_no)

{
	long		storage_ID;	/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	unsigned char	*ptr;		/* pointer to storage area	*/

	storage_ID = handle[handle_no];

	ptr = USEBLOCK(storage_ID);
	/*
	 * offset pointer to correct position
	 */

	ptr += (MAP_OFFSET +(physical_page_no * NSIZE));
	*(short *)ptr = EM_page_no;

	FORGETBLOCK(storage_ID)

	return;
}

/*
===========================================================================

FUNCTION	: set_name

PURPOSE		: writes a name into the name section of the handle data
		 storage area

RETURNED STATUS	:

DESCRIPTION	:

=========================================================================
*/
GLOBAL void set_name IFN2(short, handle_no,
		          char *, new_name)

{
	long	storage_ID;		/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	unsigned char	*ptr;		/* pointer to storage area	*/


	storage_ID = handle[handle_no];

	ptr = USEBLOCK(storage_ID);
	/*
	 * offset pointer to correct position
	 */

	ptr += NAME_OFFSET;
	strncpy((char *)ptr, new_name, NAME_LENGTH);

	FORGETBLOCK(storage_ID)

	return;
}

/*
===========================================================================

FUNCTION	: get_no_pages

PURPOSE		: gets the number of pages assigned to the specified handle

RETURNED STATUS	: no of pages returned

DESCRIPTION	:

=========================================================================
*/
GLOBAL short get_no_pages IFN1(short, handle_no)

{
	long	storage_ID;		/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	byte	*ptr;			/* pointer to storage area	*/
	short 	no_pages;		/* no. of pages in handle	*/

	storage_ID = handle[handle_no];

	ptr = USEBLOCK(storage_ID);

	no_pages = *(short *)ptr;

	FORGETBLOCK(storage_ID)

	return(no_pages);
}

/*
===========================================================================

FUNCTION	: get_EMpage_no

PURPOSE		: returns the Expanded Memory page no. used for the
		 specified logical page in the given handle

RETURNED STATUS	: Expanded Memory page no. returned

DESCRIPTION	:

=========================================================================
*/
GLOBAL short get_EMpage_no IFN2(short, handle_no,
				short, logical_page_no)

{
	long	storage_ID;		/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	byte	*ptr;			/* pointer to storage area	*/
	short	EM_page_no;		/* Expanded Memory page number	*/

	storage_ID = handle[handle_no];

	ptr = USEBLOCK(storage_ID);
	/*
	 * offset pointer to correct position
	 */

	ptr += (page_offset +(logical_page_no * NSIZE));
	EM_page_no = *(short *)ptr;

	FORGETBLOCK(storage_ID)

	return(EM_page_no);
}

/*
===========================================================================

FUNCTION	: get_map_no

PURPOSE		: returns the Expanded Memory page no. saved in the map
		attached to the given handle

RETURNED STATUS	: page no. in map returned

DESCRIPTION	:

=========================================================================
*/
GLOBAL short get_map_no IFN2(short, handle_no,
			     unsigned char, physical_page_no)

{
	long		storage_ID;	/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	unsigned char	*ptr;		/* pointer to storage area	*/
	short		EM_page_no;	/* Expanded Memory page number	*/

	storage_ID = handle[handle_no];

	ptr = USEBLOCK(storage_ID);
	/*
	 * offset pointer to correct position
	 */

	ptr += (MAP_OFFSET +(physical_page_no * NSIZE));
	EM_page_no = *(short *)ptr;

	FORGETBLOCK(storage_ID)

	return(EM_page_no);
}

/*
===========================================================================

FUNCTION	: get_name

PURPOSE		: returns a pointer to the name assigned to the given handle

RETURNED STATUS	:

DESCRIPTION	:

=========================================================================
*/
GLOBAL char *get_name IFN1(short, handle_no)

{
	long		storage_ID;	/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	unsigned char	*ptr;		/* pointer to storage area	*/

	storage_ID = handle[handle_no];

	ptr = USEBLOCK(storage_ID);
	/*
	 * offset pointer to correct position
	 */

	ptr += NAME_OFFSET;
	strncpy(name, (char *)ptr, NAME_LENGTH);

	FORGETBLOCK(storage_ID)

	return(name);
}

/*
===========================================================================

FUNCTION	: alloc_page

PURPOSE		: allocates a page from expanded memory

RETURNED 	: >=0 = SUCCESS -  EM page no. returned
		  <0  = FAILURE - error occured in trying to allocate page

DESCRIPTION	:

=========================================================================
*/
GLOBAL short alloc_page IFN0()

{
	short	EM_page_no;		/* EM_page_no to be returned	*/


	if ((EM_page_no = host_alloc_page()) == FAILURE)
		return(FAILURE);

	unallocated_pages--;

	return(EM_page_no);
}

/*
===========================================================================

FUNCTION	: free_page

PURPOSE		: frees a page of expanded memory for further use

RETURNED 	: SUCCESS - page freed successfully
		  FAILURE - unable to free page

DESCRIPTION	:

=========================================================================
*/
GLOBAL int free_page IFN1(short, EM_page_no)

{

	short	physical_page_no;

	if (EM_page_no > total_pages)
		return(FAILURE);

	/* Removed from mapped pages table */

	for (physical_page_no=0; physical_page_no < no_phys_pages; physical_page_no++) {

		if (EM_page_mapped[physical_page_no] == EM_page_no) {
			EM_page_mapped[physical_page_no] = UNMAPPED;
			break;
		}

	}
				
	if (host_free_page(EM_page_no) != SUCCESS)
		return(FAILURE);

	unallocated_pages++;

	return(SUCCESS);
}

#ifndef NTVDM
/*
========================================================================

FUNCTION	: page_already_mapped

PURPOSE		: function to determine whether a EMM page is already
		  mapped to a different physical page within intel
		  memory
				
RETURNED 	: count of number of pages in addition to the page
		  passed which are mapped to the same logical page.
		  The page number of one of these mirror pages is
		  also returned via the pointer passed as an argument.

DESCRIPTION	:
			
========================================================================
*/

GLOBAL ULONG
page_already_mapped IFN2(short, EM_page_no,
			unsigned char *, physical_page_no)

{
	unsigned char	page, orig_page;
	ULONG	map_count;

	map_count = 0;
	orig_page = *physical_page_no;

	for( page = 0; page < (unsigned char) no_phys_pages; page++ )
	{
		if ((EM_page_mapped[page] == EM_page_no) &&
						(page != orig_page ))
		{
			sure_note_trace2( LIM_VERBOSE,
				"log page %x mapped to phys page %x",
						EM_page_no, page);

			*physical_page_no = page;
			map_count++;
		}
	}

	return( map_count );
}


LOCAL VOID
connect_MM_LIM_page IFN2( USHORT, segment, SHORT, EM_page_no )
{
	ULONG eff_addr;

#ifdef PROD
	UNUSED(EM_page_no);
#endif
	
	assert2( NO, "Connecting multi-mapped page, %d, at %x",
								EM_page_no, segment );

	eff_addr = effective_addr( segment, 0 );
	sas_connect_memory( eff_addr, eff_addr + EMM_PAGE_SIZE - 1,
									SAS_MM_LIM );
}

LOCAL VOID
disconnect_MM_LIM_page IFN4( USHORT, segment, SHORT, EM_page_no,
		ULONG, map_count, unsigned char, physical_page_no )
{
	ULONG eff_addr;

#ifdef PROD
	UNUSED(EM_page_no);
#endif
	
	sure_note_trace2(LIM_VERBOSE,
		"Unmapping multi-mapped page, %d, at %x",
						EM_page_no, segment );

	eff_addr = effective_addr( segment, 0 );
	sas_connect_memory( eff_addr, eff_addr + EMM_PAGE_SIZE - 1, SAS_RAM );

	if( map_count == 1 )
	{
		/*
		 * We have to disconnect the last page of this group,
		 * by connecting it as SAS_RAM.
		 */

		segment = physical_page[physical_page_no];
		eff_addr = effective_addr( segment, 0 );

		sure_note_trace2(LIM_VERBOSE,
			"Unmapping last multi-mapped page, %d, at %x",
								EM_page_no, segment );

		sas_connect_memory( eff_addr, eff_addr + EMM_PAGE_SIZE - 1,
										SAS_RAM );
	}
}

#endif	/* !NTVDM */

/*
========================================================================

FUNCTION	: map_page

PURPOSE		: maps a page from expanded memory into Intel physical
		address space

RETURNED 	: SUCCESS - page mapped successfully
		  FAILURE - unable to map page

DESCRIPTION	:

========================================================================
*/
GLOBAL int map_page IFN2(short, EM_page_no,
			 unsigned char, physical_page_no)

{
	USHORT	segment;	/* segment address of page in	*/
				/* physical address space	*/
	unsigned char	phys_page;
	ULONG		map_count;
			
	segment = physical_page[physical_page_no];

	/*
	 *	make sure that a page is not already mapped in
	 * 	if it is - return it to Expanded Memory
	 */
	sure_note_trace2(LIM_VERBOSE,
		"map page %#x to phys page %#x",
			EM_page_no,physical_page_no);

	if(EM_page_mapped[physical_page_no] != EMPTY)
	{
		sure_note_trace1(LIM_VERBOSE,
				"phys page already mapped to page %#x",
						EM_page_mapped[physical_page_no]);

		if(EM_page_mapped[physical_page_no] == EM_page_no)
		{
			sure_note_trace0(LIM_VERBOSE,
					"remap of same page, so do nothing");

			return(SUCCESS);
		}

#ifndef NTVDM
		/*
		 * We want to return the current contents of this physical
		 * page to the logical page ( to sync up the logical page ).
		 * We have to check first that this physical page is not a
		 * mirror of some other page - if it is we have to disconnect
		 * it from the group of pages it is mirroring.
		 */

		phys_page = physical_page_no;

		if( map_count = page_already_mapped(
				EM_page_mapped[physical_page_no], &phys_page))
		{
			disconnect_MM_LIM_page( segment, EM_page_no,
								map_count, phys_page );
		}

		/*
		 * We can now unmap the physical page and indicate
		 * that it is really unmapped.
		 */
		if(host_unmap_page(segment,
				EM_page_mapped[physical_page_no]) != SUCCESS)
		{
			return(FAILURE);
		}
		EM_page_mapped [physical_page_no] = EMPTY;
#endif

	}
#ifndef NTVDM

	/*
	 * If this logical page is already mapped, make sure the
	 * new mapping has an up to date copy
	 */
	
	phys_page = physical_page_no;

	if (page_already_mapped(EM_page_no, &phys_page))
	{
		/*
		 * We now want to get the LIM logical page up to date with
		 * the physical pages that are currently mapped to it. We
		 * don't want to set EM_page_mapped [phys_page] to EMPTY
		 * after the host_unmap_page().  If we did we wouldn't notice
		 * that we had a multiply-mapped page and the patch up code
		 * wouldn't get called.
		 */

		host_update_logical_page( physical_page[phys_page],
									EM_page_no );

		/*
		 * Connect new page and "mirror" page as MM_LIM.  This may
		 * mean some pages get connected as MM_LIM multiple times
		 * - inefficient but not wrong otherwise.  This connection
		 * has to be made for all hosts - even those that can do
		 * mapping themselves.  This is to make sure that the CPU
		 * data structures associated with all pages get updated
		 * when a multi-mapped write occurs.
		 */

		connect_MM_LIM_page( segment, EM_page_no );

		connect_MM_LIM_page( physical_page[phys_page], EM_page_no );
	}
#endif
	if(host_map_page(EM_page_no, segment) != SUCCESS)
		return(FAILURE);

	EM_page_mapped[physical_page_no] = EM_page_no;

	sure_note_trace0(LIM_VERBOSE,"map OK");
	return(SUCCESS);
}

/*
========================================================================

FUNCTION	: unmap_page

PURPOSE		: unmaps a page from Intel physical address space back to
		expanded memory

RETURNED 	: SUCCESS - page unmapped successfully
		  FAILURE - error in unmapping page

DESCRIPTION	:

========================================================================
*/
GLOBAL int unmap_page IFN1(unsigned char, physical_page_no)

{
	short		EM_page_no;	/* EM_page_no currently mapped	*/
	unsigned short	segment;	/* segment address of page in	*/
					/* physical address space	*/
	SHORT		phys_page;
	ULONG		map_count;

	sure_note_trace1( LIM_VERBOSE,
				"unmap phys page %#x",physical_page_no);

	segment = physical_page[physical_page_no];

	if((EM_page_no = EM_page_mapped[physical_page_no]) == EMPTY)
	{
		/*
		 * Already done
		 */
		sure_note_trace0( LIM_VERBOSE,
					"already unmapped, so do nothing");

		return(SUCCESS);
	}

	phys_page = physical_page_no;

#ifndef NTVDM
	if( map_count = page_already_mapped( EM_page_no, (unsigned char *)&phys_page ))
	{
		disconnect_MM_LIM_page( segment, EM_page_no,
								map_count, phys_page );
	}
#endif

	if(host_unmap_page(segment, EM_page_no) != SUCCESS)
		return(FAILURE);

	EM_page_mapped[physical_page_no] = EMPTY;

	sure_note_trace0(LIM_VERBOSE,"unmap OK");
	return(SUCCESS);
}

/*
===========================================================================

FUNCTION	: map_saved

PURPOSE		: Checks to see if a map has been saved for the specified
		handle

RETURNED STATUS	: TRUE  -  A map is saved for this handle
		FALSE	-  No map has been saved

DESCRIPTION	: checks the first entry in the map for the value 'FREE'

=========================================================================
*/
GLOBAL boolean map_saved IFN1(short, handle_no)

{
	long		storage_ID;	/* host dependant storage	*/
					/* identifier, usually a ptr.	*/
	unsigned char	*ptr;		/* pointer to storage area	*/
	short		status;		/* value read from map		*/

	storage_ID = handle[handle_no];
	ptr = USEBLOCK(storage_ID);

	/*
	 * offset pointer to correct position
	 */

	ptr += MAP_OFFSET;
	status = *(short *)ptr;

	FORGETBLOCK(storage_ID)

	return((status == FREE) ? FALSE : TRUE);
}


/*
===========================================================================

FUNCTION	: save_map

PURPOSE		: takes a copy of the EM_page_mapped array and store it in
		the map section of the handle data storage area

RETURNED STATUS	: SUCCESS - everything OK
		  FAILURE - invalid segment no. passed in src array

DESCRIPTION	: if handle_no is >= 0 the map is stored in the data area
			assigned to that handle
		  if handle_no == -1 the map is stored in the array pointed
		  	to by dst_segment:dst_offset
		  if handle_no == -2 only the pages specified by the segment
		  	addresses in the src array (pointed to by
		  	src_segment:src_offset) are saved in the dst array
		  	(pointed to by dst_segment:dst_offset).

=========================================================================
*/
GLOBAL int save_map IFN5(short, handle_no,
			 unsigned short, dst_segment,
			 unsigned short, dst_offset,
			 unsigned short, src_segment,
			 unsigned short, src_offset)

{
	unsigned short	offset,		/* temp offset variable		*/
			segment,	/* segment address to be saved	*/
            i,		/* loop counter			*/
			page_no,	/* physical page no.		*/
			no_to_save;	/* no of pages in src array	*/

	if(handle_no >= 0)
		for (i = 0; i < no_phys_pages; i++)
			set_map_no(handle_no, (unsigned char) i, EM_page_mapped[i]);

	else if(handle_no == -1)
		for(i = 0; i < no_phys_pages; i++)
		{
			write_intel_word(dst_segment, dst_offset, EM_page_mapped[i]);
			dst_offset +=2;
		}

	else if(handle_no == -2)
	{
		offset = dst_offset;
		for(i  = 0; i < no_phys_pages; i++)
		{
#ifdef NTVDM
			write_intel_word(dst_segment, offset, LEAVE);
#else
			write_intel_word(dst_segment, offset, EMPTY);
#endif
			offset += 2;
		}
		read_intel_word(src_segment, src_offset, (word *)&no_to_save);
		for (i = 0; i < no_to_save; i++)
		{
			src_offset += 2;
			read_intel_word(src_segment, src_offset, &segment);
			/*
			 *	Find Physical page no.
			 */
			page_no = 0;
			do
				if(segment == physical_page[page_no])
					break;
			while(++page_no < no_phys_pages);

			if(page_no >= no_phys_pages)
				return (FAILURE);
			/*
			 *	Save EM page number in destination array	
			 */
			offset = dst_offset + (page_no * 2);
			write_intel_word(dst_segment, offset, EM_page_mapped[page_no]);
		}
	}
	return(SUCCESS);
}

/*
===========================================================================

FUNCTION	: restore_map

PURPOSE		: reads the specified map and returns 2 arrays specifying
		which pages have to be mapped out and which ones have to be
		mapped in

RETURNED STATUS	: SUCCESS - Map read successfully


DESCRIPTION	: A +ve handle number indicates that the map is stored
		within the handle data area.
		If the handle number is -ve the map will be read from the
		data pointed to by segment:offset

		Only page out - if there is a page currently mapped in and
		it is not being replaced by a copy of itself or an empty
		page
		Only page in - if new page is different to existing one
		and it is not empty

=========================================================================
*/
#ifdef ANSI
GLOBAL int restore_map (short handle_no,
			unsigned short segment,
			unsigned short offset,
			short pages_out[],
			short pages_in[])
#else
GLOBAL int restore_map (handle_no, segment, offset, pages_out, pages_in)
short handle_no;
unsigned short segment;
unsigned short offset;
short pages_out[];
short pages_in[];
#endif	/* ANSI */
{
	short	i,		/* loop counter				*/
		new_page,	/* page number read from map		*/
		old_page;	/* existing page number			*/

	for(i = 0; i < no_phys_pages; i++)
	{
		if(handle_no >= 0)
			new_page = get_map_no(handle_no, (unsigned char)i);
		else
		{
			read_intel_word(segment, offset, (word *)&new_page);
			offset += 2;
#ifdef NTVDM
			if(new_page < LEAVE || new_page >= total_pages)
#else
			if(new_page < EMPTY || new_page >= total_pages)
#endif /* NTVDM */
				return(FAILURE);
		}
		old_page = EM_page_mapped[i];

/*
		if(old_page != EMPTY && new_page != EMPTY && old_page != new_page )
*/
/* need to do unmap to empty state case to update the page copy in the LIM
   space in case of new maps of that page to other LIM slots. */
#ifdef NTVDM
		if(old_page != EMPTY && old_page != new_page && new_page != LEAVE)
#else
		if(old_page != EMPTY && old_page != new_page )
#endif
			pages_out[i] = old_page;
		else
			pages_out[i] = EMPTY;

#ifdef NTVDM
		if(new_page != EMPTY && new_page != old_page && new_page != LEAVE)
#else
		if(new_page != EMPTY && new_page != old_page)
#endif
			pages_in[i] = new_page;
		else
			pages_in[i] = EMPTY;
	}
	if(handle_no >= 0)
		set_map_no(handle_no, 0, FREE);

	return(SUCCESS);
}

/*
===========================================================================

FUNCTION	: copy_exchange_data

PURPOSE		: copies or exchanges data between conventional and
		expanded memory

RETURNED STATUS	: SUCCESS - everything ok
		FAILURE - Error ocurred in copying data

DESCRIPTION	: type - uses a bit pattern, bit 0 represents destination,
		bit 1 represents source, a set bit means expanded, a clear
		bit means conventional memory
		bit 2 represents exchange if set or move if it is clear

		e.g. 	0 (0000) = move conventional to conventional
		 	1 (0001) = move conventional to expanded
		 	6 (0110) = exchange expanded to conventional
		 	7 (0111) = exchange expanded to expanded

=========================================================================
*/
GLOBAL int copy_exchange_data IFN8(unsigned char, type,
				   short, src_handle,
				   unsigned short, src_seg_page,
				   unsigned short, src_offset,
				   short, dst_handle,
				   unsigned short, dst_seg_page,
				   unsigned short, dst_offset,
				   unsigned long, length)

{
	short		dst_EMpage,	/* EM page no . of destination	*/
			src_EMpage;	/* EM page no. of source	*/
	int		page_no;	/* phys. page no. of mapped page*/

	/*
	 * First check to see if the expanded memory page is mapped
	 * if it is - change the type to deal directly with the
	 * physical page that it is mapped to
	 */
	if( type & 1)
	{
		dst_EMpage = get_EMpage_no(dst_handle, dst_seg_page);
		if((page_no = page_status(dst_EMpage)) != UNMAPPED )
		{
			dst_seg_page = physical_page[page_no];
			type &= 6;
		}
	}
	if( type & 2)
	{
		src_EMpage = get_EMpage_no(src_handle, src_seg_page);
		if((page_no = page_status(src_EMpage)) != UNMAPPED )
		{
			src_seg_page = physical_page[page_no];
			type &= 5;
		}
	}

	switch(type)
	{
		case 0:	if(host_copy_con_to_con(length, src_seg_page, src_offset,
			   dst_seg_page, dst_offset) != SUCCESS)
				return(FAILURE);
			break;

		case 1:	if(host_copy_con_to_EM(length, src_seg_page, src_offset,
			   dst_EMpage, dst_offset) != SUCCESS)
			   	return(FAILURE);
			break;

		case 2:	if(host_copy_EM_to_con(length, src_EMpage, src_offset,
			   dst_seg_page, dst_offset) != SUCCESS)
			   	return(FAILURE);
			break;

		case 3:	if(host_copy_EM_to_EM(length, src_EMpage, src_offset,
			   dst_EMpage, dst_offset) != SUCCESS)
			   	return(FAILURE);
			break;

		case 4:	if(host_exchg_con_to_con(length, src_seg_page, src_offset,
			   dst_seg_page, dst_offset) != SUCCESS)
				return(FAILURE);
			break;

		case 5:	if(host_exchg_con_to_EM(length, src_seg_page, src_offset,
			   dst_EMpage, dst_offset) != SUCCESS)
			   	return(FAILURE);
			break;

		case 6:	if(host_exchg_con_to_EM(length, dst_seg_page, dst_offset,
			   src_EMpage, src_offset) != SUCCESS)
			   	return(FAILURE);
			break;

		case 7:	if(host_exchg_EM_to_EM(length, src_EMpage, src_offset,
			   dst_EMpage, dst_offset) != SUCCESS)
			   	return(FAILURE);
			break;

		default: return(FAILURE);
	}
	return(SUCCESS);
}

/*
========================================================================

FUNCTION	: page_status

PURPOSE		: checks if a particular EM page is mapped or not

RETURNED STATUS	: page_no - physical page no returned if mapped
		  UNMAPPED - returned if not mapped

DESCRIPTION	:

========================================================================
*/

GLOBAL int page_status IFN1(short, EMpage_no)
{
	short physical_page_no = 0;
			/* position of page in physical memory	*/

	do
		if(EM_page_mapped[physical_page_no] == EMpage_no)
			break;
	while(++physical_page_no < no_phys_pages );

	if(physical_page_no >= no_phys_pages)
		return(UNMAPPED);
	else
		return(physical_page_no);
}

/*
========================================================================

FUNCTION	: phys_page_from_addr
		
PURPOSE		: determines the physical page number of a LIM page
		  from its Intel address.
		  		
RETURNED STATUS	: The physical page containing the LIM address.

DESCRIPTION	:
			
=======================================================================
*/

LOCAL SHORT
phys_page_from_addr IFN1( sys_addr, address )

{
	sys_addr	start;

	start = effective_addr( EM_start, 0x0 );

	return( (SHORT)((ULONG)(( address - start ) / EMM_PAGE_SIZE )));
}

/*
========================================================================

FUNCTION	: get_total_pages
		  get_unallocated_pages
		  get_base_address
		  get_total_handles
		  get_total_open_handles
		  get_no_phys_pages
		  get_page_seg
		  get_map_size

PURPOSE		: simply returns the reqested variables, to avoid
		having to use globals


RETURNED STATUS	: the following variables are returned , depending upon
		the routine called:-
			total_pages
			unallocated_pages
			base_address
			total_handles
			total_open_handles
			no_phys_pages
			physical_page[i]
			map_size

DESCRIPTION	:

========================================================================
*/

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_LIM2.seg"
#endif

GLOBAL short get_total_pages IFN0()
{
	return(total_pages);
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_LIM.seg"
#endif

GLOBAL short get_unallocated_pages IFN0()
{
	return(unallocated_pages);
}

GLOBAL unsigned short get_base_address IFN0()
{
#ifdef NTVDM
	return(physical_page[0]);
#else
	return(EM_start);
#endif
}

GLOBAL short get_total_handles IFN0()
{
	return(total_handles);
}

GLOBAL short get_total_open_handles IFN0()
{
	return(total_open_handles);
}

GLOBAL short get_no_phys_pages IFN0()
{
	return(no_phys_pages);
}

GLOBAL unsigned short get_page_seg IFN1(unsigned char, page_no)
{
	return(physical_page[page_no]);
}

GLOBAL short get_map_size IFN0()
{
	return(map_size);
}

#ifdef NTVDM
GLOBAL short get_segment_page_no(unsigned short segment)
{
#if defined(LARGE_FRAME) && !defined(MONITOR)
	short i
	for (i = 0; i < no_phys_pages; i++)
	    if (physical_page[i] == segment)
		break;
	return(i);
#else
	return((segment - physical_page[0]) / EMM_PAGE_SIZE);
#endif

}
GLOBAL	unsigned short get_no_altreg_sets(void)
{
	return(no_altreg_sets);
}

GLOBAL unsigned short get_active_altreg_set(void)
{
	return(active_altreg_set);
}

GLOBAL boolean altreg_set_ok(unsigned short set)
{
    return(set < no_altreg_sets &&
	   (altreg_alloc_mask[set >> 3] & (1 << (set & 0x07))));

}

#if defined (NTVDM) && defined(MONITOR) && !defined(PROD)
/* these functions are provided for monitor to verify that
 * it has the same definitions of EMM_PAGE_SIZE and INTEL_PAGE_SIZE as
 * ours.
 */

GLOBAL unsigned short get_emm_page_size(void)
{
    return ((unsigned short)EMM_PAGE_SIZE);
}
GLOBAL unsigned short get_intel_page_size(void)
{
    return ((unsigned short) INTEL_PAGE_SIZE);
}
#endif

/* allocate a free alt mapping register set */

GLOBAL boolean allocate_altreg_set(unsigned short *altreg_set)
{
    short byte_offset, bit_offset;
    short  *page_mapped_ptr;
    IU8 mask;
    int i;
    /* this check is very important because we ** probably ** have
     * several unused bits in the allocation mask array
     */
    if (free_altreg_sets == 0)
	return (FALSE);

    /* use quick and dirty way to allocate a set */
    if (next_free_altreg_set < no_altreg_sets) {
	altreg_alloc_mask[next_free_altreg_set >> 3] |=
	       (0x1 << (next_free_altreg_set & 0x07));
	*altreg_set = next_free_altreg_set++;
    }
    else {
	for (byte_offset = 0; byte_offset < no_altreg_sets; byte_offset++) {
	    if (altreg_alloc_mask[byte_offset] != 0xFF) {
		mask = altreg_alloc_mask[byte_offset];
		bit_offset = 0;
		while (mask & (1 << bit_offset))
		    bit_offset++;
		break;
	    }
	}
	altreg_alloc_mask[byte_offset] |= (1 << bit_offset);
	*altreg_set = byte_offset * 8 + bit_offset;
    }
    /* a new alt reg set is just allocated, initialize its
     * mapping register to the current active set
     */
    page_mapped_ptr = GET_EM_PAGE_MAPPED_PTR(*altreg_set);
    for (i = 0; i < no_phys_pages; i++)
	page_mapped_ptr[i] = EM_page_mapped[i];
    return TRUE;
}
/* free the given alt mapping register set */
GLOBAL boolean deallocate_altreg_set(unsigned short set)
{

    /* can not deallocate set 0 or active set */
    if (set != 0 && set != active_altreg_set && set < no_altreg_sets &&
	altreg_alloc_mask[set >> 3] & (1 << (set &0x07))) {

	altreg_alloc_mask[set >> 3] &= (0xFE << (set & 0x07));
	free_altreg_sets++;
	if (free_altreg_sets == (no_altreg_sets - 1))
	    next_free_altreg_set = 1;
	return TRUE;
    }
    return FALSE;
}

/* This function activate the given alt mapping register set
 * input: alt reg set to be activated.
 * output: TRUE if the given set is activated.
 *	   FALSE if the given set is not activated.
 */

GLOBAL boolean activate_altreg_set(unsigned short set, short * page_in)
{
    int i;
    short * page_out, *page_in_ptr;
    short new_page, old_page, segment;


    if (active_altreg_set == set && page_in == NULL)
	return TRUE;

    /* get the mapping array to be mapped in*/
    page_in_ptr = GET_EM_PAGE_MAPPED_PTR(set);

    /* if no page-in override, use the altreg set current mapping */
    if (page_in == NULL)
	page_in = page_in_ptr;

    /* the active altreg is being paged out */
    page_out = GET_EM_PAGE_MAPPED_PTR(active_altreg_set);
    for ( i = 0; i < no_phys_pages; i++) {
	new_page = page_in[i];
	old_page = page_out[i];
	segment = physical_page[i];

	if (old_page != EMPTY && old_page != new_page) {
	    if (host_unmap_page(segment, old_page) != SUCCESS)
		return FALSE;
	}
	if(new_page != EMPTY && new_page != old_page) {
	    if (host_map_page(new_page, segment) != SUCCESS)
		return FALSE;
	}
	/* update the active-to-be set mapping */
	page_in_ptr[i] = new_page;
    }
    active_altreg_set = set;
    EM_page_mapped = page_in_ptr;
    return TRUE;
}
#endif	/* NTVDM */

#ifndef NTVDM

/*
========================================================================

FUNCTION	: LIM_b_write,
		  LIM_w_write,
		  LIM_str_write
		  patch_pages
		
PURPOSE		: LIM byte, word & string - called from write check
		  failure code in the CPU when a write to a multi-mapped
		  LIM page is detected.
		  patch_pages - generic code called from the other
		  three routines.
		  		
RETURNED STATUS	: None.

DESCRIPTION	:
			
========================================================================
*/

LOCAL VOID
patch_one_page_partial IFN4( sys_addr, intel_addr, sys_addr, eff_addr,
			MM_LIM_op_type, type, ULONG, data )

{
	ULONG		check_len;

	UNUSED( intel_addr );	/* Used in patch_one_page_full() */

	switch( type )
	{
		case BYTE_OP:
			check_len = 1;
			break;

		case WORD_OP:
			check_len = 2;
			break;

		case STR_OP:
			check_len = data;
			break;
	}

	sas_overwrite_memory( eff_addr, check_len );
}

LOCAL VOID
patch_one_page_full IFN4( sys_addr, intel_addr, sys_addr, eff_addr,
			MM_LIM_op_type, type, ULONG, data )

{
	sys_addr	check_addr;
	ULONG		check_len;

	switch( type )
	{
		case BYTE_OP:
			check_addr = eff_addr;
			check_len = 1;
			sas_store_no_check( eff_addr, data );
			break;

		case WORD_OP:
			check_addr = eff_addr;
			check_len = 2;
			sas_storew_no_check( eff_addr, data );
			break;

		case STR_OP:
			check_addr = eff_addr;
			check_len = data;
			do
			{
				sas_store_no_check( eff_addr,
					sas_hw_at_no_check(
							intel_addr ));
				intel_addr++;
				eff_addr++;
			}
			while( --data );
			break;
	}

	sas_overwrite_memory( check_addr, check_len );
}

LOCAL VOID
patch_pages IFN6( MM_LIM_op_type, type, ULONG, offset,
			SHORT, EM_page_no, SHORT, phys_page_no,
			ULONG, data, sys_addr, intel_addr )

{
	LONG		cnt01;
	sys_addr	eff_addr;

	for( cnt01 = 0; cnt01 < get_no_phys_pages(); cnt01++ )
	{
		if(( EM_page_mapped[cnt01] == EM_page_no ) &&
							( cnt01 != phys_page_no ))
		{
			eff_addr = effective_addr( get_page_seg(cnt01),
										offset );

			host_patch_one_page( intel_addr, eff_addr, type, data );

			sure_note_trace1(LIM_VERBOSE,
					"MM LIM write type %d", type );
			sure_note_trace2(LIM_VERBOSE,
					"log page 0x%x, phs page 0x%x",
								EM_page_no, cnt01 );
		}
	}
}

GLOBAL VOID
LIM_b_write IFN1( sys_addr, intel_addr )

{
	ULONG		limdata;
	SHORT		EM_page_no, phys_page_no;
	word		offset;

	phys_page_no = phys_page_from_addr( intel_addr );

	offset = intel_addr -
				effective_addr( get_page_seg(phys_page_no), 0x0 );

	EM_page_no = EM_page_mapped[phys_page_no];

	/*
	 * Get the data written in order to patch up this
	 * page's buddy pages.
	 */

	limdata = (ULONG) sas_hw_at_no_check( intel_addr );
	patch_pages( BYTE_OP, offset, EM_page_no, phys_page_no,
								limdata, intel_addr );

	/*
	 * Tell the CPU that this page has been written to.
	 */

	sas_overwrite_memory( intel_addr, 1 );
}

GLOBAL VOID
LIM_w_write IFN1( sys_addr, intel_addr )

{
	ULONG		limdata;
	SHORT		EM_page_no, phys_page_no;
	word		offset;

	phys_page_no = phys_page_from_addr( intel_addr );

	offset = intel_addr -
				effective_addr( get_page_seg(phys_page_no), 0x0 );

	EM_page_no = EM_page_mapped[phys_page_no];

	limdata = (ULONG) sas_w_at_no_check( intel_addr );
	patch_pages( WORD_OP, offset, EM_page_no, phys_page_no,
								limdata, intel_addr );

	sas_overwrite_memory( intel_addr, 2 );
}

GLOBAL VOID
LIM_str_write IFN2( sys_addr, intel_addr, ULONG, length )

{
   	SHORT		EM_page_no, phys_page_no;
	word		offset;

	phys_page_no = phys_page_from_addr( intel_addr );

	offset = intel_addr -
				effective_addr( get_page_seg(phys_page_no), 0x0 );

	EM_page_no = EM_page_mapped[phys_page_no];

	patch_pages( STR_OP, offset, EM_page_no, phys_page_no,
								length, intel_addr );

	sas_overwrite_memory( intel_addr, length );
}
#endif	/* !NTVDM */

#ifndef PROD
/*
===========================================================================

FUNCTION	: print_handle_data

PURPOSE		: used for debugging only - prints all the data stored
		for a given handle

RETURNED STATUS	: none

DESCRIPTION	:

=========================================================================
*/
GLOBAL void print_handle_data IFN1(short, handle_no)

{
	long	storage_ID;
	byte	*ptr;
	short	no_pages, i;
	char	*name_ptr;
	short	*map_ptr;
	short	*page_ptr;

	if ((storage_ID = handle[handle_no]) == 0)
	{
		printf("Unassigned handle - No. %d\n",handle_no);
		return;
	}
	ptr = USEBLOCK(storage_ID);
	name_ptr = (char *)ptr + NAME_OFFSET;
	map_ptr = (short *)(ptr + MAP_OFFSET);
	page_ptr = (short *)(ptr + page_offset);

	no_pages = *(short *)ptr;
	printf("Handle No. %d\n",handle_no);
	printf("No. of Pages = %d\n",no_pages);
	printf("Name         = '");
	for(i=0;i<8;i++)
		printf("%c",*name_ptr++);
	printf("'\n");
	printf("Map = ");
	for(i=0;i<no_phys_pages;i++)
		printf(" %d",*map_ptr++);
	printf("\n");
	for(i=0;i<no_pages;i++)
		printf("Page (%d)     = %d\n",i,*page_ptr++);

	FORGETBLOCK(storage_ID);

	return;
}
#endif	/* !PROD	*/
#endif 	/* LIM		*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\base_def.h ===
/*
 *      Name:           base_def.h
 *
 *      Author:         Jeremy Maiden
 *
 *      Created on:     3rd November 1993
 *
 *      SccsID:         @(#)base_def.h	1.7 08/19/94
 *
 *      Purpose:        This file contains the base definitions of the Insignia
 *                      standard types and constants.
 *
 * 	Conforms to:	Version 2.1 of the Insignia C Coding Standards
 *
 *      (c)Copyright Insignia Solutions Ltd., 1993. All rights reserved.
 */


/* You should use this macro wherever you have an argument to a
 * function which is unused.
 */
#ifndef UNUSED
#ifdef lint
#define UNUSED(x)	{ x; }
#else	/* !lint */
#define UNUSED(x)
#endif	/* lint */
#endif	/* UNUSED */

/*
 * Ansi extensions. See "1.5 insignia.h: macros" of coding standards....
 *
 * Note: CONST is now deprecated in favour of const, however
 * it is still in use
 */

#ifdef	ANSI
#define STRINGIFY(x)	#x
#define	CAT(x,y)	x ## y
#else	/* !ANSI */
#define STRINGIFY(x)    "x"
#define	CAT(x,y)	x y
#define	const		/* nothing */
#endif	/* ANSI */

#ifndef TRUE
#define TRUE	((IBOOL)!0)
#endif

#ifndef FALSE
#define FALSE	((IBOOL)0)
#endif

#define	PRIVATETYPE		/* documents private typedefs local to a source file */
/*
 * Insignia Standard Storage Classes
 */

#define GLOBAL                  /* Defined as nothing */
#define LOCAL   static          /* Local to the source file */
#define SAVED   static          /* For local static variables */
#define IMPORT  extern          /* To refer from another file */
#define FORWARD                 /* to refer from the same file */
#define FAST    register	/* High-speed Storage */

/*
 * Define types so that old code can be brought into the 4.0 masterpack
 */
#define ULONG	unsigned long
#define LONG	long

#define DOUBLE	double

#define VOID	void
#define	INT	int
#define	SHORT	IS16
#define	USHORT	IU16
#define TINY	IS8
#define	UTINY	IU8
#define WORD	IU16

/* types from xt.h */
#define boolean	IBOOL
#define byte	IU8
#define half_word	IU8
#define word	IU16
#define double_word	IU32
#define sys_addr	IU32
#define io_addr		IU16
#define host_addr	IU8 *
#define LIN_ADDR	IU32
#define PHY_ADDR	IU32

/*
** ANSI-independent function prototypes and definition macros.
**
** A function prototype looks like:
**
** IMPORT       USHORT  func    IPT2(UTINY, param0, CHAR *, param1);
**
** i.e. macro IPTn is used for a function with n parameters.
**
** The corresponding function definition looks like:
**
** GLOBAL       USHORT  funct   IFN2(UTINY, param0, CHAR *, param1)
** {
**      ... function body ...
** }
**
** Limitations: only parameters with declarations of the form "type name" can
** be handled. This rules out arrays (can use pointer syntax instead) and
** parameters which are pointers to functions or something similar. The previous** method of using ifdef ANSI must be used for these cases.
**
*/

#ifdef  ANSI
 
/* Function prototypes */
 
#define IPT0()                                  (void)
#define IPT1(t1, n1)                            (t1 n1)
#define IPT2(t1, n1, t2, n2)                    (t1 n1, t2 n2)
#define IPT3(t1, n1, t2, n2, t3, n3)            (t1 n1, t2 n2, t3 n3)
#define IPT4(t1, n1, t2, n2, t3, n3, t4, n4)    (t1 n1, t2 n2, t3 n3, t4 n4)
#define IPT5(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5)
#define IPT6(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6)
#define IPT7(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7)
#define IPT8(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8)
#define IPT9(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9)
#define IPT10(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10)
#define IPT11(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11)
#define IPT12(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11, t12 n12)
#define IPT13(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11, t12 n12, t13 n13)
#define IPT14(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13, t14, n14) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11, t12 n12, t13 n13, t14 n14)
#define IPT15(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13, t14, n14, t15, n15) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11, t12 n12, t13 n13, t14 n14, t15 n15)
 
/* Function definitions */
 
#define IFN0()                                  (void)
#define IFN1(t1, n1)                            (t1 n1)
#define IFN2(t1, n1, t2, n2)                    (t1 n1, t2 n2)
#define IFN3(t1, n1, t2, n2, t3, n3)            (t1 n1, t2 n2, t3 n3)
#define IFN4(t1, n1, t2, n2, t3, n3, t4, n4)    (t1 n1, t2 n2, t3 n3, t4 n4)
#define IFN5(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5)
#define IFN6(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6)
#define IFN7(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7)
#define IFN8(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8)
#define IFN9(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9)
#define IFN10(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10)
#define IFN11(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11)
#define IFN12(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11, t12 n12)
#define IFN13(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11, t12 n12, t13 n13)
#define IFN14(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13, t14, n14) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11, t12 n12, t13 n13, t14 n14)
#define IFN15(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13, t14, n14, t15, n15) \
        (t1 n1, t2 n2, t3 n3, t4 n4, t5 n5, t6 n6, t7 n7, t8 n8, t9 n9, t10 n10, t11 n11, t12 n12, t13 n13, t14 n14, t15 n15)

#else   /* ANSI */
 
/* Function prototypes */
 
#define IPT0()                                                          ()
#define IPT1(t1, n1)                                                    ()
#define IPT2(t1, n1, t2, n2)                                            ()
#define IPT3(t1, n1, t2, n2, t3, n3)                                    ()
#define IPT4(t1, n1, t2, n2, t3, n3, t4, n4)                            ()
#define IPT5(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5)                    ()
#define IPT6(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6)            ()
#define IPT7(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7)    ()
#define IPT8(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8) \
        ()
#define IPT9(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9) \
        ()
#define IPT10(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10) \
        ()
#define IPT11(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11) \
        ()
#define IPT12(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12) \
        ()
#define IPT13(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13) \
        ()
#define IPT14(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13, t14, n14) \
        ()
#define IPT15(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13, t14, n14, t15, n15) \
        ()
 
/* Function definitions */
 
#define IFN0()                                  ()
#define IFN1(t1, n1)                            (n1) \
                                                t1 n1;
#define IFN2(t1, n1, t2, n2)                    (n1, n2) \
                                                t1 n1; t2 n2;
#define IFN3(t1, n1, t2, n2, t3, n3)            (n1, n2, n3) \
                                                t1 n1; t2 n2; t3 n3;
#define IFN4(t1, n1, t2, n2, t3, n3, t4, n4)    (n1, n2, n3, n4) \
                                                t1 n1; t2 n2; t3 n3; t4 n4;
#define IFN5(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5) \
                                                (n1, n2, n3, n4, n5) \
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5;
#define IFN6(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6) \
                                                (n1, n2, n3, n4, n5, n6) \
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6;
#define IFN7(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7) \
                                                (n1, n2, n3, n4, n5, n6, n7) \
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7;
#define IFN8(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8) \
                                               (n1, n2, n3, n4, n5, n6, n7, n8)\
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7; t8 n8;
#define IFN9(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9) \
                                               (n1, n2, n3, n4, n5, n6, n7, n8, n9)\
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7; t8 n8; t9 n9;
#define IFN10(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10) \
                                               (n1, n2, n3, n4, n5, n6, n7, n8, n9, n10)\
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7; t8 n8; t9 n9;t10 n10;
#define IFN11(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11) \
                                               (n1, n2, n3, n4, n5, n6, n7, n8,\
						n9, n10, n11)\
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7; t8 n8; \
						t9 n9;t10 n10;t11 n11;
#define IFN12(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12) \
                                               (n1, n2, n3, n4, n5, n6, n7, n8,\
						n9, n10, n11, n12)\
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7; t8 n8; \
						t9 n9;t10 n10;t11 n11;t12 n12;
#define IFN13(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13) \
                                               (n1, n2, n3, n4, n5, n6, n7, n8,\
						n9, n10, n11, n12, n13)\
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7; t8 n8; \
						t9 n9; t10 n10; t11 n11; \
						t12 n12; t13 n13;
#define IFN14(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13, t14, n14) \
                                               (n1, n2, n3, n4, n5, n6, n7, n8,\
						n9, n10, n11, n12, n13, n14)\
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7; t8 n8; \
						t9 n9; t10 n10; t11 n11; \
						t12 n12; t13 n13; t14 n14;
#define IFN15(t1, n1, t2, n2, t3, n3, t4, n4, t5, n5, t6, n6, t7, n7, t8, n8, t9, n9, t10, n10, t11, n11, t12, n12, t13, n13, t14, n14, t15, n15) \
                                               (n1, n2, n3, n4, n5, n6, n7, n8,\
						n9, n10, n11, n12, n13, n14, n15)\
                                                t1 n1; t2 n2; t3 n3; t4 n4; \
                                                t5 n5; t6 n6; t7 n7; t8 n8; \
						t9 n9; t10 n10; t11 n11; \
						t12 n12; t13 n13; t14 n14; \
						t15 n15;
#endif  /* ANSI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\build_id.h ===
/*[
 *	==========================================================================
 *
 *	Name:		build_id.h
 *
 *	Author:		J. Box
 *	
 * 	create on	May 26th 1994
 *
 *	SCCS ID:	@(#)build_id.h	1.274 07/17/95
 *
 *	Purpose:	This file contains the Version ID No.s for this release
 *			of the Base.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1994. All rights reserved.
 *
 *	==========================================================================
]*/

/*
 *	The build ID is of the form YMMDD and is squeezed into 16 bits in order
 *	to be able to be passed in a 16 bit intel register.
 *			S S S Y | Y Y Y M | M M M D | D D D D
 *			      12        8         4         0 
 *
 *	The top 3 bits are used to denote a 'Special' release that has deviated in
 *	some form from the official release. Lower case characters from a-g are
 *	used to denote these special releases, but are passed in the code below as
 *	integers from 0 to 7. 0 indicates official release, 1 indicates 1st special
 *	release (a), 2 indicates 2nd release (b), etc.etc.
 *
 *  WARNING WARNING WARNING
 *  Change the Numbers, but DO NOT CHANGE THE FORMAT OF THE FOLLOWING 4 LINES
 *  They are edited automatically by a build script that expects the format:-
 *	"define<space>DAY|MONTH|YEAR|SPECIAL<tab><tab>No."
 */

#define DAY		16		/* 1-31		5 bits	*/
#define MONTH		7		/* 1-12		4 bits	*/
#define YEAR		5		/* 0-9		4 bits	*/
#define SPECIAL		0		/* 0 - 7	3 bits; 1=a,2=b,3=c,4=d,5=e,6=f,7=g */

#define BUILD_ID_CODE	((DAY & 0x1f) | ((MONTH & 0xf)<<5) | ((YEAR & 0xf)<<9 ) | ((SPECIAL & 7)<<13))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\bios.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: BIOS definitions
 *
 * Description	: Defintions for users of the BIOS
 *
 * Author	: Henry Nash
 *
 * Notes	: This is a copy of bios.h from henry/kernel taken on
 *		  17 dec 86. Several lines have been added to support
 *		  the hard disk bios (marked HD-dr). See also bios.c.
 *
 * Mods: (r2.21): Added an external declaration of rom_basic().
 */

/* SccsID[]="@(#)bios.h	1.47 06/28/95 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * The following define the BOP call numbers for the BIOS functions.
 */

#define BIOS_RESET		0x0
#define BIOS_DUMMY_INT		0x1
#define BIOS_UNEXP_INT		0x2
#define BIOS_DRIVER_INCOMPAT	0x7
#define BIOS_TIMER_INT		0x8
#define BIOS_KB_INT		0x9
#define BIOS_DISK_INT		0xD	
#define BIOS_DISKETTE_INT	0xE
#define BIOS_PRINT_SCREEN	0x5
#define BIOS_VIDEO_IO		0x10
#define BIOS_EQUIPMENT		0x11
#define BIOS_MEMORY_SIZE	0x12
#define BIOS_DISK_IO		0x13
#define BIOS_RS232_IO		0x14
#define BIOS_CASSETTE_IO	0x15
#define BIOS_KEYBOARD_IO	0x16
#define BIOS_PRINTER_IO		0x17
#define BIOS_BASIC		0x18
#define BIOS_BOOT_STRAP		0x19
#define BIOS_TIME_OF_DAY	0x1A
#define BIOS_KEYBOARD_BREAK	0x1B
#define BIOS_USER_TIMER_INT	0x1C
#define BIOS_EXTEND_CHAR	0x1F
#define BIOS_DISKETTE_IO	0x40
#define EGA_FONT_INT		0x43	/* Pointer for the EGA graphics font */

/*
 * Private bootstrap functions
 */

#define BIOS_BOOTSTRAP_1	0x90
#define BIOS_BOOTSTRAP_2	0x91
#define BIOS_BOOTSTRAP_3	0x92

/*
 * Private diskette functions
 */

#define BIOS_FL_OPERATION_1	0xA0
#define BIOS_FL_OPERATION_2	0xA1
#define BIOS_FL_OPERATION_3	0xA2
#define BIOS_FL_RESET_2		0xA3

/*
 * Private hard disk function
 */

#define BIOS_HDA_COMMAND_CHECK	0xB0

/*
 * Mouse driver functions
 */

#define BIOS_MOUSE_INSTALL1	0xB8
#define BIOS_MOUSE_INSTALL2	0xB9
#define BIOS_MOUSE_INT1	0xBA
#define BIOS_MOUSE_INT2		0xBB
#define BIOS_MOUSE_IO_LANGUAGE	0xBC
#define BIOS_MOUSE_IO_INTERRUPT	0xBD
#define BIOS_MOUSE_VIDEO_IO	0xBE

/*
 * Get date function
 */

#define BIOS_GETDATE		0xBF

/*
 * Re-entrant CPU return function
 */

#define BIOS_CPU_RETURN		0xFE

/*
 * The following defines the structure of the Bios internal storage area.
 */

#define BIOS_VAR_SEGMENT	0x40
#define BIOS_VAR_START		((sys_addr)BIOS_VAR_SEGMENT * 16L)

/*
 * Address of memory size bios word variable.
 */

#define MEMORY_VAR            (BIOS_VAR_START + 0x13)

/*
 * The Bios FDC result data storage area
 */

#define BIOS_FDC_STATUS_BLOCK	BIOS_VAR_START + 0x42

/*
 * The BIOS hard disk data area. These variables are updated to their correct
 * values before every exit from disk_io.c/disk.c to the cpu.
*/

#define CMD_BLOCK	BIOS_VAR_START + 0x42

/*
 * The Bios Reset Flag
 */

#define RESET_FLAG	BIOS_VAR_START + 0x72

#define DISK_STATUS	BIOS_VAR_START + 0x74
#define HF_NUM		BIOS_VAR_START + 0x75
#define CONTROL_BYTE	BIOS_VAR_START + 0x76
#define PORT_OFF	BIOS_VAR_START + 0x77

/*
 * Bios Buffer space
 */

typedef union {
                 word wd;
                 struct {
                          half_word scan;
                          half_word ch;
                        } byte;
               } KEY_OCCURRENCE;

#define BIOS_KB_BUFFER_START    (BIOS_VAR_START + 0x80)
#define BIOS_KB_BUFFER_END      (BIOS_VAR_START + 0x82)
#define BIOS_KB_BUFFER_HEAD     (BIOS_VAR_START + 0x1a)
#define BIOS_KB_BUFFER_TAIL     (BIOS_VAR_START + 0x1c)
#define BIOS_KB_BUFFER          0x1e
#define BIOS_KB_BUFFER_SIZE     16

#define BIOS_VIRTUALISING_BYTE     (BIOS_VAR_START + 0xAC)

#define SOFT_FLAG	0x1234 		/* value indicating a soft reset */

/*
 * The number of diskettes supported by the Bios
 */

#define MAX_DISKETTES	4


#define	MODEL_BYTE		0xfc	/* system model byte		*/
#define SUB_MODEL_BYTE		02	/* system sub model type byte	*/
#define BIOS_LEVEL		0	/* BIOS revision level		*/

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

extern void (*BIOS[]) IPT0();

#ifndef bop
#define bop(n) (*BIOS[n])()
#endif /* bop */

#ifdef PTY
extern void com_bop_pty IPT0();
#endif

#ifdef GEN_DRVR
extern void gen_driver_io IPT0();
#endif

#ifdef LIM
extern void emm_init IPT0();
extern void emm_io IPT0();
extern void return_from_call IPT0();
#endif

#ifdef SUSPEND
extern void send_script IPT0();
#endif

#ifdef CDROM
extern void cdrom_ord_fns IPT0();
extern void cdrom_ext_fns IPT0();
extern void bcdrom_io IPT0();
#endif /* CDROM */

extern void worm_init IPT0();
extern void worm_io IPT0();

extern void cmd_install IPT0();
extern void cmd_load IPT0();

#ifdef DPMI
extern void DPMI_2F IPT0();
extern void DPMI_31 IPT0();
extern void DPMI_general IPT0();
extern void DPMI_int IPT0();
extern void DPMI_r0_int IPT0();
extern void DPMI_exc IPT0();
extern void DPMI_4B IPT0();
#endif

extern void reset IPT0();
extern void illegal_bop IPT0();
extern void illegal_op_int IPT0();
extern void illegal_dvr_bop IPT0();
extern void video_io IPT0();
extern void equipment IPT0();
extern void memory_size IPT0();
extern void diskette_io IPT0();
extern void diskette_int IPT0();
extern void disk_int IPT0();
extern void not_supported IPT0();
extern void rom_basic IPT0();
extern void keyboard_io IPT0();
extern void keyboard_int IPT0();
extern void printer_io IPT0();
extern void bootstrap IPT0();
extern void time_of_day IPT0();
extern void kb_idle_poll IPT0();
extern void time_int IPT0();
extern void disk_io IPT0();
extern void print_screen IPT0();
extern void rs232_io IPT0();
extern void dummy_int IPT0();
extern void unexpected_int IPT0();
extern void Get_build_id IPT0();

#ifdef WIN_VTD
extern void VtdTickSync IPT0();
#endif /* WIN_VTD */

#ifdef EGG
extern void ega_video_io IPT0();
#endif

extern void re_direct IPT0();
extern void D11_int IPT0();
extern void int_287 IPT0();

extern void mouse_install1 IPT0();
extern void mouse_install2 IPT0();
extern void mouse_int1 IPT0();
extern void mouse_int2 IPT0();
extern void mouse_io_interrupt IPT0();
extern void mouse_io_language IPT0();
extern void mouse_video_io IPT0();
extern void mouse_EM_callback IPT0();

extern void host_mouse_install1 IPT0();
extern void host_mouse_install2 IPT0();

extern void time_of_day_init IPT0();
extern void keyboard_init IPT0();

extern void cassette_io IPT0();

extern void fl_operation1 IPT0();
extern void fl_operation2 IPT0();
extern void fl_operation3 IPT0();
extern void fl_reset2 IPT0();
extern void fl_dummy IPT0();

extern void hda_command_check IPT0();	/* HD-dr */

extern void host_unsimulate IPT0();

extern void bootstrap1 IPT0();
extern void bootstrap2 IPT0();
extern void bootstrap3 IPT0();

#ifdef NOVELL
extern void DriverInitialize IPT0();
extern void DriverReadPacket IPT0();
extern void DriverSendPacket IPT0();
extern void DriverMulticastChange IPT0();
extern void DriverCloseSocket IPT0();
extern void DriverReset IPT0();
extern void DriverShutdown IPT0();
extern void DriverAddProtocol IPT0();
extern void DriverChangePromiscuous IPT0() ;
extern void DriverOpenSocket IPT0() ;
extern void DriverCloseSocket IPT0() ;
#ifdef NOVELL_CFM
extern void DriverCheckForMore IPT0() ;
#endif
#ifdef V4CLIENT
extern void DriverChangeIntStatus IPT0() ;
#endif	/* V4CLIENT */
#endif

#ifdef	MSWDVR
extern void ms_windows IPT0();
extern void msw_mouse IPT0();
extern void msw_copy IPT0();
extern void msw_copyInit IPT0();
extern void msw_keybd IPT0();
#endif

#ifdef	NOVELL_IPX
extern void IPXResInit  IPT0();
extern void IPXResEntry  IPT0();
extern void IPXResInterrupt  IPT0();
#endif

#ifdef	NOVELL_TCPIP
extern void TCPResInit  IPT0();
extern void TCPResEntry  IPT0();
#endif

#ifdef WINSOCK
extern void ISWSEntry IPT0();
#endif /* WINSOCK */

#ifdef SWINAPI
extern void User_call IPT0();
extern void Gdi_call IPT0();
extern void Swinapi_bop IPT0();
#endif /* SWINAPI */

#if	defined(SOFTWIN_API) || defined(SWIN_HFX)
extern void SoftWindowsInit IPT0();
extern void SoftWindowsTerm IPT0();
#endif	/* SOFTWIN_API or SWIN_HFX */

#if	defined(SOFTWIN_API)
extern void SoftWindowsApi IPT0();
#endif	/* SOFTWIN_API */

#ifdef SWIN_HAW
extern void msw_sound IPT0();
#endif	/* SWIN_HAW */

#ifdef ANSI
extern void host_reset(void);
#ifndef NTVDM
extern void reboot(void);
#endif /* ! NTVDM */
extern void display_string(char *);
extern void clear_string(void);
#else
extern void host_reset IPT0();
#ifndef NTVDM
extern void reboot IPT0();
#endif /* ! NTVDM */
extern void display_string IPT0();
extern void clear_string IPT0();
#endif /* ANSI */

#ifdef ANSI
extern void smeg_collect_data(void);
extern void smeg_freeze_data(void);
#else
extern void smeg_collect_data IPT0();
extern void smeg_freeze_data IPT0();
#endif /* ANSI */

extern void softpc_version IPT0();

#ifdef NTVDM
/* MS bop stubs */
extern void MS_bop_0(void), MS_bop_1(void), MS_bop_2(void);
extern void MS_bop_3(void), MS_bop_4(void), MS_bop_5(void);
extern void MS_bop_6(void), MS_bop_7(void), MS_bop_8(void);
extern void MS_bop_9(void), MS_bop_A(void), MS_bop_B(void);
extern void MS_bop_C(void), MS_bop_D(void), MS_bop_E(void);
extern void MS_bop_F(void);
extern void switch_to_real_mode(void);
#ifdef JAPAN
extern void MS_DosV_bop(void);
#elif defined(KOREA) // JAPAN
extern void MS_HDos_bop(void);
#endif // KOREA
#endif	/* NTVDM */

#ifdef GISP_CPU
extern void hg_bop_handler IPT0();
#endif	/* GISP_CPU */

#ifdef HFX
extern void test_for_us IPT0();
#endif /* HFX */

#ifdef DOS_APP_LIC
extern void DOS_AppLicense IPT0();
#endif

IMPORT int soft_reset;

#if	defined(SPC386) && defined(WDCTRL_BOP)
extern void wdctrl_bop IPT0();
#endif	/* SPC386 && WDCTRL_BOP */

#if defined(NEC_98)
//
// BIOS common area define for PC-9800
//

#define BIOS_NEC98_VAR_SEGMENT      0x0
#define BIOS_NEC98_VAR_START        ((sys_addr)BIOS_VAR_SEGMENT * 16L)

#define BIOS_NEC98_BIOS_FLAG2       0x0400
#define BIOS_NEC98_EXPMMSZ          0x0401
#define BIOS_NEC98_SYS_SEL          0x0402
#define BIOS_NEC98_WIN_386          0x0403
#define BIOS_NEC98_USER_SP          0x0404
#define BIOS_NEC98_USER_SS          0x0406
#define BIOS_NEC98_KB_SHIFT_COD     0x0408
#define BIOS_NEC98_KB_BUFFER_ADR    0x0410
#define BIOS_NEC98_KB_ENTRY_TBL_ADR 0x0414
#define BIOS_NEC98_KB_INT_ADR       0x0418
#define BIOS_NEC98_PR_TIME          0x041C
#define BIOS_NEC98_VD_PRT           0x041E
#define BIOS_NEC98_VD_NUL           0x0423
#define BIOS_NEC98_VD_REMAIN_SEC    0x0424
#define BIOS_NEC98_VD_REMAIN_LEN    0x0426
#define BIOS_NEC98_VD_DATA_OFF      0x0428
#define BIOS_NEC98_VDISK_EQUIP      0x042A
#define BIOS_NEC98_BRANCH_INT       0x042B
#define BIOS_NEC98_BRANCH_WORK      0x042C
#define BIOS_NEC98_VD_BOOT_WORK     0x0430
#define BIOS_NEC98_VD_ADD           0x0440
#define BIOS_NEC98_CAL_ROOT_LST     0x0444
#define BIOS_NEC98_CAL_BEEP_TIME    0x0448
#define BIOS_NEC98_CAL_TONE         0x044A
#define BIOS_NEC98_CAL_USER_OFF     0x044C
#define BIOS_NEC98_CAL_USER_SEG     0x044E
#define BIOS_NEC98_CRT_FONT         0x0450
#define BIOS_NEC98_CRT_P1           0x0452
#define BIOS_NEC98_CRT_P2           0x0453
#define BIOS_NEC98_CRT_P3           0x0454
#define BIOS_NEC98_MODE_CONTROL     0x0455
#define BIOS_NEC98_IN_BIOS          0x0456
#define BIOS_NEC98_AT_SWITCH        0x0457
#define BIOS_NEC98_BIOS_FLAG5       0x0458
#define BIOS_NEC98_CR_EXT_STS       0x0459
#define BIOS_NEC98_BIOS_FLAG6       0x045A
#define BIOS_NEC98_BIOS_FLAG7       0x045B
#define BIOS_NEC98_BIOS_FLAG8       0x045C
#define BIOS_NEC98_DISK_INF         0x0460
#define BIOS_NEC98_BIOS_FLAG1       0x0480
#define BIOS_NEC98_BIOS_FLAG3       0x0481
#define BIOS_NEC98_DISK_EQUIPS      0x0482
#define BIOS_NEC98_SCSI_WORK        0x0483
#define BIOS_NEC98_BIOS_FLAG4       0x0484
#define BIOS_NEC98_F2HD_TIME        0x0485
#define BIOS_NEC98_CPU_STEP         0x0486
#define BIOS_NEC98_RDISK_EQUIP      0x0488
#define BIOS_NEC98_RDISK_EXIT       0x0489
#define BIOS_NEC98_RDISK_STATUS     0x048E
#define BIOS_NEC98_OMNI_FLAG        0x048F
#define BIOS_NEC98_BEEP_TONE        0x0490
#define BIOS_NEC98_DISK_RESET       0x0492
#define BIOS_NEC98_F2HD_MODE        0x0493
#define BIOS_NEC98_DISK_EQUIP2      0x0494
#define BIOS_NEC98_GRAPH_CHG        0x0495
#define BIOS_NEC98_GRAPH_TAI        0x0496
#define BIOS_NEC98_OMNI_INTB1       0x049A
#define BIOS_NEC98_OMNI_B1OF        0x049C
#define BIOS_NEC98_OMNI_B2SE        0x049E
#define BIOS_NEC98_OMNI_INT1B       0x04A0
#define BIOS_NEC98_OMNI_1BOF        0x04A2
#define BIOS_NEC98_OMNI_1BSE        0x04A4
#define BIOS_NEC98_OMNI_INT1A       0x04A6
#define BIOS_NEC98_OMNI_1AOF        0x04A8
#define BIOS_NEC98_OMNI_1ASE        0x04AA
#define BIOS_NEC98_XROM_PTR         0x04AC
#define BIOS_NEC98_DISK_XROM        0x04B0
#define BIOS_NEC98_XROM_ID          0x04C0
#define BIOS_NEC98_ROM_XCHG         0x04F8
#define BIOS_NEC98_ROM_OFS          0x04FA
#define BIOS_NEC98_ROM_SEG          0x04FC
#define BIOS_NEC98_SCLK_USER        0x04FE
#define BIOS_NEC98_BIOS_FLAG        0x0500
#define BIOS_NEC98_KB_BUF           0x0502
#define BIOS_NEC98_KB_KEY_BUFFER    0x0502
#define BIOS_NEC98_KB_SHFT_TBL      0x0522
#define BIOS_NEC98_KB_BUFFER_SIZ    0x0522
#define BIOS_NEC98_KB_BUF_HEAD      0x0524
#define BIOS_NEC98_KB_HEAD_POINTER  0x0524
#define BIOS_NEC98_KB_BUF_TAIL      0x0526
#define BIOS_NEC98_KB_TAIL_POINTER  0x0526
#define BIOS_NEC98_KB_COUNT         0x0528
#define BIOS_NEC98_KB_BUFFER_COUNTER        0x0528
#define BIOS_NEC98_KB_RETRY         0x0529
#define BIOS_NEC98_KB_RETRY_COUNTER 0x0529
#define BIOS_NEC98_KB_KY_STS        0x052A
#define BIOS_NEC98_KB_KEY_STS_TBL   0x052A
#define BIOS_NEC98_KB_SHFT_STS      0x053A
#define BIOS_NEC98_KB_SHIFT_STS     0x053A
#define BIOS_NEC98_CR_RASTER        0x053B
#define BIOS_NEC98_CRT_RASTER       0x053B
#define BIOS_NEC98_CR_STS_FLAG      0x053C
#define BIOS_NEC98_CR_CNT           0x053D
#define BIOS_NEC98_CRT_CNT          0x053D
#define BIOS_NEC98_CR_OFST          0x053E
#define BIOS_NEC98_CRT_PRM_OFST     0x053E
#define BIOS_NEC98_CR_SEG_ADR       0x0540
#define BIOS_NEC98_CRT_PRM_SEG      0x0540
#define BIOS_NEC98_CR_V_INT_OFST    0x0542
#define BIOS_NEC98_CRTV_OFST        0x0542
#define BIOS_NEC98_CR_V_INT_SEG     0x0544
#define BIOS_NEC98_CRTV_SEG         0x0544
#define BIOS_NEC98_CR_FONT          0x0546
#define BIOS_NEC98_CRT_FLAG         0x0546
#define BIOS_NEC98_CR_WINDW_NO      0x0547
#define BIOS_NEC98_CRT_W_NO         0x0547
#define BIOS_NEC98_CR_W_VRAMADR     0x0548
#define BIOS_NEC98_CRT_W_ADR        0x0548
#define BIOS_NEC98_CR_W_RASTER      0x054A
#define BIOS_NEC98_CRT_W_RASTER     0x054A
#define BIOS_NEC98_PRXCRT           0x054C
#define BIOS_NEC98_PRXDUPD          0x054D
#define BIOS_NEC98_PRXGCPTN         0x054E
#define BIOS_NEC98_PRXGLS           0x054E
#define BIOS_NEC98_RS_OFST_ADR      0x0556
#define BIOS_NEC98_RS_CH0_OFST      0x0556
#define BIOS_NEC98_RS_SEG_ADR       0x0558
#define BIOS_NEC98_RS_CH0_SEG       0x0558
#define BIOS_NEC98_RS_SIFT          0x055A
#define BIOS_NEC98_RS_S_FLAG        0x055B
#define BIOS_NEC98_DISK_EQUIP       0x055C
#define BIOS_NEC98_DISK_INT         0x055E
#define BIOS_NEC98_DISK_TYPE        0x0560
#define BIOS_NEC98_DISK_MODE        0x0561
#define BIOS_NEC98_DISK_TIME        0x0562
#define BIOS_NEC98_DISK_RESULT      0x0564
#define BIOS_NEC98_DISK_BOOT        0x0584
#define BIOS_NEC98_DISK_STATUS      0x0585
#define BIOS_NEC98_DISK_SENSE       0x0586
#define BIOS_NEC98_CA_TIM_CNT       0x058A
#define BIOS_NEC98_DISK_WORK        0x058C
#define BIOS_NEC98_DISK_SEG         0x058E
#define BIOS_NEC98_HDSK_MOD2        0x0590
#define BIOS_NEC98_DMA_ALLOC_TBL    0x0591
#define BIOS_NEC98_NMI_STATUS1      0x0592
#define BIOS_NEC98_NMI_STATUS2      0x0593
#define BIOS_NEC98_EXPMMSZ2         0x0594
#define BIOS_NEC98_SLOW_GEAR        0x0596
#define BIOS_NEC98_PRXCRT2          0x0597
#define BIOS_NEC98_AT_TIME          0x0598
#define BIOS_NEC98_AT_MOFF          0x059A
#define BIOS_NEC98_RDISK_BANK       0x059C
#define BIOS_NEC98_CTRL_FLAG        0x059E
#define BIOS_NEC98_SCLK_COUNT       0x05A0
#define BIOS_NEC98_SAVE_MODE        0x05A1
#define BIOS_NEC98_SAVE_COUNT       0x05A2
#define BIOS_NEC98_FD_READY_STS     0x05A4
#define BIOS_NEC98_DISK_EQUIPS2     0x05A5
#define BIOS_NEC98_CARD_STATUS      0x05A6
#define BIOS_NEC98_CARD_STATUS2     0x05A7
#define BIOS_NEC98_CARD_EQUIP       0x05A8
#define BIOS_NEC98_ASP_FLAG         0x05BD
#define BIOS_NEC98_ASP_SLOT         0x05BE
#define BIOS_NEC98_BASIC_DIPSW      0x05C0
#define BIOS_NEC98_RS_D_FLAG        0x05C1
#define BIOS_NEC98_GPIBWORK         0x05C2
#define BIOS_NEC98_KB_CODE          0x05C6
#define BIOS_NEC98_F2DD_MODE        0x05CA
#define BIOS_NEC98_F2DD_COUNT       0x05CB
#define BIOS_NEC98_F2DD_POINTER     0x05CC
#define BIOS_NEC98_F2DD_RESULT      0x05D0
#define BIOS_NEC98_MUSIC_WORK       0x05E0
#define BIOS_NEC98_V_VOL_TYPE       0x05E4
#define BIOS_NEC98_OMNI_SERVER      0x05E6
#define BIOS_NEC98_OMNI_STATION     0x05E7
#define BIOS_NEC98_DISK_PRM0        0x05E8
#define BIOS_NEC98_DISK_PRM1        0x05EC
#define BIOS_NEC98_RS_CH1_OFST      0x05F0
#define BIOS_NEC98_RS_CH1_SEG       0x05F2
#define BIOS_NEC98_RS_CH2_OFST      0x05F4
#define BIOS_NEC98_RS_CH2_SEG       0x05F6
#define BIOS_NEC98_F2HD_POINTER     0x05F8
#define BIOS_NEC98_MOUSEW           0x05FC
#define BIOS_NEC98_BASIC_LDSR       0x05FE

extern  BOOL HIRESO_MODE;
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\acc_efi.h ===
/*    0 0000  NA   SZ_B    DFLT   DS */		ACCESS_NA_NA,
/*    1 0001  NA   SZ_B    DFLT   SS */		ACCESS_NA_NA,
/*    2 0010  NA   SZ_B    ES     DS */		ACCESS_NA_NA,
/*    3 0011  NA   SZ_B    ES     SS */		ACCESS_NA_NA,
/*    4 0020  NA   SZ_B    CS     DS */		ACCESS_NA_NA,
/*    5 0021  NA   SZ_B    CS     SS */		ACCESS_NA_NA,
/*    6 0030  NA   SZ_B    SS     DS */		ACCESS_NA_NA,
/*    7 0031  NA   SZ_B    SS     SS */		ACCESS_NA_NA,
/*    8 0040  NA   SZ_B    DS     DS */		ACCESS_NA_NA,
/*    9 0041  NA   SZ_B    DS     SS */		ACCESS_NA_NA,
/*   10 0050  NA   SZ_B    FS     DS */		ACCESS_NA_NA,
/*   11 0051  NA   SZ_B    FS     SS */		ACCESS_NA_NA,
/*   12 0060  NA   SZ_B    GS     DS */		ACCESS_NA_NA,
/*   13 0061  NA   SZ_B    GS     SS */		ACCESS_NA_NA,
/*   14 0070  NA   SZ_B    -      DS */		ACCESS_NA_NA,
/*   15 0071  NA   SZ_B    -      SS */		ACCESS_NA_NA,
/*   16 0100  NA   SZ_B    DFLT   DS */		ACCESS_NA_NA,
/*   17 0101  NA   SZ_B    DFLT   SS */		ACCESS_NA_NA,
/*   18 0110  NA   SZ_B    ES     DS */		ACCESS_NA_NA,
/*   19 0111  NA   SZ_B    ES     SS */		ACCESS_NA_NA,
/*   20 0120  NA   SZ_B    CS     DS */		ACCESS_NA_NA,
/*   21 0121  NA   SZ_B    CS     SS */		ACCESS_NA_NA,
/*   22 0130  NA   SZ_B    SS     DS */		ACCESS_NA_NA,
/*   23 0131  NA   SZ_B    SS     SS */		ACCESS_NA_NA,
/*   24 0140  NA   SZ_B    DS     DS */		ACCESS_NA_NA,
/*   25 0141  NA   SZ_B    DS     SS */		ACCESS_NA_NA,
/*   26 0150  NA   SZ_B    FS     DS */		ACCESS_NA_NA,
/*   27 0151  NA   SZ_B    FS     SS */		ACCESS_NA_NA,
/*   28 0160  NA   SZ_B    GS     DS */		ACCESS_NA_NA,
/*   29 0161  NA   SZ_B    GS     SS */		ACCESS_NA_NA,
/*   30 0170  NA   SZ_B    -      DS */		ACCESS_NA_NA,
/*   31 0171  NA   SZ_B    -      SS */		ACCESS_NA_NA,
/*   32 0200  NA   SZ_W    DFLT   DS */		ACCESS_NA_NA,
/*   33 0201  NA   SZ_W    DFLT   SS */		ACCESS_NA_NA,
/*   34 0210  NA   SZ_W    ES     DS */		ACCESS_NA_NA,
/*   35 0211  NA   SZ_W    ES     SS */		ACCESS_NA_NA,
/*   36 0220  NA   SZ_W    CS     DS */		ACCESS_NA_NA,
/*   37 0221  NA   SZ_W    CS     SS */		ACCESS_NA_NA,
/*   38 0230  NA   SZ_W    SS     DS */		ACCESS_NA_NA,
/*   39 0231  NA   SZ_W    SS     SS */		ACCESS_NA_NA,
/*   40 0240  NA   SZ_W    DS     DS */		ACCESS_NA_NA,
/*   41 0241  NA   SZ_W    DS     SS */		ACCESS_NA_NA,
/*   42 0250  NA   SZ_W    FS     DS */		ACCESS_NA_NA,
/*   43 0251  NA   SZ_W    FS     SS */		ACCESS_NA_NA,
/*   44 0260  NA   SZ_W    GS     DS */		ACCESS_NA_NA,
/*   45 0261  NA   SZ_W    GS     SS */		ACCESS_NA_NA,
/*   46 0270  NA   SZ_W    -      DS */		ACCESS_NA_NA,
/*   47 0271  NA   SZ_W    -      SS */		ACCESS_NA_NA,
/*   48 0300  NA   SZ_D    DFLT   DS */		ACCESS_NA_NA,
/*   49 0301  NA   SZ_D    DFLT   SS */		ACCESS_NA_NA,
/*   50 0310  NA   SZ_D    ES     DS */		ACCESS_NA_NA,
/*   51 0311  NA   SZ_D    ES     SS */		ACCESS_NA_NA,
/*   52 0320  NA   SZ_D    CS     DS */		ACCESS_NA_NA,
/*   53 0321  NA   SZ_D    CS     SS */		ACCESS_NA_NA,
/*   54 0330  NA   SZ_D    SS     DS */		ACCESS_NA_NA,
/*   55 0331  NA   SZ_D    SS     SS */		ACCESS_NA_NA,
/*   56 0340  NA   SZ_D    DS     DS */		ACCESS_NA_NA,
/*   57 0341  NA   SZ_D    DS     SS */		ACCESS_NA_NA,
/*   58 0350  NA   SZ_D    FS     DS */		ACCESS_NA_NA,
/*   59 0351  NA   SZ_D    FS     SS */		ACCESS_NA_NA,
/*   60 0360  NA   SZ_D    GS     DS */		ACCESS_NA_NA,
/*   61 0361  NA   SZ_D    GS     SS */		ACCESS_NA_NA,
/*   62 0370  NA   SZ_D    -      DS */		ACCESS_NA_NA,
/*   63 0371  NA   SZ_D    -      SS */		ACCESS_NA_NA,
/*   64 0400  NA   SZ_W    DFLT   DS */		ACCESS_NA_NA,
/*   65 0401  NA   SZ_W    DFLT   SS */		ACCESS_NA_NA,
/*   66 0410  NA   SZ_W    ES     DS */		ACCESS_NA_NA,
/*   67 0411  NA   SZ_W    ES     SS */		ACCESS_NA_NA,
/*   68 0420  NA   SZ_W    CS     DS */		ACCESS_NA_NA,
/*   69 0421  NA   SZ_W    CS     SS */		ACCESS_NA_NA,
/*   70 0430  NA   SZ_W    SS     DS */		ACCESS_NA_NA,
/*   71 0431  NA   SZ_W    SS     SS */		ACCESS_NA_NA,
/*   72 0440  NA   SZ_W    DS     DS */		ACCESS_NA_NA,
/*   73 0441  NA   SZ_W    DS     SS */		ACCESS_NA_NA,
/*   74 0450  NA   SZ_W    FS     DS */		ACCESS_NA_NA,
/*   75 0451  NA   SZ_W    FS     SS */		ACCESS_NA_NA,
/*   76 0460  NA   SZ_W    GS     DS */		ACCESS_NA_NA,
/*   77 0461  NA   SZ_W    GS     SS */		ACCESS_NA_NA,
/*   78 0470  NA   SZ_W    -      DS */		ACCESS_NA_NA,
/*   79 0471  NA   SZ_W    -      SS */		ACCESS_NA_NA,
/*   80 0500  NA   -       DFLT   DS */		ACCESS_NA_NA,
/*   81 0501  NA   -       DFLT   SS */		ACCESS_NA_NA,
/*   82 0510  NA   -       ES     DS */		ACCESS_NA_NA,
/*   83 0511  NA   -       ES     SS */		ACCESS_NA_NA,
/*   84 0520  NA   -       CS     DS */		ACCESS_NA_NA,
/*   85 0521  NA   -       CS     SS */		ACCESS_NA_NA,
/*   86 0530  NA   -       SS     DS */		ACCESS_NA_NA,
/*   87 0531  NA   -       SS     SS */		ACCESS_NA_NA,
/*   88 0540  NA   -       DS     DS */		ACCESS_NA_NA,
/*   89 0541  NA   -       DS     SS */		ACCESS_NA_NA,
/*   90 0550  NA   -       FS     DS */		ACCESS_NA_NA,
/*   91 0551  NA   -       FS     SS */		ACCESS_NA_NA,
/*   92 0560  NA   -       GS     DS */		ACCESS_NA_NA,
/*   93 0561  NA   -       GS     SS */		ACCESS_NA_NA,
/*   94 0570  NA   -       -      DS */		ACCESS_NA_NA,
/*   95 0571  NA   -       -      SS */		ACCESS_NA_NA,
/*   96 0600  NA   SZ_W2   DFLT   DS */		ACCESS_NA_NA,
/*   97 0601  NA   SZ_W2   DFLT   SS */		ACCESS_NA_NA,
/*   98 0610  NA   SZ_W2   ES     DS */		ACCESS_NA_NA,
/*   99 0611  NA   SZ_W2   ES     SS */		ACCESS_NA_NA,
/*  100 0620  NA   SZ_W2   CS     DS */		ACCESS_NA_NA,
/*  101 0621  NA   SZ_W2   CS     SS */		ACCESS_NA_NA,
/*  102 0630  NA   SZ_W2   SS     DS */		ACCESS_NA_NA,
/*  103 0631  NA   SZ_W2   SS     SS */		ACCESS_NA_NA,
/*  104 0640  NA   SZ_W2   DS     DS */		ACCESS_NA_NA,
/*  105 0641  NA   SZ_W2   DS     SS */		ACCESS_NA_NA,
/*  106 0650  NA   SZ_W2   FS     DS */		ACCESS_NA_NA,
/*  107 0651  NA   SZ_W2   FS     SS */		ACCESS_NA_NA,
/*  108 0660  NA   SZ_W2   GS     DS */		ACCESS_NA_NA,
/*  109 0661  NA   SZ_W2   GS     SS */		ACCESS_NA_NA,
/*  110 0670  NA   SZ_W2   -      DS */		ACCESS_NA_NA,
/*  111 0671  NA   SZ_W2   -      SS */		ACCESS_NA_NA,
/*  112 0700  NA   SZ_WD   DFLT   DS */		ACCESS_NA_NA,
/*  113 0701  NA   SZ_WD   DFLT   SS */		ACCESS_NA_NA,
/*  114 0710  NA   SZ_WD   ES     DS */		ACCESS_NA_NA,
/*  115 0711  NA   SZ_WD   ES     SS */		ACCESS_NA_NA,
/*  116 0720  NA   SZ_WD   CS     DS */		ACCESS_NA_NA,
/*  117 0721  NA   SZ_WD   CS     SS */		ACCESS_NA_NA,
/*  118 0730  NA   SZ_WD   SS     DS */		ACCESS_NA_NA,
/*  119 0731  NA   SZ_WD   SS     SS */		ACCESS_NA_NA,
/*  120 0740  NA   SZ_WD   DS     DS */		ACCESS_NA_NA,
/*  121 0741  NA   SZ_WD   DS     SS */		ACCESS_NA_NA,
/*  122 0750  NA   SZ_WD   FS     DS */		ACCESS_NA_NA,
/*  123 0751  NA   SZ_WD   FS     SS */		ACCESS_NA_NA,
/*  124 0760  NA   SZ_WD   GS     DS */		ACCESS_NA_NA,
/*  125 0761  NA   SZ_WD   GS     SS */		ACCESS_NA_NA,
/*  126 0770  NA   SZ_WD   -      DS */		ACCESS_NA_NA,
/*  127 0771  NA   SZ_WD   -      SS */		ACCESS_NA_NA,
/*  128 1000  RD   SZ_B    DFLT   DS */		ACCESS_DS_RD_B,
/*  129 1001  RD   SZ_B    DFLT   SS */		ACCESS_SS_RD_B,
/*  130 1010  RD   SZ_B    ES     DS */		ACCESS_ES_RD_B,
/*  131 1011  RD   SZ_B    ES     SS */		ACCESS_ES_RD_B,
/*  132 1020  RD   SZ_B    CS     DS */		ACCESS_CS_RD_B,
/*  133 1021  RD   SZ_B    CS     SS */		ACCESS_CS_RD_B,
/*  134 1030  RD   SZ_B    SS     DS */		ACCESS_SS_RD_B,
/*  135 1031  RD   SZ_B    SS     SS */		ACCESS_SS_RD_B,
/*  136 1040  RD   SZ_B    DS     DS */		ACCESS_DS_RD_B,
/*  137 1041  RD   SZ_B    DS     SS */		ACCESS_DS_RD_B,
/*  138 1050  RD   SZ_B    FS     DS */		ACCESS_FS_RD_B,
/*  139 1051  RD   SZ_B    FS     SS */		ACCESS_FS_RD_B,
/*  140 1060  RD   SZ_B    GS     DS */		ACCESS_GS_RD_B,
/*  141 1061  RD   SZ_B    GS     SS */		ACCESS_GS_RD_B,
/*  142 1070  RD   SZ_B    -      DS */		ACCESS_NA_NA,
/*  143 1071  RD   SZ_B    -      SS */		ACCESS_NA_NA,
/*  144 1100  RD   SZ_B    DFLT   DS */		ACCESS_DS_RD_B,
/*  145 1101  RD   SZ_B    DFLT   SS */		ACCESS_SS_RD_B,
/*  146 1110  RD   SZ_B    ES     DS */		ACCESS_ES_RD_B,
/*  147 1111  RD   SZ_B    ES     SS */		ACCESS_ES_RD_B,
/*  148 1120  RD   SZ_B    CS     DS */		ACCESS_CS_RD_B,
/*  149 1121  RD   SZ_B    CS     SS */		ACCESS_CS_RD_B,
/*  150 1130  RD   SZ_B    SS     DS */		ACCESS_SS_RD_B,
/*  151 1131  RD   SZ_B    SS     SS */		ACCESS_SS_RD_B,
/*  152 1140  RD   SZ_B    DS     DS */		ACCESS_DS_RD_B,
/*  153 1141  RD   SZ_B    DS     SS */		ACCESS_DS_RD_B,
/*  154 1150  RD   SZ_B    FS     DS */		ACCESS_FS_RD_B,
/*  155 1151  RD   SZ_B    FS     SS */		ACCESS_FS_RD_B,
/*  156 1160  RD   SZ_B    GS     DS */		ACCESS_GS_RD_B,
/*  157 1161  RD   SZ_B    GS     SS */		ACCESS_GS_RD_B,
/*  158 1170  RD   SZ_B    -      DS */		ACCESS_NA_NA,
/*  159 1171  RD   SZ_B    -      SS */		ACCESS_NA_NA,
/*  160 1200  RD   SZ_W    DFLT   DS */		ACCESS_DS_RD_W,
/*  161 1201  RD   SZ_W    DFLT   SS */		ACCESS_SS_RD_W,
/*  162 1210  RD   SZ_W    ES     DS */		ACCESS_ES_RD_W,
/*  163 1211  RD   SZ_W    ES     SS */		ACCESS_ES_RD_W,
/*  164 1220  RD   SZ_W    CS     DS */		ACCESS_CS_RD_W,
/*  165 1221  RD   SZ_W    CS     SS */		ACCESS_CS_RD_W,
/*  166 1230  RD   SZ_W    SS     DS */		ACCESS_SS_RD_W,
/*  167 1231  RD   SZ_W    SS     SS */		ACCESS_SS_RD_W,
/*  168 1240  RD   SZ_W    DS     DS */		ACCESS_DS_RD_W,
/*  169 1241  RD   SZ_W    DS     SS */		ACCESS_DS_RD_W,
/*  170 1250  RD   SZ_W    FS     DS */		ACCESS_FS_RD_W,
/*  171 1251  RD   SZ_W    FS     SS */		ACCESS_FS_RD_W,
/*  172 1260  RD   SZ_W    GS     DS */		ACCESS_GS_RD_W,
/*  173 1261  RD   SZ_W    GS     SS */		ACCESS_GS_RD_W,
/*  174 1270  RD   SZ_W    -      DS */		ACCESS_NA_NA,
/*  175 1271  RD   SZ_W    -      SS */		ACCESS_NA_NA,
/*  176 1300  RD   SZ_D    DFLT   DS */		ACCESS_DS_RD_D,
/*  177 1301  RD   SZ_D    DFLT   SS */		ACCESS_SS_RD_D,
/*  178 1310  RD   SZ_D    ES     DS */		ACCESS_ES_RD_D,
/*  179 1311  RD   SZ_D    ES     SS */		ACCESS_ES_RD_D,
/*  180 1320  RD   SZ_D    CS     DS */		ACCESS_CS_RD_D,
/*  181 1321  RD   SZ_D    CS     SS */		ACCESS_CS_RD_D,
/*  182 1330  RD   SZ_D    SS     DS */		ACCESS_SS_RD_D,
/*  183 1331  RD   SZ_D    SS     SS */		ACCESS_SS_RD_D,
/*  184 1340  RD   SZ_D    DS     DS */		ACCESS_DS_RD_D,
/*  185 1341  RD   SZ_D    DS     SS */		ACCESS_DS_RD_D,
/*  186 1350  RD   SZ_D    FS     DS */		ACCESS_FS_RD_D,
/*  187 1351  RD   SZ_D    FS     SS */		ACCESS_FS_RD_D,
/*  188 1360  RD   SZ_D    GS     DS */		ACCESS_GS_RD_D,
/*  189 1361  RD   SZ_D    GS     SS */		ACCESS_GS_RD_D,
/*  190 1370  RD   SZ_D    -      DS */		ACCESS_NA_NA,
/*  191 1371  RD   SZ_D    -      SS */		ACCESS_NA_NA,
/*  192 1400  RD   SZ_W    DFLT   DS */		ACCESS_DS_RD_W,
/*  193 1401  RD   SZ_W    DFLT   SS */		ACCESS_SS_RD_W,
/*  194 1410  RD   SZ_W    ES     DS */		ACCESS_ES_RD_W,
/*  195 1411  RD   SZ_W    ES     SS */		ACCESS_ES_RD_W,
/*  196 1420  RD   SZ_W    CS     DS */		ACCESS_CS_RD_W,
/*  197 1421  RD   SZ_W    CS     SS */		ACCESS_CS_RD_W,
/*  198 1430  RD   SZ_W    SS     DS */		ACCESS_SS_RD_W,
/*  199 1431  RD   SZ_W    SS     SS */		ACCESS_SS_RD_W,
/*  200 1440  RD   SZ_W    DS     DS */		ACCESS_DS_RD_W,
/*  201 1441  RD   SZ_W    DS     SS */		ACCESS_DS_RD_W,
/*  202 1450  RD   SZ_W    FS     DS */		ACCESS_FS_RD_W,
/*  203 1451  RD   SZ_W    FS     SS */		ACCESS_FS_RD_W,
/*  204 1460  RD   SZ_W    GS     DS */		ACCESS_GS_RD_W,
/*  205 1461  RD   SZ_W    GS     SS */		ACCESS_GS_RD_W,
/*  206 1470  RD   SZ_W    -      DS */		ACCESS_NA_NA,
/*  207 1471  RD   SZ_W    -      SS */		ACCESS_NA_NA,
/*  208 1500  RD   -       DFLT   DS */		ACCESS_NA_NA,
/*  209 1501  RD   -       DFLT   SS */		ACCESS_NA_NA,
/*  210 1510  RD   -       ES     DS */		ACCESS_NA_NA,
/*  211 1511  RD   -       ES     SS */		ACCESS_NA_NA,
/*  212 1520  RD   -       CS     DS */		ACCESS_NA_NA,
/*  213 1521  RD   -       CS     SS */		ACCESS_NA_NA,
/*  214 1530  RD   -       SS     DS */		ACCESS_NA_NA,
/*  215 1531  RD   -       SS     SS */		ACCESS_NA_NA,
/*  216 1540  RD   -       DS     DS */		ACCESS_NA_NA,
/*  217 1541  RD   -       DS     SS */		ACCESS_NA_NA,
/*  218 1550  RD   -       FS     DS */		ACCESS_NA_NA,
/*  219 1551  RD   -       FS     SS */		ACCESS_NA_NA,
/*  220 1560  RD   -       GS     DS */		ACCESS_NA_NA,
/*  221 1561  RD   -       GS     SS */		ACCESS_NA_NA,
/*  222 1570  RD   -       -      DS */		ACCESS_NA_NA,
/*  223 1571  RD   -       -      SS */		ACCESS_NA_NA,
/*  224 1600  RD   SZ_W2   DFLT   DS */		ACCESS_DS_RD_W2,
/*  225 1601  RD   SZ_W2   DFLT   SS */		ACCESS_SS_RD_W2,
/*  226 1610  RD   SZ_W2   ES     DS */		ACCESS_ES_RD_W2,
/*  227 1611  RD   SZ_W2   ES     SS */		ACCESS_ES_RD_W2,
/*  228 1620  RD   SZ_W2   CS     DS */		ACCESS_CS_RD_W2,
/*  229 1621  RD   SZ_W2   CS     SS */		ACCESS_CS_RD_W2,
/*  230 1630  RD   SZ_W2   SS     DS */		ACCESS_SS_RD_W2,
/*  231 1631  RD   SZ_W2   SS     SS */		ACCESS_SS_RD_W2,
/*  232 1640  RD   SZ_W2   DS     DS */		ACCESS_DS_RD_W2,
/*  233 1641  RD   SZ_W2   DS     SS */		ACCESS_DS_RD_W2,
/*  234 1650  RD   SZ_W2   FS     DS */		ACCESS_FS_RD_W2,
/*  235 1651  RD   SZ_W2   FS     SS */		ACCESS_FS_RD_W2,
/*  236 1660  RD   SZ_W2   GS     DS */		ACCESS_GS_RD_W2,
/*  237 1661  RD   SZ_W2   GS     SS */		ACCESS_GS_RD_W2,
/*  238 1670  RD   SZ_W2   -      DS */		ACCESS_NA_NA,
/*  239 1671  RD   SZ_W2   -      SS */		ACCESS_NA_NA,
/*  240 1700  RD   SZ_WD   DFLT   DS */		ACCESS_DS_RD_WD,
/*  241 1701  RD   SZ_WD   DFLT   SS */		ACCESS_SS_RD_WD,
/*  242 1710  RD   SZ_WD   ES     DS */		ACCESS_ES_RD_WD,
/*  243 1711  RD   SZ_WD   ES     SS */		ACCESS_ES_RD_WD,
/*  244 1720  RD   SZ_WD   CS     DS */		ACCESS_CS_RD_WD,
/*  245 1721  RD   SZ_WD   CS     SS */		ACCESS_CS_RD_WD,
/*  246 1730  RD   SZ_WD   SS     DS */		ACCESS_SS_RD_WD,
/*  247 1731  RD   SZ_WD   SS     SS */		ACCESS_SS_RD_WD,
/*  248 1740  RD   SZ_WD   DS     DS */		ACCESS_DS_RD_WD,
/*  249 1741  RD   SZ_WD   DS     SS */		ACCESS_DS_RD_WD,
/*  250 1750  RD   SZ_WD   FS     DS */		ACCESS_FS_RD_WD,
/*  251 1751  RD   SZ_WD   FS     SS */		ACCESS_FS_RD_WD,
/*  252 1760  RD   SZ_WD   GS     DS */		ACCESS_GS_RD_WD,
/*  253 1761  RD   SZ_WD   GS     SS */		ACCESS_GS_RD_WD,
/*  254 1770  RD   SZ_WD   -      DS */		ACCESS_NA_NA,
/*  255 1771  RD   SZ_WD   -      SS */		ACCESS_NA_NA,
/*  256 2000  WT   SZ_B    DFLT   DS */		ACCESS_DS_WT_B,
/*  257 2001  WT   SZ_B    DFLT   SS */		ACCESS_SS_WT_B,
/*  258 2010  WT   SZ_B    ES     DS */		ACCESS_ES_WT_B,
/*  259 2011  WT   SZ_B    ES     SS */		ACCESS_ES_WT_B,
/*  260 2020  WT   SZ_B    CS     DS */		ACCESS_CS_WT_B,
/*  261 2021  WT   SZ_B    CS     SS */		ACCESS_CS_WT_B,
/*  262 2030  WT   SZ_B    SS     DS */		ACCESS_SS_WT_B,
/*  263 2031  WT   SZ_B    SS     SS */		ACCESS_SS_WT_B,
/*  264 2040  WT   SZ_B    DS     DS */		ACCESS_DS_WT_B,
/*  265 2041  WT   SZ_B    DS     SS */		ACCESS_DS_WT_B,
/*  266 2050  WT   SZ_B    FS     DS */		ACCESS_FS_WT_B,
/*  267 2051  WT   SZ_B    FS     SS */		ACCESS_FS_WT_B,
/*  268 2060  WT   SZ_B    GS     DS */		ACCESS_GS_WT_B,
/*  269 2061  WT   SZ_B    GS     SS */		ACCESS_GS_WT_B,
/*  270 2070  WT   SZ_B    -      DS */		ACCESS_NA_NA,
/*  271 2071  WT   SZ_B    -      SS */		ACCESS_NA_NA,
/*  272 2100  WT   SZ_B    DFLT   DS */		ACCESS_DS_WT_B,
/*  273 2101  WT   SZ_B    DFLT   SS */		ACCESS_SS_WT_B,
/*  274 2110  WT   SZ_B    ES     DS */		ACCESS_ES_WT_B,
/*  275 2111  WT   SZ_B    ES     SS */		ACCESS_ES_WT_B,
/*  276 2120  WT   SZ_B    CS     DS */		ACCESS_CS_WT_B,
/*  277 2121  WT   SZ_B    CS     SS */		ACCESS_CS_WT_B,
/*  278 2130  WT   SZ_B    SS     DS */		ACCESS_SS_WT_B,
/*  279 2131  WT   SZ_B    SS     SS */		ACCESS_SS_WT_B,
/*  280 2140  WT   SZ_B    DS     DS */		ACCESS_DS_WT_B,
/*  281 2141  WT   SZ_B    DS     SS */		ACCESS_DS_WT_B,
/*  282 2150  WT   SZ_B    FS     DS */		ACCESS_FS_WT_B,
/*  283 2151  WT   SZ_B    FS     SS */		ACCESS_FS_WT_B,
/*  284 2160  WT   SZ_B    GS     DS */		ACCESS_GS_WT_B,
/*  285 2161  WT   SZ_B    GS     SS */		ACCESS_GS_WT_B,
/*  286 2170  WT   SZ_B    -      DS */		ACCESS_NA_NA,
/*  287 2171  WT   SZ_B    -      SS */		ACCESS_NA_NA,
/*  288 2200  WT   SZ_W    DFLT   DS */		ACCESS_DS_WT_W,
/*  289 2201  WT   SZ_W    DFLT   SS */		ACCESS_SS_WT_W,
/*  290 2210  WT   SZ_W    ES     DS */		ACCESS_ES_WT_W,
/*  291 2211  WT   SZ_W    ES     SS */		ACCESS_ES_WT_W,
/*  292 2220  WT   SZ_W    CS     DS */		ACCESS_CS_WT_W,
/*  293 2221  WT   SZ_W    CS     SS */		ACCESS_CS_WT_W,
/*  294 2230  WT   SZ_W    SS     DS */		ACCESS_SS_WT_W,
/*  295 2231  WT   SZ_W    SS     SS */		ACCESS_SS_WT_W,
/*  296 2240  WT   SZ_W    DS     DS */		ACCESS_DS_WT_W,
/*  297 2241  WT   SZ_W    DS     SS */		ACCESS_DS_WT_W,
/*  298 2250  WT   SZ_W    FS     DS */		ACCESS_FS_WT_W,
/*  299 2251  WT   SZ_W    FS     SS */		ACCESS_FS_WT_W,
/*  300 2260  WT   SZ_W    GS     DS */		ACCESS_GS_WT_W,
/*  301 2261  WT   SZ_W    GS     SS */		ACCESS_GS_WT_W,
/*  302 2270  WT   SZ_W    -      DS */		ACCESS_NA_NA,
/*  303 2271  WT   SZ_W    -      SS */		ACCESS_NA_NA,
/*  304 2300  WT   SZ_D    DFLT   DS */		ACCESS_DS_WT_D,
/*  305 2301  WT   SZ_D    DFLT   SS */		ACCESS_SS_WT_D,
/*  306 2310  WT   SZ_D    ES     DS */		ACCESS_ES_WT_D,
/*  307 2311  WT   SZ_D    ES     SS */		ACCESS_ES_WT_D,
/*  308 2320  WT   SZ_D    CS     DS */		ACCESS_CS_WT_D,
/*  309 2321  WT   SZ_D    CS     SS */		ACCESS_CS_WT_D,
/*  310 2330  WT   SZ_D    SS     DS */		ACCESS_SS_WT_D,
/*  311 2331  WT   SZ_D    SS     SS */		ACCESS_SS_WT_D,
/*  312 2340  WT   SZ_D    DS     DS */		ACCESS_DS_WT_D,
/*  313 2341  WT   SZ_D    DS     SS */		ACCESS_DS_WT_D,
/*  314 2350  WT   SZ_D    FS     DS */		ACCESS_FS_WT_D,
/*  315 2351  WT   SZ_D    FS     SS */		ACCESS_FS_WT_D,
/*  316 2360  WT   SZ_D    GS     DS */		ACCESS_GS_WT_D,
/*  317 2361  WT   SZ_D    GS     SS */		ACCESS_GS_WT_D,
/*  318 2370  WT   SZ_D    -      DS */		ACCESS_NA_NA,
/*  319 2371  WT   SZ_D    -      SS */		ACCESS_NA_NA,
/*  320 2400  WT   SZ_W    DFLT   DS */		ACCESS_DS_WT_W,
/*  321 2401  WT   SZ_W    DFLT   SS */		ACCESS_SS_WT_W,
/*  322 2410  WT   SZ_W    ES     DS */		ACCESS_ES_WT_W,
/*  323 2411  WT   SZ_W    ES     SS */		ACCESS_ES_WT_W,
/*  324 2420  WT   SZ_W    CS     DS */		ACCESS_CS_WT_W,
/*  325 2421  WT   SZ_W    CS     SS */		ACCESS_CS_WT_W,
/*  326 2430  WT   SZ_W    SS     DS */		ACCESS_SS_WT_W,
/*  327 2431  WT   SZ_W    SS     SS */		ACCESS_SS_WT_W,
/*  328 2440  WT   SZ_W    DS     DS */		ACCESS_DS_WT_W,
/*  329 2441  WT   SZ_W    DS     SS */		ACCESS_DS_WT_W,
/*  330 2450  WT   SZ_W    FS     DS */		ACCESS_FS_WT_W,
/*  331 2451  WT   SZ_W    FS     SS */		ACCESS_FS_WT_W,
/*  332 2460  WT   SZ_W    GS     DS */		ACCESS_GS_WT_W,
/*  333 2461  WT   SZ_W    GS     SS */		ACCESS_GS_WT_W,
/*  334 2470  WT   SZ_W    -      DS */		ACCESS_NA_NA,
/*  335 2471  WT   SZ_W    -      SS */		ACCESS_NA_NA,
/*  336 2500  WT   -       DFLT   DS */		ACCESS_NA_NA,
/*  337 2501  WT   -       DFLT   SS */		ACCESS_NA_NA,
/*  338 2510  WT   -       ES     DS */		ACCESS_NA_NA,
/*  339 2511  WT   -       ES     SS */		ACCESS_NA_NA,
/*  340 2520  WT   -       CS     DS */		ACCESS_NA_NA,
/*  341 2521  WT   -       CS     SS */		ACCESS_NA_NA,
/*  342 2530  WT   -       SS     DS */		ACCESS_NA_NA,
/*  343 2531  WT   -       SS     SS */		ACCESS_NA_NA,
/*  344 2540  WT   -       DS     DS */		ACCESS_NA_NA,
/*  345 2541  WT   -       DS     SS */		ACCESS_NA_NA,
/*  346 2550  WT   -       FS     DS */		ACCESS_NA_NA,
/*  347 2551  WT   -       FS     SS */		ACCESS_NA_NA,
/*  348 2560  WT   -       GS     DS */		ACCESS_NA_NA,
/*  349 2561  WT   -       GS     SS */		ACCESS_NA_NA,
/*  350 2570  WT   -       -      DS */		ACCESS_NA_NA,
/*  351 2571  WT   -       -      SS */		ACCESS_NA_NA,
/*  352 2600  WT   SZ_W2   DFLT   DS */		ACCESS_NA_NA,
/*  353 2601  WT   SZ_W2   DFLT   SS */		ACCESS_NA_NA,
/*  354 2610  WT   SZ_W2   ES     DS */		ACCESS_NA_NA,
/*  355 2611  WT   SZ_W2   ES     SS */		ACCESS_NA_NA,
/*  356 2620  WT   SZ_W2   CS     DS */		ACCESS_NA_NA,
/*  357 2621  WT   SZ_W2   CS     SS */		ACCESS_NA_NA,
/*  358 2630  WT   SZ_W2   SS     DS */		ACCESS_NA_NA,
/*  359 2631  WT   SZ_W2   SS     SS */		ACCESS_NA_NA,
/*  360 2640  WT   SZ_W2   DS     DS */		ACCESS_NA_NA,
/*  361 2641  WT   SZ_W2   DS     SS */		ACCESS_NA_NA,
/*  362 2650  WT   SZ_W2   FS     DS */		ACCESS_NA_NA,
/*  363 2651  WT   SZ_W2   FS     SS */		ACCESS_NA_NA,
/*  364 2660  WT   SZ_W2   GS     DS */		ACCESS_NA_NA,
/*  365 2661  WT   SZ_W2   GS     SS */		ACCESS_NA_NA,
/*  366 2670  WT   SZ_W2   -      DS */		ACCESS_NA_NA,
/*  367 2671  WT   SZ_W2   -      SS */		ACCESS_NA_NA,
/*  368 2700  WT   SZ_WD   DFLT   DS */		ACCESS_DS_WT_WD,
/*  369 2701  WT   SZ_WD   DFLT   SS */		ACCESS_SS_WT_WD,
/*  370 2710  WT   SZ_WD   ES     DS */		ACCESS_ES_WT_WD,
/*  371 2711  WT   SZ_WD   ES     SS */		ACCESS_ES_WT_WD,
/*  372 2720  WT   SZ_WD   CS     DS */		ACCESS_CS_WT_WD,
/*  373 2721  WT   SZ_WD   CS     SS */		ACCESS_CS_WT_WD,
/*  374 2730  WT   SZ_WD   SS     DS */		ACCESS_SS_WT_WD,
/*  375 2731  WT   SZ_WD   SS     SS */		ACCESS_SS_WT_WD,
/*  376 2740  WT   SZ_WD   DS     DS */		ACCESS_DS_WT_WD,
/*  377 2741  WT   SZ_WD   DS     SS */		ACCESS_DS_WT_WD,
/*  378 2750  WT   SZ_WD   FS     DS */		ACCESS_FS_WT_WD,
/*  379 2751  WT   SZ_WD   FS     SS */		ACCESS_FS_WT_WD,
/*  380 2760  WT   SZ_WD   GS     DS */		ACCESS_GS_WT_WD,
/*  381 2761  WT   SZ_WD   GS     SS */		ACCESS_GS_WT_WD,
/*  382 2770  WT   SZ_WD   -      DS */		ACCESS_NA_NA,
/*  383 2771  WT   SZ_WD   -      SS */		ACCESS_NA_NA,
/*  384 3000  RW   SZ_B    DFLT   DS */		ACCESS_DS_RW_B,
/*  385 3001  RW   SZ_B    DFLT   SS */		ACCESS_SS_RW_B,
/*  386 3010  RW   SZ_B    ES     DS */		ACCESS_ES_RW_B,
/*  387 3011  RW   SZ_B    ES     SS */		ACCESS_ES_RW_B,
/*  388 3020  RW   SZ_B    CS     DS */		ACCESS_CS_RW_B,
/*  389 3021  RW   SZ_B    CS     SS */		ACCESS_CS_RW_B,
/*  390 3030  RW   SZ_B    SS     DS */		ACCESS_SS_RW_B,
/*  391 3031  RW   SZ_B    SS     SS */		ACCESS_SS_RW_B,
/*  392 3040  RW   SZ_B    DS     DS */		ACCESS_DS_RW_B,
/*  393 3041  RW   SZ_B    DS     SS */		ACCESS_DS_RW_B,
/*  394 3050  RW   SZ_B    FS     DS */		ACCESS_FS_RW_B,
/*  395 3051  RW   SZ_B    FS     SS */		ACCESS_FS_RW_B,
/*  396 3060  RW   SZ_B    GS     DS */		ACCESS_GS_RW_B,
/*  397 3061  RW   SZ_B    GS     SS */		ACCESS_GS_RW_B,
/*  398 3070  RW   SZ_B    -      DS */		ACCESS_NA_NA,
/*  399 3071  RW   SZ_B    -      SS */		ACCESS_NA_NA,
/*  400 3100  RW   SZ_B    DFLT   DS */		ACCESS_DS_RW_B,
/*  401 3101  RW   SZ_B    DFLT   SS */		ACCESS_SS_RW_B,
/*  402 3110  RW   SZ_B    ES     DS */		ACCESS_ES_RW_B,
/*  403 3111  RW   SZ_B    ES     SS */		ACCESS_ES_RW_B,
/*  404 3120  RW   SZ_B    CS     DS */		ACCESS_CS_RW_B,
/*  405 3121  RW   SZ_B    CS     SS */		ACCESS_CS_RW_B,
/*  406 3130  RW   SZ_B    SS     DS */		ACCESS_SS_RW_B,
/*  407 3131  RW   SZ_B    SS     SS */		ACCESS_SS_RW_B,
/*  408 3140  RW   SZ_B    DS     DS */		ACCESS_DS_RW_B,
/*  409 3141  RW   SZ_B    DS     SS */		ACCESS_DS_RW_B,
/*  410 3150  RW   SZ_B    FS     DS */		ACCESS_FS_RW_B,
/*  411 3151  RW   SZ_B    FS     SS */		ACCESS_FS_RW_B,
/*  412 3160  RW   SZ_B    GS     DS */		ACCESS_GS_RW_B,
/*  413 3161  RW   SZ_B    GS     SS */		ACCESS_GS_RW_B,
/*  414 3170  RW   SZ_B    -      DS */		ACCESS_NA_NA,
/*  415 3171  RW   SZ_B    -      SS */		ACCESS_NA_NA,
/*  416 3200  RW   SZ_W    DFLT   DS */		ACCESS_DS_RW_W,
/*  417 3201  RW   SZ_W    DFLT   SS */		ACCESS_SS_RW_W,
/*  418 3210  RW   SZ_W    ES     DS */		ACCESS_ES_RW_W,
/*  419 3211  RW   SZ_W    ES     SS */		ACCESS_ES_RW_W,
/*  420 3220  RW   SZ_W    CS     DS */		ACCESS_CS_RW_W,
/*  421 3221  RW   SZ_W    CS     SS */		ACCESS_CS_RW_W,
/*  422 3230  RW   SZ_W    SS     DS */		ACCESS_SS_RW_W,
/*  423 3231  RW   SZ_W    SS     SS */		ACCESS_SS_RW_W,
/*  424 3240  RW   SZ_W    DS     DS */		ACCESS_DS_RW_W,
/*  425 3241  RW   SZ_W    DS     SS */		ACCESS_DS_RW_W,
/*  426 3250  RW   SZ_W    FS     DS */		ACCESS_FS_RW_W,
/*  427 3251  RW   SZ_W    FS     SS */		ACCESS_FS_RW_W,
/*  428 3260  RW   SZ_W    GS     DS */		ACCESS_GS_RW_W,
/*  429 3261  RW   SZ_W    GS     SS */		ACCESS_GS_RW_W,
/*  430 3270  RW   SZ_W    -      DS */		ACCESS_NA_NA,
/*  431 3271  RW   SZ_W    -      SS */		ACCESS_NA_NA,
/*  432 3300  RW   SZ_D    DFLT   DS */		ACCESS_DS_RW_D,
/*  433 3301  RW   SZ_D    DFLT   SS */		ACCESS_SS_RW_D,
/*  434 3310  RW   SZ_D    ES     DS */		ACCESS_ES_RW_D,
/*  435 3311  RW   SZ_D    ES     SS */		ACCESS_ES_RW_D,
/*  436 3320  RW   SZ_D    CS     DS */		ACCESS_CS_RW_D,
/*  437 3321  RW   SZ_D    CS     SS */		ACCESS_CS_RW_D,
/*  438 3330  RW   SZ_D    SS     DS */		ACCESS_SS_RW_D,
/*  439 3331  RW   SZ_D    SS     SS */		ACCESS_SS_RW_D,
/*  440 3340  RW   SZ_D    DS     DS */		ACCESS_DS_RW_D,
/*  441 3341  RW   SZ_D    DS     SS */		ACCESS_DS_RW_D,
/*  442 3350  RW   SZ_D    FS     DS */		ACCESS_FS_RW_D,
/*  443 3351  RW   SZ_D    FS     SS */		ACCESS_FS_RW_D,
/*  444 3360  RW   SZ_D    GS     DS */		ACCESS_GS_RW_D,
/*  445 3361  RW   SZ_D    GS     SS */		ACCESS_GS_RW_D,
/*  446 3370  RW   SZ_D    -      DS */		ACCESS_NA_NA,
/*  447 3371  RW   SZ_D    -      SS */		ACCESS_NA_NA,
/*  448 3400  RW   SZ_W    DFLT   DS */		ACCESS_DS_RW_W,
/*  449 3401  RW   SZ_W    DFLT   SS */		ACCESS_SS_RW_W,
/*  450 3410  RW   SZ_W    ES     DS */		ACCESS_ES_RW_W,
/*  451 3411  RW   SZ_W    ES     SS */		ACCESS_ES_RW_W,
/*  452 3420  RW   SZ_W    CS     DS */		ACCESS_CS_RW_W,
/*  453 3421  RW   SZ_W    CS     SS */		ACCESS_CS_RW_W,
/*  454 3430  RW   SZ_W    SS     DS */		ACCESS_SS_RW_W,
/*  455 3431  RW   SZ_W    SS     SS */		ACCESS_SS_RW_W,
/*  456 3440  RW   SZ_W    DS     DS */		ACCESS_DS_RW_W,
/*  457 3441  RW   SZ_W    DS     SS */		ACCESS_DS_RW_W,
/*  458 3450  RW   SZ_W    FS     DS */		ACCESS_FS_RW_W,
/*  459 3451  RW   SZ_W    FS     SS */		ACCESS_FS_RW_W,
/*  460 3460  RW   SZ_W    GS     DS */		ACCESS_GS_RW_W,
/*  461 3461  RW   SZ_W    GS     SS */		ACCESS_GS_RW_W,
/*  462 3470  RW   SZ_W    -      DS */		ACCESS_NA_NA,
/*  463 3471  RW   SZ_W    -      SS */		ACCESS_NA_NA,
/*  464 3500  RW   -       DFLT   DS */		ACCESS_NA_NA,
/*  465 3501  RW   -       DFLT   SS */		ACCESS_NA_NA,
/*  466 3510  RW   -       ES     DS */		ACCESS_NA_NA,
/*  467 3511  RW   -       ES     SS */		ACCESS_NA_NA,
/*  468 3520  RW   -       CS     DS */		ACCESS_NA_NA,
/*  469 3521  RW   -       CS     SS */		ACCESS_NA_NA,
/*  470 3530  RW   -       SS     DS */		ACCESS_NA_NA,
/*  471 3531  RW   -       SS     SS */		ACCESS_NA_NA,
/*  472 3540  RW   -       DS     DS */		ACCESS_NA_NA,
/*  473 3541  RW   -       DS     SS */		ACCESS_NA_NA,
/*  474 3550  RW   -       FS     DS */		ACCESS_NA_NA,
/*  475 3551  RW   -       FS     SS */		ACCESS_NA_NA,
/*  476 3560  RW   -       GS     DS */		ACCESS_NA_NA,
/*  477 3561  RW   -       GS     SS */		ACCESS_NA_NA,
/*  478 3570  RW   -       -      DS */		ACCESS_NA_NA,
/*  479 3571  RW   -       -      SS */		ACCESS_NA_NA,
/*  480 3600  RW   SZ_W2   DFLT   DS */		ACCESS_NA_NA,
/*  481 3601  RW   SZ_W2   DFLT   SS */		ACCESS_NA_NA,
/*  482 3610  RW   SZ_W2   ES     DS */		ACCESS_NA_NA,
/*  483 3611  RW   SZ_W2   ES     SS */		ACCESS_NA_NA,
/*  484 3620  RW   SZ_W2   CS     DS */		ACCESS_NA_NA,
/*  485 3621  RW   SZ_W2   CS     SS */		ACCESS_NA_NA,
/*  486 3630  RW   SZ_W2   SS     DS */		ACCESS_NA_NA,
/*  487 3631  RW   SZ_W2   SS     SS */		ACCESS_NA_NA,
/*  488 3640  RW   SZ_W2   DS     DS */		ACCESS_NA_NA,
/*  489 3641  RW   SZ_W2   DS     SS */		ACCESS_NA_NA,
/*  490 3650  RW   SZ_W2   FS     DS */		ACCESS_NA_NA,
/*  491 3651  RW   SZ_W2   FS     SS */		ACCESS_NA_NA,
/*  492 3660  RW   SZ_W2   GS     DS */		ACCESS_NA_NA,
/*  493 3661  RW   SZ_W2   GS     SS */		ACCESS_NA_NA,
/*  494 3670  RW   SZ_W2   -      DS */		ACCESS_NA_NA,
/*  495 3671  RW   SZ_W2   -      SS */		ACCESS_NA_NA,
/*  496 3700  RW   SZ_WD   DFLT   DS */		ACCESS_NA_NA,
/*  497 3701  RW   SZ_WD   DFLT   SS */		ACCESS_NA_NA,
/*  498 3710  RW   SZ_WD   ES     DS */		ACCESS_NA_NA,
/*  499 3711  RW   SZ_WD   ES     SS */		ACCESS_NA_NA,
/*  500 3720  RW   SZ_WD   CS     DS */		ACCESS_NA_NA,
/*  501 3721  RW   SZ_WD   CS     SS */		ACCESS_NA_NA,
/*  502 3730  RW   SZ_WD   SS     DS */		ACCESS_NA_NA,
/*  503 3731  RW   SZ_WD   SS     SS */		ACCESS_NA_NA,
/*  504 3740  RW   SZ_WD   DS     DS */		ACCESS_NA_NA,
/*  505 3741  RW   SZ_WD   DS     SS */		ACCESS_NA_NA,
/*  506 3750  RW   SZ_WD   FS     DS */		ACCESS_NA_NA,
/*  507 3751  RW   SZ_WD   FS     SS */		ACCESS_NA_NA,
/*  508 3760  RW   SZ_WD   GS     DS */		ACCESS_NA_NA,
/*  509 3761  RW   SZ_WD   GS     SS */		ACCESS_NA_NA,
/*  510 3770  RW   SZ_WD   -      DS */		ACCESS_NA_NA,
/*  511 3771  RW   SZ_WD   -      SS */		ACCESS_NA_NA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\cdrom_fn.h ===
/*[
 *	Product:		SoftPC-AT Revision 3.0
 *	Name:			cdrom_fn.h
 *	Purpose:		Interface & defines used by cdrom_fn.c
 *
 *	Derived From:		next_cdrom.c, 1.5, 23/9/92, Jason Proctor
 *
 *	Sccs ID:		@(#)cdrom_fn.h	1.3 04/14/94
 *
 *	(c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
]*/

/* CD addressing modes */
#define		kBlockAddressMode		0
#define		kRedbookAddressMode		1
#define		kTrackAddressMode		2

/* equate for special lead out track */
#define		kActualLeadOutTrack		0xaa
#define		kLeadOutTrack			100

/* values for device status
 * 0x282 => data only, read only, prefetch supported, no interleaving
 *	    only cooked reading, no audio channel manipulation, 
 *	    supports Redbook addressing, doesn't support R-W sub-channels
 */
#define		kDeviceStatus			0x282
#define		kAudioSupported			(1<<4)
#define		kNoDiskPresent			(1<<11)

/* data formats for read subchannel command */
#define		kCurrentPosDataFormat	1
#define		kMediaCatDataFormat		2
#define		kTrackStdDataFormat		3

/* bit mask for audio status bit */
#define		kAudioPlayInProgress	0x11


/* TYPEDEFS */

struct toc_info
{
	UTINY	control;
	UTINY	hour;
	UTINY	minute;
	UTINY	sec;
	UTINY	frame;
};

/* entire table of contents */
/* naudio/ndata hacked out by Jase as we don't need them */
struct toc_all
{
	UTINY		firsttrack;
	UTINY		lasttrack;
	struct toc_info	info[101];
};

typedef struct
{
	INT				cdDeviceFD;
	IUM32			cdAddressMode;
	IUM32			cdCommandMode;
	IUM32			cdBlockSize;
	IUM32			cdBlockAddress;
	IUM32			cdTransmitCount;
	IUM32			cdReceiveCount;
	struct toc_all	cdTOC;
	BOOL			cdChangedMedia;
	BOOL			cdOpen;
	BOOL			cdReadTOC;
	UTINY			*cdBuffer;
	UTINY			cdTempBuffer [256];
	CHAR			cdDeviceName [MAXPATHLEN];

} CDROMGlobalRec;

/* conveniently small MSF record */
typedef struct
{
	UTINY				msfMinutes;
	UTINY				msfSeconds;
	UTINY				msfFrames;

} MSFRec;

/* utility routines */

extern void		CreateMSF IPT2 (MSFRec *, startMSF, MSFRec *, endMSF);
extern IUM32		Redbook2HighSierra IPT1 (UTINY *, address);
extern void		HighSierra2Redbook IPT2 (IUM32, block, MSFRec *, msf);


/* host interface stuff */

extern void		host_set_cd_retn_stat IPT0 ();
extern void		host_cd_media_changed IPT0 ();

extern int		host_scsi_test_unit_ready IPT0 ();
extern int		host_scsi_seek IPT0 ();
extern int		host_scsi_read IPT0 ();
extern int		host_scsi_play_audio IPT0 ();
extern int		host_scsi_pause_resume_audio IPT1 (BOOL, pause);
extern int		host_scsi_read_UPC IPT0 ();
extern int		host_scsi_read_position IPT1 (BOOL, full);
extern int		host_scsi_audio_status IPT0 ();
extern int		host_scsi_playback_status IPT0 ();
extern int		host_scsi_set_blocksize IPT0 ();
extern int		host_scsi_read_TOC IPT0 ();

/* IMPORTED DATA */

/* imported from base/dos/cdrom.c */
extern BOOL				bl_red_book;
extern int				cd_retn_stat;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\cdrom.h ===
/*
 * SoftPC V 3.0
 *
 * Title	: CDROM definitions
 *
 * Description	: Defintions for use of the CDROM
 *
 * Author	: WTG Charnell
 *
 * Notes	: 
 *
 */
 
/* SccsID[]="@(#)cdrom.h	1.11 11/20/92 Copyright Insignia Solutions Ltd."; */

/**********************************************************************
 *  Structure Definitions
 ************************/

#define PACKET	struct extended_command_buffer
struct extended_command_buffer {
    word	function;	/* Device driver command code		*/
    half_word	id;		/* Reserved - I.D. byte			*/
    half_word	drive;		/* Logical unit number of desired drive	*/
    half_word	command_mode;	/* Operational Mode, desired function	*/
    half_word	address_mode;	/* Addressing Mode, track,redbook,block */
    word	size;		/* Block size, Mode dependent operation	*/
    int		address;	/* Starting address, CDROM function	*/
    int		count;		/* bytes,word,blocks,sectors, etc. 	*/
    half_word	*buffer;	/* pointer for data transfer		*/
};

#define DRIVER_INFORMATION struct cdrom_device_driver
				/* ASCII text	 */
struct cdrom_device_driver {
    unsigned char   version[3];	/* Version number - driver	 */
    unsigned char   period;	/* Text separation		 */
    unsigned char   edition[3];	/* Edit number - file system	 */
    unsigned char   nul_string_1;   /* End of string delimiter	 */
    unsigned char   name[8];	/* Device Driver Name (type)	 */
    unsigned char   nul_string_2;   /* End of string delimiter	 */
    unsigned char   drives;	/* Number of drives installed	 */
    unsigned char   nul_string_3;   /* End of string delimiter	 */
    unsigned char   protocol;	/* Command Protocol		 */
    unsigned char   nul_string_4;   /* End of string delimiter	 */
};

#define DRIVE_STATUS struct cdrom_drive_status
struct cdrom_drive_status {
    unsigned char   unit;	/* Drive Unit Number of the CD-ROM	*/
    unsigned char   ldc0;	/* Last Drive Command - L.S.B.		*/
    unsigned char   ldc1;	/*  "     "      "                      */
    unsigned char   ldc2;	/*  "     "      "                      */
    unsigned char   ldc3;	/* Last Drive Command - M.S.B.		*/
    unsigned char   status;	/* Drive Status Byte			*/
    unsigned char   error;	/* Drive Error Byte			*/
    unsigned char   comm;	/* Drive Communication Error Code	*/
    unsigned char   sector;	/* Drive Address - sector number	*/
    unsigned char   second;	/*   "     "     - second		*/
    unsigned char   minute;	/*   "     "     - minute		*/
    unsigned char   disc_no;	/* Selected Disc Number - reserved	*/
    unsigned char   tracks;	/* Total number of tracks on disc	*/
    unsigned char   track_no;	/* Current Track - audio mode		*/
};

#define SIMPLE	struct original_command_buffer   
struct original_command_buffer {
    half_word	function;	/* Device driver command code		*/
    half_word	handle;		/* File or Volume handle		*/
    half_word	player;		/* Logical unit number of desired drive	*/
    half_word	count;		/* Number of block to read		*/
    int		address;	/* Starting address, CDROM function	*/
    half_word	*string;	/* Pointer address for driver status	*/
    half_word	*buffer;	/* Pointer address for data transfer	*/
};

#define CD_ERR_INVALID_DRIVE_NUM	0x6
#define CD_ERR_INVALID_ADDRESS		0x7
#define CD_ERR_INVALID_COUNT		0x8
#define CD_ERR_INVALID_FN_CODE		0x9
#define CD_ERR_UNCORECTABLE_DATA_ERR	0x11
#define CD_ERR_DRIVE_NOT_RESPONDING	0x12
#define CD_ERR_ADAPTER_DRIVE_ERROR	0x13
#define CD_ERR_MEDIA_CHANGED		0x14
#define CD_ERR_DRIVE_NOT_READY		0x15
#define CD_ERR_ADAPTER_ERROR		0x16
#define CD_ERR_DRIVE_REPORTED_ERROR	0x18
#define CD_ERR_ILLEGAL_DISC		0x19
#define CD_ERR_BYTES_NOT_TRANSFERRED	0x80
#define CD_ERR_FUNCTION_NOT_SUPPORTED	0x81
#define CD_ERR_COMMAND_NOT_FOR_TRACK	0x82
#define CD_ERR_DRIVE_IS_BUSY		0x83
#define CD_ERR_BUS_IS_BUSY		0x84
#define CD_ERR_DRIVER_NOT_INITIALISED	0x85
#define CD_ERR_INVALID_FN_MODE		0x86
#define CD_ERR_INVALID_ADDR_MODE	0x87
#define CD_ERR_INVALID_BL_SIZE		0x88

/*
 * The Bios Parameter Block has a variable structure dependant on the
 * command being called. The 1st 13 bytes, however, are always the same:
 *  Byte  0:	length of request header
 *  Byte  1:	Unit # for this request
 *  Byte  2:	Command Code
 *  Bytes 3&4:	Returned Status Word
 *  Bytes 5-12:	Reserved
 *
 * The driver fills in the Status Word (Bytes 3&4) to indicate success or
 * failure of operations. The status word is made up as follows:
 *  Bit 15:	Error (failure if set)
 *  Bits 12-14:	Reserved
 *  Bit  9:	Busy
 *  Bit  8:	Done
 *  Bits 7-0:	Error Code on failure
 */

/*
 * Shorthand for typical error returns in AX. The driver will copy this
 * into the Return Status word for us.
 */
#define DRIVE_NOT_READY	0x8002
#define BAD_FUNC	0x8003
#define WRITE_ERR	0x800A
#define READ_ERR	0x800B
#define GEN_ERR		0x800C
#define RESERVE_ERR	0x800D
#define FUNC_OK		0x0100	/* Done, No error, no chars waiting */

#define BUSY_BIT 	9
#define ERROR_BIT	15
#define DONE_BIT	8


/****************************************************************************
*	Original CD ROM command/function definitions
*
****************************************************************************/

#define ORIG_CD_GET_VERSION		0x10	/* Return ASCI version number      */
#define ORIG_CD_GET_ERROR_COUNT		0x11	/* Read  controller error counters */
#define ORIG_CD_CLEAR_CTRL_ERRORS	0x12	/* Clear controller error counters */
#define ORIG_CD_INIT_PLAYER		0x13	/* Initialize controller & drive nr */
#define ORIG_CD_SPIN_UP			0x14	/* Enable spindle motor		     */
#define ORIG_CD_SPIN_DOWN		0x15	/* Disable spindle motor	          */
#define ORIG_CD_CNVRT_BLK_NO		0x16	/* virtual to logical blk nr	     */
#define ORIG_CD_SEEK_ABS		0x17	/* Absolute seek to logical block # */
#define ORIG_CD_READ_ABS		0x18	/* Absolute read!		          */
#define ORIG_CD_READ_ABS_IGN		0x19	/* read, ignore data errors	     */
#define ORIG_CD_CLEAR_DRIVE_ERRORS	0x1A	/* Clear player errors		     */
#define ORIG_CD_READ_STATUS		0x1B	/* Read  player status		     */
#define ORIG_CD_READ_CHARACTERISTICS	0x1C	/* Read player characteristics	*/
#define ORIG_CD_FLUSH_BUFFER		0x1D	/* Flush cached Data buffers	     */
#define ORIG_CD_GET_LAST_STATUS		0x1E	/* Read "last" player status	     */


/****************************************************************************
;*	Extended CD ROM command/function definitions
;*
;*/

#define EXT_CD_REQUEST_DRIVER_INFO   	0x80 /* Report host adapter or driver info   */
#define EXT_CD_READ_ERR_COUNTERS	0x81 /* Report summary of error condition    */
#define EXT_CD_CLEAR_ERR_COUNTERS	0x82 /* Reset device driver error counters   */
#define EXT_CD_RESET_CDROM_DRIVE	0x83 /* Reset the specified drive            */
#define EXT_CD_CLEAR_DRIVE_ERR		0x84 /* Attempt to clear drive error cond.   */
#define EXT_CD_FORBID_MEDIA_REMOVAL	0x85 /*  Lock  drive door - CM2xx function   */
#define EXT_CD_PERMIT_MEDIA_REMOVAL	0x86 /* UnLock drive door - CM2xx function   */
#define EXT_CD_REQUEST_CHARACTERISTICS	0x87 /* Report drive characteristics         */
#define EXT_CD_REQUEST_STATUS		0x88 /* Report drive status                  */
#define EXT_CD_REQUEST_PREVIOUS_STATUS	0x89 /* Report previous status, this drive   */
#define EXT_CD_REQUEST_AUDIO_MODE	0x8A /* Report current mode - audio drive    */
#define EXT_CD_MODIFY_AUDIO_MODE	0x8B /* Change audio mode, this drive        */
#define	EXT_CD_FLUSH_DATA_BUFFER	0x8C /* Remove ( i.e. clear ) data buffer    */
#define EXT_CD_EXTRA			0x8D /* Reserved - next info type function   */
#define EXT_CD_LOGICAL_RESERVE_DRIVE	0x8E /* Reserve drive for this application   */
#define EXT_CD_LOGICAL_RELEASE_DRIVE	0x8F /* Release drive for next application   */
#define EXT_CD_REQUEST_DISC_CAPACITY	0x90 /* Report physical status - this disc   */
#define EXT_CD_REQUEST_TRACK_INFO	0x91 /* Report specific track information    */
#define EXT_CD_SPIN_UP_DISC		0x92 /* Start the drive spindle motor        */
#define EXT_CD_SPIN_DOWN_DISC		0x93 /*  Stop the drive spindle motor        */
#define EXT_CD_READ_DRIVE_DATA		0x94 /* Read Digital Data                    */
#define EXT_CD_WRITE_DATA		0x95 /* Reserved - command                   */
#define EXT_CD_SEEK_TO_ADDRESS		0x96 /* Seek to logical or physical addr.    */
#define EXT_CD_PLAY_AUDIO_TRACK	        0x97 /* Play a single audio track            */
#define EXT_CD_PAUSE_AUDIO_TRACK	0x98 /* Suspend play of audio track          */
#define EXT_CD_RESUME_AUDIO_PLAY	0x99 /* Resume play of audio track           */
#define EXT_CD_REQUEST_HEAD_LOCATION	0x9A /* Report position of optical head      */
#define EXT_CD_SET_UNIT_NUMBER		0x9B /* Set Unit Number in EEPROM	          */
#define EXT_CD_SET_SERIAL_NUMBER	0x9C /* Set Serial Number in EEPROM	     */

IMPORT void rqst_driver_info IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void read_error_counters IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void clear_error_counters IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void reset_drive IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void clear_drive_error IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_drive_char IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_drive_status IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_last_drive_status IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_audio_mode IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void change_audio_mode IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void cd_flush_buffers IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void reserve_drive IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void release_drive IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_disc_capacity IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_track_info IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void spin_up_drive IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void spin_down_drive IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void cd_read_data IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void cd_seek IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void play_audio IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void pause_audio IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void resume_audio IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_head_location IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_org_driver_info IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void read_ignore_err IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void cd_not_supported IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_audstat IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_UPC_code IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_play_position IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_TOC_entry IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT void rqst_TOC IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT LONG rqst_Volsize IPT0();
IMPORT void rqst_Audio_info IPT2(PACKET *,c_buf,PACKET *,s_buf);
IMPORT SHORT host_rqst_device_status IPT0();
IMPORT BOOL host_rqst_audio_status IPT0();
IMPORT void host_eject_disk IPT0();

IMPORT VOID init_cd_dvr IPT0();
IMPORT int check_for_changed_media IPT0();
IMPORT int open_cdrom IPT0();
IMPORT int close_cdrom IPT1(int, gen_fd);

IMPORT VOID setup_cds_ea IPT0();
IMPORT VOID get_cds_text IPT3(IU32, driveno, IU8 *, ptr, int, len);

IMPORT VOID term_cdrom IPT1( IU8, drive_num);
IMPORT VOID init_bcd_driver IPT0();

#if defined(GEN_DRVR)
#define MAX_DRIVER	10
#define CD_ROM_DRIVER_NUM	8
#else
#define MAX_DRIVER	1
#define CD_ROM_DRIVER_NUM	0
#endif /* GEN_DRVR */

/*
 *	Used by get_cdrom_drive().
 */
 
#ifdef	macintosh
#define UNKNOWN_DRIVE_NUMBER	('?' - 'A')
#else
#define UNKNOWN_DRIVE_NUMBER	-1
#endif	/* macintosh */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\cg.h ===
#if defined(NEC_98)
#define         CG_WRITE_SECOND         0xA1
#define         CG_WRITE_FIRST          0xA3
#define         CG_WRITE_COUNTER        0xA5
#define         CG_WRITE_PATTERN        0xA9
#define         CG_READ_PATTERN         0xA9

#define         ANK_CHAR_START          0x0000
#define         ANK_CHAR_END            0x00FF
#define         JIS1_CHAR_START         0x0121
#define         JIS1_CHAR_END           0x077E
#define         HALF_CHAR_START         0x0921
#define         HALF_CHAR_END           0x0B7E
#define         NEC_CHAR_START          0x0C21
#define         NEC_CHAR_END            0x0D7E
#define         JIS1_KANJ_START         0x1021
#define         JIS1_KANJ_END           0x2F7E
#define         JIS2_KANJ_START         0x3021
#define         JIS2_KANJ_END           0x537E
#define         USER_GAIJ_START         0x5601
#define         USER_GAIJ_END           0x57FF
#define         LARG_KANJ_START         0x5921
#define         LARG_KANJ_END           0x5C7E

extern  BOOL    HIRESO_MODE;

//#define               PATTERN_BYTE_H  72
#define         PATTERN_BYTE_N  32

//#define               PATTERN_BYTE    (HIRESO_MODE ? PATTERN_BYTE_H : PATTERN_BYTE_N)
#define         PATTERN_BYTE            (PATTERN_BYTE_N)

//#define               CG_WINDOW_OFF_H         (0xE4000L)
#define         CG_WINDOW_OFF_N         (0xA4000L)

//#define               CG_WINDOW_OFF   (HIRESO_MODE ? CG_WINDOW_OFF_H : CG_WINDOW_OFF_N)
#define         CG_WINDOW_OFF           (CG_WINDOW_OFF_N)

#define         CG_WINDOW_START         (CG_WINDOW_OFF)
#define         CG_WINDOW_END           (CG_WINDOW_OFF+0x00FFFL)

typedef struct
{
                unsigned short  code;
                unsigned char   pattern[PATTERN_BYTE];
} GAIJ_GLOBS;

extern GAIJ_GLOBS *gaijglobs;

typedef struct
{
                unsigned short  code;
                unsigned char   counter;
                unsigned char   *cgwindow_ptr;
} CG_GLOBS;

extern CG_GLOBS cgglobs;

extern BOOL half_access;

IMPORT void cg_init IPT0();
IMPORT void cg_inb IPT2(io_addr, port, half_word *, value);
IMPORT void cg_outb IPT2(io_addr, port, half_word , value);
IMPORT void cg_post IPT0();

#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\cmosbios.h ===
/* @(#)cmosbios.h	1.3 08/10/92 Copyright Insignia Solutions Ltd.
	
FILE NAME	: cmosbios.h

	THIS INCLUDE SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER	: J.P.Box
DATE		: OCT '88


=========================================================================

AMMENDMENTS	:

=========================================================================
*/
extern void set_tod();
extern half_word cmos_read();
extern void cmos_write();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\cga.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Colour Graphics Adaptor declarations
 *
 * Description	: Definitions for users of the CGA
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 */

/* SccsID[]="@(#)cga.h	1.5 05/15/93 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

#ifdef HUNTER
#    define MC6845_REGS   18        /* No. of registers in a MC6845 chip     */
#endif


#ifdef BIT_ORDER1
typedef union                       /* Template for character attributes     */
{
    half_word all;
    struct 
    {
        HALF_WORD_BIT_FIELD blinking  :1;   /* Blinking attribute                    */
        HALF_WORD_BIT_FIELD background:3;   /* Background colour R,G,B               */
        HALF_WORD_BIT_FIELD bold      :1;   /* Intensity bit                         */
        HALF_WORD_BIT_FIELD foreground:3;   /* Foreground colour R,G,B               */
    } bits;
    struct 
    {
        HALF_WORD_BIT_FIELD background_and_blink:4;     
        HALF_WORD_BIT_FIELD foreground_and_bold :4;
    } plane;
} ATTRIBUTE;
#endif

#ifdef BIT_ORDER2
typedef union                       /* Template for character attributes     */
{
    half_word all;
    struct 
    {
        HALF_WORD_BIT_FIELD foreground:3;   /* Foreground colour R,G,B               */
        HALF_WORD_BIT_FIELD bold      :1;   /* Intensity bit                         */
        HALF_WORD_BIT_FIELD background:3;   /* Background colour R,G,B               */
        HALF_WORD_BIT_FIELD blinking  :1;   /* Blinking attribute                    */
    } bits;
    struct 
    {
        HALF_WORD_BIT_FIELD foreground_and_bold :4;
        HALF_WORD_BIT_FIELD background_and_blink:4;     
    } plane;
} ATTRIBUTE;
#endif

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#ifdef HUNTER
    extern half_word MC6845[];        /* The MC6845 data register values */
    extern half_word mode_reg;        /* MC6845 mode control register value */
#endif

extern void cga_init	IPT0();
extern void cga_term	IPT0();
extern void cga_inb	IPT2(io_addr, address, half_word *, value);
extern void cga_outb	IPT2(io_addr, address, half_word, value);

typedef	struct {
	int	mode;
	int	resolution;
	int	color_select;
	int	colormask;
} CGA_GLOBS;

extern	CGA_GLOBS	CGA_GLOBALS;

#define	set_cga_mode(val)		CGA_GLOBALS.mode = (val)
#define	set_cga_resolution(val)		CGA_GLOBALS.resolution = (val)
#define	set_cga_color_select(val)	CGA_GLOBALS.color_select = (val)
#define	set_cga_colormask(val)		CGA_GLOBALS.colormask = (val)

#define	get_cga_mode()			(CGA_GLOBALS.mode)
#define	get_cga_resolution()		(CGA_GLOBALS.resolution)
#define	get_cga_color_select()		(CGA_GLOBALS.color_select)
#define	get_cga_colormask()		(CGA_GLOBALS.colormask)

#if !defined(EGG) && !defined(A_VID) && !defined(C_VID)
/* This structure is defined solely so that we don't have to ifdef every
** reference to VGLOBS->dirty_flag and VGLOBS->screen_ptr in the base/host
** for a CGA-only build.
*/
typedef	struct
{
	ULONG dirty_flag;
	UTINY *screen_ptr;
} CGA_ONLY_GLOBS;

IMPORT CGA_ONLY_GLOBS *VGLOBS;
#endif	/* !EGG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\chkmallc.h ===
/*[
 *      Product:        SoftPC-AT Revision 3.0
 *
 *      Name:           chkmalloc.h
 *
 *      Author:         Jerry Sexton
 *
 *      Created On:     15th April 1991
 *
 *      Sccs ID:        @(#)chkmalloc.h	1.1 4/15/91
 *
 *      Purpose:        This header file defines a macro which programs can
 *                      use to exit cleanly if malloc fails.
 *
 *      (c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
 *
]*/

#include "error.h"

/*
 * Allocate `nitems' items of type `type' to `var' and exit cleanly on failure.
 */
#define check_malloc(var, nitems, type) \
        while ((var = (type *) host_malloc((nitems) * sizeof(type))) == NULL) \
        { \
                host_error(EG_MALLOC_FAILURE, ERR_CONT | ERR_QUIT, ""); \
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\cntlbop.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: cntlbop.h
 *
 * Description	: Definitions for use by the control bop functions.
 *
 * Author	: J. Koprowski
 *
 * Notes	: None
 */


/* SccsID[]=" @(#) @(#)cntlbop.h	1.4 08/10/92  01/20/89 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * Return codes from control bop type functions.
 */

#ifndef SUCCESS
#define SUCCESS 		0	/* Generic success code. */
#endif

#define ERR_NO_FUNCTION		1	/* Function not implemented. */
#define ERR_WRONG_HOST		2	/* Function call was for a different
					   host. */
#define ERR_INVALID_PARAMETER	3	/* Invalid parameter (out of range,
					   malformed etc.) */
#define ERR_WRONG_HARDWARE 	4	/* Hardware not present or
					   inappropriate. */
#define ERR_OUT_OF_SPACE	5	/* Insufficient memory or disk space. */
#define ERR_RESOURCE_SHORTAGE	6	/* Other resource shortage. */

/*
 * N.B. Error codes seven through fifteen are reserved for general errors.
 * Codes of sixteen and over are for use by the host routines and are
 * specified in host_bop.h.
 */

/*
 * Control bop table structure.
 */
typedef struct
{
    unsigned int code;
    void (*function)();
} control_bop_array;

/*
 * Generic host type code used for base functions.
 */
#define GENERIC 	1

#ifndef NULL
#define NULL	0L
#endif
/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

extern void control_bop IPT0();
extern control_bop_array host_bop_table[];

#if defined(DUMB_TERMINAL) && !defined(NO_SERIAL_UIF)
extern void flatog   IPT0();
extern void flbtog   IPT0();
extern void slvtog   IPT0();
extern void comtog   IPT0();
extern void D_kyhot  IPT0();
extern void D_kyhot2 IPT0();
#endif /* DUMB_TERMINAL && !SERIAL_UIF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\cpu.h ===
/*
 * SoftPC Revision 3.0
 *
 * Title	: Definitions for the CPU
 *
 * Description	: Structures, macros and definitions for access to the
 *		  CPU registers
 *
 * Author	: Henry Nash
 *
 * Notes	: This file should be portable - but includes a file
 *		  host_cpu.h which contains machine specific definitions
 *		  of CPU register mappings etc.
 */

/* SccsID[]="@(#)cpu.h	1.28 12/10/92 Copyright Insignia Solutions Ltd."; */

#if defined(NTVDM) && defined(MONITOR)

#include "host_cpu.h"

IMPORT VOID host_set_hw_int IPT0();
IMPORT VOID host_clear_hw_int IPT0();

#ifdef CPU_30_STYLE

/*
 * These variables are obsolete - however they are referenced
 * by:-
 *
 *	1. ica.c
 */

extern  word            cpu_interrupt_map;
extern  half_word       cpu_int_translate[];
extern  word            cpu_int_delay;
extern  half_word       ica_lock;
extern  void            (*(jump_ptrs[]))();
extern  void            (*(b_write_ptrs[]))();
extern  void            (*(w_write_ptrs[]))();
extern  void            (*(b_fill_ptrs[]))();
extern  void            (*(w_fill_ptrs[]))();
extern  void            (*(b_move_ptrs[]))();
extern  void            (*(w_move_ptrs[]))();
extern  half_word       *haddr_of_src_string;

/*
 *	Host functions to be provided for the base to use with respect to the CPU.
 *	These must be done in host_cpu.h because some hosts may want functions and
 *	others may want #defines.
 */

/*
 *	This macro specifies the maximum recursion depth the CPU is required to support.
 *	(Note that a particular host may not actually use this value if it is capable
 *	of supporting abirtarily deep recursion).
 */
#define CPU_MAX_RECURSION	32

/*
 *	Interrupt types...
 */

typedef enum {	CPU_HW_RESET,
		CPU_TIMER_TICK,
		CPU_SW_INT,
		CPU_HW_INT,
		CPU_YODA_INT,
		CPU_SIGIO_EVENT
} CPU_INT_TYPE;

#ifdef CPU_PRIVATE
/*
   Function returns for private i/f procedures handling segment loading.
 */

#define SELECTOR_OK  0
#define GP_ERROR    13
#define NP_ERROR    11
#define SF_ERROR    12
#endif /* CPU_PRIVATE */

#ifdef CCPU

/* Fuctions provided by CPU */
IMPORT void		c_cpu_init	IPT0();
IMPORT void		c_cpu_interrupt	IPT2(CPU_INT_TYPE, type, USHORT, number);
IMPORT void		c_cpu_simulate	IPT0();
IMPORT void		c_cpu_q_ev_set_count	IPT1(ULONG, new_count);
IMPORT ULONG		c_cpu_q_ev_get_count	IPT0();
IMPORT ULONG		c_cpu_calc_q_ev_inst_for_time	IPT1(ULONG, time);
IMPORT void		c_cpu_EOA_hook	IPT0();
IMPORT void		c_cpu_terminate	IPT0();

#define cpu_init		c_cpu_init
#define cpu_interrupt		c_cpu_interrupt
#define cpu_simulate		c_cpu_simulate
#define	host_q_ev_set_count	c_cpu_q_ev_set_count
#define	host_q_ev_get_count	c_cpu_q_ev_get_count
#ifndef host_calc_q_ev_inst_for_time
#define	host_calc_q_ev_inst_for_time	c_cpu_calc_q_ev_inst_for_time
#endif /* host_calc_q_ev_inst_for_time */
#define cpu_EOA_hook		c_cpu_EOA_hook
#define cpu_terminate		c_cpu_terminate

#ifndef CCPU_MAIN


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Byte Registers.                                  */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT half_word c_getAL	IPT0();
IMPORT half_word c_getCL	IPT0();
IMPORT half_word c_getDL	IPT0();
IMPORT half_word c_getBL	IPT0();
IMPORT half_word c_getAH	IPT0();
IMPORT half_word c_getCH	IPT0();
IMPORT half_word c_getDH	IPT0();
IMPORT half_word c_getBH	IPT0();

IMPORT void c_setAL	IPT1(half_word, val);
IMPORT void c_setCL	IPT1(half_word, val);
IMPORT void c_setDL	IPT1(half_word, val);
IMPORT void c_setBL	IPT1(half_word, val);
IMPORT void c_setAH	IPT1(half_word, val);
IMPORT void c_setCH	IPT1(half_word, val);
IMPORT void c_setDH	IPT1(half_word, val);
IMPORT void c_setBH	IPT1(half_word, val);

#define getAL() c_getAL()
#define getCL() c_getCL()
#define getDL() c_getDL()
#define getBL() c_getBL()
#define getAH() c_getAH()
#define getCH() c_getCH()
#define getDH() c_getDH()
#define getBH() c_getBH()

#define setAL(x) c_setAL(x)
#define setCL(x) c_setCL(x)
#define setDL(x) c_setDL(x)
#define setBL(x) c_setBL(x)
#define setAH(x) c_setAH(x)
#define setCH(x) c_setCH(x)
#define setDH(x) c_setDH(x)
#define setBH(x) c_setBH(x)

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Word Registers.                                  */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT word c_getAX	IPT0();
IMPORT word c_getCX	IPT0();
IMPORT word c_getDX	IPT0();
IMPORT word c_getBX	IPT0();
IMPORT word c_getSP	IPT0();
IMPORT word c_getBP	IPT0();
IMPORT word c_getSI	IPT0();
IMPORT word c_getDI	IPT0();
IMPORT word c_getIP	IPT0();

IMPORT void c_setAX	IPT1(word, val);
IMPORT void c_setCX	IPT1(word, val);
IMPORT void c_setDX	IPT1(word, val);
IMPORT void c_setBX	IPT1(word, val);
IMPORT void c_setSP	IPT1(word, val);
IMPORT void c_setBP	IPT1(word, val);
IMPORT void c_setSI	IPT1(word, val);
IMPORT void c_setDI	IPT1(word, val);
IMPORT void c_setIP	IPT1(word, val);

#define getAX() c_getAX()
#define getCX() c_getCX()
#define getDX() c_getDX()
#define getBX() c_getBX()
#define getSP() c_getSP()
#define getBP() c_getBP()
#define getSI() c_getSI()
#define getDI() c_getDI()
#define getIP() c_getIP()

#define setAX(x) c_setAX(x)
#define setCX(x) c_setCX(x)
#define setDX(x) c_setDX(x)
#define setBX(x) c_setBX(x)
#define setSP(x) c_setSP(x)
#define setBP(x) c_setBP(x)
#define setSI(x) c_setSI(x)
#define setDI(x) c_setDI(x)
#define setIP(x) c_setIP(x)

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Segment Registers.                               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT word c_getES	IPT0();
IMPORT word c_getCS	IPT0();
IMPORT word c_getSS	IPT0();
IMPORT word c_getDS	IPT0();

IMPORT INT c_setES	IPT1(word, val);
IMPORT INT c_setCS	IPT1(word, val);
IMPORT INT c_setSS	IPT1(word, val);
IMPORT INT c_setDS	IPT1(word, val);

#define getES() c_getES()
#define getCS() c_getCS()
#define getSS() c_getSS()
#define getDS() c_getDS()

#define setES(x) c_setES(x)
#define setCS(x) c_setCS(x)
#define setSS(x) c_setSS(x)
#define setDS(x) c_setDS(x)

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Full(Private) Segment Registers.                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

#ifdef CPU_PRIVATE

IMPORT word c_getES_SELECTOR	IPT0();
IMPORT word c_getCS_SELECTOR	IPT0();
IMPORT word c_getSS_SELECTOR	IPT0();
IMPORT word c_getDS_SELECTOR	IPT0();

IMPORT word c_getCS_LIMIT	IPT0();
IMPORT word c_getDS_LIMIT	IPT0();
IMPORT word c_getES_LIMIT	IPT0();
IMPORT word c_getSS_LIMIT	IPT0();

IMPORT long c_getCS_BASE	IPT0();
IMPORT long c_getDS_BASE	IPT0();
IMPORT long c_getES_BASE	IPT0();
IMPORT long c_getSS_BASE	IPT0();

IMPORT half_word c_getCS_AR	IPT0();
IMPORT half_word c_getDS_AR	IPT0();
IMPORT half_word c_getES_AR	IPT0();
IMPORT half_word c_getSS_AR	IPT0();

IMPORT void c_setES_SELECTOR	IPT1(word, val);
IMPORT void c_setCS_SELECTOR	IPT1(word, val);
IMPORT void c_setSS_SELECTOR	IPT1(word, val);
IMPORT void c_setDS_SELECTOR	IPT1(word, val);

IMPORT void c_setCS_LIMIT	IPT1(word, val);
IMPORT void c_setDS_LIMIT	IPT1(word, val);
IMPORT void c_setES_LIMIT	IPT1(word, val);
IMPORT void c_setSS_LIMIT	IPT1(word, val);

IMPORT void c_setCS_BASE	IPT1(long, val);
IMPORT void c_setDS_BASE	IPT1(long, val);
IMPORT void c_setES_BASE	IPT1(long, val);
IMPORT void c_setSS_BASE	IPT1(long, val);

IMPORT void c_setCS_AR	IPT1(half_word, val);
IMPORT void c_setDS_AR	IPT1(half_word, val);
IMPORT void c_setES_AR	IPT1(half_word, val);
IMPORT void c_setSS_AR	IPT1(half_word, val);

#define getES_SELECTOR c_getES_SELECTOR
#define getCS_SELECTOR c_getCS_SELECTOR
#define getSS_SELECTOR c_getSS_SELECTOR
#define getDS_SELECTOR c_getDS_SELECTOR

#define getDS_LIMIT c_getDS_LIMIT
#define getCS_LIMIT c_getCS_LIMIT
#define getES_LIMIT c_getES_LIMIT
#define getSS_LIMIT c_getSS_LIMIT

#define getDS_BASE c_getDS_BASE
#define getCS_BASE c_getCS_BASE
#define getES_BASE c_getES_BASE
#define getSS_BASE c_getSS_BASE

#define getDS_AR c_getDS_AR
#define getCS_AR c_getCS_AR
#define getES_AR c_getES_AR
#define getSS_AR c_getSS_AR

#define setES_SELECTOR c_setES_SELECTOR
#define setCS_SELECTOR c_setCS_SELECTOR
#define setSS_SELECTOR c_setSS_SELECTOR
#define setDS_SELECTOR c_setDS_SELECTOR

#define setDS_LIMIT c_setDS_LIMIT
#define setCS_LIMIT c_setCS_LIMIT
#define setES_LIMIT c_setES_LIMIT
#define setSS_LIMIT c_setSS_LIMIT

#define setDS_BASE c_setDS_BASE
#define setCS_BASE c_setCS_BASE
#define setES_BASE c_setES_BASE
#define setSS_BASE c_setSS_BASE

#define setDS_AR c_setDS_AR
#define setCS_AR c_setCS_AR
#define setES_AR c_setES_AR
#define setSS_AR c_setSS_AR

#endif /* CPU_PRIVATE */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Flags.                                           */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT INT c_getAF	IPT0();
IMPORT INT c_getCF	IPT0();
IMPORT INT c_getDF	IPT0();
IMPORT INT c_getIF	IPT0();
IMPORT INT c_getOF	IPT0();
IMPORT INT c_getPF	IPT0();
IMPORT INT c_getSF	IPT0();
IMPORT INT c_getTF	IPT0();
IMPORT INT c_getZF	IPT0();
IMPORT INT c_getIOPL	IPT0();
IMPORT INT c_getNT	IPT0();
IMPORT word c_getSTATUS	IPT0();

IMPORT void c_setAF	IPT1(INT, val);
IMPORT void c_setCF	IPT1(INT, val);
IMPORT void c_setDF	IPT1(INT, val);
IMPORT void c_setIF	IPT1(INT, val);
IMPORT void c_setOF	IPT1(INT, val);
IMPORT void c_setPF	IPT1(INT, val);
IMPORT void c_setSF	IPT1(INT, val);
IMPORT void c_setTF	IPT1(INT, val);
IMPORT void c_setZF	IPT1(INT, val);
IMPORT void c_setIOPL	IPT1(INT, val);
IMPORT void c_setNT	IPT1(INT, val);

#define getAF()     c_getAF()
#define getCF()     c_getCF()
#define getDF()     c_getDF()
#define getIF()     c_getIF()
#define getOF()     c_getOF()
#define getPF()     c_getPF()
#define getSF()     c_getSF()
#define getTF()     c_getTF()
#define getZF()     c_getZF()
#define getIOPL()   c_getIOPL()
#define getNT()     c_getNT()
#define getSTATUS() c_getSTATUS()

#define setAF(x)     c_setAF(x)
#define setCF(x)     c_setCF(x)
#define setDF(x)     c_setDF(x)
#define setIF(x)     c_setIF(x)
#define setOF(x)     c_setOF(x)
#define setPF(x)     c_setPF(x)
#define setSF(x)     c_setSF(x)
#define setTF(x)     c_setTF(x)
#define setZF(x)     c_setZF(x)
#define setIOPL(x)   c_setIOPL(x)
#define setNT(x)     c_setNT(x)

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Machine Status Word.                             */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT INT c_getPE	IPT0();
IMPORT INT c_getMP	IPT0();
IMPORT INT c_getEM	IPT0();
IMPORT INT c_getTS	IPT0();
IMPORT word c_getMSW	IPT0();

#define getPE() c_getPE()
#define getMP() c_getMP()
#define getEM() c_getEM()
#define getTS() c_getTS()
#define getMSW() c_getMSW()

#ifdef CPU_PRIVATE

IMPORT void c_setPE	IPT1(INT, val);
IMPORT void c_setMP	IPT1(INT, val);
IMPORT void c_setEM	IPT1(INT, val);
IMPORT void c_setTS	IPT1(INT, val);
IMPORT void c_setMSW	IPT1(word, val);

#define setPE(x) c_setPE(x)
#define setMP(x) c_setMP(x)
#define setEM(x) c_setEM(x)
#define setTS(x) c_setTS(x)
#define setMSW(x) c_setMSW(x)

#endif /* CPU_PRIVATE */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Descriptor Registers.                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT sys_addr c_getGDT_BASE	IPT0();
IMPORT sys_addr c_getIDT_BASE	IPT0();
IMPORT sys_addr c_getLDT_BASE	IPT0();
IMPORT sys_addr c_getTR_BASE	IPT0();
IMPORT word c_getGDT_LIMIT	IPT0();
IMPORT word c_getIDT_LIMIT	IPT0();
IMPORT word c_getLDT_LIMIT	IPT0();
IMPORT word c_getTR_LIMIT	IPT0();
IMPORT word c_getLDT_SELECTOR	IPT0();
IMPORT word c_getTR_SELECTOR	IPT0();

#define getGDT_BASE() c_getGDT_BASE()
#define getIDT_BASE() c_getIDT_BASE()
#define getLDT_BASE() c_getLDT_BASE()
#define getTR_BASE()  c_getTR_BASE()
#define getGDT_LIMIT() c_getGDT_LIMIT()
#define getIDT_LIMIT() c_getIDT_LIMIT()
#define getLDT_LIMIT() c_getLDT_LIMIT()
#define getTR_LIMIT()  c_getTR_LIMIT()
#define getLDT_SELECTOR() c_getLDT_SELECTOR()
#define getTR_SELECTOR()  c_getTR_SELECTOR()

#ifdef CPU_PRIVATE

IMPORT void c_setGDT_BASE	IPT1(sys_addr, val);
IMPORT void c_setIDT_BASE	IPT1(sys_addr, val);
IMPORT void c_setLDT_BASE	IPT1(sys_addr, val);
IMPORT void c_setTR_BASE	IPT1(sys_addr, val);
IMPORT void c_setGDT_LIMIT	IPT1(word, val);
IMPORT void c_setIDT_LIMIT	IPT1(word, val);
IMPORT void c_setLDT_LIMIT	IPT1(word, val);
IMPORT void c_setTR_LIMIT	IPT1(word, val);
IMPORT void c_setLDT_SELECTOR	IPT1(word, val);
IMPORT void c_setTR_SELECTOR	IPT1(word, val);

#define setGDT_BASE(x) c_setGDT_BASE(x)
#define setIDT_BASE(x) c_setIDT_BASE(x)
#define setLDT_BASE(x) c_setLDT_BASE(x)
#define setTR_BASE(x)  c_setTR_BASE(x)
#define setGDT_LIMIT(x) c_setGDT_LIMIT(x)
#define setIDT_LIMIT(x) c_setIDT_LIMIT(x)
#define setLDT_LIMIT(x) c_setLDT_LIMIT(x)
#define setTR_LIMIT(x)  c_setTR_LIMIT(x)
#define setLDT_SELECTOR(x) c_setLDT_SELECTOR(x)
#define setTR_SELECTOR(x)  c_setTR_SELECTOR(x)

#endif /* CPU_PRIVATE */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Current Privilege Level.                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

#ifdef CPU_PRIVATE

IMPORT INT c_getCPL	IPT0();
IMPORT VOID c_setCPL	IPT1(INT, val);

#define getCPL() c_getCPL()
#define setCPL(x) c_setCPL(x)

#endif /* CPU_PRIVATE */

#endif /* CCPU_MAIN */

#endif /* CCPU */

#ifdef A3CPU

/*
 *	Function imports...
 */

/*
 *	cpu_init() - Initialises the 3.0 CPU.
 */

IMPORT VOID		a3_cpu_init();

/*
 *	cpu_interrupt() - Interrupts the 3.0 CPU.
 */
#ifdef SWITCHED_CPU
IMPORT VOID		a3_cpu_interrupt IPT2(CPU_INT_TYPE, type, IU16, number);
#else
IMPORT VOID		a3_cpu_interrupt();
#endif

/*
 *	cpu_simulate() - Performs INTEL CPU emulation.
 */
IMPORT VOID		_asm_simulate();

IMPORT VOID		a3_cpu_q_ev_set_count();
IMPORT ULONG		a3_cpu_q_ev_get_count();

#ifndef SWITCHED_CPU

IMPORT ULONG		a3_cpu_calc_q_ev_inst_for_time();

/*
 *	cpu_EOA_hook() - Resets the 3.0 CPU prior to running the next application.
 */
IMPORT VOID		a3_cpu_EOA_hook();

/*
 *	cpu_terminate() - Closes down the CPU.
 */
IMPORT VOID		a3_cpu_terminate();

IMPORT VOID C_garbage_collect_odd_based_selectors IFN0();

/*
 *	Intel register Access...
 */

#ifdef NTVDM
IMPORT half_word        getAL();
IMPORT half_word        getBL();
IMPORT half_word        getCL();
IMPORT half_word        getDL();
IMPORT half_word        getAH();
IMPORT half_word        getBH();
IMPORT half_word        getCH();
IMPORT half_word        getDH();

IMPORT word             getAX();
IMPORT word             getBX();
IMPORT word             getCX();
IMPORT word             getDX();
IMPORT word             getSP();
IMPORT word             getBP();
IMPORT word             getSI();
IMPORT word             getDI();

IMPORT word             getIP();

IMPORT word             getCS();
IMPORT word             getDS();
IMPORT word             getES();
IMPORT word             getSS();

IMPORT word             getAF();
IMPORT word             getCF();
IMPORT word             getDF();
IMPORT word             getIF();
IMPORT word		a3_getIOPL();
IMPORT word		a3_getNT();
IMPORT word             getOF();
IMPORT word             getPF();
IMPORT word             getSF();
IMPORT word             getTF();
IMPORT word             getZF();

IMPORT word		a3_getSTATUS();

IMPORT word		a3_getEM();
IMPORT word		a3_getMP();
IMPORT word		a3_getPE();
IMPORT word		a3_getTS();

IMPORT word             getMSW();

IMPORT sys_addr		a3_getGDT_BASE();
IMPORT word		a3_getGDT_LIMIT();

IMPORT sys_addr		a3_getIDT_BASE();
IMPORT word		a3_getIDT_LIMIT();

IMPORT sys_addr		a3_getLDT_BASE();
IMPORT word		a3_getLDT_LIMIT();
IMPORT word		a3_getLDT_SELECTOR();

IMPORT sys_addr		a3_getTR_BASE();
IMPORT word		a3_getTR_LIMIT();
IMPORT word		a3_getTR_SELECTOR();

IMPORT VOID             setAL();
IMPORT VOID             setCL();
IMPORT VOID             setDL();
IMPORT VOID             setBL();
IMPORT VOID             setAH();
IMPORT VOID             setCH();
IMPORT VOID             setDH();
IMPORT VOID             setBH();

IMPORT VOID             setAX();
IMPORT VOID             setCX();
IMPORT VOID             setDX();
IMPORT VOID             setBX();
IMPORT VOID             setSP();
IMPORT VOID             setBP();
IMPORT VOID             setSI();
IMPORT VOID             setDI();

IMPORT VOID             setIP();

IMPORT INT              setES();
IMPORT INT              setCS();
IMPORT INT              setSS();
IMPORT INT              setDS();

IMPORT VOID             setCF();
IMPORT VOID             setPF();
IMPORT VOID             setAF();
IMPORT VOID             setZF();
IMPORT VOID             setSF();
IMPORT VOID             setTF();
IMPORT VOID             setIF();
IMPORT VOID             setDF();
IMPORT VOID             setOF();
IMPORT VOID		a3_setIOPL();
IMPORT VOID             a3_setNT();


#else
IMPORT half_word	a3_getAL();
IMPORT half_word	a3_getBL();
IMPORT half_word	a3_getCL();
IMPORT half_word	a3_getDL();
IMPORT half_word	a3_getAH();
IMPORT half_word	a3_getBH();
IMPORT half_word	a3_getCH();
IMPORT half_word	a3_getDH();

IMPORT word		a3_getAX();
IMPORT word		a3_getBX();
IMPORT word		a3_getCX();
IMPORT word		a3_getDX();
IMPORT word		a3_getSP();
IMPORT word		a3_getBP();
IMPORT word		a3_getSI();
IMPORT word		a3_getDI();

IMPORT word		a3_getIP();

IMPORT word		a3_getCS();
IMPORT word		a3_getDS();
IMPORT word		a3_getES();
IMPORT word		a3_getSS();

IMPORT word		a3_getAF();
IMPORT word		a3_getCF();
IMPORT word		a3_getDF();
IMPORT word		a3_getIF();
IMPORT word		a3_getIOPL();
IMPORT word		a3_getNT();
IMPORT word		a3_getOF();
IMPORT word		a3_getPF();
IMPORT word		a3_getSF();
IMPORT word		a3_getTF();
IMPORT word		a3_getZF();

IMPORT word		a3_getSTATUS();

IMPORT word		a3_getEM();
IMPORT word		a3_getMP();
IMPORT word		a3_getPE();
IMPORT word		a3_getTS();

IMPORT word		a3_getMSW();

IMPORT sys_addr		a3_getGDT_BASE();
IMPORT word		a3_getGDT_LIMIT();

IMPORT sys_addr		a3_getIDT_BASE();
IMPORT word		a3_getIDT_LIMIT();

IMPORT sys_addr		a3_getLDT_BASE();
IMPORT word		a3_getLDT_LIMIT();
IMPORT word		a3_getLDT_SELECTOR();

IMPORT sys_addr		a3_getTR_BASE();
IMPORT word		a3_getTR_LIMIT();
IMPORT word		a3_getTR_SELECTOR();

IMPORT VOID		a3_setAL();
IMPORT VOID		a3_setCL();
IMPORT VOID		a3_setDL();
IMPORT VOID		a3_setBL();
IMPORT VOID		a3_setAH();
IMPORT VOID		a3_setCH();
IMPORT VOID		a3_setDH();
IMPORT VOID		a3_setBH();

IMPORT VOID		a3_setAX();
IMPORT VOID		a3_setCX();
IMPORT VOID		a3_setDX();
IMPORT VOID		a3_setBX();
IMPORT VOID		a3_setSP();
IMPORT VOID		a3_setBP();
IMPORT VOID		a3_setSI();
IMPORT VOID		a3_setDI();

IMPORT VOID		a3_setIP();

IMPORT INT		a3_setES();
IMPORT INT		a3_setCS();
IMPORT INT		a3_setSS();
IMPORT INT		a3_setDS();

IMPORT VOID		a3_setCF();
IMPORT VOID		a3_setPF();
IMPORT VOID		a3_setAF();
IMPORT VOID		a3_setZF();
IMPORT VOID		a3_setSF();
IMPORT VOID		a3_setTF();
IMPORT VOID		a3_setIF();
IMPORT VOID		a3_setDF();
IMPORT VOID		a3_setOF();
IMPORT VOID		a3_setIOPL();
IMPORT VOID             a3_setNT();
#endif /* NTVDM */


#ifdef CPU_PRIVATE

IMPORT word		a3_p_getCPL();
IMPORT word		a3_p_getES_SELECTOR();
IMPORT sys_addr		a3_p_getES_BASE();
IMPORT word		a3_p_getES_LIMIT();
IMPORT half_word	a3_p_getES_AR();
IMPORT VOID		a3_p_setES_SELECTOR();
IMPORT VOID		a3_p_setES_BASE();
IMPORT VOID		a3_p_setES_LIMIT();
IMPORT VOID		a3_p_setES_AR();
IMPORT word		a3_p_getCS_SELECTOR();
IMPORT sys_addr		a3_p_getCS_BASE();
IMPORT word		a3_p_getCS_LIMIT();
IMPORT half_word	a3_p_getCS_AR();
IMPORT VOID		a3_p_setCS_SELECTOR();
IMPORT VOID		a3_p_setCS_BASE();
IMPORT VOID		a3_p_setCS_LIMIT();
IMPORT VOID		a3_p_setCS_AR();
IMPORT word		a3_p_getDS_SELECTOR();
IMPORT sys_addr		a3_p_getDS_BASE();
IMPORT word		a3_p_getDS_LIMIT();
IMPORT half_word	a3_p_getDS_AR();
IMPORT VOID		a3_p_setDS_SELECTOR();
IMPORT VOID		a3_p_setDS_BASE();
IMPORT VOID		a3_p_setDS_LIMIT();
IMPORT VOID		a3_p_setDS_AR();
IMPORT word		a3_p_getSS_SELECTOR();
IMPORT sys_addr		a3_p_getSS_BASE();
IMPORT word		a3_p_getSS_LIMIT();
IMPORT half_word	a3_p_getSS_AR();
IMPORT VOID		a3_p_setSS_SELECTOR();
IMPORT VOID		a3_p_setSS_BASE();
IMPORT VOID		a3_p_setSS_LIMIT();
IMPORT VOID		a3_p_setSS_AR();
IMPORT VOID		a3_p_setPE();
IMPORT VOID		a3_p_setMP();
IMPORT VOID		a3_p_setEM();
IMPORT VOID		a3_p_setTS();
IMPORT VOID		a3_p_setMSW();
IMPORT VOID		a3_p_setCPL();
IMPORT VOID		a3_p_setGDT_BASE();
IMPORT VOID		a3_p_setGDT_LIMIT();
IMPORT VOID		a3_p_setIDT_BASE();
IMPORT VOID		a3_p_setIDT_LIMIT();
IMPORT VOID		a3_p_setLDT_SELECTOR();
IMPORT VOID		a3_p_setLDT_BASE();
IMPORT VOID		a3_p_setLDT_LIMIT();
IMPORT VOID		a3_p_setTR_SELECTOR();
IMPORT VOID		a3_p_setTR_BASE();
IMPORT VOID		a3_p_setTR_LIMIT();

#endif /* CPU_PRIVATE */
#endif /* SWITCHED_CPU */


/*
 *	Macro definitions...
 */

#define cpu_init		a3_cpu_init
#define cpu_simulate		_asm_simulate
#define	host_q_ev_set_count	a3_cpu_q_ev_set_count
#define	host_q_ev_get_count	a3_cpu_q_ev_get_count
#ifndef host_calc_q_ev_inst_for_time
#define	host_calc_q_ev_inst_for_time	a3_cpu_calc_q_ev_inst_for_time
#endif /* host_calc_q_ev_inst_for_time */
#define cpu_EOA_hook		a3_cpu_EOA_hook
#define cpu_terminate		a3_cpu_terminate

/*
 *	Intel register Access...
 */

#ifndef getAX

#define cpu_interrupt		a3_cpu_interrupt

#ifdef NTVDM

#define getIOPL		a3_getIOPL
#define getNT		a3_getNT
#define getSTATUS	a3_getSTATUS
#define getEM		a3_getEM
#define getMP		a3_getMP
#define getPE		a3_getPE
#define getTS		a3_getTS
#define getGDT_BASE	a3_getGDT_BASE
#define getGDT_LIMIT	a3_getGDT_LIMIT
#define getIDT_BASE	a3_getIDT_BASE
#define getIDT_LIMIT	a3_getIDT_LIMIT
#define getLDT_BASE	a3_getLDT_BASE
#define getLDT_LIMIT	a3_getLDT_LIMIT
#define getLDT_SELECTOR	a3_getLDT_SELECTOR
#define getTR_BASE	a3_getTR_BASE
#define getTR_LIMIT	a3_getTR_LIMIT
#define getTR_SELECTOR	a3_getTR_SELECTOR
#define setIOPL		a3_setIOPL
#define setNT		a3_setNT


#else

#define getAL		a3_getAL
#define getBL		a3_getBL
#define getCL		a3_getCL
#define getDL		a3_getDL
#define getAH		a3_getAH
#define getBH		a3_getBH
#define getCH		a3_getCH
#define getDH		a3_getDH
#define getAX		a3_getAX
#define getBX		a3_getBX
#define getCX		a3_getCX
#define getDX		a3_getDX
#define getSP		a3_getSP
#define getBP		a3_getBP
#define getSI		a3_getSI
#define getDI		a3_getDI
#define getIP		a3_getIP
#define getCS		a3_getCS
#define getDS		a3_getDS
#define getES		a3_getES
#define getSS		a3_getSS
#define getAF		a3_getAF
#define getCF		a3_getCF
#define getDF		a3_getDF
#define getIF		a3_getIF
#define getIOPL		a3_getIOPL
#define getNT		a3_getNT
#define getOF		a3_getOF
#define getPF		a3_getPF
#define getSF		a3_getSF
#define getTF		a3_getTF
#define getZF		a3_getZF
#define getSTATUS	a3_getSTATUS
#define getEM		a3_getEM
#define getMP		a3_getMP
#define getPE		a3_getPE
#define getTS		a3_getTS
#define getMSW		a3_getMSW
#define getGDT_BASE	a3_getGDT_BASE
#define getGDT_LIMIT	a3_getGDT_LIMIT
#define getIDT_BASE	a3_getIDT_BASE
#define getIDT_LIMIT	a3_getIDT_LIMIT
#define getLDT_BASE	a3_getLDT_BASE
#define getLDT_LIMIT	a3_getLDT_LIMIT
#define getLDT_SELECTOR	a3_getLDT_SELECTOR
#define getTR_BASE	a3_getTR_BASE
#define getTR_LIMIT	a3_getTR_LIMIT
#define getTR_SELECTOR	a3_getTR_SELECTOR
#define setAL		a3_setAL
#define setCL		a3_setCL
#define setDL		a3_setDL
#define setBL		a3_setBL
#define setAH		a3_setAH
#define setCH		a3_setCH
#define setDH		a3_setDH
#define setBH		a3_setBH
#define setAX		a3_setAX
#define setCX		a3_setCX
#define setDX		a3_setDX
#define setBX		a3_setBX
#define setSP		a3_setSP
#define setBP		a3_setBP
#define setSI		a3_setSI
#define setDI		a3_setDI
#define setIP		a3_setIP
#define setES		a3_setES
#define setCS		a3_setCS
#define setSS		a3_setSS
#define setDS		a3_setDS
#define setCF		a3_setCF
#define setPF		a3_setPF
#define setAF		a3_setAF
#define setZF		a3_setZF
#define setSF		a3_setSF
#define setTF		a3_setTF
#define setIF		a3_setIF
#define setDF		a3_setDF
#define setOF		a3_setOF
#define setIOPL		a3_setIOPL
#define setNT		a3_setNT

#endif	/* NTVDM */

#endif /* getAX */

#ifdef CPU_PRIVATE

#define getCPL		a3_p_getCPL
#define getES_SELECTOR	a3_p_getES_SELECTOR
#define getCS_SELECTOR	a3_p_getCS_SELECTOR
#define getSS_SELECTOR	a3_p_getSS_SELECTOR
#define getDS_SELECTOR	a3_p_getDS_SELECTOR
#define getES_BASE	a3_p_getES_BASE
#define getCS_BASE	a3_p_getCS_BASE
#define getDS_BASE	a3_p_getDS_BASE
#define getSS_BASE	a3_p_getSS_BASE
#define getES_LIMIT	a3_p_getES_LIMIT
#define getCS_LIMIT	a3_p_getCS_LIMIT
#define getDS_LIMIT	a3_p_getDS_LIMIT
#define getSS_LIMIT	a3_p_getSS_LIMIT
#define getES_AR	a3_p_getES_AR
#define getCS_AR	a3_p_getCS_AR
#define getDS_AR	a3_p_getDS_AR
#define getSS_AR	a3_p_getSS_AR
#define setES_SELECTOR	a3_p_setES_SELECTOR
#define setCS_SELECTOR	a3_p_setCS_SELECTOR
#define setSS_SELECTOR	a3_p_setSS_SELECTOR
#define setDS_SELECTOR	a3_p_setDS_SELECTOR
#define setES_BASE	a3_p_setES_BASE
#define setCS_BASE	a3_p_setCS_BASE
#define setDS_BASE	a3_p_setDS_BASE
#define setSS_BASE	a3_p_setSS_BASE
#define setES_LIMIT	a3_p_setES_LIMIT
#define setCS_LIMIT	a3_p_setCS_LIMIT
#define setDS_LIMIT	a3_p_setDS_LIMIT
#define setSS_LIMIT	a3_p_setSS_LIMIT
#define setES_AR	a3_p_setES_AR
#define setCS_AR	a3_p_setCS_AR
#define setDS_AR	a3_p_setDS_AR
#define setSS_AR	a3_p_setSS_AR
#define setPE		a3_p_setPE
#define setMP		a3_p_setMP
#define setEM		a3_p_setEM
#define setTS		a3_p_setTS
#define setMSW		a3_p_setMSW
#define setCPL		a3_p_setCPL
#define setGDT_BASE	a3_p_setGDT_BASE
#define setGDT_LIMIT	a3_p_setGDT_LIMIT
#define setIDT_BASE	a3_p_setIDT_BASE
#define setIDT_LIMIT	a3_p_setIDT_LIMIT
#define setLDT_SELECTOR	a3_p_setLDT_SELECTOR
#define setLDT_BASE	a3_p_setLDT_BASE
#define setLDT_LIMIT	a3_p_setLDT_LIMIT
#define setTR_SELECTOR	a3_p_setTR_SELECTOR
#define setTR_BASE	a3_p_setTR_BASE
#define setTR_LIMIT	a3_p_setTR_LIMIT

#endif /* CPU_PRIVATE */
#else
extern IU8  getIOPL();
extern IBOOL getNT();
extern IBOOL getTS();
extern IBOOL getEM();
extern IBOOL getMP();
extern word getCPL();
extern IU32 getEFLAGS();
extern IU32 getFLAGS();

#endif /* A3CPU */

#else /* CPU_30_STYLE */

/*
 * CPU Data Area
 * These externs are given before host_cpu.h is included so that the
 * variables may be gathreed into a structure and the externs overridden
* by #defines in host_cpu.h
 */

extern	word protected_mode;   /* =0 no proteced mode warning given
       		                   =1 proteced mode warning given */
extern  word            cpu_interrupt_map;
extern  half_word       cpu_int_translate[];
extern  word            cpu_int_delay;
extern  half_word       ica_lock;
extern  void            (*(jump_ptrs[]))();
extern  void            (*(b_write_ptrs[]))();
extern  void            (*(w_write_ptrs[]))();
extern  void            (*(b_fill_ptrs[]))();
extern  void            (*(w_fill_ptrs[]))();
#ifdef EGATEST
extern  void            (*(b_fwd_move_ptrs[]))();
extern  void            (*(w_fwd_move_ptrs[]))();
extern  void            (*(b_bwd_move_ptrs[]))();
extern  void            (*(w_bwd_move_ptrs[]))();
#else
extern  void            (*(b_move_ptrs[]))();
extern  void            (*(w_move_ptrs[]))();
#endif /* EGATEST */
extern  half_word       *haddr_of_src_string;

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * The cpu opcode sliding frame
 */

#ifdef BACK_M
typedef struct
{
                half_word FOURTH_BYTE;
                half_word THIRD_BYTE;
                half_word SECOND_BYTE;
                half_word OPCODE;
}  OPCODE_FRAME;

typedef struct
{
                signed_char FOURTH_BYTE;
                signed_char THIRD_BYTE;
                signed_char SECOND_BYTE;
                signed_char OPCODE;
}  SIGNED_OPCODE_FRAME;
#else
typedef struct
{
                half_word OPCODE;
                half_word SECOND_BYTE;
                half_word THIRD_BYTE;
                half_word FOURTH_BYTE;
}  OPCODE_FRAME;

typedef struct
{
                signed_char OPCODE;
                signed_char SECOND_BYTE;
                signed_char THIRD_BYTE;
                signed_char FOURTH_BYTE;
}  SIGNED_OPCODE_FRAME;
#endif /* BACK_M */

/*
 * The new ICA uses the following for H/W ints:
 */

#define CPU_HW_INT		0
#define CPU_HW_INT_MASK		(1 << CPU_HW_INT)

/*
 * CPU software interrupt definitions
 */

#define CPU_SW_INT              8
#define CPU_SW_INT_MASK         (1 << CPU_SW_INT)

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

extern OPCODE_FRAME *opcode_frame;	/* C CPU and dasm only		    */

/*
 * External declarations for the 80286 registers
 */

extern reg A;           /* Accumulator          */
extern reg B;           /* Base                 */
extern reg C;           /* Count                */
extern reg D;           /* Data                 */
extern reg SP;          /* Stack Pointer        */
extern reg BP;          /* Base pointer         */
extern reg SI;          /* Source Index         */
extern reg DI;          /* Destination Index    */
extern reg IP;          /* Instruction Pointer  */
extern reg CS;          /* Code Segment         */
extern reg DS;          /* Data Segment         */
extern reg SS;          /* Stack Segment        */
extern reg ES;          /* Extra Segment        */

/*
 * External function declarations. These may be defined to other things.
 */

#ifndef	host_simulate
extern void host_simulate	IPT0();
#endif	/* host_simulate */

#ifndef	host_cpu_reset
extern void host_cpu_reset	IPT0();
#endif	/* host_cpu_reset */

#ifndef	host_cpu_init
extern void host_cpu_init	IPT0();
#endif	/* host_cpu_init */

#ifndef	host_cpu_interrupt
extern void host_cpu_interrupt	IPT0();
#endif	/* host_cpu_interrupt */

/*
 * Definition of Descriptor Table
 */

#ifdef BIGEND

union sixteenbits
{
	word X;

	struct
	{
		half_word lower;
		half_word upper;
	} word;
};

#endif	/* BIGEND */

#ifdef LITTLEND

union sixteenbits
{
	word X;

	struct
	{
		half_word upper;
		half_word lower;
	} word;
};

#endif	/* LITTLEND */

struct DESC_TABLE
{
	union sixteenbits misc;
	union sixteenbits base;
	union sixteenbits limit;
};

#define CPU_SIGALRM_EXCEPTION           15              /* SIGALRM signal
*/
#define CPU_SIGALRM_EXCEPTION_MASK      (1 << CPU_SIGALRM_EXCEPTION)

#define CPU_TRAP_EXCEPTION              11              /* TRAP FLAG
*/
#define CPU_TRAP_EXCEPTION_MASK         (1 << CPU_TRAP_EXCEPTION)

#define CPU_YODA_EXCEPTION              13              /* YODA FLAG
*/
#define CPU_YODA_EXCEPTION_MASK         (1 << CPU_YODA_EXCEPTION)

#define CPU_SIGIO_EXCEPTION             14              /* SIGIO FLAG
*/
#define CPU_SIGIO_EXCEPTION_MASK        (1 << CPU_SIGIO_EXCEPTION)

#define CPU_RESET_EXCEPTION             12              /* RESET FLAG
*/
#define CPU_RESET_EXCEPTION_MASK        (1 << CPU_RESET_EXCEPTION)

#ifdef CCPU

IMPORT void sw_host_simulate IPT0();
IMPORT int selector_outside_table IPT2(word, selector, sys_addr *, descr_addr);
IMPORT void cpu_init IPT0();

/*
   Define descriptor 'super' types.
 */
#define INVALID				0x00
#define AVAILABLE_TSS			0x01
#define LDT_SEGMENT			0x02
#define BUSY_TSS			0x03
#define CALL_GATE			0x04
#define TASK_GATE			0x05
#define INTERRUPT_GATE			0x06
#define TRAP_GATE			0x07
#define EXPANDUP_READONLY_DATA		0x11
#define EXPANDUP_WRITEABLE_DATA		0x13
#define EXPANDDOWN_READONLY_DATA	0x15
#define EXPANDDOWN_WRITEABLE_DATA	0x17
#define NONCONFORM_NOREAD_CODE		0x19
#define NONCONFORM_READABLE_CODE	0x1b
#define CONFORM_NOREAD_CODE		0x1d
#define CONFORM_READABLE_CODE		0x1f

/* Code Segment (Private) */
extern half_word CS_AR;
extern sys_addr  CS_base;
extern word      CS_limit;

/* Data Segment (Private) */
extern half_word DS_AR;
extern sys_addr  DS_base;
extern word      DS_limit;

/* Stack Segment (Private) */
extern half_word SS_AR;
extern sys_addr  SS_base;
extern word      SS_limit;

/* Extra Segment (Private) */
extern half_word ES_AR;
extern sys_addr  ES_base;
extern word      ES_limit;

/* Local Descriptor Table Register (Private) */
extern sys_addr LDTR_base;  /* Base Address */
extern word     LDTR_limit; /* Segment 'size' */

/* Task Register (Private) */
extern sys_addr TR_base;  /* Base Address */
extern word     TR_limit; /* Segment 'size' */

/* Interrupt status, defines any abnormal processing */
extern int doing_contributory;
extern int doing_double_fault;

/* HOST - decoded access rights */
extern int ALC_CS;
extern int ALC_DS;
extern int ALC_ES;
extern int ALC_SS;

#define X_REAL 0
#define C_UPRO 1
#define C_DNRO 6
#define C_PROT 2
#define C_UPRW 7
#define C_DNRW 8
#define S_UP   3
#define S_DOWN 4
#define S_BAD  5
#define D_CODE 1
#define D_UPRO 1
#define D_DNRO 6
#define D_UPRW 7
#define D_DNRW 8
#define D_BAD  2

/*
 *
 *******************************************************************
 * The 'C' cpu register access functions.             		   *
 *******************************************************************
 *
 */

#define getCS_SELECTOR()	CS.X
#define getDS_SELECTOR()	DS.X
#define getSS_SELECTOR()	SS.X
#define getES_SELECTOR()	ES.X

#define getCS_AR()		CS_AR
#define getDS_AR()		DS_AR
#define getSS_AR()		SS_AR
#define getES_AR()		ES_AR

#define getCS_BASE()		CS_base
#define getDS_BASE()		DS_base
#define getSS_BASE()		SS_base
#define getES_BASE()		ES_base

#define getCS_LIMIT()		CS_limit
#define getDS_LIMIT()		DS_limit
#define getSS_LIMIT()		SS_limit
#define getES_LIMIT()		ES_limit

#define getLDT_BASE()		LDTR_base
#define getLDT_LIMIT()		LDTR_limit

#define getTR_BASE()	        TR_base
#define getTR_LIMIT()	        TR_limit

#define setCS_SELECTOR(val)	CS.X     = val
#define setDS_SELECTOR(val)	DS.X     = val
#define setSS_SELECTOR(val)	SS.X     = val
#define setES_SELECTOR(val)	ES.X     = val

#define setCS_AR(val)		CS_AR    = val
#define setDS_AR(val)		DS_AR    = val
#define setSS_AR(val)		SS_AR    = val
#define setES_AR(val)		ES_AR    = val

#define setCS_BASE(val)		CS_base  = val
#define setDS_BASE(val)		DS_base  = val
#define setSS_BASE(val)		SS_base  = val
#define setES_BASE(val)		ES_base  = val

#define setCS_LIMIT(val)	CS_limit = val
#define setDS_LIMIT(val)	DS_limit = val
#define setSS_LIMIT(val)	SS_limit = val
#define setES_LIMIT(val)	ES_limit = val

#define setLDT_BASE(val)	LDTR_base  = val
#define setLDT_LIMIT(val)	LDTR_limit = val

#define setTR_BASE(val)		TR_base  = val
#define setTR_LIMIT(val)	TR_limit = val
/*
 * The Machine Status Word structure
 */
typedef struct
{
     unsigned int :16;
     unsigned int reserved:12;
     unsigned int TS:1;
     unsigned int EM:1;
     unsigned int MP:1;
     unsigned int PE:1;
} mreg;

extern sys_addr address_line_mask;

extern int       CPL;   /* Current Privilege Level */

/* Global Descriptor Table Register */
extern sys_addr GDTR_base;  /* Base Address */
extern word     GDTR_limit; /* Segment 'size' */

/* Interrupt Descriptor Table Register */
extern sys_addr IDTR_base;  /* Base Address */
extern word     IDTR_limit; /* Segment 'size' */

/* Local Descriptor Table Register */
extern reg  LDTR;       /* Selector */

/* Task Register */
extern reg  TR;       /* Selector */

extern mreg MSW;     /* Machine Status Word */

extern int STATUS_CF;
extern int STATUS_SF;
extern int STATUS_ZF;
extern int STATUS_AF;
extern int STATUS_OF;
extern int STATUS_PF;
extern int STATUS_TF;
extern int STATUS_IF;
extern int STATUS_DF;
extern int STATUS_NT;
extern int STATUS_IOPL;

/*
**==========================================================================
** The CCPU basic register access macros. These may be overridden in
** host-cpu.h.
**==========================================================================
*/

#ifndef	getAX

/* READ functions  */
#define  getAX()	(A.X)
#define	 getAH()	(A.byte.high)
#define	 getAL()	(A.byte.low)
#define	 getBX()	(B.X)
#define	 getBH()	(B.byte.high)
#define	 getBL()	(B.byte.low)
#define	 getCX()	(C.X)
#define	 getCH()	(C.byte.high)
#define	 getCL()	(C.byte.low)
#define	 getDX()	(D.X)
#define	 getDH()	(D.byte.high)
#define	 getDL()	(D.byte.low)
#define	 getSP()	(SP.X)
#define	 getBP()	(BP.X)
#define	 getSI()	(SI.X)
#define	 getDI()	(DI.X)
#define	 getIP()	(IP.X)
#define	 getCS()	(CS.X)
#define	 getDS()	(DS.X)
#define	 getES()	(ES.X)
#define	 getSS()	(SS.X)
#define	 getMSW()	(m_s_w)
#define	 getDF()	(STATUS_DF)
#define	 getIF()	(STATUS_IF)
#define	 getTF()	(STATUS_TF)
#define	 getPF()	(STATUS_PF)
#define	 getAF()	(STATUS_AF)
#define	 getSF()	(STATUS_SF)
#define	 getZF()	(STATUS_ZF)
#define	 getOF()	(STATUS_OF)
#define	 getCF()    	(STATUS_CF)

#define getCPL()		(CPL)
#define getGDT_BASE()		(GDTR_base)
#define getGDT_LIMIT()		(GDTR_limit)
#define getIDT_BASE()		(IDTR_base)
#define getIDT_LIMIT()		(IDTR_limit)
#define getLDT_SELECTOR()		(LDTR.X)
#define getTR_SELECTOR()			(TR.X)
#define getMSW_reserved()	(MSW.reserved)
#define getTS()		(MSW.TS)
#define getEM()		(MSW.EM)
#define getMP()		(MSW.MP)
#define getPE()		(MSW.PE)
#define getNT()		(STATUS_NT)
#define getIOPL()	(STATUS_IOPL)
#define	 getSTATUS() 	(getCF()        |	\
			getOF()   << 11 |	\
			getZF()   << 6  |	\
			getSF()   << 7  |	\
			getAF()   << 4  |	\
			getPF()   << 2  |	\
			getTF()   << 8  |	\
			getIF()   << 9  |	\
			getDF()   << 10 |	\
			getIOPL() << 12 |	\
			getNT()   << 14)

extern	ext_load_CS();
extern	ext_load_DS();
extern	ext_load_ES();
extern	ext_load_SS();

/* WRITE functions  */
#define  setAX(val)	(A.X = (val))
#define	 setAH(val)	(A.byte.high = (val))
#define	 setAL(val)	(A.byte.low = (val))
#define	 setBX(val)	(B.X = (val))
#define	 setBH(val)	(B.byte.high = (val))
#define	 setBL(val)	(B.byte.low = (val))
#define	 setCX(val)	(C.X = (val))
#define	 setCH(val)	(C.byte.high = (val))
#define	 setCL(val)	(C.byte.low = (val))
#define	 setDX(val)	(D.X = (val))
#define	 setDH(val)	(D.byte.high = (val))
#define	 setDL(val)	(D.byte.low = (val))
#define	 setSP(val)	(SP.X = (val))
#define	 setBP(val)	(BP.X = (val))
#define	 setSI(val)	(SI.X = (val))
#define	 setDI(val)	(DI.X = (val))
#define	 setIP(val)	(IP.X = (val))
#define	 setCS(val)	ext_load_CS (val)
#define	 setDS(val)	ext_load_DS (val)
#define	 setES(val)	ext_load_ES (val)
#define	 setSS(val)	ext_load_SS (val)
#define	 setMSW(val)	(m_s_w = (val))
#define	 setDF(val)	(STATUS_DF = (val))
#define	 setIF(val)	(STATUS_IF = (val))
#define	 setTF(val)	(STATUS_TF = (val))
#define	 setPF(val)	(STATUS_PF = (val))
#define	 setAF(val)	(STATUS_AF = (val))
#define	 setSF(val)	(STATUS_SF = (val))
#define	 setZF(val)	(STATUS_ZF = (val))
#define	 setOF(val)	(STATUS_OF = (val))
#define	 setCF(val)	(STATUS_CF = (val))

#define setCPL(val)		(CPL = (val))
#define setGDT_BASE(val)	(GDTR_base = (val))
#define setGDT_LIMIT(val)	(GDTR_limit = (val))
#define setIDT_BASE(val)	(IDTR_base = (val))
#define setIDT_LIMIT(val)	(IDTR_limit = (val))
#define setLDT_SELECTOR(val)		(LDTR.X = (val))
#define setTR_SELECTOR(val)		(TR.X = (val))
#define setMSW_reserved(val)	(MSW.reserved = (val))
#define setTS(val)		(MSW.TS = (val))
#define setEM(val)		(MSW.EM = (val))
#define setMP(val)		(MSW.MP = (val))
#define setPE(val)		(MSW.PE = (val))
#define setNT(val)		(STATUS_NT = (val))
#define setIOPL(val)	(STATUS_IOPL = (val))

#else

#endif	/* getAX - default CCPU register access macros */

#endif /* CCPU */

#endif /* CPU_30_STYLE */
#endif /* NTVDM && MONITOR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\ckmalloc.h ===
/*[
 *      Product:        SoftPC-AT Revision 3.0
 *
 *      Name:           ckmalloc.h
 *
 *      Author:         Jerry Sexton
 *
 *      Created On:     15th April 1991
 *
 *      Sccs ID:        @(#)ckmalloc.h	1.4 08/10/92
 *
 *      Purpose:        This header file defines a macro which programs can
 *                      use to exit cleanly if malloc fails.
 *
 *      (c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
 *
]*/

#include "error.h"
#include MemoryH

/*
 * Allocate `nitems' items of type `type' to `var' and exit cleanly on failure.
 */
#define check_malloc(var, nitems, type) \
        while ((var = (type *) host_malloc((nitems) * sizeof(type))) == NULL) \
        { \
                host_error(EG_MALLOC_FAILURE, ERR_CONT | ERR_QUIT, ""); \
        }

/*
 * Allocate `nitems' items of type `type' to `var' and exit cleanly on failure.
 * Similar to above, but memory is guaranteed to be of value zero.
 */
#define check_calloc(var, nitems, type) \
        while ((var = (type *) host_calloc((nitems), sizeof(type))) == NULL) \
        { \
                host_error(EG_MALLOC_FAILURE, ERR_CONT | ERR_QUIT, ""); \
        }

/*
 * Re-allocate a previously allocated pointer 'in_var', of type 'type', to a pointer
 * 'out_var' to 'nitems' of type 'type'
 */
#define check_realloc(out_var, in_var, nitems, type) \
        while ((out_var = (type *) host_realloc(in_var, (nitems) * sizeof(type))) == NULL) \
        { \
                host_error(EG_MALLOC_FAILURE, ERR_CONT | ERR_QUIT, ""); \
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\cmos.h ===
/*
 * SoftPC-AT Revision 2.0
 *
 * Title	: IBM PC-AT CMOS and Real-Time Clock declarations
 *
 * Description	: This module contains declarations that are used in
 *		  accessing the Motorola MC146818 chip.
 *
 * Author(s)	: Leigh Dworkin.
 *
 * Notes	: For a detailed description of the IBM CMOS RAM
 *		  and the Motorola MC146818A chip refer to the following 
 *		  documents:
 *
 *		  - IBM PC/AT Technical Reference Manual
 *				(Section 1-59 )
 *		  - Motorola Semiconductors Handbook
 *				(Section MC146818A)
 *
 */

/* SccsID[]="@(#)cmos.h	1.9 04/24/95 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */
/* define the CMOS ports */

#define CMOS_PORT_START 0x70
#define CMOS_PORT_END 0x7f

/* The following definitions are as in the AT BIOS Pg. 5-24 */
#define CMOS_PORT 0x70
#define CMOS_DATA 0x71
#define NMI	0x80

/* define the internal cmos adresses */
/* Real Time Clock */
#define CMOS_SECONDS 0x0
#define CMOS_SEC_ALARM 0x1
#define CMOS_MINUTES	0x2
#define CMOS_MIN_ALARM	0x3
#define CMOS_HOURS	0x4
#define CMOS_HR_ALARM	0x5
#define CMOS_DAY_WEEK	0x6
#define CMOS_DAY_MONTH	0x7
#define CMOS_MONTH	0x8
#define CMOS_YEAR	0x9
#define CMOS_REG_A	0xa
#define CMOS_REG_B	0xb
#define CMOS_REG_C	0xc
#define CMOS_REG_D	0xd


/* General purpose CMOS */
#define CMOS_DIAG	0xe
#define CMOS_SHUT_DOWN	0xf
#define CMOS_DISKETTE	0x10

#define CMOS_DISK	0x12

#define CMOS_EQUIP	0x14
#define CMOS_B_M_S_LO	0x15
#define CMOS_B_M_S_HI	0x16
#define CMOS_E_M_S_LO	0x17
#define CMOS_E_M_S_HI	0x18
#define CMOS_DISK_1	0x19
#define CMOS_DISK_2	0x1a

#define CMOS_CKSUM_HI	0x2e
#define CMOS_CKSUM_LO	0x2f
#define CMOS_U_M_S_LO	0x30
#define CMOS_U_M_S_HI	0x31
#define CMOS_CENTURY	0x32
#define CMOS_INFO128	0x33

/* define bits in individual bytes */
/* register D */
#define VRT	0x80
#define REG_D_INIT	(VRT)

/* register C */
#define C_IRQF	0x80
#define C_PF	0x40
#define C_AF	0x20
#define C_UF	0x10
#define C_CLEAR 0x00
#define REG_C_INIT	(C_CLEAR)

/* register B */
#define SET	0x80
#define PIE	0x40
#define AIE	0x20
#define UIE	0x10
#define SQWE	0x08
#define DM	0x04
#define _24_HR	0x02
#define DSE	0x01
#define REG_B_INIT	(_24_HR)

/* register A */
#define UIP	0x80
#define DV2	0x40
#define DV1	0x20
#define DV0	0x10
#define RS3	0x08
#define RS2	0x04
#define RS1	0x02
#define RS0	0x01
#define REG_A_INIT	(DV1|RS2|RS1)

/* Diagnostic Status Byte 0x0e */
/* As named in the BIOS */
#define CMOS_CLK_FAIL	0x04
#define HF_FAIL		0x08
#define W_MEM_SIZE	0x10
#define BAD_CONFIG	0x20
#define BAD_CKSUM	0x40
#define BAD_BAT		0x80

/* Shutdown Status Byte 0x0f */
#define SOFT_OR_UNEXP	0x0
#define AFTER_MEMSIZE	0x1
#define AFTER_MEMTEST	0x2
#define AFTER_MEMERR	0x3
#define BOOT_REQ	0x4
#define JMP_DWORD_ICA	0x5
#define TEST3_PASS	0x6
#define TEST3_FAIL	0x7
#define TEST1_FAIL	0x8
#define BLOCK_MOVE	0x9
#define JMP_DWORD_NOICA 0xa

/* Diskette Drive Type Byte 0x10 */
#define FIRST_FLOPPY_NULL	0x0
#define FIRST_FLOPPY_360	0x10
#define FIRST_FLOPPY_12		0x20
#define FIRST_FLOPPY_720	0x30
#define FIRST_FLOPPY_144	0x40
#define SECOND_FLOPPY_NULL	0x0
#define SECOND_FLOPPY_360	0x01
#define SECOND_FLOPPY_12	0x02
#define SECOND_FLOPPY_720	0x03
#define SECOND_FLOPPY_144	0x04

/* Fixed Disk Type Byte 0x12 */
#define NO_HARD_C	0x0
#define EXTENDED_C	0xf0
#define NO_HARD_D	0x0
#define EXTENDED_D	0x0f

/* Equipment Byte 0x14 */
#define ONE_DRIVE	0x0
#define TWO_DRIVES	0x40
#define OWN_BIOS	0x0
#define CGA_40_COLUMN	0x10
#define CGA_80_COLUMN	0x20
#define MDA_PRINTER	0x30
#define CO_PROCESSOR_PRESENT	0x02
#define COPROCESSOR_NOT_PRESENT	0x00
#define DISKETTE_PRESENT	0x01
#define DISKETTE_NOT_PRESENT	0x00

/* Masks for the Equipment Byte */
#define DRIVE_INFO	0x41
#define DISPLAY_INFO	0x30
#define NPX_INFO	0x02
#define RESVD_INFO	0x8C

/* Cmos initialisation data */

#define DIAG_INIT	0x0
#define SHUT_INIT	0x0
#define FLOP_INIT	0x20
#define CMOS_RESVD	0x0
#define DISK_INIT	0xf0

#define EQUIP_INIT	0x1
#define BM_LO_INIT	0x80
#define BM_HI_INIT	0x02
#define EXP_LO		0x0
#define EXP_HI		0x0
#define DISK_EXTEND	0x14
#define DISK2_EXTEND	0x0

#define CHK_HI_INIT	0x0
#define CHK_LO_INIT	0x0
#define EXT_LO_INIT	0x0
#define EXT_HI_INIT	0x0
#define CENT_INIT	0x19
#define INFO_128_INIT	0x80

/* Useful bit masks */
#define CMOS_ADDR_MASK 0x3f
#define CMOS_BIT_MASK 0x71
#define NMI_DISABLE 0x80
#define TOP_BIT	0x80
#define REST	0x7f

/* Bit masks used in the BIOS */
/* This is used for CMOS_INFO128 */
#define M640K		0x80

#define BAD_SHUT_DOWN	0x01
#define BAD_REG_D	0x02
#define BAD_DIAG	0x04
#define BAD_EQUIP	0x08
#define BAD_FLOPPY	0x10
#define BAD_DISK	0x20
#define BAD_BMS		0x40
#define BAD_XMS		0x80
#define BAD_CHECKSUM	0x100

#define CMOS_SIZE 64

/* Real Time Clock Periodic Interrupt Rates */
#define MAX_PIR		51
#define PIR_NONE	0
#define PIR_2HZ		1
#define PIR_4HZ		1
#define PIR_8HZ		1
#define PIR_16HZ	1
#define PIR_32HZ	1
#define PIR_64HZ	3
#define PIR_128HZ	6
#define PIR_256HZ	13
#define PIR_512HZ	26
#define PIR_1MHZ	MAX_PIR
#define PIR_2MHZ	MAX_PIR
#define PIR_4MHZ	MAX_PIR
#define PIR_8MHZ	MAX_PIR
#define PIR_16MHZ	MAX_PIR
#define PIR_32MHZ	MAX_PIR

#define DONT_CARE	0xc0

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

/*
 *	void cmos_init()
 *	{
 *		This function performs several distinct initialisation
 *		tasks associated with the CMOS :
 *
 *		cmos_io_attach() - attach the CMOS ports to the IO bus.
 *		cmos_hw_init() - initialise the MC146818A
 *		cmos_post() - perform the IBM POST specific to the CMOS
 *	}
 */
IMPORT VOID cmos_init IPT0();

/*
 *	void cmos_io_attach()
 *	{
 *		This function attaches the CMOS ports to the IO bus.
 *		Presently called from cmos_init(), this should be 
 *		called at some sensible place on machine powerup.
 *	}
 */
IMPORT VOID cmos_io_attach IPT0();

/*
 *	void cmos_hw_init()
 *	{
 *		This function resets the MC146818A to its default state.
 *	}
 */
IMPORT VOID cmos_hw_init IPT0();

/*
 *	void cmos_post()
 *	{
 *		This function is a very poor emulation of what goes on in
 *		the IBM power on system test to do with the CMOS. This is
 *		called via cmos_init() from reset() in reset.c. Ideally,
 *		reset() should be renamed post() and should only call this
 *		third initialisation function, rather than _io_attach and
 *		_hw_init too.
 *		NB. There is no emulation of the strange behaviour of the
 *		notorious SHUT_DOWN byte, which allows a user program to
 *		jump to a known location in the POST, or anywhere in Intel
 *		memory, after having pulsed the keyboard reset line.
 *	}
 */
IMPORT VOID cmos_post IPT0();

/*
 *	void rtc_init()
 *	{
 *		This function sets up the 12/24 hour mode and binary/bcd
 *		mode for the data stored in the CMOS bytes.
 *		It also initialises the time bytes to the current host
 *		time, and sets up the alarm to go off at the time specified
 *		in the alarm bytes.
 *	}
 */
IMPORT VOID rtc_init IPT0();

/*
 *	void cmos_inb(port, value)
 *	io_addr port;
 *	half_word *value;
 *	{
 *		This function is invoked when a read is performed on an
 *		I/O address "port" in the range of the CMOS.
 *
 *		The function maps the I/O address to the CMOS
 *		and returns the value of the requested
 *		register in "*value".
 *	}
 */
IMPORT VOID cmos_inb IPT2(io_addr, port, half_word *, value);

/*
 *	void cmos_outb(port, value)
 *	io_addr port;
 *	half_word value;
 *	{
 *		This function is invoked when a write is performed to an
 *		I/O address "port" in the range of the CMOS, or 
 *		may also be called directly from the BIOS.
 *
 *		The function maps the I/O address to the CMOS
 *		and sets the requested register to "value".
 *	}
 */
IMPORT VOID cmos_outb IPT2(io_addr, port, half_word, value);

#if defined(NTVDM) || defined(macintosh)
/*
 *	void cmos_pickup()
 *	{
 *		This is an extremely badly named function that picks up
 *		the data stored in the cmos.ram resource to emulate not
 *		losing data between invocations of SoftPC/AT. This is
 *		called from main() at application startup.
 *	}
 */
IMPORT VOID cmos_pickup IPT0();
#endif	/* defined(NTVDM) || defined(macintosh) */

/*	void cmos_update()
 *	{
 *		This function is called from terminate() on application
 *		exit. It stores the data held in the cmos to the cmos.ram
 *		resource.
 *	}
 */
IMPORT VOID cmos_update IPT0();

/*	void rtc_tick()
 *	{
 *		This function gets called from the base routine time_strobe()
 *		which gets called by the host 20 times a second. It toggles
 *		the periodic flag at 20Hz, the update flag at 1Hz in the
 *		CMOS register C and the update bit in CMOS register A. If
 *		periodic interrupts are enabled, a burst of interrupts are
 *		sent every 20th second. The chip is capable of up to 32 MHz,
 *		and we hope noone uses this feature!.
 *		NB. This is still to be tuned. The default DOS rate is 1MHz
 *		but we try to send 20 interrupts at 20Hz, and this blows the
 *		interrupt stack. Assuming programs use the BIOS interface
 *		(INT 15) it is possible to decrement a larger count less 
 *		often, to fool the PC program.
 *
 *		This is where the CMOS code checks for interrupts from
 *		the three available sources: periodic as described above,
 *		update triggered and alarm triggered.
 *	}
 */
IMPORT VOID rtc_tick IPT0();

/*
 *	void cmos_equip_update()
 *	{
 *		This routine updates the cmos bytes when the user changes
 *		graphics adapter from the User Interface. The EQUIP and
 *		CKSUM bytes are affected, and the user is not informed
 *		of the change.
 *	}
 */
IMPORT VOID cmos_equip_update IPT0();

/*
** int cmos_write_byte( cmos_byte:int, new_value:half_word )
** Writes the specified value into the specified cmos address.
** Returns 0 if OK, 1 if cmos address out of range (there are 64 cmos bytes).
**
*/
IMPORT int cmos_write_byte IPT2(int, cmos_byte, half_word, new_value);

/*
** int cmos_read_byte( cmos_byte:int, *value:half_word )
** Reads the specified value from the specified cmos address and returns it
** at the address specified by the value parameter.
** Returns 0 if OK, 1 if cmos address out of range (there are 64 cmos bytes).
**
*/
IMPORT INT cmos_read_byte IPT2(int, cmos_byte, half_word *, value);

/*
 * Functions to read and write to the cmos resource file.
 */
IMPORT INT 
host_read_resource IPT5(        
	INT, type,      /* Unused */
	CHAR *, name,    /* Name of resource */
	UTINY *, addr,    /* Address to read data into */
	INT, maxsize,   /* Max amount of data to read */
	INT, display_error);/* Controls message output */

IMPORT void host_write_resource IPT4(
	INT,type,               /* Unused */
	CHAR *,name,             /* Name of resource */
	UTINY *,addr,             /* Address of data to write */
	LONG,size);              /* Quantity of data to write */

/*
 *	This variable works like timer_int_enabled and can be used to
 *	disable real time clock interrupts totally during debugging
 */
extern int rtc_int_enabled;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\config.h ===
#ifndef _CONFIG_H
#define _CONFIG_H
/*[
**************************************************************************

	Name:		config.h
	Author:		J.D. Richemont
	Created On:	
	Sccs ID:	@(#)config.h	1.44 04/24/95
	Purpose:	General (base+host) configuration defines + typedefs.

	See SoftPC Version 3.0 Configuration Interface - Design Document

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
	Changing this file by adding a new config type requires some hosts
	to recompile their message catalogs or nls stuff. Don't forget to
	put this in the host impact field on the BCN. Also, please only add
	new config types to the END of the current list, otherwise it is
	a real pain to edit the host catalogs!
WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING

**************************************************************************
]*/

/* Make sure error.h gets included - it is necessary for the typedefs referred
** to from the ANSI declarations.
*/
#ifndef _INS_ERROR_H
#include "error.h"
#endif	/* _INS_ERROR_H */

/* General messages returned from config funcs */

#define C_CONFIG_OP_OK      0	/* General 'all went well' message */
#define C_CONFIG_NOT_VALID -1	/* the config item is not valid */

#define COMMENT_MARK	'#'
#define PAD_CHAR	' '
#define MIN_PAD_LEN	8

/*
 * Below are the definitions of the masks used by with the flags field
 * of the config structure.  Note there are currently four unused bits
 * 0x04 0x08 0x10 and 0x20
 *
 * The first group is used as the config entry type.
 * 
 * C_SYSTEM_ONLY - indicates resource comes from the system config file only
 * C_DO_RESET    - Changing this element by default will cause a SoftPC reboot
 * C_EXPERT_OPTION - If missing from .spcconfig, take default without
 *		asking user.
 */
#define C_TYPE_MASK		((UTINY) 0x03)
#define	C_NAME_RECORD		((UTINY) 0x00)
#define	C_STRING_RECORD		((UTINY) 0x01)
#define	C_NUMBER_RECORD		((UTINY) 0x02)
#define	C_RECORD_DELETE		((UTINY) 0x03)

#define C_EXPERT_OPTION		((UTINY) 0x10)
#define C_INIT_ACTIVE		((UTINY) 0x20)
#define C_SYSTEM_ONLY		((UTINY) 0x40)
#define C_DO_RESET		((UTINY) 0x80)

/* 
 * Note: config processes the Configuration file in hostID order so the
 * ordering of hostIDs is significant.
 *
 * These items are usually system only fields and must be validated
 * before the later config items that refer to them
 *
 * EG if C_EXTEND_MAX_SIZE is not validated before then the check in
 * C_EXTENDED_MEM_SIZE is against whatever max was malloced.
 *
 * =====================================================================
 * 	To avoid backwards compatibility problems,
 *	never change any of the numbers.
 * =====================================================================
 */

#define C_FILE_DEFAULT		0
#ifdef macintosh
#define C_PRINTER_DEFAULT	1
#define C_PLOTTER_DEFAULT	2
#define C_DATACOMM_DEFAULT	4
#else	/* macintosh */
#define C_DEVICE_DEFAULT	1
#endif	/* macintosh */
#define C_PIPE_DEFAULT		3
#define C_DRIVE_MAX_SIZE	5

#define C_EXTEND_MAX_SIZE	6
#define C_EXPAND_MAX_SIZE	7

/* Extended Mem Size validation depends on Extended MAX size */
#define C_EXTENDED_MEM_SIZE	8
#define	C_MEM_SIZE		C_EXTENDED_MEM_SIZE

/* LIM size validation depends on Expanded MAX size */
#define C_LIM_SIZE		9
#define C_MEM_LIMIT		10



/* Spares for hosts to provide their own system only fields which need
** early validation.
*/
#define C_HOST_SYSTEM_0		11
#define	C_HOST_SYSTEM_1		12
#define	C_HOST_SYSTEM_2		13
#define	C_HOST_SYSTEM_3		14
#define	C_HOST_SYSTEM_4		15

#define	C_SECURE		16
#define C_SECURE_MASK           17

#define	C_CDROM_DEVICE		18

#define C_SWITCHNPX		24

#define C_HARD_DISK1_NAME	25
#define C_HARD_DISK2_NAME	26
#define C_FSA_DIRECTORY		27

/*
 * Extra config options used by multiple-HFX
 */
#define C_FSA_DIR_D		28
#define C_FSA_DIR_E		29
#define C_FSA_DIR_F		30
#define C_FSA_DIR_G		31
#define C_FSA_DIR_H		32
#define C_FSA_DIR_I		33
#define C_FSA_DIR_J		34
#define C_FSA_DIR_K		35
#define C_FSA_DIR_L		36
#define C_FSA_DIR_M		37
#define C_FSA_DIR_N		38
#define C_FSA_DIR_O		39
#define C_FSA_DIR_P		40
#define C_FSA_DIR_Q		41
#define C_FSA_DIR_R		42
#define C_FSA_DIR_S		43
#define C_FSA_DIR_T		44
#define C_FSA_DIR_U		45
#define C_FSA_DIR_V		46
#define C_FSA_DIR_W		47
#define C_FSA_DIR_X		48
#define C_FSA_DIR_Y		49
#define C_FSA_DIR_Z		50

#define C_FLOPPY_A_DEVICE	51
#define C_FLOPPY_B_DEVICE	52
#define C_SLAVEPC_DEVICE	53

#define C_GFX_ADAPTER		54
#define C_WIN_SIZE		55

#define C_MSWIN_WIDTH		56
#define C_MSWIN_HEIGHT		57
#define C_MSWIN_COLOURS		58

#define C_SOUND			59

/*
 * All of the lpt hostID's must be kept sequential because
 * the lpt code tends to do (hostID - C_LPT1_NAME)
 * calculations to index into an array of structures.
 */
#define C_LPT1_TYPE		60
#define C_LPT2_TYPE		( C_LPT1_TYPE+1 )	/*61*/
#define C_LPT3_TYPE		( C_LPT1_TYPE+2 )	/*62*/
#define C_LPT4_TYPE		( C_LPT1_TYPE+3 )	/*63*/

#define C_LPT1_NAME		64
#define C_LPT2_NAME		( C_LPT1_NAME+1 )	/*65*/
#define C_LPT3_NAME		( C_LPT1_NAME+2 )	/*66*/
#define C_LPT4_NAME		( C_LPT1_NAME+3 )	/*67*/

#define	C_LPTFLUSH1		68
#define	C_LPTFLUSH2		( C_LPTFLUSH1+1 )	/*69*/
#define	C_LPTFLUSH3		( C_LPTFLUSH1+2 )	/*70*/
#define	C_LPTFLUSH4		( C_LPTFLUSH1+3 )	/*71*/

#define C_FLUSHTIME1		72
#define C_FLUSHTIME2		( C_FLUSHTIME1+1 )	/*73*/
#define C_FLUSHTIME3		( C_FLUSHTIME1+2 )	/*74*/
#define C_FLUSHTIME4		( C_FLUSHTIME1+3 )	/*75*/

#define C_LPT1_OTHER_NAME	76
#define C_LPT2_OTHER_NAME	( C_LPT1_OTHER_NAME+1)	/*77*/
#define C_LPT3_OTHER_NAME	( C_LPT1_OTHER_NAME+2)	/*78*/
#define C_LPT4_OTHER_NAME	( C_LPT1_OTHER_NAME+3)	/*79*/

/* com hostIDs need to be grouped, same reason as lpt hostIDs
 */
#define C_COM1_TYPE		80
#define C_COM2_TYPE		( C_COM1_TYPE+1 )	/*81*/
#define C_COM3_TYPE		( C_COM1_TYPE+2 )	/*82*/
#define C_COM4_TYPE		( C_COM1_TYPE+3 )	/*83*/

#define C_COM1_NAME		84
#define C_COM2_NAME		( C_COM1_NAME+1 )	/*85*/
#define C_COM3_NAME		( C_COM1_NAME+2 )	/*86*/
#define C_COM4_NAME		( C_COM1_NAME+3 )	/*87*/

#define C_COM1_XON		88
#define C_COM2_XON		( C_COM1_XON+1)		/*89*/
#define C_COM3_XON		( C_COM1_XON+2)		/*90*/
#define C_COM4_XON		( C_COM1_XON+3)		/*91*/

#define	C_AUTOFREEZE		92
#define C_AUTOFLUSH		93
#define C_AUTOFLUSH_DELAY	94
#define	C_KEYBD_MAP		95

#define C_DOS_CMD		96

#define C_SOUND_DEVICE		97
#define C_SOUND_LEVEL		98

#define C_RODISK_PANEL		99


#define C_HU_FILENAME		100
#define C_HU_MODE		101
#define C_HU_BIOS	        102
#define C_HU_REPORT		103
#define C_HU_SDTYPE		104
#define C_HU_CHKMODE		105
#define C_HU_CHATTR		106
#define C_HU_SETTLNO		107
#define C_HU_FUDGENO		108
#define C_HU_DELAY		109
#define C_HU_GFXERR		110
#define C_HU_TS			111
#define C_HU_NUM		112

/* Strings for Boolean value - we allow for 6 possibilities */

#define C_BOOL_VALUES		113 /* to 118 */

/* COMMS adapter destination types */

#define ADAPTER_TYPE_FILE	119
#define ADAPTER_TYPE_PRINTER	120
#define ADAPTER_TYPE_PLOTTER	121
#define ADAPTER_TYPE_PIPE	122
#define ADAPTER_TYPE_DATACOMM	123
#define ADAPTER_TYPE_NULL	124
#define ADAPTER_TYPE_DEVICE	125

#define C_MSWIN_RESIZE		126

/* Enable Windows PostScript printer flushing */

#define C_LPT1_PSFLUSH		127
#define C_LPT2_PSFLUSH		(C_LPT1_PSFLUSH + 1)
#define C_LPT3_PSFLUSH		(C_LPT2_PSFLUSH + 1)
#define C_LPT4_PSFLUSH		(C_LPT3_PSFLUSH + 1)

#define C_COM1_PSFLUSH		131
#define C_COM2_PSFLUSH		(C_COM1_PSFLUSH + 1)
#define C_COM3_PSFLUSH		(C_COM2_PSFLUSH + 1)
#define C_COM4_PSFLUSH		(C_COM3_PSFLUSH + 1)


#if !defined(NTVDM) && !defined(macintosh)
#define C_CMOS			135
#endif

#if defined(NTVDM)
#define C_VDMLPT1_NAME		140
#define C_VDMLPT2_NAME		(C_VDMLPT1_NAME + 1)
#define C_VDMLPT3_NAME		(C_VDMLPT1_NAME + 2)
#define C_COM_SYNCWRITE 	C_VDMLPT3_NAME + 1
#define C_COM_TXBUFFER_SIZE	C_COM_SYNCWRITE + 1
#endif


/* Host-specific entries in the message catalogue start at
 * the following number plus 1 - note that the value must
 * fit into an IU8, so 255 is an upper limit
 */
#define LAST_BASE_CONFIG_DEFINE	240



/* Names of runtime vars that host_runtime_set/_inquire() will use.
 * These do not appear in the message catalogue anywhere.
 */
typedef enum
{
         C_NPX_ENABLED=0,	C_HD1_CYLS,	C_HD2_CYLS,
	 C_AUTOFLUSH_ON,	C_LPTFLUSH1_ON,	C_LPTFLUSH2_ON,
	 C_LPTFLUSH3_ON,	C_COM1_FLOW,	C_COM2_FLOW,
	 C_COM3_FLOW,		C_COM4_FLOW,	C_SOUND_ON,
	 C_MOUSE_ATTACHED,	C_FLOPPY_SERVER,
	 C_COM1_ATTACHED,	C_COM2_ATTACHED,
	 C_DRIVEC_ATTACHED,	C_DRIVED_ATTACHED,
	 C_LAST_RUNTIME
} RuntimeEnum;

/*********** Definitions for states of things **************/

/* Graphics adapter types */

#define NO_ADAPTOR      0xff
#define MDA             0
#define CGA             1
#define CGA_MONO        2
#define EGA             3
#define HERCULES        4
#define VGA             5


/* Floppy drive states
 * This is only used by the system that mainatins the interloack between
 * slave PC and a real device emulation
 */
#define GFI_REAL_DISKETTE_SERVER     0
#define GFI_SLAVE_SERVER             1    /* Please always be last */


/*************** Structure definitions ******************/

typedef struct 
{
	CHAR string[MAXPATHLEN];
	SHORT index;
	BOOL rebootReqd;
} ConfigValues;

typedef struct
{
	CHAR *string;
	SHORT value;
} ntable;

#define NameTable ntable

typedef struct
{
	CHAR *optionName;
	NameTable *table;
	SHORT (*valid)  IPT4( UTINY, hostID, ConfigValues, *vals,
			     NameTable, table[], CHAR, errString[] );
	VOID (*change)  IPT2( UTINY, hostID, BOOL, apply);
	SHORT (*active) IPT3( UTINY, hostID, BOOL, active, CHAR, errString[]);
	UTINY hostID;
	UTINY flags;
} OptionDescription;

typedef struct _resource_node
{
	CHAR *line;			/* resource string */
	CHAR *arg;			/* a pointer to the argument */
	struct _resource_node *next;	/* pointer to next node in list */
	SHORT allocLen;			/* length of string allocated */
} LineNode;

/* Base Config functions declarations */

extern void config IPT0();
extern void *config_inquire IPT2(UTINY, hostID, ConfigValues *, values);

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
extern void config_get IPT2(UTINY, hostID, ConfigValues **, values);
extern void config_unget IPT1(UTINY, hostID);
extern void config_unget_all IPT0();
extern SHORT config_put IPT2(UTINY, hostID, ErrDataPtr, errDataP);
extern void config_put_all IPT0();
extern void IPT0config_get_all();
extern BOOL config_reboot_check IPT0();
extern SHORT config_check IPT2(UTINY, hostID, ErrDataPtr, errDataP);
extern void config_store IPT0();
#endif

extern void config_activate IPT2(UTINY, hostID, BOOL, reqState);
extern void config_set_active IPT2(UTINY, hostID, BOOL, state);
extern BOOL config_get_active IPT1(UTINY, hostID);
extern LineNode *add_resource_node IPT1(CHAR *, str);
extern CHAR *translate_to_string IPT2(SHORT, value, NameTable, table[]);
extern SHORT translate_to_value IPT2(CHAR *, string, NameTable, table[]);
extern UTINY find_hostID IPT1(CHAR *, name);
extern CHAR *find_optionname IPT1(UTINY, hostID);
extern void host_config_init IPT1(OptionDescription *, common_defs);

#if !defined(NTVDM) || (defined(NTVDM) && !defined(MONITOR))
extern SHORT host_read_resource_file IPT2(BOOL, system, ErrDataPtr, err_buf);
extern SHORT host_write_resource_file IPT2(LineNode *, head,
                                           ErrDataPtr, err_buf);
#endif

extern void *host_inquire_extn IPT2(UTINY, hostID, ConfigValues *, values);
extern SHORT host_runtime_inquire IPT1(UTINY, what);
extern void host_runtime_set IPT2(UTINY, what, SHORT, value);
extern void host_runtime_init IPT0();
extern SHORT validate_item IPT4(UTINY, hostID, ConfigValues *, value,
                                NameTable *, table, CHAR, err[]);
extern CHAR *convert_to_external IPT1(UTINY, hostID);

#ifndef host_expand_environment_vars
extern CHAR *host_expand_environment_vars IPT1(const char *, string);
#endif /* nhost_expand_environment_vars */

extern CHAR ptr_to_empty[];

#ifdef SWITCHNPX
extern IS32 Npx_enabled;
#endif /* SWITCHNPX */

/* Dumb Terminal UIF Flag */
extern IBOOL Config_has_been_edited;

#include "host_cfg.h"

#endif /* _CONFIG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\crtc.h ===
#if defined(NEC_98)
/* CRTC include file */

/* CRTC port address */

#define CRTC_SET_PL  0x70
#define CRTC_SET_BL  0x72
#define CRTC_SET_CL  0x74
#define CRTC_SET_SSL 0x76
#define CRTC_SET_SUR 0x78
#define CRTC_SET_SDR 0x7A

/* CRTC structures */

typedef struct
{
        unsigned char   regpl;
        unsigned char   regbl;
        unsigned char   regcl;
        unsigned char   regssl;
        unsigned char   regsur;
        unsigned char   regsdr;
} CRTC_GLOBS;

extern CRTC_GLOBS crtcglobs;

IMPORT void text_gdc_init IPT0();
IMPORT void text_gdc_outb IPT2(io_addr, port, half_word, value);
IMPORT void text_gdc_post IPT0();
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\cpu2.h ===
/*
 * SoftPC Revision 2.0
 *
 * Title	: Definitions for the CPU 
 *
 * Description	: Structures, macros and definitions for access to the 
 *		  CPU registers
 *
 * Author	: Henry Nash
 *
 * Notes	: This file should be portable - but includes a file
 *		  host_cpu.h which contains machine specific definitions
 *		  of CPU register mappings etc.
 */

/* SccsID[]="@(#)cpu2.h	1.3 12/22/93 Copyright Insignia Solutions Ltd."; */

#include "host_cpu.h"

IMPORT VOID host_set_hw_int IPT0();
IMPORT VOID host_clear_hw_int IPT0();

/*
 * CPU Data Area
 * These externs are given before host_cpu.h is included so that the
 * variables may be gathreed into a structure and the externs overridden
* by #defines in host_cpu.h
 */

extern	word protected_mode;   /* =0 no proteced mode warning given
       		                   =1 proteced mode warning given */
extern  word            cpu_interrupt_map;
extern  half_word       cpu_int_translate[];
extern  word            cpu_int_delay;
extern  half_word       ica_lock;
extern  void            (*(jump_ptrs[]))();
extern  void            (*(b_write_ptrs[]))();
extern  void            (*(w_write_ptrs[]))();
extern  void            (*(b_fill_ptrs[]))();
extern  void            (*(w_fill_ptrs[]))();
#ifdef EGATEST
extern  void            (*(b_fwd_move_ptrs[]))();
extern  void            (*(w_fwd_move_ptrs[]))();
extern  void            (*(b_bwd_move_ptrs[]))();
extern  void            (*(w_bwd_move_ptrs[]))();
#else
extern  void            (*(b_move_ptrs[]))();
extern  void            (*(w_move_ptrs[]))();
#endif /* EGATEST */
extern  half_word       *haddr_of_src_string;
 
/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * The cpu opcode sliding frame
 */
 
#ifdef BACK_M
typedef struct
{
                half_word FOURTH_BYTE;
                half_word THIRD_BYTE;
                half_word SECOND_BYTE;
                half_word OPCODE;
}  OPCODE_FRAME;

typedef struct
{
                signed_char FOURTH_BYTE;
                signed_char THIRD_BYTE;
                signed_char SECOND_BYTE;
                signed_char OPCODE;
}  SIGNED_OPCODE_FRAME;
#else
typedef struct
{
                half_word OPCODE;
                half_word SECOND_BYTE;
                half_word THIRD_BYTE;
                half_word FOURTH_BYTE;
}  OPCODE_FRAME;

typedef struct
{
                signed_char OPCODE;
                signed_char SECOND_BYTE;
                signed_char THIRD_BYTE;
                signed_char FOURTH_BYTE;
}  SIGNED_OPCODE_FRAME;
#endif /* BACK_M */
 
/*
 * The new ICA uses the following for H/W ints:
 */
 
#define CPU_HW_INT		0
#define CPU_HW_INT_MASK		(1 << CPU_HW_INT)

/*
 * CPU software interrupt definitions
 */
 
#define CPU_SW_INT              8
#define CPU_SW_INT_MASK         (1 << CPU_SW_INT)

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

extern OPCODE_FRAME *opcode_frame;	/* C CPU and dasm only		    */

/*
 * External declarations for the 80286 registers
 */
 
extern reg A;           /* Accumulator          */
extern reg B;           /* Base                 */
extern reg C;           /* Count                */
extern reg D;           /* Data                 */
extern reg SP;          /* Stack Pointer        */
extern reg BP;          /* Base pointer         */
extern reg SI;          /* Source Index         */
extern reg DI;          /* Destination Index    */
extern reg IP;          /* Instruction Pointer  */
extern reg CS;          /* Code Segment         */
extern reg DS;          /* Data Segment         */
extern reg SS;          /* Stack Segment        */
extern reg ES;          /* Extra Segment        */
 
/*
 * External function declarations. These may be defined to other things.
 */

#ifndef	host_simulate
extern void host_simulate	IPT0();
#endif	/* host_simulate */

#ifndef	host_cpu_reset
extern void host_cpu_reset	IPT0();
#endif	/* host_cpu_reset */

#ifndef	host_cpu_init
extern void host_cpu_init	IPT0();
#endif	/* host_cpu_init */

#ifndef	host_cpu_interrupt
extern void host_cpu_interrupt	IPT0();
#endif	/* host_cpu_interrupt */

/*
 * Definition of Descriptor Table
 */

#ifdef BIGEND

union sixteenbits
{
	word X;

	struct
	{
		half_word lower;
		half_word upper;
	} word;
};

#endif	/* BIGEND */

#ifdef LITTLEND

union sixteenbits
{
	word X;

	struct
	{
		half_word upper;
		half_word lower;
	} word;
};

#endif	/* LITTLEND */

struct DESC_TABLE
{
	union sixteenbits misc;
	union sixteenbits base;
	union sixteenbits limit;
};

#define CPU_SIGALRM_EXCEPTION           15              /* SIGALRM signal
*/           
#define CPU_SIGALRM_EXCEPTION_MASK      (1 << CPU_SIGALRM_EXCEPTION)
 
#define CPU_TRAP_EXCEPTION              11              /* TRAP FLAG
*/
#define CPU_TRAP_EXCEPTION_MASK         (1 << CPU_TRAP_EXCEPTION)

#define CPU_YODA_EXCEPTION              13              /* YODA FLAG
*/
#define CPU_YODA_EXCEPTION_MASK         (1 << CPU_YODA_EXCEPTION)

#define CPU_SIGIO_EXCEPTION             14              /* SIGIO FLAG
*/
#define CPU_SIGIO_EXCEPTION_MASK        (1 << CPU_SIGIO_EXCEPTION)

#define CPU_RESET_EXCEPTION             12              /* RESET FLAG
*/
#define CPU_RESET_EXCEPTION_MASK        (1 << CPU_RESET_EXCEPTION)

#ifdef CCPU

IMPORT void sw_host_simulate IPT0();
IMPORT int selector_outside_table IPT2(word, selector, sys_addr *, descr_addr);
IMPORT void cpu_init IPT0();

/*
   Define descriptor 'super' types.
 */
#define INVALID				0x00
#define AVAILABLE_TSS			0x01
#define LDT_SEGMENT			0x02
#define BUSY_TSS			0x03
#define CALL_GATE			0x04
#define TASK_GATE			0x05
#define INTERRUPT_GATE			0x06
#define TRAP_GATE			0x07
#define EXPANDUP_READONLY_DATA		0x11
#define EXPANDUP_WRITEABLE_DATA		0x13
#define EXPANDDOWN_READONLY_DATA	0x15
#define EXPANDDOWN_WRITEABLE_DATA	0x17
#define NONCONFORM_NOREAD_CODE		0x19
#define NONCONFORM_READABLE_CODE	0x1b
#define CONFORM_NOREAD_CODE		0x1d
#define CONFORM_READABLE_CODE		0x1f

/* Code Segment (Private) */
extern half_word CS_AR;
extern sys_addr  CS_base;
extern word      CS_limit;

/* Data Segment (Private) */
extern half_word DS_AR;
extern sys_addr  DS_base;
extern word      DS_limit;

/* Stack Segment (Private) */
extern half_word SS_AR;
extern sys_addr  SS_base;
extern word      SS_limit;

/* Extra Segment (Private) */
extern half_word ES_AR;
extern sys_addr  ES_base;
extern word      ES_limit;
 
/* Local Descriptor Table Register (Private) */
extern sys_addr LDTR_base;  /* Base Address */
extern word     LDTR_limit; /* Segment 'size' */

/* Task Register (Private) */
extern sys_addr TR_base;  /* Base Address */
extern word     TR_limit; /* Segment 'size' */

/* Interrupt status, defines any abnormal processing */
extern int doing_contributory;
extern int doing_double_fault;

/* HOST - decoded access rights */
extern int ALC_CS;
extern int ALC_DS;
extern int ALC_ES;
extern int ALC_SS;

#define X_REAL 0
#define C_UPRO 1
#define C_DNRO 6
#define C_PROT 2
#define C_UPRW 7
#define C_DNRW 8
#define S_UP   3
#define S_DOWN 4
#define S_BAD  5
#define D_CODE 1
#define D_UPRO 1
#define D_DNRO 6
#define D_UPRW 7
#define D_DNRW 8
#define D_BAD  2

/*
 *
 *******************************************************************
 * The 'C' cpu register access functions.             		   *
 *******************************************************************
 *
 */

#define getCS_SELECTOR()	CS.X
#define getDS_SELECTOR()	DS.X
#define getSS_SELECTOR()	SS.X
#define getES_SELECTOR()	ES.X

#define getCS_AR()		CS_AR
#define getDS_AR()		DS_AR
#define getSS_AR()		SS_AR
#define getES_AR()		ES_AR

#define getCS_BASE()		CS_base
#define getDS_BASE()		DS_base
#define getSS_BASE()		SS_base
#define getES_BASE()		ES_base

#define getCS_LIMIT()		CS_limit
#define getDS_LIMIT()		DS_limit
#define getSS_LIMIT()		SS_limit
#define getES_LIMIT()		ES_limit

#define getLDT_BASE()		LDTR_base
#define getLDT_LIMIT()		LDTR_limit

#define getTR_BASE()	        TR_base
#define getTR_LIMIT()	        TR_limit

#define setCS_SELECTOR(val)	CS.X     = val
#define setDS_SELECTOR(val)	DS.X     = val
#define setSS_SELECTOR(val)	SS.X     = val
#define setES_SELECTOR(val)	ES.X     = val

#define setCS_AR(val)		CS_AR    = val
#define setDS_AR(val)		DS_AR    = val
#define setSS_AR(val)		SS_AR    = val
#define setES_AR(val)		ES_AR    = val

#define setCS_BASE(val)		CS_base  = val
#define setDS_BASE(val)		DS_base  = val
#define setSS_BASE(val)		SS_base  = val
#define setES_BASE(val)		ES_base  = val

#define setCS_LIMIT(val)	CS_limit = val
#define setDS_LIMIT(val)	DS_limit = val
#define setSS_LIMIT(val)	SS_limit = val
#define setES_LIMIT(val)	ES_limit = val

#define setLDT_BASE(val)	LDTR_base  = val
#define setLDT_LIMIT(val)	LDTR_limit = val

#define setTR_BASE(val)		TR_base  = val
#define setTR_LIMIT(val)	TR_limit = val
/*
 * The Machine Status Word structure
 */
typedef struct
{ 
     unsigned int :16;
     unsigned int reserved:12;
     unsigned int TS:1;
     unsigned int EM:1;
     unsigned int MP:1;
     unsigned int PE:1;
} mreg;
 
extern sys_addr address_line_mask;

extern int       CPL;   /* Current Privilege Level */
 
/* Global Descriptor Table Register */
extern sys_addr GDTR_base;  /* Base Address */
extern word     GDTR_limit; /* Segment 'size' */

/* Interrupt Descriptor Table Register */
extern sys_addr IDTR_base;  /* Base Address */
extern word     IDTR_limit; /* Segment 'size' */

/* Local Descriptor Table Register */
extern reg  LDTR;       /* Selector */

/* Task Register */
extern reg  TR;       /* Selector */

extern mreg MSW;     /* Machine Status Word */

extern int STATUS_CF;
extern int STATUS_SF;
extern int STATUS_ZF;
extern int STATUS_AF;
extern int STATUS_OF;
extern int STATUS_PF;
extern int STATUS_TF;
extern int STATUS_IF;
extern int STATUS_DF;
extern int STATUS_NT;
extern int STATUS_IOPL;

/*
**==========================================================================
** The CCPU basic register access macros. These may be overridden in
** host-cpu.h.
**==========================================================================
*/

#ifndef	getAX

/* READ functions  */
#define  getAX()	(A.X)
#define	 getAH()	(A.byte.high)
#define	 getAL()	(A.byte.low)
#define	 getBX()	(B.X)
#define	 getBH()	(B.byte.high)
#define	 getBL()	(B.byte.low)
#define	 getCX()	(C.X)
#define	 getCH()	(C.byte.high)
#define	 getCL()	(C.byte.low)
#define	 getDX()	(D.X)
#define	 getDH()	(D.byte.high)
#define	 getDL()	(D.byte.low)
#define	 getSP()	(SP.X)
#define	 getBP()	(BP.X)
#define	 getSI()	(SI.X)
#define	 getDI()	(DI.X)
#define	 getIP()	(IP.X)
#define	 getCS()	(CS.X)
#define	 getDS()	(DS.X)
#define	 getES()	(ES.X)
#define	 getSS()	(SS.X)
#define	 getMSW()	(m_s_w)
#define	 getDF()	(STATUS_DF)
#define	 getIF()	(STATUS_IF)
#define	 getTF()	(STATUS_TF)
#define	 getPF()	(STATUS_PF)
#define	 getAF()	(STATUS_AF)
#define	 getSF()	(STATUS_SF)
#define	 getZF()	(STATUS_ZF)
#define	 getOF()	(STATUS_OF)
#define	 getCF()    	(STATUS_CF)

#define getCPL()		(CPL)
#define getGDT_BASE()		(GDTR_base)
#define getGDT_LIMIT()		(GDTR_limit)
#define getIDT_BASE()		(IDTR_base)
#define getIDT_LIMIT()		(IDTR_limit)
#define getLDT_SELECTOR()		(LDTR.X)
#define getTR_SELECTOR()			(TR.X)
#define getMSW_reserved()	(MSW.reserved)
#define getTS()		(MSW.TS)
#define getEM()		(MSW.EM)
#define getMP()		(MSW.MP)
#define getPE()		(MSW.PE)
#define getNT()		(STATUS_NT)
#define getIOPL()	(STATUS_IOPL)
#define	 getSTATUS() 	(getCF()        |	\
			getOF()   << 11 |	\
			getZF()   << 6  |	\
			getSF()   << 7  |	\
			getAF()   << 4  |	\
			getPF()   << 2  |	\
			getTF()   << 8  |	\
			getIF()   << 9  |	\
			getDF()   << 10 |	\
			getIOPL() << 12 |	\
			getNT()   << 14)

extern	ext_load_CS();
extern	ext_load_DS();
extern	ext_load_ES();
extern	ext_load_SS();

/* WRITE functions  */
#define  setAX(val)	(A.X = (val))
#define	 setAH(val)	(A.byte.high = (val))
#define	 setAL(val)	(A.byte.low = (val))
#define	 setBX(val)	(B.X = (val))
#define	 setBH(val)	(B.byte.high = (val))
#define	 setBL(val)	(B.byte.low = (val))
#define	 setCX(val)	(C.X = (val))
#define	 setCH(val)	(C.byte.high = (val))
#define	 setCL(val)	(C.byte.low = (val))
#define	 setDX(val)	(D.X = (val))
#define	 setDH(val)	(D.byte.high = (val))
#define	 setDL(val)	(D.byte.low = (val))
#define	 setSP(val)	(SP.X = (val))
#define	 setBP(val)	(BP.X = (val))
#define	 setSI(val)	(SI.X = (val))
#define	 setDI(val)	(DI.X = (val))
#define	 setIP(val)	(IP.X = (val))
#define	 setCS(val)	ext_load_CS (val)
#define	 setDS(val)	ext_load_DS (val)
#define	 setES(val)	ext_load_ES (val)
#define	 setSS(val)	ext_load_SS (val)
#define	 setMSW(val)	(m_s_w = (val))
#define	 setDF(val)	(STATUS_DF = (val))
#define	 setIF(val)	(STATUS_IF = (val))
#define	 setTF(val)	(STATUS_TF = (val))
#define	 setPF(val)	(STATUS_PF = (val))
#define	 setAF(val)	(STATUS_AF = (val))
#define	 setSF(val)	(STATUS_SF = (val))
#define	 setZF(val)	(STATUS_ZF = (val))
#define	 setOF(val)	(STATUS_OF = (val))
#define	 setCF(val)	(STATUS_CF = (val))

#define setCPL(val)		(CPL = (val))
#define setGDT_BASE(val)	(GDTR_base = (val))
#define setGDT_LIMIT(val)	(GDTR_limit = (val))
#define setIDT_BASE(val)	(IDTR_base = (val))
#define setIDT_LIMIT(val)	(IDTR_limit = (val))
#define setLDT_SELECTOR(val)		(LDTR.X = (val))
#define setTR_SELECTOR(val)		(TR.X = (val))
#define setMSW_reserved(val)	(MSW.reserved = (val))
#define setTS(val)		(MSW.TS = (val))
#define setEM(val)		(MSW.EM = (val))
#define setMP(val)		(MSW.MP = (val))
#define setPE(val)		(MSW.PE = (val))
#define setNT(val)		(STATUS_NT = (val))
#define setIOPL(val)	(STATUS_IOPL = (val))

#endif	/* getAX - default CCPU register access macros */

#endif /* CCPU */

/*
 * No non-386 cpu can run in VM mode, so getVM is always zero.
 *
 * We also have definition of the GetInstructionPointer and GetStackPointer
 * interfaces, which on a non-386 can only be the 16 bit versions.
 */

#ifndef SPC386
#define getVM() 0
#define GetInstructionPointer() ((IU32)getIP())
#define GetStackPointer() ((IU32getSP())
#endif

#ifdef	CPU_PRIVATE
/*
 * Map new "private" cpu interface -> old interface
 */

#define	setIDT_BASE_LIMIT(base,limit)	{ setIDT_BASE(base); setIDT_LIMIT(limit); }
#define	setGDT_BASE_LIMIT(base,limit)	{ setGDT_BASE(base); setGDT_LIMIT(limit); }
#define	setLDT_BASE_LIMIT(base,limit)	{ setLDT_BASE(base); setLDT_LIMIT(limit); }
#define	setTR_BASE_LIMIT(base,limit)	{ setTR_BASE(base); setTR_LIMIT(limit); }

#define	setCS_BASE_LIMIT_AR(base,limit,ar)	{ setCS_BASE(base); setCS_LIMIT(limit); setCS_AR(ar); }
#define	setES_BASE_LIMIT_AR(base,limit,ar)	{ setES_BASE(base); setES_LIMIT(limit); setES_AR(ar); }
#define	setSS_BASE_LIMIT_AR(base,limit,ar)	{ setSS_BASE(base); setSS_LIMIT(limit); setSS_AR(ar); }
#define	setDS_BASE_LIMIT_AR(base,limit,ar)	{ setDS_BASE(base); setDS_LIMIT(limit); setDS_AR(ar); }
#define	setFS_BASE_LIMIT_AR(base,limit,ar)	{ setFS_BASE(base); setFS_LIMIT(limit); setFS_AR(ar); }
#define	setGS_BASE_LIMIT_AR(base,limit,ar)	{ setGS_BASE(base); setGS_LIMIT(limit); setGS_AR(ar); }

#endif	/* CPU_PRIVATE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\cpu_vid.h ===
/*[
======================================================================

				 SoftPC Revision 3.0

 Title:
		cpu_vid.h

 Description:

		This module supports the interface between the cpu
		and the video emulation code.

 Author:
		John Shanly

 Date:
		12 April 1991

 SccsID		@(#)cpu_vid.h	1.11 03/09/94

	(c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.

======================================================================
]*/

typedef struct
{
	void	(*b_write) IPT2(ULONG, value, ULONG, offset);
	void	(*w_write) IPT2(ULONG, value, ULONG, offset);

#ifndef	NO_STRING_OPERATIONS

	void	(*b_fill) IPT3(ULONG, value, ULONG, offset, ULONG, count);
	void	(*w_fill) IPT3(ULONG, value, ULONG, offset, ULONG, count);
	void	(*b_fwd_move) IPT4(ULONG, offset, ULONG, eas, ULONG, count,
		ULONG, src_flag);
	void	(*b_bwd_move) IPT4(ULONG, offset, ULONG, eas, ULONG, count,
		ULONG, src_flag);
	void	(*w_fwd_move) IPT4(ULONG, offset, ULONG, eas, ULONG, count,
		ULONG, src_flag);
	void	(*w_bwd_move) IPT4(ULONG, offset, ULONG, eas, ULONG, count,
		ULONG, src_flag);

#endif	/* NO_STRING_OPERATIONS */

} WRT_POINTERS;

typedef struct
{
	void	(*b_write) IPT2(IU8, eaOff, IU32, eaVal);
	void	(*w_write) IPT2(IU16, eaOff, IU32, eaVal);
	void	(*d_write) IPT2(IU32, eaOff, IU32, eaVal);
	void	(*b_fill) IPT3(IU32, eaOff, IU8, eaVal, IU32, count);
	void	(*w_fill) IPT3(IU32, eaOff, IU16, eaVal, IU32, count);
	void	(*d_fill) IPT3(IU32, eaOff, IU32, eaVal, IU32, count);
	void	(*b_fwd_move) IPT4(IU32, eaVal, IHPE, fromOff, IU32, count, IBOOL, src_flag);
	void	(*b_bwd_move) IPT4(IU32, eaVal, IHPE, fromOff, IU32, count, IBOOL, src_flag);
	void	(*w_fwd_move) IPT4(IU32, eaVal, IHPE, fromOff, IU32, count, IBOOL, src_flag);
	void	(*w_bwd_move) IPT4(IU32, eaVal, IHPE, fromOff, IU32, count, IBOOL, src_flag);
	void	(*d_fwd_move) IPT4(IU32, eaVal, IHPE, fromOff, IU32, count, IBOOL, src_flag);
	void	(*d_bwd_move) IPT4(IU32, eaVal, IHPE, fromOff, IU32, count, IBOOL, src_flag);
} EVID_WRT_POINTERS;

typedef struct
{
	WRT_POINTERS	mode_0[32];
	WRT_POINTERS	mode_1[2];
	WRT_POINTERS	mode_2[16];
#ifdef VGG
	WRT_POINTERS	mode_3[16];
#endif
} CHN_TABLE;

typedef struct
{
	CHN_TABLE	nch;
#ifdef VGG
	CHN_TABLE	ch4;
#endif
} MODE_TABLE;

extern MODE_TABLE mode_table;

typedef struct 
{
	IU32 (*b_read) IPT1(ULONG, offset);
	IU32 (*w_read) IPT1(ULONG, offset);

#ifndef	NO_STRING_OPERATIONS
	void (*str_read) IPT3(IU8 *, dest, ULONG, offset, ULONG, count);
#endif	/* NO_STRING_OPERATIONS */

} READ_POINTERS; 

typedef struct 
{
	IU32 (*b_read) IPT1(IU32, eaOff);
	IU32 (*w_read) IPT1(IU32, eaOff);
	IU32 (*d_read) IPT1(IU32, eaOff);
	void (*str_fwd_read) IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
	void (*str_bwd_read) IPT3(IU8 *, dest, IU32, eaOff, IU32, count);
} EVID_READ_POINTERS; 

extern READ_POINTERS read_pointers;

#ifndef Cpu_set_vid_wrt_ptrs
extern void Cpu_set_vid_wrt_ptrs IPT1( WRT_POINTERS *, ptrs );
extern void Cpu_set_vid_rd_ptrs IPT1( READ_POINTERS *, ptrs );
#endif /* Cpu_set_vid_wrt_ptrs */

#ifndef CPU_40_STYLE
#ifdef A3CPU

#ifdef C_VID
extern WRT_POINTERS Glue_writes;
#endif /* C_VID */

#else /* A3CPU */

#ifdef C_VID
extern MEM_HANDLERS Glue_writes;
#endif /* C_VID */

#endif /* A3CPU */
#endif /* CPU_40_STYLE */

extern WRT_POINTERS simple_writes;
extern WRT_POINTERS dth_md0_writes, dth_md1_writes, dth_md2_writes, dth_md3_writes;
extern WRT_POINTERS ch2_md0, ch2_md1, ch2_md2, ch2_md3, ch2_mdcopy;

extern READ_POINTERS Glue_reads;

extern READ_POINTERS simple_reads, pointers_RAM_off;
extern READ_POINTERS pointers_mode0_nch, pointers_mode0_ch4, pointers_mode0_ch2;
extern READ_POINTERS pointers_mode1_nch, pointers_mode1_ch4, pointers_mode1_ch2;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\dasm.h ===
/* 
   dasm.h

   Define interface to dis-assembly function.
 */

/*
   static char SccsID[]="@(#)dasm.h	1.4 08/19/94 Copyright Insignia Solutions Ltd.";
 */

extern IU16 dasm IPT4(char *, txt, IU16, seg, LIN_ADDR, off, SIZE_SPECIFIER, default_size);

/* Also available is the internal interface which allows a private
 * copy of Intel bytes to be dasm'ed even if they are not within M[]
 * Hence the caller supplies the "sas_hw_at" fucntion an any suitable
 * LIN_ADDR. The seg:off is used solely for printing.
 * This is the routine called by dasm() with p = effective_addr(seg, off)
 * and byte_at = sas_hw_at. This procedure can return -1 if it is unable
 * to return a byte.
 */
#ifdef DASM_INTERNAL
#include <decode.h>
extern IU16 dasm_internal IPT8(
   char *, txt,	/* Buffer to hold dis-assembly text (-1 means not required) */
   IU16, seg,	/* Segment for xxxx:... text in dis-assembly */
   LIN_ADDR, off,	/* ditto offset */
   SIZE_SPECIFIER, default_size,/* 16BIT or 32BIT code segment */
   LIN_ADDR, p,			/* linear address of start of instruction */
   read_byte_proc, byte_at,	/* like sas_hw_at() to use to read intel */
   char *, fmt,			/* sprintf format for first line seg:offset */
   char *, newline);		/* strcat text to separate lines */
#endif	/* DASM_INTERNAL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\cpu3.h ===
/*
 * SoftPC Revision 3.0
 *
 * Title	: Definitions for the 3.x CPU 
 *
 * Description	: Structures, macros and definitions for access to the 
 *		  CPU registers
 *
 * Author	: Wayne Plummer
 *
 * Derived from : cpu.h
 *
 * Notes	: This file should be portable - but includes a file
 *		  host_cpu.h which contains machine specific definitions
 *		  of CPU register mappings etc.
 */

/* SccsID[]="@(#)cpu3.h	1.5 12/22/93 Copyright Insignia Solutions Ltd."; */

#include "host_cpu.h"

IMPORT VOID host_set_hw_int IPT0();
IMPORT VOID host_clear_hw_int IPT0();

/*
 * These variables are obsolete - however they are referenced
 * by:-
 *
 *	1. ica.c
 */

extern  word            cpu_interrupt_map;
extern  half_word       cpu_int_translate[];
extern  word            cpu_int_delay;
extern  half_word       ica_lock;
extern  void            (*(jump_ptrs[]))();
extern  void            (*(b_write_ptrs[]))();
extern  void            (*(w_write_ptrs[]))();
extern  void            (*(b_fill_ptrs[]))();
extern  void            (*(w_fill_ptrs[]))();
extern  void            (*(b_move_ptrs[]))();
extern  void            (*(w_move_ptrs[]))();
extern  half_word       *haddr_of_src_string;

/*
 *	Host functions to be provided for the base to use with respect to the CPU.
 *	These must be done in host_cpu.h because some hosts may want functions and
 *	others may want #defines.
 */

/*
 *	This macro specifies the maximum recursion depth the CPU is required to support.
 *	(Note that a particular host may not actually use this value if it is capable
 *	of supporting abirtarily deep recursion).
 */
#define CPU_MAX_RECURSION	32

/*
 *	Interrupt types...
 */

typedef enum {	CPU_HW_RESET,
		CPU_TIMER_TICK,
		CPU_SW_INT,
		CPU_HW_INT,
		CPU_YODA_INT,
		CPU_SIGIO_EVENT
} CPU_INT_TYPE;

#ifdef CPU_PRIVATE
/*
   Function returns for private i/f procedures handling segment loading.
 */

#define SELECTOR_OK  0
#define GP_ERROR    13
#define NP_ERROR    11
#define SF_ERROR    12
#endif /* CPU_PRIVATE */

#ifdef CCPU

/* Fuctions provided by CPU */
IMPORT void		c_cpu_init	IPT0 ();
IMPORT void		c_cpu_interrupt	IPT2(CPU_INT_TYPE, type, IU16, number);
IMPORT void		c_cpu_simulate	IPT0();
IMPORT void		c_cpu_q_ev_set_count	IPT1(ULONG, new_count);
IMPORT ULONG		c_cpu_q_ev_get_count	IPT0();
IMPORT ULONG		c_cpu_calc_q_ev_inst_for_time	IPT1(ULONG, time);
IMPORT void		c_cpu_EOA_hook	IPT0();
IMPORT void		c_cpu_terminate	IPT0();

#define cpu_init		c_cpu_init
#define cpu_interrupt		c_cpu_interrupt
#define cpu_simulate		c_cpu_simulate
#define	host_q_ev_set_count	c_cpu_q_ev_set_count
#define	host_q_ev_get_count	c_cpu_q_ev_get_count
#ifndef host_calc_q_ev_inst_for_time
#define	host_calc_q_ev_inst_for_time	c_cpu_calc_q_ev_inst_for_time
#endif /* host_calc_q_ev_inst_for_time */
#define cpu_EOA_hook		c_cpu_EOA_hook
#define cpu_terminate		c_cpu_terminate

#ifndef CCPU_MAIN


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Byte Registers.                                  */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT half_word c_getAL	IPT0();
IMPORT half_word c_getCL	IPT0();
IMPORT half_word c_getDL	IPT0();
IMPORT half_word c_getBL	IPT0();
IMPORT half_word c_getAH	IPT0();
IMPORT half_word c_getCH	IPT0();
IMPORT half_word c_getDH	IPT0();
IMPORT half_word c_getBH	IPT0();
   
IMPORT void c_setAL	IPT1(half_word, val);
IMPORT void c_setCL	IPT1(half_word, val);
IMPORT void c_setDL	IPT1(half_word, val);
IMPORT void c_setBL	IPT1(half_word, val);
IMPORT void c_setAH	IPT1(half_word, val);
IMPORT void c_setCH	IPT1(half_word, val);
IMPORT void c_setDH	IPT1(half_word, val);
IMPORT void c_setBH	IPT1(half_word, val);

#define getAL() c_getAL()
#define getCL() c_getCL()
#define getDL() c_getDL()
#define getBL() c_getBL()
#define getAH() c_getAH()
#define getCH() c_getCH()
#define getDH() c_getDH()
#define getBH() c_getBH()

#define setAL(x) c_setAL(x)
#define setCL(x) c_setCL(x)
#define setDL(x) c_setDL(x)
#define setBL(x) c_setBL(x)
#define setAH(x) c_setAH(x)
#define setCH(x) c_setCH(x)
#define setDH(x) c_setDH(x)
#define setBH(x) c_setBH(x)

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Word Registers.                                  */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT word c_getAX	IPT0();
IMPORT word c_getCX	IPT0();
IMPORT word c_getDX	IPT0();
IMPORT word c_getBX	IPT0();
IMPORT word c_getSP	IPT0();
IMPORT word c_getBP	IPT0();
IMPORT word c_getSI	IPT0();
IMPORT word c_getDI	IPT0();
IMPORT word c_getIP	IPT0();

IMPORT void c_setAX	IPT1(word, val);
IMPORT void c_setCX	IPT1(word, val);
IMPORT void c_setDX	IPT1(word, val);
IMPORT void c_setBX	IPT1(word, val);
IMPORT void c_setSP	IPT1(word, val);
IMPORT void c_setBP	IPT1(word, val);
IMPORT void c_setSI	IPT1(word, val);
IMPORT void c_setDI	IPT1(word, val);
IMPORT void c_setIP	IPT1(word, val);

#define getAX() c_getAX()
#define getCX() c_getCX()
#define getDX() c_getDX()
#define getBX() c_getBX()
#define getSP() c_getSP()
#define getBP() c_getBP()
#define getSI() c_getSI()
#define getDI() c_getDI()
#define getIP() c_getIP()

#define setAX(x) c_setAX(x)
#define setCX(x) c_setCX(x)
#define setDX(x) c_setDX(x)
#define setBX(x) c_setBX(x)
#define setSP(x) c_setSP(x)
#define setBP(x) c_setBP(x)
#define setSI(x) c_setSI(x)
#define setDI(x) c_setDI(x)
#define setIP(x) c_setIP(x)

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Segment Registers.                               */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT word c_getES	IPT0();
IMPORT word c_getCS	IPT0();
IMPORT word c_getSS	IPT0();
IMPORT word c_getDS	IPT0();

IMPORT INT c_setES	IPT1(word, val);
IMPORT INT c_setCS	IPT1(word, val);
IMPORT INT c_setSS	IPT1(word, val);
IMPORT INT c_setDS	IPT1(word, val);

#define getES() c_getES()
#define getCS() c_getCS()
#define getSS() c_getSS()
#define getDS() c_getDS()

#define setES(x) c_setES(x)
#define setCS(x) c_setCS(x)
#define setSS(x) c_setSS(x)
#define setDS(x) c_setDS(x)

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Full(Private) Segment Registers.                 */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

#ifdef CPU_PRIVATE

IMPORT word c_getES_SELECTOR	IPT0();
IMPORT word c_getCS_SELECTOR	IPT0();
IMPORT word c_getSS_SELECTOR	IPT0();
IMPORT word c_getDS_SELECTOR	IPT0();

IMPORT word c_getCS_LIMIT	IPT0();
IMPORT word c_getDS_LIMIT	IPT0();
IMPORT word c_getES_LIMIT	IPT0();
IMPORT word c_getSS_LIMIT	IPT0();

IMPORT long c_getCS_BASE	IPT0();
IMPORT long c_getDS_BASE	IPT0();
IMPORT long c_getES_BASE	IPT0();
IMPORT long c_getSS_BASE	IPT0();

IMPORT half_word c_getCS_AR	IPT0();
IMPORT half_word c_getDS_AR	IPT0();
IMPORT half_word c_getES_AR	IPT0();
IMPORT half_word c_getSS_AR	IPT0();

IMPORT void c_setES_SELECTOR	IPT1(word, val);
IMPORT void c_setCS_SELECTOR	IPT1(word, val);
IMPORT void c_setSS_SELECTOR	IPT1(word, val);
IMPORT void c_setDS_SELECTOR	IPT1(word, val);

IMPORT void c_setCS_LIMIT	IPT1(word, val);
IMPORT void c_setDS_LIMIT	IPT1(word, val);
IMPORT void c_setES_LIMIT	IPT1(word, val);
IMPORT void c_setSS_LIMIT	IPT1(word, val);

IMPORT void c_setCS_BASE	IPT1(long, val);
IMPORT void c_setDS_BASE	IPT1(long, val);
IMPORT void c_setES_BASE	IPT1(long, val);
IMPORT void c_setSS_BASE	IPT1(long, val);

IMPORT void c_setCS_AR	IPT1(half_word, val);
IMPORT void c_setDS_AR	IPT1(half_word, val);
IMPORT void c_setES_AR	IPT1(half_word, val);
IMPORT void c_setSS_AR	IPT1(half_word, val);

#define getES_SELECTOR c_getES_SELECTOR
#define getCS_SELECTOR c_getCS_SELECTOR
#define getSS_SELECTOR c_getSS_SELECTOR
#define getDS_SELECTOR c_getDS_SELECTOR

#define getDS_LIMIT c_getDS_LIMIT
#define getCS_LIMIT c_getCS_LIMIT
#define getES_LIMIT c_getES_LIMIT
#define getSS_LIMIT c_getSS_LIMIT

#define getDS_BASE c_getDS_BASE
#define getCS_BASE c_getCS_BASE
#define getES_BASE c_getES_BASE
#define getSS_BASE c_getSS_BASE

#define getDS_AR c_getDS_AR
#define getCS_AR c_getCS_AR
#define getES_AR c_getES_AR
#define getSS_AR c_getSS_AR

#define setES_SELECTOR c_setES_SELECTOR
#define setCS_SELECTOR c_setCS_SELECTOR
#define setSS_SELECTOR c_setSS_SELECTOR
#define setDS_SELECTOR c_setDS_SELECTOR

#define setDS_LIMIT c_setDS_LIMIT
#define setCS_LIMIT c_setCS_LIMIT
#define setES_LIMIT c_setES_LIMIT
#define setSS_LIMIT c_setSS_LIMIT

#define setDS_BASE c_setDS_BASE
#define setCS_BASE c_setCS_BASE
#define setES_BASE c_setES_BASE
#define setSS_BASE c_setSS_BASE

#define setDS_AR c_setDS_AR
#define setCS_AR c_setCS_AR
#define setES_AR c_setES_AR
#define setSS_AR c_setSS_AR

#endif /* CPU_PRIVATE */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Flags.                                           */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT INT c_getAF	IPT0();
IMPORT INT c_getCF	IPT0();
IMPORT INT c_getDF	IPT0();
IMPORT INT c_getIF	IPT0();
IMPORT INT c_getOF	IPT0();
IMPORT INT c_getPF	IPT0();
IMPORT INT c_getSF	IPT0();
IMPORT INT c_getTF	IPT0();
IMPORT INT c_getZF	IPT0();
IMPORT INT c_getIOPL	IPT0();
IMPORT INT c_getNT	IPT0();
IMPORT word c_getSTATUS	IPT0();

IMPORT void c_setAF	IPT1(INT, val);
IMPORT void c_setCF	IPT1(INT, val);
IMPORT void c_setDF	IPT1(INT, val);
IMPORT void c_setIF	IPT1(INT, val);
IMPORT void c_setOF	IPT1(INT, val);
IMPORT void c_setPF	IPT1(INT, val);
IMPORT void c_setSF	IPT1(INT, val);
IMPORT void c_setTF	IPT1(INT, val);
IMPORT void c_setZF	IPT1(INT, val);
IMPORT void c_setIOPL	IPT1(INT, val);
IMPORT void c_setNT	IPT1(INT, val);

#define getAF()     c_getAF()
#define getCF()     c_getCF()
#define getDF()     c_getDF()
#define getIF()     c_getIF()
#define getOF()     c_getOF()
#define getPF()     c_getPF()
#define getSF()     c_getSF()
#define getTF()     c_getTF()
#define getZF()     c_getZF()
#define getIOPL()   c_getIOPL()
#define getNT()     c_getNT()
#define getSTATUS() c_getSTATUS()

#define setAF(x)     c_setAF(x)
#define setCF(x)     c_setCF(x)
#define setDF(x)     c_setDF(x)
#define setIF(x)     c_setIF(x)
#define setOF(x)     c_setOF(x)
#define setPF(x)     c_setPF(x)
#define setSF(x)     c_setSF(x)
#define setTF(x)     c_setTF(x)
#define setZF(x)     c_setZF(x)
#define setIOPL(x)   c_setIOPL(x)
#define setNT(x)     c_setNT(x)

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Machine Status Word.                             */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT INT c_getPE	IPT0();
IMPORT INT c_getMP	IPT0();
IMPORT INT c_getEM	IPT0();
IMPORT INT c_getTS	IPT0();
IMPORT word c_getMSW	IPT0();

#define getPE() c_getPE()
#define getMP() c_getMP()
#define getEM() c_getEM()
#define getTS() c_getTS()
#define getMSW() c_getMSW()

#ifdef CPU_PRIVATE

IMPORT void c_setPE	IPT1(INT, val);
IMPORT void c_setMP	IPT1(INT, val);
IMPORT void c_setEM	IPT1(INT, val);
IMPORT void c_setTS	IPT1(INT, val);
IMPORT void c_setMSW	IPT1(word, val);

#define setPE(x) c_setPE(x)
#define setMP(x) c_setMP(x)
#define setEM(x) c_setEM(x)
#define setTS(x) c_setTS(x)
#define setMSW(x) c_setMSW(x)

#endif /* CPU_PRIVATE */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Descriptor Registers.                            */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

IMPORT sys_addr c_getGDT_BASE	IPT0();
IMPORT sys_addr c_getIDT_BASE	IPT0();
IMPORT sys_addr c_getLDT_BASE	IPT0();
IMPORT sys_addr c_getTR_BASE	IPT0();
IMPORT word c_getGDT_LIMIT	IPT0();
IMPORT word c_getIDT_LIMIT	IPT0();
IMPORT word c_getLDT_LIMIT	IPT0();
IMPORT word c_getTR_LIMIT	IPT0();
IMPORT word c_getLDT_SELECTOR	IPT0();
IMPORT word c_getTR_SELECTOR	IPT0();

#define getGDT_BASE() c_getGDT_BASE()
#define getIDT_BASE() c_getIDT_BASE()
#define getLDT_BASE() c_getLDT_BASE()
#define getTR_BASE()  c_getTR_BASE()
#define getGDT_LIMIT() c_getGDT_LIMIT()
#define getIDT_LIMIT() c_getIDT_LIMIT()
#define getLDT_LIMIT() c_getLDT_LIMIT()
#define getTR_LIMIT()  c_getTR_LIMIT()
#define getLDT_SELECTOR() c_getLDT_SELECTOR()
#define getTR_SELECTOR()  c_getTR_SELECTOR()

#ifdef CPU_PRIVATE

IMPORT void c_setGDT_BASE	IPT1(sys_addr, val);
IMPORT void c_setIDT_BASE	IPT1(sys_addr, val);
IMPORT void c_setLDT_BASE	IPT1(sys_addr, val);
IMPORT void c_setTR_BASE	IPT1(sys_addr, val);
IMPORT void c_setGDT_LIMIT	IPT1(word, val);
IMPORT void c_setIDT_LIMIT	IPT1(word, val);
IMPORT void c_setLDT_LIMIT	IPT1(word, val);
IMPORT void c_setTR_LIMIT	IPT1(word, val);
IMPORT void c_setLDT_SELECTOR	IPT1(word, val);
IMPORT void c_setTR_SELECTOR	IPT1(word, val);

#define setGDT_BASE(x) c_setGDT_BASE(x)
#define setIDT_BASE(x) c_setIDT_BASE(x)
#define setLDT_BASE(x) c_setLDT_BASE(x)
#define setTR_BASE(x)  c_setTR_BASE(x)
#define setGDT_LIMIT(x) c_setGDT_LIMIT(x)
#define setIDT_LIMIT(x) c_setIDT_LIMIT(x)
#define setLDT_LIMIT(x) c_setLDT_LIMIT(x)
#define setTR_LIMIT(x)  c_setTR_LIMIT(x)
#define setLDT_SELECTOR(x) c_setLDT_SELECTOR(x)
#define setTR_SELECTOR(x)  c_setTR_SELECTOR(x)

#endif /* CPU_PRIVATE */

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Provide Access to Current Privilege Level.                         */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

#ifdef CPU_PRIVATE

IMPORT INT c_getCPL	IPT0();
IMPORT VOID c_setCPL	IPT1(INT, val);

#define getCPL() c_getCPL()
#define setCPL(x) c_setCPL(x)

#endif /* CPU_PRIVATE */

#endif /* CCPU_MAIN */

#endif /* CCPU */

#ifdef A3CPU

/*
 *	Function imports...
 */

/*
 *	cpu_init() - Initialises the 3.0 CPU.
 */

IMPORT VOID		a3_cpu_init IPT0();

/*
 *	cpu_interrupt() - Interrupts the 3.0 CPU.
 */
#ifdef SWITCHED_CPU
IMPORT VOID		a3_cpu_interrupt IPT2(CPU_INT_TYPE, type, IU16, number);
#else
IMPORT VOID		a3_cpu_interrupt();
#endif

/*
 *	cpu_simulate() - Performs INTEL CPU emulation.
 */
IMPORT VOID		_asm_simulate();

IMPORT VOID		a3_cpu_q_ev_set_count();
IMPORT ULONG		a3_cpu_q_ev_get_count();

#ifndef SWITCHED_CPU

extern IU32 a3_cpu_calc_q_ev_inst_for_time IPT1 (IU32, time);

/*
 *	cpu_EOA_hook() - Resets the 3.0 CPU prior to running the next application.
 */
IMPORT VOID		a3_cpu_EOA_hook();

/*
 *	cpu_terminate() - Closes down the CPU.
 */
IMPORT VOID		a3_cpu_terminate();

/*
 *	Intel register Access...
 */

IMPORT half_word	a3_getAL();
IMPORT half_word	a3_getBL();
IMPORT half_word	a3_getCL();
IMPORT half_word	a3_getDL();
IMPORT half_word	a3_getAH();
IMPORT half_word	a3_getBH();
IMPORT half_word	a3_getCH();
IMPORT half_word	a3_getDH();

IMPORT word		a3_getAX();
IMPORT word		a3_getBX();
IMPORT word		a3_getCX();
IMPORT word		a3_getDX();
IMPORT word		a3_getSP();
IMPORT word		a3_getBP();
IMPORT word		a3_getSI();
IMPORT word		a3_getDI();

IMPORT word		a3_getIP();

IMPORT word		a3_getCS();
IMPORT word		a3_getDS();
IMPORT word		a3_getES();
IMPORT word		a3_getSS();

IMPORT word		a3_getAF();
IMPORT word		a3_getCF();
IMPORT word		a3_getDF();
IMPORT word		a3_getIF();
IMPORT word		a3_getIOPL();
IMPORT word		a3_getNT();
IMPORT word		a3_getOF();
IMPORT word		a3_getPF();
IMPORT word		a3_getSF();
IMPORT word		a3_getTF();
IMPORT word		a3_getZF();

IMPORT word		a3_getSTATUS();

IMPORT word		a3_getEM();
IMPORT word		a3_getMP();
IMPORT word		a3_getPE();
IMPORT word		a3_getTS();

IMPORT word		a3_getMSW();

IMPORT sys_addr		a3_getGDT_BASE();
IMPORT word		a3_getGDT_LIMIT();

IMPORT sys_addr		a3_getIDT_BASE();
IMPORT word		a3_getIDT_LIMIT();

IMPORT sys_addr		a3_getLDT_BASE();
IMPORT word		a3_getLDT_LIMIT();
IMPORT word		a3_getLDT_SELECTOR();

IMPORT sys_addr		a3_getTR_BASE();
IMPORT word		a3_getTR_LIMIT();
IMPORT word		a3_getTR_SELECTOR();

IMPORT VOID		a3_setAL();
IMPORT VOID		a3_setCL();
IMPORT VOID		a3_setDL();
IMPORT VOID		a3_setBL();
IMPORT VOID		a3_setAH();
IMPORT VOID		a3_setCH();
IMPORT VOID		a3_setDH();
IMPORT VOID		a3_setBH();

IMPORT VOID		a3_setAX();
IMPORT VOID		a3_setCX();
IMPORT VOID		a3_setDX();
IMPORT VOID		a3_setBX();
IMPORT VOID		a3_setSP();
IMPORT VOID		a3_setBP();
IMPORT VOID		a3_setSI();
IMPORT VOID		a3_setDI();

IMPORT VOID		a3_setIP();

IMPORT INT		a3_setES();
IMPORT INT		a3_setCS();
IMPORT INT		a3_setSS();
IMPORT INT		a3_setDS();

IMPORT VOID		a3_setCF();
IMPORT VOID		a3_setPF();
IMPORT VOID		a3_setAF();
IMPORT VOID		a3_setZF();
IMPORT VOID		a3_setSF();
IMPORT VOID		a3_setTF();
IMPORT VOID		a3_setIF();
IMPORT VOID		a3_setDF();
IMPORT VOID		a3_setOF();
IMPORT VOID		a3_setIOPL();
IMPORT VOID		a3_setNT();

#ifdef CPU_PRIVATE

IMPORT word		a3_p_getCPL();
IMPORT word		a3_p_getES_SELECTOR();
IMPORT sys_addr		a3_p_getES_BASE();
IMPORT word		a3_p_getES_LIMIT();
IMPORT half_word	a3_p_getES_AR();
IMPORT VOID		a3_p_setES_SELECTOR();
IMPORT VOID		a3_p_setES_BASE();
IMPORT VOID		a3_p_setES_LIMIT();
IMPORT VOID		a3_p_setES_AR();
IMPORT word		a3_p_getCS_SELECTOR();
IMPORT sys_addr		a3_p_getCS_BASE();
IMPORT word		a3_p_getCS_LIMIT();
IMPORT half_word	a3_p_getCS_AR();
IMPORT VOID		a3_p_setCS_SELECTOR();
IMPORT VOID		a3_p_setCS_BASE();
IMPORT VOID		a3_p_setCS_LIMIT();
IMPORT VOID		a3_p_setCS_AR();
IMPORT word		a3_p_getDS_SELECTOR();
IMPORT sys_addr		a3_p_getDS_BASE();
IMPORT word		a3_p_getDS_LIMIT();
IMPORT half_word	a3_p_getDS_AR();
IMPORT VOID		a3_p_setDS_SELECTOR();
IMPORT VOID		a3_p_setDS_BASE();
IMPORT VOID		a3_p_setDS_LIMIT();
IMPORT VOID		a3_p_setDS_AR();
IMPORT word		a3_p_getSS_SELECTOR();
IMPORT sys_addr		a3_p_getSS_BASE();
IMPORT word		a3_p_getSS_LIMIT();
IMPORT half_word	a3_p_getSS_AR();
IMPORT VOID		a3_p_setSS_SELECTOR();
IMPORT VOID		a3_p_setSS_BASE();
IMPORT VOID		a3_p_setSS_LIMIT();
IMPORT VOID		a3_p_setSS_AR();
IMPORT VOID		a3_p_setPE();
IMPORT VOID		a3_p_setMP();
IMPORT VOID		a3_p_setEM();
IMPORT VOID		a3_p_setTS();
IMPORT VOID		a3_p_setMSW();
IMPORT VOID		a3_p_setCPL();
IMPORT VOID		a3_p_setGDT_BASE();
IMPORT VOID		a3_p_setGDT_LIMIT();
IMPORT VOID		a3_p_setIDT_BASE();
IMPORT VOID		a3_p_setIDT_LIMIT();
IMPORT VOID		a3_p_setLDT_SELECTOR();
IMPORT VOID		a3_p_setLDT_BASE();
IMPORT VOID		a3_p_setLDT_LIMIT();
IMPORT VOID		a3_p_setTR_SELECTOR();
IMPORT VOID		a3_p_setTR_BASE();
IMPORT VOID		a3_p_setTR_LIMIT();

#endif /* CPU_PRIVATE */
#endif /* SWITCHED_CPU */


/*
 *	Macro definitions...
 */

#define cpu_init		a3_cpu_init
#define cpu_simulate		_asm_simulate
#define	host_q_ev_set_count	a3_cpu_q_ev_set_count
#define	host_q_ev_get_count	a3_cpu_q_ev_get_count
#ifndef host_calc_q_ev_inst_for_time
#define	host_calc_q_ev_inst_for_time	a3_cpu_calc_q_ev_inst_for_time
#endif /* host_calc_q_ev_inst_for_time */
#define cpu_EOA_hook		a3_cpu_EOA_hook
#define cpu_terminate		a3_cpu_terminate

/*
 *	Intel register Access...
 */

#ifndef getAX

#define cpu_interrupt		a3_cpu_interrupt

#define getAL		a3_getAL
#define getBL		a3_getBL
#define getCL		a3_getCL
#define getDL		a3_getDL
#define getAH		a3_getAH
#define getBH		a3_getBH
#define getCH		a3_getCH
#define getDH		a3_getDH
#define getAX		a3_getAX
#define getBX		a3_getBX
#define getCX		a3_getCX
#define getDX		a3_getDX
#define getSP		a3_getSP
#define getBP		a3_getBP
#define getSI		a3_getSI
#define getDI		a3_getDI
#define getIP		a3_getIP
#define getCS		a3_getCS
#define getDS		a3_getDS
#define getES		a3_getES
#define getSS		a3_getSS
#define getAF		a3_getAF
#define getCF		a3_getCF
#define getDF		a3_getDF
#define getIF		a3_getIF
#define getIOPL		a3_getIOPL
#define getNT		a3_getNT
#define getOF		a3_getOF
#define getPF		a3_getPF
#define getSF		a3_getSF
#define getTF		a3_getTF
#define getZF		a3_getZF
#define getSTATUS	a3_getSTATUS
#define getEM		a3_getEM
#define getMP		a3_getMP
#define getPE		a3_getPE
#define getTS		a3_getTS
#define getMSW		a3_getMSW
#define getGDT_BASE	a3_getGDT_BASE
#define getGDT_LIMIT	a3_getGDT_LIMIT
#define getIDT_BASE	a3_getIDT_BASE
#define getIDT_LIMIT	a3_getIDT_LIMIT
#define getLDT_BASE	a3_getLDT_BASE
#define getLDT_LIMIT	a3_getLDT_LIMIT
#define getLDT_SELECTOR	a3_getLDT_SELECTOR
#define getTR_BASE	a3_getTR_BASE
#define getTR_LIMIT	a3_getTR_LIMIT
#define getTR_SELECTOR	a3_getTR_SELECTOR
#define setAL		a3_setAL
#define setCL		a3_setCL
#define setDL		a3_setDL
#define setBL		a3_setBL
#define setAH		a3_setAH
#define setCH		a3_setCH
#define setDH		a3_setDH
#define setBH		a3_setBH
#define setAX		a3_setAX
#define setCX		a3_setCX
#define setDX		a3_setDX
#define setBX		a3_setBX
#define setSP		a3_setSP
#define setBP		a3_setBP
#define setSI		a3_setSI
#define setDI		a3_setDI
#define setIP		a3_setIP
#define setES		a3_setES
#define setCS		a3_setCS
#define setSS		a3_setSS
#define setDS		a3_setDS
#define setCF		a3_setCF
#define setPF		a3_setPF
#define setAF		a3_setAF
#define setZF		a3_setZF
#define setSF		a3_setSF
#define setTF		a3_setTF
#define setIF		a3_setIF
#define setDF		a3_setDF
#define setOF		a3_setOF
#define setIOPL		a3_setIOPL
#define setNT		a3_setNT

#endif /* getAX */

#ifdef CPU_PRIVATE

#define getCPL		a3_p_getCPL
#define getES_SELECTOR	a3_p_getES_SELECTOR
#define getCS_SELECTOR	a3_p_getCS_SELECTOR
#define getSS_SELECTOR	a3_p_getSS_SELECTOR
#define getDS_SELECTOR	a3_p_getDS_SELECTOR
#define getES_BASE	a3_p_getES_BASE
#define getCS_BASE	a3_p_getCS_BASE
#define getDS_BASE	a3_p_getDS_BASE
#define getSS_BASE	a3_p_getSS_BASE
#define getES_LIMIT	a3_p_getES_LIMIT
#define getCS_LIMIT	a3_p_getCS_LIMIT
#define getDS_LIMIT	a3_p_getDS_LIMIT
#define getSS_LIMIT	a3_p_getSS_LIMIT
#define getES_AR	a3_p_getES_AR
#define getCS_AR	a3_p_getCS_AR
#define getDS_AR	a3_p_getDS_AR
#define getSS_AR	a3_p_getSS_AR
#define setES_SELECTOR	a3_p_setES_SELECTOR
#define setCS_SELECTOR	a3_p_setCS_SELECTOR
#define setSS_SELECTOR	a3_p_setSS_SELECTOR
#define setDS_SELECTOR	a3_p_setDS_SELECTOR
#define setES_BASE	a3_p_setES_BASE
#define setCS_BASE	a3_p_setCS_BASE
#define setDS_BASE	a3_p_setDS_BASE
#define setSS_BASE	a3_p_setSS_BASE
#define setES_LIMIT	a3_p_setES_LIMIT
#define setCS_LIMIT	a3_p_setCS_LIMIT
#define setDS_LIMIT	a3_p_setDS_LIMIT
#define setSS_LIMIT	a3_p_setSS_LIMIT
#define setES_AR	a3_p_setES_AR
#define setCS_AR	a3_p_setCS_AR
#define setDS_AR	a3_p_setDS_AR
#define setSS_AR	a3_p_setSS_AR
#define setPE		a3_p_setPE
#define setMP		a3_p_setMP
#define setEM		a3_p_setEM
#define setTS		a3_p_setTS
#define setMSW		a3_p_setMSW
#define setCPL		a3_p_setCPL
#define setGDT_BASE	a3_p_setGDT_BASE
#define setGDT_LIMIT	a3_p_setGDT_LIMIT
#define setIDT_BASE	a3_p_setIDT_BASE
#define setIDT_LIMIT	a3_p_setIDT_LIMIT
#define setLDT_SELECTOR	a3_p_setLDT_SELECTOR
#define setLDT_BASE	a3_p_setLDT_BASE
#define setLDT_LIMIT	a3_p_setLDT_LIMIT
#define setTR_SELECTOR	a3_p_setTR_SELECTOR
#define setTR_BASE	a3_p_setTR_BASE
#define setTR_LIMIT	a3_p_setTR_LIMIT

#endif /* CPU_PRIVATE */

#endif /* A3CPU */

#ifdef SPC386
/*
 * New additions for SPC386 builds follow...
 * eventually it would be nice to change the start of this file to conform
 * to the new style when there is effort to spare.
 *
 *       Wayne Plummer 19/3/93 (GISP project)
 */

#ifdef CCPU
IMPORT void c_setSTATUS	IPT1(IU16, val);
#define setSTATUS()  c_setSTATUS()
#else
IMPORT VOID		a3_setSTATUS IPT1(IU16, val);
#define setSTATUS	a3_setSTATUS
#endif


#ifdef CCPU
IMPORT IU32 c_getEFLAGS	IPT0();
#define getEFLAGS() c_getEFLAGS()
#else
IMPORT IU32		a3_getEFLAGS();
#define getEFLAGS	a3_getEFLAGS
#endif

#ifdef CCPU
IMPORT void c_setEFLAGS	IPT1(IU32, val);
#define setEFLAGS()  c_setEFLAGS()
#else
IMPORT VOID		a3_setEFLAGS IPT1(IU32, val);
#define setEFLAGS	a3_setEFLAGS
#endif


#ifdef CCPU
IMPORT   IU32   c_getEAX               IPT0();
#define           getEAX               c_getEAX
#else
IMPORT   IU32  a3_getEAX               IPT0();
#define           getEAX               a3_getEAX
#endif

#ifdef CCPU
IMPORT   IU32   c_getEBX               IPT0();
#define           getEBX               c_getEBX
#else
IMPORT   IU32  a3_getEBX               IPT0();
#define           getEBX               a3_getEBX
#endif

#ifdef CCPU
IMPORT   IU32   c_getECX               IPT0();
#define           getECX               c_getECX
#else
IMPORT   IU32  a3_getECX               IPT0();
#define           getECX               a3_getECX
#endif

#ifdef CCPU
IMPORT   IU32   c_getEDX               IPT0();
#define           getEDX               c_getEDX
#else
IMPORT   IU32  a3_getEDX               IPT0();
#define           getEDX               a3_getEDX
#endif

#ifdef CCPU
IMPORT   IU32   c_getESP               IPT0();
#define           getESP               c_getESP
#else
IMPORT   IU32  a3_getESP               IPT0();
#define           getESP               a3_getESP
#endif

#ifdef CCPU
IMPORT   IU32   c_getEBP               IPT0();
#define           getEBP               c_getEBP
#else
IMPORT   IU32  a3_getEBP               IPT0();
#define           getEBP               a3_getEBP
#endif

#ifdef CCPU
IMPORT   IU32   c_getESI               IPT0();
#define           getESI               c_getESI
#else
IMPORT   IU32  a3_getESI               IPT0();
#define           getESI               a3_getESI
#endif

#ifdef CCPU
IMPORT   IU32   c_getEDI               IPT0();
#define           getEDI               c_getEDI
#else
IMPORT   IU32  a3_getEDI               IPT0();
#define           getEDI               a3_getEDI
#endif

#ifdef CCPU
IMPORT   IU32   c_getEIP               IPT0();
#define           getEIP               c_getEIP
#else
IMPORT   IU32  a3_getEIP               IPT0();
#define           getEIP               a3_getEIP
#endif

#ifdef CCPU
IMPORT   IU16   c_getFS                IPT0();
#define           getFS                c_getFS 
#else
IMPORT   IU16  a3_getFS                IPT0();
#define           getFS                a3_getFS 
#endif

#ifdef CCPU
IMPORT   IU16   c_getGS                IPT0();
#define           getGS                c_getGS 
#else
IMPORT   IU16  a3_getGS                IPT0();
#define           getGS                a3_getGS 
#endif

#ifdef CCPU
IMPORT   IU16   c_getVM                IPT0();
#define           getVM                c_getVM 
#else
IMPORT   IU16  a3_getVM                IPT0();
#define           getVM                a3_getVM 
#endif

#ifdef CCPU
IMPORT   IU16   c_getPG                IPT0();
#define           getPG                c_getPG 
#else
IMPORT   IU16  a3_getPG                IPT0();
#define           getPG                a3_getPG 
#endif

#ifdef CCPU
IMPORT   VOID   c_setEAX               IPT1(IU32, val);
#define           setEAX               c_setEAX
#else
IMPORT   IU32  a3_setEAX               IPT1(IU32, val);
#define           setEAX               a3_setEAX
#endif

#ifdef CCPU
IMPORT   VOID   c_setEBX               IPT1(IU32, val);
#define           setEBX               c_setEBX
#else
IMPORT   IU32  a3_setEBX               IPT1(IU32, val);
#define           setEBX               a3_setEBX
#endif

#ifdef CCPU
IMPORT   VOID   c_setECX               IPT1(IU32, val);
#define           setECX               c_setECX
#else
IMPORT   IU32  a3_setECX               IPT1(IU32, val);
#define           setECX               a3_setECX
#endif

#ifdef CCPU
IMPORT   VOID   c_setEDX               IPT1(IU32, val);
#define           setEDX               c_setEDX
#else
IMPORT   IU32  a3_setEDX               IPT1(IU32, val);
#define           setEDX               a3_setEDX
#endif

#ifdef CCPU
IMPORT   VOID   c_setESP               IPT1(IU32, val);
#define           setESP               c_setESP
#else
IMPORT   IU32  a3_setESP               IPT1(IU32, val);
#define           setESP               a3_setESP
#endif

#ifdef CCPU
IMPORT   VOID   c_setEBP               IPT1(IU32, val);
#define           setEBP               c_setEBP
#else
IMPORT   IU32  a3_setEBP               IPT1(IU32, val);
#define           setEBP               a3_setEBP
#endif

#ifdef CCPU
IMPORT   VOID   c_setESI               IPT1(IU32, val);
#define           setESI               c_setESI
#else
IMPORT   IU32  a3_setESI               IPT1(IU32, val);
#define           setESI               a3_setESI
#endif

#ifdef CCPU
IMPORT   VOID   c_setEDI               IPT1(IU32, val);
#define           setEDI               c_setEDI
#else
IMPORT   IU32  a3_setEDI               IPT1(IU32, val);
#define           setEDI               a3_setEDI
#endif

#ifdef CCPU
IMPORT   VOID   c_setEIP               IPT1(IU32, val);
#define           setEIP               c_setEIP
#else
IMPORT   IU32  a3_setEIP               IPT1(IU32, val);
#define           setEIP               a3_setEIP
#endif

#ifdef CCPU
IMPORT   VOID   c_setFS                IPT1(IU16, val);
#define           setFS                c_setFS 
#else
IMPORT   IU32  a3_setFS                IPT1(IU16, val);
#define           setFS                a3_setFS 
#endif

#ifdef CCPU
IMPORT   VOID   c_setGS                IPT1(IU16, val);
#define           setGS                c_setGS 
#else
IMPORT   IU32  a3_setGS                IPT1(IU16, val);
#define           setGS                a3_setGS 
#endif

#ifdef IRET_HOOKS
#ifdef CCPU
IMPORT   VOID c_Cpu_set_hook_selector  IPT1(IU16, selector);
#define  Cpu_set_hook_selector         c_Cpu_set_hook_selector
#else
IMPORT   VOID a3_Cpu_set_hook_selector IPT1(IU16, selector);
#define  Cpu_set_hook_selector         a3_Cpu_set_hook_selector
#endif
#endif /* IRET_HOOKS */

#ifdef CPU_PRIVATE

#ifdef CCPU
IMPORT	IU32	c_getFS_BASE		IPT0();
#define		getFS_BASE		c_getFS_BASE 
#else
IMPORT	IU32	a3_p_getFS_BASE		IPT0();
#define		getFS_BASE		a3_p_getFS_BASE 
#endif

#ifdef CCPU
IMPORT	IU16	c_getFS_LIMIT		IPT0();
#define		getFS_LIMIT		c_getFS_LIMIT 
#else
IMPORT	IU16	a3_p_getFS_LIMIT	IPT0();
#define		getFS_LIMIT		a3_p_getFS_LIMIT 
#endif

#ifdef CCPU
IMPORT	IU8	c_getFS_AR		IPT0();
#define		getFS_AR		c_getFS_AR 
#else
IMPORT	IU8	a3_p_getFS_AR		IPT0();
#define		getFS_AR		a3_p_getFS_AR 
#endif

#ifdef CCPU
IMPORT	IU32	c_getGS_BASE		IPT0();
#define		getGS_BASE		c_getGS_BASE 
#else
IMPORT	IU32	a3_p_getGS_BASE		IPT0();
#define		getGS_BASE		a3_p_getGS_BASE 
#endif

#ifdef CCPU
IMPORT	IU16	c_getGS_LIMIT		IPT0();
#define		getGS_LIMIT		c_getGS_LIMIT 
#else
IMPORT	IU16	a3_p_getGS_LIMIT	IPT0();
#define		getGS_LIMIT		a3_p_getGS_LIMIT 
#endif

#ifdef CCPU
IMPORT	IU8	c_getGS_AR		IPT0();
#define		getGS_AR		c_getGS_AR 
#else
IMPORT	IU8	a3_p_getGS_AR		IPT0();
#define		getGS_AR		a3_p_getGS_AR 
#endif

#ifdef CCPU
IMPORT	void	c_setFS_BASE		IPT1(IU32, base);
#define		setFS_BASE		c_setFS_BASE 
#else
IMPORT	void	a3_p_setFS_BASE		IPT1(IU32, base);
#define		setFS_BASE		a3_p_setFS_BASE 
#endif

#ifdef CCPU
IMPORT	void	c_setFS_LIMIT		IPT1(IU16, limit);
#define		setFS_LIMIT		c_setFS_LIMIT 
#else
IMPORT	void	a3_p_setFS_LIMIT	IPT1(IU16, limit);
#define		setFS_LIMIT		a3_p_setFS_LIMIT 
#endif

#ifdef CCPU
IMPORT	void	c_setFS_AR		IPT1(IU8, ar);
#define		setFS_AR		c_setFS_AR 
#else
IMPORT	void	a3_p_setFS_AR		IPT1(IU8, ar);
#define		setFS_AR		a3_p_setFS_AR 
#endif


#ifdef CCPU
IMPORT	void	c_setGS_BASE		IPT1(IU32, base);
#define		setGS_BASE		c_setGS_BASE 
#else
IMPORT	void	a3_p_setGS_BASE		IPT1(IU32, base);
#define		setGS_BASE		a3_p_setGS_BASE 
#endif

#ifdef CCPU
IMPORT	void	c_setGS_LIMIT		IPT1(IU16, limit);
#define		setGS_LIMIT		c_setGS_LIMIT 
#else
IMPORT	void	a3_p_setGS_LIMIT	IPT1(IU16, limit);
#define		setGS_LIMIT		a3_p_setGS_LIMIT 
#endif

#ifdef CCPU
IMPORT	void	c_setGS_AR		IPT1(IU8, ar);
#define		setGS_AR		c_setGS_AR 
#else
IMPORT	void	a3_p_setGS_AR		IPT1(IU8, ar);
#define		setGS_AR		a3_p_setGS_AR 
#endif

#ifndef CCPU
/*
 * These functions get the (E)IP or (E)SP correctly whatever size stack
 * or code segment is in use.
 */
extern IU32 GetInstructionPointer IPT0();
extern IU32 GetStackPointer IPT0();
#endif /* CCPU */
#endif /* CPU_PRIVATE */
#endif /* SPC386 */

#ifdef IRET_HOOKS
/*
 * The interfaces provided by the CPU so that the ICA can initiate and
 * terminate an iret hook.
 */

extern void Cpu_do_hook IPT2(IUM8, line, IBOOL, is_hooked);
extern void Cpu_inter_hook_processing IPT1(IUM8, line);
extern void Cpu_unhook IPT1(IUM8, line_number);
#ifdef GISP_CPU
extern void Cpu_set_hook_selector IPT1(IU16, selector);
extern void Cpu_hook_bop IPT0();
#endif

#endif /* IRET_HOOKS */

/*
 * No non-386 cpu can run in VM mode, so getVM is always zero.
 * The same is true for GISP, but it has its own version of this interface.
 *
 * We also have definition of the GetInstructionPointer and GetStackPointer
 * interfaces, which on a non-386 can only be the 16 bit versions.
 */

#ifndef SPC386
#define getVM() 0
#define GetInstructionPointer() ((IU32)getIP())
#define GetStackPointer() ((IU32getSP())
#endif

#ifdef SWIN_CPU_OPTS
extern IBOOL Cpu_find_dcache_entry IPT2(IU16, seg, LIN_ADDR *, base);
#endif

#ifdef	CPU_PRIVATE
/*
 * Map new "private" cpu interface -> old interface
 */

#define	setIDT_BASE_LIMIT(base,limit)	{ setIDT_BASE(base); setIDT_LIMIT(limit); }
#define	setGDT_BASE_LIMIT(base,limit)	{ setGDT_BASE(base); setGDT_LIMIT(limit); }
#define	setLDT_BASE_LIMIT(base,limit)	{ setLDT_BASE(base); setLDT_LIMIT(limit); }
#define	setTR_BASE_LIMIT(base,limit)	{ setTR_BASE(base); setTR_LIMIT(limit); }

#define	setCS_BASE_LIMIT_AR(base,limit,ar)	{ setCS_BASE(base); setCS_LIMIT(limit); setCS_AR(ar); }
#define	setES_BASE_LIMIT_AR(base,limit,ar)	{ setES_BASE(base); setES_LIMIT(limit); setES_AR(ar); }
#define	setSS_BASE_LIMIT_AR(base,limit,ar)	{ setSS_BASE(base); setSS_LIMIT(limit); setSS_AR(ar); }
#define	setDS_BASE_LIMIT_AR(base,limit,ar)	{ setDS_BASE(base); setDS_LIMIT(limit); setDS_AR(ar); }
#define	setFS_BASE_LIMIT_AR(base,limit,ar)	{ setFS_BASE(base); setFS_LIMIT(limit); setFS_AR(ar); }
#define	setGS_BASE_LIMIT_AR(base,limit,ar)	{ setGS_BASE(base); setGS_LIMIT(limit); setGS_AR(ar); }

#endif	/* CPU_PRIVATE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\debug.h ===
/*
 * SccsID = @(#)debug.h	1.5 01/23/95 Copyright Insignia Solutions Ltd.
 *
 * The following values are used to indicate which ega setting decided that
 * the display should be disabled. The global variable display_disabled
 * should be 1 (or more) of these values.
 *
 */

#define	ASYNC_RESET		1
#define	SYNC_RESET		2
#define	VIDEO_DRIVERS_DISABLED	4

#ifndef	YES
#define	YES	1
#define	NO	0
#endif

#ifdef	PROD
#define	NON_PROD(x)
#define	PROD_ONLY(x)	x
#else
#define	NON_PROD(x)	x
#define	PROD_ONLY(x)
#endif

#ifndef	PROD
#include <stdio.h>
#include "trace.h"

#ifndef	newline
#define	newline	fprintf(trace_file, "\n")
#endif

#ifndef	file_id
#define	file_id		fprintf(trace_file, "%s:%d ", __FILE__, __LINE__ ) 
#endif

#define	note_entrance0(str)			if (io_verbose & EGA_ROUTINE_ENTRY) { file_id;fprintf(trace_file, str);newline; }
#define	note_entrance1(str,p1)			if (io_verbose & EGA_ROUTINE_ENTRY) { file_id;fprintf(trace_file, str,p1);newline; }
#define	note_entrance2(str,p1,p2)		if (io_verbose & EGA_ROUTINE_ENTRY) { file_id;fprintf(trace_file, str,p1,p2);newline; }
#define	note_entrance3(str,p1,p2,p3)		if (io_verbose & EGA_ROUTINE_ENTRY) { file_id;fprintf(trace_file, str,p1,p2,p3);newline; }
#define	note_entrance4(str,p1,p2,p3,p4)		if (io_verbose & EGA_ROUTINE_ENTRY) { file_id;fprintf(trace_file, str,p1,p2,p3,p4);newline; }
#define note_write_state0(str)			if (io_verbose & EGA_WRITE_VERBOSE) { file_id;fprintf(trace_file, str);newline; }
#define note_write_state1(str,p1)		if (io_verbose & EGA_WRITE_VERBOSE) { file_id;fprintf(trace_file, str,p1);newline; }
#define note_write_state2(str,p1,p2)		if (io_verbose & EGA_WRITE_VERBOSE) { file_id;fprintf(trace_file, str,p1,p2);newline; }
#define note_write_state3(str,p1,p2,p3)		if (io_verbose & EGA_WRITE_VERBOSE) { file_id;fprintf(trace_file, str,p1,p2,p3);newline; }
#define	note_display_state0(str)		if (io_verbose & EGA_DISPLAY_VERBOSE) { file_id;fprintf(trace_file, str);newline; }
#define	note_display_state1(str,p1)		if (io_verbose & EGA_DISPLAY_VERBOSE) { file_id;fprintf(trace_file, str,p1);newline; }
#define	note_display_state2(str,p1,p2)		if (io_verbose & EGA_DISPLAY_VERBOSE) { file_id;fprintf(trace_file, str,p1,p2);newline; }
#define	note_display_state3(str,p1,p2,p3)	if (io_verbose & EGA_DISPLAY_VERBOSE) { file_id;fprintf(trace_file, str,p1,p2,p3);newline; }
#define	do_display_trace(str,thing_to_do)	if (io_verbose & EGA_DISPLAY_VERBOSE) { file_id;fprintf(trace_file, str);newline;thing_to_do; }

/*
 * Generic tracing stuff to avoid nasty defines everywhere
 */

#define	note_trace0(trace_bit,str)		if (io_verbose & (trace_bit)) { file_id; fprintf(trace_file, str); newline; }
#define	note_trace1(trace_bit,str,p0)		if (io_verbose & (trace_bit)) { file_id;fprintf(trace_file, str,p0);newline; }
#define	note_trace2(trace_bit,str,p0,p1)	if (io_verbose & (trace_bit)) { file_id;fprintf(trace_file, str,p0,p1);newline; }
#define	note_trace3(trace_bit,str,p0,p1,p2)	if (io_verbose & (trace_bit)) { file_id;fprintf(trace_file, str,p0,p1,p2);newline; }
#define	note_trace4(trace_bit,str,p0,p1,p2,p3)	if (io_verbose & (trace_bit)) { file_id;fprintf(trace_file, str,p0,p1,p2,p3);newline; }
#define	note_trace5(trace_bit,str,p0,p1,p2,p3,p4) \
	if (io_verbose & (trace_bit)) { \
		file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4);newline; }
#define	note_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5) \
	if (io_verbose & (trace_bit)) { \
		file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5);newline; }
#define	note_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6) \
	if (io_verbose & (trace_bit)) { \
		file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6);newline; }
#define	note_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7) \
	if (io_verbose & (trace_bit)) { \
		file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6,p7); \
		newline; }


#define	always_trace0(str)		{ \
                      file_id;fprintf(trace_file, str);newline; }
#define	always_trace1(str,p0)		{ \
                      file_id;fprintf(trace_file, str,p0);newline; }
#define	always_trace2(str,p0,p1)	{ \
                      file_id;fprintf(trace_file, str,p0,p1);newline; }
#define	always_trace3(str,p0,p1,p2)	{ \
                      file_id;\
                      fprintf(trace_file, str,p0,p1,p2);newline; }
#define	always_trace4(str,p0,p1,p2,p3){ \
                      file_id; \
                      fprintf(trace_file, str,p0,p1,p2,p3); newline; }
#define	always_trace5(str,p0,p1,p2,p3,p4){ \
                      file_id; \
                      fprintf(trace_file, str,p0,p1,p2,p3,p4); newline; }
#define	always_trace6(str,p0,p1,p2,p3,p4,p5){ \
                      file_id; \
                      fprintf(trace_file, str,p0,p1,p2,p3,p4,p5); newline; }
#define	always_trace7(str,p0,p1,p2,p3,p4,p5,p6){ \
                      file_id; \
                      fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6); newline; }
#define	always_trace8(str,p0,p1,p2,p3,p4,p5,p6,p7){ \
                      file_id; \
                      fprintf(trace_file,str,p0,p1,p2,p3,p4,p5,p6,p7);newline;}

/*
** The _no_nl macros also print messages when appropriate, but they do
** not put a new line afterwards.
*/
#define	note_trace0_no_nl(trace_bit, str)				\
		if (io_verbose & (trace_bit)){ 				\
 			fprintf(trace_file, str);			\
			fflush( trace_file );				\
		}
#define	note_trace1_no_nl(trace_bit, str, p0)				\
		if (io_verbose & (trace_bit)){ 				\
 			fprintf(trace_file, str, p0);			\
			fflush( trace_file );				\
		}
#define	note_trace2_no_nl(trace_bit, str, p0, p1)			\
		if (io_verbose & (trace_bit)){ 				\
 			fprintf(trace_file, str, p0, p1);		\
			fflush( trace_file );				\
		}

#define	sure_note_trace0(trace_bit,str)		\
		if (io_verbose & (trace_bit)) {\
			host_block_timer();\
			 file_id; fprintf(trace_file, str); newline; \
			host_release_timer();\
		}
#define	sure_note_trace1(trace_bit,str,p0)		\
		if (io_verbose & (trace_bit)) {\
			host_block_timer();\
			 file_id;fprintf(trace_file, str,p0);newline; \
			host_release_timer();\
		}
#define	sure_note_trace2(trace_bit,str,p0,p1)	\
		if (io_verbose & (trace_bit)) {\
			host_block_timer();\
			 file_id;fprintf(trace_file, str,p0,p1);newline; \
			host_release_timer();\
		}
#define	sure_note_trace3(trace_bit,str,p0,p1,p2)	\
		if (io_verbose & (trace_bit)) {\
			host_block_timer();\
			 file_id;fprintf(trace_file, str,p0,p1,p2);newline; \
			host_release_timer();\
		}
#define	sure_note_trace4(trace_bit,str,p0,p1,p2,p3)	\
		if (io_verbose & (trace_bit)) {\
			host_block_timer();\
			 file_id;fprintf(trace_file, str,p0,p1,p2,p3);newline; \
			host_release_timer();\
		}
#define	sure_note_trace5(trace_bit,str,p0,p1,p2,p3,p4) \
		if (io_verbose & (trace_bit)) { \
			host_block_timer();\
			file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4);\
			newline; \
			host_release_timer();\
		}
#define	sure_note_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5) \
		if (io_verbose & (trace_bit)) { \
			host_block_timer();\
			file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5);\
			newline; \
			host_release_timer();\
		}
#define	sure_note_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6) \
		if (io_verbose & (trace_bit)) { \
			host_block_timer();\
			file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6);\
			newline; \
			host_release_timer();\
		}
#define	sure_note_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7) \
	if (io_verbose & (trace_bit)) { \
			host_block_timer();\
			file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6,p7); \
			newline; \
			host_release_timer();\
		}

#define	sub_note_trace0(trace_bit,str)		\
	if (sub_io_verbose & (trace_bit))\
	{ file_id; fprintf(trace_file, str); newline; }
#define	sub_note_trace1(trace_bit,str,p0)	\
	if (sub_io_verbose & (trace_bit))\
	{ file_id;fprintf(trace_file, str,p0);newline; }
#define	sub_note_trace2(trace_bit,str,p0,p1)	\
	if (sub_io_verbose & (trace_bit))\
	{ file_id;fprintf(trace_file, str,p0,p1);newline; }
#define	sub_note_trace3(trace_bit,str,p0,p1,p2)	\
	if (sub_io_verbose & (trace_bit))\
	{ file_id;fprintf(trace_file, str,p0,p1,p2);newline; }
#define	sub_note_trace4(trace_bit,str,p0,p1,p2,p3)	\
	if (sub_io_verbose & (trace_bit))\
	{ file_id;fprintf(trace_file, str,p0,p1,p2,p3);newline; }
#define	sub_note_trace5(trace_bit,str,p0,p1,p2,p3,p4) \
	if (sub_io_verbose & (trace_bit))\
	{file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4);newline; }
#define	sub_note_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5) \
	if (sub_io_verbose & (trace_bit))\
	{file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5);newline; }
#define	sub_note_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6) \
	if (sub_io_verbose & (trace_bit))\
	{file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6);newline; }
#define	sub_note_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7) \
	if (sub_io_verbose & (trace_bit))\
	{file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6,p7);newline; }

#define	sure_sub_note_trace0(trace_bit,str)		\
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		 file_id; fprintf(trace_file, str); newline; \
		host_release_timer();\
	}
#define	sure_sub_note_trace1(trace_bit,str,p0)	\
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		 file_id;fprintf(trace_file, str,p0);newline; \
		host_release_timer();\
	}
#define	sure_sub_note_trace2(trace_bit,str,p0,p1)	\
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		 file_id;fprintf(trace_file, str,p0,p1);newline; \
		host_release_timer();\
	}
#define	sure_sub_note_trace3(trace_bit,str,p0,p1,p2)	\
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		 file_id;fprintf(trace_file, str,p0,p1,p2);newline; \
		host_release_timer();\
	}
#define	sure_sub_note_trace4(trace_bit,str,p0,p1,p2,p3)	\
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		 file_id;fprintf(trace_file, str,p0,p1,p2,p3);newline; \
		host_release_timer();\
	}
#define	sure_sub_note_trace5(trace_bit,str,p0,p1,p2,p3,p4) \
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4);newline; \
		host_release_timer();\
	}
#define	sure_sub_note_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5) \
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5);newline; \
		host_release_timer();\
	}
#define	sure_sub_note_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6) \
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6);newline; \
		host_release_timer();\
	}
#define	sure_sub_note_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7) \
	if (sub_io_verbose & (trace_bit))\
	{\
		host_block_timer();\
		file_id;fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6,p7);newline; \
		host_release_timer();\
	}

#define	assert0(test,str)			if (!(test)) { file_id;fprintf(trace_file,str);newline; }
#define	assert1(test,str,p1)			if (!(test)) { file_id;fprintf(trace_file,str,p1);newline; }
#define	assert2(test,str,p1,p2)			if (!(test)) { file_id;fprintf(trace_file,str,p1,p2);newline; }
#define	assert3(test,str,p1,p2,p3)		if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3);newline; }
#define	assert4(test,str,p1,p2,p3,p4)		if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4);newline; }
#define	assert5(test,str,p1,p2,p3,p4,p5)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4,p5);newline; }
#define	assert6(test,str,p1,p2,p3,p4,p5,p6)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4,p5,p6);newline; }
#define	assert7(test,str,p1,p2,p3,p4,p5,p6,p7)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4,p5,p6,p7);newline; }
#define	assert8(test,str,p1,p2,p3,p4,p5,p6,p7,p8)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4,p5,p6,p7,p8);newline; }

#define	assert0_do(test,str,do)			if (!(test)) { file_id;fprintf(trace_file,str);newline;do; }
#define	assert1_do(test,str,p1,do)		if (!(test)) { file_id;fprintf(trace_file,str,p1);newline;do; }
#define	assert2_do(test,str,p1,p2,do)		if (!(test)) { file_id;fprintf(trace_file,str,p1,p2);newline;do; }
#define	assert3_do(test,str,p1,p2,p3,do)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3);newline;do; }
#define	assert4_do(test,str,p1,p2,p3,p4,do)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4);newline;do; }
#define	assert5_do(test,str,p1,p2,p3,p4,p5,do)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4,p5);newline;do; }
#define	assert6_do(test,str,p1,p2,p3,p4,p5,p6,do)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4,p5,p6);newline;do; }
#define	assert7_do(test,str,p1,p2,p3,p4,p5,p6,p7,do)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4,p5,p6,p7);newline;do; }
#define	assert8_do(test,str,p1,p2,p3,p4,p5,p6,p7,p8,do)	if (!(test)) { file_id;fprintf(trace_file,str,p1,p2,p3,p4,p5,p6,p7,p8);newline;do; }

#else /* PROD */

#ifdef HUNTER
#include <stdio.h>
#include "trace.h"
#endif /* HUNTER */

#define	init_debugging()
#define	note_entrance0(str)
#define	note_entrance1(str,p1)
#define	note_entrance2(str,p1,p2)
#define	note_entrance3(str,p1,p2,p3)
#define	note_entrance4(str,p1,p2,p3,p4)
#define note_write_state0(str)
#define note_write_state1(str,p1)
#define note_write_state2(str,p1,p2)
#define note_write_state3(str,p1,p2,p3)
#define	note_display_state0(str)
#define	note_display_state1(str,p1)
#define	note_display_state2(str,p1,p2)
#define	note_display_state3(str,p1,p2,p3)
#define	do_display_trace(str,thing_to_do)
#define	note_trace0(trace_bit,str)
#define	note_trace1(trace_bit,str,p0)
#define	note_trace2(trace_bit,str,p0,p1)
#define	note_trace3(trace_bit,str,p0,p1,p2)
#define	note_trace4(trace_bit,str,p0,p1,p2,p3)
#define	note_trace5(trace_bit,str,p0,p1,p2,p3,p4)
#define	note_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5)
#define	note_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6)
#define	note_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7)
#define	always_trace0(str)
#define	always_trace1(str,p0)
#define	always_trace2(str,p0,p1)
#define	always_trace3(str,p0,p1,p2)
#define	always_trace4(str,p0,p1,p2,p3)
#define	always_trace5(str,p0,p1,p2,p3,p4)
#define	always_trace6(str,p0,p1,p2,p3,p4,p5)
#define	always_trace7(str,p0,p1,p2,p3,p4,p5,p6)
#define	always_trace8(str,p0,p1,p2,p3,p4,p5,p6,p7)
#define	note_trace0_no_nl(trace_bit,str)
#define	note_trace1_no_nl(trace_bit,str,p0)
#define	note_trace2_no_nl(trace_bit,str,p0,p1)
#define	sure_note_trace0(trace_bit,str)
#define	sure_note_trace1(trace_bit,str,p0)
#define	sure_note_trace2(trace_bit,str,p0,p1)
#define	sure_note_trace3(trace_bit,str,p0,p1,p2)
#define	sure_note_trace4(trace_bit,str,p0,p1,p2,p3)
#define	sure_note_trace5(trace_bit,str,p0,p1,p2,p3,p4)
#define	sure_note_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5)
#define	sure_note_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6)
#define	sure_note_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7)
#define	sub_note_trace0(trace_bit,str)
#define	sub_note_trace1(trace_bit,str,p0)
#define	sub_note_trace2(trace_bit,str,p0,p1)
#define	sub_note_trace3(trace_bit,str,p0,p1,p2)
#define	sub_note_trace4(trace_bit,str,p0,p1,p2,p3)
#define	sub_note_trace5(trace_bit,str,p0,p1,p2,p3,p4)
#define	sub_note_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5)
#define	sub_note_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6)
#define	sub_note_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7)
#define	sure_sub_note_trace0(trace_bit,str)
#define	sure_sub_note_trace1(trace_bit,str,p0)
#define	sure_sub_note_trace2(trace_bit,str,p0,p1)
#define	sure_sub_note_trace3(trace_bit,str,p0,p1,p2)
#define	sure_sub_note_trace4(trace_bit,str,p0,p1,p2,p3)
#define	sure_sub_note_trace5(trace_bit,str,p0,p1,p2,p3,p4)
#define	sure_sub_note_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5)
#define	sure_sub_note_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6)
#define	sure_sub_note_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7)

#define	assert0(test,str)
#define	assert1(test,str,p1)
#define	assert2(test,str,p1,p2)
#define	assert3(test,str,p1,p2,p3)
#define	assert4(test,str,p1,p2,p3,p4)
#define	assert5(test,str,p1,p2,p3,p4,p5)
#define	assert6(test,str,p1,p2,p3,p4,p5,p6)
#define	assert7(test,str,p1,p2,p3,p4,p5,p6,p7)
#define	assert8(test,str,p1,p2,p3,p4,p5,p6,p7,p8)

#define	assert0_do(test,str,do)
#define	assert1_do(test,str,p1,do)
#define	assert2_do(test,str,p1,p2,do)
#define	assert3_do(test,str,p1,p2,p3,do)
#define	assert4_do(test,str,p1,p2,p3,p4,do)
#define	assert5_do(test,str,p1,p2,p3,p4,p5,do)
#define	assert6_do(test,str,p1,p2,p3,p4,p5,p6,do)
#define	assert7_do(test,str,p1,p2,p3,p4,p5,p6,p7,do)
#define	assert8_do(test,str,p1,p2,p3,p4,p5,p6,p7,p8,do)

#endif /* PROD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\cpu4.h ===
/*
 * SoftPC Revision 3.0
 *
 * Title	: Definitions for the 80386 CPU 
 *
 * Description	: Structures, macros and definitions for access to the 
 *		  CPU registers
 *
 * Author	: Wayne Plummer
 *
 * Derived From : cpu.h
 *
 * Notes	: This file should be portable - but includes a file
 *		  host_cpu.h which contains machine specific definitions
 *		  of CPU register mappings etc.
 *
 * SccsID	: @(#)cpu4.h	1.12 10/21/94
 *
 *	(c)Copyright Insignia Solutions Ltd., 1991-1994. All rights reserved.
 */

#include "host_cpu.h"

IMPORT VOID host_set_hw_int IPT0();
IMPORT VOID host_clear_hw_int IPT0();


/*
 *	Host functions to be provided for the base to use with respect to the CPU.
 *	These must be done in host_cpu.h because some hosts may want functions and
 *	others may want #defines.
 */

/*
 *	This macro specifies the maximum recursion depth the CPU is required to support.
 *	(Note that a particular host may not actually use this value if it is capable
 *	of supporting abirtarily deep recursion).
 */
#define CPU_MAX_RECURSION	32

/*
 *	Interrupt types...
 */

#include <CpuInt_c.h>
typedef enum CPU_INT_TYPE CPU_INT_TYPE;

#ifdef CPU_PRIVATE
/*
   Function returns for private i/f procedures handling segment loading.
 */

#define GP_ERROR    13
#define NP_ERROR    11
#define SF_ERROR    12
#endif /* CPU_PRIVATE */

/*
 * Include the main part of the cpu interface, which at present is generated
 */
#include	<cpu4gen.h>

IMPORT void		cpuEnableInterrupts IPT1(IBOOL, yes_or_no);

#ifdef IRET_HOOKS
#ifdef CCPU
IMPORT   VOID c_Cpu_set_hook_selector  IPT1(IU16, selector);
#define  Cpu_set_hook_selector         c_Cpu_set_hook_selector
#else
IMPORT   VOID a3_Cpu_set_hook_selector IPT1(IU16, selector);
#define  Cpu_set_hook_selector         a3_Cpu_set_hook_selector
#endif
#endif /* IRET_HOOKS */

/*
 * These functions get the (E)IP or (E)SP correctly whatever size stack
 * or code segment is in use.  For anything but GISP, we always hold
 * the IP as a 32 bit quantity, so we don't have to worry about the
 * distinction.
 */

#ifdef GISP_CPU
extern IU32 GetInstructionPointer IPT0();
#else
#define GetInstructionPointer getEIP
#endif
extern IU32 GetStackPointer IPT0();


#ifdef IRET_HOOKS
/*
 * The interfaces provided by the CPU so that the ICA can initiate and
 * terminate an iret hook.
 */

extern void Cpu_do_hook IPT2(IUM8, line, IBOOL, is_hooked);
extern void Cpu_inter_hook_processing IPT1(IUM8, line);
extern void Cpu_unhook IPT1(IUM8, line_number);
#ifdef GISP_CPU
extern void Cpu_set_hook_selector IPT1(IU16, selector);
extern void Cpu_hook_bop IPT0();
#endif

#endif /* IRET_HOOKS */

/*
 * This function lets ios.c determine whether it is OK for it to go
 * ahead and do an in or out instruction, or whether the CPU wants to take
 * it over instead.
 */

/* However, it is sometimes defined as a macro */

#if !defined(CCPU) && !defined(PROD)
extern IBOOL IOVirtualised IPT4(io_addr, io_address, IU32 *, value, LIN_ADDR, offset, IU8, width);
#endif

#ifndef CCPU
/*
 * Npx functions:
 */
#ifndef PROD
GLOBAL IU32 a_getNpxControlReg	IPT0();
GLOBAL IU32 a_getNpxStatusReg	IPT0();
GLOBAL IU32 a_getNpxTagwordReg	IPT0();
GLOBAL char *a_getNpxStackReg	IPT2(IU32, reg_num, char *, buffer);
#endif /* PROD */

#ifdef PIG
GLOBAL void a_setNpxControlReg	IPT1(IU32, newControl);
GLOBAL void a_setNpxStatusReg	IPT1(IU32, newStatus);
#endif /* PIG */
#endif /* !CCPU */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\decode.h ===
/* 
   decode.h

   Define all data types and functions supported by the Intel
   instruction decoder.
 */

/*
   static char SccsID[]="@(#)decode.h	1.5 08/25/94 Copyright Insignia Solutions Ltd.";
 */

#ifndef	_DECODE_H_
#define	_DECODE_H_

typedef struct
   {
   UTINY  arg_type;        /* Decoded operand type. */
   USHORT identifier;      /* Identifier within a specific type */
   UTINY  sub_id;          /* Sub-identifier */
   UTINY  addressability;  /* How the operand is addressed */
   ULONG  arg_values[2];   /* Specific values for operand. */
   } DECODED_ARG;

typedef struct
   {
   UTINY operand_size;       /* Operand size for inst. */
   UTINY address_size;       /* Address size for inst. */
   UTINY prefix_sz;          /* Nr. of prefix bytes (maybe 0).             */
   UTINY inst_sz;            /* Nr. bytes in inst. (includes prefix bytes) */
   USHORT inst_id;           /* Decoded instruction identifier.            */
   DECODED_ARG args[3];      /* Three operands arg1, arg2, arg3 are        */
			     /* allowed.                                   */
   } DECODED_INST;

/*
   The allowable types of address size.
 */
#define ADDR_16		(UTINY)0
#define ADDR_32		(UTINY)1

/*
   The allowable types of operand size.
 */
#define OP_16 (UTINY)0
#define OP_32 (UTINY)1


#ifdef ANSI
typedef IS32 (*read_byte_proc) (LIN_ADDR);
#else
typedef IS32 (*read_byte_proc) ();
#endif

extern void decode IPT4(
	LIN_ADDR, p,
	DECODED_INST *, d_inst,
	SIZE_SPECIFIER, default_size,
	read_byte_proc, func		
);
#endif	/* _DECODE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\disk_geo.h ===
/*[
 *	Name:		disk_geom.h
 *
 *	Derived From:	n/a
 *
 *	Author:		Dave Howell.
 *
 *	Created:	September 1992.
 *
 * 	Sccs ID:        @(#)disk_geom.h	1.1 01/12/93
 *
 *	Purpose:	This header is the interface to disk_geom.c, and provides
 *				definitions of some disk geometry constants.
 *
 *	Interface:	n/a
 *
 *	(c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
 *
]*/

/*
 *	Interface to disk_geom.c
 */

IMPORT BOOL do_geom_validation IPT4 (	unsigned long,   	dos_size,
										SHORT *, 			nCylinders,
										UTINY *, 			nHeads,
										UTINY *, 			nSectors);

/*
 *	Some manifest constants used in disk calculations.
 */

#define	ONEMEG					1024 * 1024
#define HD_MAX_DISKALLOCUN			32
#define HD_SECTORS_PER_TRACK	 		17
#define HD_HEADS_PER_DRIVE	  		4
#define HD_BYTES_PER_SECTOR	  		512
#define HD_SECTORS_PER_CYL (HD_HEADS_PER_DRIVE * HD_SECTORS_PER_TRACK)
#define HD_BYTES_PER_CYL   (HD_BYTES_PER_SECTOR * HD_SECTORS_PER_CYL)
#define HD_DISKALLOCUNSIZE (HD_BYTES_PER_CYL * 30)
#define SECTORS 0x0c		/* offset in buffer for sectors in partition
				 * marker */
#define MAX_PARTITIONS  5
#define START_PARTITION 0x1be
#define SIZE_PARTITION  16
#define SIGNATURE_LEN   2

#define checkbaddrive(d)	if ( (d) != 0 && (d) != 1) host_error(EG_OWNUP,ERR_QUIT,"illegal driveid (host_fdisk)");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\dpmi.h ===
/*
 * SoftPC AT Revision 2.0
 *
 * Title        : DPMI host definitions
 *
 * Description  : Definitions for the DPMI TSR host
 *
 * Author       : WTG Charnell
 *
 * Notes        : None
 */



/* SccsID[]="@(#)dpmi.h	1.1 08/06/93 Copyright Insignia Solutions Ltd."; */

#define LDT_INCR        8
#define LDT_DESC_MASK   7       /* LDT desc , prot level 3 */
#define LDT_SHIFT       3
#define LDT_ALLOC_LIMIT	0x1fff	/* max avail LDT selectors */
#define	MIN_EMM_BLOCK	0x14000	/* amount of EMM needed by TSR */
#define MEM_HANDLE_BLOCK_SIZE	0x100	/* DPMI mem handles are obtained in blocks of this size */
#define CALL_INST_SIZE	7	/* 32 bit far call = 7 bytes */
#define PUSH_JMP_SIZE	8	/* PUSH word then far jmp = 8 bytes */
#define STACKLET_SIZE	192	/* safe size according to DOSX */
#define MAX_WP_HANDLE	4	/* maximnum active watchpoints (386 dbg regs) */

#define INIT_R0_SP	0x7e
#define INIT_LOCKED_SP	0xffe
#define RM_SEG_SIZE	0x900
#define NUM_CALLBACKS	32
#define METASTACK_LIMIT	20

#define	DPMI_FN_VERB	0x1
#define	DPMI_MDSW_VERB	0x2
#define	DPMI_INT_VERB	0x4
#define	DPMI_GEN_VERB	0x8
#define DPMI_STACK_VERB	0x10
#define DPMI_ERROR_VERB	0x20


typedef struct
{
	BOOL allocated;
	BOOL rm_seg;
} LDT_alloct;

typedef struct mem_alloc
{
	IU32 base_addr;
	IU32 size;
	IU32 handle;
	IU16 selector;
	struct mem_alloc *next;
} mem_alloct;

typedef struct 
{
	IU16 segment;
	IU32 offset;
} DPMI_intvect;

typedef struct
{
        IU16	CS;
        IU16	DS;
        IU16	ES;
        IU16	SS;
        IU32	SP;
        IU32	IP;
	IU32	DI;
	IU32	SI;
	IU32	BP;
	IU32	AX;
	IU32	BX;
	IU32	CX;
	IU32	DX;
	IU32	Flags;
	BOOL	wrapping;
	BOOL	already_iretted;
} DPMI_saved_state;

typedef struct
{
	DPMI_intvect rm_vec;
	DPMI_intvect rm_call_struct;
	DPMI_intvect pm_routine;
	IU16 rm_stack_alias;
	BOOL used;
} DPMI_callbackt;

typedef struct
{
	DPMI_intvect wp_addr;
	IU8	wp_size;
	IU8	wp_type;
	IU8	reg;
	BOOL	wp_hit;
	BOOL	used;
} DPMI_debugwpt;

typedef struct
{
	IU32	DCR;
	IU32	DSR;
	IU32	DR[5];
} debug_regt;

extern IU16 allocate_one_desc IPT0();

extern VOID setup_LDT_desc IPT4( IU16, selector, IU32, base, IU32, limit, 
			IU16, access_rights);

extern VOID DPMI_exc_ret IPT0();

extern VOID push_rm_sp IPT1(IU16, spval);

extern VOID pop_rm_sp IPT0();

extern IU16 get_next_rm_sp IPT0();

extern VOID free_rm_sp_entry IPT0();

extern VOID push_locked_sp IPT1(IU16, spval);

extern VOID pop_locked_sp IPT0();

extern IU16 get_next_locked_sp IPT0();

extern VOID free_locked_sp_entry IPT0();

extern VOID Reserve_one_desc IPT1(IU16, sel);

extern VOID dpmi_trace IPT9(IU32, mask, char*, str, char*, p1,
        char *, p2, char *, p3, char *, p4, char *, p5, char *, p6,
        char *, p7);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\dma.h ===
/*
 * SoftPC-AT Revision 2.0
 *
 * Title	: IBM PC-AT DMA Adaptor declarations
 *
 * Description	: This module contains declarations that are used in
 *		  accessing the DMA Adaptor emulation
 *
 * Author(s)	: Ross Beresford
 *
 * Notes	: For a detailed description of the IBM DMA Adaptor,
 *		  and the INTEL DMA Controller chips refer to the following 
 *		  documents:
 *
 *		  - IBM PC/AT Technical Reference Manual
 *				(Section 1-9 Direct Memory Access)
 *		  - INTEL Microsystems Components Handbook
 *				(Section 2-52 DMA Controller 8237A)
 *
 *		  A more succinct account of the DMA adaptor follows:
 *

 * DMA Adaptor:
 * -----------
 *
 * The DMA "adaptor" is really just a part of the AT System Board. This
 * is its block diagram:
 *
 *                +-----------+                                             
 *        000-01F |8237A-5 | 0|                                 A0-A7       
 * IOS <-+------> |  DMA   | 1| -------------------------------------+      
 *       |        | CNTRL  | 2|      +-------+                       |      
 *       |        |   0    | 3| ---> |ALS 573|                 A8-A15|      
 *       |        +-----------+      |  DMA  | ----------------------+      
 *       |           ^               |ADDRESS|                       |      
 *       |            \              | LATCH |      +-------+        |      
 *       |             \ cascade     +-------+      | LS612 |        |      
 *       |080-09F       \                           |       | A16-A23|      
 *       +----------------------------------------> |  DMA  | -------+      
 *       |                \                         |  PAGE | A17-A23|      
 *       |        +-----------+                     |  REG  |        |      
 *       |        |8237A-5 | 4|                     +-------+        |      
 *       +------> |  DMA   | 5| -------------------------------------+      
 *        0C0-0DF | CNTRL  | 6|      +-------+                 A9-A16|      
 *                |   1    | 7| ---> |ALS 573|                       |      
 *                +-----------+      |  DMA  | ----------------------+-> SAS
 *                                   |ADDRESS|                  A1-A8       
 *                                   | LATCH |                              
 *                                   +-------+                              

 * DMA Controllers:
 * ---------------
 *
 * The 8237A-5 DMA controller chips used are restricted to 4 DMA
 * channels each: thus, 2 DMA controller chips are required to give the
 * AT's 7 DMA channels.
 *
 * The 8237A-5 DMA controller chips support more than one device by
 * "cascading" them: that is, connecting the control inputs of the
 * "additional" device to the control outputs of the "initial" device.
 * One channel in the initial device must be dedicated to serving
 * each additional device by setting it to "cascade mode".
 *
 * On the AT system board, channel 4 of DMA Controller 1 is set to
 * "cascade mode", and serves DMA Controller 0.
 *
 * Channels 0-3 (on DMA Controller 0) are used to support 8-bit I/O
 * devices and provide transfers of up to 64K bytes: the 16-bit addresses
 * generated by the DMA Controller are mapped directly onto bits A0-A15
 * of a 24 bit system address.
 *
 * Channels 5-7 (on DMA Controller 1) are used to support 16-bit I/O
 * devices and provide transfers of up to 128K bytes: the 16-bit addresses
 * generated by the DMA Controller are mapped onto bits A1-A16 of a
 * 24 bit system address, and bit A0 is set to 0.
 *
 * The state of a controller is defined by a set of internal registers
 * and a flip-flop: the internal registers are used in setting up and
 * performing a DMA transfer; the First/Last Flip-Flop controls which
 * byte of a 16 bit address is accessed from the I/O bus.
 *
 * The state information for a controller is represented by a DMA_CNTRL
 * object.

 * DMA Address Latches:
 * -------------------
 *
 * Each DMA Controller has an ALS573 DMA Address Latch associated with
 * it. These are required because of a restriction in the design of the
 * DMA Controller: in order to reduce its pin count it does not directly
 * output bits A8-A15 onto the address bus, but uses an external latch.
 * 
 * Since the address latches do not have any separate functional
 * identity, their state and behaviour is included in with the
 * controllers.

 * DMA Page Registers:
 * ------------------
 *
 * An LS612 DMA Page Register chip is used to establish the constant top
 * bits of the system address for a DMA transfer; each DMA channel has a
 * byte register in the chip for this purpose.
 * 
 * In DMA channels 0-3, bits A16-A23 of the 24 bit system address are
 * established from bits D0-D7 of the page register for the channel.
 * 
 * In DMA channels 5-7, bits A17-A23 of the 24 bit system address are
 * established from bits D1-D7 of the page register for the channel:
 * Bit D0 is not used for these channels, since bit A16 of the system
 * address is established by the DMA controller for these channels.
 *
 * The state information for the page register chip is represented
 * by a DMA_PAGE object.
 */ 

/* SccsID[]="@(#)dma.h	1.7 11/10/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * DMA CONTROLLER
 */

/* the number of channels per controller */
#define	DMA_CONTROLLER_CHANNELS	4

/* a flip-flop; it toggles between the values 0 and 1 */
typedef	unsigned int	DMA_FLIP_FLOP;

/* a DMA address; it is indexed by the flip-flop value */
typedef	half_word	DMA_WORD[2];

/* a DMA command */
#ifdef BIT_ORDER1
typedef union
{
	half_word all;
	struct
	{
		 HALF_WORD_BIT_FIELD DACK_high:1;       /* not supported */
		 HALF_WORD_BIT_FIELD DREQ_high:1;	/* not supported */
		 HALF_WORD_BIT_FIELD extended_write:1;  /* not supported */
		 HALF_WORD_BIT_FIELD rotate_priority:1;	  
		 HALF_WORD_BIT_FIELD compressed_timing:1;/* not supported */
		 HALF_WORD_BIT_FIELD controller_disable:1;
		 HALF_WORD_BIT_FIELD ch0_address_hold:1;/* not supported */
		 HALF_WORD_BIT_FIELD mm_enable:1;       /* not supported */
       } bits;
} DMA_COMMAND;
#endif
#ifdef BIT_ORDER2
typedef union
{
 	half_word all;
	struct
	{
		 HALF_WORD_BIT_FIELD mm_enable:1;       /* not supported */
		 HALF_WORD_BIT_FIELD ch0_address_hold:1;/* not supported */
		 HALF_WORD_BIT_FIELD controller_disable:1;
		 HALF_WORD_BIT_FIELD compressed_timing:1; /* not supported */
		 HALF_WORD_BIT_FIELD rotate_priority:1;	  
		 HALF_WORD_BIT_FIELD extended_write:1;  /* not supported */
		 HALF_WORD_BIT_FIELD DREQ_high:1;       /* not supported */
		 HALF_WORD_BIT_FIELD DACK_high:1;	/* not supported */
	} bits;
} DMA_COMMAND;
#endif

/* a DMA mode */
#ifdef BIT_ORDER1
typedef union
{
 	half_word all;
	struct
	{
		 HALF_WORD_BIT_FIELD mode:2;	    /* single/block/demand/cascade */
		 HALF_WORD_BIT_FIELD address_dec:1; /* inc or dec count  */
		 HALF_WORD_BIT_FIELD auto_init:1;   /* autoinitialize ?  */
		 HALF_WORD_BIT_FIELD transfer_type:2; /* read/write/verify */
		 HALF_WORD_BIT_FIELD scratch:2;     /* channel select mapped here */
       } bits;
} DMA_MODE;
#endif
#ifdef BIT_ORDER2
typedef union
{
 	half_word all;
	struct
	{
		 HALF_WORD_BIT_FIELD scratch:2;     /* channel select mapped here */
		 HALF_WORD_BIT_FIELD transfer_type:2; /* read/write/verify */
		 HALF_WORD_BIT_FIELD auto_init:1;   /* autoinitialize ?  */
		 HALF_WORD_BIT_FIELD address_dec:1; /* inc or dec count  */
		 HALF_WORD_BIT_FIELD mode:2;	    /* single/block/demand/cascade */
       } bits;
} DMA_MODE;
#endif

#if defined(NEC_98)

#ifdef BIT_ORDER1
typedef union
{
        half_word all;
        struct
        {
                HALF_WORD_BIT_FIELD reserve:4;
                HALF_WORD_BIT_FIELD incrementmode:2;
                HALF_WORD_BIT_FIELD scratch:2;
        } bits;
} DMA_BANK_MODE;
#endif

#ifdef BIT_ORDER2
typedef union
{
        half_word all;
        struct
        {
                HALF_WORD_BIT_FIELD scratch:2;
                HALF_WORD_BIT_FIELD incrementmode:2;
                HALF_WORD_BIT_FIELD reserve:4;
        } bits;
} DMA_BANK_MODE;
#endif

#define DMA_64K_MODE            0
#define DMA_1M_MODE             1
#define DMA_16M_MODE            3

#endif // NEC_98

/* DMA Mode register mode bit settings */
#define DMA_DEMAND_MODE		0
#define DMA_SINGLE_MODE		1
#define DMA_BLOCK_MODE		2
#define DMA_CASCADE_MODE	3

/* DMA Mode register transfer type bit settings */
#define DMA_VERIFY_TRANSFER	0
#define DMA_WRITE_TRANSFER	1
#define DMA_READ_TRANSFER	2
#define DMA_ILLEGAL_TRANSFER	3

/* a DMA status */
#ifdef BIT_ORDER1
typedef union
{
	half_word all;
	struct
	{
		HALF_WORD_BIT_FIELD request:4;		/* request pending   */
		HALF_WORD_BIT_FIELD terminal_count:4;	/* terminal count reached */
	} bits;
} DMA_STATUS;
#endif
#ifdef BIT_ORDER2
typedef union
{
	half_word all;
	struct {
		HALF_WORD_BIT_FIELD terminal_count:4;	/* terminal count reached */
		HALF_WORD_BIT_FIELD request:4;		/* request pending   */
	} bits;
} DMA_STATUS;
#endif

/* a DMA mask register (only the bottom 4 bits are meaningful) */
typedef	half_word	DMA_MASK;

/* a DMA Controller state */
typedef struct
{
	DMA_WORD	base_address[DMA_CONTROLLER_CHANNELS];
	DMA_WORD	base_count[DMA_CONTROLLER_CHANNELS];
	DMA_WORD	current_address[DMA_CONTROLLER_CHANNELS];
	DMA_WORD	current_count[DMA_CONTROLLER_CHANNELS];
	DMA_WORD	temporary_address[DMA_CONTROLLER_CHANNELS];
	DMA_WORD	temporary_count[DMA_CONTROLLER_CHANNELS];
	DMA_STATUS	status;
	DMA_COMMAND	command;
	half_word	temporary;
	DMA_MODE	mode[DMA_CONTROLLER_CHANNELS];
	DMA_MASK	mask;
	half_word	request;
	DMA_FLIP_FLOP	first_last;
#if defined(NEC_98)
        DMA_BANK_MODE   bank_mode[DMA_CONTROLLER_CHANNELS];
#endif // NEC_98
} DMA_CNTRL;

/*
 * DMA PAGE REGISTERS
 */

/* the number of channels per page register chip */
#define	DMA_PAGE_CHANNELS	16

/* a DMA Page Register chip state */
typedef	struct
{
	half_word	page[DMA_PAGE_CHANNELS];
} DMA_PAGE;

/*
 * DMA ADAPTOR
 */

/* the number of controllers per adaptor */
#if defined(NEC_98)
#define DMA_ADAPTOR_CONTROLLERS 1
#else  // !NEC_98
#define	DMA_ADAPTOR_CONTROLLERS	2
#endif // !NEC_98

/* the numbering convention for the controllers */
#define	DMA_CONTROLLER	0
#define	DMA1_CONTROLLER	1

/* a DMA adaptor state */
typedef	struct
{
	DMA_CNTRL	controller[DMA_ADAPTOR_CONTROLLERS];
	DMA_PAGE	pages;
} DMA_ADAPT;

/* the number of logical channels per adaptor */
#define	DMA_ADAPTOR_CHANNELS	\
	(DMA_ADAPTOR_CONTROLLERS * DMA_CONTROLLER_CHANNELS)

/* macros for converting between logical and physical channel numbers */
#define	dma_logical_channel(controller, channel)	\
		(controller*DMA_CONTROLLER_CHANNELS + channel)
#define	dma_physical_channel(channel)	\
		(channel%DMA_CONTROLLER_CHANNELS)
#define	dma_physical_controller(channel)	\
		(channel/DMA_CONTROLLER_CHANNELS)

/* macro for building a system address dependent on the channel */
#define	dma_system_address(channel, page, offset) \
	( (channel < 4) \
	? (((sys_addr)(page & 0xff) << 16) | ((sys_addr)(offset & 0xffff) << 0)) \
	: (((sys_addr)(page & 0xfe) << 16) | ((sys_addr)(offset & 0xffff) << 1)) )

/* macro for determining the DMA unit size dependent on the channel */
#define	dma_unit_size(channel) ( (channel < 4) ? 1 : 2)

/* the channel assignments */
#define	DMA_RESERVED_CHANNEL_0	0
#if defined(NEC_98)
#define DMA_RESERVED_CHANNEL_1  1
#define DMA_RESERVED_CHANNEL_2  2
#define DMA_RESERVED_CHANNEL_3  3
#define DMA_DISKETTE_CHANNEL    2
#else  // !NEC_98
#define	DMA_SDLC_CHANNEL	1
#define	DMA_DISKETTE_CHANNEL	2
#define	DMA_DISK_CHANNEL	3
#define	DMA_CASCADE_CHANNEL	4
#define	DMA_RESERVED_CHANNEL_5	5
#define	DMA_RESERVED_CHANNEL_6	6
#define	DMA_RESERVED_CHANNEL_7	7
#define DMA_FAKE_CHANNEL_1	8
#define DMA_FAKE_CHANNEL_2	9
#define DMA_FAKE_CHANNEL_3	10
#define DMA_FAKE_CHANNEL_4	11
#define DMA_FAKE_CHANNEL_5	12
#define DMA_FAKE_CHANNEL_6	13
#define DMA_FAKE_CHANNEL_7	14
#define DMA_REFRESH_CHANNEL	15
#endif  // !NEC_98

/* these masks define the redundant bits of the I/O addresses */
#define	DMA_REDUNDANT_BITS	0x10
#define	DMA1_REDUNDANT_BITS	0x01
#define	DMA_PAGE_REDUNDANT_BITS	0x10

/*
 * DMA Address - the following union is used only in the BIOS functions
 * to help determine how a system address should be expressed in terms
 * of its component parts.
 * It is not used within the DMA emulation
 */
#ifdef BIGEND
typedef union
{
	sys_addr all;
	half_word array[4];
	struct
	{
		half_word pad;
		half_word page;
		half_word high;
		half_word low;
	} parts;
	struct
	{
		word high;
		word low;
	} words;
} DMA_ADDRESS;
#endif
#ifdef LITTLEND
typedef union
{
	sys_addr all;
	half_word array[4];
	struct
	{
		half_word low;
		half_word high;
		half_word page;
		half_word pad;
	} parts;
	struct
	{
		word low;
		word high;
	} words;
} DMA_ADDRESS;
#endif

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

/*
 *	void dma_init()
 *	{
 *		This function performs several distinct initialisation
 *		tasks associated with the DMA adaptor:
 *
 *		the DMA Controller chips and the DMA Page Register chip
 *		are connected to the I/O bus;
 *
 *		a hardware reset is performed for each DMA Controller
 *		chip;
 *	}
 */
IMPORT VOID dma_init IPT0();

/*
 *	void dma_post()
 *	{
 *		the mode register for each DMA channel is set up to the
 *		normal value for an AT.
 *	}
 */
IMPORT VOID dma_post IPT0();

/*
 *	void dma_inb(port, value)
 *	io_addr port;
 *	half_word *value;
 *	{
 *		This function is invoked when a read is performed on an
 *		I/O address "port" in the range of one of the DMA
 *		Controller chips. dma_inb() may also be called directly
 *		from the BIOS.
 *
 *		The function maps the I/O address to the particular DMA
 *		controller and returns the value of the requested
 *		register in "*value".
 *	}
 */
IMPORT VOID dma_inb IPT2(io_addr, port, half_word *, value);

/*
 *	void dma_outb(port, value)
 *	io_addr port;
 *	half_word value;
 *	{
 *		This function is invoked when a write is performed to an
 *		I/O address "port" in the range of one of the DMA
 *		Controller chips. dma_outb() may also be called directly
 *		from the BIOS.
 *
 *		The function maps the I/O address to the particular DMA
 *		controller and sets the requested register to "value".
 *	}
 */
IMPORT VOID dma_outb IPT2(io_addr, port, half_word, value);

/*
 *	void dma_page_inb(port, value)
 *	io_addr port;
 *	half_word *value;
 *	{
 *		This function is invoked when a read is performed on an
 *		I/O address "port" in the range of the DMA Page Register
 *		chip. dma_page_inb() may also be called directly from the
 *		BIOS.
 *
 *		The function maps the I/O address to a particular DMA
 *		page register and returns its value in "*value".
 *	}
 */
IMPORT VOID dma_page_inb IPT2(io_addr, port, half_word *, value);

/*
 *	void dma_page_outb(port, value)
 *	io_addr port;
 *	half_word value;
 *	{
 *		This function is invoked when a write is performed to an
 *		I/O address "port" in the range of the DMA Page Register
 *		chip. dma_page_outb() may also be called directly from the
 *		BIOS.
 *
 *		The function maps the I/O address to a particular DMA
 *		page register and sets it to "value".
 *	}
 */
IMPORT VOID dma_page_outb IPT2(io_addr, port, half_word, value);

/*
 *	dma_request(channel, hw_buffer, length)
 *	half_word channel;
 *	char *hw_buffer;
 *	word length;
 *	{
 *		I/O devices call this function to initiate a DMA
 *		transfer. It is analogous to raising the DREQ line
 *		on the DMA controller for the channel.
 *
 *		The DMA channel to be used is passed in "channel";
 *		"hw_buffer" is the address in the device's memory
 *		space of the buffer that should be read from or written
 *		into the system address space; "length" is the maximum
 *		number of units to be transferred: the unit is a
 *		half_word for channels 0-3 and a word for channels 5-7.
 *
 *		The function returns TRUE if more transfers can be
 *		accepted or FALSE if the terminal count has been
 *		reached.
 *	}
 */
IMPORT int dma_request IPT3(half_word, port, char *, hw_buffer, word, length);

/*
 *	void dma_enquire(channel, address, length)
 *	half_word channel;
 *	sys_addr *address;
 *	word *length;
 *	{
 *		I/O devices call this function to find out how the
 *		DMA controller has been programmed up to do a transfer.
 *
 *		The DMA channel to be accessed is passed in "channel";
 *		the address in system address space that will be read
 *		or written in the transfer is returned in "*address";
 *		"length" is the number of units that have been
 *		requested: the unit is a half_word for channels 0-3
 *		and a word for channels 5-7.
 *	}
 */
IMPORT VOID dma_enquire IPT3(half_word, channel, sys_addr *, address, word *, length);

#ifdef NTVDM
/*
 * BOOL dmaGetAdaptor
 *
 * Used by MS for third party Vdds to retrieve current DMA settings
 *
 * entry: void
 * exit : DMA_ADAPT * , pointer to the DMA_ADAPT structure
 *
 */
DMA_ADAPT *dmaGetAdaptor();
#endif	/* NTVDM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\dfa.h ===
/*[
 *      Name:		dfa.h
 *
 *      Derived From:	DEC 3.0 dfa.gi and pk_dfa.gi
 *
 *      Author:         Justin Koprowski
 *
 *      Created On:	18th February 1992
 *
 *      Sccs ID:        @(#)dfa.h	1.5 01/29/93
 *
 *      Purpose:	DFA definitions
 *
 *      (c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
]*/

/* DFA global functions */

IMPORT VOID dfa_run IPT1(USHORT, isymb);
IMPORT LONG dfa_load IPT2(CHAR *, file, LONG *, err);
IMPORT VOID dfa_init IPT0();

/* 
 * mapping to use for displaying IBM extended
 * ASCII char.
 */

typedef struct {
	SHORT	hostval;/* host character to use */
	SHORT 	cset;	/* host character set to use */
} gmap_;

/* 
 * this gets initialised from the compiled
 * description file (see dfa_build() in dfa.c)
 * as does dispcap below
 */

IMPORT gmap_ dfa_glist[256];

#define NALTCHARSETS 6+1	/* 6 alt.+base */

typedef struct {
	CHAR *spcon;		/* terminal start up string */	
	CHAR *spcoff;		/* terminal shutdown string */
	CHAR *shiftin;		/* activate base char set */
	CHAR *shiftout;		/* activate selected alt.char set */
	CHAR *alt[NALTCHARSETS]; /* select alt.char sets */
	CHAR *ctldisp;		/* display control codes */
	CHAR *ctlact;		/* interpret control codes */
} dispcap_;

IMPORT dispcap_ dispcap;

#define DFA_NOFILE	1
#define DFA_BADFILE	2
#define DFA_NOMEM	3


/* 
 * define structure of keyboard input machine header
 * as found at front of its definition file
 */

#define DFA_MAGIC	0x01d1

typedef struct {
	SHORT	magic;			/* some daft signature			*/
	SHORT	startstateid;		/* the starting DFA state		*/
	SHORT	nDFAstates;		/* number of deterministic states	*/
	SHORT   nalphabet;		/* number of symbols in input alphabet  */
	SHORT	n_in_tlist;		/* size of transition list block	*/
	SHORT	n_in_alist;		/* size of acceptance actions block	*/
	SHORT	nindices;		/* #.capability strings for display */
	SHORT	sizeofcapstrings;	/* #.bytes for all cap.strings */
} machineHdr_, *machineHdrPtr_;


/* 
 * pseudocodes for semantic actions on machine accepting
 * an input string
 */

#define SEM_SELECTINTERP        0
#define SEM_LOCK        	1
#define SEM_LOCK1       	2
#define SEM_UNLK        	3
#define SEM_UNLK1       	4
#define SEM_UNLK2       	5
#define SEM_TOGLOCK        	6
#define SEM_TOGLOCK1       	7
#define SEM_TOGLOCK2       	8
#define SEM_SWITCH      	9
#define SEM_KYHOT       	10
#define SEM_KYHOT2      	11
#define SEM_REFRESH     	12
#define SEM_UNPUT     		13
#define SEM_ALOCK1       	14
#define SEM_ASPC       		15
#define SEM_EXIT       		16
#define SEM_KYHOT3      	17
#define SEM_FLATOG              18
#define SEM_FLBTOG              19
#define SEM_SLVTOG              20
#define SEM_COMTOG              21
#define SEM_EDSPC               22
#define SEM_LSTSET              23

/* 
 * indicate how transition list is packed for a given DFA state
 * Indexed is an array of next state id's, indexed by the input
 * symbol.
 * Unindexed is an array of (state id, input symbol) pairs which
 * are searched for match on input symbol.
 */

#define PINDEXED        	1
#define PUNINDEXED      	2

/* 
 * indicate the importance of a given DFA state.
 * upon reaching an ENDSTATE, can undertake the semantic actions
 * provided there are no further transitions from this state.
 * if there are, then must wait to see what next input symbol is.
 * If this doesn't match, we can definitely undertake these actions
 */

#define STARTSTATE      1
#define ENDSTATE        2
#define INTERMEDIATE    0
#define ILLEGAL		0xffff

#define	WILDC		0x101
 
typedef struct {
        UTINY attrib;   	/* state attribute (start, end etc.) 	*/
        UTINY howpacked; 	/* INDEXED or UNINDEXED 		*/
        SHORT ntrans;           /* #.members of transition list 	*/
        ULONG nextstates;	/* offset within packed trans.list area */
                                /* to start of this list 		*/
        ULONG actions; 		/* offset into action list area for	*/
                                /* actions for this state (if acceptor) */
} packedDFA_, *packedDFAPtr_;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\dterm.h ===
/*[
	Name:		DTerm.h
	Derived From:	Unknown
	Author:		Paul Murray
	Created On:	July 1990
	Sccs ID:	08/10/92 @(#)DTerm.h	1.6
	Purpose:	MACROS, labels etc. used in the Dumb Terminal

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

#define TBUFSIZ 20480
#define HIWATER TBUFSIZ - 400

#define PC_DISPLAY_WIDTH        80
#define PC_DISPLAY_HEIGHT       25
#define PC_DISPLAY_HPELS        8
#define PC_DISPLAY_VPELS        16
#define MAX_DIRTY_COUNT         8001          /* Max number of dirty bits  */

#define ERH_DUMBTERM 0
#define DT_NORMAL 0
#define DT_ERROR 1
#define DT_SCROLL_UP 0
#define DT_SCROLL_DOWN 1
#define DT_CURSOR_OFF 0
#define DT_CURSOR_ON 1
#define CURSOR_MODE_BASE 0

#ifndef EHS_MSG_LEN
#define EHS_MSG_LEN 1024
#endif

#define DT_NLS_KEY_SIZE		80	/* Size of strings for key compares */

#define EMIT    1
#define BUFFER  0
#define ROWS1_24        124     /* default dumb term rows displayed (for 24 line
 screen) */
#define ROWS0_23        23      /* display rows 0 - 23 instead  */

#define SCREEN_WIDTH 639
#define SCREEN_HEIGHT 199
#define TEXT_LINE_HEIGHT 8
#define BLACK_BACKGROUND 0


#define PC_CURSOR_BAD_ROW -1
#define PC_CURSOR_BAD_COL -1

#define TICKS_PER_FLUSH 3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\dsktrace.h ===
/* SccsId = @(#)dsktrace.h	1.9 04/12/95 */
/*
 * dsktrace.h
 *
 *	Jerry Kramskoy
 *	(reworked due to CI by Ade Brownlow )
 *
 */

/* to use disk traceing, must set the relevant bit(s) with the yoda 
 * 'it' command (e.g it 20), which then lets user select info required
 * AJO 15/12/92; Can also use yoda trace command, for which these constants
 * were changed from (1 << 2) to 0x4 style cos' Alpha/OSF/1 compiler won't
 * initialise a constant expression of this kind.
 */

/* trace fixed disk bios entry and exit
 * (with status and CF on exit)
 */
#define		CALL	0x1		/* reserved */

/* give info about BIOS command
 */
#define		CMDINFO	0x2

/* give information about execution of BIOS command
 * (gives results, and parameters of commands)
 */
#define		XINFO	0x4

/* give execution status of BIOS command
 * (flags errors during polls of disk controller, etc)
 */
#define		XSTAT	0x8

/* trace physical attach,detach
 */
#define		PAD	0x10

/* trace io attach,detach
 */
#define		IOAD	0x20

/* trace inb's, outb's, etc
 */
#define		PORTIO	0x40

/* trace fixed disk IRQ line
 */
#define		INTRUPT	0x80

/* trace fixed disk hw activity
 * (selects PORTIO, INTRUPT also)
 */
#define		HWXINFO	0x100

/* disk data dump
 */
#define		DDATA	0x200

/* trace host physical io (file pointer locn pre read(), write())
 */
#define		PHYSIO	0x400

/* to activate fixed disk controller tracing, must set DHW bit
 */
#define		DHW	0x4000

/* to activate disk BIOS tracing, must set DBIOS bit
 */

#define		DBIOS	0x8000

/* wdctrl_bop reads/writes
 */
#define		WDCTRL	0x10000

/*
 * handles to be used when bundling up multiple trace output
 */
#define INW_TRACE_HNDL	1
#define OUTW_TRACE_HNDL	2


/* disk tracing macro
 */
#ifndef PROD
#define dt0(infoid,hndl,fmt) \
	{if (io_verbose & HDA_VERBOSE) disktrace(infoid,0,hndl,fmt,0,0,0,0,0);}
#define dt1(infoid,hndl,fmt,i) \
	{if (io_verbose & HDA_VERBOSE) disktrace(infoid,1,hndl,fmt,i,0,0,0,0);}
#define dt2(infoid,hndl,fmt,i,j) \
	{if (io_verbose & HDA_VERBOSE) disktrace(infoid,2,hndl,fmt,i,j,0,0,0);}
#define dt3(infoid,hndl,fmt,i,j,k) \
	{if (io_verbose & HDA_VERBOSE) disktrace(infoid,3,hndl,fmt,i,j,k,0,0);}
#define dt4(infoid,hndl,fmt,i,j,k,l) \
	{if (io_verbose & HDA_VERBOSE) disktrace(infoid,4,hndl,fmt,i,j,k,l,0);}
#define dt5(infoid,hndl,fmt,i,j,k,l,m) \
	{if (io_verbose & HDA_VERBOSE) disktrace(infoid,5,hndl,fmt,i,j,k,l,m);}
#else
#define dt0(infoid,hndl,fmt) ;
#define dt1(infoid,hndl,fmt,i) ;
#define dt2(infoid,hndl,fmt,i,j) ;
#define dt3(infoid,hndl,fmt,i,j,k) ;
#define dt4(infoid,hndl,fmt,i,j,k,l) ;
#define dt5(infoid,hndl,fmt,i,j,k,l,m) ;
#endif

#ifndef PROD
VOID	setdisktrace();
IMPORT	IU32 disktraceinfo;
#ifdef ANSI
void disktrace (int, int, int, char *, unsigned long, unsigned long, unsigned long, unsigned long, unsigned long);
#else
VOID	disktrace();
#endif /* ANSI */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\egagraph.h ===
/*
 * SccsID = @(#)egagraph.h	1.13 04/22/93  Copyright Insignia Solutions Ltd.
 */

#ifdef	EGG

typedef	union {
	half_word	as_byte;
	struct {
#ifdef	BIT_ORDER2
		unsigned screen_can_wrap : 1;
		unsigned split_screen_used : 1;
		unsigned ht_of_200_scan_lines : 1;
		unsigned double_pix_wid : 1;
		unsigned graph_shift_reg : 1;
		unsigned cga_mem_bank : 1;
		unsigned chained : 1;
		unsigned text_mode : 1;
#else
		unsigned text_mode : 1;
		unsigned chained : 1;
		unsigned cga_mem_bank : 1;
		unsigned graph_shift_reg : 1;
		unsigned double_pix_wid : 1;
		unsigned ht_of_200_scan_lines : 1;
		unsigned split_screen_used : 1;
		unsigned screen_can_wrap : 1;
#endif
	} as_bfld;
} DISPLAY_STATE;

#define EGA_PALETTE_SIZE 16
extern	struct	EGA_GLOBALS {
	int			actual_offset_per_line;	/* in bytes */
#ifdef VGG
	_10_BITS		screen_split;
	boolean			palette_change_required;
	boolean			colour_256;
	boolean			colour_select;	/* 16/64 size palette choice (AR10:7) */
	half_word		DAC_mask;
	int			mid_pixel_pad;	/* video bits 4&5 when AR10:7 = 1 */
	int			top_pixel_pad;	/* video bits 7 & 6 unless 256 colour mode */
	half_word		palette_ind[EGA_PALETTE_SIZE];
	boolean		multiply_vert_by_two;
#else
	_9_BITS			screen_split;
#endif
	int			colours_used;
	PC_palette		palette[EGA_PALETTE_SIZE];
	byte			border[3];
	int			plane_mask;
	int			intensity;
	boolean			attrib_font_select;
	int			prim_font_index;	/* index (0-3) of primary selected font	    */
	int			sec_font_index;		/* index (0-3) of secondary selected font   */
	int			underline_start;	/* scanline to start drawing underline attr */
	DISPLAY_STATE		display_state;
	byte			*regen_ptr[4];
} EGA_GRAPH;

#ifdef VGG
extern PC_palette *DAC;			/* Size is `VGA_DAC_SIZE' */
#endif

#define	get_screen_can_wrap()		(EGA_GRAPH.display_state.as_bfld.screen_can_wrap)
#define	get_200_scan_lines()		(EGA_GRAPH.display_state.as_bfld.ht_of_200_scan_lines)
#define	get_split_screen_used()		(EGA_GRAPH.display_state.as_bfld.split_screen_used)
#define	get_actual_offset_per_line()	(EGA_GRAPH.actual_offset_per_line)
#define	get_ptr_offset(ptr,offs)	((ptr) != NULL ? &((ptr)[offs]) : NULL)
#define	get_regen_ptr1(offs)		get_ptr_offset(EGA_GRAPH.regen_ptr[0],offs)
#define	get_regen_ptr2(offs)		get_ptr_offset(EGA_GRAPH.regen_ptr[1],offs)
#define	get_regen_ptr3(offs)		get_ptr_offset(EGA_GRAPH.regen_ptr[2],offs)
#define	get_regen_ptr4(offs)		get_ptr_offset(EGA_GRAPH.regen_ptr[3],offs)
#define	get_regen_ptr(x,offs)		get_ptr_offset(EGA_GRAPH.regen_ptr[x],offs)
#define	get_plane_mask()		(EGA_GRAPH.plane_mask)
#define	get_intensity()			(EGA_GRAPH.intensity)
#define	plane0_enabled()		(get_plane_mask() & 0x1)
#define	plane01_enabled()		(get_plane_mask() & 0x3)
#define	plane1_enabled()		(get_plane_mask() & 0x2)
#define	plane2_enabled()		(get_plane_mask() & 0x4)
#define	plane23_enabled()		(get_plane_mask() & 0xC)
#define	plane3_enabled()		(get_plane_mask() & 0x8)
#define	all_planes_enabled()		(get_plane_mask() & 0xf)
#define	get_cga_mem_bank()		(EGA_GRAPH.display_state.as_bfld.cga_mem_bank)
#define	get_graph_shift_reg()		(EGA_GRAPH.display_state.as_bfld.graph_shift_reg)
#define	get_memory_chained()		(EGA_GRAPH.display_state.as_bfld.chained)
#define	get_double_pix_wid()		(EGA_GRAPH.display_state.as_bfld.double_pix_wid)
#define	get_munged_index()		(EGA_GRAPH.display_state.as_byte)
#define is_it_cga()			(EGA_GRAPH.display_state.as_byte & 0x60)
#define is_it_text()			((EGA_GRAPH.display_state.as_byte & 0x80) == 0x80)
#define	get_attrib_font_select()	(EGA_GRAPH.attrib_font_select)
#ifdef V7VGA
#define	get_screen_split()		(((EGA_GRAPH.screen_split.as_word)+1)<<EGA_GRAPH.multiply_vert_by_two)
#else
#define	get_screen_split()		((EGA_GRAPH.screen_split.as_word)+1)
#endif /* V7VGA */
#define	get_prim_font_index()		(EGA_GRAPH.prim_font_index)
#define	get_sec_font_index()		(EGA_GRAPH.sec_font_index)
#define	get_underline_start()		(EGA_GRAPH.underline_start)

#ifdef VGG
#define get_256_colour_mode()		(EGA_GRAPH.colour_256)
#define get_DAC_mask()			(EGA_GRAPH.DAC_mask)
#define get_colour_select()		(EGA_GRAPH.colour_select)
#define get_top_pixel_pad()		(EGA_GRAPH.top_pixel_pad)
#define get_mid_pixel_pad()		(EGA_GRAPH.mid_pixel_pad)
#if defined(NEC_98)         
#define get_palette_change_required()   (NEC98Display.palette.flag)
#else  // !NEC_98
#define get_palette_change_required()	(EGA_GRAPH.palette_change_required)
#endif // !NEC_98
#define get_palette_val(idx)		(EGA_GRAPH.palette_ind[(idx)])

#define set_256_colour_mode(val)	EGA_GRAPH.colour_256 = (val)
#define set_DAC_mask(val)		EGA_GRAPH.DAC_mask = (val)
#define set_colour_select(val)		EGA_GRAPH.colour_select = (val)
#define set_top_pixel_pad(val)		EGA_GRAPH.top_pixel_pad = (val)
#define set_mid_pixel_pad(val)		EGA_GRAPH.mid_pixel_pad = (val)
#if defined(NEC_98)         
#define set_palette_change_required(v)  NEC98Display.palette.flag = (v)
#else  // !NEC_98
#define set_palette_change_required(v)	EGA_GRAPH.palette_change_required = (v)
#endif // !NEC_98
#define set_palette_val(idx,val)	EGA_GRAPH.palette_ind[(idx)] = (val)
#define flag_palette_change_required()	EGA_GRAPH.palette_change_required = (TRUE)
#endif

#define	set_screen_can_wrap(val)	EGA_GRAPH.display_state.as_bfld.screen_can_wrap = (val)
#define	set_attrib_font_select(val)	EGA_GRAPH.attrib_font_select = (val)
#define	set_regen_ptr1(ptr)		EGA_GRAPH.regen_ptr[0] = (ptr)
#define	set_regen_ptr2(ptr)		EGA_GRAPH.regen_ptr[1] = (ptr)
#define	set_regen_ptr3(ptr)		EGA_GRAPH.regen_ptr[2] = (ptr)
#define	set_regen_ptr4(ptr)		EGA_GRAPH.regen_ptr[3] = (ptr)
#define	set_regen_ptr(x,ptr)		EGA_GRAPH.regen_ptr[(x)] = (ptr)
#define	set_plane_mask(val)		EGA_GRAPH.plane_mask = (val)
#define	set_intensity(val)		EGA_GRAPH.intensity = (val)
#define	set_cga_mem_bank(val)		EGA_GRAPH.display_state.as_bfld.cga_mem_bank = ((val) & 1)
#define	set_graph_shift_reg(val)	EGA_GRAPH.display_state.as_bfld.graph_shift_reg = ((val) & 1)
#define	set_memory_chained(val)		EGA_GRAPH.display_state.as_bfld.chained = ((val) & 1)
#define	set_text_mode(val) \
	EGA_GRAPH.display_state.as_bfld.text_mode = ((val) & 1)
#define	set_double_pix_wid(val)		EGA_GRAPH.display_state.as_bfld.double_pix_wid = ((val) & 1)
#define	set_200_scan_lines(val)		EGA_GRAPH.display_state.as_bfld.ht_of_200_scan_lines = (val)
#define	set_split_screen_used(val)	EGA_GRAPH.display_state.as_bfld.split_screen_used = (val)
#define	set_actual_offset_per_line(val)	EGA_GRAPH.actual_offset_per_line = (val)
#define	set_screen_split_hi(val)	EGA_GRAPH.screen_split.as_bfld.top_bit = (val)
#define	set_screen_split_lo(val)	EGA_GRAPH.screen_split.as_bfld.lo_byte = (val)
#define	set_screen_split(val)		EGA_GRAPH.screen_split.as_word = (val)
#define	set_prim_font_index(val)	EGA_GRAPH.prim_font_index = (val)
#define	set_sec_font_index(val)		EGA_GRAPH.sec_font_index = (val)
#define	set_underline_start(val)		EGA_GRAPH.underline_start = (val)

typedef	enum {
	ALPHA_MODE,
	GRAPHICS_MODE
} MODE_TYPE;

typedef enum {
	NO_SCROLL,
	TEXT_SCROLL,
	CGA_TEXT_SCROLL,
	CGA_GRAPH_SCROLL,
	EGA_GRAPH_SCROLL
#ifdef VGG
	,
	VGA_GRAPH_SCROLL
#endif
#ifdef V7VGA
	,
	V7VGA_GRAPH_SCROLL
#endif
} SCROLL_TYPE;

extern	char	mode_strings[][20];

#define	get_mode_string(mode)		mode_strings[(int) mode]

#define	RED	0
#define	GREEN	1
#define	BLUE	2

#define	get_palette_bit(color)		attribute_controller.palette[attribute_controller.address.as_bfld.index].as_bfld.color
#define	get_palette_color(col,sec_col)	((get_palette_bit(col)*0xA0)  | (get_palette_bit(sec_col)*0x50))

#define	get_border_bit(color)		attribute_controller.overscan_color.as_bfld.color
#define	get_border_color(col,sec_col)	((get_border_bit(col)*0xA0) | (get_border_bit(sec_col)*0x50))

#define	MAX_SCAN_LINES		350
#define	MAX_SCREEN_SPLIT	350

typedef	enum {
	SIMPLE_MARKING,
	CGA_GRAPHICS_MARKING,
	EGA_GRAPHICS_MARKING
} MARKING_TYPE;

/*
 * attribute bit selecting character to come from secondary font
 */

#define	SEC_FONT_ATTR	0x8

/*
 * The EGA underlines if the attr = X000X001, where X means 'dont care'.
 */
#define UL_ATTR_MASK	0x77	/* Mask to remove the X bits */
#define UL_ATTR		0x01	/* value to test against after masking */

/*
 * ======================================================================
 * Extern function prototypes.
 * ======================================================================
 */

IMPORT	void	dump_EGA_GRAPH IPT0();

/* AJO 18-Feb-93
 * The following prototype should be in gfx_upd.h (the code is in gfx_update.c),
 * however we can't put it there cos' gfx_upd.h most be included before
 * this file, but MARKING_TYPE and SCROLL_TYPE are defined in here; so short
 * of putting it in it own special include file this is the easiest option
 * for the moment.
 */
IMPORT void set_gfx_update_routines IPT3(T_calc_update, update_routine,
		MARKING_TYPE, marking_type, SCROLL_TYPE, scroll_type);

#endif	/* EGG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\egamode.h ===
/*
 * File: egamode.h
 *
 * SccsID = @(#)egamode.h	1.3 08/10/92 Copyright Insignia Solutions Ltd.
 *
 */


extern	boolean	(*choose_display_mode)();
extern	boolean	choose_ega_display_mode();
#ifdef VGG
#if defined(NEC_98)         
extern  boolean choose_NEC98_display_mode();
extern  boolean choose_NEC98_graph_mode();
extern  BOOL    video_emu_mode ;
#else  // !NEC_98
extern	boolean	choose_vga_display_mode();
#endif // !NEC_98
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\d_inst.h ===
/* 
   d_inst.h

   Define all Decoded Instruction Types.
 */

/*
   static char SccsID[]="@(#)d_inst.h	1.1 08/03/93 Copyright Insignia Solutions Ltd.";
 */


/*
   The Decoded Intel Instructions.
   -------------------------------

   Number Field: col(-c)=32, width(-w)=3.
 */

#define I_AAA		(USHORT)  0
#define I_AAD		(USHORT)  1
#define I_AAM		(USHORT)  2
#define I_AAS		(USHORT)  3
#define I_ADC8		(USHORT)  4
#define I_ADC16		(USHORT)  5
#define I_ADC32		(USHORT)  6
#define I_ADD8		(USHORT)  7
#define I_ADD16		(USHORT)  8
#define I_ADD32		(USHORT)  9
#define I_AND8		(USHORT) 10
#define I_AND16		(USHORT) 11
#define I_AND32		(USHORT) 12
#define I_ARPL		(USHORT) 13
#define I_BOUND16	(USHORT) 14
#define I_BOUND32	(USHORT) 15
#define I_BSF16		(USHORT) 16
#define I_BSF32		(USHORT) 17
#define I_BSR16		(USHORT) 18
#define I_BSR32		(USHORT) 19
#define I_BSWAP		(USHORT) 20
#define I_BT16		(USHORT) 21
#define I_BT32		(USHORT) 22
#define I_BTC16		(USHORT) 23
#define I_BTC32		(USHORT) 24
#define I_BTR16		(USHORT) 25
#define I_BTR32		(USHORT) 26
#define I_BTS16		(USHORT) 27
#define I_BTS32		(USHORT) 28
#define I_CALLF16	(USHORT) 29
#define I_CALLF32	(USHORT) 30
#define I_CALLN16	(USHORT) 31
#define I_CALLN32	(USHORT) 32
#define I_CALLR16	(USHORT) 33
#define I_CALLR32	(USHORT) 34
#define I_CBW		(USHORT) 35
#define I_CDQ		(USHORT) 36
#define I_CLC		(USHORT) 37
#define I_CLD		(USHORT) 38
#define I_CLI		(USHORT) 39
#define I_CLTS		(USHORT) 40
#define I_CMC		(USHORT) 41
#define I_CMP8		(USHORT) 42
#define I_CMP16		(USHORT) 43
#define I_CMP32		(USHORT) 44
#define I_CMPSB		(USHORT) 45
#define I_CMPSD		(USHORT) 46
#define I_CMPSW		(USHORT) 47
#define I_CMPXCHG8	(USHORT) 48
#define I_CMPXCHG16	(USHORT) 49
#define I_CMPXCHG32	(USHORT) 50
#define I_CWD		(USHORT) 51
#define I_CWDE		(USHORT) 52
#define I_DAA		(USHORT) 53
#define I_DAS		(USHORT) 54
#define I_DEC8		(USHORT) 55
#define I_DEC16		(USHORT) 56
#define I_DEC32		(USHORT) 57
#define I_DIV8		(USHORT) 58
#define I_DIV16		(USHORT) 59
#define I_DIV32		(USHORT) 60
#define I_ENTER16	(USHORT) 61
#define I_ENTER32	(USHORT) 62
#define I_F2XM1		(USHORT) 63
#define I_FABS		(USHORT) 64
#define I_FADD		(USHORT) 65
#define I_FADDP		(USHORT) 66
#define I_FBLD		(USHORT) 67
#define I_FBSTP		(USHORT) 68
#define I_FCHS		(USHORT) 69
#define I_FCLEX		(USHORT) 70
#define I_FCOM		(USHORT) 71
#define I_FCOMP		(USHORT) 72
#define I_FCOMPP	(USHORT) 73
#define I_FCOS		(USHORT) 74
#define I_FDECSTP	(USHORT) 75
#define I_FDIV		(USHORT) 76
#define I_FDIVP		(USHORT) 77
#define I_FDIVR		(USHORT) 78
#define I_FDIVRP	(USHORT) 79
#define I_FFREE		(USHORT) 80
#define I_FFREEP	(USHORT) 81
#define I_FIADD		(USHORT) 82
#define I_FICOM		(USHORT) 83
#define I_FICOMP	(USHORT) 84
#define I_FIDIV		(USHORT) 85
#define I_FIDIVR	(USHORT) 86
#define I_FILD		(USHORT) 87
#define I_FIMUL		(USHORT) 88
#define I_FINCSTP	(USHORT) 89
#define I_FINIT		(USHORT) 90
#define I_FIST		(USHORT) 91
#define I_FISTP		(USHORT) 92
#define I_FISUB		(USHORT) 93
#define I_FISUBR	(USHORT) 94
#define I_FLD		(USHORT) 95
#define I_FLD1		(USHORT) 96
#define I_FLDCW		(USHORT) 97
#define I_FLDENV16	(USHORT) 98
#define I_FLDENV32	(USHORT) 99
#define I_FLDL2E	(USHORT)100
#define I_FLDL2T	(USHORT)101
#define I_FLDLG2	(USHORT)102
#define I_FLDLN2	(USHORT)103
#define I_FLDPI		(USHORT)104
#define I_FLDZ		(USHORT)105
#define I_FMUL		(USHORT)106
#define I_FMULP		(USHORT)107
#define I_FNOP		(USHORT)108
#define I_FPATAN	(USHORT)109
#define I_FPREM		(USHORT)110
#define I_FPREM1	(USHORT)111
#define I_FPTAN		(USHORT)112
#define I_FRNDINT	(USHORT)113
#define I_FRSTOR16	(USHORT)114
#define I_FRSTOR32	(USHORT)115
#define I_FSAVE16	(USHORT)116
#define I_FSAVE32	(USHORT)117
#define I_FSCALE	(USHORT)118
#define I_FSETPM	(USHORT)119
#define I_FSIN		(USHORT)120
#define I_FSINCOS	(USHORT)121
#define I_FSQRT		(USHORT)122
#define I_FST		(USHORT)123
#define I_FSTCW		(USHORT)124
#define I_FSTENV16	(USHORT)125
#define I_FSTENV32	(USHORT)126
#define I_FSTP		(USHORT)127
#define I_FSTSW		(USHORT)128
#define I_FSUB		(USHORT)129
#define I_FSUBP		(USHORT)130
#define I_FSUBR		(USHORT)131
#define I_FSUBRP	(USHORT)132
#define I_FTST		(USHORT)133
#define I_FUCOM		(USHORT)134
#define I_FUCOMP	(USHORT)135
#define I_FUCOMPP	(USHORT)136
#define I_FXAM		(USHORT)137
#define I_FXCH		(USHORT)138
#define I_FXTRACT	(USHORT)139
#define I_FYL2X		(USHORT)140
#define I_FYL2XP1	(USHORT)141
#define I_HLT		(USHORT)142
#define I_IDIV8		(USHORT)143
#define I_IDIV16	(USHORT)144
#define I_IDIV32	(USHORT)145
#define I_IMUL8		(USHORT)146
#define I_IMUL16	(USHORT)147
#define I_IMUL32	(USHORT)148
#define I_IMUL16T2	(USHORT)149
#define I_IMUL16T3	(USHORT)150
#define I_IMUL32T2	(USHORT)151
#define I_IMUL32T3	(USHORT)152
#define I_IN8		(USHORT)153
#define I_IN16		(USHORT)154
#define I_IN32		(USHORT)155
#define I_INC8		(USHORT)156
#define I_INC16		(USHORT)157
#define I_INC32		(USHORT)158
#define I_INSB		(USHORT)159
#define I_INSD		(USHORT)160
#define I_INSW		(USHORT)161
#define I_INT3		(USHORT)162
#define I_INT		(USHORT)163
#define I_INTO		(USHORT)164
#define I_INVD		(USHORT)165
#define I_INVLPG	(USHORT)166
#define I_IRET		(USHORT)167
#define I_IRETD		(USHORT)168
#define I_JB16		(USHORT)169
#define I_JB32		(USHORT)170
#define I_JBE16		(USHORT)171
#define I_JBE32		(USHORT)172
#define I_JCXZ		(USHORT)173
#define I_JECXZ		(USHORT)174
#define I_JL16		(USHORT)175
#define I_JL32		(USHORT)176
#define I_JLE16		(USHORT)177
#define I_JLE32		(USHORT)178
#define I_JMPF16	(USHORT)179
#define I_JMPF32	(USHORT)180
#define I_JMPN		(USHORT)181
#define I_JMPR16	(USHORT)182
#define I_JMPR32	(USHORT)183
#define I_JNB16		(USHORT)184
#define I_JNB32		(USHORT)185
#define I_JNBE16	(USHORT)186
#define I_JNBE32	(USHORT)187
#define I_JNL16		(USHORT)188
#define I_JNL32		(USHORT)189
#define I_JNLE16	(USHORT)190
#define I_JNLE32	(USHORT)191
#define I_JNO16		(USHORT)192
#define I_JNO32		(USHORT)193
#define I_JNP16		(USHORT)194
#define I_JNP32		(USHORT)195
#define I_JNS16		(USHORT)196
#define I_JNS32		(USHORT)197
#define I_JNZ16		(USHORT)198
#define I_JNZ32		(USHORT)199
#define I_JO16		(USHORT)200
#define I_JO32		(USHORT)201
#define I_JP16		(USHORT)202
#define I_JP32		(USHORT)203
#define I_JS16		(USHORT)204
#define I_JS32		(USHORT)205
#define I_JZ16		(USHORT)206
#define I_JZ32		(USHORT)207
#define I_LAHF		(USHORT)208
#define I_LAR		(USHORT)209
#define I_LDS		(USHORT)210
#define I_LEA		(USHORT)211
#define I_LEAVE16	(USHORT)212
#define I_LEAVE32	(USHORT)213
#define I_LES		(USHORT)214
#define I_LFS		(USHORT)215
#define I_LGDT16	(USHORT)216
#define I_LGDT32	(USHORT)217
#define I_LGS		(USHORT)218
#define I_LIDT16	(USHORT)219
#define I_LIDT32	(USHORT)220
#define I_LLDT		(USHORT)221
#define I_LMSW		(USHORT)222
#define I_LOADALL	(USHORT)223
#define I_LOCK		(USHORT)224
#define I_LODSB		(USHORT)225
#define I_LODSD		(USHORT)226
#define I_LODSW		(USHORT)227
#define I_LOOP16	(USHORT)228
#define I_LOOP32	(USHORT)229
#define I_LOOPE16	(USHORT)230
#define I_LOOPE32	(USHORT)231
#define I_LOOPNE16	(USHORT)232
#define I_LOOPNE32	(USHORT)233
#define I_LSL		(USHORT)234
#define I_LSS		(USHORT)235
#define I_LTR		(USHORT)236
#define I_MOV_SR	(USHORT)237
#define I_MOV_CR	(USHORT)238
#define I_MOV_DR	(USHORT)239
#define I_MOV_TR	(USHORT)240
#define I_MOV8		(USHORT)241
#define I_MOV16		(USHORT)242
#define I_MOV32		(USHORT)243
#define I_MOVSB		(USHORT)244
#define I_MOVSD		(USHORT)245
#define I_MOVSW		(USHORT)246
#define I_MOVSX8	(USHORT)247
#define I_MOVSX16	(USHORT)248
#define I_MOVZX8	(USHORT)249
#define I_MOVZX16	(USHORT)250
#define I_MUL8		(USHORT)251
#define I_MUL16		(USHORT)252
#define I_MUL32		(USHORT)253
#define I_NEG8		(USHORT)254
#define I_NEG16		(USHORT)255
#define I_NEG32		(USHORT)256
#define I_NOP		(USHORT)257
#define I_NOT8		(USHORT)258
#define I_NOT16		(USHORT)259
#define I_NOT32		(USHORT)260
#define I_OR8		(USHORT)261
#define I_OR16		(USHORT)262
#define I_OR32		(USHORT)263
#define I_OUT8		(USHORT)264
#define I_OUT16		(USHORT)265
#define I_OUT32		(USHORT)266
#define I_OUTSB		(USHORT)267
#define I_OUTSD		(USHORT)268
#define I_OUTSW		(USHORT)269
#define I_POP16		(USHORT)270
#define I_POP32		(USHORT)271
#define I_POP_SR	(USHORT)272
#define I_POPA		(USHORT)273
#define I_POPAD		(USHORT)274
#define I_POPF		(USHORT)275
#define I_POPFD		(USHORT)276
#define I_PUSH16	(USHORT)277
#define I_PUSH32	(USHORT)278
#define I_PUSHA		(USHORT)279
#define I_PUSHAD	(USHORT)280
#define I_PUSHF		(USHORT)281
#define I_PUSHFD	(USHORT)282
#define I_RCL8		(USHORT)283
#define I_RCL16		(USHORT)284
#define I_RCL32		(USHORT)285
#define I_RCR8		(USHORT)286
#define I_RCR16		(USHORT)287
#define I_RCR32		(USHORT)288
#define I_RETF16	(USHORT)289
#define I_RETF32	(USHORT)290
#define I_RETN16	(USHORT)291
#define I_RETN32	(USHORT)292
#define I_ROL8		(USHORT)293
#define I_ROL16		(USHORT)294
#define I_ROL32		(USHORT)295
#define I_ROR8		(USHORT)296
#define I_ROR16		(USHORT)297
#define I_ROR32		(USHORT)298
#define I_R_INSB	(USHORT)299 /* REP   INS  */
#define I_R_INSD	(USHORT)300 /* REP   INS  */
#define I_R_INSW	(USHORT)301 /* REP   INS  */
#define I_R_OUTSB	(USHORT)302 /* REP   OUTS */
#define I_R_OUTSD	(USHORT)303 /* REP   OUTS */
#define I_R_OUTSW	(USHORT)304 /* REP   OUTS */
#define I_R_LODSB	(USHORT)305 /* REP   LODS */
#define I_R_LODSD	(USHORT)306 /* REP   LODS */
#define I_R_LODSW	(USHORT)307 /* REP   LODS */
#define I_R_MOVSB	(USHORT)308 /* REP   MOVS */
#define I_R_MOVSD	(USHORT)309 /* REP   MOVS */
#define I_R_MOVSW	(USHORT)310 /* REP   MOVS */
#define I_R_STOSB	(USHORT)311 /* REP   STOS */
#define I_R_STOSD	(USHORT)312 /* REP   STOS */
#define I_R_STOSW	(USHORT)313 /* REP   STOS */
#define I_RE_CMPSB	(USHORT)314 /* REPE  CMPS */
#define I_RE_CMPSD	(USHORT)315 /* REPE  CMPS */
#define I_RE_CMPSW	(USHORT)316 /* REPE  CMPS */
#define I_RNE_CMPSB	(USHORT)317 /* REPNE CMPS */
#define I_RNE_CMPSD	(USHORT)318 /* REPNE CMPS */
#define I_RNE_CMPSW	(USHORT)319 /* REPNE CMPS */
#define I_RE_SCASB	(USHORT)320 /* REPE  SCAS */
#define I_RE_SCASD	(USHORT)321 /* REPE  SCAS */
#define I_RE_SCASW	(USHORT)322 /* REPE  SCAS */
#define I_RNE_SCASB	(USHORT)323 /* REPNE SCAS */
#define I_RNE_SCASD	(USHORT)324 /* REPNE SCAS */
#define I_RNE_SCASW	(USHORT)325 /* REPNE SCAS */
#define I_SAHF		(USHORT)326
#define I_SAR8		(USHORT)327
#define I_SAR16		(USHORT)328
#define I_SAR32		(USHORT)329
#define I_SBB8		(USHORT)330
#define I_SBB16		(USHORT)331
#define I_SBB32		(USHORT)332
#define I_SCASB		(USHORT)333
#define I_SCASD		(USHORT)334
#define I_SCASW		(USHORT)335
#define I_SETB		(USHORT)336
#define I_SETBE		(USHORT)337
#define I_SETL		(USHORT)338
#define I_SETLE		(USHORT)339
#define I_SETNB		(USHORT)340
#define I_SETNBE	(USHORT)341
#define I_SETNL		(USHORT)342
#define I_SETNLE	(USHORT)343
#define I_SETNO		(USHORT)344
#define I_SETNP		(USHORT)345
#define I_SETNS		(USHORT)346
#define I_SETNZ		(USHORT)347
#define I_SETO		(USHORT)348
#define I_SETP		(USHORT)349
#define I_SETS		(USHORT)350
#define I_SETZ		(USHORT)351
#define I_SGDT16	(USHORT)352
#define I_SGDT32	(USHORT)353
#define I_SHL8		(USHORT)354
#define I_SHL16		(USHORT)355
#define I_SHL32		(USHORT)356
#define I_SHLD16	(USHORT)357
#define I_SHLD32	(USHORT)358
#define I_SHR8		(USHORT)359
#define I_SHR16		(USHORT)360
#define I_SHR32		(USHORT)361
#define I_SHRD16	(USHORT)362
#define I_SHRD32	(USHORT)363
#define I_SIDT16	(USHORT)364
#define I_SIDT32	(USHORT)365
#define I_SLDT		(USHORT)366
#define I_SMSW		(USHORT)367
#define I_STC		(USHORT)368
#define I_STD		(USHORT)369
#define I_STI		(USHORT)370
#define I_STOSB		(USHORT)371
#define I_STOSD		(USHORT)372
#define I_STOSW		(USHORT)373
#define I_STR		(USHORT)374
#define I_SUB8		(USHORT)375
#define I_SUB16		(USHORT)376
#define I_SUB32		(USHORT)377
#define I_TEST8		(USHORT)378
#define I_TEST16	(USHORT)379
#define I_TEST32	(USHORT)380
#define I_VERR		(USHORT)381
#define I_VERW		(USHORT)382
#define I_WAIT		(USHORT)383
#define I_WBINVD	(USHORT)384
#define I_XADD8		(USHORT)385
#define I_XADD16	(USHORT)386
#define I_XADD32	(USHORT)387
#define I_XCHG8		(USHORT)388
#define I_XCHG16	(USHORT)389
#define I_XCHG32	(USHORT)390
#define I_XLAT		(USHORT)391
#define I_XOR8		(USHORT)392
#define I_XOR16		(USHORT)393
#define I_XOR32		(USHORT)394
#define I_ZBADOP	(USHORT)395
#define I_ZBOP		(USHORT)396 /* Insignia's own BOP */
#define I_ZFRSRVD	(USHORT)397 /* Intel Floating Point reserved */
#define I_ZRSRVD	(USHORT)398 /* Intel reserved */
#define I_ZZEXIT	(USHORT)399 /* Insignia's PIG exit opcode */

#define MAX_DECODED_INST 399

/*
   End of  Decoded Intel Instructions.
   -----------------------------------
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\egacpu.h ===
/*
 * SccsID = @(#)egacpu.h	1.22 10/24/94 Copyright Insignia Solutions Ltd.
 */

typedef enum
{
	WRITE_MODE,
	PLANES_ENABLED,
	ROTATION,
	CHAINED,
	BIT_PROT,
	FUNCTION,
	SET_RESET,
	ENABLE_SET_RESET,
	RAM_ENABLED,
	RAM_MOVED
} CHANGE_TYPE;

typedef union
{
#ifdef BIT_ORDER1
	struct
	{
		unsigned unused:27;
		unsigned sr:1;
		unsigned bp:1;
		unsigned func:2;
		unsigned pe:1;
	} state;
	struct
	{
		unsigned unused:27;
		unsigned lookup:5;
	} mode_0;
	struct
	{
		unsigned unused:31;
		unsigned lookup:1;
	} mode_1;
	struct
	{
		unsigned unused:28;
		unsigned lookup:4;
	} mode_2;
	struct
	{
		unsigned unused:28;
		unsigned lookup:4;
	} mode_3;
#else
	struct
	{
		unsigned pe:1;
		unsigned func:2;
		unsigned bp:1;
		unsigned sr:1;
		unsigned unused:27;
	} state;
	struct
	{
		unsigned lookup:5;
		unsigned unused:27;
	} mode_0;
	struct
	{
		unsigned lookup:1;
		unsigned unused:31;
	} mode_1;
	struct
	{
		unsigned lookup:4;
		unsigned unused:28;
	} mode_2;
	struct
	{
		unsigned lookup:4;
		unsigned unused:28;
	} mode_3;
#endif
} MAGIC;

typedef struct
{
	ULONG	latches;
	UTINY	*VGA_rplane;
	UTINY	*VGA_wplane;
	UTINY	*scratch;
	ULONG	sr_masked_val;
	ULONG	sr_nmask;
	ULONG	data_and_mask;
	ULONG	data_xor_mask;
	ULONG	latch_xor_mask;
	ULONG	bit_prot_mask;
	ULONG	plane_enable;
	ULONG	plane_enable_mask;
	ULONG	*sr_lookup;
	VOID	(*fwd_str_read_addr)();
	VOID	(*bwd_str_read_addr)();
	ULONG	dirty_flag;
	LONG	dirty_low;
	LONG	dirty_high;
	IU8	*video_copy;
	VOID	(*mark_byte)();
	VOID	(*mark_word)();
	VOID	(*mark_string)();
	ULONG	read_shift_count;
	ULONG	read_mapped_plane;
	ULONG	colour_comp;
	ULONG	dont_care;
	ULONG	v7_vid_copy_off;
	ULONG	copy_func_pbp;
	UTINY	*route_reg1;
	UTINY	*route_reg2;
	UTINY	*screen_ptr;
	ULONG	rotate;
#if defined(NEC_98)         
        unsigned char   *gvram_p00_copy;
        unsigned char   *gvram_p10_copy;
        unsigned char   *gvram_p20_copy;
        unsigned char   *gvram_p30_copy;
        unsigned char   *gvram_p01_copy;
        unsigned char   *gvram_p11_copy;
        unsigned char   *gvram_p21_copy;
        unsigned char   *gvram_p31_copy;
        long            gvram_dirty_flag0;
        long            gvram_dirty_flag1;
        unsigned char   read_bank;
        unsigned char   select_bank;
        unsigned char   *gvram_p00_ptr;
        unsigned char   *gvram_p10_ptr;
        unsigned char   *gvram_p20_ptr;
        unsigned char   *gvram_p30_ptr;
        unsigned char   *gvram_p01_ptr;
        unsigned char   *gvram_p11_ptr;
        unsigned char   *gvram_p21_ptr;
        unsigned char   *gvram_p31_ptr;
} NEC98_GLOBALS, VGA_GLOBALS;
#else  // !NEC_98
} VGA_GLOBALS;
#endif // !NEC_98

#if defined(NEC_98)         
extern struct NEC98_CPU_GLOBALS
#else  // !NEC_98
extern struct EGA_CPU_GLOBALS
#endif // !NEC_98
{
#if defined(NEC_98)         
        NEC98_GLOBALS    *globals;
#else  // !NEC_98
#ifndef	HOST_VGA_GLOBALS
	VGA_GLOBALS	*globals;
#endif
#endif // !NEC_98
	ULONG		saved_state;		/* Last value of EGA_CPU.ega_state.state */
	ULONG		saved_mode_chain;		/* Last value of mode/chain combined */
#if defined(NEC_98)         
        MAGIC           NEC98_state;
#else  // !NEC_98
	MAGIC		ega_state;
#endif // !NEC_98
	ULONG		fun_or_protection;   /* true means write function is 1-3 and/or there
						is bit protection, so latches must be used */
	ULONG		calc_data_xor;	/* Used to recalculate data_xor_mask when the
									bit prot reg changes */
	ULONG		calc_latch_xor;	/* Used to recalculate latch_xor_mask when the
									bit prot reg changes */
	ULONG		set_reset;
	ULONG		sr_enable;
	ULONG		sr_value;
	ULONG		ram_enabled;

	UTINY		write_mode;
	UTINY		chain;
	UTINY		doubleword;
	UTINY		*plane_offset;
	UTINY		*read_mapped_plane_ch2;
#ifdef V7VGA
	UTINY		seq_chain4;
	UTINY		seq_chain;
#endif
#if defined(NEC_98)
} NEC98_CPU;
#else  // !NEC_98
} EGA_CPU;
#endif // !NEC_98

#if defined(NEC_98)
#define NEC98GLOBS       NEC98_CPU.globals

#define	getVideolatches()		NEC98GLOBS->latches
#define	setVideolatches(value)		NEC98GLOBS->latches = value
#define	getVideorplane()		NEC98GLOBS->VGA_rplane
#define	setVideorplane(value)		NEC98GLOBS->VGA_rplane = value
#define	getVideowplane()		NEC98GLOBS->VGA_wplane
#define	setVideowplane(value)		NEC98GLOBS->VGA_wplane = value
#define	getVideoscratch()		NEC98GLOBS->scratch
#define	setVideoscratch(value)		NEC98GLOBS->scratch = value
#define	getVideosr_masked_val()		NEC98GLOBS->sr_masked_val
#define	setVideosr_masked_val(value)	NEC98GLOBS->sr_masked_val = value
#define	getVideosr_nmask()		NEC98GLOBS->sr_nmask
#define	setVideosr_nmask(value)		NEC98GLOBS->sr_nmask = value
#define	getVideodata_and_mask()		NEC98GLOBS->data_and_mask
#define	setVideodata_and_mask(value)	NEC98GLOBS->data_and_mask = value
#define	getVideodata_xor_mask()		NEC98GLOBS->data_xor_mask
#define	setVideodata_xor_mask(value)	NEC98GLOBS->data_xor_mask = value
#define	getVideolatch_xor_mask()	NEC98GLOBS->latch_xor_mask
#define	setVideolatch_xor_mask(value)	NEC98GLOBS->latch_xor_mask = value
#define	getVideobit_prot_mask()		NEC98GLOBS->bit_prot_mask
#define	setVideobit_prot_mask(value)	NEC98GLOBS->bit_prot_mask = value
#define	getVideoplane_enable()		NEC98GLOBS->plane_enable
#define	setVideoplane_enable(value)	NEC98GLOBS->plane_enable = value
#define	getVideoplane_enableMask()	NEC98GLOBS->plane_enable_mask
#define	setVideoplane_enable_mask(value)	NEC98GLOBS->plane_enable_mask = value
#define	getVideosr_lookup()		NEC98GLOBS->sr_lookup
#define	setVideosr_lookup(value)	NEC98GLOBS->sr_lookup = value
#define	getVideofwd_str_read_addr()	NEC98GLOBS->fwd_str_read_addr
#define	setVideofwd_str_read_addr(value)	NEC98GLOBS->fwd_str_read_addr = value
#define	getVideobwd_str_read_addr()	NEC98GLOBS->bwd_str_read_addr
#define	setVideobwd_str_read_addr(value)	NEC98GLOBS->bwd_str_read_addr = value
#define	getVideodirty_total()		NEC98GLOBS->dirty_flag
#define	setVideodirty_total(value)	NEC98GLOBS->dirty_flag = value
#define	getVideodirty_low()		NEC98GLOBS->dirty_low
#define	setVideodirty_low(value)	NEC98GLOBS->dirty_low = value
#define	getVideodirty_high()		NEC98GLOBS->dirty_high
#define	setVideodirty_high(value)	NEC98GLOBS->dirty_high = value
#define	getVideovideo_copy()		NEC98GLOBS->video_copy
#define	setVideovideo_copy(value)	NEC98GLOBS->video_copy = value
#define	getVideomark_byte()		NEC98GLOBS->mark_byte
#define	setVideomark_byte(value)	NEC98GLOBS->mark_byte = value
#define	getVideomark_word()		NEC98GLOBS->mark_word
#define	setVideomark_word(value)	NEC98GLOBS->mark_word = value
#define	getVideomark_string()		NEC98GLOBS->mark_string
#define	setVideomark_string(value)	NEC98GLOBS->mark_string = value
#define	getVideoread_shift_count()	NEC98GLOBS->read_shift_count
#define	setVideoread_shift_count(value)	NEC98GLOBS->read_shift_count = value
#define	getVideoread_mapped_plane()	NEC98GLOBS->read_mapped_plane
#define	setVideoread_mapped_plane(value)	NEC98GLOBS->read_mapped_plane = value
#define	getVideocolour_comp()		NEC98GLOBS->colour_comp
#define	setVideocolour_comp(value)	NEC98GLOBS->colour_comp = value
#define	getVideodont_care()		NEC98GLOBS->dont_care
#define	setVideodont_care(value)	NEC98GLOBS->dont_care = value
#define	getVideov7_bank_vid_copy_off()	NEC98GLOBS->v7_vid_copy_off
#define	setVideov7_bank_vid_copy_off(value)	NEC98GLOBS->v7_vid_copy_off = value
#define	getVideoscreen_ptr()		NEC98GLOBS->screen_ptr
#define	setVideoscreen_ptr(value)	NEC98GLOBS->screen_ptr = value
#define	getVideorotate()		NEC98GLOBS->rotate
#define	setVideorotate(value)		NEC98GLOBS->rotate = value
#define	getVideocalc_data_xor()		calc_data_xor
#define	setVideocalc_data_xor(value)	calc_data_xor = value
#define	getVideocalc_latch_xor()	calc_latch_xor
#define	setVideocalc_latch_xor(value)	calc_latch_xor = value
#define	getVideoread_byte_addr()		
#define	setVideoread_byte_addr(value)	
#define	getVideov7_fg_latches()		fg_latches
#define	setVideov7_fg_latches(value)	fg_latches = value
#define	getVideoGC_regs()		
#define	setVideoGC_regs(value)		
#define	getVideolast_GC_index()		
#define	setVideolast_GC_index(value)	
#define	getVideodither()		
#define	setVideodither(value)	
#define	getVideowrmode()	
#define	setVideowrmode(value)	
#define	getVideochain()	
#define	setVideochain(value)	
#define	getVideowrstate()	
#define	setVideowrstate(value)	

#define write_state NEC98_CPU.NEC98_state.state
#else  // !NEC_98
#ifndef CPU_40_STYLE	/* Vglobs done via access fns */
#ifdef	HOST_VGA_GLOBALS
/* Some hosts, such as the Mac, declare their own VGA_GLOBALS structure */
IMPORT	VGA_GLOBALS		HostVGAGlobals;
#define	VGLOBS			(&HostVGAGlobals)		/*Always used as a pointer*/
#else
#define VGLOBS			EGA_CPU.globals
#endif

#define	getVideolatches()		VGLOBS->latches
#define	setVideolatches(value)		VGLOBS->latches = value
#define	getVideorplane()		VGLOBS->VGA_rplane
#define	setVideorplane(value)		VGLOBS->VGA_rplane = value
#define	getVideowplane()		VGLOBS->VGA_wplane
#define	setVideowplane(value)		VGLOBS->VGA_wplane = value
#define	getVideoscratch()		VGLOBS->scratch
#define	setVideoscratch(value)		VGLOBS->scratch = value
#define	getVideosr_masked_val()		VGLOBS->sr_masked_val
#define	setVideosr_masked_val(value)	VGLOBS->sr_masked_val = value
#define	getVideosr_nmask()		VGLOBS->sr_nmask
#define	setVideosr_nmask(value)		VGLOBS->sr_nmask = value
#define	getVideodata_and_mask()		VGLOBS->data_and_mask
#define	setVideodata_and_mask(value)	VGLOBS->data_and_mask = value
#define	getVideodata_xor_mask()		VGLOBS->data_xor_mask
#define	setVideodata_xor_mask(value)	VGLOBS->data_xor_mask = value
#define	getVideolatch_xor_mask()	VGLOBS->latch_xor_mask
#define	setVideolatch_xor_mask(value)	VGLOBS->latch_xor_mask = value
#define	getVideobit_prot_mask()		VGLOBS->bit_prot_mask
#define	setVideobit_prot_mask(value)	VGLOBS->bit_prot_mask = value
#define	getVideoplane_enable()		VGLOBS->plane_enable
#define	setVideoplane_enable(value)	VGLOBS->plane_enable = value
#define	getVideoplane_enableMask()	VGLOBS->plane_enable_mask
#define	setVideoplane_enable_mask(value)	VGLOBS->plane_enable_mask = value
#define	getVideosr_lookup()		VGLOBS->sr_lookup
#define	setVideosr_lookup(value)	VGLOBS->sr_lookup = value
#define	getVideofwd_str_read_addr()	VGLOBS->fwd_str_read_addr
#define	setVideofwd_str_read_addr(value)	VGLOBS->fwd_str_read_addr = value
#define	getVideobwd_str_read_addr()	VGLOBS->bwd_str_read_addr
#define	setVideobwd_str_read_addr(value)	VGLOBS->bwd_str_read_addr = value
#define	getVideodirty_total()		VGLOBS->dirty_flag
#define	setVideodirty_total(value)	VGLOBS->dirty_flag = value
#define	getVideodirty_low()		VGLOBS->dirty_low
#define	setVideodirty_low(value)	VGLOBS->dirty_low = value
#define	getVideodirty_high()		VGLOBS->dirty_high
#define	setVideodirty_high(value)	VGLOBS->dirty_high = value
#define	getVideovideo_copy()		VGLOBS->video_copy
#define	setVideovideo_copy(value)	VGLOBS->video_copy = value
#define	getVideomark_byte()		VGLOBS->mark_byte
#define	setVideomark_byte(value)	VGLOBS->mark_byte = value
#define	getVideomark_word()		VGLOBS->mark_word
#define	setVideomark_word(value)	VGLOBS->mark_word = value
#define	getVideomark_string()		VGLOBS->mark_string
#define	setVideomark_string(value)	VGLOBS->mark_string = value
#define	getVideoread_shift_count()	VGLOBS->read_shift_count
#define	setVideoread_shift_count(value)	VGLOBS->read_shift_count = value
#define	getVideoread_mapped_plane()	VGLOBS->read_mapped_plane
#define	setVideoread_mapped_plane(value)	VGLOBS->read_mapped_plane = value
#define	getVideocolour_comp()		VGLOBS->colour_comp
#define	setVideocolour_comp(value)	VGLOBS->colour_comp = value
#define	getVideodont_care()		VGLOBS->dont_care
#define	setVideodont_care(value)	VGLOBS->dont_care = value
#define	getVideov7_bank_vid_copy_off()	VGLOBS->v7_vid_copy_off
#define	setVideov7_bank_vid_copy_off(value)	VGLOBS->v7_vid_copy_off = value
#define	getVideoscreen_ptr()		VGLOBS->screen_ptr
#define	setVideoscreen_ptr(value)	VGLOBS->screen_ptr = value
#define	getVideorotate()		VGLOBS->rotate
#define	setVideorotate(value)		VGLOBS->rotate = value
#define	getVideocalc_data_xor()		calc_data_xor
#define	setVideocalc_data_xor(value)	calc_data_xor = value
#define	getVideocalc_latch_xor()	calc_latch_xor
#define	setVideocalc_latch_xor(value)	calc_latch_xor = value
#define	getVideoread_byte_addr()		
#define	setVideoread_byte_addr(value)	
#define	getVideov7_fg_latches()		fg_latches
#define	setVideov7_fg_latches(value)	fg_latches = value
#define	getVideoGC_regs()		
#define	setVideoGC_regs(value)		
#define	getVideolast_GC_index()		
#define	setVideolast_GC_index(value)	
#define	getVideodither()		
#define	setVideodither(value)	
#define	getVideowrmode()	
#define	setVideowrmode(value)	
#define	getVideochain()	
#define	setVideochain(value)	
#define	getVideowrstate()	
#define	setVideowrstate(value)	

#else	/* CPU_40_STYLE */

extern void setVideorplane IPT1(IU8 *, value);
extern IU8 * getVideorplane IPT0();
extern void setVideowplane IPT1(IU8 *, value);
extern IU8 * getVideowplane IPT0();
extern void setVideoscratch IPT1(IU8 *, value);
extern IU8 * getVideoscratch IPT0();
extern void setVideosr_masked_val IPT1(IU32, value);
extern IU32 getVideosr_masked_val IPT0();
extern void setVideosr_nmask IPT1(IU32, value);
extern IU32 getVideosr_nmask IPT0();
extern void setVideodata_and_mask IPT1(IU32, value);
extern IU32 getVideodata_and_mask IPT0();
extern void setVideodata_xor_mask IPT1(IU32, value);
extern IU32 getVideodata_xor_mask IPT0();
extern void setVideolatch_xor_mask IPT1(IU32, value);
extern IU32 getVideolatch_xor_mask IPT0();
extern void setVideobit_prot_mask IPT1(IU32, value);
extern IU32 getVideobit_prot_mask IPT0();
extern void setVideoplane_enable IPT1(IU32, value);
extern IU32 getVideoplane_enable IPT0();
extern void setVideoplane_enable_mask IPT1(IU32, value);
extern IU32 getVideoplane_enable_mask IPT0();
extern void setVideosr_lookup IPT1(IUH *, value);
extern IUH * getVideosr_lookup IPT0();
extern void setVideofwd_str_read_addr IPT1(IUH *, value);
extern IUH * getVideofwd_str_read_addr IPT0();
extern void setVideobwd_str_read_addr IPT1(IUH *, value);
extern IUH * getVideobwd_str_read_addr IPT0();
extern void setVideodirty_total IPT1(IU32, value);
extern IU32 getVideodirty_total IPT0();
extern void setVideodirty_low IPT1(IS32, value);
extern IS32 getVideodirty_low IPT0();
extern void setVideodirty_high IPT1(IS32, value);
extern IS32 getVideodirty_high IPT0();
extern void setVideovideo_copy IPT1(IU8 *, value);
extern IU8 * getVideovideo_copy IPT0();
extern void setVideomark_byte IPT1(IUH *, value);
extern IUH * getVideomark_byte IPT0();
extern void setVideomark_word IPT1(IUH *, value);
extern IUH * getVideomark_word IPT0();
extern void setVideomark_string IPT1(IUH *, value);
extern IUH * getVideomark_string IPT0();
extern void setVideoread_shift_count IPT1(IU32, value);
extern IU32 getVideoread_shift_count IPT0();
extern void setVideoread_mapped_plane IPT1(IU32, value);
extern IU32 getVideoread_mapped_plane IPT0();
extern void setVideocolour_comp IPT1(IU32, value);
extern IU32 getVideocolour_comp IPT0();
extern void setVideodont_care IPT1(IU32, value);
extern IU32 getVideodont_care IPT0();
extern void setVideov7_bank_vid_copy_off IPT1(IU32, value);
extern IU32 getVideov7_bank_vid_copy_off IPT0();
extern void setVideoscreen_ptr IPT1(IU8 *, value);
extern IU8 * getVideoscreen_ptr IPT0();
extern void setVideorotate IPT1(IU32, value);
extern IU32 getVideorotate IPT0();
extern void setVideocalc_data_xor IPT1(IU32, value);
extern IU32 getVideocalc_data_xor IPT0();
extern void setVideocalc_latch_xor IPT1(IU32, value);
extern IU32 getVideocalc_latch_xor IPT0();
extern void setVideoread_byte_addr IPT1(IUH *, value);
extern IUH * getVideoread_byte_addr IPT0();
extern void setVideov7_fg_latches IPT1(IU32, value);
extern IU32 getVideov7_fg_latches IPT0();
extern void setVideoGC_regs IPT1(IUH **, value);
extern IUH ** getVideoGC_regs IPT0();
extern void setVideolast_GC_index IPT1(IU8, value);
extern IU8 getVideolast_GC_index IPT0();
extern void setVideodither IPT1(IU8, value);
extern IU8 getVideodither IPT0();
extern void setVideowrmode IPT1(IU8, value);
extern IU8 getVideowrmode IPT0();
extern void setVideochain IPT1(IU8, value);
extern IU8 getVideochain IPT0();
extern void setVideowrstate IPT1(IU8, value);
extern IU8 getVideowrstate IPT0();

#include "evidgen.h"	/* generated by MkCpuInt */

#ifdef C_VID
extern struct VideoVector C_Video;	/* in (generated) vglfunc.c */

#undef  getVideolatches
#define getVideolatches()	((*(C_Video.GetVideolatches))())
#undef	setVideolatches
#define	setVideolatches(value)	( (*(C_Video.SetVideolatches))(value))
#undef	SetWritePointers
#define SetWritePointers	setWritePointers
#undef	SetReadPointers
#define SetReadPointers	setReadPointers
#undef	SetMarkPointers
#define SetMarkPointers	setMarkPointers
#endif	/* C_VID */
#endif	/* CPU_40_STYLE */

#define write_state EGA_CPU.ega_state.state
#endif // !NEC_98

#define UNCHAINED	0
#define CHAIN2		1
#define CHAIN4		2

IMPORT ULONG sr_lookup[16];

#define N_WRITE_TYPES 24

#if defined(NEC_98)         
#define get_latch(n) (* ((UTINY *) (&NEC98GLOBS->latches) + n))

#define get_latch0 get_latch(0)
#define get_latch1 get_latch(1)
#define get_latch2 get_latch(2)
#define get_latch3 get_latch(3)
#define get_latch01 (* (USHORT *) (&NEC98GLOBS->latches))
#define get_latch23 (* (USHORT *) (&NEC98GLOBS->latches + 2))

#define put_latch(n, value) * ((UTINY *) (&NEC98GLOBS->latches) + n) = (value)

#define put_latch0(value) put_latch(0, value)
#define put_latch1(value) put_latch(1, value)
#define put_latch2(value) put_latch(2, value)
#define put_latch3(value) put_latch(3, value)
#else  // !NEC_98
#ifdef CPU_40_STYLE
extern IU32 latchval;	/* used for following latch macros */
#define get_latch(n) \
	(latchval = getVideolatches(),\
	(* ((UTINY *) (&latchval) + n)))

#define get_latch0 get_latch(0)
#define get_latch1 get_latch(1)
#define get_latch2 get_latch(2)
#define get_latch3 get_latch(3)
#define get_latch01 \
	(latchval = getVideolatches(),  \
	(* (USHORT *) (&latchval)))

#define get_latch23 \
	(latchval = getVideolatches(),  \
	(* (USHORT *) (&latchval + 2)))

#define put_latch(n, value) \
	(* ((UTINY *) (&latchval) + n) = (value), \
	setVideolatches(latchval))

#define put_latch0(value) put_latch(0, value)
#define put_latch1(value) put_latch(1, value)
#define put_latch2(value) put_latch(2, value)
#define put_latch3(value) put_latch(3, value)

#else	/* CPU_40_STYLE */

#define get_latch(n) (* ((UTINY *) (&VGLOBS->latches) + n))

#define get_latch0 get_latch(0)
#define get_latch1 get_latch(1)
#define get_latch2 get_latch(2)
#define get_latch3 get_latch(3)
#define get_latch01 (* (USHORT *) (&VGLOBS->latches))
#define get_latch23 (* (USHORT *) (&VGLOBS->latches + 2))

#define put_latch(n, value) * ((UTINY *) (&VGLOBS->latches) + n) = (value)

#define put_latch0(value) put_latch(0, value)
#define put_latch1(value) put_latch(1, value)
#define put_latch2(value) put_latch(2, value)
#define put_latch3(value) put_latch(3, value)

#endif	/* CPU_40_STYLE */
#endif // !NEC_98

/*
 * macro to do the logical operations on cpu data and the latch values
 */

#define do_logicals(val,latch)  (((latch) & ((val & getVideodata_and_mask()) \
		^ getVideodata_xor_mask())) | (val & ((latch) ^ getVideolatch_xor_mask())))


/* Routines */

extern void ega_mode0_gen_chn_b_write IPT1(byte *,arg1);
extern void ega_mode0_gen_chn_w_write IPT1(byte *,arg1);
extern void ega_mode0_gen_chn_b_fill IPT2(byte *,arg1, byte *,arg2);
extern void ega_mode0_gen_chn_w_fill IPT2(byte *,arg1, byte *,arg2);
extern void ega_mode0_gen_chn_b_move IPT2(byte *,arg1, byte *,arg2);

extern void ega_mode1_gen_chn_b_write IPT1(byte *,arg1);
extern void ega_mode1_gen_chn_w_write IPT1(byte *,arg1);
extern void ega_mode1_gen_chn_b_fill IPT2(byte *,arg1, byte *,arg2);
extern void ega_mode1_gen_chn_w_fill IPT2(byte *,arg1, byte *,arg2);
extern void ega_mode1_gen_chn_b_move IPT2(byte *,arg1, byte *,arg2);
extern void ega_mode1_gen_chn_w_move IPT2(byte *,arg1, byte *,arg2);

extern void ega_mode2_gen_chn_b_write IPT1(byte *,arg1);
extern void ega_mode2_gen_chn_w_write IPT1(byte *,arg1);
extern void ega_mode2_gen_chn_b_fill IPT2(byte *,arg1, byte *,arg2);
extern void ega_mode2_gen_chn_w_fill IPT2(byte *,arg1, byte *,arg2);
extern void ega_mode2_gen_chn_b_move IPT2(byte *,arg1, byte *,arg2);
extern void ega_mode2_gen_chn_w_move IPT2(byte *,arg1, byte *,arg2);

/* 1 plane masked write */
extern void ega_mode0_copy1_mask_b_write0 IPT1(byte *,arg1);
extern void ega_mode0_copy1_mask_b_write1 IPT1(byte *,arg1);
extern void ega_mode0_copy1_mask_b_write2 IPT1(byte *,arg1);
extern void ega_mode0_copy1_mask_b_write3 IPT1(byte *,arg1);

#ifdef VGG
extern boolean vga_mode0_gen_chn4_b_write IPT0();
extern boolean vga_mode0_gen_chn4_w_write IPT0();
extern boolean vga_mode0_gen_chn4_b_fill IPT0();
extern boolean vga_mode0_gen_chn4_w_fill IPT0();
extern boolean vga_mode0_gen_chn4_b_move IPT0();
/* wr 1 */
extern boolean vga_mode1_gen_chn4_b_write IPT0();
extern boolean vga_mode1_gen_chn4_w_write IPT0();
extern boolean vga_mode1_gen_chn4_b_fill IPT0();
extern boolean vga_mode1_gen_chn4_w_fill IPT0();
extern boolean vga_mode1_gen_chn4_b_move IPT0();
extern boolean vga_mode1_gen_chn4_w_move IPT0();
/* wr 2 */
extern boolean vga_mode2_gen_chn4_b_write IPT0();
extern boolean vga_mode2_gen_chn4_w_write IPT0();
extern boolean vga_mode2_gen_chn4_b_fill IPT0();
extern boolean vga_mode2_gen_chn4_w_fill IPT0();
extern boolean vga_mode2_gen_chn4_b_move IPT0();
extern boolean vga_mode2_gen_chn4_w_move IPT0();
/* wr 3 */
extern boolean vga_mode3_gen_chn4_b_write IPT0();
extern boolean vga_mode3_gen_chn4_w_write IPT0();
extern boolean vga_mode3_gen_chn4_b_fill IPT0();
extern boolean vga_mode3_gen_chn4_w_fill IPT0();
extern boolean vga_mode3_gen_chn4_b_move IPT0();
extern boolean vga_mode3_gen_chn4_w_move IPT0();

extern boolean vga_mode3_gen_chn_b_write IPT0();
extern boolean vga_mode3_gen_chn_w_write IPT0();
extern boolean vga_mode3_gen_chn_b_fill IPT0();
extern boolean vga_mode3_gen_chn_w_fill IPT0();
extern boolean vga_mode3_gen_chn_b_move IPT0();
extern boolean vga_mode3_gen_chn_w_move IPT0();

extern boolean vga_mode3_gen_b_write IPT0();
extern boolean vga_mode3_gen_w_write IPT0();
extern boolean vga_mode3_gen_b_fill IPT0();
extern boolean vga_mode3_gen_w_fill IPT0();
extern boolean vga_mode3_gen_b_move IPT0();
extern boolean vga_mode3_gen_w_move IPT0();
#endif /* VGG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\d_oper.h ===
/* 
   d_oper.h

   Define all Decoded Operand Types.
 */

/*
   static char SccsID[]="@(#)d_oper.h	1.1 05 Oct 1993 Copyright Insignia Solutions Ltd.";
 */


/*
   The Decoded Intel Operands.
   ---------------------------

   The naming convention used is similiar to that used in the Intel
   documentation for the 386 or 486 processors. See Appendix A - The
   Opcode Map, for details.

   Each decoded operand has an argument type, identifiers,
   addressability indication and specific values associated with it.
   The exact return values for each operand are listed below. The values
   should only be accessed through the macros provided, the layout may
   be changed in the future. The macros take a pointer to a DECODED_ARG
   as their argument.

   
   Operands are encoded in a two letter plus optional size form:-

      <addressing method><operand type><size>
   
   Addressing methods are denoted by upper case letters, viz:-

   C The operand is a control register.

     register identifier.           DCD_IDENTIFIER
     addressability(Read/Write).    DCD_ADDRESSABILITY

   D The operand is a debug register.

     register identifier.           DCD_IDENTIFIER
     addressability(Read/Write).    DCD_ADDRESSABILITY

   I The operand is an immediate value.

     immediate identifier.          DCD_IDENTIFIER
     addressability(Read/Write).    DCD_ADDRESSABILITY
     the value.                     DCD_IMMED1

   J The operand is a relative offset.

     addressability(Read/Write).    DCD_ADDRESSABILITY
     the value.                     DCD_IMMED1

   K The operand is two immediate values.

     addressability(Read/Write).    DCD_ADDRESSABILITY
     the first value.               DCD_IMMED1
     the second value.              DCD_IMMED2

   M The operand is held in memory.

     addressing mode.               DCD_IDENTIFIER
     sub type of addressing mode.   DCD_SUBTYPE
     addressability(Read/Write).    DCD_ADDRESSABILITY
     segment register identifier.   DCD_SEGMENT_ID
     addressing displacement.       DCD_DISP

   R The operand is a general register.

     register identifier.           DCD_IDENTIFIER
     addressability(Read/Write).    DCD_ADDRESSABILITY

   S The operand is a segment register.

     register identifier.           DCD_IDENTIFIER
     addressability(Read/Write).    DCD_ADDRESSABILITY

   T The operand is a test register.

     register identifier.           DCD_IDENTIFIER
     addressability(Read/Write).    DCD_ADDRESSABILITY
   
   V The operand is a register in the co-processor stack.

     stack addressing mode.              DCD_IDENTIFIER
     addressability(Read/Write).         DCD_ADDRESSABILITY
     stack relative register identifier. DCD_INDEX

   Operand types are denoted by lower case letters, viz:-

   a operand pair in memory, as used by BOUND.
     <size> = 16 word operands.
     <size> = 32 double word operands.

   b byte.

   d double word.

   i floating point integer
     <size>  16 16-bit word integer
     <size>  32 32-bit short integer
     <size>  64 64-bit long integer
     <size>  80 80-bit packed decimal integer

   p far pointer.
     <size> = 16 16:16 ptr (ie 32-bit)
     <size> = 32 16:32 ptr (ie 48-bit)

   r floating point real
     <size> = 32 32-bit short real
     <size> = 64 64-bit long real
     <size> = 80 80-bit temp real

   w word.

   s six-byte descriptor.
   
   Additionally the 'M' addressing method has a form with no operand
   type, but the following optional sizes:-
      
      <size>  14 =  14-byte data block
      <size>  28 =  28-byte data block
      <size>  94 =  94-byte data block
      <size> 108 = 108-byte data block
   
 */

/*
   The argument types:-
 */
#define A_	(UTINY)  0
#define A_Rb	(UTINY)  1 /* aka r8,r/m8                            */
#define A_Rw	(UTINY)  2 /* aka r16,r/m16                          */
#define A_Rd	(UTINY)  3 /* aka r32,r/m32                          */
#define A_Sw	(UTINY)  4 /* aka Sreg                               */
#define A_Cd	(UTINY)  5 /* aka CRx                                */
#define A_Dd	(UTINY)  6 /* aka DRx                                */
#define A_Td	(UTINY)  7 /* aka TRx                                */
#define A_M	(UTINY)  8 /* aka m                                  */
#define A_M14	(UTINY)  9 /* aka m14byte                            */
#define A_M28	(UTINY) 10 /* aka m28byte                            */
#define A_M94	(UTINY) 11 /* aka m94byte                            */
#define A_M108	(UTINY) 12 /* aka m108byte                           */
#define A_Ma16	(UTINY) 13 /* aka m16&16                             */
#define A_Ma32	(UTINY) 14 /* aka m32&32                             */
#define A_Mb	(UTINY) 15 /* aka m8,r/m8,moffs8                     */
#define A_Md	(UTINY) 16 /* aka m32,r/m32,moffs32                  */
#define A_Mi16	(UTINY) 17 /* aka m16int                             */
#define A_Mi32	(UTINY) 18 /* aka m32int                             */
#define A_Mi64	(UTINY) 19 /* aka m64int                             */
#define A_Mi80	(UTINY) 20 /* aka m80dec                             */
#define A_Mp16	(UTINY) 21 /* aka m16:16                             */
#define A_Mp32	(UTINY) 22 /* aka m16:32                             */
#define A_Mr32	(UTINY) 23 /* aka m32real                            */
#define A_Mr64	(UTINY) 24 /* aka m64real                            */
#define A_Mr80	(UTINY) 25 /* aka m80real                            */
#define A_Ms	(UTINY) 26 /* aka m16&32                             */
#define A_Mw	(UTINY) 27 /* aka m16,r/m16,moffs16                  */
#define A_I	(UTINY) 28 /* aka imm8,imm16,imm32                   */
#define A_J	(UTINY) 29 /* aka rel8,rel16,rel32                   */
#define A_K	(UTINY) 30 /* aka ptr16:16,ptr16:32                  */
#define A_V	(UTINY) 31 /* aka ST,push onto ST, ST(i)             */

/* allowable DCD_IDENTIFIER'S for byte registers */
#define A_AL	(USHORT)0
#define A_CL	(USHORT)1
#define A_DL	(USHORT)2
#define A_BL	(USHORT)3
#define A_AH	(USHORT)4
#define A_CH	(USHORT)5
#define A_DH	(USHORT)6
#define A_BH	(USHORT)7

/* allowable DCD_IDENTIFIER'S for word registers */
#define A_AX	(USHORT)0
#define A_CX	(USHORT)1
#define A_DX	(USHORT)2
#define A_BX	(USHORT)3
#define A_SP	(USHORT)4
#define A_BP	(USHORT)5
#define A_SI	(USHORT)6
#define A_DI	(USHORT)7

/* allowable DCD_IDENTIFIER'S for double word registers */
#define A_EAX	(USHORT)0
#define A_ECX	(USHORT)1
#define A_EDX	(USHORT)2
#define A_EBX	(USHORT)3
#define A_ESP	(USHORT)4
#define A_EBP	(USHORT)5
#define A_ESI	(USHORT)6
#define A_EDI	(USHORT)7

/* allowable DCD_IDENTIFIER'S for segment registers */
/* allowable DCD_SEGMENT_ID'S for segment addressing registers */
#define A_ES	(USHORT)0
#define A_CS	(USHORT)1
#define A_SS	(USHORT)2
#define A_DS	(USHORT)3
#define A_FS	(USHORT)4
#define A_GS	(USHORT)5

/* allowable DCD_IDENTIFIER'S for control registers */
#define A_CR0	(USHORT)0
#define A_CR1	(USHORT)1
#define A_CR2	(USHORT)2
#define A_CR3	(USHORT)3
#define A_CR4	(USHORT)4
#define A_CR5	(USHORT)5
#define A_CR6	(USHORT)6
#define A_CR7	(USHORT)7

/* allowable DCD_IDENTIFIER'S for debug registers */
#define A_DR0	(USHORT)0
#define A_DR1	(USHORT)1
#define A_DR2	(USHORT)2
#define A_DR3	(USHORT)3
#define A_DR4	(USHORT)4
#define A_DR5	(USHORT)5
#define A_DR6	(USHORT)6
#define A_DR7	(USHORT)7

/* allowable DCD_IDENTIFIER'S for test registers */
#define A_TR0	(USHORT)0
#define A_TR1	(USHORT)1
#define A_TR2	(USHORT)2
#define A_TR3	(USHORT)3
#define A_TR4	(USHORT)4
#define A_TR5	(USHORT)5
#define A_TR6	(USHORT)6
#define A_TR7	(USHORT)7

/* allowable DCD_IDENTIFIER'S for memory addressing type */
/* <addr size><mode><r/m> */
#define A_1600	  (USHORT) 0 /* [BX + SI]       */
#define A_1601	  (USHORT) 1 /* [BX + DI]       */
#define A_1602	  (USHORT) 2 /* [BP + SI]       */
#define A_1603	  (USHORT) 3 /* [BP + DI]       */
#define A_1604	  (USHORT) 4 /* [SI]            */
#define A_1605	  (USHORT) 5 /* [DI]            */
#define A_1606	  (USHORT) 6 /* [d16]           */
#define A_1607	  (USHORT) 7 /* [BX]            */

#define A_1610	  (USHORT) 8 /* [BX + SI + d8]  */
#define A_1611	  (USHORT) 9 /* [BX + DI + d8]  */
#define A_1612	  (USHORT)10 /* [BP + SI + d8]  */
#define A_1613	  (USHORT)11 /* [BP + DI + d8]  */
#define A_1614	  (USHORT)12 /* [SI + d8]       */
#define A_1615	  (USHORT)13 /* [DI + d8]       */
#define A_1616	  (USHORT)14 /* [BP + d8]       */
#define A_1617	  (USHORT)15 /* [BX + d8]       */

#define A_1620	  (USHORT)16 /* [BX + SI + d16] */
#define A_1621	  (USHORT)17 /* [BX + DI + d16] */
#define A_1622	  (USHORT)18 /* [BP + SI + d16] */
#define A_1623	  (USHORT)19 /* [BP + DI + d16] */
#define A_1624	  (USHORT)20 /* [SI + d16]      */
#define A_1625	  (USHORT)21 /* [DI + d16]      */
#define A_1626	  (USHORT)22 /* [BP + d16]      */
#define A_1627	  (USHORT)23 /* [BX + d16]      */

/* <addr size><mode><r/m> */
#define A_3200	  (USHORT)24 /* [EAX]       */
#define A_3201	  (USHORT)25 /* [ECX]       */
#define A_3202	  (USHORT)26 /* [EDX]       */
#define A_3203	  (USHORT)27 /* [EBX]       */
#define A_3205	  (USHORT)28 /* [d32]       */
#define A_3206	  (USHORT)29 /* [ESI]       */
#define A_3207	  (USHORT)30 /* [EDI]       */

#define A_3210	  (USHORT)31 /* [EAX + d8]  */
#define A_3211	  (USHORT)32 /* [ECX + d8]  */
#define A_3212	  (USHORT)33 /* [EDX + d8]  */
#define A_3213	  (USHORT)34 /* [EBX + d8]  */
#define A_3215	  (USHORT)35 /* [EBP + d8]  */
#define A_3216	  (USHORT)36 /* [ESI + d8]  */
#define A_3217	  (USHORT)37 /* [EDI + d8]  */

#define A_3220	  (USHORT)38 /* [EAX + d32] */
#define A_3221	  (USHORT)39 /* [ECX + d32] */
#define A_3222	  (USHORT)40 /* [EDX + d32] */
#define A_3223	  (USHORT)41 /* [EBX + d32] */
#define A_3225	  (USHORT)42 /* [EBP + d32] */
#define A_3226	  (USHORT)43 /* [ESI + d32] */
#define A_3227	  (USHORT)44 /* [EDI + d32] */

/* <addr size><S=SIB form><mode><base> */
#define A_32S00	  (USHORT)45 /* [EAX + si]       */
#define A_32S01	  (USHORT)46 /* [ECX + si]       */
#define A_32S02	  (USHORT)47 /* [EDX + si]       */
#define A_32S03	  (USHORT)48 /* [EBX + si]       */
#define A_32S04	  (USHORT)49 /* [ESP + si]       */
#define A_32S05	  (USHORT)50 /* [d32 + si]       */
#define A_32S06	  (USHORT)51 /* [ESI + si]       */
#define A_32S07	  (USHORT)52 /* [EDI + si]       */

#define A_32S10	  (USHORT)53 /* [EAX + si + d8]  */
#define A_32S11	  (USHORT)54 /* [ECX + si + d8]  */
#define A_32S12	  (USHORT)55 /* [EDX + si + d8]  */
#define A_32S13	  (USHORT)56 /* [EBX + si + d8]  */
#define A_32S14	  (USHORT)57 /* [ESP + si + d8]  */
#define A_32S15	  (USHORT)58 /* [EBP + si + d8]  */
#define A_32S16	  (USHORT)59 /* [ESI + si + d8]  */
#define A_32S17	  (USHORT)60 /* [EDI + si + d8]  */

#define A_32S20	  (USHORT)61 /* [EAX + si + d32] */
#define A_32S21	  (USHORT)62 /* [ECX + si + d32] */
#define A_32S22	  (USHORT)63 /* [EDX + si + d32] */
#define A_32S23	  (USHORT)64 /* [EBX + si + d32] */
#define A_32S24	  (USHORT)65 /* [ESP + si + d32] */
#define A_32S25	  (USHORT)66 /* [EBP + si + d32] */
#define A_32S26	  (USHORT)67 /* [ESI + si + d32] */
#define A_32S27	  (USHORT)68 /* [EDI + si + d32] */

/* memory address directly encoded in instruction */
#define A_MOFFS16   (USHORT)69 /* [d16] */
#define A_MOFFS32   (USHORT)70 /* [d32] */

/* <addr size><XLT>, xlat addressing form */
#define A_16XLT   (USHORT)71 /* [BX + AL]  */
#define A_32XLT   (USHORT)72 /* [EBX + AL] */

/* <addr size><ST><SRC|DST>, string addressing forms */
#define A_16STSRC (USHORT)73 /* [SI]  */
#define A_32STSRC (USHORT)74 /* [ESI] */
#define A_16STDST (USHORT)75 /* [DI]  */
#define A_32STDST (USHORT)76 /* [EDI] */

/* allowable DCD_SUBTYPE'S for memory addressing sub type */
/* <ss><index> */
#define A_SINO (UTINY) 0 /* No SIB byte */
#define A_SI00 (UTINY) 1 /* EAX       */
#define A_SI01 (UTINY) 2 /* ECX       */
#define A_SI02 (UTINY) 3 /* EDX       */
#define A_SI03 (UTINY) 4 /* EBX       */
#define A_SI04 (UTINY) 5 /* none      */
#define A_SI05 (UTINY) 6 /* EBP       */
#define A_SI06 (UTINY) 7 /* ESI       */
#define A_SI07 (UTINY) 8 /* EDI       */

#define A_SI10 (UTINY) 9 /* EAX x 2   */
#define A_SI11 (UTINY)10 /* ECX x 2   */
#define A_SI12 (UTINY)11 /* EDX x 2   */
#define A_SI13 (UTINY)12 /* EBX x 2   */
#define A_SI14 (UTINY)13 /* undefined */
#define A_SI15 (UTINY)14 /* EBP x 2   */
#define A_SI16 (UTINY)15 /* ESI x 2   */
#define A_SI17 (UTINY)16 /* EDI x 2   */

#define A_SI20 (UTINY)17 /* EAX x 4   */
#define A_SI21 (UTINY)18 /* ECX x 4   */
#define A_SI22 (UTINY)19 /* EDX x 4   */
#define A_SI23 (UTINY)20 /* EBX x 4   */
#define A_SI24 (UTINY)21 /* undefined */
#define A_SI25 (UTINY)22 /* EBP x 4   */
#define A_SI26 (UTINY)23 /* ESI x 4   */
#define A_SI27 (UTINY)24 /* EDI x 4   */

#define A_SI30 (UTINY)25 /* EAX x 8   */
#define A_SI31 (UTINY)26 /* ECX x 8   */
#define A_SI32 (UTINY)27 /* EDX x 8   */
#define A_SI33 (UTINY)28 /* EBX x 8   */
#define A_SI34 (UTINY)29 /* undefined */
#define A_SI35 (UTINY)30 /* EBP x 8   */
#define A_SI36 (UTINY)31 /* ESI x 8   */
#define A_SI37 (UTINY)32 /* EDI x 8   */

/* allowable DCD_IDENTIFIER'S for immediates */
#define A_IMMC  (USHORT)0 /* constant */
#define A_IMMB  (USHORT)1 /* byte */
#define A_IMMW  (USHORT)2 /* word */
#define A_IMMD  (USHORT)3 /* double word */
#define A_IMMWB (USHORT)4 /* word <- byte */
#define A_IMMDB (USHORT)5 /* double word <- byte */

/* allowable DCD_IDENTIFIER'S for co-processor registers */
#define A_ST   (USHORT)0 /* Stack Top */
#define A_STP  (USHORT)1 /* Push onto Stack Top */
#define A_STI  (USHORT)2 /* Stack Register relative to Stack Top */

/* allowable DCD_ADDRESSABILITY'S

   The operand addressability rules, bit encoded as follows:-
      Bit 0 = 1 ==> is source argument.
      Bit 1 = 1 ==> is destination argument.
 */
#define AA_   0
#define AA_R  1
#define AA_W  2
#define AA_RW 3


/*
   Macros to access operand values.
   All take pointer to DECODED_ARG as their argument.
 */

#define DCD_IDENTIFIER(p)     ((p)->identifier)
#define DCD_ADDRESSABILITY(p) ((p)->addressability)
#define DCD_SUBTYPE(p)        ((p)->sub_id)
#define DCD_SEGMENT_ID(p)     ((p)->arg_values[0])
#define DCD_DISP(p)           ((p)->arg_values[1])
#define DCD_IMMED1(p)         ((p)->arg_values[0])
#define DCD_IMMED2(p)         ((p)->arg_values[1])
#define DCD_INDEX(p)          ((p)->arg_values[0])
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\egatrace.h ===
/*
 *
 * SccsID @(#)egatrace.h	1.3 08/10/92 Copyright Insignia Solutions
 *
 *	The file is in binary format, with the following structure:
 *
 *	Adaptor type (byte),then..
 *
 *	op:data,data, etc.
 *	where op can be:
 *
 *	1	Set last_address read to M[data] (32bits)
 *	2	outb port,value (long,byte)
 *	3	outw port,value (long,word)
 *	4	inb port (long)
 *	5	M[addr] = data (long,byte)
 *	6	M[addr] = data (long,word)
 *	7	M[l_addr->h_addr] = data (long,long,byte)
 *	8	M[l_addr->h_addr] = data (long,long,word)
 *	9	M[l_addr->h_addr] = data,data.. (long,long, (h_addr-l_addr+1)*byte)
 *	10	Graphics Tick.
 *	11	Scroll.
 *	12	inw port (long)
 *	13	read byte (set lda to addr)
 *	14	read word (set lda to addr+1)
 *	15	read string (set lda to laddr or haddr dp DF)
 *	254	checkpoint
 *	255	End.
 *
 *	words & longs are Intel/Clipper format - ie low byte first.
 */

#define READ		1
#define OUTB		2
#define OUTW		3
#define INB		4
#define WRITE_BYTE	5
#define WRITE_WORD	6
#define FILL_BYTE	7
#define FILL_WORD	8
#define MOVE_BYTE	9
#define TICK		10
#define SCROLL		11
#define	INW		12
#define	READ_BYTE	13	/* lda = addr */
#define	READ_WORD	14	/* lda = addr + 1 */
#define	READ_STRING	15	/* lda = haddr ?? */

#define	MAX_DUMP_TYPE	15
#define	CHECKPT		254
#define EOFile		255
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\egaports.h ===
/*
 * SccsID = @(#)egaports.h	1.17 10/21/92 Copyright Insignia Solutions Ltd.
 */

#ifdef	EGG
	/* defined in ega_write.c : */
	extern void ega_write_init IPT0();
	extern void ega_write_term IPT0();
	extern void ega_write_routines_update IPT1(CHANGE_TYPE,c);

#ifdef V7VGA
/* The video seven VGA board has extra memory, but the CRTC does not cross
 * bank boundaries unless the counter bank enable bit is set. 
 * This means that the size as far as wrapping and displaying is concerned is 
 * only one bank unless that bit is set.
 */
#define	EGA_PLANE_SIZE	0x20000
#define EGA_PLANE_DISP_SIZE  \
	(extensions_controller.ram_bank_select.as_bfld.counter_bank_enable? \
			EGA_PLANE_SIZE:0x10000)
#else
#define	EGA_PLANE_SIZE	0x10000
#define EGA_PLANE_DISP_SIZE EGA_PLANE_SIZE
#endif /* V7VGA */

	extern void ega_init IPT0();
	extern void ega_term IPT0();
	extern void ega_gc_outb_index IPT2(io_addr,ia,half_word,hw);
#ifdef	HUNTER
	extern int ega_get_line_compare IPT0();
	extern int ega_get_max_scan_lines IPT0();
	extern void ega_set_line_compare IPT1(int,i);
#endif
	IMPORT VOID update_banking IPT0();
	IMPORT VOID set_banking IPT2(IU8, rd_bank, IU8, wrt_bank);

	IMPORT VOID set_mark_funcs IPT0();

	extern int ega_int_enable;

	extern byte *EGA_planes;

#define EGA_plane01 EGA_planes
#define EGA_plane23 (EGA_planes+2)
#define EGA_plane0123 EGA_planes

#define FONT_MEM_SIZE	0x2000		/* max no of bytes in font memory block */
#define FONT_MEM_OFF	0x4000		/* mem offset of next font definition from previous */

#define FONT_BASE_ADDR	2

#define FONT_MAX_HEIGHT	32		/* max font support for 32 scanline high fonts */

#ifdef V7VGA
#define   set_v7_bank_for_seq_chain4( rd_bank, wrt_bank )  *(wrt_bank) =  \
			(((extensions_controller.ram_bank_select.as_bfld.cpu_write_bank_select & 1)<<2) \
			| (miscellaneous_output_register.as_bfld.page_bit_odd_even<<1) \
			| extensions_controller.page_select.as_bfld.extended_page_select); \
										*(rd_bank) =  \
			(((extensions_controller.ram_bank_select.as_bfld.cpu_read_bank_select & 1)<<2) \
			| (miscellaneous_output_register.as_bfld.page_bit_odd_even<<1) \
			| extensions_controller.page_select.as_bfld.extended_page_select)
#endif /* V7VGA */

#endif

#if defined(C_VID) || defined(A2CPU)

/*
 *	C_VID variants use the ports code in e/vga_ports.c
 */

#define Cpu_define_outb( port, func )
#else
/* Declare as Import to remove warnings */
#ifdef ANSI
IMPORT VOID Cpu_define_outb(IU16 adapterID, VOID (*asmFunc) IPT2(io_addr, port, half_word, value));
#else
IMPORT VOID Cpu_define_outb IPT2(IU16, adapterID, VOID (*)(), asmFunc);
#endif /* ANSI */
 
#endif /* C_VID || A2CPU */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\egaread.h ===
/* SccsID = @(#)egaread.h	1.5 08/10/92 Copyright Insignia Solutions */

#ifdef ANSI
extern void ega_read_init(void);
extern void ega_read_term(void);
extern void ega_read_routines_update(void);
extern boolean ega_need_read_op(int);
#else /* ANSI */
extern void ega_read_init();
extern void ega_read_term();
extern void ega_read_routines_update();
extern boolean ega_need_read_op();
#endif /* ANSI */

typedef struct
{
	ULONG	mode;
	UTINY	colour_compare;
	UTINY	colour_dont_care;
} READ_STATE;

IMPORT READ_STATE read_state;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\equip.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Equipment word definitions
 *
 * Description	: The equipment word shows what optional devices are
 *		  attached to the PC
 *
 * Author	: Ross Beresford
 *
 * Notes	: None
 */

/* SccsID[]="@(#)equip.h	1.3 08/10/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

#ifdef	BIGEND
#ifdef	BIT_ORDER1
typedef union 
{
	word all;
	struct {
		HALF_WORD_BIT_FIELD printer_count:2;
		HALF_WORD_BIT_FIELD not_used:1;
		HALF_WORD_BIT_FIELD game_io_present:1;
		HALF_WORD_BIT_FIELD rs232_count:3;
		HALF_WORD_BIT_FIELD unused:1;

		HALF_WORD_BIT_FIELD max_diskette:2; /* BEWARE - 0 RELATIVE */
		HALF_WORD_BIT_FIELD video_mode:2;
		HALF_WORD_BIT_FIELD ram_size:2;
		HALF_WORD_BIT_FIELD coprocessor_present:1;
		HALF_WORD_BIT_FIELD diskette_present:1;
	} bits;
} EQUIPMENT_WORD;
#endif
#ifdef	BIT_ORDER2
typedef union 
{
	word all;
	struct {
		HALF_WORD_BIT_FIELD unused:1;
		HALF_WORD_BIT_FIELD rs232_count:3;
		HALF_WORD_BIT_FIELD game_io_present:1;
		HALF_WORD_BIT_FIELD not_used:1;
		HALF_WORD_BIT_FIELD printer_count:2;

		HALF_WORD_BIT_FIELD diskette_present:1;
		HALF_WORD_BIT_FIELD coprocessor_present:1;
		HALF_WORD_BIT_FIELD ram_size:2;
		HALF_WORD_BIT_FIELD video_mode:2;
		HALF_WORD_BIT_FIELD max_diskette:2; /* BEWARE - 0 RELATIVE */
	} bits;
} EQUIPMENT_WORD;
#endif
#endif

#ifdef	LITTLEND
#ifdef	BIT_ORDER1
typedef union 
{
	word all;
	struct {
		HALF_WORD_BIT_FIELD max_diskette:2; /* BEWARE - 0 RELATIVE */
		HALF_WORD_BIT_FIELD video_mode:2;
		HALF_WORD_BIT_FIELD ram_size:2;
		HALF_WORD_BIT_FIELD coprocessor_present:1;
		HALF_WORD_BIT_FIELD diskette_present:1;

		HALF_WORD_BIT_FIELD printer_count:2;
		HALF_WORD_BIT_FIELD not_used:1;
		HALF_WORD_BIT_FIELD game_io_present:1;
		HALF_WORD_BIT_FIELD rs232_count:3;
		HALF_WORD_BIT_FIELD unused:1;
	} bits;
} EQUIPMENT_WORD;
#endif
#ifdef	BIT_ORDER2
typedef union 
{
	word all;
	struct {
		HALF_WORD_BIT_FIELD diskette_present:1;
		HALF_WORD_BIT_FIELD coprocessor_present:1;
		HALF_WORD_BIT_FIELD ram_size:2;
		HALF_WORD_BIT_FIELD video_mode:2;
		HALF_WORD_BIT_FIELD max_diskette:2; /* BEWARE - 0 RELATIVE */

		HALF_WORD_BIT_FIELD unused:1;
		HALF_WORD_BIT_FIELD rs232_count:3;
		HALF_WORD_BIT_FIELD game_io_present:1;
		HALF_WORD_BIT_FIELD not_used:1;
		HALF_WORD_BIT_FIELD printer_count:2;
	} bits;
} EQUIPMENT_WORD;
#endif
#endif

#define EQUIP_FLAG		BIOS_VAR_START + 0x10

#define	RAM_SIZE_16K	0
#define	RAM_SIZE_32K	1
#define	RAM_SIZE_48K	2
#define	RAM_SIZE_64K	3

#define	VIDEO_MODE_UNUSED	0
#define	VIDEO_MODE_40X25_COLOUR	1
#define	VIDEO_MODE_80X25_COLOUR	2
#define	VIDEO_MODE_80X25_BW	3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\egavideo.h ===
/* SccsID = @(#)egavideo.h      1.13 11/22/93 Copyright Insignia Solutions */

#define ega_char_height   0x485 /* word on IBM, but second byte always 0 */
#define ega_info          0x487 /* lots of useful info. */
#define ega_info3         0x488 /* EGA switches + feature bits. == 0xf9 */
#define EGA_SAVEPTR       0x4A8    /* offset into M of pointer to pointer table for parms etc */
#define VGA_DCC           0x48A /* offset into M of index into dcc table */

/* fields of info & info3: */
#define get_EGA_no_clear() (sas_hw_at_no_check(ega_info) & 0x80)
#define get_EGA_disp() ((sas_hw_at_no_check(ega_info) & 2)>>1)
#define get_EGA_mem() ((sas_hw_at_no_check(ega_info) & 0x60)>>5)
#define get_EGA_cursor_no_emulate() (sas_hw_at_no_check(ega_info) & 1)
#define set_EGA_cursor_no_emulate(val)  \
        sas_store_no_check(ega_info,    \
        (IU8)((sas_hw_at_no_check(ega_info) & 0xfe) | (val)));

#define get_EGA_feature() (sas_hw_at_no_check(ega_info3) & 0xf0)>>4
#define get_EGA_switches() (sas_hw_at_no_check(ega_info3) & 0xf)
/* offset into each entry of each section of ega mode parameters */
#define EGA_PARMS_COLS 0
#define EGA_PARMS_ROWS 1
#define EGA_PARMS_HEIGHT 2
#define EGA_PARMS_LENGTH 3      /* Word */
#define EGA_PARMS_SEQ   5       /* Sequencer regs 1-4 */
#define EGA_PARMS_SEQ_SIZE 4
#define EGA_PARMS_MISC  9       /* Misc. register */
#define EGA_PARMS_CRTC  10      /* CRT regs 0-24 */
#define EGA_PARMS_CRTC_SIZE 25
#define EGA_PARMS_CURSOR 20     /* CRT regs 10 & 11 */
#define EGA_PARMS_ATTR  35      /* Attribute regs 0-19 */
#define EGA_PARMS_ATTR_SIZE 20
#define EGA_PARMS_GRAPH 55      /* Graphics regs 0-8 */
#define EGA_PARMS_GRAPH_SIZE 9
#define EGA_PARMS_SIZE 64       /* Size of one entry in table */
#define FONT_LOAD_MODE 0xB      /* Screen 'mode' to use to load fonts */
/* Location of default ega mode parameters */
#define EGA_PARMS_OFFSET 0x0F09
#define VGA_PARMS_OFFSET 0x0150 /* was F09 but now have more modes in parm table */

#define EGA_PALETTE_ENABLE      0x20

/* Offsets into the save table of the various pointers */

/* Offsets into the save table of the various pointers */
#define PALETTE_OFFSET 4
#define ALPHA_FONT_OFFSET 8
#define GRAPH_FONT_OFFSET 12

/* Location of font definitions */
#if 0
#define EGA_CGMN        0xC2230
#define EGA_CGDDOT      0xC3160
#define EGA_HIFONT      0xC3990         /* 8x16 font for 640x480 ext */
#define EGA_CGMN_OFF    0x2230
#define EGA_CGMN_FDG_OFF 0x3030
#define EGA_CGDDOT_OFF  0x3160
#define EGA_HIFONT_OFF  0x3990
#define EGA_INT1F_OFF   0x3560
#endif

#ifdef VGG
/* Flags controlling extra bits of VGA BIOS, not in EGA one */
#define VGA_FLAGS       0x489
#define S350            0
#define S400            0x10
#define S200            0x80
#define PAL_LOAD_OFF    0x8
#define VGA_MONO        0x4
#define GREY_SCALE      0x2
#define VGA_ACTIVE      0x1
#define get_VGA_flags() sas_hw_at_no_check(VGA_FLAGS)
#define set_VGA_flags(val) sas_store_no_check(VGA_FLAGS, (val))
#define get_VGA_lines() (sas_hw_at_no_check(VGA_FLAGS) & 0x90)
#define set_VGA_lines(val) sas_store_no_check(VGA_FLAGS, (IU8)((sas_hw_at_no_check(VGA_FLAGS) & 0x6f) | (val)))
#define is_GREY()       (sas_hw_at_no_check(VGA_FLAGS) & 2)
#define set_GREY(val)   sas_store_no_check(VGA_FLAGS, (IU8)((sas_hw_at_no_check(VGA_FLAGS) & 0xfd) | (val)))
#define is_PAL_load_off() (sas_hw_at_no_check(VGA_FLAGS) & 0x80)
#define set_PAL_load_off(val) sas_store_no_check(VGA_FLAGS, (IU8)((sas_hw_at_no_check(VGA_FLAGS) & 0xf7) | (val)))
#define is_MONO()       (sas_hw_at_no_check(VGA_FLAGS) & 4)

/* Location of INT10 AX=1b, second stage info table */
#define INT10_1B_DATA   0x01bc
#endif

/*
 * Defines for values indicating real number of scanlines on display
 * These are the values returned by INT10 AH=1B, and are also used
 * internally
 */
#define RS200   0
#define RS350   1
#define RS400   2
#define RS480   3

#ifdef ANSI
extern int get_scanlines(void);
extern sys_addr find_mode_table(int,sys_addr *);
extern sys_addr follow_ptr(sys_addr);
#else
extern int get_scanlines();
extern sys_addr find_mode_table();
extern sys_addr follow_ptr();
#endif /* ANSI */

#ifdef MSWDVR
IMPORT VOID host_mswin_disable IPT0();
#endif

#ifdef V7VGA
IMPORT VOID v7vga_extended_set_mode IPT0();
IMPORT VOID v7vga_func_6f IPT0();
#endif

#ifdef VGG
IMPORT VOID vga_set_palette IPT0();
IMPORT VOID vga_func_12 IPT0();
IMPORT VOID init_vga_dac IPT1( int, table );
#endif

#if defined(NTVDM) && defined(MONITOR)

#define F8x14    0
#define F8x8pt1  1
#define F8x8pt2  2
#define F9x14    3
#define F8x16    4
#define F9x16    5

typedef struct {
        word off;
        word seg;
} NativeFontAddr;

IMPORT NativeFontAddr nativeFontAddresses[6];
#endif  /* NTVDM & MONITOR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\fdisk.h ===
/* @(#)fdisk.h	1.9 02/10/93 Copyright Insignia Solutions Ltd. 
	
FILE NAME	:

	THIS INCLUDE SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER	:
DATE		:


=========================================================================

AMENDMENTS	:

=========================================================================
*/

IMPORT VOID disk_io IPT0();
IMPORT VOID disk_post IPT0();

IMPORT VOID fdisk_inb IPT2(io_addr, port, UTINY *, value);
IMPORT UTINY fdisk_read_dir IPT2(io_addr, port, UTINY *, value);
IMPORT VOID fdisk_inw IPT2(io_addr, port, USHORT *, value);
IMPORT VOID fdisk_outb IPT2(io_addr, port, UTINY, value);
IMPORT VOID fdisk_outw IPT2(io_addr, port, USHORT, value);
IMPORT VOID fdisk_ioattach IPT0();
IMPORT VOID fdisk_iodetach IPT0();
IMPORT VOID fdisk_physattach IPT1(int, driveno);
IMPORT VOID fdisk_reset IPT0();
IMPORT VOID hda_init IPT0();
IMPORT VOID host_fdisk_get_params IPT4(int, driveid, int *, n_cyl,
					int *, n_heads, int *, n_sects);
IMPORT VOID host_fdisk_term IPT0();
IMPORT int host_fdisk_rd IPT4(int, driveid, int,offset, int, nsecs, char *,buf);
IMPORT int host_fdisk_wt IPT4(int, driveid, int,offset, int, nsecs, char *,buf);
IMPORT VOID host_fdisk_seek0 IPT1(int, driveid);
IMPORT int host_fdisk_create IPT2(char *, filename, ULONG, units);

IMPORT VOID patch_rom IPT2(IU32, addr, IU8, val);
IMPORT VOID fast_disk_bios_attach IPT1( int, drive );
IMPORT VOID fast_disk_bios_detach IPT1( int, drive );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\emm.h ===
/* SccsID = @(#)emm.h	1.12 08/31/93 Copyright Insignia Solutions Ltd.
	
FILE NAME	: emm.h

	THIS INCLUDE SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER	: J.P.Box
DATE		: July '88


=========================================================================

AMMENDMENTS	:

=========================================================================
*/
#define	VERSION			0x40	/* memory manager version no.	*/
#define EMM_PAGE_SIZE		0x4000	/* page size  - 16k		*/
#define MAX_NO_HANDLES		255	/* max. no. of handles supported*/
					/* under EMS 4.0 ( 0 - 255 )	*/
#ifdef NTVDM
#define MAX_NO_PAGES		36 + 12 /* below 640KB = 36 pages	*/
					/* above 640KB = 12 pages	*/
#define MAX_ALTREG_SETS 	255	/* allowable alt map register set */
/* one byte represents 8 sets */
#define ALTREG_ALLOC_MASK_SIZE	(MAX_ALTREG_SETS + 7) / 8
#define IMPOSSIBLE_ALTREG_SET	255
#define INTEL_PAGE_SIZE 	0x1000	/* Intel CPU page size		*/
#define INTEL_PARAGRAPH_SIZE	0x10	/* Intel CPU paragraph size	*/
#define EMM_INTEL_PAGE_RATIO	4	/* 1 EMM PAGE = 4 INTEL PAGEs	*/
#define PAGE_PARA_RATIO 	0x100	/* 1 INTEL PAGE = 0x100 PARAs	*/
#define EMM_PAGE_TO_INTEL_PAGE(emm_page)    \
	(emm_page * EMM_INTEL_PAGE_RATIO)
#define SEGMENT_TO_INTEL_PAGE(segment)	    \
	(segment / PAGE_PARA_RATIO)

#else
#define MAX_NO_PAGES		32	/* max. no of locations for	*/
					/* mapping pages, (24 between	*/
					/* 256KB and 640KB and 8 between*/
					/* EM_start and EM_end		*/
#endif

#define MIN_FUNC_NO		0x40	/* Lowest function code		*/
#ifndef PROD
#define	MAX_FUNC_NO		0x5f	/* Highest function code	*/
#else					/* (includes trace options)	*/
#define	MAX_FUNC_NO		0x5d	/* Highest function code	*/
#endif
#define NAME_LENGTH		8	/* Length of handle name	*/
#define UNMAPPED		-1	/* EM page is not mapped in	*/
#define	MSB	     ((IU32)0x80000000)	/* used for pagemap operations	*/
/*
 *	The following 3 defines are used in specifying the current
 * 	or required mapping context
 */
#define EMPTY			-1	/* No page mapped in   		*/
#define LEAVE			-2	/* Leave existing page alone	*/
#define	FREE			-3	/* indicates page map not used 	*/

/*
 *	The following 4 defines are used in the function 26,
 *	Get Expanded Memory Hardware Information call
 */				
#define RAW_PAGE_SIZE		1024	/* size in paragraphs(16 bytes)	*/
#define ALT_REGISTER_SETS	0	/* Alternate register sets	*/
#define DMA_CHANNELS		0	/* No of DMA channels supported	*/
#define DMA_CHANNEL_OPERATION	0	
			

/*	ERROR RETURNS from Top Layer		*/


#ifdef NTVDM
#define EMM_SUCCESS		0
#endif
#define	EMM_HW_ERROR		0x81	/* memory allocation failure	*/
#define BAD_HANDLE		0x83	/* couldn't find handle		*/
#define	BAD_FUNC_CODE		0x84	/* Function code not defined	*/
#define NO_MORE_HANDLES		0x85	/* No handles available		*/
#define MAP_SAVED		0x86	/* Mapping context saved	*/
#define	NOT_ENOUGH_PAGES	0x87	/* Not enough Total pages	*/
#define NO_MORE_PAGES		0x88	/* No more pages available	*/
#define BAD_LOG_PAGE		0x8a	/* Invalid logical page no.	*/
#define BAD_PHYS_PAGE		0x8b	/* Invalid physical page no.	*/
#define MAP_IN_USE		0x8d	/* Mapping context already saved*/
#define NO_MAP			0x8e	/* The handle has no map saved	*/
#define BAD_SUB_FUNC		0x8f	/* Invalid sub-function code	*/
#define NOT_SUPPORTED		0x91	/* This function not supported	*/
#define MOVE_MEM_OVERLAP	0x92	/* Src and dest memory overlap	*/
#define TOO_FEW_PAGES		0x93	/* Not enough pages in handle	*/
#define OFFSET_TOO_BIG		0x95	/* Offset exceeds size of page	*/
#define LENGTH_GT_1M		0x96	/* Region length exceeds 1 Mbyte*/
#define XCHG_MEM_OVERLAP	0x97	/* Src and dest memory overlap	*/
#define BAD_TYPE		0x98	/* Unsupported memory type	*/

#ifdef NTVDM
#define UNSUPPORTED_ALT_REGS	0x9A	/* altreg set is not supported */
#define NO_FREE_ALT_REGS	0x9B	/* no free alt reg available */
#define INVALID_ALT_REG 	0x9d	/* invalid alt reg was given	*/
#endif

#define NO_ALT_REGS		0x9c	/* Alt. map regs not supported	*/
#define HANDLE_NOT_FOUND	0xa0	/* Can't find specified name	*/
#define NAME_EXISTS		0xa1	/* Handle name already used	*/
#define WRAP_OVER_1M		0xa2	/* Attempt made to wrap over 1M	*/
#define BAD_MAP			0xa3	/* Source array contents wrong	*/
#define ACCESS_DENIED		0xa4	/* O/S denies access to this	*/


#ifdef NTVDM
typedef struct	_LIM_CONFIG_DATA {
    boolean  initialized;		/* the structure contains meaningful data */
    unsigned short total_altreg_sets;	/* total alt mapping register set */
    unsigned long backfill;		/* back fill in bytes */
    unsigned short base_segment;	/* back fill starting segment */
    boolean  use_all_umb;		/* use all available UMB for frame */
} LIM_CONFIG_DATA, * PLIM_CONFIG_DATA;

IMPORT	boolean	get_lim_configuration_data(PLIM_CONFIG_DATA lim_config_data);
IMPORT	unsigned short get_no_altreg_sets(void);
IMPORT	unsigned short get_active_altreg_set(void);
IMPORT	boolean altreg_set_ok(unsigned short set);
IMPORT	boolean allocate_altreg_set(unsigned short * set);
IMPORT	boolean deallocate_altreg_set(unsigned short set);
IMPORT	boolean activate_altreg_set(unsigned short set, short * page_in);
IMPORT	short	get_segment_page_no(unsigned short segment);
IMPORT unsigned short get_lim_page_frames(unsigned short * page_table, PLIM_CONFIG_DATA lim_config_data);
IMPORT boolean init_lim_configuration_data(PLIM_CONFIG_DATA lim_config_data);
IMPORT unsigned short get_lim_backfill_segment(void);

#if defined(MONITOR) && !defined(PROD)
IMPORT unsigned short get_emm_page_size(void);
IMPORT unsigned short get_intel_page_size(void);
#endif

#endif


/*	Handle storage area layout
 *
 *	__________________________________________________________
 *	|  N  |  . Handle Name  .  |  Map Context |No.  |No.  |
 *	|_____|____________________|______________|_____|_____|___
 *
 *	name					  nsize
 * 	offset					  <----->
 *	|----->
 *	|	map offset
 *	|-------------------------->
 *	|		page offset
 *	|----------------------------------------->
 *
 *	N		No. of pages in handle
 *	Handle Name	Optional 8 character name
 *	Map Context	A 'snapshot' of the pages currently mapped
 *			requires a 2 byte entry for every physical
 *			page - (optional)
 *	No		Expanded memory page number assigned to handle
 */
#define NSIZE		2
#define	NAME_OFFSET	2
#define	MAP_OFFSET	(NAME_OFFSET + NAME_LENGTH)

/* page_offset is set by the init_expanded_memory() routine */

/*
 *	External declarations for Top level routines
 */

IMPORT void reset_emm_funcs IPT0();
 
/*
 *	External declarations for memory manager routines
 */
 
#ifdef ANSI
extern int		restore_map(short handle_no, unsigned short segment,
				    unsigned short offset,
				    short pages_out[], short pages_in[]);
#else /* ANSI */
extern int		restore_map();
#endif /* ANSI */

IMPORT VOID LIM_b_write   IPT1(sys_addr, intel_addr);
IMPORT VOID LIM_str_write IPT2(sys_addr, intel_addr, ULONG, length);
IMPORT VOID LIM_w_write   IPT1(sys_addr, intel_addr);

IMPORT boolean	handle_ok	IPT1(short, handle_no);
IMPORT short	get_new_handle	IPT1(short, no_pages);
IMPORT int	free_handle	IPT1(short, handle_no);
IMPORT void	print_handle_data IPT1(short, handle_no);
IMPORT short	get_total_handles IPT0();
IMPORT short	get_total_open_handles IPT0();
IMPORT int	reallocate_handle IPT3(short, handle_no,
				       short, old_page_count,
				       short, new_page_count);
#ifndef NTVDM
IMPORT ULONG	page_already_mapped IPT2(short, EM_page_no,
					 unsigned char *, physical_page_no);
#endif


IMPORT short	get_map_size	IPT0();
IMPORT boolean	map_saved	IPT1(short, handle_no);
IMPORT short	get_map_no IPT2(short, handle_no,
				unsigned char, physical_page_no);
IMPORT int	save_map IPT5(short, handle_no,
			      unsigned short, dst_segment,
			      unsigned short, dst_offset,
			      unsigned short, src_segment,
			      unsigned short, src_offset);

IMPORT int copy_exchange_data IPT8(unsigned char, type,
				   short, src_handle,
				   unsigned short, src_seg_page,
				   unsigned short, src_offset,
				   short, dst_handle,
				   unsigned short, dst_seg_page,
				   unsigned short, dst_offset,
				   unsigned long, length);

IMPORT short	alloc_page	IPT0();
IMPORT int	page_status	IPT1(short, EMpage_no);
IMPORT int	free_page	IPT1(short, EM_page_no);
IMPORT int	map_page	IPT2(short, EM_page_no,
				     unsigned char, physical_page_no);
IMPORT int	unmap_page	IPT1(unsigned char, physical_page_no);
IMPORT short	get_no_pages	IPT1(short, handle_no);
IMPORT void	set_no_pages	IPT2(short, handle_no, short, no_pages);
IMPORT short	get_total_pages IPT0();
IMPORT short	get_unallocated_pages IPT0();
IMPORT short	get_no_phys_pages IPT0();

IMPORT int init_expanded_memory IPT2(int, size, int, mem_limit);
IMPORT void free_expanded_memory IPT0();

IMPORT unsigned short get_base_address IPT0();
IMPORT unsigned short get_page_seg IPT1(unsigned char, page_no);

IMPORT short	get_EMpage_no IPT2(short, handle_no, short, logical_page_no);
IMPORT void	set_EMpage_no IPT3(short, handle_no, short, logical_page_no,
				   short, EM_page_no);

IMPORT void	set_map_no IPT3(short, handle_no,
				unsigned char, physical_page_no,
				short, EM_page_no);

IMPORT char *	get_name	IPT1(short, handle_no);
IMPORT void	set_name	IPT2(short, handle_no, char *, new_name);

/*
 *	External declarations for host specific routines
 */
 
IMPORT int	host_initialise_EM	IPT1(short, size);
IMPORT int	host_deinitialise_EM	IPT0();
IMPORT long	host_allocate_storage	IPT1(int, no_bytes);
IMPORT int	host_free_storage	IPT1(long, storage_ID);
IMPORT long	host_reallocate_storage IPT3(long, storage_ID,
			int, size, int, new_size);
IMPORT int	host_map_page 		IPT2(short, EM_page_no,
			unsigned short, segment);
IMPORT int	host_unmap_page		 IPT2(unsigned short, segment,
			short, EM_page_no);
IMPORT short	host_alloc_page		IPT0();
IMPORT int	host_free_page		IPT1(short, EM_page_no);
IMPORT int	host_copy_con_to_con	IPT5(int, length,
			unsigned short, src_seg, unsigned short, src_off,
			unsigned short, dst_seg, unsigned short, dst_off);
IMPORT int	host_copy_con_to_EM	IPT5(int, length,
			unsigned short, src_seg, unsigned short, src_off,
			unsigned short, dst_page, unsigned short, dst_off);
IMPORT int	host_copy_EM_to_con	IPT5(int, length,
			unsigned short, src_page, unsigned short, src_off,
			unsigned short, dst_seg, unsigned short, dst_off);
IMPORT int	host_copy_EM_to_EM	IPT5(int, length,
			unsigned short, src_page, unsigned short, src_off,
			unsigned short, dst_page, unsigned short, dst_off);
IMPORT int	host_exchg_con_to_con	IPT5(int, length,
			unsigned short, src_seg, unsigned short, src_off,
			unsigned short, dst_seg, unsigned short, dst_off);
IMPORT int	host_exchg_con_to_EM	IPT5(int, length,
			unsigned short, src_seg, unsigned short, src_off,
			unsigned short, dst_page, unsigned short, dst_off);
IMPORT int	host_exchg_EM_to_EM	IPT5(int, length,
			unsigned short, src_page, unsigned short, src_off,
			unsigned short, dst_page, unsigned short, dst_off);


#if defined(X86GFX) && defined(NTVDM)

// for x86 platform, we don't have to update logical page
// as they are in a single section of view.
// If we did an unmap as for mips, then mirror pages will
// get unmapped which is not what we want.

#define host_update_logical_page
#define host_patch_one_page     patch_one_page_full

#else /* (NTVDM AND X86GFX) */

#ifndef host_update_logical_page
#define host_update_logical_page	host_unmap_page
#define host_patch_one_page		patch_one_page_full
#endif

#endif /* (NTVDM AND X86GFX) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\fla.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Floppy Disk Adaptor definitions
 *
 * Description	: This file contains those definitions that are used
 *		  by modules calling the FLA as well as thw FLA itself.
 *
 * Author	: Henry Nash
 *
 * Notes	: This file is included by fla.f and should not be
 *		  included directly.
 */

/* @(#)fla.h	1.5 08/26/92 */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

/*
 * The FLA also supports the IBM Digital Output Register (DOR) that is used
 * to control the physical drives.  The bits are assigned as follows:
 *
 *	Bits 0,1   - Drive select between drives 0-3
 *	Bit  2     - Not Reset (ie reset when low)
 *	Bit  3     - Interrupts/DMA  enabled
 *	Bits 4-7   - Motor on for drives 0-3
 *
 */ 

#define DOR_RESET	0x04
#define DOR_INTERRUPTS	0x08

/*
 * The following define the command codes supported by the FDC
 */

#define FDC_READ_TRACK    	0x02    
#define FDC_SPECIFY    		0x03
#define FDC_SENSE_DRIVE_STATUS	0x04
#define FDC_WRITE_DATA	    	0x05    
#define FDC_READ_DATA    	0x06    
#define FDC_RECALIBRATE    	0x07
#define FDC_SENSE_INT_STATUS    0x08
#define FDC_WRITE_DELETED_DATA  0x09
#define FDC_READ_ID    		0x0A
#define FDC_READ_DELETED_DATA   0x0C
#define FDC_FORMAT_TRACK    	0x0D
#define FDC_SEEK    		0x0F
#define FDC_SCAN_EQUAL    	0x11
#define FDC_SCAN_LOW_OR_EQUAL   0x19
#define FDC_SCAN_HIGH_OR_EQUAL  0x1D

#define FDC_COMMAND_MASK        0x1f    /* Bits that specify the command */

/*
 * The following mask specifies the Drive Ready Transition state in
 * Status register 0
 */

#define FDC_DRIVE_READY_TRANSITION 	0xC0

/*
 * The FDC Status register bit positions:
 */

#define FDC_RQM		0x80
#define FDC_DIO		0x40
#define FDC_NDMA	0x20
#define FDC_BUSY	0x10

/*
 * Extra registers required for SFD
 */

#define DIR_DRIVE_SELECT_0      (1 << 0)
#define DIR_DRIVE_SELECT_1      (1 << 1)
#define DIR_HEAD_SELECT_0       (1 << 2)
#define DIR_HEAD_SELECT_1       (1 << 3)
#define DIR_HEAD_SELECT_2       (1 << 4)
#define DIR_HEAD_SELECT_3       (1 << 5)
#define DIR_WRITE_GATE          (1 << 6)
#define DIR_DISKETTE_CHANGE     (1 << 7)

#define IDR_ID_MASK             0xf8

#define DCR_RATE_MASK           0x3
#define DCR_RATE_500            0x0
#define DCR_RATE_300            0x1
#define DCR_RATE_250            0x2
#define DCR_RATE_1000           0x3

#define DSR_RQM                 (1 << 7)
#define DSR_DIO                 (1 << 6)

#define DUAL_CARD_ID            0x50

/*
 * ============================================================================
 * External functions and data
 * ============================================================================
 */

/*
 * The flag that indiactes the FLA is busy, and cannot accept asynchronous
 * commands (eg motor off).
 */

extern boolean fla_busy;
extern boolean fla_ndma;

/*
 * The adaptor functions
 */

extern void fla_init IPT0();
extern void fla_inb IPT2(io_addr, port, half_word *, value);
extern void fla_outb IPT2(io_addr, port, half_word, value);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\flexlmif.h ===
/*[
 *****************************************************************************
 *	Name:			flexlmif.h
 *
 *	Derived From:		(original)
 *
 *	Author:			Bruce Anderson
 *
 *	Created On:		August 1993
 *
 *	Sccs ID:		@(#)flexlmif.h	1.4 02/10/94
 *
 *	Coding Stds:		2.0
 *
 *	Purpose:		interface for Flexlm dialog box
 *
 *	Copyright Insignia Solutions Ltd., 1993. All rights reserved.
 *****************************************************************************
]*/

#ifdef LICENSING
typedef struct
{
	IBOOL	demo_license ;
#ifdef SOFTWINDOWS_AND_SOFTPC	/* Needed when we have SoftPC and SoftWindows */
	IBOOL	softwindows ;
#endif
	CHAR	host_id[13] ;
	CHAR	server_name[64] ; /* Is this big enough? */
	CHAR	serial_number[20] ; 
	IU16	number_users ;
	IU16	date[3] ; /* day,month,year */
	CHAR	authorization[21] ; /* Code with no white space. */
	IU16	port_number ;
	IBOOL	rootinstall;	/* root is being given chance to install a license */
} FLEXLM_DIALOG ;


extern void Flexlm_dialog_popup IPT1( FLEXLM_DIALOG * , data ) ;
extern void Flexlm_dialog_close IPT0( ) ;
extern void Flexlm_dialog_get IPT1( FLEXLM_DIALOG * , data ) ;
extern void Flexlm_dialog_set IPT1( FLEXLM_DIALOG * , data ) ;
extern IBOOL Flexlm_install_license IPT1(IBOOL, rootinst) ;
extern void Flexlm_start_lmgrd IPT0() ;
extern void Flexlm_error_dialog IPT1( CHAR *, name ) ;
extern IBOOL Flexlm_warning_dialog IPT1( CHAR *, name ) ;
extern CHAR *Flexlm_get_lic_filename IPT0( ) ;

/* Callbacks */
extern IBOOL Flexlm_dialog_validate_authorization IPT1( CHAR * , authorization ) ;
extern IBOOL Flexlm_dialog_validate_serial IPT1( CHAR * , serial ) ;
extern IBOOL Flexlm_dialog_cancel_installation IPT0( ) ;
extern IBOOL Flexlm_dialog_install_license IPT0( ) ;
extern IBOOL Flexlm_dialog_quit_SoftPC IPT0( ) ;
#endif	/* LICENSING */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\error.h ===
#ifdef NTVDM
#include "..\..\host\inc\error.h"

#else
#ifndef _INS_ERROR_H
#define _INS_ERROR_H
/*[
	Name:		error.h
	Derived From:	Base 2.0
	Author(s):	M.McCusker and J.D.R. (config msgs)
	Created On:	Unknown
	Sccs ID:	@(#)error.h	1.45 06/22/95
	Purpose:	Define the list of error messages and also the
			interface to the host_error family of functions.
	Notes:		This file is guarded against multiple inclusion.

MUST INCLUDE
	insignia.h

DESCRIPTION
	This file provides an interface into the SoftPC error handling system.

	It defines the main generic base error messages in a large enum.

	It also defines a list of error headers and variants.  3.0 host_error
	Now looks up the error code in a table of ERROR_STRUCTs to find what
	header to print and also in which of the possible variants to format
	the error panel.

	Header types are:-
		EH_WARNING		A warning message
		EH_ERROR		Runtime Error
		EH_CONFIG		Configuration File Problem
		EH_INSTALL		installation File Problem.

	Each variant has up to three separate strings that will be printed on
	the panel.  These strings change function depending on the error
	variant.

	Variant types are:-
		EV_SIMPLE		Simple Error Pnael, Message Only.
		EV_EXTRA_CHAR		Extra Char panel, current default.
		EV_BAD_FILE		Config Error variant bad file.
		EV_SYS_BAD_VALUE	Config System Bad Entry.
		EV_BAD_VALUE		Config bad user config entry.
		EV_BAD_INPUT		Input also variant of EV_EXTRA_CHAR.

	Each variant interprets the ErrData structure a little differently.
	The BAD VALUE/INPUT variants also allow input form the error panel
	into string_1 of the ErrData Structure.  For input if the user hits
	the Continue button on the panel the input filed is strcpy'd to
	string_1.  string_1 MUST be a pointer to an adequately sized char[].
	
		Name			Parameters
		EV_SIMPLE		No parameters required.
		EV_EXTRA_CHAR		1 - Extra Char.
		EV_BAD_FILE		1 - Name of problem file.
		EV_SYS_BAD_VALUE	1 - Current Value of entry.
					2 - Bad Option option name.
		EV_BAD_VALUE		1 - Current value char array (i/o).
					2 - Bad Option Name.
					3 - System Default Value.
		EV_BAD_INPUT		1 - Problem Line (i/o).

IMPORTED DATA
Error Description Tables	ERROR_STRUCT base_errors[];
				ERROR_STRUCT host_errors[];

base and host errors	Tables indexed by the error code that provide
			host_error_ext with the header and variant types.

TYPEDEFS

Parameter to extended error	struct
				{
					char *string_1;
					char *string_2;
					char *string_3;
				} ErrData, *ErrDataPtr;

Error Function Pointers		struct
				{
					SHORT (*error_conf)();
					SHORT (*error)();
					SHORT (*error_ext)();
				} ERRORFUNCS;

Ancillary data per error	struct
				{
					CHAR header;
					CHAR variant;
				} ERROR_STRUCT;

The error code enum,		See header file for details.

GLOBAL FUNCTIONS

Current Error Function Table	IMPORT ERRORFUNCS *working_error_funcs;

Error Macros			host_error_conf(panel, num, opts, extra)
				host_error(num, opts, extra)
				host_error_ext(num, opts, data)

host_error_conf

	SHORT host_error_conf
		(int panel, int errCode, int buttons, char *extraChar)

	host_error_conf will not be supported by the 3.0 generic Motif UIF.
	This call will just be a straight front end to a call of
	host_error_ext.

	See Also host_error_ext.

host_error

	SHORT host_error(int errCode, int buttons, char *extraChar)

	This function loads extraChar into string one of a local ErrData
	structure and calls host_error_ext.
	
	See also host_error_ext.

host_error_ext

	SHORT host_error_ext(int errCode, int buttons, ErrDataPtr errDataP)

	ErrCode is an index into either the base_errors array or the
	host_errors array, 1-999 base, 1001-1999 host_errors.  The header
	code and the variant type is looked up in this array.

	A maximum of three buttons can be or'ed into the buttons parameter
	which are: ERR_QUIT, ERR_CONT, ERR_RESET, ERR_DEF & ERR_CONFIG any
	three of these can be used, NB ERR_CONFIG and ERR_DEF are exactly the
	same ERR_CONFIG is provided for backwards compatibility.  The
	following macros are provided for convenience:-
		ERR_QU_CO_RE
		ERR_QU_CO_DE
		ERR_QU_CO
		ERR_QU_RE
		ERR_QU_DE
		ERR_STANDARD		Here for compatibility

	After the panel is displayed, and the user chooses an option button is
	interpreted as follows:-
		ERR_QUIT  - Call terminate(), doesn't return.
		ERR_CONT  - For some variants strcpy the input field.
		ERR_RESET - Calls Reboot.
		ERR_DEF } - No action.
		ERR_CONFIG}

	Finally, host_error_ext returns the option the user selected.

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
]*/

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * Button bit mask values
 */

#define	ERR_QUIT	1
#define	ERR_CONT	2
#define	ERR_RESET	4
#define	ERR_DEF		8
#define	ERR_CONFIG	8

#define	ERR_QU_CO_RE	( ERR_QUIT | ERR_CONT | ERR_RESET )
#define	ERR_QU_CO_DE	( ERR_QUIT | ERR_CONT | ERR_DEF )
#define	ERR_QU_CO	( ERR_QUIT | ERR_CONT )
#define	ERR_QU_RE	( ERR_QUIT | ERR_RESET )
#define	ERR_QU_DE	( ERR_QUIT | ERR_DEF )

#define	ERR_STANDARD	( ERR_QU_CO_RE )	/* here for compatibility */

/*
 * The following are the Generic Error messages displayed by
 * SoftPC.  Host Specific messages are defined in xxxx_error.h
 * where xxxx is the machine ID.
 */

/*
   New messages MUST be added to the end of the list, or replace a
   spare number. This rule prevents undue change to message catalogues,
   both Insignia-generated ones and translations provided by OEMs.
  
   YOU MUST UPDATE message.c AND err_tble.c
   YOU MUST REPORT A HOST IMPACT ON MESSAGE CATALOGUES
 */

typedef enum 
{
	EG_BAD_OP=0,
	EG_SLAVEPC_NO_LOGIN,
	EG_SLAVEPC_NO_RESET,	
	EG_SLAVEPC_BAD_LINE,
	EG_MISSING_HDISK,  
	EG_REAL_FLOPPY_IN_USE,
	EG_HDISK_BADPATH,	  
	EG_HDISK_BADPERM,	 
	EG_HDISK_INVALID,
	EG_NO_ROOM_FOR_LIM,
	EG_HDISK_CANNOT_CREATE,
	EG_HDISK_READ_ONLY, 
	EG_OWNUP,	 	     
	EG_FSA_NOT_FOUND,     
	EG_FSA_NOT_DIRECTORY,
	EG_FSA_NO_READ_ACCESS,  
	EG_NO_ACCESS_TO_FLOPPY, 
	EG_NO_ROM_BASIC,
	EG_SLAVE_ON_TTYA,  
	EG_TTYA_ON_SLAVE, 
	EG_SAME_HD_FILE, 
	EG_DFA_BADOPEN,
	EG_EXPANDED_MEM_FAILURE,	  
	EG_MISSING_FILE,            
	EG_CONT_RESET,		     
	EG_INVALID_EXTENDED_MEM_SIZE,
	EG_INVALID_EXPANDED_MEM_SIZE,
	EG_INVALID_AUTOFLUSH_DELAY,
	EG_INVALID_VIDEO_MODE,
	EG_NO_GRAPHICS,		/* Dumb terminal using spare slot */
	EG_REZ_UPDATE,		
	EG_NO_REZ_UPDATE,
	EG_HFX_NO_USE,
	EG_HFX_NO_NET,
	EG_HFX_IN_USE,
	EG_HFX_LOST_DIR,
	EG_HFX_NOT_DIR,
	EG_HFX_CANT_READ,
	EG_HFX_DRIVE_NO_USE,
	EG_HFX_DRIVE_ILL,
	EG_NO_FONTS,	
	EG_UNSUPPORTED_VISUAL,
	EG_NO_SOUND,
	EG_SIG_PIPE,         
	EG_MALLOC_FAILURE,  
	EG_NO_REAL_FLOPPY_AT_ALL,
	EG_SYS_MISSING_SPCHOME,
	EG_SYS_MISSING_FILE,
	EG_BAD_OPTION, 
	EG_WRITE_ERROR,		/* Dumb terminal using spare slot */
	EG_CONF_MISSING_FILE,
	EG_CONF_FILE_WRITE,
	EG_DEVICE_LOCKED,
	EG_DTERM_BADOPEN,
	EG_DTERM_BADTERMIO,
	EG_BAD_COMMS_NAME,
	EG_BAD_VALUE,
	EG_SYS_BAD_VALUE,
	EG_SYS_BAD_OPTION,
	EG_SYS_CONF_MISSING,
	EG_BAD_CONF,
	EG_CONF_MISSING,
	EG_BAD_MSG_CAT,
	EG_DEMO_EXPIRED,
	EG_GATE_A20,
	EG_NO_LOCKD,
	EG_DATE_FWD,
	EG_DATE_BACK,

	EG_NOT_CHAR_DEV,  /*  New generic floppy error.   GM */
	EG_MSW_256_COLOURS,
	EG_MSW_16_COLOURS,

	EG_HDISK_LOCKED,
	EG_UNKNOWN_LOCK,
	EG_NO_TERM_DESCR,
	EG_DEFAULT_TERM,

	EG_ST_BAD_OPTION,	/* New Serial Terminal config error messages */
	EG_ST_BAD_CONF,
	EG_ST_CONF_MISSING,

	EG_UNSUPPORTED_DEPTH,	/* BCN 1622 */
	
	EG_INSUF_MEMORY,

	EG_BAD_DISK_READ,
	EG_BAD_DISK_WRITE,
	
	EG_LICENSE_FAILURE,	/* Licensing error messages. BCN XXXX */
	EG_LICENSE_EXPIRED,
	EG_LICENSE_LOST,
	EG_3_MINS_LEFT,
	EG_TIMES_UP,
	EG_UNAUTHORISED,
	EG_LICENSE_EXCEEDED,
	EG_INSTALL_ON_SERVER,
	EG_FAILED_LMGRD,
	EG_FAILED_INITTAB,
	EG_UPDATE_LICFILE_FAILED,
	EG_WRONG_MSWDVR,
#ifdef DOS_APP_LIC
	EG_DAL_TOO_MUCH_NESTING,
	EG_DAL_LIC_EXPIRED,
	EG_DAL_LIC_EXCEEDED,
#endif
	EG_FAILED_RCLOCAL,

#ifdef SOFTWIN_API
	EG_API_MISMATCH,
#endif /* SOFTWIN_API */

	EG_OVERWRITE_DRIVE_C,

	EG_NO_SNDBLST_SUPPORT,
	EG_DIRECTORY,
#ifdef HOST_HELP
	EG_HELP_ERROR,
	EG_HELP_NOT_INSTALLED,
#endif /* HOST_HELP */
#ifdef SECURE
	EG_SYS_INSECURE,
#endif

	EG_INFINITE_LOOP,
	EG_DRIVER_MISMATCH,
	EG_MISSING_INS_VXD,
	NUM_BASE_ERRORS
} base_error_type;

/* The error message EG_HDISK_NOT_FOUND was a duplicate of EG_MISSING_HDISK
** so was removed. This define is in case EG_HDISK_NOT_FOUND is being used
** in anyone's host.
*/
#define       EG_HDISK_NOT_FOUND	EG_MISSING_HDISK

typedef struct
{
	char header;
	char varient;
} ERROR_STRUCT;

typedef enum
{
	EH_WARNING=0,
	EH_ERROR,
	EH_CONFIG,
	EH_INSTALL,
	EH_LAST
} base_error_headers;

typedef enum
{
	EV_SIMPLE=0,
	EV_EXTRA_CHAR,
	EV_BAD_FILE,
	EV_SYS_BAD_VALUE,
	EV_BAD_VALUE,
	EV_BAD_INPUT,
	EV_LAST
} base_error_varients;

/* 
 * 'string_1' is always used for input when necessary.  When it is
 * used for input it must point to a buffer with ample space.
 */
typedef struct
{
	char *string_1;	/* this must be a pointer to an ample buffer */
	char *string_2;
	char *string_3;
} ErrData, *ErrDataPtr;

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#ifdef ANSI

typedef struct
{
	SHORT (*error_conf)(int, int, int, char *);
	SHORT (*error)(int, int, char *);
	SHORT (*error_ext)(int, int, ErrDataPtr);
} ERRORFUNCS;

#else /* ANSI */

typedef struct
{
	SHORT (*error_conf)();
	SHORT (*error)();
	SHORT (*error_ext)();
} ERRORFUNCS;

#endif /* ANSI */

IMPORT ERRORFUNCS *working_error_funcs;

#define host_error_conf(panel, num, opts, extra)\
		(*working_error_funcs->error_conf)(panel, num, opts, extra)

#define host_error(num, opts, extra)\
		(*working_error_funcs->error)(num, opts, extra)

#define host_error_ext(num, opts, data)\
		(*working_error_funcs->error_ext)(num, opts, data)
/* Prototype for the host_get_system_error_function which
 * sits in the source code. Added 8.3.95
 */
IMPORT char * host_get_system_error IPT3 (char *, filename, int, line, int, errno);


/*
 * Undefine these GWI defines if the host isn't using the GWI interface
 */

#include	"host_gwi.h"

#endif /* _INS_ERROR_H */
#endif /* ntvdm */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\floppy.h ===
/*
 * VPC-XT Revision 2.0
 *
 * Title	: High Density Floppy BIOS Definitions
 *
 * Description	: Definitions used in the floppy diskette BIOS emulation
 *
 * Author	: Ross Beresford
 *
 * Notes	: 
 *		 
 *		
 *		  
 */

/* @(#)floppy.h	1.9 08/25/93 */


/*
 *	FLOPPY DATA AREAS: we maintain the same data variables as the real
 *	BIOS in case applications know of their significance and use them.
 */

/*
 *	THE SEEK STATUS:
 *
 *	+---+---+---+---+---+---+---+---+
 *	| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 *	+---+---+---+---+---+---+---+---+
 *        ^   ^   ^   ^   ^   ^   ^   ^
 *        |   |   |   |   |   |   |   |
 *        |   |   |   |   |   |   |   +- set if drive A needs recalibrating
 *        |   |   |   |   |   |   |
 *        |   |   |   |   |   |   +----- set if drive B needs recalibrating
 *        |   |   |   |   |   |
 *        |   |   |   |   |   +--------- (set if drive C needs recalibrating)
 *        |   |   |   |   |
 *        |   |   |   |   +------------- (set if drive D needs recalibrating)
 *        |   |   |   |
 *        |   |   |   +----------------- )
 *        |   |   |                      )
 *        |   |   +--------------------- )- unused
 *        |   |                          )
 *        |   +------------------------- )
 *        |
 *        +----------------------------- set when an interrupt is acknowledged
 */

#define SEEK_STATUS		(BIOS_VAR_START + 0x3e)

#define SS_RECAL_ON_0		(1 << 0)
#define SS_RECAL_ON_1		(1 << 1)
#define SS_RECAL_ON_2		(1 << 2)
#define SS_RECAL_ON_3		(1 << 3)
#define	SS_RECAL_MASK		(SS_RECAL_ON_0|SS_RECAL_ON_1| \
					SS_RECAL_ON_2|SS_RECAL_ON_3)
#define SS_INT_OCCURRED		(1 << 7)

/*
 *	THE MOTOR STATUS: this variable reflects the state of the 
 *	Digital Output Register in the floppy adapter
 *
 *	+---+---+---+---+---+---+---+---+
 *	| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 *	+---+---+---+---+---+---+---+---+
 *        ^   ^   ^   ^   ^   ^   ^   ^
 *        |   |   |   |   |   |   |   |
 *        |   |   |   |   |   |   |   +- set if drive A motor is running
 *        |   |   |   |   |   |   |                                   
 *        |   |   |   |   |   |   +----- set if drive B motor is running
 *        |   |   |   |   |   |                                   
 *        |   |   |   |   |   +--------- (set if drive C motor is running)
 *        |   |   |   |   |                                   
 *        |   |   |   |   +------------- (set if drive D motor is running)
 *        |   |   |   |                                   
 *        |   |   |   +----------------- )   number of the drive that is
 *        |   |   |                      )-  currently selected in the
 *        |   |   +--------------------- )   floppy adapter
 *        |   |                                   
 *        |   +------------------------- unused
 *        |                                   
 *        +----------------------------- set during a write operation
 */

#define MS_MOTOR_0_ON		(1 << 0)
#define MS_MOTOR_1_ON		(1 << 1)
#define MS_MOTOR_2_ON		(1 << 2)
#define MS_MOTOR_3_ON		(1 << 3)
#define	MS_MOTOR_ON_MASK	(MS_MOTOR_0_ON|MS_MOTOR_1_ON| \
						MS_MOTOR_2_ON|MS_MOTOR_3_ON)
#define	MS_DRIVE_SELECT_0	(1 << 4)
#define	MS_DRIVE_SELECT_1	(1 << 5)
#define	MS_DRIVE_SELECT_MASK	(MS_DRIVE_SELECT_0|MS_DRIVE_SELECT_1)
#define MS_WRITE_OP		(1 << 7)

/* 
 *	THE MOTOR COUNT: this counter shows how many timer ticks must 
 *	elapse before the drive motors can be turned off. The timer
 *	interrupt handler decrements this value once per timer tick.
 */

#define MC_MAXIMUM		(~0)

/*
 *	THE FLOPPY STATUS:
 *
 *	+---+---+---+---+---+---+---+---+
 *	| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 *	+---+---+---+---+---+---+---+---+
 *        ^   ^   ^   ^   ^   ^   ^   ^
 *        |   |   |   |   |   |   |   |
 *        |   |   |   |   |   |   |   +- )
 *        |   |   |   |   |   |   |      )
 *        |   |   |   |   |   |   +----- )   0 if the last operation was
 *        |   |   |   |   |   |          )-  carried out successfully;
 *        |   |   |   |   |   +--------- )   otherwise one of various
 *        |   |   |   |   |              )   error values
 *        |   |   |   |   +------------- )
 *        |   |   |   |                                   
 *        |   |   |   +----------------- set when there is a CRC error
 *        |   |   |                      
 *        |   |   +--------------------- set when the FDC has a bug
 *        |   |                                   
 *        |   +------------------------- set when a seek terminates abnormally
 *        |                                   
 *        +----------------------------- set when there is a time out
 */

#define FLOPPY_STATUS		(BIOS_VAR_START + 0x41)

#define FS_OK           	0x00
#define FS_BAD_COMMAND         	0x01
#define FS_BAD_ADDRESS_MARK    	0x02
#define FS_WRITE_PROTECTED      0x03
#define FS_SECTOR_NOT_FOUND    	0x04
#define FS_MEDIA_CHANGE		0x06
#define FS_DMA_ERROR         	0x08
#define FS_DMA_BOUNDARY        	0x09
#define FS_MEDIA_NOT_FOUND	0x0C

#define FS_CRC_ERROR         	(1 << 4)
#define FS_FDC_ERROR         	(1 << 5)
#define FS_SEEK_ERROR          	(1 << 6)
#define FS_TIME_OUT            	(1 << 7)

#define	FS_NONSENSICAL		(~0)

/*
 *	THE FDC STATUS: this array stores the result bytes returned from
 *	the floppy disk controller after a command has been executed. 
 */

/*
 *	THE RATE STATUS: this variable controls data rate scanning, 
 *	which is used to determine which of various types of media is 
 *	actually installed in a floppy drive.
 *
 *	+---+---+---+---+	Current data rate (reflects status of the
 *	| 7 | 6 | 5 | 4 |	Digital Control Register in the floppy
 *	+---+---+---+---+	adapter)
 *
 *	+---+---+---+---+
 *	| 3 | 2 | 1 | 0 |	Last data rate to try
 *	+---+---+---+---+
 *        ^   ^   ^   ^
 *        |   |   |   |
 *        |   |   |   +- unused
 *        |   |   |      
 *        |   |   +----- unused
 *        |   |          
 *        |   +--------- )  00 = 500 kbs data rate
 *        |              )- 01 = 300 kbs data rate
 *        +------------- )  10 = 250 kbs data rate
 *                          11 = 1000 kbs data rate
 *
 *	next_rate() is used to cycle through the possible data rates
 */

#define RATE_STATUS		(BIOS_VAR_START + 0x8B)

#define	RS_300	(1 << 6)
#define	RS_250	(1 << 7)
#define	RS_500	(0)
#define	RS_1000	(3 << 6)
#define	RS_MASK	(RS_300 | RS_250)

#ifdef	NTVDM
/* On NT, don't cycle through RS_1000. Why? */
#define	next_rate(rate) (rate == RS_1000? RS_500: \
			(rate == RS_500 ? RS_250: \
			(rate == RS_250 ? RS_300: RS_500)))
#else
#define	next_rate(rate)	(rate == RS_500 ? RS_250: \
			(rate == RS_250 ? RS_300: \
			(rate == RS_300 ? RS_1000: RS_500)))
#endif

/*
 *	Unused high density floppy variables
 */

#define HF_STATUS		(BIOS_VAR_START + 0x8C)
#define HF_ERROR		(BIOS_VAR_START + 0x8D)
#define HF_INT_FLAG		(BIOS_VAR_START + 0x8E)

/*
 *	THE DRIVE CAPABILITY INDICATORS: this variable describes what
 *	features are supported by floppy drives A and B
 *
 *	NB if Drive A supports 80 tracks, the BIOS assumes that the
 *	floppy adapter is a dual fixed disk/diskette adapter
 *
 *	+---+---+---+---+
 *	| 7 | 6 | 5 | 4 |	Drive B
 *	+---+---+---+---+	
 *
 *	+---+---+---+---+
 *	| 3 | 2 | 1 | 0 |	Drive A
 *	+---+---+---+---+
 *        ^   ^   ^   ^
 *        |   |   |   |
 *        |   |   |   +- set if drive supports 80 tracks
 *        |   |   |      
 *        |   |   +----- set for a multiple data rate drive
 *        |   |          
 *        |   +--------- set if the drive capability is determined
 *        |              
 *        +------------- unused
 *
 */

#define DRIVE_CAPABILITY	(BIOS_VAR_START + 0x8F)

#define DC_80_TRACK	(1 << 0)
#define DC_DUAL		DC_80_TRACK
#define DC_MULTI_RATE	(1 << 1)
#define DC_DETERMINED	(1 << 2)
#define	DC_MASK		(DC_80_TRACK|DC_MULTI_RATE|DC_DETERMINED)

/*
 *	THE DRIVE STATUS: one byte each for drive A and B; within the
 *	BIOS functions, the format is as follows:
 *
 *      <- media bits -> <- drive bits ->
 *       
 *	+---+---+---+---+---+---+---+---+
 *	| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 *	+---+---+---+---+---+---+---+---+
 *        ^   ^   ^   ^   ^   ^   ^   ^
 *        |   |   |   |   |   |   |   |
 *        |   |   |   |   |   |   |   +- set if drive supports 80 tracks
 *        |   |   |   |   |   |   |      
 *        |   |   |   |   |   |   +----- set for a multiple data rate drive
 *        |   |   |   |   |   |          
 *        |   |   |   |   |   +--------- set if capability is determined
 *        |   |   |   |   |              
 *        |   |   |   |   +------------- unused
 *        |   |   |   |                                   
 *        |   |   |   +----------------- set when media is determined
 *        |   |   |                      
 *        |   |   +--------------------- set when double stepping is required
 *        |   |                                   
 *        |   +------------------------- )  00 = 500 kbs data rate
 *        |                              )- 01 = 300 kbs data rate
 *        +----------------------------- )  10 = 250 kbs data rate
 *                                          11 = 1000 kbs data rate
 *
 *
 *	Outside the BIOS functions, the status is converted to a different
 *	format to be compatible with earlier releases of the BIOS
 *       
 *	+---+---+---+---+---+---+---+---+
 *	| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 *	+---+---+---+---+---+---+---+---+
 *        ^   ^   ^   ^   ^   ^   ^   ^
 *        |   |   |   |   |   |   |   |
 *        |   |   |   |   |   |   |   +- ) 000 = 360K in 360K undetermined
 *        |   |   |   |   |   |   |      ) 001 = 360K in 1.2M undetermined
 *        |   |   |   |   |   |   |      ) 010 = 1.2M in 1.2M undetermined
 *        |   |   |   |   |   |   +----- ) 011 = 360K in 360K media determined
 *        |   |   |   |   |   |          ) 100 = 360K in 1.2M media determined
 *        |   |   |   |   |   |          ) 101 = 1.2M in 1.2M media determined
 *        |   |   |   |   |   |          ) 110 = unused
 *        |   |   |   |   |   +--------- ) 111 = drive invalid
 *        |   |   |   |   |              
 *        |   |   |   |   +------------- unused
 *        |   |   |   |                                   
 *        |   |   |   +----------------- set when media is determined
 *        |   |   |                      
 *        |   |   +--------------------- set when double stepping is required
 *        |   |                                   
 *        |   +------------------------- )  00 = 500 kbs data rate
 *        |                              )- 01 = 300 kbs data rate
 *        +----------------------------- )  10 = 250 kbs data rate
 *                                          11 = 1000 kbs data rate
 */

#define FDD_STATUS		(BIOS_VAR_START + 0x90)

#define FS_MEDIA_DET		(1 << 4)
#define FS_DOUBLE_STEP		(1 << 5)

#define FS_360_IN_360		0x0
#define FS_360_IN_12		0x1
#define FS_12_IN_12		0x2
#define FS_288_IN_288		0x3
#define FS_DRIVE_SICK       	0x7

#define	media_determined(state)	((state & 3) + 3)

/*
 *	THE DRIVE TRACK: one byte each for drives A and B; records
 *	which track each drive last did a seek to
 *
 *	FDD_CLONK_TRACK and FDD_JUDDER_TRACK are track numbers used
 *	in the determination of track capacity
 */

#define FDD_TRACK		(BIOS_VAR_START + 0x94)

#define FDD_CLONK_TRACK		48
#define FDD_JUDDER_TRACK	10

/*
 *	DISKETTE PARAMETER TABLES: the disk pointer in the interrupt
 *	vector table addresses a table of floppy disk characteristics
 *	applying to the current drive and media; the entries in the
 *	table are referenced by offsets
 *
 *	Standard parameter tables are established in the ROM for common
 *	media and drive types; these are referenced from a drive type
 *	table also in ROM
 */

#define DISK_POINTER_ADDR	0x78

#define	DT_SPECIFY1		0	/* 1st FDC specify byte */
#define	DT_SPECIFY2		1	/* 2nd FDC specify byte */
#define	DT_MOTOR_WAIT		2	/* motor off wait time */
#define	DT_N_FORMAT		3	/* bytes/sector indicator */
#define	DT_LAST_SECTOR		4	/* sectors/track */
#define DT_GAP_LENGTH		5	/* gap length */
#define DT_DTL			6	/* data length */
#define DT_FORMAT_GAP_LENGTH	7	/* gap length for format */
#define DT_FORMAT_FILL_BYTE	8	/* fill byte for format */
#define DT_HEAD_SETTLE		9	/* head settle time/ms */
#define DT_MOTOR_START		10	/* motor start time/s */
#define DT_MAXIMUM_TRACK	11	/* maximum track number */
#define DT_DATA_TRANS_RATE	12	/* data transfer rate */

#define	DT_SIZE_OLD		11	/* old table size */
#define	DT_SIZE_NEW		13	/* new table size */

#define MOTOR_WAIT		0x25	/* standard motor off wait time */

#define	DR_CNT			9	/* number of drive types */
#define	DR_SIZE_OF_ENTRY	(sizeof(half_word) + sizeof(word))
					/* size of drive type entry */
#define	DR_WRONG_MEDIA		(1 << 7)/* set if "wrong" media for drive type */

/*
 *	SFD BIOS FLOPPY DISK EQUATES
 */


/*
 *	Drive intelligence level (returned by READ DASD TYPE function)
 */

#define	DRIVE_IQ_UNKNOWN	0
#define DRIVE_IQ_NO_CHANGE_LINE 1
#define DRIVE_IQ_CHANGE_LINE	2
#define DRIVE_IQ_RESERVED	3


/*
 *	Maximum track accessible for drive types
 */

#define	MAXIMUM_TRACK_ON_360	39
#define	MAXIMUM_TRACK_ON_12	79
#define	MAXIMUM_TRACK_ON_720	79
#define	MAXIMUM_TRACK_ON_144	79


/*
 *	Media types
 */

#define	MEDIA_TYPE_360_IN_360		1
#define	MEDIA_TYPE_360_IN_12		2
#define	MEDIA_TYPE_12_IN_12		3
#define	MEDIA_TYPE_720_IN_720		4
#define	MEDIA_TYPE_720_IN_144		5
#define	MEDIA_TYPE_144_IN_144		6

/*
 *	Floppy disk controller status register formats
 */

#define	ST0_UNIT_SELECT_0		(1 << 0)
#define	ST0_UNIT_SELECT_1		(1 << 1)
#define	ST0_HEAD_ADDRESS		(1 << 2)
#define	ST0_NOT_READY			(1 << 3)
#define	ST0_EQUIPMENT_CHECK		(1 << 4)
#define	ST0_SEEK_END			(1 << 5)
#define	ST0_INTERRUPT_CODE_0		(1 << 6)
#define	ST0_INTERRUPT_CODE_1		(1 << 7)

#define	ST1_MISSING_ADDRESS_MARK	(1 << 0)
#define	ST1_NOT_WRITEABLE		(1 << 1)
#define	ST1_NO_DATA			(1 << 2)
#define	ST1_UNUSED_AND_ALWAYS_0_0	(1 << 3)
#define	ST1_OVERRUN			(1 << 4)
#define	ST1_DATA_ERROR			(1 << 5)
#define	ST1_UNUSED_AND_ALWAYS_0_1	(1 << 6)
#define	ST1_END_OF_CYLINDER		(1 << 7)


/*
 *	DMA adapter command codes
 */

#define BIOS_DMA_READ	0x46	/* == write to memory */
#define BIOS_DMA_WRITE	0x4A	/* == read from memory */
#define BIOS_DMA_VERIFY	0x42	/* == verify against memory */

/*
 *	Number of floppy drives that can really be supported
 */

#if defined(NEC_98)
#define MAX_FLOPPY      0x1a
#else  // !NEC_98
#define MAX_FLOPPY	0x02
#endif // !NEC_98

/*
 *	Special value of sectors transferred count
 */

#define	IGNORE_SECTORS_TRANSFERRED	-1

/*
 *	One second in motor time units (1/8 seconds)
 */

#define	WAIT_A_SECOND	 8

/*
 *	Minimum head settle times in milliseconds
 */

#define	HEAD_SETTLE_360	20
#define	HEAD_SETTLE_12	15

/*
 *	FDC settle time in microseconds
 */

#define	FDC_SETTLE	45

/*
 *	Number of times to poll FDC for correct direction and controller
 *	ready before timing out
 */

#define FDC_TIME_OUT	10

/*
 *	SFD BIOS FLOPPY FUNCTION DEFINITIONS
 */

/*
 *	Primary external functions
 */

#ifdef ANSI
extern void diskette_io(void);
extern void diskette_int(void);
extern void diskette_post(void);
#else
extern void diskette_io();
extern void diskette_int();
extern void diskette_post();
#endif /* ANSI */

/*
 *	Secondary external functions
 */

#ifdef ANSI
extern void fl_disk_reset(int);
extern void fl_disk_status(int);
extern void fl_disk_read(int);
extern void fl_disk_write(int);
extern void fl_disk_verify(int);
extern void fl_disk_format(int);
extern void fl_fnc_err(int);
extern void fl_disk_parms(int);
extern void fl_disk_type(int);
extern void fl_disk_change(int);
extern void fl_format_set(int);
extern void fl_set_media(int);
extern void fl_diskette_setup(void);
#else
extern void fl_disk_reset();
extern void fl_disk_status();
extern void fl_disk_read();
extern void fl_disk_write();
extern void fl_disk_verify();
extern void fl_disk_format();
extern void fl_fnc_err();
extern void fl_disk_parms();
extern void fl_disk_type();
extern void fl_disk_change();
extern void fl_format_set();
extern void fl_set_media();
extern void fl_diskette_setup();
#endif /* ANSI */


/*
 *	Other external functions and data
 */

#ifdef ANSI
extern void drive_detect(int);
extern void translate_old(int);
extern void GetFormatParams(int *, int *, int *, int *);
#else
extern void drive_detect();
extern void translate_old();
extern void GetFormatParams();
#endif /* ANSI */


/*
 * External functions in the host.
 */
#ifdef ANSI
extern void host_floppy_init(int, int);
extern void host_floppy_term(int, int);
extern void host_attach_floppies (void);
extern void host_detach_floppies (void);
extern void host_flip_real_floppy_ind (void);
#else
extern void host_floppy_init();
extern void host_floppy_term();
extern void host_attach_floppies ();
extern void host_detach_floppies ();
extern void host_flip_real_floppy_ind ();
#endif /* ANSI */

/*
 *	Secondary function jump table definitions
 */

#define	FL_DISK_RESET	0x00
#define	FL_DISK_STATUS	0x01
#define	FL_DISK_READ	0x02
#define	FL_DISK_WRITE	0x03
#define	FL_DISK_VERF	0x04
#define	FL_DISK_FORMAT	0x05
#define	FL_DISK_PARMS	0x08
#define	FL_FNC_ERR	0x14
#define	FL_DISK_TYPE	0x15
#define	FL_DISK_CHANGE	0x16
#define	FL_FORMAT_SET	0x17
#define	FL_SET_MEDIA	0x18

#define	FL_JUMP_TABLE_SIZE	0x19

#define	fl_operation_in_range(op)	(op < FL_JUMP_TABLE_SIZE)

extern void ((*(fl_fnc_tab[]))());

#ifdef NTVDM
/*
 * NT can't assume the presence and placings of SoftPC ROMs.
 * These variables initialised from ntio.sys
 */
extern word int15_seg, int15_off;
extern word wait_int_seg, wait_int_off;
extern word dr_type_seg, dr_type_off;
extern sys_addr dr_type_addr;
#endif /* NTVDM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\ga_defs.h ===
/*[
======================================================================

				 SoftPC Revision 3.0

 Title:
		ga_defs.h

 Description:

		This module contains defines to support the write mode
		copy function tester for the VGA emulation.

 Author:
		John Shanly

 Date:
		26 September 1990

 SccsID	"@(#)ga_defs.h	1.3 08/10/92 Copyright Insignia Solutions Ltd."

======================================================================
]*/

IMPORT IHP Gdp;

IMPORT ULONG EasVal;
IMPORT ULONG Ead;
IMPORT ULONG Count;
IMPORT ULONG V1;
IMPORT ULONG V2;
IMPORT ULONG V3;
IMPORT ULONG V4;
IMPORT ULONG V5;

IMPORT ULONG V6;
IMPORT ULONG V7;
IMPORT ULONG V8;
IMPORT ULONG V9;
IMPORT ULONG V10;
IMPORT ULONG V11;
IMPORT ULONG V12;
IMPORT ULONG V13;
IMPORT ULONG V14;
IMPORT ULONG V15;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\gendrvr.h ===
/*
 * SoftPC Version 2.0
 *
 * Title	:	Pseudo terminal Interface Task.
 *
 * Desription	:	This module contains those function calls necessary to
 *			interface a PC driver to the pseudo terminal unix
 *			unix drivers.
 *
 * Author	:	Simon Frost/William Charnell
 *
 * Notes	:	None
 *
 */

/*
static char SccsID[]="@(#)gendrvr.h	1.4 09/24/92 Copyright Insignia Solutions Ltd.";
*/

#if defined (GEN_DRVR) || defined (CDROM)
extern void init_gen_drivers();
#endif /* GEN_DRVR || CDROM */

#ifdef GEN_DRVR
extern void gen_driver_io();
#endif /* GEN_DRVR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\getptis.h ===
{ 0 , " CopierActionCopyZero "},
{ 1 , " CopierActionCopyOne "},
{ 2 , " CopierActionCopyTwo "},
{ 3 , " CopierActionCopyThree "},
{ 4 , " CopierActionCopyFour "},
{ 5 , " CopierActionCopyFive "},
{ 6 , " CopierActionCopySix "},
{ 7 , " CopierActionCopyVariable "},
{ 8 , " CopierActionPatchJcond "},
{ 9 , " CopierActionBackoverMarker "},
{ 10 , " CopierActionSubrId "},
{ 11 , " CopierActionNpxExceptionData "},
{ 12 , " CopierActionNeedNextIntelEip "},
{ 13 , " CopierActionTupleImm "},
{ 14 , " CopierActionTupleDisp "},
{ 15 , " CopierActionTupleImm2 "},
{ 16 , " CopierActionTupleRetEIP "},
{ 17 , " CopierActionTearOffFlags "},
{ 18 , " CopierActionSetsFt "},
{ 19 , " CopierActionTrackFt "},
{ 20 , " CopierActionSrcFt "},
{ 21 , " CopierNoteSrcEAX "},
{ 22 , " CopierNoteSrcAX "},
{ 23 , " CopierNoteDstEAX "},
{ 24 , " CopierNoteDstAX "},
{ 25 , " CopierNoteDstAL "},
{ 26 , " CopierNoteSrcEBX "},
{ 27 , " CopierNoteSrcBX "},
{ 28 , " CopierNoteDstEBX "},
{ 29 , " CopierNoteDstBX "},
{ 30 , " CopierNoteDstBL "},
{ 31 , " CopierNoteSrcECX "},
{ 32 , " CopierNoteSrcCX "},
{ 33 , " CopierNoteDstECX "},
{ 34 , " CopierNoteDstCX "},
{ 35 , " CopierNoteDstCL "},
{ 36 , " CopierNoteSrcEDX "},
{ 37 , " CopierNoteSrcDX "},
{ 38 , " CopierNoteDstEDX "},
{ 39 , " CopierNoteDstDX "},
{ 40 , " CopierNoteDstDL "},
{ 41 , " CopierNoteSrcEBP "},
{ 42 , " CopierNoteDstEBP "},
{ 43 , " CopierNoteDstBP "},
{ 44 , " CopierNoteSrcEDI "},
{ 45 , " CopierNoteDstEDI "},
{ 46 , " CopierNoteDstDI "},
{ 47 , " CopierNoteSrcESI "},
{ 48 , " CopierNoteDstESI "},
{ 49 , " CopierNoteDstSI "},
{ 50 , " CopierNoteAddConstraintEAX "},
{ 51 , " CopierNoteRemoveConstraintEAX "},
{ 52 , " CopierNoteAddConstraintAX "},
{ 53 , " CopierNoteRemoveConstraintAX "},
{ 54 , " CopierNoteAddConstraintEBX "},
{ 55 , " CopierNoteRemoveConstraintEBX "},
{ 56 , " CopierNoteAddConstraintBX "},
{ 57 , " CopierNoteRemoveConstraintBX "},
{ 58 , " CopierNoteAddConstraintECX "},
{ 59 , " CopierNoteRemoveConstraintECX "},
{ 60 , " CopierNoteAddConstraintCX "},
{ 61 , " CopierNoteRemoveConstraintCX "},
{ 62 , " CopierNoteAddConstraintEDX "},
{ 63 , " CopierNoteRemoveConstraintEDX "},
{ 64 , " CopierNoteAddConstraintDX "},
{ 65 , " CopierNoteRemoveConstraintDX "},
{ 66 , " CopierNoteAddSingleInstruction "},
{ 67 , " CopierNoteProcessSingleInstruction "},
{ 68 , " CopierNoteSrcESP "},
{ 69 , " UnusedCopierNoteSrcSP "},
{ 70 , " CopierNotePostDstSP "},
{ 71 , " CopierNotePostDstESP "},
{ 72 , " CopierNotePostCommitPop "},
{ 73 , " CopierNoteHspTrackAbs "},
{ 74 , " CopierNoteHspTrackOpnd "},
{ 75 , " CopierNoteHspTrackReset "},
{ 76 , " CopierNoteHspAdjust "},
{ 77 , " CopierNotePigSynch "},
{ 78 , " CopierNoteMissPigSynch "},
{ 79 , " CopierNoteSrcUniverse "},
{ 80 , " CopierNoteSetDF "},
{ 81 , " CopierNoteClearDF "},
{ 82 , " CopierNoteBPILabel "},
{ 83 , " CopierActionLast "},
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\get_env.h ===
/*[
 *	Name:		get_env.h
 *
 *	Derived From:	(original)
 *
 *	Author:		Keith Rautenmbach
 *
 *	Created On:	March 1995
 *
 *	Sccs ID:	@(#)get_env.h	1.1 05/15/95
 *
 *	Purpose:	Prototypes for the Soft486 getenv() wrappers
 *
 *	(c) Copyright Insignia Solutions Ltd., 1995. All rights reserved
]*/


/* These functions are in base/support/get_env.c */

extern IBOOL IBOOLgetenv IPT2(char *, name, IBOOL, default_value);
extern ISM32 ISM32getenv IPT2(char *, name, ISM32, default_value);
extern char *STRINGgetenv IPT2(char *, name, char *, default_value);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\ga_mark.h ===
/*[
======================================================================

				 SoftPC Revision 3.0

 Title:
		ga_mark.h

 Description:

		This header file allows C code to see generated routines.

 Author:
		John Shanly

 Date:
		5 December 1990

 SccsID	: @(#)ga_mark.h	1.8 04/15/94

        (c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

======================================================================
]*/

extern void _mark_byte_nch IPT1(IU32, eaOff);
extern void _mark_word_nch IPT1(IU32, eaOff);
extern void _mark_string_nch IPT2(IU32, eaOff, IU32, count);

extern void _mark_byte_ch4 IPT1(IU32, eaOff);
extern void _mark_word_ch4 IPT1(IU32, eaOff);
extern void _mark_string_ch4 IPT2(IU32, eaOff, IU32, count);

extern void _simple_mark_sml IPT1(IU32, eaOff);
extern void _simple_mark_lge IPT2(IU32, eaOff, IU32, count);

extern void _cga_mark_byte IPT1(IU32, eaOff);
extern void _cga_mark_word IPT1(IU32, eaOff);
extern void _cga_mark_string IPT2(IU32, eaOff, IU32, count);

typedef struct 
{
	IU32 (*b_mark) IPT1(IU32, eaOff);
	IU32 (*w_mark) IPT1(IU32, eaOff);
	void (*str_mark) IPT2(IU32, eaOff, IU32, count);
} MARK_POINTERS; 

typedef struct 
{
	IU32 (*b_mark) IPT1(IU32, eaOff);
	IU32 (*w_mark) IPT1(IU32, eaOff);
	IU32 (*d_mark) IPT1(IU32, eaOff);
	void (*str_mark) IPT2(IU32, eaOff, IU32, count);
} EVID_MARK_POINTERS; 

extern MARK_POINTERS simple_marks, cga_marks, nch_marks, ch4_marks;

extern IU32 _simple_b_read();
extern IU32 _simple_w_read();
extern void _simple_str_read();

extern IU32 _rd_ram_dsbld_byte();
extern IU32 _rd_ram_dsbld_word();
extern void _rd_ram_dsbld_string();
extern void _rd_ram_dsbld_fwd_string_lge();
extern void _rd_ram_dsbld_bwd_string_lge();

extern IU32 _rdm0_byte_nch();
extern IU32 _rdm0_word_nch();
extern void _rdm0_string_nch();
extern void _rdm0_fwd_string_nch_lge();
extern void _rdm0_bwd_string_nch_lge();

extern IU32 _rdm0_byte_ch4();
extern IU32 _rdm0_word_ch4();
extern void _rdm0_string_ch4();
extern void _rdm0_fwd_string_ch4_lge();
extern void _rdm0_bwd_string_ch4_lge();

extern IU32 _rdm1_byte_nch();
extern IU32 _rdm1_word_nch();
extern void _rdm1_string_nch();
extern void _rdm1_fwd_string_nch_lge();
extern void _rdm1_bwd_string_nch_lge();

extern IU32 _rdm1_byte_ch4();
extern IU32 _rdm1_word_ch4();
extern void _rdm1_string_ch4();
extern void _rdm1_fwd_string_ch4_lge();
extern void _rdm1_bwd_string_ch4_lge();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\gfirflop.h ===
/*[
	Name:		gfirflop.h
	Derived From:	2.0 gfirflop.h
	Author:		Henry Nash / David Rees
	Created On:	Unknown
	Sccs ID:	05/10/93 @(#)gfirflop.h	1.6
	Purpose:	Real Diskette functions declarations for GFI
	Notes:		On the Sun version, these globals are exported
               		from 'sun3_wang.c'.

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
]*/

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

extern SHORT host_gfi_rdiskette_active IPT3(UTINY, hostID, BOOL, active,
                                            CHAR *, err);
extern SHORT host_gfi_rdiskette_attach IPT1(UTINY, drive);
extern void  host_gfi_rdiskette_detach IPT1(UTINY, drive);
extern void host_gfi_rdiskette_change IPT2(UTINY, hostID, BOOL, apply);
extern void  host_gfi_rdiskette_init IPT1(UTINY, drive);
extern void  host_gfi_rdiskette_term IPT1(UTINY, drive);
extern SHORT host_gfi_rdiskette_valid IPT3(UTINY, hostID, ConfigValues *, val,
                                           CHAR *, err);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\gfisflop.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: GFI Slave PC interface 
 *
 * Description	: Definitions required for Remote Procedure Call 
 *		  interface, etc.
 *
 * Author	: Jerry Kramskoy
 *
 * Notes	:
 */

/* SccsID[]="@(#)gfisflop.h	1.3 08/10/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */


/*****************************************************************************
 * RS232 port linked to IBM PC
 *****************************************************************************
 */

#define SLAVE_PC_PORT	"/dev/ttya"

/*****************************************************************************
 * Remote Procedure Call (RPC) defines
 *****************************************************************************
 */
#define MAXMSG		120	/* maximum size for message data */
#define MAXFLAGS	2	/* number of bytes in IBM flags   */

/* command ids */
#define LOGIN		0
#define LOGOUT		1
#define WTDMA		2
#define WTDOR		3
#define WTFDC		4
#define RDFDC		5
#define TESTINT		6
#define WTDISKB		7
#define RDDISKB		8
#define CHKMOTOR	9
#define CLRMSTAT	10
#define BLOCKBIOS	11
#define CLRINTFLAG	12
#define DATARATE	13
#define DRIVETYPE	14
#define DISKCHANGE	15
#define PRINTSTRING	100
#define IBMFLAGS	101
#define SIBMFLAG	102
#define BADCALL		200

/* status returns */
#define FDCSUCCESS	0
#define FDCTIMOUT	1
#define FDCFAIL		2
#define LINERR		3
 
/* IBM debugging flags */
#define FLAG0		0
#define FLAG1		1

/* FLAG0 */
#define WATCHPKTS	0x80
#define D_RAWMSG	0x40
#define D_LOGIN		0x20
#define D_LOGOUT	0x10
#define D_WTDOR		0x08
#define D_WTDMA		0x04
#define D_WTFDC		0x02
#define D_RDFDC		0x01
/* FLAG1 */
#define D_TESTINT	0x80
#define D_WTDBF		0x40
#define D_RDDBF		0x20
#define WATCHINT	0x10
#define WATCHPORT	0x08
#define PAUSE	        0x04
#define ALL		0xff
/*****************************************************************************
 * FDC interface command identifiers
 *****************************************************************************
 */
#define RDDATA		6
#define RDDELDATA	0xc
#define WTDATA		5
#define WTDELDATA	9
#define RDTRACK		2
#define RDID		0xa
#define FMTTRACK	0xd
#define SCANEQ		0x11
#define SCANLE		0x19
#define SCANHE		0x1d
#define RECAL		7
#define SENSINT		8
#define SPECIFY		3
#define SENSDRIVE	4
#define SEEK		0xf
#define MOTORON		0x12
#define MOTOROFF	0x13
#define SLEEP		0x14
#define DRVRESET	0x15

/* vpc gfi error codes
 */
#define LOGICAL		1
#define PROTOCOL	2
/****************************************************************************
 * I/O ports
 **************************************************************************** 
 * Floppy Disk Controller (8257A)
 */
#define FDC_MAIN_STATUS_REG  	(unsigned short) 0x3F4
#define FDC_DATA_REG	   	(unsigned short) 0x3F5

/* DMA controller (8237A)
 */
#define DMA_INTERNAL_FFLOP  	(unsigned short) 0xC
#define DMA_MODE_REG	  	(unsigned short) 0xB
#define DMA_BASADDR_CHAN2	(unsigned short) 0x4
#define DMA_COUNT_CHAN2	  	(unsigned short) 0x5	/* base addr + word cnt reg (wt) */
#define DMA_MASK_REG	  	(unsigned short) 0xA

/* DMA page register (channel 2)
 */
#define PAGE_REG_CHAN2	  	(unsigned short) 0x81

/* Digital Output Register
 */
#define DOR_PORT	  	(unsigned short) 0x3F2
/* *************************************************************************
 * FDC defines
 ***************************************************************************
 */
#define FDC_TO_CPU		(short) 0x40	/* DIO on  */
#define CPU_TO_FDC		(short) 0x00	/* DIO off */
#define DIO_MASK		(short) 0x40	/* mask to get DIO from main stat.reg */
#define RQM_MASK		(short) 0x80	/* mask to get RQM from main stat reg */
#define CB_MASK			(short) 0x10	/* mask to get CB  from main stat reg */
/***************************************************************************
 * DMA defines
 ***************************************************************************
 */
#define MEM_TO_FDC		(short) 1
#define FDC_TO_MEM		(short) 0
#define RDMODE			(unsigned char ) 0x4a
#define WTMODE			(unsigned char ) 0x46
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\gfitest.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Generic Floppy Interface Test definitions
 *
 * Description	: Test functions declarations for GFI
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 */

/* SccsID[]="@(#)gfitest.h	1.4 10/29/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

IMPORT int gfi_test_command IPT2(FDC_CMD_BLOCK *, command_block,
	FDC_RESULT_BLOCK *, result_block);
IMPORT int gfi_test_drive_on IPT1(int, drive);
IMPORT int gfi_test_drive_off IPT1(int, drive);
IMPORT int gfi_test_high IPT1(int, drive);
IMPORT int gfi_test_drive_type IPT1(int, drive);
IMPORT int gfi_test_change IPT1(int, drive);
IMPORT int gfi_test_reset IPT1(FDC_RESULT_BLOCK *, result_block);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\gfiempty.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Generic Floppy Interface Empty definitions
 *
 * Description	: "Empty" functions declarations for GFI
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 */

/* SccsID[]="@(#)gfiempty.h	1.3 08/10/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#ifdef ANSI
extern void gfi_empty_init(int);
extern int gfi_empty_command(FDC_CMD_BLOCK *, FDC_RESULT_BLOCK *);
extern int gfi_empty_drive_on(int);
extern int gfi_empty_drive_off(int);
extern int gfi_empty_reset(FDC_RESULT_BLOCK *);
extern int gfi_empty_high(int, half_word);
extern int gfi_empty_low(int);
extern int gfi_empty_drive_type(int);
extern int gfi_empty_change(int);

#else
extern void gfi_empty_init();
extern int gfi_empty_command();
extern int gfi_empty_drive_on();
extern int gfi_empty_drive_off();
extern int gfi_empty_reset();
extern int gfi_empty_high();
extern int gfi_empty_low();
extern int gfi_empty_drive_type();
extern int gfi_empty_change();
#endif /* ANSI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\gfx_upd.h ===
/*[
	Name:		gfx_upd.h
	Derived From:	Unknown
	Author:		Unknown
	Created On:	Unknown
	Sccs ID:	@(#)gfx_upd.h	1.27 07/09/93
	Purpose:	Unknown

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

/*
 * PC palette structure.
 */
typedef struct
{
	half_word red; 		/* max = 0xff */
	half_word green;	/* max = 0xff */
	half_word blue; 	/* max = 0xff */
} PC_palette;


typedef boolean (*T_mark_byte) IPT1(int, off_in);
typedef boolean (*T_mark_word) IPT1(int, addr);
typedef boolean (*T_mark_fill) IPT2(int, laddr, int, haddr);
typedef boolean (*T_mark_wfill) IPT3(int, laddr, int, haddr, int, col);
typedef boolean (*T_mark_string)  IPT2(int, laddr, int, haddr);
typedef void    (*T_calc_update) IPT0();
typedef boolean (*T_scroll_up) IPT6(int, start, int, width, int, height, int, attr, int, nlines,int,dummy);
typedef boolean (*T_scroll_down) IPT6(int, start, int, width, int, height, int, attr, int, nlines,int,dummy);

typedef struct
{
	T_mark_byte mark_byte;	/* handle byte written to regenmemory */
	T_mark_word mark_word;
	T_mark_fill mark_fill;
	T_mark_wfill mark_wfill;
	T_mark_string mark_string;
	T_calc_update calc_update;
	T_scroll_up scroll_up;
	T_scroll_down scroll_down;
} UPDATE_ALG;
 
/* BCN 864 */
/* moved from gfx_update.c so other people can use it */
typedef	struct	{
	int	line_no;
	int	start;
	int	end;
	long	video_copy_offset;
#ifndef NEC_98
#ifdef VGG
	int	v7frig; /* for those annoying V7 (and undocumented VGA) modes */
			  /* with chars_per_line not a multiple of 4 */
#endif /* VGG */
#endif  // !NEC_98
} DIRTY_PARTS;

#if defined(NEC_98)
typedef struct{
        unsigned short  *codeadr ;      /* line top address TVRAM code          */
        unsigned short  *attradr ;      /* line top address TVRAM attribute */
}       STRC_COMP_LINE ;
#endif  // NEC_98

typedef enum {
#if defined(NEC_98)
        NEC98_TEXT_40,
        NEC98_TEXT_80,
        NEC98_TEXT_20L,
        NEC98_TEXT_25L,
        NEC98_GRAPH_200,
        NEC98_GRAPH_400,
        NEC98_T20L_G200,
        NEC98_T25L_G200,
        NEC98_T20L_G400,
        NEC98_T25L_G400,
        NEC98_GRAPH_200_SLT,
        NEC98_T20L_G200_SLT,
        NEC98_T25L_G200_SLT,
#endif  // NEC_98
        EGA_HI_SP,
        EGA_HI_SP_WR,
        EGA_MED_SP,
        EGA_MED_SP_WR,
        EGA_LO_SP,
        EGA_LO_SP_WR,
        EGA_HI,
        EGA_HI_WR,
        EGA_MED,
        EGA_MED_WR,
        EGA_LO,
        EGA_LO_WR,
        EGA_HI_FUN,
        EGA_MED_FUN,
        EGA_LO_FUN,
        EGA_TEXT_40,
        EGA_TEXT_40_WR,
        EGA_TEXT_40_SP,
        EGA_TEXT_40_SP_WR,
        CGA_TEXT_40,
        CGA_TEXT_40_WR,
        CGA_TEXT_40_SP,
        CGA_TEXT_40_SP_WR,
        TEXT_40_FUN,
        EGA_TEXT_80,
        EGA_TEXT_80_WR,
        EGA_TEXT_80_SP,
        EGA_TEXT_80_SP_WR,
        CGA_TEXT_80,
        CGA_TEXT_80_WR,
        CGA_TEXT_80_SP,
        CGA_TEXT_80_SP_WR,
        TEXT_80_FUN,
        CGA_HI,
        CGA_HI_FUN,
        CGA_MED,
        CGA_MED_FUN,
        DUMMY_FUN
} DISPLAY_MODE;


typedef struct
{
#if defined(NEC_98)
        void (*init_screen)(void);
#else   // !NEC_98
	void (*init_screen) IPT0();
#endif  // !NEC_98
	void (*init_adaptor) IPT2(int,arg1, int,arg2);
	void (*change_mode) IPT0();
	void (*set_screen_scale) IPT1(int,arg1);
	void (*set_palette) IPT2(PC_palette *,arg1, int,arg2);
	void (*set_border) IPT1(int,arg1);
	void (*clr_screen) IPT0();
	void (*flush_screen) IPT0();
	void (*mark_refresh) IPT0();
	void (*graphics_tick) IPT0();
	void (*start_update) IPT0();
	void (*end_update) IPT0();
	boolean (*scroll_up) IPT6(int, start, int, width, int, height,
					int, attr, int, nlines,int,dummy);
	boolean (*scroll_down) IPT6(int,arg1,int,arg2,int,arg3,int,arg4,int,
						arg5,int,arg6);
	void (*paint_cursor) IPT3(int,arg1, int,arg2, half_word,arg3);
#ifdef GISP_SVGA 
	void (*hide_cursor) IPT3(int,arg1, int,arg2, half_word,arg3);
#endif		/* GISP_SVGA */
#ifdef EGG
	void (*set_paint) IPT2(DISPLAY_MODE,arg1, int,arg2);
	void (*change_plane_mask) IPT1(int,arg1);
	void (*update_fonts) IPT0();
	void (*select_fonts) IPT2(int,arg1, int,arg2);
	void (*free_font) IPT1(int,arg1);
#endif
	void (*mode_select_changed) IPT1(int,arg1);
	void (*color_select_changed) IPT1(int,arg1);
	void (*screen_address_changed) IPT2(int,arg1, int,arg2);
	void (*cursor_size_changed) IPT2(int,arg1, int,arg2);	
	void (*scroll_complete) IPT0();	
} VIDEOFUNCS;

extern VIDEOFUNCS *working_video_funcs;

#if defined(NEC_98)
#ifndef NEC98VRAM
#define NEC98VRAM
typedef struct  {
        unsigned short  code;
        unsigned char           attr;
}       NEC98_VRAM_COPY;
#endif
#endif  // NEC_98

#define host_init_screen()\
	(working_video_funcs->init_screen)()
#define host_init_adaptor(ad,ht)\
	(working_video_funcs->init_adaptor)(ad,ht)
#define host_change_mode()\
	(working_video_funcs->change_mode)()
#define host_set_screen_scale(sz)\
	(working_video_funcs->set_screen_scale)(sz)
#define host_set_palette(pltt,sz)\
	(working_video_funcs->set_palette)(pltt,sz)
#define host_set_border_colour(col)\
	(working_video_funcs->set_border)(col)
#define host_clear_screen()\
	(working_video_funcs->clr_screen)()
#define host_flush_screen()\
	(working_video_funcs->flush_screen)()
#define host_mark_screen_refresh()\
	(working_video_funcs->mark_refresh)()
#define host_graphics_tick()\
	(working_video_funcs->graphics_tick)()
#define host_start_update()\
	(working_video_funcs->start_update)()
#define host_end_update()\
	(working_video_funcs->end_update)()
#define host_scroll_up(l,t,r,b,a,c)\
	(working_video_funcs->scroll_up)(l,t,r,b,a,c)
#define host_scroll_down(l,t,r,b,a,c)\
	(working_video_funcs->scroll_down)(l,t,r,b,a,c)
#define host_paint_cursor(x,y,attr)\
	(working_video_funcs->paint_cursor)(x,y,attr)
#ifdef GISP_SVGA
#define host_hide_cursor(x,y,attr)\
	(working_video_funcs->hide_cursor)(x,y,attr)
#endif		/* GISP_SVGA */
#ifdef EGG
#define host_set_paint_routine(mode,ht)\
	(working_video_funcs->set_paint)(mode,ht)
#define host_change_plane_mask(mode)\
	(working_video_funcs->change_plane_mask)(mode)
#define host_update_fonts()\
	(working_video_funcs->update_fonts)()
#define host_select_fonts(f1,f2)\
	(working_video_funcs->select_fonts)(f1,f2)
#define host_free_font(ind)\
	(working_video_funcs->free_font)(ind)
#endif /* EGG */

/* Overrideable in host defs if not desired */
#ifndef host_mode_select_changed
#define host_mode_select_changed(m)\
	(working_video_funcs->mode_select_changed)(m)
#endif

/* Overrideable in host defs if not desired */
#ifndef host_color_select_changed
#define host_color_select_changed(c)\
	(working_video_funcs->color_select_changed)(c)
#endif

/* Overrideable in host defs if not desired */
#ifndef host_screen_address_changed
#define host_screen_address_changed(start,end)\
	(working_video_funcs->screen_address_changed)(start,end)
#endif

/* Overrideable in host defs if not desired */
#ifndef host_cursor_size_changed
#define host_cursor_size_changed(hi, lo)\
	(working_video_funcs->cursor_size_changed)(hi, lo)
#endif

/* Overrideable in host defs if not desired */
#ifndef host_scroll_complete
#define host_scroll_complete()\
	(working_video_funcs->scroll_complete)()
#endif

/*
 * Undefine these GWI defines if the host isn't using the GWI interface
 */

#include	"host_gwi.h"

extern void (*paint_screen)();	/* ptr to host routine to paint screen	*/
#ifdef V7VGA
extern void (*paint_v7ptr)();	/* ptr to host routine to paint V7 h/w pointer	*/
extern void (*clear_v7ptr)();	/* ptr to host routine to clear V7 h/w pointer	*/
#endif /* V7VGA */

extern UPDATE_ALG update_alg;
#if defined(NEC_98)
extern NEC98_VRAM_COPY *video_copy;
#else  // !NEC_98
extern byte *video_copy;
#endif // !NEC_98
extern MEM_HANDLERS vid_handlers;

extern boolean text_scroll_up IPT6(int, start, int, width, int, height,
	int, attr, int, nlines,int,dummy);
extern boolean text_scroll_down IPT6(int, start, int, width, int, height,
	int, attr, int, nlines,int,dummy);
extern boolean cga_text_scroll_up IPT6(int, start, int, width, int, height,
	int, attr, int, nlines,int,dummy);
extern boolean cga_text_scroll_down IPT6(int, start, int, width,
	int, height, int, attr, int, nlines,int,dummy);
extern boolean cga_graph_scroll_up IPT6(int, start, int, width, int, height,
	int, attr, int, nlines, int, colour);
extern boolean cga_graph_scroll_down IPT6(int, start, int, width,
	int, height, int, attr, int, nlines, int, colour);

extern  void	dummy_calc IPT0();
extern	void	text_update IPT0();
#if defined(NEC_98)
IMPORT  void    NEC98_text_update(void);
#endif  // NEC_98

extern	void	cga_med_graph_update IPT0();
extern	void	cga_hi_graph_update IPT0();

extern	void	ega_text_update IPT0();
extern	void	ega_wrap_text_update IPT0();
extern	void	ega_split_text_update IPT0();
extern	void	ega_wrap_split_text_update IPT0();

extern	void	ega_graph_update IPT0();
extern	void	ega_wrap_graph_update IPT0();
extern	void	ega_split_graph_update IPT0();
extern	void	ega_wrap_split_graph_update IPT0();

extern	void	vga_graph_update IPT0();
extern	void	vga_split_graph_update IPT0();

#if defined(HERC)
extern  void	herc_update_screen IPT0();
#endif

extern	boolean	dummy_scroll IPT6(int,dummy1,int,dummy2,int,dummy3,
				int,dummy4,int,dummy5,int,dummy6);
extern	void	bios_has_moved_cursor IPT2(int,arg1, int,arg2);
extern	void	base_cursor_shape_changed IPT0();
extern	void	host_cga_cursor_has_moved IPT2(int,arg1, int,arg2);
extern	void	screen_refresh_required IPT0();

extern	void	host_ega_cursor_has_moved IPT2(int,arg1, int,arg2);
extern	void	flag_mode_change_required IPT0();
extern  void    reset_graphics_routines IPT0();
extern	void	reset_paint_routines IPT0();

// STREAM_IO codes are disabled on NEC_98 machines, enabled on others.
#ifndef NEC_98
#ifdef NTVDM
IMPORT  void    stream_io_update(void);
#endif
#endif // !NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\gfi.h ===
/*
 * SoftPC Version 2.0
 *
 * Title	: Generic Floppy Interface level definitions
 *
 * Description	: Data structures for GFI
 *
 * Author	: Henry Nash + various others
 *
 */

/*
   static char SccsID[]="@(#)gfi.h	1.12 04/08/93 Copyright Insignia Solutions Ltd.";
 */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

#define MAX_COMMAND_LEN		9	/* max number of command bytes */
#define MAX_RESULT_LEN		7	/* max number of result bytes */

typedef unsigned char FDC_CMD_BLOCK;
typedef unsigned char FDC_RESULT_BLOCK;


/* START: FDC COMMAND BLOCK DEFINITIONS >>>>>>>>>>>>>>>>>>>>>>>>>>> */

/*
 * A simple access to the command type and drive
 */

/* the command itself	     */
#define get_type_cmd(ptr) (ptr[0] & 0x1f)
#define put_type_cmd(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x1f) | ((val << 0) & 0x1f))
/* ...and the drive no	     */
#define get_type_drive(ptr) (ptr[1] & 0x3)
#define put_type_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)

/*
 * Class 0 - read data, read deleted data, all scans
 */

/* multi-track		     */
#define get_c0_MT(ptr) ((ptr[0] & 0x80) >> 7)
#define put_c0_MT(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x80) | ((val << 7) & 0x80))
/* always 1 - FM not used    */
#define get_c0_MFM(ptr) ((ptr[0] & 0x40) >> 6)
#define put_c0_MFM(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x40) | ((val << 6) & 0x40))
/* skip data 		     */
#define get_c0_skip(ptr) ((ptr[0] & 0x20) >> 5)
#define put_c0_skip(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x20) | ((val << 5) & 0x20))
/* the command itself 	     */
#define get_c0_cmd(ptr) (ptr[0] & 0x1f)
#define put_c0_cmd(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x1f) | ((val << 0) & 0x1f))
/* padding */
#define get_c0_pad(ptr) ((ptr[1] & 0xf8) >> 3)
#define put_c0_pad(ptr,val) ptr[1] = (ptr[1] & ~0xf8) | ((val << 3) & 0xf8)
/* which head 		     */
#define get_c0_head(ptr) ((ptr[1] & 0x4) >> 2)
#define put_c0_head(ptr,val) ptr[1] = (ptr[1] & ~0x4) | ((val << 2) & 0x4)
/* drive unit */
#define get_c0_drive(ptr) (ptr[1] & 0x3)
#define put_c0_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)
/* cylinder number 	     */
#define get_c0_cyl(ptr) ptr[2]
#define put_c0_cyl(ptr,val) ptr[2] = val
/* head number - again !     */
#define get_c0_hd(ptr) ptr[3]
#define put_c0_hd(ptr,val) ptr[3] = val
/* sector number 	     */
#define get_c0_sector(ptr) ptr[4]
#define put_c0_sector(ptr,val) ptr[4] = val
/* encoded bytes per sector  */
#define get_c0_N(ptr) ptr[5]
#define put_c0_N(ptr,val) ptr[5] = val
/* last sector on track      */
#define get_c0_EOT(ptr) ptr[6]
#define put_c0_EOT(ptr,val) ptr[6] = val
/* gap length 		     */
#define get_c0_GPL(ptr) ptr[7]
#define put_c0_GPL(ptr,val) ptr[7] = val
/* data length */
#define get_c0_DTL(ptr) ptr[8]
#define put_c0_DTL(ptr,val) ptr[8] = val

/*
 * Class 1 - write data, write deleted data
 */

/* multi-track		     */
#define get_c1_MT(ptr) ((ptr[0] & 0x80) >> 7)
#define put_c1_MT(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x80) | ((val << 7) & 0x80))
/* always 1 - FM not used    */
#define get_c1_MFM(ptr) ((ptr[0] & 0x40) >> 6)
#define put_c1_MFM(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x40) | ((val << 6) & 0x40))
/* padding */
#define get_c1_pad(ptr) ((ptr[0] & 0x20) >> 5)
#define put_c1_pad(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x20) | ((val << 5) & 0x20))
/* the command itself 	     */
#define get_c1_cmd(ptr) (ptr[0] & 0x1f)
#define put_c1_cmd(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x1f) | ((val << 0) & 0x1f))
/* padding */
#define get_c1_pad1(ptr) ((ptr[1] & 0xf8) >> 3)
#define put_c1_pad1(ptr,val) ptr[1] = (ptr[1] & ~0xf8) | ((val << 3) & 0xf8)
/* which head 		     */
#define get_c1_head(ptr) ((ptr[1] & 0x4) >> 2)
#define put_c1_head(ptr,val) ptr[1] = (ptr[1] & ~0x4) | ((val << 2) & 0x4)
/* drive unit */
#define get_c1_drive(ptr) (ptr[1] & 0x3)
#define put_c1_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)
/* cylinder number 	     */
#define get_c1_cyl(ptr) ptr[2]
#define put_c1_cyl(ptr,val) ptr[2] = val
/* head number - again !     */
#define get_c1_hd(ptr) ptr[3]
#define put_c1_hd(ptr,val) ptr[3] = val
/* sector number 	     */
#define get_c1_sector(ptr) ptr[4]
#define put_c1_sector(ptr,val) ptr[4] = val
/* encoded bytes per sector  */
#define get_c1_N(ptr) ptr[5]
#define put_c1_N(ptr,val) ptr[5] = val
/* last sector on track      */
#define get_c1_EOT(ptr) ptr[6]
#define put_c1_EOT(ptr,val) ptr[6] = val
/* gap length 		     */
#define get_c1_GPL(ptr) ptr[7]
#define put_c1_GPL(ptr,val) ptr[7] = val
/* data length */
#define get_c1_DTL(ptr) ptr[8]
#define put_c1_DTL(ptr,val) ptr[8] = val

/*
 * Class 2 - read a track
 */

/* always 1 - FM not used    */
#define get_c2_MFM(ptr) ((ptr[0] & 0x40) >> 6)
#define put_c2_MFM(ptr,val) ptr[0] = (ptr[0] & ~0x40) | ((val << 6) & 0x40)
/* skip data 		     */
#define get_c2_skip(ptr) ((ptr[0] & 0x20) >> 5)
#define put_c2_skip(ptr,val) ptr[0] = (ptr[0] & ~0x20) | ((val << 5) & 0x20)
/* the command itself 	     */
#define get_c2_cmd(ptr) (ptr[0] & 0x1f)
#define put_c2_cmd(ptr,val) ptr[0] = (ptr[0] & ~0x1f) | ((val << 0) & 0x1f)
/* padding */
/* padding */
#define get_c2_pad1(ptr) ((ptr[1] & 0xf8) >> 3)
#define put_c2_pad1(ptr,val) ptr[1] = (unsigned char)((ptr[1] & ~0xf8) | ((val << 3) & 0xf8))
/* which head 		     */
#define get_c2_head(ptr) ((ptr[1] & 0x4) >> 2)
#define put_c2_head(ptr,val) ptr[1] = (ptr[1] & ~0x4) | ((val << 2) & 0x4)
/* drive unit */
#define get_c2_drive(ptr) (ptr[1] & 0x3)
#define put_c2_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)
/* cylinder number 	     */
#define get_c2_cyl(ptr) ptr[2]
#define put_c2_cyl(ptr,val) ptr[2] = val
/* head number - again !     */
#define get_c2_hd(ptr) ptr[3]
#define put_c2_hd(ptr,val) ptr[3] = val
/* sector number 	     */
#define get_c2_sector(ptr) ptr[4]
#define put_c2_sector(ptr,val) ptr[4] = val
/* encoded bytes per sector  */
#define get_c2_N(ptr) ptr[5]
#define put_c2_N(ptr,val) ptr[5] = val
/* last sector on track      */
#define get_c2_EOT(ptr) ptr[6]
#define put_c2_EOT(ptr,val) ptr[6] = val
/* gap length 		     */
#define get_c2_GPL(ptr) ptr[7]
#define put_c2_GPL(ptr,val) ptr[7] = val
/* data length */
#define get_c2_DTL(ptr) ptr[8]
#define put_c2_DTL(ptr,val) ptr[8] = val

/*
 * Class 3 - format a track
 */

/* padding */
#define get_c3_pad(ptr) ((ptr[0] & 0x80) >> 7)
#define put_c3_pad(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x80) | ((val << 7) & 0x80))
/* always 1 - FM not used    */
#define get_c3_MFM(ptr) ((ptr[0] & 0x40) >> 6)
#define put_c3_MFM(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x40) | ((val << 6) & 0x40))
/* padding */
#define get_c3_pad1(ptr) ((ptr[0] & 0x20) >> 5)
#define put_c3_pad1(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x20) | ((val << 5) & 0x20))
/* the command itself 	     */
#define get_c3_cmd(ptr) (ptr[0] & 0x1f)
#define put_c3_cmd(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x1f) | ((val << 0) & 0x1f))
/* padding */
#define get_c3_pad2(ptr) ((ptr[1] & 0xf8) >> 3)
#define put_c3_pad2(ptr,val) ptr[1] = (ptr[1] & ~0xf8) | ((val << 3) & 0xf8)
/* which head 		     */
#define get_c3_head(ptr) ((ptr[1] & 0x4) >> 2)
#define put_c3_head(ptr,val) ptr[1] = (ptr[1] & ~0x4) | ((val << 2) & 0x4)
/* drive unit */
#define get_c3_drive(ptr) (ptr[1] & 0x3)
#define put_c3_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)
/* encoded bytes per sector  */
#define get_c3_N(ptr) ptr[2]
#define put_c3_N(ptr,val) ptr[2] = val
/* sectors per cylinder      */
#define get_c3_SC(ptr) ptr[3]
#define put_c3_SC(ptr,val) ptr[3] = val
/* gap length 		     */
#define get_c3_GPL(ptr) ptr[4]
#define put_c3_GPL(ptr,val) ptr[4] = val
/* filler byte		     */
#define get_c3_filler(ptr) ptr[5]
#define put_c3_filler(ptr,val) ptr[5] = val

/*
 * Class 4 - read ID
 */

/* padding */
#define get_c4_pad(ptr) ((ptr[0] & 0x80) >> 7)
#define put_c4_pad(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x80) | ((val << 7) & 0x80))
/* always 1 - FM not used    */
#define get_c4_MFM(ptr) ((ptr[0] & 0x40) >> 6)
#define put_c4_MFM(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x40) | ((val << 6) & 0x40))
/* padding */
#define get_c4_pad1(ptr) ((ptr[0] & 0x20) >> 5)
#define put_c4_pad1(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x20) | ((val << 5) & 0x20))
/* the command itself 	     */
#define get_c4_cmd(ptr) (ptr[0] & 0x1f)
#define put_c4_cmd(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x1f) | ((val << 0) & 0x1f))
/* padding */
#define get_c4_pad2(ptr) ((ptr[1] & 0xf8) >> 3)
#define put_c4_pad2(ptr,val) ptr[1] = (unsigned char)((ptr[1] & ~0xf8) | ((val << 3) & 0xf8))
/* which head 		     */
#define get_c4_head(ptr) ((ptr[1] & 0x4) >> 2)
#define put_c4_head(ptr,val) ptr[1] = (ptr[1] & ~0x4) | ((val << 2) & 0x4)
/* drive unit */
#define get_c4_drive(ptr) (ptr[1] & 0x3)
#define put_c4_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)

/*
 * Class 5 - recalibrate
 */

/* padding */
#define get_c5_pad(ptr) ((ptr[0] & 0xe0) >> 5)
#define put_c5_pad(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0xe0) | ((val << 5) & 0xe0))
/* the command itself 	     */
#define get_c5_cmd(ptr) (ptr[0] & 0x1f)
#define put_c5_cmd(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x1f) | ((val << 0) & 0x1f))
/* padding */
#define get_c5_pad1(ptr) ((ptr[1] & 0xfc) >> 2)
#define put_c5_pad1(ptr,val) ptr[1] = (unsigned char)((ptr[1] & ~0xfc) | ((val << 2) & 0xfc))
/* drive unit */
#define get_c5_drive(ptr) (ptr[1] & 0x3)
#define put_c5_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)

/*
 * Class 6 - specify
 */

/* the command itself 	     */
#define get_c6_cmd(ptr) (ptr[0] & 0x1f)
#define put_c6_cmd(ptr,val) ptr[0] = (ptr[0] & ~0x1f) | ((val << 0) & 0x1f)
/* step rate time	     */
#define get_c6_SRT(ptr) ((ptr[1] & 0xf0) >> 4)
#define put_c6_SRT(ptr,val) ptr[1] = (ptr[1] & ~0xf0) | ((val << 4) & 0xf0)
/* head unload time	     */
#define get_c6_HUT(ptr) (ptr[1] & 0xf)
#define put_c6_HUT(ptr,val) ptr[1] = (ptr[1] & ~0xf) | ((val << 0) & 0xf)
/* head load time	     */
#define get_c6_HLT(ptr) ((ptr[2] & 0xfe) >> 1)
#define put_c6_HLT(ptr,val) ptr[2] = (ptr[2] & ~0xfe) | ((val << 1) & 0xfe)
/* non-dma mode - not supp.  */
#define get_c6_ND(ptr) (ptr[2] & 0x1)
#define put_c6_ND(ptr,val) ptr[2] = (unsigned char)((ptr[2] & ~0x1) | ((val << 0) & 0x1))

/*
 * Class 7 - sense drive status
 */

/* the command itself 	     */
#define get_c7_cmd(ptr) (ptr[0] & 0x1f)
#define put_c7_cmd(ptr,val) ptr[0] = (ptr[0] & ~0x1f) | ((val << 0) & 0x1f)
/* which head 		     */
#define get_c7_head(ptr) ((ptr[1] & 0x4) >> 2)
#define put_c7_head(ptr,val) ptr[1] = (ptr[1] & ~0x4) | ((val << 2) & 0x4)
/* drive unit */
#define get_c7_drive(ptr) (ptr[1] & 0x3)
#define put_c7_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)

/*
 * Class 8 - seek
 */

/* padding */
#define get_c8_pad(ptr) ((ptr[0] & 0xe0) >> 5)
#define put_c8_pad(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0xe0) | ((val << 5) & 0xe0))
/* the command itself 	     */
#define get_c8_cmd(ptr) (ptr[0] & 0x1f)
#define put_c8_cmd(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x1f) | ((val << 0) & 0x1f))
/* padding */
#define get_c8_pad1(ptr) ((ptr[1] & 0xf8) >> 3)
#define put_c8_pad1(ptr,val) ptr[1] = (unsigned char)((ptr[1] & ~0xf8) | ((val << 3) & 0xf8))
/* which head 		     */
#define get_c8_head(ptr) ((ptr[1] & 0x4) >> 2)
#define put_c8_head(ptr,val) ptr[1] = (unsigned char)((ptr[1] & ~0x4) | ((val << 2) & 0x4))
/* drive unit */
#define get_c8_drive(ptr) (ptr[1] & 0x3)
#define put_c8_drive(ptr,val) ptr[1] = (ptr[1] & ~0x3) | ((val << 0) & 0x3)
/* new cylinder no for seek  */
#define get_c8_new_cyl(ptr) ptr[2]
#define put_c8_new_cyl(ptr,val) ptr[2] = val

/* END:   FDC COMMAND BLOCK DEFINITIONS <<<<<<<<<<<<<<<<<<<<<<<<<<< */

/* START: FDC RESULT BLOCK DEFINITIONS >>>>>>>>>>>>>>>>>>>>>>>>>>>> */

/*
 * Class 0 - read/write data, read/write deleted data,
 *    	     all scans, read/format a track
 */

/* status register 0         */
#define get_r0_ST0(ptr) ptr[0]
#define put_r0_ST0(ptr,val) ptr[0] = val
/* status register 1         */
#define get_r0_ST1(ptr) ptr[1]
#define put_r0_ST1(ptr,val) ptr[1] = val
/* status register 2         */
#define get_r0_ST2(ptr) ptr[2]
#define put_r0_ST2(ptr,val) ptr[2] = val
/* cylinder number 	     */
#define get_r0_cyl(ptr) ptr[3]
#define put_r0_cyl(ptr,val) ptr[3] = val
/* head number 		     */
#define get_r0_head(ptr) ptr[4]
#define put_r0_head(ptr,val) ptr[4] = val
/* sector number 	     */
#define get_r0_sector(ptr) ptr[5]
#define put_r0_sector(ptr,val) ptr[5] = val
/* encoded bytes per sector if N == 0  */
#define get_r0_N(ptr) ptr[6]
#define put_r0_N(ptr,val) ptr[6] = val

/*
 * Class 1 - a split up way of looking at Status registers
 * ST0 to ST2.
 */

/* Termination code  */
#define get_r1_ST0_int_code(ptr) ((ptr[0] & 0xc0) >> 6)
#define put_r1_ST0_int_code(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0xc0) | ((val << 6) & 0xc0))
/* End of seek cmd   */
#define get_r1_ST0_seek_end(ptr) ((ptr[0] & 0x20) >> 5)
#define put_r1_ST0_seek_end(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x20) | ((val << 5) & 0x20))
/* Equipment fault   */
#define get_r1_ST0_equipment(ptr) ((ptr[0] & 0x10) >> 4)
#define put_r1_ST0_equipment(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x10) | ((val << 4) & 0x10))
/* Device not ready  */
#define get_r1_ST0_not_ready(ptr) ((ptr[0] & 0x8) >> 3)
#define put_r1_ST0_not_ready(ptr,val) ptr[0] = (ptr[0] & ~0x8) | ((val << 3) & 0x8)
/* State of head     */
#define get_r1_ST0_head_address(ptr) ((ptr[0] & 0x4) >> 2)
#define put_r1_ST0_head_address(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x4) | ((val << 2) & 0x4))
/* Which drive	     */
#define get_r1_ST0_unit(ptr) (ptr[0] & 0x3)
#define put_r1_ST0_unit(ptr,val) ptr[0] = (ptr[0] & ~0x3) | ((val << 0) & 0x3)
/* Access off end of cylinder 		*/
#define get_r1_ST1_end_of_cylinder(ptr) ((ptr[1] & 0x80) >> 7)
#define put_r1_ST1_end_of_cylinder(ptr,val) ptr[1] = (ptr[1] & ~0x80) | ((val << 7) & 0x80)
/* CRC error in data field/ID		*/
#define get_r1_ST1_data_error(ptr) ((ptr[1] & 0x20) >> 5)
#define put_r1_ST1_data_error(ptr,val) ptr[1] = (ptr[1] & ~0x20) | ((val << 5) & 0x20)
/* timeout of device */
#define get_r1_ST1_over_run(ptr) ((ptr[1] & 0x10) >> 4)
#define put_r1_ST1_over_run(ptr,val) ptr[1] = (ptr[1] & ~0x10) | ((val << 4) & 0x10)
/* sector not found  */
#define get_r1_ST1_no_data(ptr) ((ptr[1] & 0x4) >> 2)
#define put_r1_ST1_no_data(ptr,val) ptr[1] = (unsigned char)((ptr[1] & ~0x4) | ((val << 2) & 0x4))
/* write protected   */
#define get_r1_ST1_write_protected(ptr) ((ptr[1] & 0x2) >> 1)
#define put_r1_ST1_write_protected(ptr,val) ptr[1] = (unsigned char)((ptr[1] & ~0x2) | ((val << 1) & 0x2))
/* Cannot find adress mask/ID  		*/
#define get_r1_ST1_no_address_mark(ptr) (ptr[1] & 0x1)
#define put_r1_ST1_no_address_mark(ptr,val) ptr[1] = (unsigned char)((ptr[1] & ~0x1) | ((val << 0) & 0x1))
/* Deleted data found in Read/Scan	*/
#define get_r1_ST2_control_mark(ptr) ((ptr[2] & 0x40) >> 6)
#define put_r1_ST2_control_mark(ptr,val) ptr[2] = (ptr[2] & ~0x40) | ((val << 6) & 0x40)
/* CRC error in data field		*/
#define get_r1_ST2_data_field_error(ptr) ((ptr[2] & 0x20) >> 5)
#define put_r1_ST2_data_field_error(ptr,val) ptr[2] = (ptr[2] & ~0x20) | ((val << 5) & 0x20)
/* cylinder miss-match 			*/
#define get_r1_ST2_wrong_cyclinder(ptr) ((ptr[2] & 0x10) >> 4)
#define put_r1_ST2_wrong_cyclinder(ptr,val) ptr[2] = (ptr[2] & ~0x10) | ((val << 4) & 0x10)
/* Match found in scan      		*/
#define get_r1_ST2_scan_equal_hit(ptr) ((ptr[2] & 0x8) >> 3)
#define put_r1_ST2_scan_equal_hit(ptr,val) ptr[2] = (ptr[2] & ~0x8) | ((val << 3) & 0x8)
/* Sector not found during scan command */
#define get_r1_ST2_scan_not_satisfied(ptr) ((ptr[2] & 0x4) >> 2)
#define put_r1_ST2_scan_not_satisfied(ptr,val) ptr[2] = (ptr[2] & ~0x4) | ((val << 2) & 0x4)
/* Invalid cylinder found		*/
#define get_r1_ST2_bad_cylinder(ptr) ((ptr[2] & 0x2) >> 1)
#define put_r1_ST2_bad_cylinder(ptr,val) ptr[2] = (ptr[2] & ~0x2) | ((val << 1) & 0x2)
/* Missing Address mark			*/
#define get_r1_ST2_no_address_mark(ptr) (ptr[2] & 0x1)
#define put_r1_ST2_no_address_mark(ptr,val) ptr[2] = (ptr[2] & ~0x1) | ((val << 0) & 0x1)

/*
 * Class 2 - sense drive status
 */

/* Device fault      		*/
#define get_r2_ST3_fault(ptr) ((ptr[0] & 0x80) >> 7)
#define put_r2_ST3_fault(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x80) | ((val << 7) & 0x80))
/* Write protected diskette	*/
#define get_r2_ST3_write_protected(ptr) ((ptr[0] & 0x40) >> 6)
#define put_r2_ST3_write_protected(ptr,val) ptr[0] = (ptr[0] & ~0x40) | ((val << 6) & 0x40)
/* Device is ready		*/
#define get_r2_ST3_ready(ptr) ((ptr[0] & 0x20) >> 5)
#define put_r2_ST3_ready(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x20) | ((val << 5) & 0x20))
/* Track zero found		*/
#define get_r2_ST3_track_0(ptr) ((ptr[0] & 0x10) >> 4)
#define put_r2_ST3_track_0(ptr,val) ptr[0] = (ptr[0] & ~0x10) | ((val << 4) & 0x10)
/* Double sided diskette	*/
#define get_r2_ST3_two_sided(ptr) ((ptr[0] & 0x8) >> 3)
#define put_r2_ST3_two_sided(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x8) | ((val << 3) & 0x8))
/* Side address signal		*/
#define get_r2_ST3_head_address(ptr) ((ptr[0] & 0x4) >> 2)
#define put_r2_ST3_head_address(ptr,val) ptr[0] = (unsigned char)((ptr[0] & ~0x4) | ((val << 2) & 0x4))
/* Which unit is selected	*/
#define get_r2_ST3_unit(ptr) (ptr[0] & 0x3)
#define put_r2_ST3_unit(ptr,val) ptr[0] = (ptr[0] & ~0x3) | ((val << 0) & 0x3)

/*
 * Class 3 - sense interrupt status
 */

/* status register 0         */
#define get_r3_ST0(ptr) ptr[0]
#define put_r3_ST0(ptr,val) ptr[0] = val
/* present cylinder number   */
#define get_r3_PCN(ptr) ptr[1]
#define put_r3_PCN(ptr,val) ptr[1] = val

/*
 * Class 4 - invalid codes
 */

/* status register 0         */
#define get_r4_ST0(ptr) ptr[0]
#define put_r4_ST0(ptr,val) ptr[0] = val

/* END:   FDC RESULT BLOCK DEFINITIONS <<<<<<<<<<<<<<<<<<<<<<<<<<<< */


/*
 * An entry data structure that holds information describing the number of bytes
 * in the fdc command/result phases. The index is the fdc command code, see
 * the INTEL Application note on the 8272A for a full description.
 *
 * The "result_byte" is the number of bytes in the standard FDC result phase
 * while "gfi_result_byte" is the number of bytes in the pseudo result phase
 * used by GFI and its server modules (ie some commands that do not normally
 * have a result phase, use an implicit Sense Interrupt Status result phase).
 */

typedef struct {
		 half_word cmd_bytes;		/* number of command bytes */
		 half_word result_bytes;	/* number of result bytes  */
		 half_word gfi_result_bytes;	/* number of GFI result bytes  */
		 half_word cmd_class;		/* class of the command    */
		 half_word result_class;	/* class of the result     */
		 boolean   dma_required;	/* dma required ?	   */
		 boolean   int_required;	/* interrupts required ?   */
	       } FDC_DATA_ENTRY;


/*
 * The following list the error codes that the GFI commands (see gfi.f) can
 * return.  0 is considered to be success.
 */

#define GFI_PROTOCOL_ERROR	1
#define GFI_FDC_TIMEOUT		2
#define GFI_FDC_LOGICAL_ERROR	3

/*
 * GFI Drive types
 */

#define GFI_DRIVE_TYPE_NULL		0	/* unidentified */
#define GFI_DRIVE_TYPE_360		1	/* 360K 5.25" */
#define GFI_DRIVE_TYPE_12		2	/* 1.2M 5.25" */
#define GFI_DRIVE_TYPE_720		3	/* 720K 3.5" */
#define GFI_DRIVE_TYPE_144		4	/* 1.44M 3.5" */
#define	GFI_DRIVE_TYPE_288		5	/* 2.88M 3.5" */

#ifdef NTVDM
#define GFI_DRIVE_TYPE_MAX              6
#endif


/***************************************************************************
**
**      Definitions and prototypes for the gfi_function_table,
**  the functions therein, and the orthogonal floppy interface functions.
**  Using the typedef'd prototypes should make it much easier to avoid
**  definition clashes.
**	This is now the only base floppy header file, and if you use the
**  generic unix_flop.c module, the only floppy header anywhere. The generic
**  code is meant to help a new unix port get quick floppy support; it is
**  not meant to replace fancy host floppy code.
**	The improvements that I have made to the floppy system in general are
**  also supposed to make life easier.
**
**      GM.
****************************************************************************
**
**
**
** The GFI has a structure containing pointers to functions that provide
** the diskette support for all possible drives (0-1) and drive types.
**  Each floppy emmulator module has a function for loading this table
** with the module's own local functions which can then be used by the
** gfi system to emmulate the sort of device the module was designed for.
**
** 	This table (of two structures - one for each possible drive)
**  is of course GLOBAL.
**
** The structure has the following fields:
**
** The GFI command function:		GFI_FUNC_ENTRY.command_fn,
** The GFI drive on function:		GFI_FUNC_ENTRY.drive_on_fn,
** The GFI drive off function:		GFI_FUNC_ENTRY.drive_off_fn,
** The GFI reset function:		GFI_FUNC_ENTRY.reset_fn,
** The GFI set high density function:	GFI_FUNC_ENTRY.high_fn,
** The GFI drive type function:		GFI_FUNC_ENTRY.drive_type_fn,
** The GFI disk changed function:	GFI_FUNC_ENTRY.change_fn
**
**   Structure definition:
**  -----------------------
*/
typedef struct
{
	SHORT (*command_fn) IPT2( FDC_CMD_BLOCK *, ip, FDC_RESULT_BLOCK *, res );
	SHORT (*drive_on_fn) IPT1( UTINY, drive );
	SHORT (*drive_off_fn) IPT1( UTINY, drive );
	SHORT (*reset_fn) IPT2( FDC_RESULT_BLOCK *, res, UTINY, drive );
	SHORT (*high_fn) IPT2( UTINY, drive, half_word, n);
	SHORT (*drive_type_fn) IPT1( UTINY, drive );
	SHORT (*change_fn) IPT1( UTINY, drive );

} GFI_FUNCTION_ENTRY;

/*
** ============================================================================
** External declarations and macros
** ============================================================================
**
**
**
** The data structure describing the fdc command/result phases, and the
** function pointer table set up by calls to the individual init functions
** in each of the GFI server modules.
**
**
**
** 	These tables are in gfi.c
*/
	IMPORT GFI_FUNCTION_ENTRY gfi_function_table[];
	IMPORT FDC_DATA_ENTRY     gfi_fdc_description[];
/*
**	The following functions form the interface between the GFI system
**  and the floppy module (whichever). They are global, but the only access
**  to the other functions gfi needs is via the gfi_function_table.
*/

IMPORT SHORT host_gfi_rdiskette_valid
	IPT3(UTINY,hostID,ConfigValues *,vals,CHAR *,err);

IMPORT SHORT host_gfi_rdiskette_active
	IPT3(UTINY, hostID, BOOL, active, CHAR, *err);

IMPORT SHORT gfi_empty_active
	IPT3(UTINY, hostID, BOOL, active, CHAR, *err);

IMPORT VOID  host_gfi_rdiskette_change
	IPT2(UTINY, hostID, BOOL, apply);

#ifndef host_rflop_drive_type
/* new function to say what kind of drive we have
*/
IMPORT SHORT host_rflop_drive_type IPT2 (INT, fd, CHAR *, name);
#endif /* host_rflop_drive_type */

/*  The gfi global functions. These need to be global because they are the
** interface to the private host dependant floppy functions. Each one does
** little more than call the real function via the table.
*/
/* The gfi_reset is special; not the same as the other floppy inits because
** it is called from main() to startup the gfi system by making both drives
** 'empty'. This means that it has no drive parameter.
*/

IMPORT SHORT gfi_drive_on IPT1( UTINY, drive );
IMPORT SHORT gfi_drive_off IPT1( UTINY, drive );
IMPORT SHORT gfi_low IPT1( UTINY, drive );
IMPORT SHORT gfi_drive_type IPT1( UTINY, drive );
IMPORT SHORT gfi_change IPT1( UTINY, drive );
IMPORT VOID gfi_init IPT0();
IMPORT SHORT gfi_reset IPT2( FDC_RESULT_BLOCK *, res, UTINY, drive );
IMPORT SHORT gfi_high IPT2( UTINY, drive, half_word, n);
IMPORT SHORT gfi_fdc_command IPT2( FDC_CMD_BLOCK *, ip, FDC_RESULT_BLOCK *, res );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\ggdc.h ===
#if defined(NEC_98)
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
/*::::::::::::::::::    NEC98 Graphic Emulation Header    :::::::::::::::*/
/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/


/*--------------------    MODE FF2 PORT ADDRESS      -------------------*/

#define MODE_FF2                        0x6A    /* mode FF2 PORT */

/*--------------------      G-GDC PORT ADDRESS      --------------------*/

#define GGDC_PARAMETER          0xA0    /* G-GDC PORT A0H */
#define GGDC_COMMAND            0xA2    /* G-GDC PORT A2H */

/*--------------------   VRAM SELECT PORT ADDRESS    -------------------*/

#define VRAM_DISPLAY            0xA4    /* displayed  bank select reg */
#define VRAM_DRAW                       0xA6    /* read/write bank select reg */

/*--------------------     PALETTE PORT ADDRESS     --------------------*/

#define PALETTE_A8                      0xA8    /* palette #3,#7( 8 colors) */
                                                                        /* palette index(16 colors) */
#define PALETTE_AA                      0xAA    /* palette #2,#6( 8 colors) */
                                    /* palette green(16 colors) */
#define PALETTE_AC                      0xAC    /* palette #1,#5( 8 colors) */
                                    /* palette red  (16 colors) */
#define PALETTE_AE                      0xAE    /* palette #0,#4( 8 colors) */
                                    /* palette blue (16 colors) */

/*--------------------      GRCG PORT ADDRESS      ---------------------*/

#define GRCG_MODE                       0x7C    /* GRCG mode reg */
#define GRCG_TILE                       0x7E    /* GRCG tile reg */

/*--------------------      EGC PORT ADDRESS       ---------------------*/

#define EGC_ACTIVE                      0x4A0   /* EGC active           reg     */
#define EGC_MODE                        0x4A2   /* EGC mode             reg     */
#define EGC_ROP                         0x4A4   /* EGC rastorop         reg     */
#define EGC_FORE                        0x4A6   /* EGC fore color       reg     */
#define EGC_MASK                        0x4A8   /* EGC mask                     reg */
#define EGC_BACK                        0x4AA   /* EGC back color       reg     */
#define EGC_BITAD                       0x4AC   /* EGC bit address      reg     */
#define EGC_LENGTH                      0x4AE   /* EGC bit length       reg */

/*--------------------      GGDC COMMAND SET       ---------------------*/

#define GGDC_RESET1                     0x00    
#define GGDC_RESET2                     0x01    
#define GGDC_RESET3                     0x09    
#define GGDC_SYNC_OFF           0x0E    
#define GGDC_SYNC_ON            0x0F    
#define GGDC_SLAVE                      0x6E    
#define GGDC_MASTER                     0x6F    
#define GGDC_START1                     0x6B    
#define GGDC_START2                     0x0D    
#define GGDC_STOP1                      0x05    
#define GGDC_STOP2                      0x0C    
#define GGDC_ZOOM                       0x46    
#define GGDC_SCROLL1            0x70    
#define GGDC_SCROLL2            0x71    
#define GGDC_SCROLL3            0x72    
#define GGDC_SCROLL4            0x73    
#define GGDC_SCROLL5            0x74    
#define GGDC_SCROLL6            0x75    
#define GGDC_SCROLL7            0x76    
#define GGDC_SCROLL8            0x77    
#define GGDC_CSRFORM            0x4B    
#define GGDC_PITCH                      0x47    
#define GGDC_LPEN                       0xC0    
#define GGDC_VECTW                      0x4C    
#define GGDC_VECTE                      0x6C    
#define GGDC_TEXTW1                     0x78    
#define GGDC_TEXTW2                     0x79    
#define GGDC_TEXTW3                     0x7A    
#define GGDC_TEXTW4                     0x7B    
#define GGDC_TEXTW5                     0x7C    
#define GGDC_TEXTW6                     0x7D    
#define GGDC_TEXTW7                     0x7E    
#define GGDC_TEXTW8                     0x7F    
#define GGDC_TEXTE                      0x68    
#define GGDC_CSRW                       0x49    
#define GGDC_CSRR                       0xE0    
#define GGDC_MASK                       0x4A    
#define GGDC_WRITE1                     0x20    
#define GGDC_WRITE2                     0x21    
#define GGDC_WRITE3                     0x22    
#define GGDC_WRITE4                     0x23    
#define GGDC_WRITE5                     0x28    
#define GGDC_WRITE6                     0x29    
#define GGDC_WRITE7                     0x2A    
#define GGDC_WRITE8                     0x2B    
#define GGDC_WRITE9                     0x30    
#define GGDC_WRITE10            0x31    
#define GGDC_WRITE11            0x32    
#define GGDC_WRITE12            0x33    
#define GGDC_WRITE13            0x38    
#define GGDC_WRITE14            0x39    
#define GGDC_WRITE15            0x3A    
#define GGDC_WRITE16            0x3B    
#define GGDC_READ1                      0xA0    
#define GGDC_READ2                      0xA1    
#define GGDC_READ3                      0xA2    
#define GGDC_READ4                      0xA3    
#define GGDC_READ5                      0xA8    
#define GGDC_READ6                      0xA9    
#define GGDC_READ7                      0xAA    
#define GGDC_READ8                      0xAB    
#define GGDC_READ9                      0xB0    
#define GGDC_READ10                     0xB1    
#define GGDC_READ11                     0xB2    
#define GGDC_READ12                     0xB3    
#define GGDC_READ13                     0xB8    
#define GGDC_READ14                     0xB9    
#define GGDC_READ15                     0xBA    
#define GGDC_READ16                     0xBB    
#define GGDC_DMAW1                      0x24    
#define GGDC_DMAW2                      0x25    
#define GGDC_DMAW3                      0x26    
#define GGDC_DMAW4                      0x27    
#define GGDC_DMAW5                      0x2C    
#define GGDC_DMAW6                      0x2D    
#define GGDC_DMAW7                      0x2E    
#define GGDC_DMAW8                      0x2F    
#define GGDC_DMAW9                      0x34    
#define GGDC_DMAW10                     0x35    
#define GGDC_DMAW11                     0x36    
#define GGDC_DMAW12                     0x37    
#define GGDC_DMAW13                     0x3C    
#define GGDC_DMAW14                     0x3D    
#define GGDC_DMAW15                     0x3E    
#define GGDC_DMAW16                     0x3F    
#define GGDC_DMAR1                      0xA4    
#define GGDC_DMAR2                      0xA5    
#define GGDC_DMAR3                      0xA6    
#define GGDC_DMAR4                      0xA7    
#define GGDC_DMAR5                      0xAC    
#define GGDC_DMAR6                      0xAD    
#define GGDC_DMAR7                      0xAE    
#define GGDC_DMAR8                      0xAF    
#define GGDC_DMAR9                      0xB4    
#define GGDC_DMAR10                     0xB5    
#define GGDC_DMAR11                     0xB6    
#define GGDC_DMAR12                     0xB7    
#define GGDC_DMAR13                     0xBC    
#define GGDC_DMAR14                     0xBD    
#define GGDC_DMAR15                     0xBE    
#define GGDC_DMAR16                     0xBF    

#define DRAWING                         1
#define NOTDRAW                         0

/*---------------------     MODE FF2 DATA SET      ---------------------*/

#define FF2_COLORSEL            0
#define FF2_EGCEXT                      1
#define FF2_LCD1MODE            2
#define FF2_LCD2MODE            3
#define FF2_LSIINIT                     4
#define FF2_GDCCLOCK1           5
#define FF2_GDCCLOCK2           6
#define FF2_REGWRITE            7

#define FF2_8COLOR                      0x00
#define FF2_16COLOR                     0x01
#define FF2_DISENB                      0x06
#define FF2_ENABLE                      0x07
#define FF2_GRCG                        0x08
#define FF2_EGC                         0x09
#define FF2_GT1DOT                      0x40
#define FF2_GTEQ                        0x41
#define FF2_GR640                       0x42
#define FF2_GR641                       0x43
#define FF2_INIOFF                      0x80
#define FF2_INION                       0x81
#define FF2_GDC25                       0x82
#define FF2_GDC50                       0x83
#define FF2_GDC25_1                     0x82
#define FF2_GDC50_1                     0x83
#define FF2_GDC25_2                     0x84
#define FF2_GDC50_2                     0x85

/*---------------------   VRAM SELECT DATA SET     ---------------------*/

#define FORE_BANK                       0x00    /* NEC98 G-VRAM select fore */
#define BACK_BANK                       0x01    /* NEC98 G-VRAM select back */

/*------------------------   PALETTE DATA SET    -----------------------*/

#define WIN_PALB                        0               /* windows palette Blue    */
#define WIN_PALG                        1               /* windows palette Green   */
#define WIN_PALR                        2               /* windows palette Red     */
#define WIN_PALQ                        3               /* windows palette Reserve */

#define NEC98PALG                        0               /* NEC98 16 colors palette Green */
#define NEC98PALR                        1               /* NEC98 16 colors palette Red   */
#define NEC98PALB                        2               /* NEC98 16 colors palette Blue  */

/*-----------------      GRAPHIC GLOBAL STRUCTURE     ------------------*/

        /* use for( Window->HARDWARE_STATE structure-> FullScreen ) */

typedef struct{
        unsigned char   command         ;
        unsigned char   count           ;
        unsigned char   param[16]       ;
}       _STRC_NOW;

typedef struct{

        UCHAR           sync_param[8]           ;       /* save sync       parameter */
        UCHAR           zoom_param                      ;       /* save zoom       parameter */
        UCHAR           scroll_param[8]         ;       /* save scroll     parameter */
        UCHAR           csrform_param[3]        ;       /* save csrform    parameter */
        UCHAR           pitch_param                     ;       /* save pitch      parameter */
        UCHAR           vectw_param[11]         ;       /* save vectw      parameter */
        UCHAR           textw_param[8]          ;       /* save textw      parameter */
        UCHAR           csrw_param[3]           ;       /* save csrw       parameter */
        UCHAR           mask_param[2]           ;       /* save mask       parameter */
        UCHAR           write                           ;       /* save write      command   */
        UCHAR           start_stop                      ;       /* save start/stop command   */
        _STRC_NOW       ggdc_now                        ;       /* save gdc set    parameter */

} STRC_GGDC_GLOBALS;

typedef struct{

        UCHAR   pal_8_data[4]           ; /* save  8 colors mode palette data */
        UCHAR   pal_16_data[16][3]      ; /* save 16 colors mode palette data */
        UCHAR   pal_16_index            ; /* save last use palette index reg  */

} STRC_PALETTE_GLOBALS;


typedef struct{

        UCHAR   grcg_mode                       ; /* save GRCG MODE REGISTER            */
        UCHAR   grcg_count                      ; /* save GRCG TILE REG's position 	*/
        UCHAR   grcg_tile[4]            ; /* save GRCG TILE REGISTER            */

} STRC_GRCG_GLOBALS;

/* structure for EGC register  1994/03/25 */
/*                                 /03/29 */
typedef struct {                                                // 940325
        unsigned short Reg0;                                    // 940325
        unsigned short Reg1;                                    // 940325
        unsigned short Reg2;                                    // 940325
        unsigned short Reg3;                                    // 940325
        unsigned short Reg4;                                    // 940325
        unsigned short Reg5;                                    // 940325
        unsigned short Reg6;                                    // 940325
        unsigned short Reg7;                                    // 940325
        unsigned short Reg3fb;                                  // 940329
        unsigned short Reg5fb;                                  // 940329
} STRC_EGC_REGS;                                                // 940325


typedef struct{
        unsigned long   asm_vram        ; /* vram start address         4 bytes */
        unsigned long   asm_ead         ; /* gdc draw start address 4 bytes */
        unsigned long   asm_pitch       ; /* gdc next line                      4 bytes */
        unsigned long   asm_dir         ; /* gdc next move position     4 bytes */
        unsigned short  asm_dc          ; /* gdc vectw parameter        2 bytes */
        unsigned short  asm_d           ; /* gdc vectw parameter        2 bytes */
        unsigned short  asm_d2          ; /* gdc vectw parameter        2 bytes */
        unsigned short  asm_d1          ; /* gdc vectw parameter        2 bytes */
        unsigned short  asm_dm          ; /* gdc vectw parameter        2 bytes */
        unsigned short  asm_ptn         ; /* gdc line pattern           2 bytes */
        unsigned short  asm_zoom        ; /* gdc zoom parameter         2 bytes */
        unsigned short  asm_sl          ; /* gdc graph char sline       2 bytes */
        unsigned short  asm_wg          ; /* gdc wg bit set                     2 bytes */
        unsigned short  asm_maskgdc     ; /* gdc mask for gdc 7-0       2 bytes */
        unsigned char   asm_txt[8]      ; /* gdc graph char data        8 bytes */
} GGDC_C_TO_ASM ;

typedef struct{
        unsigned long   lastead         ;
        unsigned short  lastdad         ;
        unsigned char   lastcsrr[5]     ;
} GGDC_CSRR_BACK ;

extern  DISPLAY_GLOBS                   NEC98Display ;
extern  STRC_GGDC_GLOBALS               ggdcglobs       ;
extern  STRC_PALETTE_GLOBALS    paletteglobs;
extern  STRC_GRCG_GLOBALS               grcgglobs       ;

extern STRC_EGC_REGS egc_regs;                  // EGC register 940325

#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\gispsvga.h ===
/*[
 * File Name		: gispsvga.h
 *
 * Derived From		: Template
 *
 * Author		: Mike
 *
 * Creation Date	: Feb 94
 *
 * SCCS Version		: @(#)gispsvga.h	1.1 02/22/94
 *!
 * Purpose
 *	This file contains prototypes for global functions and variables that
 *	get declared when GISP_SVGA is defined, and that don't use types
 *	defined in HostHwVgaH.  Those prototypes that do are in hwvga.h.
 *
 *	Well that's the theory.  Unfortunately almost all the prototypes
 *	are actually stil in hwvga.h, but should move here eventually!
 *
 *! (c)Copyright Insignia Solutions Ltd., 1994. All rights reserved.
]*/

#ifdef GISP_SVGA

extern void romMessageAddress IPT0( );
extern void gispROMInit IPT0( );


#endif /* GISP_SVGA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\gmi.h ===
/*
*
* Interface to gmi routines.
*
*/

/* static char SccsID[]="@(#)gmi.h	1.8 04/26/93 Copyright Insignia Solutions Ltd."; */
typedef enum 
{
	RAM,
	VIDEO,
	ROM,
	IN_FRAGMENT,
	NEXT_FRAGMENT
} mem_type;

typedef struct
{
	VOID	(*b_write)();
	VOID	(*w_write)();
	VOID	(*b_fill)();
	VOID	(*w_fill)();
	VOID	(*b_move)IPT4(UTINY *, laddr, UTINY *, haddr, UTINY *, src,
		 UTINY, src_type);
	VOID	(*w_move)();
} MEM_HANDLERS;

#ifndef UNIVERSAL	/* These are in host_cpu.h during a UNIVERSAL build. */

IMPORT	void	gmi_b_write IPT1(host_addr, intel_addr);
IMPORT	void	gmi_w_write IPT1(host_addr, intel_addr);
IMPORT	void	gmi_b_move IPT4(host_addr, intel_dest_start,
	host_addr, intel_dest_end, host_addr, intel_src, boolean, direction);
IMPORT	void	gmi_w_move IPT4(host_addr, intel_dest_start,
	host_addr, intel_dest_end, host_addr, intel_src, boolean, direction);
IMPORT	void	gmi_b_fill IPT2(host_addr, start, host_addr, end);
IMPORT	void	gmi_w_fill IPT2(host_addr, start, host_addr, end);
IMPORT	boolean	gmi_w_check IPT3(host_addr, laddr, host_addr, haddr,
	host_addr *, endaddr);
IMPORT	void	gmi_init IPT1(sys_addr, size);

#ifdef	CCPU
IMPORT	boolean	gmi_connect_mem IPT3(sys_addr, laddr, sys_addr, haddr,
	mem_type, type);
IMPORT	boolean	gmi_disconnect_mem IPT3(sys_addr, laddr,
	sys_addr, haddr, mem_type, type);
IMPORT	void	gmi_define_mem IPT2(mem_type, type, MEM_HANDLERS *, handlers);
#else	/* CCPU */
IMPORT	boolean	gmi_connect_mem	IPT3(host_addr, laddr, host_addr, haddr,
	mem_type, type);
IMPORT 	boolean	gmi_disconnect_mem IPT3(host_addr, laddr, host_addr, haddr,
	mem_type, type);
IMPORT	void	gmi_define_mem IPT2(mem_type, type, MEM_HANDLERS *, handlers);
#endif	/* CCPU */

#endif /* UNIVERSAL */

/*
 * defines for direction argument of gmi_x_move().
 * Has the same meaning as the INtel direction flag.
 */
#define FORWARDS 0
#define BACKWARDS 1

#ifdef EGATEST
#define gmi_redefine_mem(type,handlers) \
b_write_ptrs[(int)type] = handlers.b_write; \
w_write_ptrs[(int)type] = handlers.w_write; \
b_fill_ptrs[(int)type] = handlers.b_fill; \
w_fill_ptrs[(int)type] = handlers.w_fill; \
b_fwd_move_ptrs[(int)type] = handlers.b_move_fwd; \
b_bwd_move_ptrs[(int)type] = handlers.b_move_bwd; \
w_fwd_move_ptrs[(int)type] = handlers.w_move_fwd; \
w_bwd_move_ptrs[(int)type] = handlers.w_move_bwd; 
#else
#define gmi_redefine_mem(type,handlers) \
b_write_ptrs[(int)type] = handlers.b_write; \
w_write_ptrs[(int)type] = handlers.w_write; \
b_fill_ptrs[(int)type] = handlers.b_fill; \
w_fill_ptrs[(int)type] = handlers.w_fill; \
b_move_ptrs[(int)type] = handlers.b_move; \
w_move_ptrs[(int)type] = handlers.w_move; 
#endif /* EGATEST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\gore.h ===
/*[
======================================================================

				 SoftPC Revision 3.0

 Title:
		gore.h

 Description:

		This is the header file for the Graphics Object Recognition
		( GORE ) system for communicating update information from
		the VGA emulation to the host graphics system.

 Author:
		John Shanly

 Date:
		6 November 1990

 SccsID	"@(#)gore.h	1.2 08/10/92 Copyright Insignia Solutions Ltd."

======================================================================
]*/

#ifdef INTERLEAVED

#define	B_POS_UNIT_DIFF	 4
#define	B_NEG_UNIT_DIFF	-4
#define	W_POS_UNIT_DIFF	 8
#define	W_NEG_UNIT_DIFF	-8
#define	CURR_LINE_DIFF	320

#else

#define	B_POS_UNIT_DIFF	 1
#define	B_NEG_UNIT_DIFF	-1
#define	W_POS_UNIT_DIFF	 2
#define	W_NEG_UNIT_DIFF	-2
#define	CURR_LINE_DIFF	80

#endif /* INTERLEAVED */


typedef struct
{
	VOID		(*b_wrt)();
	VOID		(*w_wrt)();
	VOID		(*b_str)();
	VOID		(*w_str)();
} GU_HANDLER;

typedef struct
{
	ULONG		obj_type;
	ULONG		offset;
	ULONG		tlx;
	ULONG		tly;
	ULONG		width;
	ULONG		height;
} OBJ_DATA;

typedef struct _OBJECT
{
	OBJ_DATA		data;
	struct _OBJECT	*next;
	struct _OBJECT	*prev;
} OBJECT, *OBJ_PTR;

typedef struct
{
	ULONG		curr_addr;
	ULONG		obj_start;
	ULONG		start;
	ULONG		end;
	ULONG		curr_line_end;
	ULONG		prev_line_start;
	ULONG		rect_width;
	ULONG		rect_height;
	OBJ_PTR	obj_ptr;
	OBJ_PTR	obj_ptr2;
	ULONG		count;
} GORE_DATA_WRT;

typedef struct
{
	ULONG		start;
	ULONG		end;
	ULONG		width;
	OBJ_PTR	obj_ptr;
} GORE_DATA_STR;

typedef struct
{
	ULONG			curr_line_diff;
	ULONG			max_vis_addr;
	ULONG			shift_count;
	GORE_DATA_WRT	gd_b_wrt;
	GORE_DATA_WRT	gd_w_wrt;
	GORE_DATA_STR	gd_b_str;
	GORE_DATA_STR	gd_w_str;
} GORE_DATA;

typedef	UTINY			OBJ_TYPE;

#define	OBJ_PTR_NULL	((OBJ_PTR) 0)

#define	INITIAL_MAX_LIST_SIZE	1000		/* Arbitrary */

#define	RANDOM_BW			0
#define	RANDOM_WW			1
#define	LINE_RIGHT_BW		2
#define	LINE_RIGHT_WW		3
#define	LINE_RIGHT_BS		4
#define	LINE_RIGHT_WS		5
#define	LINE_LEFT_BW		6
#define	LINE_LEFT_WW		7
#define	LINE_LEFT_BS		8
#define	LINE_LEFT_WS		9
#define	LINE_DOWN_BW		10
#define	LINE_DOWN_WW		11
#define	LINE_UP_BW			12
#define	LINE_UP_WW			13
#define	RECT_RIGHT_DOWN_BW	14
#define	RECT_RIGHT_DOWN_WW	15
#define	RECT_RIGHT_DOWN_BS	16
#define	RECT_RIGHT_DOWN_WS	17
#define	RECT_LEFT_DOWN_BW		18
#define	RECT_LEFT_DOWN_WW		19
#define	RECT_RIGHT_UP_BS		20
#define	RECT_RIGHT_UP_WS		21
#define	RECT_LEFT_UP_BS		22
#define	RECT_LEFT_UP_WS		23
#define	LINE_DOWN_LEFT_BW		24
#define	LINE_DOWN_RIGHT_BW	25
#define	LINE_DOWN_LEFT_WW		26
#define	LINE_DOWN_RIGHT_WW	27
#define	RECT_DOWN_RIGHT_BW	28
#define	RECT_DOWN_RIGHT_WW	29
#define	ANNULLED			30
#define	MAX_OBJ_TYPES		31

#define	NOT_PENDING		0
#define	BW			1
#define	WW			2
#define	BS			3
#define	WS			4

IMPORT GU_HANDLER gu_handler;
IMPORT GORE_DATA gd;
IMPORT VOID (*paint_screen)();
IMPORT VOID process_object_list();
IMPORT ULONG trace_gore;
IMPORT ULONG stat_gore;
IMPORT OBJ_PTR start_object();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\gvi.h ===
/*
 * SoftPC Revision 3.0
 *
 * Title	: Generic Video Interface Module definitions
 *
 * Description	: Definitions for users of the Generic Video Interface Module
 *
 * Author	: Henry Nash / David Rees
 *
 * Notes	: This file should be included by all external modules that
 *		  use the GVI module.
 */

/* SccsID[]="@(#)gvi.h	1.16 06/28/93 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Constant definitions
 * ============================================================================
 */

#define GAP_WIDTH	0xC0 	 /* Width of the gap in bytes                */
#define ODD_START       0xBA000L  /* Start of the odd bank                    */
#define ODD_END         0xBBF3FL  /* End of the odd bank                      */
#define EVEN_START      0xB8000L  /* Start of the even bank                   */
#define EVEN_END        0xB9F3FL  /* End of the even bank                     */
#define	ODD_OFFSET	(ODD_START-EVEN_START)	/* offset of odd bank to even bank */

#define SCAN_LINE_LENGTH 80	/* Length of a scan line in bytes */

#define CGA_CURS_HEIGHT	   2	 /* CGA 'usual' underscore cursor	      */
#define CGA_CURS_START     7	 /* CGA 'usual' underscore cursor	      */

#define MDA_CURS_HEIGHT    2	 /* Default MDA cursor height               */
#define MDA_CURS_START     7 	 /* Default MDA cursor starting scan line   */

#define CGA_HEIGHT	200	/* In host scan lines */
#define EGA_HEIGHT	350
#define HERC_HEIGHT	350
#define VGA_HEIGHT	400


/*
 * Legal modes for the adapter
 */
#undef TEXT
#define TEXT	        0	/* Alpha numeric mode 80 by 25, or 40 by 25  */
#define GRAPHICS	1	/* All Points Addressable 640x200 or 320x200 */

#define HIGH		0	/* APA 640x200,  2 colors		     */
#define MEDIUM		1	/* APA 320x200,  4 colors		     */
#define LOW		2	/* APA 160x100, 16 colors  (not supported)   */

#define VGA_DAC_SIZE	0x100
#ifdef EGG
#ifdef VGG
#define MAX_NUM_FONTS	8	/* VGA support 8 fonts */
#else
#define MAX_NUM_FONTS	4	/* EGA support 4 fonts */
#endif  /* VGG */
#endif  /* EGG */


#ifdef HERC

/* Hercules Page 0  */

#define P0_EVEN_START1      0x0000  /* Start of the even bank         */
#define P0_EVEN_END1        0x1E95  /* End of the even bank           */
#define P0_ODD_START1       0x2000  /* Start of the odd bank          */
#define P0_ODD_END1         0x3E95  /* End of the odd bank            */
#define P0_EVEN_START2      0x4000  /* Start of the even bank         */
#define P0_EVEN_END2        0x5E95  /* End of the even bank           */
#define P0_ODD_START2       0x6000  /* Start of the odd bank          */
#define P0_ODD_END2         0x7E95  /* End of the odd bank            */

/* Hercules Page 1   */

#define P1_EVEN_START1      0x8000  /* Start of the even bank         */
#define P1_EVEN_END1        0x9E95  /* End of the even bank           */
#define P1_ODD_START1       0xA000  /* Start of the odd bank          */
#define P1_ODD_END1         0xBE95  /* End of the odd bank            */
#define P1_EVEN_START2      0xC000  /* Start of the even bank         */
#define P1_EVEN_END2        0xDE95  /* End of the even bank           */
#define P1_ODD_START2       0xE000  /* Start of the odd bank          */
#define P1_ODD_END2         0xFE95  /* End of the odd bank            */

#define HERC_CURS_HEIGHT   2	 /* Default  Hercules MDA cursor height     */
#define HERC_CURS_START    13 	 /* Default  Hercules MDA cursor starting scan line   */

#endif	/* HERC */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#if defined(NEC_98)
extern  void    gvi_init(void);
#else  // !NEC_98
extern	void	gvi_init IPT1(half_word, v_adapter);
#endif // !NEC_98
extern	void	gvi_term IPT0();
extern	void	recalc_screen_params IPT0();

#ifdef EGG
IMPORT VOID ega_term IPT0();
IMPORT VOID ega_init IPT0();
#endif

#ifdef VGG
IMPORT VOID vga_term IPT0();
IMPORT VOID vga_init IPT0();
#endif

/*
 * The screen memory limits in host and PC address space
 */

extern sys_addr gvi_pc_low_regen;
extern sys_addr gvi_pc_high_regen;

/*
 * Variable to determine which video adapter is currently selected
 */

extern half_word video_adapter;

/*
 * screen height varies on EGA. It is set in two parts; the top bit is controlled by
 * a separate register to the lower 8 bits. The _9_BITS type is used to help emulate
 * this type of setting.
 */

#if defined(NEC_98)
typedef struct
{
                        BOOL    atrsel;
                        BOOL    graphmode;
                        BOOL    width;
                        BOOL    fontsel;
                        BOOL    graph88;
                        BOOL    kacmode;
                        BOOL    nvmwpermit;
                        BOOL    dispenable;
} MODE_FF;

/* ADD NEC98 Graphic Emulater's STRUC 930617 */

typedef struct
{
        BOOL                    vh;
        unsigned char           cr;
        unsigned short          lf;
        unsigned short          zw;
        unsigned long           sad1;
        unsigned short          sl1;
        BOOL                    im1;
        unsigned long           sad2;
        unsigned short          sl2;
        BOOL                    im2;
        unsigned char           lr;
        unsigned short          p;
        unsigned char           slrctl;
        unsigned char           dir;
        BOOL                    dgd;
        unsigned short          dc;
        unsigned short          d;
        unsigned short          d2;
        unsigned short          d1;
        unsigned short          dm;
        unsigned short          ptn;
        unsigned short          txt[8];
        unsigned long           ead;
        BOOL                    wg;
        unsigned short          dad;
        unsigned char           whl;
        unsigned char           mod;
        BOOL                    startstop;
} _STRC_GGDC ;

typedef struct{
        BOOL                    flag;
        PALETTEENTRY            data[16];
} _STRC_PALETTE ;

typedef struct{
        BOOL                    colorsel;
        BOOL                    egcext;
        BOOL                    lcd1mode;
        BOOL                    lcd2mode;
        BOOL                    lsiinit;
        BOOL                    gdcclock;
        BOOL                    regwrite;
} _STRC_MODE_FF2;

#endif // NEC_98
typedef union {
        word    as_word;
        struct
        {
#ifdef  BIT_ORDER1
                unsigned        unused          : 7,
                                top_bit         : 1,
                                low_byte        : 8;
#else
                unsigned        low_byte        : 8,
                                top_bit         : 1,
                                unused          : 7;
#endif
        } as_bfld;
} _9_BITS;

/*
 * VGA has greater resolution to VGA - some regs have an extra bit thrown in
 * in some register to boost them to 10 bits. Split this into three parts as
 * a super set of the 9_bit type.
 */

typedef union {
        word    as_word;
        struct
        {
#ifdef  BIT_ORDER1
                unsigned        unused          : 6,
                                top_bit         : 1,
				med_bit		: 1,
                                low_byte        : 8;
#else
                unsigned        low_byte        : 8,
				med_bit		: 1,
                                top_bit         : 1,
                                unused          : 6;
#endif
        } as_bfld;
} _10_BITS;
/*
 * Definition of variables which reflect the state of the current adapter
 */

typedef	struct {
	int mode_change_required;	/* Display mode changed not just in EGA */
	int bytes_per_line;		/* In TEXT mode the no. of bytes per line   */
	int chars_per_line;		/* In TEXT mode the no. of chars per line   */
	int char_width;			/* Width of a character in host pixels      */
	int char_height;		/* Height of a character in PC pixels       */
	int screen_start;		/* Address in adaptor memory of current screen */
#ifdef VGG
	_10_BITS screen_height;		/* Height in pc scanlines of screen	    */
#else
	_9_BITS	screen_height;		/* Height in pc scanlines of screen	    */
#endif
	half_word *screen_ptr;		/* pointer to start of regen buffer	    */
	int screen_length;		/* Number of bytes in one screenfull        */
#if defined(NEC_98)
        BOOL    crt_on;
#endif // NEC_98
	int display_disabled;		/* 0 if it's OK to do screen output.        */
					/* it is used to implement the VIDEO_ENABLE */
					/* bit in the mode select register          */
	int cursor_start;		/* scanlines from top of char block	    */
	int cursor_height;		/* in scanlines from cursor start	    */
	int cursor_start1;		/* start scanline of poss 2nd block	    */
	int cursor_height1;		/* height of 2nd block or 0 if none	    */
	int cur_x,cur_y;		/* Current cursor position */
	boolean PC_cursor_visible;	/* flag for cursor visible or not */
	boolean word_addressing;	/* if TRUE, bytes_per_line=2*chars_per_line */
#ifdef VGG
	boolean chain4_mode;
	boolean doubleword_mode;	/* if TRUE, bytes_per_line=4*chars_per_line */
					/* else bytes_per_line=chars_per_line	    */
#ifdef V7VGA
	boolean seq_chain4_mode;
	boolean seq_chain_mode;
#endif /* V7VGA */
#endif
	int pix_width;			/* Width of a PC pixel in host pixels	    */
	int pix_char_width;		/* Width of PC character pixel in host pixels (is this used?) */
	int pc_pix_height; 		/* Height of PC pixel in pixels   */
	int host_pix_height; 		/* Height of PC pixel in host pixels	    */
	int offset_per_line;		/* mirrors bytes_per_line for mda and cga, but can vary for ega */
	int screen_limit;		/* number of bytes in video_copy */
#if defined(NEC_98)
        BOOL    beep_on;
        BOOL    beep_changed;
        word    beep_rate;

        int     blink_rate;
        BOOL    blink_disable;
        int     pitch_width;
        BOOL    kcg_dot_mode;
/*--------------------------------------------------*/
        int     gvram_length;
        int     gvram_width;
        int     gvram_height;
        int     gvram_start;
        int     gvram_offset;
        int     gvram_text_line;
        int     gvram_line_char;
        int     gvram_scan;
        unsigned char   *gvram_ptr;
        unsigned char   *gvram_copy;
/*--------------------------------------------------*/
        MODE_FF modeff;
        _STRC_GGDC      ggdcemu ;
        _STRC_PALETTE   palette ;
        _STRC_MODE_FF2  modeff2 ;
#endif // NEC_98
} DISPLAY_GLOBS;

#if defined(NEC_98)
extern  DISPLAY_GLOBS   NEC98Display;
#else  // !NEC_98
extern	DISPLAY_GLOBS	PCDisplay;
#endif // !NEC_98

#if defined(NEC_98)
#define set_gvram_length(val)   NEC98Display.gvram_length = val
#define set_gvram_width(val)    NEC98Display.gvram_width  = val
#define set_gvram_height(val)   NEC98Display.gvram_height = val
#define set_gvram_start(val)    NEC98Display.gvram_start  = val
#define set_gvram_ptr(val)      NEC98Display.gvram_ptr    = val
#define set_gvram_copy(val)     NEC98Display.gvram_copy   = val
#define set_text_lines(val)     NEC98Display.gvram_text_line = val
#define set_line_per_char(val)  NEC98Display.gvram_line_char = val
#define set_gvram_scan(val)     NEC98Display.gvram_scan = val

#define get_gvram_length()      NEC98Display.gvram_length
#define get_gvram_width()       NEC98Display.gvram_width
#define get_gvram_height()      NEC98Display.gvram_height
#define get_gvram_start()       NEC98Display.gvram_start
#define get_gvram_ptr()         NEC98Display.gvram_ptr
#define get_gvram_copy()        NEC98Display.gvram_copy
#define get_text_lines()        NEC98Display.gvram_text_line
#define get_line_per_char()     NEC98Display.gvram_line_char
#define get_gvram_scan()        NEC98Display.gvram_scan

#define get_graph_ptr()         &((NEC98Display.gvram_ptr)[NEC98Display.gvram_start])
#define set_gvram_start_offset(val)     NEC98Display.gvram_offset = val
#define get_gvram_start_offset()        NEC98Display.gvram_offset

#define set_mode_change_required(val)   NEC98Display.mode_change_required = (val)
#define set_word_addressing(val)        NEC98Display.word_addressing = (val)
#define set_offset_per_line(val)        NEC98Display.offset_per_line = (val)
#define set_offset_per_line_recal(val)  { set_offset_per_line(val); recalc_screen_params(); }
#define set_word_addressing_recal(val)  { set_word_addressing(val); recalc_screen_params(); }
#define set_cur_x(val)                  NEC98Display.cur_x = (val)
#define set_cur_y(val)                  NEC98Display.cur_y = (val)
#define set_cursor_start(val)           NEC98Display.cursor_start = (val)
#define inc_cursor_start()              (NEC98Display.cursor_start)++
#define set_cursor_height(val)          NEC98Display.cursor_height = (val)
#define set_cursor_start1(val)          NEC98Display.cursor_start1 = (val)
#define set_cursor_height1(val)         NEC98Display.cursor_height1 = (val)
#define set_cursor_visible(val)         NEC98Display.PC_cursor_visible = (val)
#define set_display_disabled(val)       NEC98Display.display_disabled = (val)
#define set_bit_display_disabled(val)   NEC98Display.display_disabled |= (val)
#define clear_bit_display_disabled(val) NEC98Display.display_disabled &= ~(val)
#define set_bytes_per_line(val)         NEC98Display.bytes_per_line = (val)
#define set_chars_per_line(val)         NEC98Display.chars_per_line = (val)
#define set_horiz_total(val)            { set_chars_per_line(val); recalc_screen_params(); }
#define set_char_width(val)             NEC98Display.char_width = (val)
#define set_char_height(val)            NEC98Display.char_height = (val)
#define set_char_height_recal(val)      { set_char_height(val); recalc_screen_params(); }
#define set_screen_length(val)          NEC98Display.screen_length = (val)
#define set_screen_start(val)           NEC98Display.screen_start = (val)
#define set_screen_height(val)          NEC98Display.screen_height.as_word = (val)
#define set_screen_height_recal(val)    { set_screen_height(val); recalc_screen_params(); }
#define set_screen_height_lo(val)       NEC98Display.screen_height.as_bfld.low_byte = ((val) & 0xff)
#define set_screen_height_lo_recal(val) { set_screen_height_lo(val); recalc_screen_params(); }
#define set_screen_height_med(val)       NEC98Display.screen_height.as_bfld.med_bit = ((val) & 0xff)
#define set_screen_height_med_recal(val)        { set_screen_height_med(val); recalc_screen_params(); }
#define set_screen_height_hi(val)       NEC98Display.screen_height.as_bfld.top_bit = ((val) & 1)
#define set_screen_height_hi_recal(val) { set_screen_height_hi(val); recalc_screen_params(); }
#define set_screen_ptr(ptr)             NEC98Display.screen_ptr = (ptr)
#define set_pix_width(val)              NEC98Display.pix_width = (val)
#define set_pc_pix_height(val)          NEC98Display.pc_pix_height = (val)
#define set_host_pix_height(val)        NEC98Display.host_pix_height = (val)
#define set_pix_char_width(val)         NEC98Display.pix_char_width = (val)

#define get_mode_change_required()      (NEC98Display.mode_change_required)
#define get_offset_per_line()           (NEC98Display.offset_per_line)
#define get_pix_width()                 (NEC98Display.pix_width)
#define get_pc_pix_height()             (NEC98Display.pc_pix_height)
#define get_host_pix_height()           (NEC98Display.host_pix_height)
#define get_pix_char_width()            (NEC98Display.pix_char_width)
#define get_word_addressing()           (NEC98Display.word_addressing)
#define get_cur_x()                     (NEC98Display.cur_x)
#define get_cur_y()                     (NEC98Display.cur_y)
#define get_cursor_start()              (NEC98Display.cursor_start)
#define get_cursor_height()             (NEC98Display.cursor_height)
#define get_cursor_start1()             (NEC98Display.cursor_start1)
#define get_cursor_height1()            (NEC98Display.cursor_height1)
#define is_cursor_visible()             (NEC98Display.PC_cursor_visible != FALSE)
#define get_display_disabled()          (NEC98Display.display_disabled)
#define get_bytes_per_line()            (NEC98Display.bytes_per_line)
#define get_chars_per_line()            (NEC98Display.chars_per_line)
#define get_char_width()                (NEC98Display.char_width)
#define get_char_height()               (NEC98Display.char_height)
#define get_screen_length()             (NEC98Display.screen_length)
#define get_screen_start()              (NEC98Display.screen_start)
#define get_screen_height()             ((NEC98Display.screen_height.as_word+1)*get_pc_pix_height())
#define get_screen_height_lo()          (NEC98Display.screen_height.as_bfld.low_byte)
#define get_screen_height_hi()          (NEC98Display.screen_height.as_bfld.top_bit)
#define get_screen_end()                (get_screen_start() + get_screen_length() + gvi_pc_low_regen)
#define get_screen_ptr(offs)            &((NEC98Display.screen_ptr)[offs])
#define get_screen_base()               ((get_screen_start() << 1) + gvi_pc_low_regen)
#ifdef VGG
#define set_chain4_mode(val)            NEC98Display.chain4_mode = (val)
#define set_doubleword_mode(val)        NEC98Display.doubleword_mode = (val)
#define get_chain4_mode()               (NEC98Display.chain4_mode)
#define get_doubleword_mode()           (NEC98Display.doubleword_mode)
#ifdef V7VGA
#define set_seq_chain4_mode(val)        NEC98Display.seq_chain4_mode = (val)
#define set_seq_chain_mode(val) NEC98Display.seq_chain_mode = (val)
#define get_seq_chain4_mode()   (NEC98Display.seq_chain4_mode)
#define get_seq_chain_mode()    (NEC98Display.seq_chain_mode)
#endif /* V7VGA */
#endif
#else  // !NEC_98
#define	set_mode_change_required(val)	PCDisplay.mode_change_required = (val)
#define	set_word_addressing(val)	PCDisplay.word_addressing = (val)
#define	set_offset_per_line(val)	PCDisplay.offset_per_line = (val)
#define	set_offset_per_line_recal(val)	{ set_offset_per_line(val); recalc_screen_params(); }
#define	set_word_addressing_recal(val)	{ set_word_addressing(val); recalc_screen_params(); }
#define	set_cur_x(val)			PCDisplay.cur_x = (val)
#define	set_cur_y(val)			PCDisplay.cur_y = (val)
#define	set_cursor_start(val)		PCDisplay.cursor_start = (val)
#define	inc_cursor_start()		(PCDisplay.cursor_start)++
#define	set_cursor_height(val)		PCDisplay.cursor_height = (val)
#define	set_cursor_start1(val)		PCDisplay.cursor_start1 = (val)
#define	set_cursor_height1(val)		PCDisplay.cursor_height1 = (val)
#define	set_cursor_visible(val)		PCDisplay.PC_cursor_visible = (val)
#define	set_display_disabled(val)	PCDisplay.display_disabled = (val)
#define	set_bit_display_disabled(val)	PCDisplay.display_disabled |= (val)
#define	clear_bit_display_disabled(val)	PCDisplay.display_disabled &= ~(val)
#define	set_bytes_per_line(val)		PCDisplay.bytes_per_line = (val)
#define	set_chars_per_line(val)		PCDisplay.chars_per_line = (val)
#define	set_horiz_total(val)		{ set_chars_per_line(val); recalc_screen_params(); }
#define	set_char_width(val)		PCDisplay.char_width = (val)
#define	set_char_height(val)		PCDisplay.char_height = (val)
#define	set_char_height_recal(val)	{ set_char_height(val); recalc_screen_params(); }
#define	set_screen_length(val)		PCDisplay.screen_length = (val)
#define	set_screen_limit(val)		PCDisplay.screen_limit = (val)
#define set_screen_start(val)		PCDisplay.screen_start = (val)
#define	set_screen_height(val)		PCDisplay.screen_height.as_word = (val)
#define	set_screen_height_recal(val)	{ set_screen_height(val); recalc_screen_params(); }
#define set_screen_height_lo(val)       PCDisplay.screen_height.as_bfld.low_byte = ((val) & 0xff)
#define set_screen_height_lo_recal(val)	{ set_screen_height_lo(val); recalc_screen_params(); }
#define set_screen_height_med(val)       PCDisplay.screen_height.as_bfld.med_bit = ((val) & 0xff)
#define set_screen_height_med_recal(val)	{ set_screen_height_med(val); recalc_screen_params(); }
#define set_screen_height_hi(val)       PCDisplay.screen_height.as_bfld.top_bit = ((val) & 1)
#define set_screen_height_hi_recal(val)	{ set_screen_height_hi(val); recalc_screen_params(); }
#define	set_screen_ptr(ptr)		PCDisplay.screen_ptr = (ptr)
#define	set_pix_width(val)		PCDisplay.pix_width = (val)
#define	set_pc_pix_height(val)		PCDisplay.pc_pix_height = (val)
#define	set_host_pix_height(val)	PCDisplay.host_pix_height = (val)
#define	set_pix_char_width(val)		PCDisplay.pix_char_width = (val)

#define	get_mode_change_required()	(PCDisplay.mode_change_required)
#define	get_offset_per_line()		(PCDisplay.offset_per_line)
#define	get_pix_width()			(PCDisplay.pix_width)
#define	get_pc_pix_height()		(PCDisplay.pc_pix_height)
#define	get_host_pix_height()		(PCDisplay.host_pix_height)
#define	get_pix_char_width()		(PCDisplay.pix_char_width)
#define	get_word_addressing()		(PCDisplay.word_addressing)
#define	get_cur_x()			(PCDisplay.cur_x)
#define	get_cur_y()			(PCDisplay.cur_y)
#define	get_cursor_start()		(PCDisplay.cursor_start)
#define	get_cursor_height()		(PCDisplay.cursor_height)
#define	get_cursor_start1()		(PCDisplay.cursor_start1)
#define	get_cursor_height1()		(PCDisplay.cursor_height1)
#define	is_cursor_visible()		(PCDisplay.PC_cursor_visible != FALSE)
#define	get_display_disabled()		(PCDisplay.display_disabled)
#define	get_bytes_per_line()		(PCDisplay.bytes_per_line)
#define	get_chars_per_line()		(PCDisplay.chars_per_line)
#define	get_char_width()		(PCDisplay.char_width)
#define	get_char_height()		(PCDisplay.char_height)
#define	get_screen_length()		(PCDisplay.screen_length)
#define get_screen_start()		(PCDisplay.screen_start)
#ifdef VGG
#define get_screen_height()             ((video_adapter == VGA) ? ((PCDisplay.screen_height.as_word+1)<<EGA_GRAPH.multiply_vert_by_two) : \
							((PCDisplay.screen_height.as_word+1)*get_pc_pix_height()))
#else
#define get_screen_height()             ((PCDisplay.screen_height.as_word+1)*get_pc_pix_height())
#endif /* VGG */
#define get_screen_height_lo()          (PCDisplay.screen_height.as_bfld.low_byte)
#define get_screen_height_hi()          (PCDisplay.screen_height.as_bfld.top_bit)
#define	get_screen_end()		(get_screen_start() + get_screen_length() + gvi_pc_low_regen)
#define	get_screen_ptr(offs)		((PCDisplay.screen_ptr) + (offs))
#define get_screen_base()		((get_screen_start() << 1) + gvi_pc_low_regen)
#ifdef VGG
#define set_chain4_mode(val)		PCDisplay.chain4_mode = (val)
#define set_doubleword_mode(val)	PCDisplay.doubleword_mode = (val)
#define get_chain4_mode()		(PCDisplay.chain4_mode)
#define get_doubleword_mode()		(PCDisplay.doubleword_mode)
#ifdef V7VGA
#define set_seq_chain4_mode(val)	PCDisplay.seq_chain4_mode = (val)
#define set_seq_chain_mode(val)	PCDisplay.seq_chain_mode = (val)
#define get_seq_chain4_mode()	(PCDisplay.seq_chain4_mode)
#define get_seq_chain_mode()	(PCDisplay.seq_chain_mode)
#endif /* V7VGA */
#endif
#endif // !NEC_98

/*
 * useful macro to get character height in host pixels
 */
#define get_host_char_height()		(get_char_height()*get_host_pix_height()*get_pc_pix_height())

/*
 * Macros to check for regen buffer - both 8088 and M68000 address space
 */

#define gvi_pc_check_regen(addr) (addr >= gvi_pc_low_regen && addr <= gvi_pc_high_regen)
#if defined(NEC_98)
/******************************************************************* */
/* For PC-9801 Emulation related functions                           */
/******************************************************************* */
/*      Miscelinous macros used for PC-98 H/W architecture           */
/******************************************************************* */
/*  Color/Code conversion macro groups                               */
#define NEC98_CODE_LR    0x8080             /* Mask for determine L/R */
#define NEC98_CODE_MASK  0x7f7f             /* Mask for extract JIS   */
#define NEC98_CODE_BIAS  0x0020             /* Bias for NEC98 code     */
#define NEC98_CODE_LEFT  1                  /* LEFT CODE for flag     */
#define NEC98_CODE_RIGHT 2                  /* RIGHT CODE for flag    */

#define NEC98_ATR_COLOR          0xE0             /* Mask for color   */
#define NEC98_ATR_BLACK          0x00             /* Black            */
#define NEC98_ATR_REVERSE        0x04             /* Mask for reverse */
#define NEC98_ATR_BLINK          0x02             /* Mask for blink   */
#define NEC98_ATR_SECRET         0x01             /* Mask for secret  */
                                                 /* Note: negative!  */

#define NEC98_is_secret(x)       (!(x&NEC98_ATR_SECRET)) /* Is secret ?  */
#define NEC98_is_reverse(x)      (x&NEC98_ATR_REVERSE)   /* Is reverse ? */
#define NEC98_is_blink(x)        (x&NEC98_ATR_BLINK)     /* Is blink ?   */
#define NEC98_norm_color(x)      ((x&0x01)|((x&0x02)?0x04:0)|((x&0x04)?0x02:0))
#define NEC98_get_color(x)       NEC98_norm_color((x&NEC98_ATR_COLOR)>>5)
                                                    /* Extract color */
#define NEC98_EGA_BGCOLOR(x)     (x<<4)              /* EGA bg color  */
#define NEC98_EGA_FGCOLOR(x)     (x)                 /* EGA fg color  */

/* PC-98 Text-VRAM manupilation groups */

/* PC-98 text vram locations (32 bits offset addr.)                         */
#define NEC98_N_TEXT_P0_OFF      (0xA0000L)        /* First text page addr   */
#define NEC98_N_TEXT_P1_OFF      (0xA1000L)        /* Second text page addr  */
#define NEC98_N_ATTR_P0_OFF      (0xA2000L)        /* First Attribute page   */
#define NEC98_N_ATTR_P1_OFF      (0xA3000L)        /* Second attribute page  */

#define NEC98_H_TEXT_P0_OFF      (0xE0000L)        /* First text page addr   */
#define NEC98_H_TEXT_P1_OFF      (0xE1000L)        /* Second text page addr  */
#define NEC98_H_ATTR_P0_OFF      (0xE2000L)        /* First Attribute page   */
#define NEC98_H_ATTR_P1_OFF      (0xE3000L)        /* Second attribute page  */

extern BOOL HIRESO_MODE;
//#define       NEC98_TEXT_P0_OFF NEC98_N_TEXT_P0_OFF
//#define       NEC98_TEXT_P1_OFF NEC98_N_TEXT_P1_OFF
//#define       NEC98_ATTR_P0_OFF NEC98_N_ATTR_P0_OFF
//#define       NEC98_ATTR_P1_OFF NEC98_N_ATTR_P1_OFF
#define NEC98_TEXT_P0_OFF (HIRESO_MODE ? NEC98_H_TEXT_P0_OFF : NEC98_N_TEXT_P0_OFF)
#define NEC98_TEXT_P1_OFF (HIRESO_MODE ? NEC98_H_TEXT_P1_OFF : NEC98_N_TEXT_P1_OFF)
#define NEC98_ATTR_P0_OFF (HIRESO_MODE ? NEC98_H_ATTR_P0_OFF : NEC98_N_ATTR_P0_OFF)
#define NEC98_ATTR_P1_OFF (HIRESO_MODE ? NEC98_H_ATTR_P1_OFF : NEC98_N_ATTR_P1_OFF)

/* PC-98 text vram locations (32 bits flat addr.) */
#define NEC98TVA         (NEC98Display.screen_ptr)

#define NEC98_TEXT_P0_PTR        (NEC98_TEXT_P0_START+NEC98TVA)
#define NEC98_TEXT_P1_PTR        (NEC98_TEXT_P1_START+NEC98TVA)
#define NEC98_ATTR_P0_PTR        (NEC98_ATTR_P0_START+NEC98TVA)
#define NEC98_ATTR_P1_PTR        (NEC98_ATTR_P1_START+NEC98TVA)

/* PC-98 text vram locations (relative to MVDM's VIDEO memory) */
#define NEC98_TEXT_P0_START      0x0000
#define NEC98_TEXT_P1_START      0x1000
#define NEC98_ATTR_P0_START      0x2000
#define NEC98_ATTR_P1_START      0x3000

/* PC-98 text vram limits (relative to MVDM VIDEO memory) */
#define NEC98_REGEN_START        0x0000
#define NEC98_REGEN_END          0x3ffe

/* Address Conversion macros */
//#define       NEC98_EGA_char_loc(x)            (x-NEC98Display.screen_start)
//#define       NEC98_EGA_attr_loc(x)            (NEC98_EGA_char_loc(x)+NEC98TVA)
#define LINES_PER_SCREEN (NEC98Display.screen_length/NEC98Display.offset_per_line)                                                                                                                                                                                                                /*      (?_?) */ //????????
#define COLUMNS_PER_LINE        (NEC98Display.chars_per_line)
#define OFFSET_PER_LINE         (NEC98Display.offset_per_line)

#define set_crt_on(val) NEC98Display.crt_on=(val)
#define get_crt_on() (NEC98Display.crt_on)
#define set_beep_rate(val)      NEC98Display.beep_rate = (val)
#define get_beep_rate()         (NEC98Display.beep_rate)
#define set_beep_on(val)        NEC98Display.beep_on = (val)
#define get_beep_on()           (NEC98Display.beep_on)
#define set_beep_changed(val)   NEC98Display.beep_changed = (val)
#define get_beep_changed()      (NEC98Display.beep_changed)
#define set_pitch_width(val)    NEC98Display.pitch_width = (val)
#define get_pitch_width()       (NEC98Display.pitch_width)
#define set_blink_rate(val)     NEC98Display.blink_rate = (val)
#define get_blink_rate()        (NEC98Display.blink_rate)
#define set_blink_disable(val)  NEC98Display.blink_disable = (val)
#define get_blink_disable()     (NEC98Display.blink_disable)

#define PC_98   7
//#define NEC98_ATR_BLACK  0

/********************************************************************/
/* Statics/structures for PC-98 H/W architecture                    */
/********************************************************************/
#ifndef NEC98VRAM
#define NEC98VRAM
typedef struct  {
        unsigned short  code;
        unsigned char           attr;
}       NEC98_VRAM_COPY;
#endif

/* Structures represents PC-9801 multi split displaying */
typedef struct  {
        unsigned char *addr;              /* Beginning addr.            */
        int            lines;             /* Number of lines in region. */
} NEC98_SplitElem;

typedef struct  {
        int            nRegions;          /* Number of regions(max4)    */
        NEC98_SplitElem  split[4];         /* Each split elements        */
} NEC98_TextSplits;

extern NEC98_TextSplits  text_splits;    /* CRT split data structure     */
                                        /* Should be opened to ather's  */

/************************************************************************/
/*      Prototype declarations for NEC98 Prototypes                      */
/************************************************************************/
unsigned short Cnv_NEC98_ToSjisLR(NEC98_VRAM_COPY cell,unsigned short *flg);
NEC98_VRAM_COPY Get_NEC98_VramCellL( unsigned short loc );
NEC98_VRAM_COPY Get_NEC98_VramCellA( unsigned short *addr );
unsigned char Cnv_NEC98_atr( unsigned char attr );

#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\haw.h ===
/*[
 *	Product:		SoftWindows Revision 2.0
 *
 *	Name:			haw.h
 *
 *	Derived From:	Original
 *
 *	Authors:		Rob Tizzard
 *
 *	Created On:		16th April 1994
 *
 *	Purpose:		All base/host definitions for the SoftWindows
 *				    host audio wave driver interface.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1994. All rights reserved.
 *
]*/


#ifdef SCCSID
static char SccsID[]="@(#)haw.h	1.2 12/20/94";
#endif

/* Standard device sample formats */

#define HAW_INVALIDFORMAT     0x00000000       /* invalid format */
#define HAW_FORMAT_1M08       0x00000001       /* 11.025 kHz, Mono,   8-bit  */
#define HAW_FORMAT_1S08       0x00000002       /* 11.025 kHz, Stereo, 8-bit  */
#define HAW_FORMAT_1M16       0x00000004       /* 11.025 kHz, Mono,   16-bit */
#define HAW_FORMAT_1S16       0x00000008       /* 11.025 kHz, Stereo, 16-bit */
#define HAW_FORMAT_2M08       0x00000010       /* 22.05  kHz, Mono,   8-bit  */
#define HAW_FORMAT_2S08       0x00000020       /* 22.05  kHz, Stereo, 8-bit  */
#define HAW_FORMAT_2M16       0x00000040       /* 22.05  kHz, Mono,   16-bit */
#define HAW_FORMAT_2S16       0x00000080       /* 22.05  kHz, Stereo, 16-bit */
#define HAW_FORMAT_4M08       0x00000100       /* 44.1   kHz, Mono,   8-bit  */
#define HAW_FORMAT_4S08       0x00000200       /* 44.1   kHz, Stereo, 8-bit  */
#define HAW_FORMAT_4M16       0x00000400       /* 44.1   kHz, Mono,   16-bit */
#define HAW_FORMAT_4S16       0x00000800       /* 44.1   kHz, Stereo, 16-bit */

#define HAW_NAME_LEN  32	/* Device name length */

typedef struct {
      IUM8 channels;  				 /* Number of output channels */
      IBOOL pitch_control;      	 /* If TRUE device has pitch control */
      IBOOL playbackrate_control;  	 /* If TRUE device has playback rate control */ 
      IBOOL volume_control;          /* If TRUE device has volume control */  
      IBOOL lr_volume_control;       /* If TRUE device has left & right volume control */  
      IBOOL synchronous;    		 /* If TRUE device plays sounds synchronously */        
	  IU32	formats;				 /* Standard output sample formats supported */
	  IU8	dev_name[HAW_NAME_LEN];  /* Name of waveform output device */
} HAWO_CAPS;

/*
 * -----------------------------------------------------------------------------
 * Host input capabilites.
 * -----------------------------------------------------------------------------
 */

typedef struct {
      IUM8  channels;   	         /* Number of input channels */
      IBOOL synchronous;             /* If TRUE device records sounds synchronously */
	  IU32	formats;				 /* Standard output sample formats supported */
	  IU8	dev_name[HAW_NAME_LEN];  /* Name of waveform input device */
} HAWI_CAPS;

/*
 * -----------------------------------------------------------------------------
 * Host audio position structure.
 * -----------------------------------------------------------------------------
 */
 
/* position_type field values */

#define HAW_POSN_MILLI_SEC    (IUM8)1
#define HAW_POSN_SAMPLE       (IUM8)2
#define HAW_POSN_BYTE_COUNT   (IUM8)3

typedef struct {

	IUM8 position_type;   
			            
	union {
		IU32 milli_sec;    /* HAW_POSN_MILLI_SEC in milliseconds */
	 	IU32 sample;       /* HAW_POSN_SAMPLE  in number of wave samples*/
	 	IU32 byte_count;   /* HAW_POSN_BYTE_COUNT  in number of wave samples*/
	} u;

} HAW_POSN;

/*
 * -----------------------------------------------------------------------------
 * Host audio formats.
 * -----------------------------------------------------------------------------
 */

#define HAW_PCM_NOCOMPRESS (IUM8)0 /* Pulse Code Modulated, uncompressed. */
 
/* Adaptive Pulse Code Modulated (ADPCM) */

#define HAW_ADPCM_2 (IUM8)1  /* ADPCM, 2:1 compression */
#define HAW_ADPCM_3 (IUM8)2  /* ADPCM, 3:1 compression */
#define HAW_ADPCM_4 (IUM8)3  /* ADPCM, 4:1 compression */


/*
 * -----------------------------------------------------------------------------
 * Host audio function return codes.
 * -----------------------------------------------------------------------------
 */

#define HAW_OK            (IUM8)0  /* Sucessfully completed function. */
#define HAW_NOTSUPPORTED  (IUM8)1  /* Feature not supported */
#define HAW_INVALID       (IUM8)1  /* Feature not supported */

/*
 * -----------------------------------------------------------------------------
 * Default pitch & playback rates for hosts which don't have the support.
 * -----------------------------------------------------------------------------
 */

#define HAW_DEF_PITCH    	(HAW_FIXPNT)  0x00010000 /* 1.0 */
#define HAW_DEF_PLAYBACK    (HAW_FIXPNT)  0x00010000 /* 1.0 */

/*
 * -----------------------------------------------------------------------------
 * Host channel values.
 * -----------------------------------------------------------------------------
 */

#define HAW_MONO		(IUM8) 1
#define HAW_STEREO		(IUM8) 2

/*
 * -----------------------------------------------------------------------------
 * Host audio loop control constants.
 * -----------------------------------------------------------------------------
 */

#define HAW_LOOP_START   (IUM8)1
#define HAW_LOOP_END     (IUM8)2

/*
 * -----------------------------------------------------------------------------
 * Host sample sizes.
 * -----------------------------------------------------------------------------
 */

#define	HAW_SAMPLE_8	 (IUM8)8
#define	HAW_SAMPLE_16	 (IUM8)16

/*
 * -----------------------------------------------------------------------------
 * Host Miscilanous Structures
 * -----------------------------------------------------------------------------
 */
 
typedef IU32 HAW_FIXPNT;		/* Fixed point */

typedef struct {
	LIN_ADDR	callbackData;	/* Call back data */
} HAW_CALLBACK;

/*
 * -----------------------------------------------------------------------------
 * Host audio wave function prototypes.
 * -----------------------------------------------------------------------------
 */
 
extern IUM8 hawo_num_devices IPT0();

extern void hawo_query_capabilities IPT2
   (
   IUM8, device,	   /* Output device */
   HAWO_CAPS, *pcaps   /* Pointer to output capabilities structure. */
   );

extern IUM8 hawo_query_format IPT5
   (
   IUM8, device,	    /* Output device */
   IUM8, channels,      /* channels required */
   IUM8, data_type,     /* Data type, HAW_PCM_NOCOMPRESS, etc. */
   IU32, sample_rate,   /* Samples per second. */
   IUM8, sample_size    /* 8 or 16-bit data samples. */
   );

extern IUM8 hawo_open IPT5
   (
   IUM8, device,	   /* Output device */
   IUM8, channels,     /* channels required */
   IUM8, data_type,    /* Data type, HAW_PCM_NOCOMPRESS, etc. */
   IU32, sample_rate,  /* Samples per second. */
   IUM8, sample_size   /* 8 or 16-bit data samples. */
   );

extern HAW_FIXPNT hawo_get_pitch IPT1
   (
   IUM8, device	    /* Output device */
   );

extern HAW_FIXPNT hawo_get_playback_rate IPT1
   (
   IUM8, device	    /* Output device */
   );

extern IU32 hawo_get_def_volume IPT1
   (
   IUM8, device	    /* Output device */
   );

extern IUM8 hawo_set_pitch IPT2
   (
   IUM8, device,	    /* Output device */
   HAW_FIXPNT, pitch    /* New pitch value */
   );

extern IUM8 hawo_set_playback_rate IPT2
   (
   IUM8, device,	            /* Output device */
   HAW_FIXPNT, playback_rate	/* New playback value */
   );

extern IUM8 hawo_set_volume IPT2
   (
   IUM8, device,	    /* Output device */
   IU32, volume			/* New volume value */
   );

extern void hawo_write IPT6
   (
   IUM8, device,	        /* Output device */
   LIN_ADDR, data_addr,		/* Intel memory Pointer to wave data */
   IU32, data_size,			/* Number of bytes of output data */
   IUM8, flags,				/* Flags controlling loop playback */
   IU32, loops,				/* Number of times to play loop */
   HAW_CALLBACK *, hawo_callback	/* Callback function */
   );

extern void hawo_get_position IPT2
   (
   IUM8, device,	    /* Output device */
   HAW_POSN *, pinfo	/* Pointer to audio position(time) structure */
   );

extern void hawo_pause IPT1
   (
   IUM8, device	    /* Output device */
   );

extern void hawo_restart IPT1
   (
   IUM8, device	    /* Output device */
   );

extern void hawo_reset IPT1
   (
   IUM8, device	    /* Output device */
   );

extern void hawo_close IPT1
   (
   IUM8, device	    /* Output device */
   );

extern IBOOL hawo_is_active IPT1
   (
   IUM8, device	    /* Output device */
   );

extern IUM8 hawo_break_loop IPT2
   (
   IUM8, device,	/* Output device */
   IBOOL, at_end	/* If TRUE action at end of loop, otherwise action immediately */
   );

extern IUM8 hawi_num_devices IPT0();

extern void hawi_query_capabilities IPT1
   (
   HAWI_CAPS, *pcaps   /* Pointer to input capabilities structure. */
   );

extern IUM8 hawi_query_format IPT4
   (
   IUM8, channels,      /* channels required */
   IUM8, data_type,     /* Data type, HAW_PCM_NOCOMPRESS, etc. */
   IU32, sample_rate,   /* Samples per second. */
   IUM8, sample_size    /* 8 or 16-bit data samples. */
   );

extern IUM8 hawi_open IPT5
   (
   IUM8, channels,    /* channels required */
   IUM8, data_type,   /* Data type, HAW_PCM_NOCOMPRESS, etc. */
   IU32, sample_rate, /* Samples per second. */
   IUM8, sample_size,  /* 8 or 16-bit data samples. */
   LIN_ADDR, buff_addr
   );

extern void hawi_get_position IPT1
   (
   HAW_POSN *, pinfo	/* Pointer to audio position(time) structure */
   );

extern void hawi_add_buffer IPT3
   (
   IU32, data_addr,	    			/* Intel memory Pointer to wave data */
   IU32, data_size,	        		/* Number of bytes in input data buffer */
   HAW_CALLBACK *, hawi_callback	/* Callback function */
   );

extern void hawi_start IPT0();

extern void hawi_restart IPT0();

extern IBOOL hawi_is_active IPT0();

extern void hawi_close IPT0();

extern IBOOL hawo_hardware_acquire IPT1
   (
   IUM8, device	    /* Output device */
   );
   
extern IBOOL hawi_hardware_acquire IPT0();

extern void hawo_hardware_realease IPT1
   (
   IUM8, device	    /* Output device */
   );
   
extern void hawi_hardware_realease IPT0();

extern IBOOL hawo_enable IPT0();
extern IBOOL hawi_enable IPT0();

extern IBOOL hawo_disable IPT0();
extern IBOOL hawi_disable IPT0();

extern IBOOL hawo_WEP IPT0();
extern IBOOL hawi_WEP IPT0();

extern void hawo_dec_int_cnt IPT1
   (
   IUM8, device	    /* Output device */
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\gisp_sas.h ===
/*[
 *
 *	File		:	gisp_sas.h
 *
 *	Derived from	:	next_sas.h
 *
 *	Purpose		:	gisp specific Roms offsets
 *				and Rom specific symbols etc.
 *
 *	Author		:	Rog
 *	Date		:	3 Feb 1993
 *
 *	SCCS id		:	@(#)gisp_sas.h	1.5 02/22/94
 *	
 *	(c) Copyright Insignia Solutions Ltd., 1992 All rights reserved
 *
 *	Modifications	:	
 *
]*/

#ifdef GISP_SVGA
#ifndef _GISP_SAS_H_
#define _GISP_SAS_H_

/* Offsets of our stuff into the ROMS */

/* from VGA.ASM */

#define INT10CODEFRAG_OFF	0x0400	/* Code frag to perform INT 10 */
#define FULLSCREENFLAG_OFFSET 	0x0410	/* Use host BIOS ? */
#define GISP_INT_10_ADDR_OFFSET	0x830	/* Int 10 moved to int 42 offset */
#define HOST_BIOS_ROUTINE	0x0821	/* JMP addr to patch */
#define HOST_INT_42_BIOS_ROUTINE	0x0841 /* Other JMP addr to patch :-) */


#ifdef IRET_HOOKS
/*
 *	The offset in bios1 of the BOP that returns us to the monitor.
 */

#define BIOS_IRET_HOOK_OFFSET	0x1c00
#endif /* IRET_HOOKS */


/* Data for the ROM moving stuff */

/* The address of the INT 10 entry point into the Host macines ROMS */

struct
HostVideoBiosEntrytag
{
		word	segment;
		word	offset;
} HostVideoBiosEntry , HostVideoBiosInt42Entry;

extern GLOBAL IBOOL LimBufferInUse IPT0();

#endif		/* _GISP_SAS_H_ */
#endif /* GISP_SVGA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\hfx.h ===
/*
 * SoftPC Revision 3.0
 *
 * Title	: hfx.h
 *
 * Description	: Definitions and external declarations for HFX.
 *
 * Author	: J. Koprowski + L. Dworkin
 *
 * Sccs ID	: @(#)hfx.h	1.32 05/24/95
 *
 * Notes	:
 *
 * Mods		:
 */

#ifdef HFX

#ifdef SCCSID
/* static char SccsID[]="@(#)hfx.h	1.32 05/24/95 Copyright Insignia Solutions Ltd."; */
#endif

/****************************************************************/
/*								*/
/*           Redirector type definitions and constants.         */
/*								*/
/****************************************************************/
/*
 * Redirector CDS or current directory structure.
 */
#define DIRSTRLEN	(64+3)
#define TEMPLEN		(DIRSTRLEN*2)

typedef struct {
	char	curdir_text[DIRSTRLEN];	/* text of assignment and curdir */
	word		curdir_flags;	/* various flags */
	double_word	curdir_devptr;	/* local pointer to DPB or net device */
	word		curdir_id;	/* cluster of current dir (net ID) */
	word		whoknows;
	word		curdir_user_word;
	word		curdir_end;	/* end of assignment */
} CDS;

/* Flag word masks */
#define curdir_isnet	0x8000
#define curdir_inuse	0x4000
#define curdir_splice	0x2000
#define curdir_local	0x1000
#define curdir_sharing	0x0800
#define curdir_iscdrom	0x0080	/* this works with MSCDEX 2.20 */

/* The location of the fake IFS header we place in ROM */
/* to make DOS 4.01 happy. */

#define	IFS_SEG	0xf000
#define IFS_OFF	0x6000

#define REDIRIN	0x8
#define RECVRIN 0x80
#define MSNGRIN	0x4
#define SRVRIN	0x40

#ifndef PROD
extern IU32 severity;
#include "trace.h"

#define DEBUG_INPUT	0x1
#define DEBUG_REG	0x2
#define DEBUG_FUNC	0x4
#define DEBUG_HOST	0x8
#define DEBUG_INIT	0x10
#define DEBUG_CHDIR	0x20
#define hfx_trace0(trace_bit,str)	if(severity&trace_bit){fprintf(trace_file,str);}
#define hfx_trace1(trace_bit,str,p1)	if(severity&trace_bit){fprintf(trace_file,str,p1);}
#define hfx_trace2(trace_bit,str,p1,p2)	if(severity&trace_bit){fprintf(trace_file,str,p1,p2);}
#define hfx_trace3(trace_bit,str,p1,p2,p3)	if(severity&trace_bit){fprintf(trace_file,str,p1,p2,p3);}
#define hfx_trace4(trace_bit,str,p1,p2,p3,p4)	if(severity&trace_bit){fprintf(trace_file,str,p1,p2,p3,p4);}
#else
#define hfx_trace0(trace_bit,str)
#define hfx_trace1(trace_bit,str,p1)
#define hfx_trace2(trace_bit,str,p1,p2)
#define hfx_trace3(trace_bit,str,p1,p2,p3)
#define hfx_trace4(trace_bit,str,p1,p2,p3,p4)
#endif /* !PROD */

typedef struct {
	double_word	SFLink;
	word		SFCount;
	word		SFTable;
} SF;

typedef struct {
	word		sf_ref_count;
	word		sf_mode;
	half_word	sf_attr;
	word		sf_flags;
	double_word	sf_devptr;
	word		sf_firclus;
	word		sf_time;
	word		sf_date;
	double_word	sf_size;
	double_word	sf_position;
	word		sf_cluspos;
	word		sf_dirsecl;
	word		sf_dirsech; /* Grew to 32 bits in DOS 4+ */
	half_word	sf_dirpos;
	half_word	sf_name[11];
	double_word	sf_chain;
	word		sf_UID;
	word		sf_PID;
	word		sf_MFT;
/*
 * New DOS 4+ fields. lst_clus field moved down here
 * because dirsec field grew to 32 bits.
 */
	word		sf_lst_clus;/* moved down */
	double_word	sf_ifs;		/* file is in this file sys */
} sf_entry;

#define SF_REF_COUNT 	sft_ea + 0
#define SF_MODE		sft_ea + 2
#define SF_ATTR		sft_ea + 4
#define SF_FLAGS	sft_ea + 5
#define SF_DEVPTR	sft_ea + 7
#define SF_FIRCLUS	sft_ea + 11	/* 0xb */
#define SF_TIME		sft_ea + 13	/* 0xd */
#define SF_DATE		sft_ea + 15	/* 0xf */
#define SF_SIZE		sft_ea + 17	/* 0x11 */
#define SF_POSITION	sft_ea + 21	/* 0x15 */
#define SF_CLUSPOS	sft_ea + 25	/* 0x19 */
#define SF_DIRSECL	sft_ea + 27	/* 0x1b */
#define SF_DIRSECH	sft_ea + 29	/* 0x1d */
#define SF_DIRPOS	sft_ea + 31	/* 0x1f */
#define SF_NAME		sft_ea + 32	/* 0x20 */
#define SF_CHAIN	sft_ea + 43	/* 0x2b */
#define SF_UID		sft_ea + 47	/* 0x2f */
#define SF_PID		sft_ea + 49	/* 0x31 */
#define SF_MFT		sft_ea + 51	/* 0x33 */
#define SF_LST_CLUS	sft_ea + 53 /* 0x35 - moved down here for DOS 4+ */
#define SF_IFS		sft_ea + 55 /* 0x37 */

#define SF_NET_ID SF_CLUSPOS

#define sf_default_number 0x5
#define sf_busy 0xffff
#define sf_free 0

#define sf_isfcb 0x8000
#define sf_isnet 0x8000
#define sf_close_nodate 0x4000
#define sf_pipe 0x2000
#define sf_no_inherit 0x1000
#define sf_net_spool 0x0800

#define devid_file_clean	0x40
#define devid_file_mask_drive	0x3f

#define devid_device		0x80
#define devid_device_EOF	0x40
#define devid_device_raw	0x20
#define devid_device_special	0x10
#define devid_device_clock	0x08
#define devid_device_null	0x04
#define devid_device_con_out	0x02
#define devid_device_con_in	0x01

#define devid_block_dev		0x1f

/* file modes */
#define access_mask	0x0f
#define open_for_read	0x00
#define open_for_write	0x01
#define open_for_both	0x02

#define sharing_mask		0xf0
#define sharing_compat		0x00
#define sharing_deny_both	0x10
#define sharing_deny_write	0x20
#define sharing_deny_read	0x30
#define sharing_deny_none	0x40
#define sharing_net_FCB		0x70
#define sharing_no_inherit	0x80

/*
 * DOS 4+ Extended Open "Does exist" & "Doesn't exist" action values.
 */

#define DX_MASK		0x03
#define DX_FAIL		0x00
#define DX_OPEN		0x01
#define DX_REPLACE	0x02

#define NX_MASK		0x30
#define NX_FAIL		0x00
#define NX_CREATE	0x10

/*
 * DOS error codes.
 * N.B. error_not_error is specific to this implementation, although
 * DOS assumes an error return of zero equals success.
 */
#define error_not_error			0
#define error_invalid_function		1
#define error_file_not_found		2
#define error_path_not_found		3
#define error_too_many_open_files	4
#define error_access_denied		5
#define error_invalid_handle		6
#define error_arena_trashed		7
#define error_not_enough_memory		8
#define error_invalid_block		9
#define error_bad_environment		10
#define error_bad_format		11
#define error_invalid_access		12
#define error_invalid_data		13
#define error_reserved			14
#define error_invalid_drive		15
#define error_current_directory		16
#define error_not_same_device		17
#define error_no_more_files		18

/* These are the universal int 24 mappings for the old INT 24 set of errors */
#define error_write_protect		19
#define error_bad_unit			20
#define error_not_ready			21
#define error_bad_command		22
#define error_CRC			23
#define error_bad_length		24
#define error_Seek			25
#define error_not_DOS_disk		26
#define error_sector_not_found		27
#define error_out_of_paper		28
#define error_write_fault		29
#define error_read_fault		30
#define error_gen_failure		31

/* These are the new 3.0 error codes reported through INT 24 */
#define error_sharing_violation		32
#define error_lock_violation		33
#define error_wrong_disk		34
#define error_FCB_unavailable		35
#define error_sharing_buffer_exceeded	36

/* New OEM network-related errors are 50-79 */
#define error_not_supported		50

/* End of INT 24 reportable errors */
#define error_file_exists		80
#define error_DUP_FCB			81
#define error_canot_make		82
#define error_FAIL_I24			83

/* New 3.0 network related error codes */
#define error_out_of_structures		84
#define error_Already_assigned		85
#define error_invalid_password		86
#define error_invalid_parameter		87
#define error_NET_write_fault		88
/*
 * error_is_not_directory is a code specific to this implementation.
 * It enables more code to be put in the base.
 */
#define error_is_not_directory		89

/* Interrupt 24 error codes */
#define error_I24_write_protect		0
#define error_I24_bad_unit		1
#define error_I24_not_ready		2
#define error_I24_bad_command		3
#define error_I24_CRC			4
#define error_I24_bad_length		5
#define error_I24_Seek			6
#define error_I24_not_DOS_disk		7
#define error_I24_sector_not_found	8
#define error_I24_out_of_paper		9
#define error_I24_write_fault		0xa
#define error_I24_read_fault		0xb
#define error_I24_gen_failure		0xc
/* NOTE: Code 0xD is used by MT-DOS */
#define error_I24_wrong_disk		0xf

/* The following are masks for the AH register on Int 24 */
#define Allowed_FAIL			0x08
#define Allowed_RETRY			0x10
#define Allowed_IGNORE			0x20
/* Note: ABORT is always allowed */

#define I24_operation			0x1	/* Z if READ, NZ if WRITE */
#define I24_area			0x6	/* 00 if DOS
						 * 01 if FAT
						 * 10 if root DIR
						 * 11 if DATA */
#define I24_class			0x80	/* Z if DISK, NZ if FAT */

/*
 * The following are offsets within the fifty three byte structure that
 * is used by search first and search next operations.
 */
#define DMA_DRIVE_BYTE 0
#define DMA_SEARCH_NAME 1
#define DMA_SATTRIB 12
#define DMA_LASTENT 13
#define DMA_DIRSTART 15
#define DMA_LOCAL_CDS 17
#define DMA_UNKNOWN 19
#define DMA_NAME 21
#define DMA_ATTRIBUTES 32
#define DMA_TIME 43
#define DMA_DATE 45
#define DMA_CLUSTER 47
#define DMA_FILE_SIZE 49

/*
 * DOS access masks used by create and open.
 */
#define open_for_read	0x00
#define open_for_write	0x01
#define open_for_both	0x02

/*
 * DOS file attribute masks.
 */
#define attr_read_only	0x1
#define attr_hidden	0x2
#define attr_system	0x4
#define attr_volume_id	0x8
#define attr_directory	0x10
#define attr_archive	0x20
#define attr_device	0x40

#define attr_bad	0x80
#define attr_good	0x7f

#define attr_all	(attr_hidden|attr_system|attr_directory)
#define attr_ignore	(attr_read_only|attr_archive|attr_device)
#define attr_changeable (attr_read_only|attr_hidden|attr_system|attr_archive)

/*
 * Disk information structure used by NetDiskInfo in the base,
 * and host_diskinfo.
 */
typedef struct
{
	double_word total_clusters;	/* Total number of blocks. */
	double_word clusters_free;	/* Total number of blocks free. */
	double_word bytes_per_sector;
	double_word sectors_per_cluster;
} DOS_DISK_INFO;

/*
 * Non-alphabetic DOS legal characters.  !! Needs checking. !!
 */
#define NON_ALPHA_DOS_CHARS "01234567890_-@$%^&!#{}()~`'"

/*
 * DOS file name length limits.
 */
#define MAX_DOS_NAME_LENGTH 8
#define MAX_DOS_EXT_LENGTH 3
#define MAX_DOS_FULL_NAME_LENGTH 12

/* defines for host_lseek "whence" */
#define REL_START 0
#define REL_CUR 1
#define REL_EOF 2

/****************************************************************/
/*								*/
/*		 HFX directory details structure.		*/
/*								*/
/****************************************************************/

typedef struct hfx_found_dir_entry
{
	half_word			attr;
	CHAR				*host_name;
	CHAR				*dos_name;
	LONG				direntry;
	struct hfx_found_dir_entry	*next;
} HFX_FOUND_DIR_ENT;

/*
 * This structure is actually host specific because of the 
 * HFX_DIR field which is defined in host_hfx.h and which must 
 * therefore be included prior to this file.
 */

typedef struct hfx_direntry
{
	HOST_DIR			*dir;
	CHAR				*name;
	CHAR				*template;
	LONG				direntry;
	HFX_FOUND_DIR_ENT		*found_list_head;
	HFX_FOUND_DIR_ENT		*found_list_curr;
	BOOL				first_find;
	struct hfx_direntry		*next;
	struct hfx_direntry		*last;
	half_word			search_attr;

	/* AJO 26/11/92
	 * The following is required to support architectures where
	 * pointers are longer than 32 bits.
	 */
#if LONG_SHIFT > 2
	IU32				id;
#endif /* LONG_SHIFT > 2 */
} HFX_DIR;

/****************************************************************/
/*								*/
/*		 External function declarations.		*/
/*								*/
/****************************************************************/
/*
 * Functions for generating mapped file extensions.
 */
extern unsigned short calc_crc	IPT2(unsigned char *, host_name,
	unsigned short, name_length);
extern void crc_to_str	IPT2(unsigned short, crc, unsigned char *, extension);

/*
 * Functions for retrieving system variables used by the redirector.
 */
extern void cds_info	IPT3(word, seg, word, off, int, num_cds_entries);
extern void sft_info	IPT2(word, seg, word, off);
extern double_word get_wfp_start	IPT0();
extern word get_curr_dir_end	IPT0();
extern double_word get_thiscds	IPT2(word *, seg, word *, off);
extern double_word get_thissft	IPT0();
extern double_word get_es_di	IPT0();
extern double_word get_ds_si	IPT0();
extern double_word get_ds_dx	IPT0();
extern half_word get_sattrib	IPT0();
extern double_word get_ren_wfp	IPT0();
extern double_word get_dmaadd	IPT1(int, format);
extern word get_current_pdb	IPT0();
extern double_word get_sftfcb	IPT0();
extern char *get_hfx_root	IPT1(half_word, hfx_entry);
extern char *get_hfx_global	IPT1(half_word, hfx_entry);
extern validate_hfxroot	IPT1(char *, path);
extern void hfx_root_changed	IPT1(char *, name);
extern word get_xoflag	IPT0();
extern void set_usercx	IPT1(word, cx);

/*
 * Redirector net functions.
 */
extern word NetInstall	IPT0();
extern word NetRmdir	IPT0();
extern word NetMkdir	IPT0();
extern word NetChdir	IPT0();
extern word NetClose	IPT0();
extern word NetCommit	IPT0();
extern word NetRead	IPT0();
extern word NetWrite	IPT0();
extern word NetLock	IPT0();
extern word NetUnlock	IPT0();
extern word NetDiskInfo	IPT0();
extern word NetSet_file_attr	IPT0();
extern word NetGet_file_info	IPT0();
extern word NetRename	IPT0();
extern word NetDelete	IPT0();
extern word NetOpen	IPT0();
extern word NetCreate	IPT0();
extern word NetSeq_search_first	IPT0();
extern word NetSeq_search_next	IPT0();
extern word NetSearch_first	IPT0();
extern word NetSearch_next	IPT0();
extern word NetAbort	IPT0();
extern word NetAssoper	IPT0();
extern word NetPrinter_Set_String	IPT0();
extern word NetFlush_buf	IPT0();
extern word NetLseek	IPT0();
extern word NetReset_Env	IPT0();
extern word NetSpool_check	IPT0();
extern word NetSpool_close	IPT0();
extern word NetSpool_oper	IPT0();
extern word NetSpool_echo_check	IPT0();
extern word NetUnknown	IPT0();
extern word NetExtendedAttr	IPT0();
extern word NetExtendedOpen	IPT0();

/*
 * Redirector as called by BOP 2F instruction.
 */
extern void redirector	IPT0();

/*
 * Base utility functions found in hfx_util.c.
 */
extern void pad_filename	IPT2(unsigned char *, instr,
	unsigned char *, outstr);
extern void unpad_filename	IPT2(unsigned char *, iname,
	unsigned char *, oname);
extern boolean match	IPT7(unsigned char *, host_path,
	unsigned char *, template, half_word, sattrib, int, init,
	unsigned char *, host_name, unsigned char *, dos_name,
	half_word *, attr);
extern int find	IPT7(HFX_DIR *, dir_ptr, unsigned char *, template,
	half_word, sattrib, unsigned char *, host_name,
	unsigned char *, dos_name, half_word *, attr, int, last_addr);
extern void cleanup_dirlist	IPT0();
extern boolean is_open_dir	IPT1(HFX_DIR *, dir_ptr);
extern void tidy_up_dirptr	IPT0();
extern void rm_dir	IPT1(HFX_DIR *, dir_ptr);

#if LONG_SHIFT > 2
/* AJO 26/11/92
 * Additional base utility functions required for architectures with pointers
 * longer than 32bits; found in hfx_util.c.
 */
extern HFX_DIR *hfx_get_dir_from_id IPT1 (IU32, hfx_dir_id);
#endif /* LONG_SHIFT > 2 */

/*
 * Base functions found in hfx_share.c.
 */
extern word check_access_sharing	IPT3(word, fd, half_word, a_s_m,
	boolean, rdonly);

/*
 * Base functions found in redirect.c.
 */
extern int net_use	IPT2( half_word, drive, char *, name );
extern int net_change	IPT2( half_word, drive, char *, name );
extern IBOOL is_global_hfx_drive	IPT1( half_word, hfx_entry);
extern int get_lastdrive	IPT0();
extern half_word get_current_drive IPT0();
extern VOID resolve_any_net_join IPT2(CHAR *,dos_path_in,CHAR *,dos_path_out);

extern BOOL cds_is_sharing IPT1(CHAR *, dos_path);

/*
 * Host functions in xxx_hfx.c called from HFX.
 */
extern void host_concat	IPT3(unsigned char *, path, unsigned char *, name,
	unsigned char *, result);
extern word host_create	IPT4(unsigned char *, name, word, attr,
	half_word, create_new, word *, fd);
extern void host_to_dostime	IPT3(time_t, secs_since_70, word *, date,
	word *, time);
extern time_t host_get_datetime	IPT2(word *, date, word *, thetime);
extern int host_set_time	IPT2(word, fd, time_t, hosttime);
extern word host_open	IPT6(unsigned char *, name, half_word, attrib,
	word *, fd, double_word *, size, word *, date, word *, thetime);
extern word host_truncate	IPT2(word, fd, long, size);
extern word host_close	IPT1(word, fd);
extern word host_commit	IPT1(word, fd);
extern word host_write	IPT4(word, fd, unsigned char *, buf, word, num,
	word *, count);
extern word host_read	IPT4(word, fd, unsigned char *, buf, word, num,
	word *, count);
extern word host_delete	IPT1(unsigned char *, name);
extern word host_rename	IPT2(unsigned char *, from, unsigned char *, to);
extern half_word host_getfattr	IPT1(unsigned char *, name);
extern word host_get_file_info	IPT4(unsigned char *, name, word *, thetime,
	word *, date, double_word *, size);
extern word host_set_file_attr	IPT2(unsigned char *, name, half_word, attr);
extern word host_lseek	IPT4(word, fd, double_word, offset, int, whence,
	double_word *, position);
extern word host_lock	IPT3(word, fd, double_word, start, double_word, length);
extern word host_unlock	IPT3(word, fd, double_word, start, double_word, length);
extern int host_check_lock	IPT0();
extern void host_disk_info	IPT2(DOS_DISK_INFO *, disk_info, int, drive);
extern word host_rmdir	IPT1(unsigned char *, host_path);
extern word host_mkdir	IPT1(unsigned char *, host_path);
extern word host_chdir	IPT1(unsigned char *, host_path);
extern void host_get_volume_id	IPT2(unsigned char *, net_path,
	unsigned char *, volume_id);
extern word host_gen_err	IPT1(int, the_errno);
extern void init_fd_hname	IPT0();

#ifndef	host_opendir
extern HOST_DIR *host_opendir	IPT1(const char *, host_path);
#endif	/* host_opendir */

#ifndef	host_readdir
extern struct host_dirent *host_readdir	IPT1(HOST_DIR *, dirp);
#endif	/* host_readdir */

#ifndef	host_access
extern int host_access	IPT2(unsigned char *, host_name, int, mode);
#endif	/* host_access */

extern CHAR *host_machine_name IPT0();
extern CHAR *host_get_file_name IPT1(CHAR *,pathname);
extern CHAR *host_make_file_path IPT3(CHAR *,buf, CHAR *,dirname,
                                     CHAR *,filename);
extern time_t host_dos_to_host_time IPT2( IU16, date, IU16, time );

#ifndef hfx_rename
extern INT hfx_rename IPT2(CHAR *,from, CHAR *,to);
#endif	/* hfx_rename */




/*
 * Host functions in xxx_map.c.
 */
extern int host_map_file	IPT4(unsigned char *, host_name,
	unsigned char *, match_name, unsigned char *, dos_name,
	unsigned char *, curr_dir);
extern boolean host_validate_path	IPT4(unsigned char *, net_path,
	word *, start_pos, unsigned char *, host_path, word, new_file);
extern void host_get_net_path	IPT3(unsigned char *, net_path,
	unsigned char *, original_dos_path, word *, start_pos);

/*
 * Host functions in xxx_unix.c or equivalent.
 */
extern boolean host_file_is_directory	IPT1(char *, name);
extern boolean host_validate_pathname	IPT1(char *, name);
extern boolean host_check_read_access	IPT1(char *, name);

extern half_word dos_ver;

/*
 * The following are constants associated with redirector system
 * variables.  However, their location varies between DOS versions
 * three and four, so variables need to be used.
 */
extern word DMAADD;
extern word CurrentPDB;
extern word SATTRIB;
extern word THISSFT;
extern word THISCDS;
extern word WFP_START;
extern word REN_WFP;
extern word CURR_DIR_END;
extern word SFT_STRUCT_LENGTH;

/* ================================================================== */

/*
   Instance Variables for HFX Driver, ie those variables which must
   be set up for each Virtual Machine under Windows 3.x. The NIDDB
   Manager (cf virtual.c) basically forces us to define these in one
   memory area.
 */

/* The instance structure (All variables tagged HFX_IN_) */
typedef struct
   {
   half_word HFX_IN_primary_drive;
   char **   HFX_IN_hfx_root_dir;
   int       HFX_IN_num_hfx_drives;   /* no. of hfx drives in use */
   int       HFX_IN_max_hfx_drives;   /* no. of possible drives to use */
   word      HFX_IN_old_flags[26];
   BOOL      HFX_IN_inDOS;
   BOOL      HFX_IN_HfxInstalled;     /* DOS has HFX driver (FSADRIVE) installed */

   /*
      Holds whether a drive is case sensitive or not, each drive masked
      in:  0 = case sensitive
           1 = case insensitive
    */
   IU32      HFX_IN_case_sense;

   /*
      Holds whether the default case for file names should be upper or lower
      case: 0 = lower case
            1 = upper case
    */
   IU32	     HFX_IN_upper_case;

   /*
      Holds whether the drive is in global use by hfx:
			0 = not in use by hfx
            1 = in use by hfx
    */
   IU32	     HFX_IN_global_hfx_drive;

   /*
      Holds the drive number related to the current HFX operation,
      setup in test_for_us().
    */
   IU8       HFX_IN_curr_driveno;
   HOST_DIR  *HFX_IN_this_dir;
   HFX_DIR   *HFX_IN_head_dir_ptr;
   HFX_DIR   *HFX_IN_tail_dir_ptr;
   UTINY     HFX_IN_current_dir[MAX_PATHLEN];   /* UNIX HOST requirement */
   } HFX_INSTANCE_DATA, **HFX_INSTANCE_DATA_HANDLE;

IMPORT HFX_INSTANCE_DATA_HANDLE hfx_handle;

/* Define access to instance variables via handle */
#define primary_drive  ((*hfx_handle)->HFX_IN_primary_drive)
#define hfx_root_dir   ((*hfx_handle)->HFX_IN_hfx_root_dir)
#define num_hfx_drives ((*hfx_handle)->HFX_IN_num_hfx_drives)
#define max_hfx_drives ((*hfx_handle)->HFX_IN_max_hfx_drives)
#define old_flags      ((*hfx_handle)->HFX_IN_old_flags)
#define inDOS          ((*hfx_handle)->HFX_IN_inDOS)
#define HfxInstalled   ((*hfx_handle)->HFX_IN_HfxInstalled)
#define case_sense     ((*hfx_handle)->HFX_IN_case_sense)
#define upper_case     ((*hfx_handle)->HFX_IN_upper_case)
#define global_hfx_drive      ((*hfx_handle)->HFX_IN_global_hfx_drive)
#define curr_driveno   ((*hfx_handle)->HFX_IN_curr_driveno)
#define this_dir       ((*hfx_handle)->HFX_IN_this_dir)
#define head_dir_ptr   ((*hfx_handle)->HFX_IN_head_dir_ptr)
#define tail_dir_ptr   ((*hfx_handle)->HFX_IN_tail_dir_ptr)
#define current_dir    ((*hfx_handle)->HFX_IN_current_dir)

/* ================================================================== */

enum
{
	DRIVE_FREE,
	DRIVE_RESERVED,
	DRIVE_INUSE
};

typedef	IU8	drv_stat;

IMPORT drv_stat	get_hfx_drive_state	IPT1(IU8, drive);
IMPORT void		set_hfx_drive_state	IPT2(IU8, drive, drv_stat, state);


#ifdef SWIN_HFX
/*
 *	Function called by Softwindows to check for network files, and
 *	function called by it to open a file.
 */

extern IBOOL Hfx_is_net_file IPT1(sys_addr, fname);
extern IU32 Hfx_open_file IPT7(IU8, function, IU8, flags, sys_addr, fname, IU16 *,fd_p, IU16 *, date, IU16 *, time, IBOOL *, rdonly);
extern IU32 Hfx_file_exists IPT1(sys_addr, fname);

/*
 *	An additional "unix like" file function, to duplicate a file handle.
 *	Returns -1 on failure.
 */

extern IS16 host_duph IPT1(IS16, oldHandle);

#endif /* SWIN_HFX */
#endif /* HFX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\herc.h ===
/*
 * VPC-XT Revision 2.0
 *
 * Title	: Hercules Mono Display Adaptor declarations
 *
 * Description	: Definitions for users of the Hercules MDA
 *
 * Author	: P. Jadeja 
 *
 * Notes	: None
 */


/* SccsID[]=" @(#) @(#)herc.h	1.4 08/10/92 02/02/89 01/17/89 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/* None */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#define HERC_SCAN_LINE_LENGTH 90

extern void herc_init IPT0();
extern void herc_term IPT0();
extern void herc_inb IPT2(io_addr, port, half_word *, value);
extern void herc_outb IPT2(io_addr, port, half_word, value);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\harness.h ===
/*
*	MODULE:		harness.h
*
*	PURPOSE:	Some macros and typedefs etc for the test harness.
*				This file should be #included into the C file
*				which contains the function table.
*
*	AUTHOR:		Jason Proctor
*
*	DATE:		Fri Aug 11 1989
*/

/* SccsID[]="@(#)harness.h	1.3 08/10/92 Copyright Insignia Solutions Ltd."; */

/* harness-wide system parameters */
#define MAXLINE	64
#define MAXFILE 16
#define MAXARGS	8

/* defines for standard C return types */
#define VOID	0
#define CHAR	1
#define SHORT	2
#define INT		3
#define LONG	4
#define HEX		5
#define LONGHEX	6
#define FLOAT	7
#define DOUBLE	8
#define STRPTR	9
#define BOOL	10
#define SYS		11

/* states for argument extraction subroutine */
#define NOTINQUOTE	0
#define INSQUOTE	1
#define INDQUOTE	2

/* typedef for master function table */
typedef struct
{
	char *func_name;			/* name of the function as a string */
	int nparams;				/* how many params it takes */
	int return_type;			/* what kind of animal it returns */
	int (*func) ();				/* pointer to 'glue' function */
	int arg_type1;				/* type of arg 1 */
	int arg_type2;				/* .... etc .... */
	int arg_type3;
	int arg_type4;
	int arg_type5;
	int arg_type6;
	int arg_type7;
	int arg_type8;
} Functable;

/* typedef for linked list of variables */
typedef struct Var_List
{
	struct Var_List *next;
	struct Var_List *prev;
	char *vname;
	char *value;
	int vsize;
} Varlist;

/* typedef for return code union */
/* can be reduced to just longs and doubles (I think) */
/* due to return codes being held in registers/globals etc */
typedef union
{
	int i;
	long l;
	char *p;
	float f;
	double d;
} Retcodes;

/* macros for return code bits to make life easier */
#define ret_char		retcode.i
#define ret_short		retcode.i
#define ret_int			retcode.i
#define ret_long		retcode.l
#define ret_hex			retcode.i
#define ret_longhex		retcode.l
#define ret_strptr		retcode.p
#define ret_bool		retcode.i
#define ret_sys			retcode.i

/* and these are treated as doubles */
#define ret_float		retcode.f
#define ret_double		retcode.d
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\hg_sas.h ===
/*===========================================================================*/

/*[
 * File Name		: hg_sas.h
 *
 * Derived From		: 
 *
 * Author		: Jane Sales
 *
 * Creation Date	: 29th August, 1992
 *
 * SCCS Version		: @(#)hg_sas.h	1.1 08/06/93
 *!
 * Purpose
 *	The hardware CPU - SAS interface
 *
 *! (c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
]*/

/*===========================================================================*/

extern void  a3_cpu_reset IPT0 ();
extern void  intl_cpu_init IPT1 (IU32, size);
extern IBOOL hg_protect_memory IPT3 (IU32, address, IU32, size, IU32, access);

extern void hh_enable_20_bit_wrapping IPT0 ();
extern void hh_disable_20_bit_wrapping IPT0 ();

extern void m_set_sas_base IPT1 (IHP, address);

/*===========================================================================*/
/*===========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\hg_stat.h ===
/*===========================================================================*/
/*[
 *	File Name		:	hg_stat.h
 *
 *	Derived from		:	New.
 *
 *	Author			:	Wayne Plummer 
 *
 *	Creation Date		:	12 Apr 1993
 *	
 *	SCCS Version		:	@(#)hg_stat.h	1.1 08/06/93
 *!
 *	Purpose	
 *		This header file declares the variables and macros used
 *		for stats gathering in non-PROD builds of the GISP CPU.
 *
 *!	(c) Copyright Insignia Solutions Ltd., 1993. All rights reserved.
 *
]*/

/*===========================================================================*/

#ifdef PROD
#define PC_S_INC(NAME)
#else /* PROD */
#define PC_S_INC(NAME)	NAME++

IMPORT IU32	HG_S_SIM, HG_S_CALLB, HG_S_E20, HG_S_D20, HG_S_MINV,
		HG_S_LDT, HG_S_IDT, HG_S_CQEV, HG_S_PROT, HG_S_EIF,
		HG_S_INTC, HG_S_INTR, HG_S_PINT, HG_S_PFLT, HG_S_PVINT,
		HG_S_PWINT, HG_S_PWFLT, HG_S_PPMINT, HG_S_INTNH, HG_S_FLTH,
		HG_S_FLT1H, HG_S_FLT6H, HG_S_FLT6H_PFX, HG_S_FLT6H_BOP,
		HG_S_FLT6H_NOTBOP, HG_S_FLT6H_LOCK, HG_S_FLT13H, HG_S_FLT14H, HG_S_BOPFB,
		HG_S_BOPFB0, HG_S_BOPFB1, HG_S_BOPFB2, HG_S_BOPFB3,
		HG_S_SQEV, HG_S_GQEV, HG_S_TDQEV, HG_S_HOOK, HG_S_IHOOK,
		HG_S_UHOOK, HG_S_HOOKSEL, HG_S_HOOKBOP;

#endif /* PROD */

/*===========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\host.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: host.h
 *
 * Description	: Host specific declarations for the machine dependant
 *		  modules of SoftPC. THIS IS A BASE INCLUDE FILE
 *
 * Author	: Henry Nash
 *
 * Notes	: Everything in here must portable !!!
 */

/* SccsID[]="@(#)host.h	1.6 09/14/93 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#ifdef PC_CONFIG
extern void pc_config();	
#endif

IMPORT	VOID	host_flip_real_floppy_ind IPT2(int, drive, BOOL, active);


extern void host_floppy_init();
extern void host_floppy_term();
extern void host_reset();

extern boolean host_rdiskette_open_drive();


/* Unix Utilities - xxxx_unix.c */
extern char           *host_get_cur_dir();
#ifndef host_memset
extern void            host_memset();
#endif /* nhost_memset */
extern int             host_get_file_size();
extern boolean         host_file_is_directory();
extern boolean         host_validate_pathname();
extern boolean         host_check_rd_wt_access();
extern boolean         host_check_read_access();
#ifdef SUSPEND
extern void	       suspend_softpc();
#endif
#ifndef REAL_VGA
IMPORT VOID memset4 IPT3( IU32, data, ULONG *, laddr, ULONG, count );
#endif
IMPORT VOID fill_alternate_bytes IPT3( IS8 *, start, IS8 *, end, IS8, value);
IMPORT VOID fill_both_bytes IPT3( IU16, data, IU16 *, dest, ULONG, len );

#ifdef	SETUID_ROOT

/* real/effective user ID stuff */
IMPORT void host_init_uid IPT0 ();
IMPORT void host_set_root IPT0 ();
IMPORT void host_revert_uid IPT0 ();

#endif	/* SETUID_ROOT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\host_cfg.h ===
/*[
	host_cfg.h	1.2 08/10/92

	(c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
]*/



#ifndef _HOST_CONFIG_H		/* ensure we are only included once */
#define _HOST_CONFIG_H

#endif	/* _HOST_CONFIG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\hosthunt.h ===
/*[
 *	Name:		host_hunt.h
 *	Derived from:	Original
 *	Author:		Philippa Watson
 *	Created on:	27 June 1991
 *	Sccs ID:	@(#)hosthunt.h	1.5 09/27/93
 *	Purpose:	This file contains host-configurable items for Hunter.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
 *
]*/

/* None of this file is needed for non-HUNTER builds. */
#ifdef	HUNTER

/*
** Binary file access modes.
*/

#ifdef NTVDM
#define	RB_MODE		"rb"
#define	WB_MODE		"wb"
#define	AB_MODE		"ab"
#else
#define	RB_MODE		"r"
#define	WB_MODE		"w"
#define	AB_MODE		"a"
#endif

/*
 * Host to PC co-ordinate conversion, and vice-versa.
 */
 
#define host_conv_x_to_PC(mode, x)	x_host_to_PC(mode, x)
#define host_conv_y_to_PC(mode, y)	y_host_to_PC(mode, y)
#define host_conv_PC_to_x(mode, x)	x_PC_to_host(mode, x)
#define host_conv_PC_to_y(mode, y)	y_PC_to_host(mode, y)

#endif	/* HUNTER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\hg_cpu.h ===
/*===========================================================================*/

/*[
 * File Name		: hg_cpu.h
 *
 * Derived From		:
 *
 * Author		: Jane Sales
 *
 * Creation Date	: 20th July, 1992
 *
 * SCCS Version		: @(#)hg_cpu.h	1.2 08/19/94
 *!
 * Purpose
 *	This module contains the interface between the various modules of
 *	the hardware assisted CPU.
 *
 *! (c)Copyright Insignia Solutions Ltd., 1993. All rights reserved.
]*/

/*===========================================================================*/

struct h_cpu_registers
	{
	IU32	GDT_base;
	IU16	GDT_limit;
	IU32	IDT_base;
	IU16	IDT_limit;
	IU32	LDT_base;
	IU16	LDT_limit;
	IU16	LDT_selector;
	IU32	TR_base;
	IU16	TR_limit;
	IU16	TR_selector;
	IU16	CS_limit;
	IU8		CS_ar;
	IU16	DS_limit;
	IU8		DS_ar;
	IU16	ES_limit;
	IU8		ES_ar;
	IU16	SS_limit;
	IU8		SS_ar;
	IU16	FS_limit;
	IU8		FS_ar;
	IU16	GS_limit;
	IU8		GS_ar;
	IU8		CPL;
	IU32	CR1;
	IU32	CR2;
	IU32	DR0;
	IU32	DR1;
	IU32	DR2;
	IU32	DR3;
	IU32	DR4;
	IU32	DR5;
	IU32	DR6;
	IU32	DR7;
	IU32	TR3;
	IU32	TR4;
	IU32	TR5;
	IU32	TR6;
	IU32	TR7;
	struct  hh_regs  *tp;		/* in hh_regs.h								*/	
	};

/*==========================================================================*/
/* macros for accessing registers in h_cpu_registers                        */
/* Intel ports only, so these endian macros should be OK 					*/

union bregs
	{
	ULONG  h_l;
	USHORT h_w[2];
	UTINY  h_c[4];
	};		
#define	WORD(n, v)	((*((union bregs *)(&v))).h_w[n])
#define	BYTE(n, v)	((*((union bregs *)(&v))).h_c[n])

#define EAX(c)	(((c)->tp)->t_eax)
#define AX(c)	WORD(0, ((c)->tp)->t_eax)
#define AH(c)	BYTE(1, ((c)->tp)->t_eax)
#define AL(c)	BYTE(0, ((c)->tp)->t_eax)
#define EBX(c)	(((c)->tp)->t_ebx)
#define BX(c)	WORD(0, ((c)->tp)->t_ebx)
#define BH(c)	BYTE(1, ((c)->tp)->t_ebx)
#define BL(c)	BYTE(0, ((c)->tp)->t_ebx)
#define ECX(c)	(((c)->tp)->t_ecx)
#define CX(c)	WORD(0, ((c)->tp)->t_ecx)
#define CH(c)	BYTE(1, ((c)->tp)->t_ecx)
#define CL(c)	BYTE(0, ((c)->tp)->t_ecx)
#define EDX(c)	(((c)->tp)->t_edx)
#define DX(c)	WORD(0, ((c)->tp)->t_edx)
#define DH(c)	BYTE(1, ((c)->tp)->t_edx)
#define DL(c)	BYTE(0, ((c)->tp)->t_edx)
#define DS(c)	WORD(0, ((c)->tp)->t_ds)
#define ES(c)	WORD(0, ((c)->tp)->t_es)
#define SS(c)	WORD(0, ((c)->tp)->t_ss)
#define CS(c)	WORD(0, ((c)->tp)->t_cs)
#define FS(c)	WORD(0, ((c)->tp)->t_fs)
#define GS(c)	WORD(0, ((c)->tp)->t_gs)
#define ESI(c)	(((c)->tp)->t_esi)
#define SI(c)	WORD(0, ((c)->tp)->t_esi)
#define EDI(c)	(((c)->tp)->t_edi)
#define DI(c)	WORD(0, ((c)->tp)->t_edi)
#define EFL(c)	(((c)->tp)->t_eflags)
#define FL(c)	WORD(0, ((c)->tp)->t_eflags)
#define IP(c)	WORD(0, ((c)->tp)->t_eip)
#define EIP(c)	(((c)->tp)->t_eip)
#define ESP(c)	(((c)->tp)->t_esp)
#define SP(c)	WORD(0, ((c)->tp)->t_esp)
#define EBP(c)	(((c)->tp)->t_ebp)
#define BP(c)	WORD(0, ((c)->tp)->t_ebp)
#define CR0(c)	(((c)->tp)->t_cr0)
#define MSW(c)	WORD(0, ((c)->tp)->t_cr0)

#define GDT_base(c)	((c)->GDT_base)
#define GDT_limit(c)	((c)->GDT_limit)
#define IDT_base(c)	((c)->IDT_base)
#define IDT_limit(c)	((c)->IDT_limit)
#define LDT_base(c)	((c)->LDT_base)
#define LDT_limit(c)	((c)->LDT_limit)
#define LDT_selector(c)	((c)->LDT_selector)
#define TR_base(c)	((c)->TR_base)
#define TR_limit(c)	((c)->TR_limit)
#define TR_selector(c)	((c)->TR_selector)
#define CS_ar(c)	((c)->CS_ar)
#define CS_limit(c)	((c)->CS_limit)
#define DS_ar(c)	((c)->DS_ar)
#define DS_limit(c)	((c)->DS_limit)
#define ES_ar(c)	((c)->ES_ar)
#define ES_limit(c)	((c)->ES_limit)
#define SS_ar(c)	((c)->SS_ar)
#define SS_limit(c)	((c)->SS_limit)
#define FS_ar(c)	((c)->FS_ar)
#define FS_limit(c)	((c)->FS_limit)
#define GS_ar(c)	((c)->GS_ar)
#define GS_limit(c)	((c)->GS_limit)
#define CPL(c)	((c)->CPL)
#define CR1(c)	((c)->CR1)
#define CR2(c)	((c)->CR2)

/*===========================================================================*/
/* Bit definitions                                                           */

/* CR0 register */

#define M_PE	0x0001		/* Protection enable 		*/
#define M_MP	0x0002		/* Maths present			*/
#define M_EM	0x0004		/* Emulation				*/
#define M_TS	0x0008		/* Task switched			*/
#define M_ET	0x0010		/* Extension type			*/
#define M_NE	0x0020		/* Numeric error			*/
#define M_WP	0x0100		/* Write protect			*/
#define M_AM	0x0400		/* Alignment mask			*/
#define M_NW	0x2000		/* Not write-through		*/
#define M_CD	0x4000		/* Cache disable			*/
#define M_PG	0x8000		/* Paging					*/

/* EFLAGS register */

#define	PS_C		0x0001		/* carry bit				*/
#define	PS_P		0x0004		/* parity bit				*/
#define	PS_AC		0x0010		/* auxiliary carry bit		*/
#define	PS_Z		0x0040		/* zero bit					*/
#define	PS_N		0x0080		/* negative bit				*/
#define	PS_T		0x0100		/* trace enable bit			*/
#define	PS_IE		0x0200		/* interrupt enable bit		*/
#define	PS_D		0x0400		/* direction bit			*/
#define	PS_V		0x0800		/* overflow bit				*/
#define	PS_IOPL		0x3000		/* I/O privilege level		*/
#define	PS_NT		0x4000		/* nested task flag			*/
#define	PS_RF		0x10000		/* Reset flag				*/
#define	PS_VM		0x20000		/* Virtual 86 mode flag		*/

#define HWCPU_POSSIBLE		0	/* Emulation can continue					*/
#define HWCPU_FAIL			1	/* O/S wouldn't run pc code					*/
#define HWCPU_HALT			2	/* HALT opcode executed						*/
#define HWCPU_IMPOSSIBLE	3	/* illegal opcode encountered				*/

#define HWCPU_TICKS			20	/* ticks per second							*/

typedef void (h_exception_handler_t) IPT2 (IU32, h_exception_num, IU32, h_error_code_t);
typedef void (COMMS_CB) IPT1(long, dummy);
extern VOID  (*Hg_spc_entry) IPT0();
extern IBOOL (*Hg_spc_async_entry) IPT0();
extern VOID  (*Hg_spc_return) IPT0();
extern IBOOL Hg_SS_is_big;
/*===========================================================================*/
/* functions                                                                 */

extern struct	hh_regs *hh_cpu_init IPT2 (IU32, size, IU32, monitor_address);
extern IS16		hh_cpu_simulate IPT0();
extern void		hh_mark_cpu_state_invalid IPT0();
extern void		hh_pm_pc_IDT_is_at IPT2 (IU32, address, IU32, length);
extern void		hh_LDT_is_at IPT2 (IU32, address, IU32, length);
extern IU32		hh_cpu_calc_q_ev_inst_for_time IPT1 (IU32, time);
extern IBOOL	hh_protect_memory IPT3 (IU32, address, IU32, size, IU32, access);
extern IBOOL	hh_set_intn_handler IPT2 (IU32, hh_int_num, h_exception_handler_t, hh_intn_handler);
extern IBOOL	hh_set_fault_handler IPT2 (IU32, hh_fault_num, h_exception_handler_t, hh_fault_handler);
extern VOID		hh_enable_IF_checks IPT1(IBOOL, whenPM);
extern IU32		hh_resize_memory IPT1(IU32, size);
extern VOID		hh_save_npx_state IPT1(IBOOL, reset);
#ifdef LIM
extern IU32	hh_LIM_allocate IPT2(IU32, n_pages, IHP *, addr);
extern IU32	hh_LIM_map IPT3(IU32, block, IU32, length, IHP, dst_addr);
extern IU32	hh_LIM_unmap IPT2(IHP, src_addr, IU32, length);
extern IU32	hh_LIM_deallocate IPT0();
#endif /* LIM */
extern VOID		hh_restore_npx_state IPT1(IBOOL, do_diff);
#ifndef PROD
extern void		hh_enable_slow_mode IPT0();
#endif /* PROD */
extern void		hh_cpu_terminate IPT0();

extern VOID		hg_resize_memory IPT1(IU32, size);
extern void		hg_os_bop_handler IPT1 (unsigned int, BOPNum);
extern void		hg_fault_handler IPT2 (IU32, fault_num, IU32, error_code);
extern void		hg_fault_1_handler IPT2 (IU32, fault_num, IU32, error_code);
extern void		hg_fault_6_handler IPT2 (IU32, fault_num, IU32, error_code);
extern void		hg_fault_10_handler IPT2 (IU32, fault_num, IU32, error_code);
extern void		hg_fault_13_handler IPT2 (IU32, fault_num, IU32, error_code);
extern void		hg_fault_14_handler IPT2 (IU32, fault_num, IU32, error_code);

/* The fpu fault handler (16) catches FPU exceptions, and generates SoftPC */
/* interrupt ( 0x75 ) which corresponds to IRQ13. */
extern void 	hg_fpu_fault_handler IPT2 (IU32, fault_num, IU32, error_code);

extern IU32		hg_callback_handler IPT1 (IU32, status);

extern VOID		hg_set_default_fault_handler IPT2(IU32, hg_fault_num,
					h_exception_handler_t, hg_handler);
extern IBOOL		hg_set_intn_handler IPT2 (IU32, interrupt_number,
					h_exception_handler_t *, function);
extern IBOOL		hg_set_fault_handler IPT2 (IU32, exception_number,
					h_exception_t *, function);
#ifdef IRET_HOOKS
extern void		hg_add_comms_cb IPT2(COMMS_CB, next_batch, IUS32, timeout);
#endif

extern VOID		host_display_win_logo IPT0 ();

/*===========================================================================*/
/* the data itself                                                           */

extern struct	h_cpu_registers *Cp;	
extern IBOOL	H_trace;

/*
 * We need to know if Windows is running as the fault handling is different
 * if it is. The variable is set/unset by BOPs inserted into our
 * modified DOSX, and by hg_cpu_reset.
 */
extern	IBOOL	H_windows;
extern	IBOOL 	H_regs_changed;

extern	IU32	Pc_timeout;			/* Value to return in if q_ev pending	*/
extern	IU32	Pc_q_ev_dec;		/* Chunk to dec q_ev counter by			*/

extern	IU32	Pc_woken;			/* Reason callback handler was called	*/
extern	IU32	Pc_timeout;
extern	IU32	Pc_if_set;
extern	IU32	Pc_tick;

extern	IU32	Pc_run_timeout;		/* Parameters "to" pc_run				*/
extern	IU32	Pc_run_option_none;
extern	IU32	Pc_run_if_set;
extern	IU32	Pc_run_pm_if_set;
extern	IU32	Pc_run_tick;

extern	IU32	Pc_prot_none;		/* Memory protection values				*/
extern	IU32	Pc_prot_read;
extern	IU32	Pc_prot_write;
extern	IU32	Pc_prot_execute;

extern	IU32	Pc_success;
extern	IU32	Pc_no_space;
extern	IU32	Pc_invalid_address;
extern	IU32	Pc_failure;
extern	IU32	Pc_invalid_argument;


/*===========================================================================*/
/*===========================================================================*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\host_fio.h ===
/*[
 *	Name:		host_fio.h
 *	Derived From:	Original
 *	Author:		Philippa Watson
 *	Created On:	7 February 1992
 *	Sccs Id:	@(#)host_fio.h	1.3 08/10/92
 *	Purpose:	Host-side definitions for standard file i/o. This
 *			version is placed in the base for hosts which support
 *			standard unix file i/o.
 *	Modified by Robert Kokuti 26/5/92, BCN 886
 *
 *	(c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
 *
]*/

/* The HOST_FILE_DESC structure contains information to identify a file on disk
** For Unix, it corresponds to char *.
*/

#define	HOST_FILE_DESC	char *

/* The HOST_FILE structure contains any file information which needs to be
** passed to the calls below. For Unix, it corresponds to the FILE structure.
*/

#define	HOST_FILE	FILE *

/* host_fopen_for_read(HOST_FILE_DESC filename) opens the given file for reading and
** returns a HOST_FILE. If the returned value is zero then the open
** has failed, otherwise it has succeeded.
*/

#define	host_fopen_for_read(filename)	fopen(filename, "r")

/* host_fopen_for_write(HOST_FILE_DESC filename) opens the given file for writing and
** returns a HOST_FILE. If the returned value is zero then the open
** has failed, otherwise it has succeeded.
*/

#define	host_fopen_for_write(filename)	fopen(filename, "w")

/* host_fopen_for_write_plus(HOST_FILE_DESC filename) opens the given file for writing
** and reading and returns a HOST_FILE. If the returned value is zero
** then the open has failed, otherwise it has succeeded.
*/

#define host_fopen_for_write_plus(filename)	fopen(filename, "w+")

/* host_fcreate_disk_file(HOST_FILE_DESC filename) creates & opens the given file for writing
** and reading and returns a HOST_FILE. If the returned value is zero
** then the create & open has failed, otherwise it has succeeded.
*/

#define host_fcreate_disk_file(filename)	fopen(filename, "w+")

/* host_fclose(HOST_FILE file) closes the given file. This routine returns
** zero for success. Any other return value is failure.
*/

#define	host_fclose(file)	(fclose(file) != EOF)

/* host_fseek_abs(HOST_FILE file, LONG location) seeks to the given absolute
** position in the file (i.e. relative to the start). It returns zero for
** success. Any other return value is a failure.
*/

#define	host_fseek_abs(file, location)	fseek(file, location, SEEK_SET)

/* host_fwrite_buffer(unsigned char *buffer, int itemsize, int nitems,
** HOST_FILE file) writes nitems each of itemsize from the buffer to the
** file. It returns zero for success. Any other return value is a failure.
*/

#define host_fwrite_buffer(buffer, itemsize, nitems, file)	\
	(fwrite(buffer, itemsize, nitems, file) != nitems)
	
/* host_fread_buffer(unsigned char *buffer, int itemsize, int nitems,
** HOST_FILE file) reads nitems each of itemsize from the file into the
** buffer. It returns zero for success. Any other return value is a failure.
*/

#define host_fread_buffer(buffer, itemsize, nitems, file)	\
	(fread(buffer, itemsize, nitems, file) != nitems)

/* host_feof(HOST_FILE file) returns non-zero when end of file is read from
** the file. It returns zero otherwise.
*/

#define	host_feof(file)		feof(file)

/* A useful define to avoid using lots of seek/write pairs. If the result is 0
** then the seek and write were successful; otherwise one of them failed.
*/

#define	host_fwrite_buffer_at(file, location, buffer, itemsize, nitems)	\
	(host_fseek_abs(file, location) ||	\
	host_fwrite_buffer(buffer, itemsize, nitems, file))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\host_com.h ===
#ifndef _HOST_COM_H
#define _HOST_COM_H

/*[
	Name:		host_com.h
	Derived From:	Base 2.0
	Author:		Ross Beresford 
	Created On:	
	Sccs ID:	12/13/94 @(#)host_com.h	1.10
	Purpose:	
		Definition of the interface between the generic communications
		adapter emulation functions and the host specific functions.
		THIS IS A BASE MODULE

		Users of the comms emulation functions must provide an
		implementation of the following host specific functions:

VOID host_com_reset(adapter)
int adapter;
{
	Initialise communications channel for "adapter" 
}

SHORT host_com_valid
	(UTINY hostID, ConfigValues *val, NameTable *dummy, CHAR *errString)
{
	Routine to validate a comms entry, called by config system.
}

VOID host_com_change(UTINY hostID, BOOL apply)
{
	Routine called by config to clean up after validation depending
	on if apply is true or not.  If not then the validation files
	are to be closed, otherwise the active adapter is to be shutdown and
	the validation data transfered.
}

SHORT host_com_active(UTINY hostID, BOOL active, CHAR *errString)
{
	Connect the adapter to the outside world.  Open or close
	the adapter as appropiate.
}

VOID host_com_close(adapter)
int adapter;
{
	Close communications channel for "adapter"
}

VOID host_com_read(adapter, value, error_mask)
int adapter;
char *value;
int *error_mask;
{
	Read communications channel for "adapter", placing the result in the
	character address pointed to by "value". Bits in "error_mask" may be
	set to indicate that the character is invalid for the following
	reason(s):

	HOST_COM_FRAMING_ERROR		framing error
	HOST_COM_OVERRUN_ERROR		overrun error
	HOST_COM_PARITY_ERROR		parity error
	HOST_COM_BREAK_RECEIVED 	break on input line
	HOST_COM_NO_DATA		value was not data
}

VOID host_com_write(adapter, value)
int adapter;
char value;
{
	Write "value" to the  communications channel for "adapter"
}

VOID host_com_ioctl(adapter, request, arg)
int adapter;
int request;
long arg;
{
	Perform control function "request" qualified by "arg" on the
	communications channel for "adapter".

	Request may take the following values:

	HOST_COM_SBRK :- Set break control for "adapter"; "arg" has no
			 significance

	HOST_COM_CBRK :- Clear break control for "adapter"; "arg" has no
			 significance

	HOST_COM_SDTR :- Set data terminal ready for "adapter"; "arg" has no
			 significance

	HOST_COM_CDTR :- Clear data terminal ready for "adapter"; "arg" has
			 no significance

	HOST_COM_SRTS :- Set request to send for "adapter"; "arg" has no
			 significance

	HOST_COM_CRTS :- Clear request to send for "adapter"; "arg" has no
			 significance

	HOST_COM_INPUT_READY :- Set the value pointed to by (int *) "arg" to
				TRUE if there is input pending for "adapter"


	HOST_COM_MODEM :- Set the value pointed to by (int *) "arg" to the
			  current modem status; the following bit fields are
			  significant and represent the state of the modem
			  input signals:

		HOST_COM_MODEM_CTS	clear to send
		HOST_COM_MODEM_RI	ring indicator
		HOST_COM_MODEM_DSR	data set ready
		HOST_COM_MODEM_RLSD	received line signal detect

	HOST_COM_BAUD :- Change the baud rate to that corresponding to the
			 value of "arg"; the following values of "arg" are
			 significant:

		HOST_COM_B50		50 baud
		HOST_COM_B75		75 baud
		HOST_COM_B110		110 baud
		HOST_COM_B134		134.5 baud
		HOST_COM_B150		150 baud
		HOST_COM_B300		300 baud
		HOST_COM_B600		600 baud
		HOST_COM_B1200		1200 baud
		HOST_COM_B1800		1800 baud
		HOST_COM_B2000		2000 baud
		HOST_COM_B2400		2400 baud
		HOST_COM_B3600		3600 baud
		HOST_COM_B4800		4800 baud
		HOST_COM_B7200		7200 baud
		HOST_COM_B9600		9600 baud
		HOST_COM_B19200		19200 baud
		HOST_COM_B38400		38400 baud
		HOST_COM_B57600		57600 baud
		HOST_COM_B115200	115200 baud

	HOST_COM_FLUSH :- Flush output; "arg" has no significance

	HOST_COM_DATABITS :- Set the line discipline to use "arg" data bits.

	HOST_COM_STOPBITS :- Set the line discipline to use "arg" stop bits.

	HOST_COM_PARITY :- Set the line discipline to the parity setting
			   implied by "arg", which may take one of the
			   following values:

		HOST_COM_PARITY_NONE	no parity
		HOST_COM_PARITY_EVEN	even parity
		HOST_COM_PARITY_ODD	odd parity
		HOST_COM_PARITY_MARK	parity stuck at 1
		HOST_COM_PARITY_SPACE	parity stuck at 0
}

GLOBAL void host_com_enable_autoflush IFN1(IS32,adapter)
{
	Reset the autoflush disabled flag for the serial port.
}

GLOBAL void host_com_disable_autoflush IFN1(IS32,adapter)
{
	Cancel any outstanding autoflush event for the serial port and set the
	autoflush disabled flag for the serial port.
}

#ifndef macintosh
GLOBAL void host_com_xon_change IFN2(IU8,hostID, IBOOL,apply)
{
	If the serial port is not active then do nothing.
	If the serial port is active then change the flow control parameter of
	the device.
	If the serial port also has an asynchronous event manager defined then
	change the mode of the event manager.
}
#endif	macintosh

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
]*/

IMPORT VOID host_com_reset IPT1(int,adapter);

IMPORT SHORT host_com_valid
	IPT4(UTINY,hostID,ConfigValues *,val,NameTable *,dummy,CHAR *,errString);
IMPORT VOID host_com_change IPT2(UTINY,hostID, BOOL,apply);
IMPORT SHORT host_com_active IPT3(UTINY,hostID, BOOL,active, CHAR *,errString);
IMPORT VOID host_com_close IPT1(int,adapter);

#if defined(NTVDM) && defined(FIFO_ON)
IMPORT UTINY host_com_read_char(int adapter, FIFORXDATA *buffer, UTINY count);
IMPORT VOID host_com_fifo_char_read(int adapter);
#endif

IMPORT VOID host_com_read IPT3(int,adapter,UTINY *,value, int *,error_mask);
IMPORT VOID host_com_write IPT2(int,adapter, char,value);
IMPORT VOID host_com_ioctl IPT3(int,adapter, int,request, LONG,arg);

#ifdef NTVDM
extern	boolean host_com_check_adapter(int adapter);
extern void host_com_lock(int adapter);
extern void host_com_unlock(int adapter);
extern int host_com_char_read(int adapter, int da_int);
extern void host_com_disable_open(int adapter, int disableOpen);
extern void host_com_da_int_change(int adapter, int da_int_state, int da_data_state);
#define host_com_msr_callback(a,b)
#endif

#ifdef PS_FLUSHING
IMPORT void host_com_enable_autoflush IPT1(IS32,adapter);
IMPORT void host_com_disable_autoflush IPT1(IS32,adapter);
#endif	/* PS_FLUSHING */

#ifndef macintosh
IMPORT void host_com_xon_change IPT2(IU8,hostID, IBOOL,apply);
#endif	/* macintosh */

#define	HOST_COM_SBRK		0000001
#define	HOST_COM_CBRK		0000002
#define	HOST_COM_SDTR		0000003
#define	HOST_COM_CDTR		0000004
#define	HOST_COM_SRTS		0000005
#define	HOST_COM_CRTS		0000006
#define	HOST_COM_MODEM		0000007
#define	HOST_COM_BAUD		0000010 
#define	HOST_COM_FLUSH		0000011
#define	HOST_COM_INPUT_READY	0000012
#define	HOST_COM_DATABITS	0000013
#define	HOST_COM_STOPBITS	0000014
#define	HOST_COM_PARITY		0000015

#ifdef NTVDM
#define HOST_COM_LSR		0000016
#endif

#define	HOST_COM_FRAMING_ERROR	(1 << 0)
#define	HOST_COM_OVERRUN_ERROR	(1 << 1)
#define	HOST_COM_BREAK_RECEIVED	(1 << 2)
#define	HOST_COM_PARITY_ERROR	(1 << 3)
#define HOST_COM_NO_DATA		(1 << 4)
#ifdef NTVDM
#define HOST_COM_FIFO_ERROR	(1 << 7)
#endif

#define	HOST_COM_MODEM_CTS	(1 << 0)
#define	HOST_COM_MODEM_RI	(1 << 1)
#define	HOST_COM_MODEM_DSR	(1 << 2)
#define	HOST_COM_MODEM_RLSD	(1 << 3)

#define	HOST_COM_B50	 0000001
#define	HOST_COM_B75	 0000002
#define	HOST_COM_B110	 0000003
#define	HOST_COM_B134	 0000004
#define	HOST_COM_B150	 0000005
#define	HOST_COM_B300	 0000006
#define	HOST_COM_B600	 0000007
#define	HOST_COM_B1200	 0000010
#define	HOST_COM_B1800	 0000011
#define	HOST_COM_B2000	 0000012
#define	HOST_COM_B2400	 0000013
#define	HOST_COM_B3600	 0000014
#define	HOST_COM_B4800	 0000015
#define	HOST_COM_B7200	 0000016
#define	HOST_COM_B9600	 0000017
#define	HOST_COM_B19200	 0000020
#define	HOST_COM_B38400	 0000021
#define	HOST_COM_B57600	 0000022
#define	HOST_COM_B115200 0000023

#define	HOST_COM_PARITY_NONE	0000000
#define	HOST_COM_PARITY_EVEN	0000001
#define	HOST_COM_PARITY_ODD	0000002
#define	HOST_COM_PARITY_MARK	0000003
#define	HOST_COM_PARITY_SPACE	0000004

#endif /* _HOST_COM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\host_gwi.h ===
/*[
 *	Name:		host_gwi.h
 *
 *	Author:		Simion Calcev
 *
 *	Created On:	17th December 1991
 *
 *	Purpose:	To undefine GWI defines for those hosts which don't
 *				want to support the GWI interface.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
]*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\host_msw.h ===
/*[
 *	Product:	SoftPC-AT Revision 3.0
 *
 *	Name:		host_msw.h
 *
 *	Derived From:	Alpha MS-Windows Driver by Ross Beresford
 *
 *	Author:		Rob Tizzard
 *
 *	Created On:	1st November 1990
 *
 *	Sccs ID:	@(#)host_msw.h	1.43 07/08/94
 *
 *	Purpose:	All host dependent definitions for SoftPC MicroSoft
 *		  	Windows 3.0 driver.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
 *
]*/

#if defined(MSWDVR) && defined(XWINDOW)

/*
 * -----------------------------------------------------------------------------
 * X include files.
 * -----------------------------------------------------------------------------
 */

#include <X11/X.h>
#include <X11/Xlib.h>
#include <X11/Xresource.h>
#include <X11/Xutil.h>

/* 
 * -----------------------------------------------------------------------------
 * GDIINFO data structure 
 * -----------------------------------------------------------------------------
 */ 

#define VERSION		0x0300     /* Windows version 3.0 */
#define TECHNOLOGY	DT_RASDISPLAY	   /* Raster Display */
#define BITSPIXEL     	4 	   /* Bits per pixel for display */
#define PLANES	  	1	   /* Number of planes for display */			
#define NUMCOLOURS	16	   /* Number of static colours in display table */
#define NUMFONTS	0	   /* Number of driver fonts */

/*
 * Basic dpLines value
 */
#ifdef SWIN_WIDE_LINES
#define LINES		(LC_POLYLINE|LC_WIDE|LC_STYLED|LC_WIDESTYLED|LC_INTERIORS)
#else
#define LINES		(LC_POLYLINE|LC_STYLED|LC_INTERIORS)
#endif

#ifdef SWIN_GRAPHICS_PRIMS	/* { */
/*
 * Basic dpCurves value
 */
#ifdef SWIN_WIDE_LINES
#define CURVES		(CC_CIRCLES|CC_PIE|CC_CHORD|CC_ELLIPSES|CC_WIDE|CC_STYLED|CC_WIDESTYLED|CC_INTERIORS)
#else
#define CURVES		(CC_CIRCLES|CC_PIE|CC_CHORD|CC_ELLIPSES|CC_STYLED|CC_INTERIORS)
#endif

/*
 * Basic dpPolygonals value
 */
#ifdef SWIN_WIDE_LINES
#define POLYGONALS	(PC_ALTPOLYGON|PC_RECTANGLE|PC_WINDPOLYGON|PC_SCANLINE|PC_WIDE|PC_STYLED|PC_WIDESTYLED|PC_INTERIORS)
#else
#define POLYGONALS	(PC_ALTPOLYGON|PC_RECTANGLE|PC_WINDPOLYGON|PC_SCANLINE|PC_STYLED|PC_INTERIORS)
#endif

#else	/* SWIN_GRAPHICS_PRIMS } { */

/*
 * Basic dpCurves value
 */
#ifdef SWIN_WIDE_LINES
#define CURVES		(CC_ELLIPSES|CC_WIDE|CC_STYLED|CC_WIDESTYLED|CC_INTERIORS)
#else
#define CURVES		(CC_ELLIPSES|CC_STYLED|CC_INTERIORS)
#endif

/*
 * Basic dpPolygonals value
 */
#ifdef SWIN_WIDE_LINES
#define POLYGONALS	(PC_RECTANGLE|PC_SCANLINE|PC_WIDE|PC_STYLED|PC_WIDESTYLED|PC_INTERIORS)
#else
#define POLYGONALS	(PC_RECTANGLE|PC_SCANLINE|PC_STYLED|PC_INTERIORS)
#endif

#endif /* SWIN_GRAPHICS_PRIMS  } */

#ifdef SWIN_BOLD_TEXT_OPTS	/* { */
#define TEXTUAL		(TC_CP_STROKE|TC_RA_ABLE|TC_EA_DOUBLE)
#else
#define TEXTUAL		(TC_CP_STROKE|TC_RA_ABLE)
#endif /* SWIN_BOLD_TEXT_OPTS	   } */

#define CLIP		CP_RECTANGLE		/* Rectangle */

#ifdef SWIN_DEVBMP
#define RASTER		(RC_BITBLT|RC_BITMAP64|RC_GDI20_OUTPUT|RC_SAVEBITMAP|RC_DI_BITMAP|RC_PALETTE|RC_DIBTODEV|RC_STRETCHBLT|RC_DEVBITS)
#else
#define RASTER		(RC_BITBLT|RC_BITMAP64|RC_GDI20_OUTPUT|RC_SAVEBITMAP|RC_DI_BITMAP|RC_PALETTE|RC_DIBTODEV)
#endif /* SWIN_DEVBMP */

#define DCMANAGE	DC_IGNOREDFNP		/* Display */
#define PALCOLOURS	0			/* Colours available in palette */
#define PALCOLRESERVED	0			/* Reserved colours for brushes & pens */
#define PALCOLOURRES	24			/* DAC RGB resolution */

/* X & Y dots per inch */

#define XDOTSPERINCH	((FLOAT) mswdvr.displayWidth / (FLOAT) mswdvr.displayWidthMM * 25.4)
#define YDOTSPERINCH 	((FLOAT) mswdvr.displayHeight / (FLOAT) mswdvr.displayHeightMM * 25.4)

/* 
 * -----------------------------------------------------------------------------
 * Image Data format
 * -----------------------------------------------------------------------------
 */

#define FORMAT		ZPixmap

#define HOSTBYTEORDER	MSBFirst
#define HOSTBITORDER	MSBFirst

#define MBYTEORDER	MSBFirst
#define MBITORDER	MSBFirst

/*
 * -----------------------------------------------------------------------------
 * Size of physical pen & brush data structures written to Intel memory
 * -----------------------------------------------------------------------------
 */

#define PPEN_SIZE	(sizeof(PEN_MAPPING))
#define PBRUSH_SIZE	(sizeof(BRUSH_MAPPING))

#ifdef SWIN_DEVBMP
/*
 * -----------------------------------------------------------------------------
 * Size of device bitmap entry tables
 * -----------------------------------------------------------------------------
 */

/*
 * number of entries in table
 */
#define PPBITMAP_MAX    512
/*
 * number of bytes to pass back to Intel (GDI) to describe
 * a device bitmap data structure (inc. PBITMAP structure)
 */
#define PPBITMAP_SIZE   (32 + sizeof(word))
#define BITMAP_FAILURE	0xffff		/* indicates cannot realize device bitmap */
#endif /* SWIN_DEVBMP */


/*
 * -----------------------------------------------------------------------------
 * Size of brush monochrome & colour tile data in bytes
 * -----------------------------------------------------------------------------
 */

#define BRUSH_MONO_SIZE		8
#define BRUSH_COLOUR_SIZE	64

/*
 * -----------------------------------------------------------------------------
 * Number of scratch areas.
 * -----------------------------------------------------------------------------
 */

#define MAX_SCRATCH_AREAS       2

/* 
 * -----------------------------------------------------------------------------
 * MS-Windows Driver Types 
 * -----------------------------------------------------------------------------
 */

/* Pixel, RGB & shift unit */

typedef double_word	MSWPIXEL;
typedef double_word	MSWCOLOUR;
typedef half_word	SHIFTUNIT;

/* type of host pixel values, never seen by Windows */

typedef unsigned long	HOSTPIXEL;

/* Colourmap & translate table data structure */

typedef struct {
	HOSTPIXEL	pixel;		/* host pixel value */
	MSWCOLOUR	rgb;		/* RGB value */
} MSWCOLOURMAP;

#ifdef SWIN_GRAPHICS_PRIMS
/*
 * PolyPoints data structure and used in general for windows points
 * describing graphics operations
 */
typedef struct {
	SHORT	x;
	SHORT	y;
} WinPoint;

#define MAXPOINTS	512

#endif /* SWIN_GRAPHICS_PRIMS */

/* Drawing Rectangle */

typedef	XRectangle	Rectangle;

/* Window attributes */

typedef	XWindowAttributes	WindowAttributes;

/* Structure used in mapping MSW bitmaps to X pixmaps */

typedef struct {
   ULONG           type;           /* mapping type */
   BOOL            translate;      /* translate flag */
   Drawable        mapping;        /* mapped pixmap */
   LONG            x;              /* x origin of bitmap */
   LONG            y;              /* y origin of bitmap */
   word            width;          /* width of bitmap */
   word            height;         /* height of bitmap */
   word            bytes_per_line; /* width in bytes */
   half_word       planes;         /* number of bitmap planes */
   half_word       bitsPixel;      /* bits per pixel */
   double_word     bits;           /* Segment and offset of bitmap */
   half_word       *data;          /* bitmap data address */
   word            segmentIndex;   /* index to next Huge bitmap segment */
   word            scanSegment;    /* scan lines per segment */
   word            fillBytes;      /* unused bytes within a segment */
   HOSTPIXEL       foreground;     /* pixel corresponding to 1 */
   HOSTPIXEL       background;     /* pixel corresponding to 0 */
   LONG            active_x;       /* active area origin x */
   LONG            active_y;       /* active area origin y */
   ULONG           active_width;   /* active area width */
   ULONG           active_height;  /* active area height */
   IU32            flags;          /* creation flags */
#ifdef SWIN_DEVBMP
   BOOL		   deviceBitmap;   /* flag to test whether device bitmap */
#endif
} BITMAP_MAPPING;

/* Structure used in mapping MSW brushes to X GCs */

#ifdef SWIN_MEMTOMEM_ROPS
typedef struct
{
	IU16	left;
	IU16	top;
	IU16	right;
	IU16	bottom;
} Rect;
#endif /* SWIN_MEMTOMEM_ROPS */

/*
 * The following structure is kept in GDI and must be kept AS SMALL AS POSSIBLE.
 * This is the justification for use of the bit-fields (against Insignia
 * coding standards) & why some of the fields appear in other than the
 * obvious order - so that we can try to natural size align stuff (so that
 * there are no padding bytes added by the compiler). Note that more fields
 * could be moved into the pen/brush union but it doesn't end up saving
 * space - and could actually make it worse.
 *
 * NOTE - the handle field must be first - code in X_mswobj.c assumes that
 *	  it is the first item found in Intel memory & the pen/brush cache
 *	  code also depends on it.
 */
typedef struct {
	word		handle;			/* Unique brush identifier */
	word		line_width;		/* Pen line width */

	unsigned int	inuse:1;		/* Is brush/pen in use */
	unsigned int	tiled:1;		/* Brush tiled flag */
	unsigned int	width:4;		/* Brush width */
	unsigned int	height:4;		/* Brush height */
	unsigned int	monoPresent:1;		/* Mono bitmap present ? */
	unsigned int	colourPresent:1;	/* Colour bitmap present ? */
	unsigned int objectGCHandle:4;   	/* Entry within GC Table */
	unsigned int penXbackground:1;		/* pen background is X pixel! */

#ifdef SWIN_INVERTBRUSH_OPT
	unsigned int invertedTile:1;		/* brush tile is inverted */
#endif /* SWIN_INVERTBRUSH_OPT */

	int function;				/* GC function */

	union {
		struct {				/* BRUSHES only */
			unsigned int use_clip_mask:1;	/* clip mask None or !None */
#ifdef SWIN_MEMTOMEM_ROPS
			unsigned int patPresent:1;	/* pattern data present */
			unsigned int bmpBits:6;		/* pattern from mono bitmap */
			unsigned int xRotation:4;	/* x pattern rotation */
			unsigned int yRotation:4;	/* y pattern rotation */
#endif /* SWIN_MEMTOMEM_ROPS */
		} brush;
		struct {			/* PENS only */
			int line_style;		/* GC line style */
		} pen;
	} obj;

	MSWCOLOUR    foreground; 	      	/* Foreground colour */
	MSWCOLOUR    background; 	      	/* Backgound colour */

	HOSTPIXEL	fgPixel;		/* Foreground pixel value */
	HOSTPIXEL	bgPixel;		/* Background pixel value */

	half_word	monoBitmap[BRUSH_MONO_SIZE]; 	/* Data for mono brush */
	half_word	colourBitmap[BRUSH_COLOUR_SIZE];/* Data for colour brush */

	GC           gc;   	            		/* X GC to fill using brush */
	Pixmap	mapping;	     		/* Brush tile data mapping */
	Rectangle    clip_area;        		/* Area used when clipping */

#ifdef SWIN_MEMTOMEM_ROPS
	IU16		originX;		/* Brush tile origin x coord */
	IU16		originY;		/* Brush tile origin y coord */
	IS8		rop2;			/* Tiling rop */
#endif /* SWIN_MEMTOMEM_ROPS */

	IU8		style;			/* Brush style */
} BRUSH_MAPPING;

/*
 * Define structure that holds the stuff that used to be in BRUSH_MAPPING but is
 * taken out here to save space; this structure is cached in host memory and the
 * non-BRUSH_MAPPING members are recalculated when required.
 *
 * NOTE - gdi field must be first in the structure that follows; the
 *	  GET_BRUSH_PATTERN macro depends on it.
 */
typedef struct {
	BRUSH_MAPPING gdi;			/* copy of GDI bit of brush */
	XGCValues gcValues;			/* X GC values for display */
	unsigned long valueMask;		/* X GC value mask */
	IU8 patData[BRUSH_COLOUR_SIZE];		/* tiled brush pattern */
} X_BRUSH_MAPPING;

#ifdef SWIN_MEMTOMEM_ROPS
#define GET_BRUSH_PATTERN()		(((X_BRUSH_MAPPING *)bp)->patData)
#endif /* SWIN_MEMTOMEM_ROPS */

/*
 * Pens & brushes are all the same under X.
 */
#define PEN_MAPPING 	BRUSH_MAPPING
#define X_PEN_MAPPING 	X_BRUSH_MAPPING

/* Main windows driver data structure */

typedef struct {
	Display      *display;			/* X display */
	int          screen;			/* X screen */
	IS32	     intel_version;		/* version of Intel driver */
	Window       parent;			/* X Parent Window ID */
	Window       window;			/* X Output Window ID */
	Colormap     colourmap;			/* X colourmap */
	WindowAttributes  windowAttr;		/* X Output Window attributes */
	HOSTPIXEL    *planeMasks;	        /* X pixel plane masks */
	HOSTPIXEL    mergeMask;			/* X merged pixel plane masks */
	HOSTPIXEL    whitePixelValue;		/* X White pixel values */
	HOSTPIXEL    blackPixelValue;		/* X Black pixel value */
	ULONG	     displayWidth;		/* X Display width in pixels */
	ULONG	     displayHeight;		/* X Display height in pixels */
	ULONG        displayWidthMM;            /* X Display width in MM */
	ULONG        displayHeightMM;           /* X Display height in MM */
	ULONG        windowState;		/* Windows driver state */
	half_word    oldCrtModeByte;		/* Saved CRT Mode Byte */
	BOOL         crtModeByteSaved;		/* CRT Mode Byte saved flag */
	BOOL         sizeInitialised;		/* Windows size initialised flag */
	BOOL         envDefinedSize;		/* Windows size defined flag */
	BOOL	     winPtr;			/* Windows pointer active flag */
	BOOL         cursorDisplayed;		/* Cursor displayed flag */
	Cursor       cursor;			/* X ID of current cursor */
	int	     cursorCallbackActive;	/* warp suppression */
	int          cursorLastLocX;		/* Last x position of cursor */
	int	     cursorLastLocY;		/* Last y position of cursor */
	int          cursorXLocX;		/* x position of X pointer */
	int	     cursorXLocY;		/* y position of X pointer */
	BOOL         cursorXOutside;		/* X pointer outside window */
	word         version;			/* Windows version */
	word         nextSegment;		/* Windows next segment increment */
	word         flags;			/* Windows flags */
	word         deviceColourMatchSegment;	/* Segment of Windows function DeviceColourMatch */
	word         deviceColourMatchOffset;	/* Offset of Windows function DeviceColourMatch */
	word         bitsPixel;			/* Windows bits per pixel */
	word         numColours;		/* Windows colours */
	word         numPens;			/* Windows pens */
	word         palColours;		/* Windows palette colours */
	word         palColReserved;		/* Windows reserved palette colours */
	word         palColourRes;		/* Windows palette colours */
	UTINY        *colourToMono;		/* Windows colour to mono conversion table */
	MSWPIXEL     *colourTrans;		/* Windows colour translation table */
	MSWPIXEL     *invColourTrans;		/* Windows inverse colour translation table */
	BOOL         paletteModified;		/* Windows palette modified flag */
	BOOL         paletteEnabled;		/* Windows palette enabled flag */
	BITMAP_MAPPING    saveWindow;		/* Windows background output Window */
	UTINY	     *scratchMemory;		/* Windows driver global scratch area */
	ULONG	     scratchMemorySize;		/* Windows driver global scratch area size */
	BOOL         mode_change_exit;

	/* Store a tile pixmap and BRUSH_MAPPING structure for the brush improvement code */

	PEN_MAPPING	*ppen;
	BRUSH_MAPPING	*pbrush;

	X_PEN_MAPPING	*pxpen;
	X_BRUSH_MAPPING	*pxbrush;

	Pixmap		tile_mapping;
	word		tile_depth,tile_width,tile_height;

	/* Translation from host pixels to monochrome
	 * The HostToMono "function" enforces the 8-bit limit
	 */
	MSWPIXEL	hostToMono[256];
#ifdef SWIN_BACKING_STORE
	IBOOL		draw_direct;
#endif
} MSW_DATA;

#define HostToMono(hostpixel)	(mswdvr.hostToMono[(hostpixel)&0xff])

/*
 * -----------------------------------------------------------------------------
 * Driver optimizations
 * -----------------------------------------------------------------------------
 */

/* Enable Fast bitmap optimizations */

#define FASTBITMAP

/* Enable Output flush optimizations */

#define FLUSHSCANLINES		TRUE	
#define FLUSHPOLYLINES		TRUE		
#define FLUSHRECTANGLES		TRUE	
#define FLUSHELLIPSES		TRUE
#define FLUSHBITMAPS		TRUE	
#define FLUSHTEXT		TRUE

#endif /* MSWDVR_DEBUG */

/* 
 * -----------------------------------------------------------------------------
 * Host driver routines 
 * -----------------------------------------------------------------------------
 */

#if !(defined(MSWDVR_DEBUG) && defined(MSWDVR_MAIN))

/* For some reason, all of these function names are remapped with #defines.
 * The MSWDVR_DEBUG mechanism further remaps them to point to the
 * various debug routines instead, but this only happens in ms_windows.h
 *
 * To allow for fussy pre-processors, add a #define MSWDVR_MAIN which is
 * used in ms_windows.c to disable this particular translation.
 * 
 * The ideal solution would be to do away with this whole level of misdirection.
 */

#define	HostBitblt		BltBitblt
#define	HostColorInfo		ColColorInfo
#define HostControl		WinControl
#define HostDeviceBitmapBits	DibDeviceBitmapBits
#define	HostDisable		WinDisable
#define	HostEnable		WinEnable
#define HostEventEnd            PtrEventEnd
#define	HostExtTextOut		TxtExtTextOut
#define	HostFastBorder		BltFastBorder
#define HostSetDIBitsToDevice	DibSetDIBitsToDevice
#define	HostRealizeObject	ObjRealizeObject
#define	HostStrblt		TxtStrblt
#define	HostOutput		OutOutput
#define	HostPixel		WinPixel
#define	HostScanlr		WinScanlr
#define	HostSetCursor		PtrSetCursor
#define	HostSaveScreenBitmap	SavSaveScreenBitmap
#define	HostGetCharWidth	TxtGetCharWidth
#define HostSetPalette		ColSetPalette
#define HostGetPalette		ColGetPalette
#define HostSetPalTrans		ColSetPalTrans
#define HostGetPalTrans		ColGetPalTrans
#define HostUpdateColors	ColUpdateColors
#define HostPtrEnable           PtrEnable
#define HostPtrDisable          PtrDisable
#ifdef SWIN_DEVBMP
#define HostBitmapBits      ObjBitmapBits
#define HostSelectBitmap    ObjSelectBitmap
#endif /* SWIN_DEVBMP */


#endif /* !(defined(MSWDVR_DEBUG) && defined(MSWDVR_MAIN)) */

/* The following don't get a debug wrapper - don't know why... */

#define	HostLogo		LgoLogo
#define HostFillGDIInfo		WinFillGDIInfo
#define HostFillPDEVInfo	WinFillPDEVInfo
#define	HostMoveCursor		PtrMoveCursor
#define	HostCheckCursor		PtrCheckCursor	
#define HostStretchBlt		BltStretchBlt

/*
 * -----------------------------------------------------------------------------
 * Debug Entry Points
 * -----------------------------------------------------------------------------
 */

/* Functions */

#ifdef MSWDVR_DEBUG

/*
 * Low-level functions.
 */
extern VOID	DReportColEnquire IPT2(MSWCOLOUR,colour,sys_addr,pcolour);
extern VOID	DReportPixelEnquire IPT2(MSWPIXEL,pixel,MSWCOLOUR,rgb);
extern VOID	DPrintBitmap IPT3(UTINY *,bitmap,ULONG,bytes_per_line,ULONG,height);
extern VOID	DPrintMonoBitmap IPT4(UTINY *,bitmap,ULONG,bytes_per_line,ULONG,width,ULONG,height);
extern VOID	DPrintImageDetails IPT1(XImage *,img);
extern VOID	DPrintBitmapDetails IPT1(sys_addr,bm);
extern VOID	DPrintDevBitmapDetails IPT1(sys_addr,bm);
extern VOID	DPrintMessage IPT1(CHAR *,message);
extern VOID	DPrintInteger IPT1(LONG,integer);
extern VOID	DPrintColourmap IPT2(MSWCOLOURMAP *,colourmap,ULONG,colourmapSize);
extern VOID	DPrintSrcDstRect IPT6(LONG,sx,LONG,sy,LONG,dx,LONG,dy,ULONG,xext,ULONG,yext);
extern VOID	DPrintPBrush IPT1(sys_addr, lpBrush);
extern VOID	DPrintPPen IPT1(sys_addr,PPen);
extern VOID	DPrintDrawMode IPT2(sys_addr,DrawMode, BOOL, text);
extern VOID	DPrintDevice IPT1(sys_addr,Device);
extern VOID	DPrintlpPoints IPT2(sys_addr,lpPoints,word,Count);
extern VOID	DPrintClipRect IPT1(sys_addr,lpClipRect);
extern VOID	DPrintObject IPT3(word,style,sys_addr,lpInObj,sys_addr,lpOutObj);
extern VOID	DPrintFontInfo IPT1(sys_addr,pfont);
extern VOID	DPrintTextXForm IPT1(sys_addr,lpTextXForm);
extern VOID	DPrintDIBHeader IPT2(sys_addr,lpDIBHeader,word,setOrget);
extern VOID	DPrintTransTable IPT2(MSWPIXEL *,table,ULONG,tableSize);
extern VOID	DDrawLogo IPT1(sys_addr,stkframe);

/*
 * High-level functions
 */
extern VOID	DBitblt IPT11 ( sys_addr,lpDestDev, word,dstXOrg,word,dstYOrg,
		sys_addr,lpSrcDev,  word,srcXOrg,word,srcYOrg,
		word,xext,word,yext,double_word,rop3,
		sys_addr,lpPBrush,sys_addr,lpDrawMode);
extern VOID	DColorInfo IPT3(sys_addr,lpDestDev,double_word,colorin,sys_addr,lpPColor);
extern VOID	DControl IPT4(sys_addr,lpDestDev,word,wFunction,sys_addr,lpInData,sys_addr,lpOutData);
extern VOID	DDisable IPT1(sys_addr,lpDestDev);
extern VOID	DEnable IPT5(sys_addr,lpDestDev,word,wStyle,sys_addr,lpDestType,sys_addr,
		lpOutputFile,sys_addr,lpData);
extern VOID	DEnumDFonts IPT1(sys_addr,stkframe);
extern VOID	DEnumObj IPT1(sys_addr,stkframe);
extern VOID	DOutput IPT8(sys_addr,lpDestDev,word,lpStyle,word,Count,sys_addr,lpPoints,
		sys_addr,lpPPen,sys_addr,lpPBrush,sys_addr,lpDrawMode,sys_addr,lpClipRect);
extern VOID	DPixel IPT5(sys_addr,lpDestDev,word,x,word,y,double_word,PhysColor,sys_addr,lpDrawMode);
#ifdef SWIN_DEVBMP
extern VOID	DBitmapBits IPT4(sys_addr,lpDevice,double_word,fFlags,double_word,dwCount,double_word,lpBits);
extern VOID	DSelectBitmap IPT4(sys_addr,lpDevice,sys_addr,lpPrevBitmap,sys_addr,lpBitmap,double_word,fFlags);
#endif
extern VOID	DRealizeObject IPT5(word,Style,sys_addr,lpInObj,sys_addr,lpOutObj,word,originX,word,originY);
extern VOID	DStrblt IPT9(sys_addr,lpDestDev,word,DestxOrg,word,DestyOrg,sys_addr,lpClipRect,
		sys_addr,lpString,word,Count,sys_addr,lpFont,sys_addr,lpDrawMode, sys_addr,lpTextXForm);
extern VOID	DScanlr IPT5(sys_addr,lpDestDev,word,x,word,y,double_word,PhysColor,word,Style);
extern VOID	DDeviceMode IPT1(sys_addr,stkframe);
extern VOID	DInquire IPT1(sys_addr,stkframe);
extern VOID	DSetCursor IPT1(sys_addr,lpCursorShape);
extern VOID	DMoveCursor IPT1(sys_addr,stkframe);
extern VOID	DCheckCursor IPT1(sys_addr,stkframe);
extern VOID	DSaveScreenBitmap IPT5(word, command, word, x, word, y, word, xext, word, yext);
extern VOID	DExtTextOut IPT12(sys_addr, dstdev, word, dx, word, dy, sys_addr, cliprect, sys_addr, 
		str, word, strlnth, sys_addr, pfont, sys_addr, drawmode, sys_addr, textxform, 
		sys_addr, txtcharwidths, sys_addr, opaquerect, word, options);
extern VOID	DGetCharWidth IPT7(sys_addr,dstdev,sys_addr,buffer,word,first,word,last,sys_addr,
		pfont,sys_addr,drawmode,sys_addr,textxform);
extern VOID	DDeviceBitmap IPT1(sys_addr,stkframe);
extern VOID	DDeviceBitmapBits IPT8(sys_addr,lpDestDev,word,setOrget,word,startScan,word,
		numScans,sys_addr,lpDIBBits,sys_addr,lpDIBHeader,sys_addr,
		lpDrawMode,sys_addr,lpColorInfo);
extern VOID	DSetDIBitsToDevice IPT10(sys_addr, lpDestDev, word, screenXOrigin, word, 
		screenYOrigin, word, startScan, word, numScans, sys_addr, lpClipRect, 
		sys_addr, lpDrawMode, sys_addr, lpDIBBits, sys_addr, lpDIBHeader, 
		sys_addr, lpColorInfo);
extern VOID	DFastBorder IPT11(sys_addr,lpDestDev,word,dx,word,dy,word,xext,word,yext,
		word,hbt,word,vbt,double_word,rop3,sys_addr,pbrush,
		sys_addr,drawmode,sys_addr,cliprect);
extern VOID	DSetAttribute IPT1(sys_addr,stkframe);
extern VOID	DSetPalette IPT3(word,wIndex,word,wCount,sys_addr,lpColorTable);
extern VOID	DGetPalette IPT3(word,wIndex,word,wCount,sys_addr,lpColorTable);
extern VOID	DSetPalTrans IPT1(sys_addr,lpTranslate);
extern VOID	DGetPalTrans IPT1(sys_addr,lpTranslate);
extern VOID	DUpdateColors IPT5(word,wStartX,word,wStartY,word,wExtX,word,wExtY,sys_addr,lpTranslate);
extern char *	DGXopToString IPT1(int, gxop);
extern void	DPrintLineStyle IPT1(int, style);
extern void	DPrintBrushStyle IPT1(int, style);
extern void	DPrintStyle IPT1(int, lpStyle);

#else

#define DPrintMonoBitmap(bitmap,bytes_per_line,width,height)
#define DReportColEnquire(p1,p2)
#define DReportPixelEnquire(p1,p2)
#define	DPrintImageDetails(p1)
#define	DPrintBitmapDetails(p1) 
#define DPrintMessage(p1)
#define DPrintColourmap(p1,p2)
#define DPrintSrcDstRect(p1,p2,p3,p4,p5,p6)
#define DPrintGDIInfo
#define DPrintBitmap(p1,p2,p3)
#define DPrintPBrush(p1,p2)
#define DPrintPpen(p1)
#define DPrintDrawMode(p1,p2)
#define DPrintDevice(p1)
#define DPrintlpPoints(p1,p2)
#define DPrintClipRect(p1)
#define DPrintInteger(p1) 
#define DPrintTransTable(p1,p2)
#define DGXopToString (p1)
#define DPrintLineStyle (p1)
#define DPrintBrushStyle (p1)
#define	DPrintStyle (p1)

#define DBitblt(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11)
#define DColorInfo(p1,p2,p3)
#define DControl(p1,p2,p3,p4)
#define DDisable(p1)
#define DDeviceBitmapBits(p1,p2,p3,p4,p5,p6,p7,p8)
#define DEnable(p1,p2,p3,p4,p5)
#define DExtTextOut(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12)
#define DFastBorder(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11)
#define DGetPaletteEntries(p1,p2,p3)
#define DGetPaletteTranslate(p1,p2)
#define DOutput(p1,p2,p3,p4,p5,p6,p7,p8)
#define DPixel(p1,p2,p3,p4,p5)
#define DRealizeObject(p1,p2,p3,p4,p5)
#define DSaveScreenBitmap(p1,p2,p3,p4,p5)
#define DScanlr(p1,p2,p3,p4,p5)
#define DSetDIBitsToDevice(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10)
#define DSetPaletteEntries(p1,p2,p3)
#define DSetPaletteTranslate(p1,p2)
#define DStrblt(p1,p2,p3,p4,p5,p6,p7,p8,p9)
#define DUpdateColors(p1,p2,p3,p4,p5)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\host_hun.h ===
HOST_HUNT.H no Longer exists!!! - Renamed to be HOSTHUNT.h (conform to 8.3 naming
conventions.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\host_pth.h ===
/*[
 *	Name:		host_pth.h
 *
 *	Deived from:	(original)
 *
 *	Author:		John Cremer
 *
 *	Created on:	11 Oct 93
 *
 *	Sccs ID:	@(#)host_pth.h	1.1 10/13/93
 *
 *	Coding stds:	2.0
 *
 *	Purpose:	Definitions and function declarations for host pathname
 * 			editting routines.
 *
 *	Copyright Insignia Solutions Ltd., 1993.  All rights reserved.
]*/

typedef	char	HOST_PATH;	/* host pathname string type */

extern HOST_PATH *HostPathAppendFileName IPT3(
    HOST_PATH *,buf,		/* buffer for resulting pathname */ 
    HOST_PATH *,dirPath,	/* directory pathname */
    CHAR *,fileName		/* file name to be appended */
);

extern HOST_PATH *HostPathAppendDirName IPT3(
    HOST_PATH *,buf,		/* buffer for resulting pathname */ 
    HOST_PATH *,dirPath,        /* directory pathname */
    CHAR *,dirName              /* directory name to be appended */
);

extern HOST_PATH *HostPathAppendPath IPT3(
    HOST_PATH *,buf,		/* buffer for resulting pathname */
    HOST_PATH *,dirPath,	/* existing directory path */
    HOST_PATH *,path		/* path to be appended */
);

extern HOST_PATH *HostPathMakeTempFilePath IPT3(
    HOST_PATH *,buf,		/* buffer for resulting pathname */
    HOST_PATH *,dirPath,	/* directory path, or NULL */
    CHAR *,fileName		/* file name, or NULL */
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\host_nls.h ===
/*
 *	Name:			host_nls.h
 *	Derived From:		HP 2.0 host_nls.h
 *	Author:			Philippa Watson
 *	Created On:		23 January 1991
 *	Sccs ID:		@(#)host_nls.h	1.9 08/19/94
 *	Purpose:		Host side nls definitions.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
 */

/*
 * The following messages are the only ones that are not in the
 * NLS message catalog.  The first is used if SoftPC cannot open
 * the message catalog.  The second is used if a message is not found
 * in the catalog.
 */
#define CAT_OPEN_MSG            "Message file problem. Cannot find the native language support catalog\n"
#define CAT_ERROR_MSG           "Message file problem. Cannot find the required error text in the native language support catalogs."
#define EMPTY                   ""


/* Offset for accessing config NLS strings - the config dynamically 
   fills the config definitions with entries retrieved from NLS
   by accessing the message referenced by CONF_STR_OFFSET + hostID */
#define CONF_STR_OFFSET		2001

/* NLS definitions used to indicate the type of situation */
#define PNL_TITLE_GROUP		3001
#define PNL_TITLE_WARNING	3001
#define PNL_TITLE_ERROR		3002
#define PNL_TITLE_CONF_PROB	3003
#define PNL_TITLE_INST_PROB	3004

/* NLS definitions used in config to show what is not perfect */
#define PNL_CONF_GROUP		3010
#define PNL_CONF_PROB_FILE	3010
#define PNL_CONF_VALUE_REQUIRED	3011
#define PNL_CONF_CURRENT_VALUE	3012
#define PNL_CONF_DEFAULT_VALUE	3013
#define PNL_CONF_CHANGE_CURRENT	3014
#define PNL_CONF_NEW_VALUE	3015

/* NLS definitions used to display the User interface buttons */
#define PNL_BUTTONS_GROUP	3020
#define PNL_BUTTONS_DEFAULT	3020
#define PNL_BUTTONS_CONTINUE	3021
#define PNL_BUTTONS_EDIT	3027
#define PNL_BUTTONS_RESET	3022
#define PNL_BUTTONS_QUIT	3023
#define PNL_BUTTONS_ENTER	3024
#define PNL_BUTTONS_OR		3025
#define PNL_BUTTONS_COMMA	3026

/* NLS definitions used for reading the keyboard response to buttons on DT's */
#define PNL_DT_KEYS_DEFAULT	3030
#define PNL_DT_KEYS_CONTINUE	3031
#define PNL_DT_KEYS_EDIT	3036
#define PNL_DT_KEYS_RESET	3032
#define PNL_DT_KEYS_QUIT	3033
#define PNL_DT_KEYS_YES		3034
#define PNL_DT_KEYS_NO		3035
#define PNL_LIST_ON_MSG		3037
#define PNL_LIST_OFF_MSG	3038
#define PNL_LIST_COM_MSG	3039
#define PNL_LIST_SLV_MSG	3040
#define PNL_LIST_FPB_MSG	3041
#define PNL_LIST_FPA_MSG	3042
#define PNL_LIST_ED_MSG         3043
#define PNL_LIST_PRK_MSG        3044

extern void  host_nls_get_msg 		IPT3(int,msg_num,
						CHAR *,msg_buff,int,buff_len);
#ifdef NTVDM
#define host_nls_get_msg_no_check host_nls_get_msg
#else
extern void  host_nls_get_msg_no_check 	IPT3(int,msg_num,
						CHAR *,msg_buff,int,buff_len);
extern int nls_init IPT0();
#endif

/* In order to stabilise the numbers used in the NLS catalogues,
 * we now fix the C_* defines in config.h. The config_message
 * array in X_nls.c therefore needs to hold both the string and
 * and the official ID number. host_nls_scan_default is a utility
 * function to replace the direct array lookups.
 */ 
typedef struct {
	char	*name;		/* default string */
	IU8	hostID;		/* config ID number, e.g. C_SWITCHNPX */
} config_default;

extern CHAR *host_nls_scan_default	IPT2(int,msg_num,
					     config_default *,dflt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\host_sas.h ===
/*[
 *      Product:        SoftPC-AT Revision 3.0
 *
 *      Name:           host_sas.h
 *
 *      Derived From:   New
 *
 *      Authors:        A. Guthrie
 *
 *      Created On:     Wed Apr 24 18:33:01 BST 1991
 *
 *      Sccs ID:        @(#)host_sas.h	1.18 08/10/92
 *
 *      Purpose:        Defines the function pointer interface to host sas
 *			routines.
 *
 *      (c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
 *
]*/
#if defined(BASE_SAS) && defined(HOST_SAS)

#ifndef SAS_PREFIX
#define SAS_PREFIX()	sas_
#endif /* SAS_PREFIX */

#define IDENT(a)	a
#define CAT(a,b)	IDENT(a)b
#define sas_term			CAT(SAS_PREFIX(),term)
#define sas_init			CAT(SAS_PREFIX(),init)
#define sas_memory_size			CAT(SAS_PREFIX(),memory_size)
#define sas_memory_type			CAT(SAS_PREFIX(),memory_type)
#define sas_blockop			CAT(SAS_PREFIX(),blockop)
#define sas_load			CAT(SAS_PREFIX(),load)
#define sas_loadw			CAT(SAS_PREFIX(),loadw)
#define sas_store			CAT(SAS_PREFIX(),store)
#define sas_storew			CAT(SAS_PREFIX(),storew)
#define sas_storedw			CAT(SAS_PREFIX(),storedw)
#define sas_store_no_check		CAT(SAS_PREFIX(),store_no_check)
#define sas_storew_no_check		CAT(SAS_PREFIX(),storew_no_check)
#define sas_storedw_no_check		CAT(SAS_PREFIX(),storedw_no_check)
#define sas_fills			CAT(SAS_PREFIX(),fills)
#define sas_fillsw			CAT(SAS_PREFIX(),fillsw)
#define sas_hw_at			CAT(SAS_PREFIX(),hw_at)
#define sas_w_at			CAT(SAS_PREFIX(),w_at)
#define sas_dw_at			CAT(SAS_PREFIX(),dw_at)
#define sas_hw_at_no_check		CAT(SAS_PREFIX(),hw_at_no_check)
#define sas_w_at_no_check		CAT(SAS_PREFIX(),w_at_no_check)
#define sas_dw_at_no_check		CAT(SAS_PREFIX(),dw_at_no_check)
#define sas_loads			CAT(SAS_PREFIX(),loads)
#define sas_stores			CAT(SAS_PREFIX(),stores)
#define sas_loads_no_check		CAT(SAS_PREFIX(),loads_no_check)
#define sas_stores_no_check		CAT(SAS_PREFIX(),stores_no_check)
#define sas_move_bytes_forward		CAT(SAS_PREFIX(),move_bytes_forward)
#define sas_move_words_forward		CAT(SAS_PREFIX(),move_words_forward)
#define sas_move_bytes_backward		CAT(SAS_PREFIX(),move_bytes_backward)
#define sas_move_words_backward		CAT(SAS_PREFIX(),move_words_backward)
#define sas_enable_20_bit_wrapping	CAT(SAS_PREFIX(),enable_20_bit_wrapping)
#define sas_disable_20_bit_wrapping	CAT(SAS_PREFIX(),disable_20_bit_wrapping)
#define sas_twenty_bit_wrapping_enabled	CAT(SAS_PREFIX(),twenty_bit_wrapping_enabled)
#define sas_part_enable_20_bit_wrap	CAT(SAS_PREFIX(),part_enable_20_bit_wrap)
#define sas_part_disable_20_bit_wrap	CAT(SAS_PREFIX(),part_disable_20_bit_wrap)
#define sas_scratch_address		CAT(SAS_PREFIX(),scratch_address)
#define sas_connect_memory		CAT(SAS_PREFIX(),connect_memory)
#define sas_overwrite_memory		CAT(SAS_PREFIX(),overwrite_memory)

#endif /* BASE_SAS && HOST_SAS */

#ifndef BASE_SAS

#ifdef HOST_SAS

typedef struct
{
	VOID		( *do_sas_init ) ();
	VOID		( *do_sas_term ) ();
	sys_addr	( *do_sas_memory_size ) ();
	half_word	( *do_sas_memory_type ) ();
	VOID		( *do_sas_load ) ();
	VOID		( *do_sas_loadw ) ();
	VOID		( *do_sas_store ) ();
	VOID		( *do_sas_storew ) ();
	VOID		( *do_sas_storedw ) ();
	VOID		( *do_sas_fills ) ();
	VOID		( *do_sas_fillsw) ();
	half_word	( *do_sas_hw_at ) ();
	word		( *do_sas_w_at ) ();
	double_word	( *do_sas_dw_at ) ();
	VOID		( *do_sas_loads ) ();
	VOID		( *do_sas_stores ) ();
	VOID		( *do_sas_move_bytes_forward ) ();
	VOID		( *do_sas_move_words_forward ) ();
	VOID		( *do_sas_move_bytes_backward ) ();
	VOID		( *do_sas_move_words_backward ) ();
	host_addr	( *do_sas_get_byte_addr ) ();
	host_addr	( *do_sas_inc_M_ptr ) ();
	host_addr	( *do_sas_M_get_dw_ptr ) ();
	VOID		( *do_sas_enable_20_bit_wrapping ) ();
	VOID		( *do_sas_disable_20_bit_wrapping ) ();
	host_addr	( *do_sas_scratch_address ) ();
	VOID		( *do_sas_connect_memory ) ();
	VOID		( *do_sas_store_no_check ) ();
	VOID		( *do_sas_storew_no_check ) ();
	VOID		( *do_sas_storedw_no_check ) ();
	half_word	( *do_sas_hw_at_no_check ) ();
	word		( *do_sas_w_at_no_check ) ();
	half_word	( *do_sas_blockop ) ();
	double_word	( *do_sas_dw_at_no_check ) ();
	BOOL		( *do_sas_twenty_bit_wrapping_enabled ) ();
	VOID		( *do_sas_part_enable_20_bit_wrap ) ();
	VOID		( *do_sas_part_disable_20_bit_wrap ) ();
	VOID		( *do_sas_loads_no_check ) ();
	VOID		( *do_sas_stores_no_check ) ();
	VOID		( *do_sas_overwrite_memory ) ();
} SAS_FUNCTIONS;

IMPORT SAS_FUNCTIONS	host_sas_funcs;

#define	sas_init( size ) \
	( *host_sas_funcs.do_sas_init ) ( size )
#define	sas_term( ) \
	( *host_sas_funcs.do_sas_term ) ( )
#define	sas_memory_size( ) \
	( *host_sas_funcs.do_sas_memory_size ) ( )
#define	sas_memory_type( ) \
	( *host_sas_funcs.do_sas_memory_type ) ( )
#define	sas_blockop( start, end, op ) \
	( *host_sas_funcs.do_sas_blockop ) ( start, end, op )
#define	sas_load( addr, val ) \
	( *host_sas_funcs.do_sas_load ) ( addr, val )
#define	sas_loadw( addr, val ) \
	( *host_sas_funcs.do_sas_loadw ) ( addr, val )
#define	sas_store( addr, val ) \
	( *host_sas_funcs.do_sas_store ) ( addr, val )
#define	sas_storew( addr, val ) \
	( *host_sas_funcs.do_sas_storew ) ( addr, val )
#define	sas_storedw( addr, val ) \
	( *host_sas_funcs.do_sas_storedw ) ( addr, val )
#define	sas_store_no_check( addr, val ) \
	( *host_sas_funcs.do_sas_store_no_check ) ( addr, val )
#define	sas_storew_no_check( addr, val ) \
	( *host_sas_funcs.do_sas_storew_no_check ) ( addr, val )
#define	sas_storedw_no_check( addr, val ) \
	( *host_sas_funcs.do_sas_storedw_no_check ) ( addr, val )
#define	sas_fills( addr, val, len ) \
	( *host_sas_funcs.do_sas_fills ) ( addr, val, len )
#define	sas_fillsw( addr, val, len ) \
	( *host_sas_funcs.do_sas_fillsw ) ( addr, val, len )
#define	sas_hw_at( addr ) \
	( *host_sas_funcs.do_sas_hw_at ) ( addr )
#define	sas_w_at( addr ) \
	( *host_sas_funcs.do_sas_w_at ) ( addr )
#define	sas_dw_at( addr ) \
	( *host_sas_funcs.do_sas_dw_at ) ( addr )
#define	sas_hw_at_no_check( addr ) \
	( *host_sas_funcs.do_sas_hw_at_no_check ) ( addr )
#define	sas_w_at_no_check( addr ) \
	( *host_sas_funcs.do_sas_w_at_no_check ) ( addr )
#define	sas_dw_at_no_check( addr ) \
	( *host_sas_funcs.do_sas_dw_at_no_check ) ( addr )
#define	sas_loads( src, dest, len ) \
	( *host_sas_funcs.do_sas_loads ) ( src, dest, len )
#define	sas_stores( dest, src, len ) \
	( *host_sas_funcs.do_sas_stores ) ( dest, src, len )
#define	sas_move_bytes_forward( src, dest, len ) \
	( *host_sas_funcs.do_sas_move_bytes_forward ) ( src, dest, len )
#define	sas_move_words_forward( src, dest, len ) \
	( *host_sas_funcs.do_sas_move_words_forward ) ( src, dest, len )
#define	sas_move_bytes_backward( src, dest, len ) \
	( *host_sas_funcs.do_sas_move_bytes_backward ) ( src, dest, len )
#define	sas_move_words_backward( src, dest, len ) \
	( *host_sas_funcs.do_sas_move_words_backward ) ( src, dest, len )
#define	get_byte_addr( address ) \
	( *host_sas_funcs.do_sas_get_byte_addr ) ( address )
#define	inc_M_ptr( buf, offset ) \
	( *host_sas_funcs.do_sas_inc_M_ptr ) ( buf, offset )
#define	M_get_dw_ptr( offset ) \
	( *host_sas_funcs.do_sas_M_get_dw_ptr ) ( offset )
#define	sas_enable_20_bit_wrapping() \
	( *host_sas_funcs.do_sas_enable_20_bit_wrapping ) ()
#define	sas_disable_20_bit_wrapping() \
	( *host_sas_funcs.do_sas_disable_20_bit_wrapping ) ()
#define	sas_part_enable_20_bit_wrap( flag, target, source) \
	( *host_sas_funcs.do_sas_part_enable_20_bit_wrap ) ( flag, target, source)
#define	sas_part_disable_20_bit_wrap( flag, target, source) \
	( *host_sas_funcs.do_sas_part_disable_20_bit_wrap ) ( flag, target, source)
#define	sas_twenty_bit_wrapping_enabled() \
	( *host_sas_funcs.do_sas_twenty_bit_wrapping_enabled ) ()
#define	sas_scratch_address( length ) \
	( *host_sas_funcs.do_sas_scratch_address ) ( length )
#define	sas_connect_memory( laddr, haddr, len ) \
	( *host_sas_funcs.do_sas_connect_memory ) ( laddr, haddr, len )
#define	sas_loads_no_check( src, dest, len ) \
	( *host_sas_funcs.do_sas_loads_no_check ) ( src, dest, len )
#define	sas_stores_no_check( dest, src, len ) \
	( *host_sas_funcs.do_sas_stores_no_check ) ( dest, src, len )
#define	sas_overwrite_memory( dest, len ) \
	( *host_sas_funcs.do_sas_overwrite_memory ) ( dest, len )

#endif /* HOST_SAS */

#endif /* BASE_SAS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\host_sig.h ===
/*
 *	File:		host_sig.h
 *
 *	Purpose:	header file to provide typedefs and prototypes
 *			for use with the host signal functions.
 *
 *	Author:	John Shanly
 *
 *	Date:		July 2, 1992
 *
 *	SccsID @(#)host_sig.h	1.3 11/17/92 Copyright (1992 )Insignia Solutions Ltd
 */

typedef void (*VOIDFUNC)();

#ifdef ANSI
GLOBAL void (*host_signal( int sig, VOIDFUNC handler )) ();
#else
GLOBAL void (*host_signal()) ();
#endif	/* ANSI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\host_lpt.h ===
#ifdef	PRINTER

#ifndef _HOST_LPT_H
#define _HOST_LPT_H
#if defined(NEC_98)         // NEC {

IMPORT  SHORT           host_lpt_valid
   IPT4(UTINY,hostID, ConfigValues *,val, NameTable *,dummy, CHAR *,errString);
IMPORT  VOID            host_lpt_change IPT2(UTINY,hostID, BOOL,apply);
IMPORT  SHORT           host_lpt_active
                        IPT3(UTINY,hostID, BOOL,active, CHAR *,errString);
IMPORT  void            host_lpt_close IPT0();
IMPORT  unsigned long   host_lpt_status IPT0();
IMPORT  BOOL            host_print_byte IPT1(byte, value);
//IMPORT        BOOL            host_print_doc IPT0();
//IMPORT        void            host_reset_print IPT0();
IMPORT  void            host_print_auto_feed IPT1(BOOL,auto_feed);

#define HOST_LPT_BUSY   (1 << 0)                // NEC
#else
/*[
	Name:		host_lpt.h
	Derived From:	Base 2.0
	Author:		Ross Beresford
	Created On:	
	Sccs ID:	11/14/94 @(#)host_lpt.h	1.8
	Purpose:	
		Definition of the interface between the generic printer
		adapter emulation functions and the host specific functions.
		THIS IS A BASE MODULE

		Users of the printer emulation functions must provide an
		implementation of the following host specific functions.
		In each of the calls, "adapter" is the index number for
		the parallel port (ie 0 for LPT1: through to 2 for LPT3:)

SHORT host_lpt_valid
	(UTINY hostID, ConfigValues *val, NameTable *dummy, CHAR *errString)
{
	Routine to validate a comms entry, called by config system.
}

VOID host_lpt_change(UTINY hostID, BOOL apply)
{
	Routine called by config to clean up after validation depending
	on if apply is true or not.  If not then the validation files
	are to be closed, otherwise the active adapter is to be shutdown and
	the validation data transfered.
}

SHORT host_lpt_active(UTINY hostID, BOOL active, CHAR *errString)
{
	Connect the adapter to the outside world.  Open or close
	the adapter as appropiate.
}

void host_lpt_close(adapter)
int adapter;
{
	Close connection to external printing device for the
	parallel port
}

unsigned long host_lpt_status(adapter)
int adapter;
{
	Return status of external printing device.  The
	following bits may be set in the return value; bits
	marked FOR FUTURE USE are not yet used by the base
	parallel port implementation.

	HOST_LPT_BUSY	printer is busy - wait for this bit
			to clear before sending further output

	HOST_LPT_PEND	printer is out of paper
			- FOR FUTURE USE

	HOST_LPT_SELECT	printer is in the selected state
			- FOR FUTURE USE

	HOST_LPT_ERROR	printer is in an error state
			- FOR FUTURE USE
}

boolean host_print_byte(adapter, value)
int adapter;
half_word value;
{
	Output "value" to the external printing device
}

void host_reset_print(adapter)
int adapter;
{
	<chrisP 4-Oct-91>
	Hard reset the printer.  This may involve...
	Flush the output to the external printing
	device
}

boolean host_print_doc(adapter)
int adapter;
{
	Flush the output to the external printing device
}

void host_print_auto_feed(adapter, auto_feed)
int adapter;
boolean auto_feed;
{
	If "auto_feed" is TRUE, then output an extra line
	feed character for each carriage return output to
	the external printing device.
}

GLOBAL void host_lpt_enable_autoflush IFN1(IS32, adapter)
{
	Reset the autoflush disabled flag for the printer port.
}

GLOBAL void host_lpt_disable_autoflush IFN1(IS32, adapter)
{
	Cancel any outstanding autoflush event for the printer port and set the
        autoflush disabled flag for the printer port.
}

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

Modifications:
		<chrisP 4-Oct-91>
		Change the name of host_print_doc() to host_reset_print().
		This reflects what is actually needed when it is called from printer.c.
		If your port really wants to print a document when the reset
		line becomes active, you can call your host_print_doc from 
		host_reset_print.
		
]*/

IMPORT	SHORT		host_lpt_valid
    IPT4(UTINY,hostID, ConfigValues *,val, NameTable *,dummy, CHAR *,errString);
IMPORT	VOID		host_lpt_change IPT2(UTINY,hostID, BOOL,apply);
IMPORT	SHORT		host_lpt_active
	IPT3(UTINY,hostID, BOOL,active, CHAR *,errString);
IMPORT	void		host_lpt_close IPT1(int,adapter);
IMPORT	unsigned long	host_lpt_status IPT1(int,adapter);
IMPORT	BOOL		host_print_byte IPT2(int,adapter, byte, value);
IMPORT	BOOL		host_print_doc IPT1(int,adapter);
IMPORT	void		host_reset_print IPT1(int,adapter);
IMPORT	void		host_print_auto_feed IPT2(int,adapter, BOOL,auto_feed);

#if defined(NTVDM)
IMPORT	BOOLEAN 	host_set_lpt_direct_access(int adapter, BOOLEAN direct_access);
IMPORT	UCHAR		host_read_printer_status_port(int adapter);
#endif

#ifdef PS_FLUSHING
IMPORT void host_lpt_enable_autoflush IPT1(IS32, adapter);
IMPORT void host_lpt_disable_autoflush IPT1(IS32, adapter);
#endif	/* PS_FLUSHING */

#if defined (NTVDM) && defined(MONITOR)
IMPORT void host_printer_setup_table(sys_addr table_addr, word nPorts, word * lptStatusPortAddr);
#endif

#define	HOST_LPT_BUSY	(1 << 0)
#define	HOST_LPT_PEND	(1 << 1)
#define	HOST_LPT_SELECT	(1 << 2)
#define	HOST_LPT_ERROR	(1 << 3)

/*
 * Printer port numbering convention. Internal numbering is 0 based,
 * and number_for_adapter() converts to the PC world's convention.
 */
#define LPT1			0
#define LPT2			1
#define LPT3			2

#define	number_for_adapter(adapter)	(adapter + 1)

#endif	// NEC_98                                          // NEC }

#endif /* _HOST_LPT_H */

#endif /* PRINTER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\host_str.h ===
/*[
 *	Name:		host_str.h
 *
 *	Derived From:	(original)
 *
 *	Author:		John Cremer
 *
 *	Created On:	Oct 93
 *
 *	Sccs ID:	@(#)host_str.h	1.1 10/29/93
 *
 *	Coding Stds:	2.0
 *
 *	Purpose:	Provide prototypes for additional string manipulation
 *			functions.
 *
 *	Copyright Insignia Solutions Ltd., 1993.  All rights reserved.
]*/


 
GLOBAL CHAR *HostStrdup IPT1(
    CHAR *, s1		/* string to be duplicated */
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\host_uis.h ===
#ifndef _HOST_UIS_H
#define _HOST_UIS_H

typedef enum 
{
	PT_WARNING,
	PT_ERROR,
	PT_INFORM,
	PT_QUESTION,
	PT_WORKING,
	PT_LAST
} PTInd;

#define PM_WARNING	pm_warning_image
#define PM_ERROR	pm_error_image
#define PM_INFORM	pm_inform_image
#define PM_QUESTION	pm_question_image
#define PM_WORKING	pm_working_image

/* control button stuff */
#define LEFT_RA_POSITION	25	/* 25 percent */
#define CENTRE_LA_POSITION	37	/* 37 percent */
#define CENTRE_RA_POSITION	62	/* 62 percent */
#define RIGHT_LA_POSITION	75	/* 75 percent */
#define NON_DEF_TOP_OFFSET	10

#ifdef HOST_HELP
/*
	Control button positions for dialogs with four buttons - ie those
	with OK, Reset, Cancel, and Help.
*/
#define FIRST_RA_POSITION	23	/* percent */
#define SECOND_LA_POSITION	27
#define SECOND_RA_POSITION	48
#define THIRD_LA_POSITION	52
#define THIRD_RA_POSITION	73
#define FOURTH_LA_POSITION	77

#endif /*HOST_HELP*/


typedef struct
{
	XtAppContext context;
	Widget toplevel;
	Widget main_win;	/* SoftPC main window */
        Widget pc_screen;	/* SoftPC screen widget */
	BOOL ready;		/* SoftPC uif Ready */
	LONG paneCount;
	int decorNoSize, decorSize;
	XmString panelTitles[PT_LAST];
} UIS;

IMPORT UIS uis;
IMPORT BOOL BatchMode;

IMPORT LONG uis_event_loop IPT2(LONG *,loop, BOOL,wait_non_zero);
IMPORT XmString wordWrap IPT3(XmString,str,Dimension,width,XmFontList,fList);

#ifdef HOST_HELP
IMPORT void callContextHelp IPT1(long, callContext) ;
IMPORT void callMainHelp IPT0() ;
IMPORT void callHelpOnHelp IPT0() ;
#endif

IMPORT CHAR pm_warning_image[];
IMPORT CHAR pm_error_image[];
IMPORT CHAR pm_inform_image[];
IMPORT CHAR pm_question_image[];
IMPORT CHAR pm_working_image[];

IMPORT void MGInstallMwmCloseCallback();

IMPORT void UxPopupInterface();
IMPORT void UxPopdownInterface();

#endif /* _HOST_UIS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\hwvga.h ===
/*[
 *
 *	File		:	hwvga.h
 *
 *	Derived from:	(original)
 *
 *	Purpose		:	interface definition for hardware vga routines
 *
 *	Author		:	Rog
 *	Date		:	23 Feb 1993
 *
 *    SCCS Garbage	:	@(#)hwvga.h	1.5 11/22/93
 *	
 *	(c) Copyright Insignia Solutions Ltd., 1992 All rights reserved
 *
 *	Modifications	:
 *				Prototypes that don't depend on types
 *				defined in HostHwVgaH should go in gispsvga.h
 *				not here.  This file does contain some 
 *				prototypes from before this split was made.
 *
]*/


#ifdef GISP_SVGA
#ifndef _HWVGA_H_
#define _HWVGA_H_

/* Video Mode types*/

#define	ALPHA		0x00
#define GRAPH		0x01
#define UNIMP		0x03
#define NA		0x04

/* Plane storage types	*/
#define ALPHA_INTERLEAVED	0x0001	/* Mode3 et ak is ca00ca00ca00 etc */
#define GRAPH_PACKED		0x0100	/* Vid modes are packed */
/* Data */

typedef struct
{
	IS8		modeType;		/* Current Video Mode Type */
	IS8		numPlanes;		/* number of planes in use */
	BOOL		runningFullScreen;	/* Are we fs at the moment */
	BOOL		fullScreenAvail;	/* Can we go Full Screen */
	BOOL		forcedFullScreen;	/* Are we full screen coz we want it */
	VGAState	* pSavedVGAState;	/* Any saved VGA State */
	BOOL		savedStateValid;
	struct		{
				IU32	offset;
				IU32	segment;
			} hostSavePtr;
	IU8		dccIndex;
	IU32		planeStorage;		/* Storage methods in planes */
}
vInfo;

extern vInfo videoInfo;


/* Prototypes */

BOOL videoModeIs IPT2( IU8 , videoMode , IU8 , videoType );
BOOL hostIsFullScreen IPT0( );
BOOL hostEasyMode IPT0( );
void hostFindPlaneStorage IPT0( );
void hostRepaintDecoration IPT0( );
void enableFullScreenVideo IPT0( );
void disableFullScreenVideo IPT1( BOOL , syncEmulation  );
void syncEmulationToHardware IPT1( pVGAState , currentVGAState );
void readEmulationState IPT1( pVGAState , currentVGAState );
void initHWVGA IPT0( );
void getHostFontPointers IPT0( );
void setupHwVGAGlobals IPT0( );
void loadFontToVGA IPT5( sys_addr , table , int , count , int , charOff , int , fontNum , int , nBytes );
void loadFontToEmulation IPT5( sys_addr , table , int , count , int , charOff , int , fontNum , int , nBytes );
void hostFreeze IPT0();
void hostUnfreeze IPT0();
void mapHostROMs IPT0( );

#ifndef hostStartFullScreen
void hostStartFullScreen IPT0();
#endif	/* hostStartFullScreen */

#ifndef	hostStopFullScreen
void hostStopFullScreen IPT0();
#endif	/* hostStopFullScreen */

#ifdef	HUNTER
void hunterGetFullScreenInfo IPT0();
#endif	/* HUNTER */

extern BOOL NeedGISPROMInit;

#endif /* _HWVGA_H_ */
#endif /* GISP_SVGA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\ica.h ===
/*
 * SoftPC Version 2.0
 *
 * Title	: Interrupt Controller Adapter definitions
 *
 * Description	: Include file for users of the ICA
 *
 * Author	: Jim Hatfield / David Rees
 *
 * Notes	: Rewritten from an original by Henry Nash
 */

/* SccsID[]="@(#)ica.h	1.25 10/19/95 Copyright Insignia Solutions Ltd."; */


/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#define	ICA_MASTER	0
#define ICA_SLAVE	1

#define	EGA_VTRACE_INT	2
#define	AT_EGA_VTRACE_INT	1
#define	AT_EGA_VTRACE_ADAPTER	1

/*
 * Allow the host to override the default values if its wants to
 */
#ifndef HOST_CPU_MOUSE_INT
#define HOST_AT_CPU_MOUSE_INT           1
#define HOST_AT_CPU_MOUSE_ADAPTER       1
#define HOST_AT_MOUSE_INT_VEC           0x0a
#define HOST_CPU_MOUSE_INT              2
#endif /* HOST_CPU_MOUSE_INT */
/*
 * CPU hardware interrupt definitions
 */
/* For the XT */
#define CPU_TIMER_INT   	0
#define CPU_KB_INT      	1
#define CPU_MOUSE_INT      	HOST_CPU_MOUSE_INT
#define AT_CPU_MOUSE_INT      	HOST_AT_CPU_MOUSE_INT
#define AT_CPU_MOUSE_ADAPTER	HOST_AT_CPU_MOUSE_ADAPTER
#define	MOUSE_VEC		HOST_AT_MOUSE_INT_VEC
#if defined(NEC_98)
#define CPU_CRTV_INT            2
#endif // NEC_98
#define CPU_RS232_SEC_INT   	3
#define CPU_RS232_PRI_INT   	4
#define CPU_DISK_INT   		5
#define CPU_DISKETTE_INT   	6
#define CPU_PRINTER_INT   	7

#if defined(NEC_98)
#define CPU_NO_DEVICE          -1
#define CPU_RS232_THIRD_INT    12
#endif

/* Different lines for the AT */
#define CPU_PRINTER2_INT	5

/*
 * For the Slave Chip on the AT
 */
#define CPU_RTC_INT		0

#if defined (NOVELL) || defined (NOVELL_IPX)
#define NETWORK_INT		2
#endif

#if defined (SWIN_HAW) 
#define SWIN_HAW_INT		3
#endif

#if defined (ASPI)
#define ASPI_INT		4
#endif

#define CPU_AT_NPX_INT		5	/* NPX exception */
#define CPU_AT_DISK_INT		6

 
#ifndef CPU_30_STYLE

/* def of bits in the CPU_INTERRUPT_MAP ?? */
#define CPU_HW_INT		0
#define CPU_HW_INT_MASK		(1 << CPU_HW_INT)

/*
 * CPU software interrupt definitions
 */
 
#define CPU_SW_INT              8
#define CPU_SW_INT_MASK         (1 << CPU_SW_INT)
#endif /* 3.0 CPU */

#define DIVIDE_OVERFLOW_INT     0

#define	END_INTERRUPT	0x20

extern void ica0_init IPT0();
extern void ica1_init IPT0();
extern void ica0_post IPT0();
extern void ica1_post IPT0();

extern void ica_hw_interrupt_cancel IPT2(IU32, adapter, IU32, line_no);
extern IU8 ica_scan_irr IPT1(IU32, adapter);
extern void ica_interrupt_cpu IPT2(IU32, adapter, IU32, line);
extern void ica_eoi IPT3(IU32, adapter, IS32 *, line, IBOOL, rotate);

#if defined (NTVDM)

#ifdef MONITOR
extern void ica_iret_hook_called IPT1(IU32, line);
extern void ica_iret_hook_control IPT3(IU32, adapter, IU32, line, IBOOL, enable);
#endif

VOID ica_RestartInterrupts(ULONG);
extern IS32 ica_intack IPT1(IU32 *, hook_addr);

extern void ica_clear_int(IU32 adapter, IU32 line);
extern void ica_inb(io_addr port, IU8 *val);
extern void ica_outb(io_addr port, IU8 val);
extern void ica_hw_interrupt(IU32 adapter, IU32 line_no, IS32 call_count);




/*
 *  The NTVDM ica adapter structure has been moved to \nt\private\inc\vdm.h
 *  and is almost identical to the standard softpc ica adapter structure.
 *  It was Extracted to make it visible clearly from the monitor\kernel on
 *  x86
 *
 *  Notable differences:
 *  1. added ica_delayedints field for ntvdm's implementaion of delayed ints
 *  2. type definitions have change to match win32
 *  3. ADAPTER_STATE has been renamed to VDMVIRTUALICA
 *  4. Does not implement CPU_40 iret hooks
 *
 */
#include <vdm.h>
extern VDMVIRTUALICA VirtualIca[];

#else   /* ndef NTVDM */

extern void SWPIC_clear_int IPT2(IU32, adapter, IU32, line_no);
extern void SWPIC_init_funcptrs IPT0();
extern void SWPIC_inb IPT2(io_addr, port, IU8 *, value);
extern void SWPIC_outb IPT2(io_addr, port, IU8, value);
extern void SWPIC_hw_interrupt IPT3(IU32, adapter, IU32, line_no,
	IS32, call_count);

#ifdef HOOKED_IRETS
extern IS32 ica_intack IPT1(IU32 *, hook_addr);
extern void ica_iret_hook_called IPT1(IU32, line);
extern void ica_enable_iret_hooks IPT0();
extern void ica_disable_iret_hooks IPT0();
extern void ica_iret_hook_control IPT3(IU32, adapter, IU32, line, IBOOL, enable);
#else	/* !HOOKED_IRETS */
extern IS32 ica_intack IPT0();
#endif	/* !HOOKED_IRETS */

#ifdef CPU_40_STYLE
typedef void (*ICA_CALLBACK) IPT1(IU32, parm);
extern IBOOL action_interrupt IPT4(IU32, adapter, IU32, line, ICA_CALLBACK, func, IU32, parm);
extern void cancel_action_interrupt IPT2(IU32, adapter, IU32, line);
extern void ica_async_hw_interrupt IPT3(IU32, adapter, IU32, line_no,
        IS32, call_count);

extern void ica_check_stale_iret_hook IPT0();
#define MAX_ISR_DEPTH   3   /* max recursion level of ISR before ints blocked */
#define MAX_INTR_DELTA_FOR_LOST_HOOK	85
#endif /* CPU_40_STYLE */

typedef struct {
        IBOOL	ica_master;   /* TRUE = Master; FALSE = Slave		*/

	IU8	ica_irr;	/* Interrupt Request Register		*/
	IU8	ica_isr;	/* In Service Register			*/
	IU8	ica_imr;	/* Interrupt Mask Register		*/
	IU8	ica_ssr;	/* Slave Select Register		*/

	IU16	ica_base;	/* Interrupt base address for cpu	*/
	IU16	ica_hipri;	/* Line no. of highest priority line	*/
	IU16	ica_mode;	/* Various single-bit modes		*/

	IS32	ica_count[8];	/* This is an extension of ica_irr for	*/
				/* our frig. Contains HOW MANY of each	*/
				/* interrupt is required		*/
	IU32	ica_int_line;	/* Current pending interrupt		*/
				/* being counted down by the CPU	*/

	IU32	ica_cpu_int;	/* The state of the INT line to the CPU	*/

#ifdef CPU_40_STYLE             /* callback structure for action_interrupt() */
        IU32    callback_parm[8];       /* callback parameter */
	ICA_CALLBACK callback_fn[8];	/* callback fn */
	IS32	isr_depth[8];	/* iret hook recursion level */
	IS32	isr_progress[8][MAX_ISR_DEPTH + 1];	/* isr aging by int */
	IS32	isr_time_decay[8][MAX_ISR_DEPTH];	/* isr aging by time */
#endif

} ADAPTER_STATE;


/* 'no callback' define for action_interrupt callbacks */
#define NO_ICA_CALLBACK ((ICA_CALLBACK) 0L)

#endif  /* NTVDM */


#if !defined(NTVDM)
#ifdef  REAL_ICA

extern void host_ica_hw_interrupt IPT3(IU32, adap, IU32, line, IS32, cnt);
extern void host_ica_hw_interrupt_delay IPT4(IU32, adap, IU32, line, IS32, cnt, IS32, delay);
extern void host_ica_clear_int IPT2(IU32, adap, IU32, line);

#define ica_hw_interrupt(ms,line,cnt)				host_ica_hw_interrupt(ms, line, cnt)
#define	ica_hw_interrupt_delay(ms,line,cnt,delay)	host_ica_hw_interrupt(ms, line, cnt)
#define ica_clear_int(ms, line)						host_ica_clear_int(ms, line)

#else   /* REAL_ICA */

/*
 *  Change these. They come last.
 */

#define ica_inb(port,val)                       ((*ica_inb_func) (port,val))
#define ica_outb(port,val)                      ((*ica_outb_func) (port,val))
#define ica_hw_interrupt(ms,line,cnt)           ((*ica_hw_interrupt_func) (ms,line,cnt))
#define ica_clear_int(ms,line)                  ((*ica_clear_int_func) (ms,line))

 
/*
 *  PIC access functions needed for HW & SW
 */
extern void (*ica_inb_func) IPT2(io_addr, port, IU8 *, value);
extern void (*ica_outb_func) IPT2(io_addr, port, IU8, value);
extern void (*ica_hw_interrupt_func) IPT3(IU32, adapter, IU32, line_no,
	IS32, call_count);
extern void (*ica_clear_int_func) IPT2(IU32, adapter, IU32, line_no);

#endif  /* REAL_ICA */
#endif  /* !NTVDM */

#ifdef GISP_CPU
/*
 *	Prototype functions for interfaces provided by the ICA.
 */

typedef IBOOL HOOK_AGAIN_FUNC IPT1(IUM32, callers_ref);
extern void Ica_enable_hooking IPT3(IUM8, line_number,
			HOOK_AGAIN_FUNC *, hook_again, IUM32, callers_ref);

extern void Ica_hook_bop IPT1(IUM8, line_number);

#endif /* GISP_CPU */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\idetect.h ===
/*
 * File:        idetect.h
 *
 * Author:      J.Roper
 *
 * Import Necessary items for IDLE DETECT
 *
 * SccsID @(#)idetect.h 1.6 08/25/93 Copyright Insignia Solutions Ltd
 */

#ifndef NTVDM
extern int idle_no_video;
extern int idle_no_comlpt;
extern int idle_no_disk;
#endif

void    idetect();
void    idle_set();
void    idle_ctl();

#define IDLE_INIT               0
#define IDLE_KYBD_POLL  1
#define IDLE_TIME_TICK  2
#define IDLE_WAITIO             3


#ifdef NTVDM
/*
 * NT VDM idling system based on waits - call funcs for counter idle indicators
 * to allow them to cancel waits.
 */
VOID HostIdleNoActivity(VOID);

#define IDLE_video()    HostIdleNoActivity()
#define IDLE_comlpt()   HostIdleNoActivity()
#define IDLE_disk()     HostIdleNoActivity()

/* exported just for kb_setup_vector intialization */
extern word *pICounter;
extern word *pCharPollsPerTick;
extern word *pMinConsecutiveTicks;
extern word IdleNoActivity;
extern word ienabled;

#else
#define IDLE_video()    idle_no_video = 0
#define IDLE_comlpt()   idle_no_comlpt = 0
#define IDLE_disk()     idle_no_disk = 0
#endif

#define IDLE_tick()             idetect(IDLE_TIME_TICK)
#define IDLE_poll()             idetect(IDLE_KYBD_POLL)
#define IDLE_waitio()   idetect(IDLE_WAITIO)
#define IDLE_init()             idetect(IDLE_INIT)
#define IDLE_set(a,b)   idle_set(a,b)
#define IDLE_ctl(a)             idle_ctl(a)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\hunter.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Hunter -- the bug finder.
 *
 * Description	: External definitions for the hunter globals and routines.
 *
 * Author	: David Rees
 *
 * Notes	: DAR r3.2 - retyped host_hunter_image_check to int to
 *		             match changes in sun3_hunt.c, hunter.c 
 */

/* static char SccsID[]="@(#)hunter.h	1.10 09/01/92 Copyright Insignia Solutions Ltd."; */

/* This file has no effect unless HUNTER is defined. */
#ifdef	HUNTER

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
** Defines required by hunter base files
*/

/* EGA screen lengths (in scan lines) */
#define CGA_SCANS	200	/* CGA graphics modes screen length */
#define EGA_SCANS	350	/* EGA graphics mode screen length */
#define VGA_SCANS	400	/* VGA modes screen length */
#define	VGA_GSCANS	480	/* VGA graphics modes screen length */

/* Macro to determine whether a given point is inside a no check box. The
** point is given in PC terms.
*/
#define	xy_inabox(x, y)		(check_inside(x, y) >= 0)

/* Report types */
#define BRIEF			0
#define ABBREV			1
#define FULL			2

/* CGA screen dump sizes */
#define HUNTER_REGEN_SIZE     (16*1024)
#define HUNTER_BIOS_SIZE      0x90
#define HUNTER_SD_SIZE        (HUNTER_REGEN_SIZE + HUNTER_BIOS_SIZE)

/*
 * intel memory position defines for data stored in bios variables
 * used relative to BIOS_VAR_START to get bd indexes
 */
#define VID_MODE	0x449	/* vd_video_mode */
#define VID_COLS	0x44A	/* vd_cols_on_screen */
#define	VID_LEN  	0x44C	/* vd_crt_len */
#define	VID_ADDR	0x44E	/* vd_crt_start */
#define	VID_CURPOS	0x450	/* cursor table 8 pages */
#define	VID_CURMOD	0x460	/* vd_cursor_mode */
#define	VID_PAGE	0x462	/* vd_current_page */
#define VID_INDEX	0x463	/* vd_addr_6845 */
#define	VID_THISMOD	0x465	/* vd_cursor_mode */
#define	VID_PALETTE	0x466	/* vd_crt_palette */
#define VID_ROWS	0x484	/* vd_crt_rows - EGA only */

/*
** Screen dump mode bytes for EGA-type dumps.
*/
#define	EGA_SOURCE	0	/* Data gathered on EGA */
#define	VGA_SOURCE	1	/* Data gathered on VGA */
#define	V7VGA_SOURCE	2	/* Data gathered on Super7 VGA */

/*
** Structure for variables required by hunter base files
*/
typedef	struct
{
	word		h_page_length;	/* text bytes per page */
	half_word 	h_bd_page;	/* Active page from bios dump */
	word		h_sd_no;	/* no of current screen */
	half_word	spc_mode;	/* Mode in current spc bios */
	half_word	spc_page;	/* Page in current spc bios */
	word		spc_cols;	/* Columns in current spc bios */
	half_word	*h_regen;	/* current regen */
	half_word	*h_scrn_buffer;	/* current screendump */
#ifdef EGG
	half_word	*ega_r_planes;	/* EGA current regen data */
	half_word	*ega_s_planes;	/* EGA current screen dump data */
	half_word	e_sd_mode;	/* Data pack mode */
	int		h_line_compare;	/* line compare from VGA reg */
	int		h_max_scans;	/* max scan lines from VGA reg */
	half_word	h_bd_rows;	/* Rows from bios dunp */
	half_word	spc_rows;	/* softPC bios rows */
#endif	/* EGG */
	word		h_linecount;	/* Line within script file */
	word		h_scrn_length;	/* text bytes per screen */
	half_word	h_bd_mode;	/* Mode from bios dump */
	half_word	h_pixel_bits;	/* bits per pixel increment */
	half_word	h_report;
	BOOL		h_check_attr;	/* Value of HUCHECK env. variable */
	word		h_areas;	/* No. of non-check areas on screen */
	BOOL		h_txterr_prt;	/* stop txt error printing */
	word		h_gfxerr_max;	/* Value of HUGFXERR env. variable */
	char		h_filename_sd[MAXPATHLEN];	/* Ext filename, .sd */
	half_word	h_bios_buffer[HUNTER_BIOS_SIZE];/* current bios dump */
	word		h_bd_cols;	/* Cols from bios dump */
	word		h_bd_start;	/* plane start address */
	half_word	hc_mode;	/* video mode of active display screen */
	half_word	h_chk_mode;	/* value of HUCHKMODE env var */
	BOOL		h_gfxerr_prt;	/* stop gfx error printing */
}	BASE_HUNT_VARS;

IMPORT	BASE_HUNT_VARS	bh_vars;

/* Macros for accessing the above base hunter variables. */
#define	hunter_page_length	bh_vars.h_page_length
#define	hunter_bd_page		bh_vars.h_bd_page
#define	hunter_sd_no		bh_vars.h_sd_no
#define SPC_mode		bh_vars.spc_mode
#define SPC_page		bh_vars.spc_page
#define SPC_cols		bh_vars.spc_cols
#define hunter_regen		bh_vars.h_regen
#define hunter_scrn_buffer	bh_vars.h_scrn_buffer
#ifdef EGG
#define ega_regen_planes	bh_vars.ega_r_planes
#define ega_scrn_planes		bh_vars.ega_s_planes
#define ega_sd_mode		bh_vars.e_sd_mode
#define hunter_line_compare	bh_vars.h_line_compare
#define hunter_max_scans	bh_vars.h_max_scans
#define hunter_bd_rows		bh_vars.h_bd_rows
#define SPC_rows		bh_vars.spc_rows
#endif	/* EGG */
#define hunter_linecount	bh_vars.h_linecount
#define hunter_scrn_length	bh_vars.h_scrn_length
#define hunter_bd_mode		bh_vars.h_bd_mode
#define hunter_pixel_bits	bh_vars.h_pixel_bits
#define hunter_report		bh_vars.h_report
#define hunter_check_attr	bh_vars.h_check_attr
#define hunter_areas		bh_vars.h_areas
#define hunter_txterr_prt	bh_vars.h_txterr_prt
#define hunter_gfxerr_max	bh_vars.h_gfxerr_max
#define hunter_filename_sd	bh_vars.h_filename_sd
#define hunter_bios_buffer	bh_vars.h_bios_buffer
#define hunter_bd_cols		bh_vars.h_bd_cols
#define hunter_bd_start		bh_vars.h_bd_start
#define current_mode		bh_vars.hc_mode
#define hunter_chk_mode		bh_vars.h_chk_mode
#define hunter_gfxerr_prt	bh_vars.h_gfxerr_prt

/*
** Functions required by base hunter stuff
*/
#ifdef	ANSI

IMPORT	SHORT	check_inside(USHORT x, USHORT y);
IMPORT	VOID	save_error(int x, int y);
#ifndef	hunter_fopen
IMPORT	int	hunter_getc(FILE *p);
#endif	/* hunter_fopen */

#else	/* ANSI */

IMPORT	SHORT	check_inside();
IMPORT	VOID	save_error();
#ifndef	hunter_fopen
IMPORT	int	hunter_getc();
#endif	/* hunter_fopen */

#endif	/* ANSI */

/*------------------------------------------------------------------------*/

#define HUNTER_TITLE          "SoftPC -- TRAPPER "
#define HUNTER_TITLE_PREV     "SoftPC -- TRAPPER PREVIEW "
#define HUNTER_FLIP_STR       "Flip Screen"
#define HUNTER_DISP_STR       "Display Errors"
#define HUNTER_CONT_STR       "Continue"
#define HUNTER_NEXT_STR       "Next"
#define HUNTER_PREV_STR       "Previous"
#define HUNTER_ABORT_STR      "Abort"
#define HUNTER_ALL_STR        "All"
#define HUNTER_EXIT_STR       "Exit error display"
#define HUNTER_AUTO_ON_STR    "Select box carry On/Off"
#define HUNTER_AUTO_OFF_STR   "Select box delete"
#define HUNTER_DELBOXES_STR   "Delete all boxes"

#define HUNTER_SETTLE_TIME    50        /* about 2.75 secs */
#define HUNTER_SETTLE_NO       5        /* default # of settles before giveup */
#define HUNTER_FUDGE_NO       0      /* default % increase for deltas */
#define HUNTER_START_DELAY   50      /* default additional # of timetix before accepting 1st scancode (about 2.75 secs) */
#define HUNTER_GFXERR_MAX     5      /* default no of grafix errors printed out */
#define HUNTER_TXTERR_MAX     10      /* no of text errors o/p  */
#define HUNTER_FUDGE_NO_ULIM  65535   /* limit made as large as possible */
#define HUNTER_START_DELAY_ULIM 65535 /* for config.c */
#define HUNTER_GFXERR_ULIM   200     /* max no allowed in config.c */
#define HUNTER_SETTLE_NO_ULIM 255     /* as large as possible */
#define IMAGE_ERROR		0
#define REGEN_ERROR		1	/* error type indicators for flipscr */

#define ABORT                 0
#define CONTINUE              1
#define PAUSE                 2
#define PREVIEW               3

#define HUNTER_NEXT			1
#define HUNTER_PREV			2
#define HUNTER_ALL			3
#define HUNTER_EXIT		  	4
 
#define MAX_BOX		     8

#define VIDEO_MODES	      7 /* No of std video modes	 */
#define REQD_REGS	      8 /* MC6845 r0 - r7 */

/* hunter checking equates */
#define HUNTER_SHORT_CHK	0
#define HUNTER_LONG_CHK		1
#define HUNTER_MAX_CHK		2

/* declarations of environment variable variables */

extern half_word hunter_mode;             /* ABORT, PAUSE or CONTINUE */

/* declarations of other globals */

extern boolean   hunter_initialised;  /* TRUE if hunter_init() done */	
extern boolean   hunter_pause;            /* TRUE if PAUSEd */

/* non_check region structure definition */

typedef struct  box_rec {		  
                     boolean    free;
                     boolean    carry;
		     boolean	drawn;
                     USHORT     top_x, top_y;
                     USHORT     bot_x, bot_y;
        	        } BOX;

/* video mode structure definition */
typedef struct mode_rec {
			char	*mnemonic;
			half_word mode_reg;
			half_word R[REQD_REGS];
			} MR;

/*
** Structure for all host functions called from Trapper base functions.
*/

typedef struct
{
#ifdef	ANSI
	/* host initialisation */
	VOID (*init) (half_word hunter_mode);
	
	/* enable/disable menus according to flag */
	VOID (*activate_menus) (BOOL activate);

	/* for flip screen */
	VOID (*flip_indicate) (BOOL sd_file);

	/* for error display */
	VOID (*mark_error) (USHORT x, USHORT y);
	VOID (*wipe_error) (USHORT x, USHORT y);

	/* for RCN menu */
	VOID (*draw_box) (BOX *box);
	VOID (*wipe_box) (BOX *box);

	/* for host image checking - can only be done if data
	** can be read from the host screen
	*/
	ULONG (*check_image) (BOOL initial);
	VOID (*display_image) (BOOL image_swapped);
	VOID (*display_status) (CHAR *message);

#else	/* ANSI */

	/* host initialisation */
	VOID (*init) ();

	/* enable/disable menus according to flag */
	VOID (*activate_menus) ();

	/* for flip screen */
	VOID (*flip_indicate) ();

	/* for error display */
	VOID (*mark_error) ();
	VOID (*wipe_error) ();

	/* for RCN menu */
	VOID (*draw_box) ();
	VOID (*wipe_box) ();

	/* for host image checking - can only be done if data
	** can be read from the host screen
	*/
	ULONG (*check_image) ();
	VOID (*display_image) ();
	VOID (*display_status) ();
#endif	/* ANSI */
}
	HUNTER_HOST_FUNCS;
	
IMPORT	HUNTER_HOST_FUNCS	hunter_host_funcs;

/*
** Macros for calling all the host hunter functions
*/

#define	hh_init(mode)		(hunter_host_funcs.init) (mode)
#define	hh_activate_menus(flag)	(hunter_host_funcs.activate_menus) (flag)
#define	hh_flip_indicate(sd)	(hunter_host_funcs.flip_indicate) (sd)
#define	hh_mark_error(x, y)	(hunter_host_funcs.mark_error) (x, y)
#define	hh_wipe_error(x, y)	(hunter_host_funcs.wipe_error) (x, y)
#define	hh_draw_box(box_ptr)	(hunter_host_funcs.draw_box) (box_ptr)
#define	hh_wipe_box(box_ptr)	(hunter_host_funcs.wipe_box) (box_ptr)
#define	hh_check_image(init)	(hunter_host_funcs.check_image) (init)
#define	hh_display_image(swap)	(hunter_host_funcs.display_image) (swap)
#define	hh_display_status(msg)	(hunter_host_funcs.display_status) (msg)

/*
** Structure for all base Trapper functions which may be called from the
** host.
*/

typedef struct
{
#ifdef	ANSI
	/* Functions called by Trapper menu */
	VOID (*start_screen) (USHORT screen_no);	/* Fast forward */
	VOID (*next_screen) (VOID);
	VOID (*prev_screen) (VOID);
	VOID (*show_screen) (USHORT screen_no, BOOL compare);
	VOID (*continue_trap) (VOID);
	VOID (*abort_trap) (VOID);
	
	/* Functions called by Errors menu */
	VOID (*flip_screen) (VOID);
	VOID (*next_error) (VOID);
	VOID (*prev_error) (VOID);
	VOID (*all_errors) (VOID);
	VOID (*wipe_errors) (VOID);
	
	/* Functions called by RCN menu */
	VOID (*delete_box) (VOID);
	VOID (*carry_box) (VOID);
	
	/* Functions called from mouse event handling */
	VOID (*select_box) (USHORT x, USHORT y);
	VOID (*new_box) (BOX *box);

#else	/* ANSI */

	/* Functions called by Trapper menu */
	VOID (*start_screen) ();	/* Fast forward */
	VOID (*next_screen) ();
	VOID (*prev_screen) ();
	VOID (*show_screen) ();
	VOID (*continue_trap) ();
	VOID (*abort_trap) ();
	
	/* Functions called by Errors menu */
	VOID (*flip_screen) ();
	VOID (*next_error) ();
	VOID (*prev_error) ();
	VOID (*all_errors) ();
	VOID (*wipe_errors) ();
	
	/* Functions called by RCN menu */
	VOID (*delete_box) ();
	VOID (*carry_box) ();
	
	/* Functions called from mouse event handling */
	VOID (*select_box) ();
	VOID (*new_box) ();
#endif	/* ANSI */
}
	HUNTER_BASE_FUNCS;
	
IMPORT	HUNTER_BASE_FUNCS	hunter_base_funcs;

/*
** Macros to access the base functions defined above.
*/

#define	bh_start_screen(scr_no)	(hunter_base_funcs.start_screen) (scr_no)
#define	bh_next_screen()	(hunter_base_funcs.next_screen) ()
#define	bh_prev_screen()	(hunter_base_funcs.prev_screen) ()
#define	bh_show_screen(scr_no, compare) \
		(hunter_base_funcs.show_screen) (scr_no, compare)
#define	bh_continue()		(hunter_base_funcs.continue_trap) ()
#define	bh_abort()		(hunter_base_funcs.abort_trap) ()
#define	bh_flip_screen()	(hunter_base_funcs.flip_screen) ()
#define	bh_next_error()		(hunter_base_funcs.next_error) ()
#define	bh_prev_error()		(hunter_base_funcs.prev_error) ()
#define	bh_all_errors()		(hunter_base_funcs.all_errors) ()
#define	bh_wipe_errors()	(hunter_base_funcs.wipe_errors) ()
#define	bh_delete_box()		(hunter_base_funcs.delete_box) ()
#define	bh_carry_box()		(hunter_base_funcs.carry_box) ()
#define	bh_select_box(x, y)	(hunter_base_funcs.select_box) (x, y)
#define	bh_new_box(box_ptr)	(hunter_base_funcs.new_box) (box_ptr)

/*
** Structure for the display adapter specific functions.
*/

typedef	struct
{
#ifdef	ANSI
	BOOL (*get_sd_rec) (int rec);	/* Unpack a screen dump */
	BOOL (*init_compare) (VOID);	/* Prepare for comparison */
	long (*compare) (int pending);	/* Do a comparison */
	VOID (*bios_check) (VOID);	/* Check the bios area */
	VOID (*pack_screen)(FILE *dmp_ptr);	/* Pack the SoftPC screen */
	BOOL (*getspc_dump)(FILE *dmp_ptr, int rec);	/* Unpk SoftPC screen */
	VOID (*flip_regen) (BOOL swapped);	/* Swap dumped and real scrs */
	VOID (*preview_planes) (VOID);	/* View the dump data in preview mode */

#ifdef	EGG
	VOID (*check_split) (VOID);		/* Check for split screen */
	VOID (*set_line_compare) (int value);	/* Set line compare register */
	int (*get_line_compare) (VOID);		/* Get line compare reg value */
	int (*get_max_scan_lines) (VOID);	/* Get max scan lines value */
#endif	/* EGG */

#else	/* ANSI */

	BOOL (*get_sd_rec) ();		/* Unpack a screen dump */
	BOOL (*init_compare) ();	/* Prepare for comparison */
	long (*compare) ();		/* Do a comparison */
	VOID (*bios_check) ();		/* Check the bios area */
	VOID (*pack_screen)();		/* Pack the SoftPC screen */
	BOOL (*getspc_dump)();		/* Unpk SoftPC screen */
	VOID (*flip_regen) ();		/* Swap the dumped and real screen */
	VOID (*preview_planes) ();	/* View the dump data in preview mode */

#ifdef	EGG
	VOID (*check_split) ();		/* Check for split screen */
	VOID (*set_line_compare) ();	/* Set line compare register */
	int (*get_line_compare) ();	/* Get line compare reg value */
	int (*get_max_scan_lines) ();	/* Get max scan lines value */
#endif	/* EGG */

#endif	/* ANSI	*/
}
	HUNTER_VIDEO_FUNCS;

IMPORT	HUNTER_VIDEO_FUNCS	*hv_funcs;

/*
** Macros to access the hunter video functions
*/
#define	hv_get_sd_rec(rec)		(hv_funcs->get_sd_rec)(rec)
#define	hv_init_compare()		(hv_funcs->init_compare)()
#define	hv_compare(pending)		(hv_funcs->compare)(pending)
#define	hv_bios_check()			(hv_funcs->bios_check)()
#define	hv_pack_screen(file_ptr)	(hv_funcs->pack_screen)(file_ptr)
#define	hv_getspc_dump(file_ptr, rec)	(hv_funcs->getspc_dump)(file_ptr, rec)
#define	hv_flip_regen(swapped)		(hv_funcs->flip_regen)(swapped)
#define hv_preview_planes()		(hv_funcs->preview_planes)()

#ifdef	EGG
#define	hv_check_split()		(hv_funcs->check_split)()
#define	hv_set_line_compare(value)	(hv_funcs->set_line_compare)(value)
#define	hv_get_line_compare()		(hv_funcs->get_line_compare)()
#define	hv_get_max_scan_lines()		(hv_funcs->get_max_scan_lines)()
#endif	/* EGG */
	
/* Macros for printfs. TTn for information; TEn for errors; TWn for warnings.
** Note - these macros have been designed to "swallow the semicolon" and
** evaluate as a single expression so it's quite ok to write the following
** code:
**		if (something)
**			TT0("dfhjjgjf");
**		else
**			TE0("gfdg");
*/

#define PS0(s)			fprintf(trace_file, s)
#define	PS1(s, a1)		fprintf(trace_file, s, a1)
#define	PS2(s, a1, a2)		fprintf(trace_file, s, a1, a2)
#define	PS3(s, a1, a2, a3)	fprintf(trace_file, s, a1, a2, a3)
#define	PS4(s, a1, a2, a3, a4)	fprintf(trace_file, s, a1, a2, a3, a4)
#define	PS5(s, a1, a2, a3, a4, a5)	\
				fprintf(trace_file, s, a1, a2, a3, a4, a5)
#define	PS6(s, a1, a2, a3, a4, a5, a6)	\
				fprintf(trace_file, s, a1, a2, a3, a4, a5, a6)
#define	PS7(s, a1, a2, a3, a4, a5, a6, a7)		\
				fprintf(trace_file,	\
					s, a1, a2, a3, a4, a5, a6, a7)
#define	PS8(s, a1, a2, a3, a4, a5, a6, a7, a8)		\
				fprintf(trace_file,	\
					s, a1, a2, a3, a4, a5, a6, a7, a8)
#ifndef	newline
#define	newline			PS0("\n")
#endif	/* newline */

#define	TP0(is, s)		(VOID)(					\
				PS0(is),				\
				PS0(s),					\
				newline					\
				)
#define	TP1(is, s, a1)		(VOID)(					\
				PS0(is),				\
				PS1(s, a1),				\
				newline					\
				)
#define	TP2(is, s, a1, a2)	(VOID)(					\
				PS0(is),				\
				PS2(s, a1, a2),				\
				newline					\
				)
#define	TP3(is, s, a1, a2, a3)	(VOID)(					\
				PS0(is),				\
				PS3(s, a1, a2, a3),			\
				newline					\
				)
#define	TP4(is, s, a1, a2, a3, a4)					\
				(VOID)(					\
				PS0(is),				\
				PS4(s, a1, a2, a3, a4),			\
				newline					\
				)
#define	TP5(is, s, a1, a2, a3, a4, a5)					\
				(VOID)(					\
				PS0(is),				\
				PS5(s, a1, a2, a3, a4, a5),		\
				newline					\
				)
#define	TP6(is, s, a1, a2, a3, a4, a5, a6)				\
				(VOID)(					\
				PS0(is),				\
				PS6(s, a1, a2, a3, a4, a5, a6),		\
				newline					\
				)
#define	TP7(is, s, a1, a2, a3, a4, a5, a6, a7)				\
				(VOID)(					\
				PS0(is),				\
				PS7(s, a1, a2, a3, a4, a5, a6, a7),	\
				newline					\
				)
#define	TP8(is, s, a1, a2, a3, a4, a5, a6, a7, a8)			\
				(VOID)(					\
				PS0(is),				\
				PS8(s, a1, a2, a3, a4, a5, a6, a7, a8),	\
				newline					\
				)

#define	TT0(s)			TP0("TRAPPER: ", s)
#define	TT1(s, a1)		TP1("TRAPPER: ", s, a1)
#define	TT2(s, a1, a2)		TP2("TRAPPER: ", s, a1, a2)
#define	TT3(s, a1, a2, a3)	TP3("TRAPPER: ", s, a1, a2, a3)
#define	TT4(s, a1, a2, a3, a4)	TP4("TRAPPER: ", s, a1, a2, a3, a4)
#define	TT5(s, a1, a2, a3, a4, a5)	\
				TP5("TRAPPER: ", s, a1, a2, a3, a4, a5)
#define	TT6(s, a1, a2, a3, a4, a5, a6)	\
				TP6("TRAPPER: ", s, a1, a2, a3, a4, a5, a6)
#define	TT7(s, a1, a2, a3, a4, a5, a6, a7)	\
				TP7("TRAPPER: ", s, a1, a2, a3, a4, a5, a6, a7)
#define	TT8(s, a1, a2, a3, a4, a5, a6, a7, a8)		\
				TP8("TRAPPER: ",	\
				s, a1, a2, a3, a4, a5, a6, a7, a8)

#define	TE0(s)			TP0("TRAPPER error: ", s)
#define	TE1(s, a1)		TP1("TRAPPER error: ", s, a1)
#define	TE2(s, a1, a2)		TP2("TRAPPER error: ", s, a1, a2)
#define	TE3(s, a1, a2, a3)	TP3("TRAPPER error: ", s, a1, a2, a3)
#define	TE4(s, a1, a2, a3, a4)	TP4("TRAPPER error: ", s, a1, a2, a3, a4)
#define	TE5(s, a1, a2, a3, a4, a5)	\
				TP5("TRAPPER error: ", s, a1, a2, a3, a4, a5)
#define	TE6(s, a1, a2, a3, a4, a5, a6)	\
				TP6("TRAPPER error: ", s, a1, a2, a3, a4, a5, a6)
#define	TE7(s, a1, a2, a3, a4, a5, a6, a7)		\
				TP7("TRAPPER error: ",	\
				s, a1, a2, a3, a4, a5, a6, a7)
#define	TE8(s, a1, a2, a3, a4, a5, a6, a7, a8)		\
				TP8("TRAPPER error: ",	\
				s, a1, a2, a3, a4, a5, a6, a7, a8)

#define	TW0(s)			TP0("TRAPPER warning: ", s)
#define	TW1(s, a1)		TP1("TRAPPER warning: ", s, a1)
#define	TW2(s, a1, a2)		TP2("TRAPPER warning: ", s, a1, a2)
#define	TW3(s, a1, a2, a3)	TP3("TRAPPER warning: ", s, a1, a2, a3)
#define	TW4(s, a1, a2, a3, a4)	TP4("TRAPPER warning: ", s, a1, a2, a3, a4)
#define	TW5(s, a1, a2, a3, a4, a5)	\
				TP5("TRAPPER warning: ", s, a1, a2, a3, a4, a5)
#define	TW6(s, a1, a2, a3, a4, a5, a6)					\
				TP6("TRAPPER warning: ",		\
				s, a1, a2, a3, a4, a5, a6)
#define	TW7(s, a1, a2, a3, a4, a5, a6, a7)				\
				TP7("TRAPPER warning: ",		\
				s, a1, a2, a3, a4, a5, a6, a7)
#define	TW8(s, a1, a2, a3, a4, a5, a6, a7, a8)				\
				TP8("TRAPPER warning: ",		\
				s, a1, a2, a3, a4, a5, a6, a7, a8)
/*
 * ============================================================================
 * Function definitions
 * ============================================================================
 */

/* function in keybd_io, only called by hunter */
extern int bios_buffer_size();

/* function in keyba, only called by hunter */
extern int buffer_status_8042();

/* functions in hunter called from reset, timer */
extern void hunter_init();
extern void do_hunter();

#endif	/* HUNTER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\jcgensyn.h ===
# define NAME 257
# define STRING 258
# define CONSTANT 259
# define DIGEST 260
# define OPSUB0 261
# define OPSUB1 262
# define OPSUB2 263
# define LSQUARE 264
# define RSQUARE 265
# define OR 266
# define COMMA 267
# define ARROW 268
# define LCURL 269
# define RCURL 270
# define LBRACKET 271
# define RBRACKET 272
# define SEMICOLON 273
# define LANGLE 274
# define RANGLE 275
# define COLON 276
# define STAR 277
# define DOT 278
# define INVALID 279
# define MODENAME 280
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\ipx.h ===
/*[
 *	Product:		SoftPC-AT Revision 3.0
 *	Name:			ipx.h
 *	Derived From:	Original
 *	Author:			Jase
 *	Created On:		Oct 6 1992
 *	Sccs ID:		12/11/92 @(#)ipx.h	1.5
 *	Purpose:		Base defines & typedefs for IPX implementations.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
 *
 *	Rcs ID:			
 *			$Source: /masterNeXT3.0/host/inc/RCS/next_novell.h,v $
 *			$Revision: 1.2 $
 *			$Date: 92/10/15 14:37:48 $
 *			$Author: jason $
 ]*/

/* DEFINES */

/* IPX device file */
#define		sIPXDevice						"/dev/ipx"

/* IPX function selector codes */
#define		kIPXOpenSocket					0x00
#define		kIPXCloseSocket					0x01
#define		kIPXGetLocalTarget				0x02
#define		kIPXSendPacket					0x03
#define		kIPXListenForPacket				0x04
#define		kIPXScheduleEvent				0x05
#define		kIPXCancelEvent					0x06
/* note missing 0x07 selector */
#define		kIPXGetIntervalMarker			0x08
#define		kIPXGetInternetAddress			0x09
#define		kIPXRelinquishControl			0x0a
#define		kIPXDisconnectFromTarget		0x0b

/* SPX function selector codes */
#define		kSPXInitialize					0x10
#define		kSPXEstablishConnection			0x11
#define		kSPXListenForConnection			0x12
#define		kSPXTerminateConnection			0x13
#define		kSPXAbortConnection				0x14
#define		kSPXGetConnectionStatus			0x15
#define		kSPXSendSequencedPacket			0x16
#define		kSPXListenForSequencedPacket	0x17

/* selector code bounds */
#define		kMinSelector					0x00
#define		kMaxSelector					0x17

/* in-use codes */
#define		kAvailable						0x00
#define		kCounting						0xfd
#define		kListening						0xfe
#define		kSending						0xff

/* completion codes */
#define		kSuccess						0x00
#define		kWatchdogTerminate				0xed
#define		kNoPathFound					0xfa
#define		kEventCancelled					0xfc
#define		kPacketOverflow					0xfd
#define		kSocketTableFull				0xfe
#define		kNotInUse						0xff
#define		kSocketAlreadyOpen				0xff
#define		kNoSuchSocket					0xff

/* number of open sockets we support */
/* currently at IPX maximum */
#define		kMaxOpenSockets					150

/* maximum size of IPX packet */
#define		kMaxPacketSize					576

/* packet buffer size */
#define		kPacketBufferSize				1536

/* maximum NCP data size - for IPXGetBufferSize function */
#define		kMaxNCPDataSize					1024

/* size of IPX header */
#define		kHeaderSize						30

/* event types */
#define		kNoEvent						0
#define		kIPXEvent						1
#define		kAESEvent						2

/********************************************************/

/* TYPEDEFS */

/* IPX structures */

typedef struct
{
	USHORT			packetChecksum;
	USHORT			packetLength;
	UTINY			packetControl;
	UTINY			packetType;
	UTINY			packetDestNet [4];
	UTINY			packetDestNode [6];
	UTINY			packetDestSock [2];
	UTINY			packetSrcNet [4];
	UTINY			packetSrcNode [6];
	UTINY			packetSrcSock [2];

} IPXHeaderRec;

typedef struct
{
	UTINY			net [4];
	UTINY			node [6];
	UTINY			sock [2];

} IPXAddressRec;

/* DOS ECB record (from NetWare DOS Programmers Guide) */
typedef struct ECB
{
	sys_addr		ecbLinkAddress;
	UTINY			ecbESRAddress [4];
	UTINY			ecbInUseFlag;
	UTINY			ecbCompletionCode;
	USHORT			ecbSocketNumber;
	UTINY			ecbIPXWorkspace [4];
	UTINY			ecbDriverWorkspace [12];
	UTINY			ecbImmediateAddress [6];
	USHORT			ecbFragmentCount;
	UTINY			ecbFragmentAddress1 [4];
	USHORT			ecbFragmentSize1;
	UTINY			ecbFragmentAddress2 [4];
	USHORT			ecbFragmentSize2;

} ECBRec;

/* host IPX implementation structures */

typedef struct
{
	int				socketFD;
	USHORT			socketNumber;
	BOOL			socketTransient;

} SocketRec;

/* linked-list of IPX or AES events */
typedef struct Event
{
	struct Event	*eventNext;
	struct Event	*eventPrev;
	UTINY			eventType;
	sys_addr		eventECB;
	SocketRec		*eventSocket;
	USHORT			eventClock;

} EventRec;

typedef struct
{
	BOOL			ipxInitialised;
	USHORT			ipxSelector;
	USHORT			ipxClock;
	UTINY			ipxNetwork [4];
	UTINY			ipxNode [6];
	UTINY			ipxBuffer [kPacketBufferSize];
	SocketRec		ipxSockets [kMaxOpenSockets];
	EventRec		*ipxQueue;
	EventRec		*ipxEvent;

} IPXGlobalRec;

/********************************************************/

/* PROTOTYPES */

/* imports */

/* dispatchers */
IMPORT VOID			IPXBop IPT0 ();
IMPORT VOID			IPXHost IPT0 ();

/* host interface stuff */
IMPORT BOOL			host_ipx_init IPT0 ();

IMPORT VOID			host_ipx_tick IPT0 ();

IMPORT VOID			host_ipx_raise_exception IPT0 ();

IMPORT BOOL			host_ipx_open_socket IPT1 (SocketRec *, socket);
IMPORT VOID			host_ipx_close_socket IPT1 (SocketRec *, socket);

IMPORT VOID			host_ipx_send_packet IPT1 (SocketRec *, socket);
IMPORT BOOL			host_ipx_poll_socket IPT1 (SocketRec *, socket);

IMPORT VOID			host_ipx_load_packet IPT2
	(SocketRec *, socket, sys_addr, ecbAddress);
IMPORT BOOL			host_ipx_save_packet IPT2
	(SocketRec *, socket, sys_addr, ecbAddress);

IMPORT BOOL			host_ipx_rip_query IPT1 (IPXAddressRec *, ipxAddr);

/* base stuff accessed from host */

IMPORT EventRec 	*FindEvent IPT3
	(UTINY, linkType, sys_addr, ecbAddress, SocketRec *, linkSocket);

/********************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\j_c_lang.h ===
/*
 *      Name:           j_c_lang.h
 *
 *      Author:         Simon Frost
 *
 *      Created on:     February 1994
 *
 *      SccsID:         @(#)j_c_lang.h	1.2 08/19/94
 *
 *      Purpose:        This file contains the necessary declarations for C
 *                      files generated from J-code.
 *
 *      (c)Copyright Insignia Solutions Ltd., 1994. All rights reserved.
 */
/* defines needed for basic types */
#define	jccc_parm1 r2 
#define	jccc_parm2 r3 
#define	jccc_parm3 r4 
#define	jccc_parm4 r5 
#define	jccc_gdp r1 
/* define variables (register replacements) used */
extern IUH	rnull ; /* holder for a null arg in calls and null return args */
extern IUH	r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10,r11,r12,r13,r14,r15,
		r16,r17,r18,r19,r20,r21,r22,r23,r24,r25,r26,r27,r28,r29,r30,r31;

/* prototypes for support functions - see j_c_lang.c ? how many are used */
extern IUH mask IPT2(IUH, bitpos, IUH, len);
extern IUH rorl IPT2(IUH, src, IUH, rots);
extern IUH rorw IPT2(IUH, src, IUH, rots);
extern IUH rorb IPT2(IUH, src, IUH, rots);
extern IUH roll IPT2(IUH, src, IUH, rots);
extern IUH rolw IPT2(IUH, src, IUH, rots);
extern IUH rolb IPT2(IUH, src, IUH, rots);

#ifdef LITTLEND
#define	UOFF_15_8(a)	(((IU8 *)(a))+1)
#define	SOFF_15_8(a)	(((IS8 *)(a))+1)
#define	REGBYTE		0
#define	REGWORD		0
#define	REGLONG		0
#endif
#ifdef BIGEND
#define UOFF_15_8(a)	((IU8 *)(a) + sizeof(IUH)-2)
#define SOFF_15_8(a)	((IS8 *)(a) + sizeof(IUH)-2)
#define	REGBYTE		(sizeof(IUH) -1)
#define	REGWORD		(sizeof(IUH)/2 -1)
#define	REGLONG		(sizeof(IUH)/4 -1)
#endif
#define __J_C_LANG	/* mark as already included */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\keycaps.h ===
/*[
	Name:		IBMKeyCaps.h
	Derived From:	New Development
	Author:		gvdl
	Created On:	31 July 1991
	Sccs ID:	08/10/92 @(#)keycaps.h	1.3
	Purpose:	Table of all keycaps indexed by matrix code.

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

#ifdef UIF_TEST

#define MISSING_KEY ((UTINY) 0x01)
#define BAD_DOWN    ((UTINY) 0x02)
#define BAD_UP      ((UTINY) 0x04)
#define DUP_KEY     ((UTINY) 0x08)

LOCAL CHAR *keycaps[] =
{
	"",
	"`",
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9",
	"0",
	"-",
	"=",
	"",
	"Backspace",
	"Tab",
	"q",
	"w",
	"e",
	"r",
	"t",
	"y",
	"u",
	"i",
	"o",
	"p",
	"[",
	"]",
	"\\",
	"Caps",
	"a",
	"s",
	"d",
	"f",
	"g",
	"h",
	"j",
	"k",
	"l",
	";",
	"'",
	"102 1/2Ret",
	"Return",
	"ShiftL",
	"102 1/2ShL",
	"z",
	"x",
	"c",
	"v",
	"b",
	"n",
	"m",
	",",
	".",
	"/",
	"",
	"ShiftR",
	"CntrlL",
	"",
	"AltL",
	"Space",
	"AltR",
	"",
	"CntrlR",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"",
	"Insert",
	"Delete",
	"",
	"",
	"Left",
	"Home",
	"End",
	"",
	"Up",
	"Down",
	"PgUp",
	"PgDn",
	"",
	"",
	"Right",
	"Num",
	"kp7",
	"kp4",
	"kp1",
	"",
	"kp/",
	"kp8",
	"kp5",
	"kp2",
	"kp0",
	"kp*",
	"kp9",
	"kp6",
	"kp3",
	"kp.",
	"kp-",
	"kp+",
	"",
	"kpEnter",
	"",
	"Esc",
	"",
	"F01",
	"F02",
	"F03",
	"F04",
	"F05",
	"F06",
	"F07",
	"F08",
	"F09",
	"F10",
	"F11",
	"F12",
	"PrtScr",
	"Scroll",
	"Pause",
};

#endif /* UIF_TEST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\ios.h ===
/*
 * SoftPC-AT Version 2.0
 *
 * Title        : I/O Address Space definitions
 *
 * Description  : Definitions for users of the I/O Address Space Module
 *
 * Author       : Rod MacGregor (bless his cotton socks)
 *
 * Notes        : None
 */

/* SccsID[]= @(#)ios.h  1.25 09 Feb 1995 */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/* Size of i/o memory array in half-words */

#if defined( NTVDM ) || defined ( GISP_SVGA ) || defined ( SFELLOW )
#define PC_IO_MEM_SIZE  0x10000 /* Must be a power of two! */
#else
#define PC_IO_MEM_SIZE  0x400   /* Must be a power of two! */
#endif

#ifdef NTVDM
typedef struct _extioentry {
    io_addr ioaddr;
    char    iadapter;
    struct _extioentry *ioextnext;
} ExtIoEntry, *PExtIoEntry;
#endif /* NTVDM */


#if defined(NEC_98)
/*
 * AT Keyboard adapter
 */

#define KEYBA_PORT_START        0x60
#define KEYBA_PORT_END          0x6e

#define KEYBA_IO_BUFFERS        0x60
#define KEYBA_STATUS_CMD        0x64

/*
 * The diskette IO address range
 */

#define FLOPPY_1MB_PORT_START           0x90
#define FLOPPY_1MB_PORT_END             0x9E
#define FLOPPY_640KB_PORT_START         0xC8
#define FLOPPY_640KB_PORT_END           0xCE
#define FLOPPY_1MB_640KB_PORT_START     0xBE
#define FLOPPY_1MB_640KB_PORT_END       0xBE

/*
 * The supported diskette IO addresses
 */

#define READ_STATUS_REG_1MB     0x90
#define WRITE_CMD_REG_1MB       0x92
#define READ_DATA_1MB           0x92
#define READ_STATUS_REG_640KB   0xC8
#define WRITE_CMD_REG_640KB     0xCA
#define READ_DATA_640KB         0xCA
#define MODE_CHG_1MB_640KB      0xBE

/*
 * The hard disk IO address range  This is not "SCSI".
 */

#define HD_PORT_START           0x80
#define HD_PORT_END             0x82

/* The addresses of the four ports assigned to the HDA. */

#define HD_ODR                  0x80
#define HD_IDR                  0x80
#define HD_OCR                  0x82
#define HD_ISR                  0x82

/*
 * PC-98 Keyboard adapter
 */

#define KEYBD_PORT_START        0x41
#define KEYBD_PORT_END          0x4F

#define KEYBD_DATA_READ         0x41
#define KEYBD_STATUS_CMD        0x43

/*
 * Calendar and Clock - Changed from RTC & CMOS.
 */
#define CALENDAR_PORT_START     0x20
#define CALENDAR_PORT_END       0x2E

#define CALENDAR_SET_REG        0x20

/*
 * System Port - Only PC-9800.
 */
#define SYSTEM_PORT_START       0x31
#define SYSTEM_PORT_END         0x3F

#define SYSTEM_READ_PORT_A      0x31
#define SYSTEM_READ_PORT_B      0x33
#define SYSTEM_READ_PORT_C      0x35
#define SYSTEM_WRITE_PORT_C     0x35
#define SYSTEM_WRITE_MODE       0x37

/*
 * Timer adapter -
 * Only (N-mode)Counter-1 differs port address from Counter-0 & 2.
 */

#define TIMER_PORT_START        0x71
#define TIMER_PORT_END          0x7F

#define TIMER0_REG              0x71
#define TIMER1_REG              0x73
#define TIMER2_REG              0x75
#define TIMER_MODE_REG          0x77

/*
 * DMA registers
 */

/* DMA controller I/0 space ranges */
#define DMA_PORT_START          0x01
#define DMA_PORT_END            0x1F

/* DMA controller address registers */
#define DMA_CH0_ADDRESS         0x01
#define DMA_CH0_COUNT           0x03
#define DMA_CH1_ADDRESS         0x05
#define DMA_CH1_COUNT           0x07
#define DMA_CH2_ADDRESS         0x09
#define DMA_CH2_COUNT           0x0B
#define DMA_CH3_ADDRESS         0x0D
#define DMA_CH3_COUNT           0x0F

/* DMA controller miscellaneous registers */
#define DMA_SHARED_REG_A                0x11
#define DMA_WRITE_REQUEST_REG           0x13
#define DMA_WRITE_ONE_MASK_BIT          0x15
#define DMA_WRITE_MODE_REG              0x17
#define DMA_CLEAR_FLIP_FLOP             0x19
#define DMA_SHARED_REG_B                0x1B
#define DMA_CLEAR_MASK                  0x1D
#define DMA_WRITE_ALL_MASK_BITS         0x1F

/* DMA bank register I/O space range */
#define DMA_PAGE_PORT_START             0x21
#define DMA_PAGE_PORT_END               0x29

/* DMA bank registers */
#define DMA_CH0_PAGE_REG                0x27
#define DMA_CH1_PAGE_REG                0x21
#define DMA_CH2_PAGE_REG                0x23
#define DMA_CH3_PAGE_REG                0x25
#define DMA_MODE_REG                    0x29

/*
 * Interrupt Control Registers
 */
#define ICA0_PORT_START         0x00
#define ICA0_PORT_END           0x02

#define ICA0_PORT_0             0x00
#define ICA0_PORT_1             0x02

#define ICA1_PORT_START         0x08
#define ICA1_PORT_END           0x0A

#define ICA1_PORT_0             0x08
#define ICA1_PORT_1             0x0A

/*
 * RS232 Adaptors
 */
#define RS232_COM1_PORT_START           0x30
#define RS232_COM1_PORT_END             0x3E
#define RS232_COM2_PORT_START           0xB0
#define RS232_COM2_PORT_END             0xB3
#define RS232_COM3_PORT_START           0xB2
#define RS232_COM3_PORT_END             0xBB

/*
 * Parallel printer adaptors
 */
#ifdef  PRINTER
#define LPT1_PORT_START         0x40
#define LPT1_PORT_END           0x4E
#endif  /* PRINTER */

/*
 * Line Counter Only PC-9800
 */
#define LINE_COUNTER_PORT_START         0x70
#define LINE_COUNTER_PORT_END           0x7A

/*
 * GRCG (Graphics Charger)
 */

#define GRCG_NORMAL_PORT_START          0x7C
#define GRCG_NORMAL_PORT_END            0x7E
#define GRCG_HIRESO_PORT_START          0xA4
#define GRCG_HIRESO_PORT_END            0xA6

/*
 * GDC (Graphic Display Controler)
 */
#define TEXT_GDC_PORT_START             0x60
#define TEXT_GDC_PORT_END               0x6E
#define GRAPH_GDC_PORT_START            0xA0
#define GRAPH_GDC_PORT_END              0xAE

/*
 * EGC (Enhanced Graphics Charger)
 */
#define EGC_PORT_START          0x4A0
#define EGC_PORT_END            0x4AE

/*
 * CG ROM
 */
#define CG_ROM_PORT_START       0xA1
#define CG_ROM_PORT_END         0xAF

/*
 * NMI Controller
 */
#define NMIC_PORT_START         0x50
#define NMIC_PORT_END           0x5E

/*
 * MOUSE CONTROLLER
 */
#define MOUSE_NMODE_PORT_START          0x7FD9
#define MOUSE_NMODE_PORT_END            0x7FDF

#define MOUSE_HMODE_PORT_START          0x61
#define MOUSE_HMODE_PORT_END            0x6F

#define CPU_PORT_START                  0xF0
#define CPU_PORT_END                    0xF6

/*
 * The following defines a key for each adaptor.  This is used as a
 * parameter to the io_connect_port() function.
 */
#define EMPTY_ADAPTOR           0
#define ICA0_ADAPTOR            1
#define DMA_ADAPTOR             2
#define ICA1_ADAPTOR            3
#define TIMER_ADAPTOR           4
#define NMI_ADAPTOR             5
#define HDA_ADAPTOR             6
#define FLOPPY_1MB_ADAPTOR      7
#define FLOPPY_640KB_ADAPTOR    8
#define FLOPPY_1MB_640KB        9
#define COM1_ADAPTOR            10
#define DMA_PAGE_ADAPTOR        11
#define MOUSE_ADAPTOR           12
#define CALENDAR_ADAPTOR        13
#define SYSTEM_PORT             14
#define TEXT_GDC_ADAPTOR        15
#define CG_ADAPTOR              16
#define LINE_COUNTER            17
#define GRAPHIC_ADAPTOR         18
#define GRCG                    19
#define EGC                     20
#define KEYB_ADAPTOR            21
#ifdef PRINTER
#define LPT1_ADAPTER            22
#endif
#define COM2_ADAPTOR            23
#define COM3_ADAPTOR            24
#define CPU_PORT                25
#define CALENDER_PORT           26

#define SPARE_ADAPTER1          27
#define SPARE_ADAPTER2          28
#define SPARE_ADAPTER3          29
#define SPARE_ADAPTER4          30
#define SPARE_ADAPTER5          31
#define SPARE_ADAPTER6          32
#define SPARE_ADAPTER7          33
#define SPARE_ADAPTER8          34

#define IO_MAX_NUMBER_ADAPTORS  35
#define NUMBER_SPARE_ADAPTERS   (SPARE_ADAPTER8 - SPARE_ADAPTER1)

#else  // !NEC_98
/*
 * The IO address range for the Monochrome Display Adapter.
 */

#define MDA_PORT_START          0x3B0
#define MDA_PORT_END            0x3BF


#ifdef HERC
#define HERC_PORT_START         0x3B0
#define HERC_PORT_END           0x3BF
#endif

/*
 * Memory bounds for the colour graphics adaptor
 */

#define CGA_PORT_START          0x3D0
#define CGA_PORT_END            0x3DF

/*
 * The individual enhanced adaptor registers
 */

#define EGA_SEQ_INDEX           0x3C4
#define EGA_SEQ_DATA            0x3C5
#define EGA_CRTC_INDEX          0x3D4
#define EGA_CRTC_DATA           0x3D5
#define EGA_GC_INDEX            0x3CE
#define EGA_GC_DATA             0x3CF
#define EGA_GC_POS1             0x3CC
#define EGA_GC_POS2             0x3CA
#define EGA_AC_INDEX_DATA       0x3C0
#define EGA_AC_SECRET           0x3C1           /* mentioned in "programmer's guide to pc & ps/2 video systems" p36 tip */
#define EGA_MISC_REG            0x3C2
#define EGA_FEAT_REG            0x3DA
#define EGA_IPSTAT0_REG         0x3C2
#define EGA_IPSTAT1_REG         0x3DA
#define VGA_MISC_READ_REG       0x3CC
#define VGA_FEAT_READ_REG       0x3CA

/*
 * Extra registers in VGA for controlling the DAC
 */

#ifdef VGG
#define VGA_DAC_MASK            0x3C6
#define VGA_DAC_RADDR           0x3C7   /* Address for reads */
#define VGA_DAC_WADDR           0x3C8   /* Address for writes */
#define VGA_DAC_DATA            0x3C9   /* DAC data */
#endif

/*
 * The individual colour adaptor registers
 */

#define CGA_INDEX_REG           0x3D4
#define CGA_DATA_REG            0x3D5
#define CGA_CONTROL_REG         0x3D8
#define CGA_COLOUR_REG          0x3D9
#define CGA_STATUS_REG          0x3DA

/*
 * Internal colour adaptor registers, accessed via data/index registers
 */

#define CGA_R14_CURS_ADDRH      0xE
#define CGA_R15_CURS_ADDRL      0xF

/*
 * The diskette IO address range
 */

#define DISKETTE_PORT_START     0x3F0
#define DISKETTE_PORT_END       0x3F7

/*
 * The supported diskette IO addresses
 */

#define DISKETTE_ID_REG         0x3f1
#define DISKETTE_DOR_REG        0x3F2
#define DISKETTE_STATUS_REG     0x3F4
#define DISKETTE_DATA_REG       0x3F5
#define DISKETTE_FDISK_REG      0x3f6
#define DISKETTE_DIR_REG        0x3f7
#define DISKETTE_DCR_REG        0x3f7


/*
 * The hard disk IO address range
 */

#define DISK_PORT_START         0x1F0
#define DISK_PORT_END           0x1F8

/* The addresses of the four ports assigned to the HDA. */

#define HD_PORT_0               0x320
#define HD_PORT_1               0x321
#define HD_PORT_2               0x322
#define HD_PORT_3               0x323


/*
 * PPI adapter
 */
/* On the AT, PPI_GENERAL is like the combination of
 * PPI_GENERAL and PPI_SWITCHES on the XT. All the switch
 * information is in the AT CMOS RAM ports 70-7f
 */
#define PPI_PORT_START          0x60
#define PPI_PORT_END            0x6f

#define PPI_KEYBOARD            0x60
#define PPI_GENERAL             0x61
#define PPI_SWITCHES            0x62

/*
 * AT Keyboard adapter
 */

#define KEYBA_PORT_START        0x60
#define KEYBA_PORT_END          0x6e

#define KEYBA_IO_BUFFERS        0x60
#define KEYBA_STATUS_CMD        0x64

/*
 * CMOS and Real Time Clock
 */
/*
 * These are defined in cmos.h
 *
#define CMOS_PORT_START         0x70
#define CMOS_PORT_END           0x7f

#define CMOS_PORT               0x70
#define CMOS_DATA               0x71
 */

/*
 * Timer adapter
 */

#define TIMER_PORT_START        0x40
#define TIMER_PORT_END          0x5F

#define TIMER0_REG              0x40
#define TIMER1_REG              0x41
#define TIMER2_REG              0x42
#define TIMER_MODE_REG          0x43

/*
 * DMA registers
 */

/* DMA controller I/0 space ranges */
#define DMA_PORT_START          0x00
#define DMA_PORT_END            0x1F

#define DMA1_PORT_START         0xC0
#define DMA1_PORT_END           0xDF

/* DMA controller address registers */
#define DMA_CH0_ADDRESS         0x00
#define DMA_CH0_COUNT           0x01
#define DMA_CH1_ADDRESS         0x02
#define DMA_CH1_COUNT           0x03
#define DMA_CH2_ADDRESS         0x04
#define DMA_CH2_COUNT           0x05
#define DMA_CH3_ADDRESS         0x06
#define DMA_CH3_COUNT           0x07

#define DMA_CH4_ADDRESS         0xC0
#define DMA_CH4_COUNT           0xC2
#define DMA_CH5_ADDRESS         0xC4
#define DMA_CH5_COUNT           0xC6
#define DMA_CH6_ADDRESS         0xC8
#define DMA_CH6_COUNT           0xCA
#define DMA_CH7_ADDRESS         0xCC
#define DMA_CH7_COUNT           0xCE

/* DMA controller miscellaneous registers */
#define DMA_SHARED_REG_A        0x08
#define DMA_WRITE_REQUEST_REG   0x09
#define DMA_WRITE_ONE_MASK_BIT  0x0A
#define DMA_WRITE_MODE_REG      0x0B
#define DMA_CLEAR_FLIP_FLOP     0x0C
#define DMA_SHARED_REG_B        0x0D
#define DMA_CLEAR_MASK          0x0E
#define DMA_WRITE_ALL_MASK_BITS 0x0F

#define DMA1_SHARED_REG_A       0xD0
#define DMA1_WRITE_REQUEST_REG  0xD2
#define DMA1_WRITE_ONE_MASK_BIT 0xD4
#define DMA1_WRITE_MODE_REG     0xD6
#define DMA1_CLEAR_FLIP_FLOP    0xD8
#define DMA1_SHARED_REG_B       0xDA
#define DMA1_CLEAR_MASK         0xDC
#define DMA1_WRITE_ALL_MASK_BITS        0xDE

/* DMA page register I/O space range */
#define DMA_PAGE_PORT_START     0x80
#define DMA_PAGE_PORT_END       0x9F

/* DMA page registers */
#define DMA_CH0_PAGE_REG        0x87
#define DMA_CH1_PAGE_REG        0x83
#define DMA_FLA_PAGE_REG        0x81
#define DMA_HDA_PAGE_REG        0x82
#define DMA_CH5_PAGE_REG        0x8b
#define DMA_CH6_PAGE_REG        0x89
#define DMA_CH7_PAGE_REG        0x8a
#define DMA_REFRESH_PAGE_REG    0x8f
#define MFG_PORT        0x80
#define DMA_FAKE1_REG   0x84
#define DMA_FAKE2_REG   0x85
#define DMA_FAKE3_REG   0x86
#define DMA_FAKE4_REG   0x88
#define DMA_FAKE5_REG   0x8c
#define DMA_FAKE6_REG   0x8d
#define DMA_FAKE7_REG   0x8e

/*
 * Interrupt Control Registers
 */

#    define ICA0_PORT_START     0x20
#    define ICA0_PORT_END       0x3F

#    define ICA0_PORT_0         0x20
#    define ICA0_PORT_1         0x21

#    define ICA1_PORT_START     0xA0
#    define ICA1_PORT_END       0xBF

#    define ICA1_PORT_0         0xA0
#    define ICA1_PORT_1         0xA1

/*
 * RS232 Adaptors
 */

#define RS232_COM1_PORT_START   0x3F8
#define RS232_COM1_PORT_END     0x3FF
#define RS232_COM2_PORT_START   0x2F8
#define RS232_COM2_PORT_END     0x2FF
#define RS232_COM3_PORT_START   0x3e8
#define RS232_COM3_PORT_END     0x3eF
#define RS232_COM4_PORT_START   0x2e8
#define RS232_COM4_PORT_END     0x2eF
#define RS232_PRI_PORT_START    0x3F8
#define RS232_PRI_PORT_END      0x3FF
#define RS232_SEC_PORT_START    0x2F8
#define RS232_SEC_PORT_END      0x2FF

/*
 * Parallel printer adaptors
 */

#ifdef  PRINTER
#define LPT1_PORT_START         0x3bc
#define LPT1_PORT_END           0x3c0
#define LPT2_PORT_START         0x378
#define LPT2_PORT_END           0x37c
#define LPT3_PORT_START         0x278
#define LPT3_PORT_END           0x27c

#define LPT_MASK                0xff0
#endif  /* PRINTER */

/* SoundBlaster I/O Ports */

#ifdef SWIN_SNDBLST_NULL
#define SNDBLST1_PORT_START             0x0220
#define SNDBLST1_PORT_END               0x022F
#define SNDBLST2_PORT_START             0x0240
#define SNDBLST2_PORT_END               0x026F
#endif

/*
 * PCI configuration ports.
 */

#define PCI_CONFIG_ADDRESS       0xcf8
#define PCI_CONFIG_DATA          0xcfc

#ifndef SFELLOW
/*
 * The following defines a key for each adaptor.  This is used as a
 * parameter to the io_connect_port() function.
 */


#define EMPTY_ADAPTOR           0
#define DMA_ADAPTOR             1
#define ICA0_ADAPTOR            2
#define TIMER_ADAPTOR           3
#define PPI_ADAPTOR             4
#define NMI_ADAPTOR             5
#define COM2_ADAPTOR            6
#define HDA_ADAPTOR             7
#define MDA_ADAPTOR             8
#define CGA_ADAPTOR             9
#define FLA_ADAPTOR             10
#define COM1_ADAPTOR            11
#define DMA_PAGE_ADAPTOR        12
#define MOUSE_ADAPTOR           13

#define EGA_SEQ_ADAP_INDEX      15
#define EGA_SEQ_ADAP_DATA       16
#define EGA_GC_ADAP_INDEX       17
#define EGA_GC_ADAP_DATA        18
#define EGA_CRTC_ADAPTOR        19
#define EGA_AC_ADAPTOR          20
#define EGA_MISC_ADAPTOR        21
#define EGA_FEAT_ADAPTOR        22
#define EGA_IPSTAT0_ADAPTOR     23
#define EGA_IPSTAT1_ADAPTOR     24
#define ICA1_ADAPTOR            25
#define AT_KEYB_ADAPTOR         26
#define CMOS_ADAPTOR            27
#ifdef HERC
#define HERC_ADAPTOR            28
#endif
#if (NUM_SERIAL_PORTS > 2)
#define COM3_ADAPTOR            29
#define COM4_ADAPTOR            30
#endif
#ifdef PRINTER
#define LPT1_ADAPTER            31
#define LPT2_ADAPTER            32
#define LPT3_ADAPTER            33
#endif /* PRINTER */

#ifdef VGG
#define VGA_DAC_INDEX_PORT      34
#define VGA_DAC_DATA_PORT       35
#endif

#define SNDBLST_ADAPTER         36

#ifdef NTVDM    /* Spare slots for user supplied VDDs */
#define SPARE_ADAPTER1          37
#define SPARE_ADAPTER2          38
#define SPARE_ADAPTER3          39
#define SPARE_ADAPTER4          40
#define SPARE_ADAPTER5          41
#define SPARE_ADAPTER6          42
#define SPARE_ADAPTER7          43


#define IO_MAX_NUMBER_ADAPTORS  44      /* make this equal to the highest used plus one please! */

#define NUMBER_SPARE_ADAPTERS   (SPARE_ADAPTER7 - SPARE_ADAPTER1)

#else   /* NTVDM */

#ifdef GISP_SVGA
#define GISP_VGA_FUDGE_ADAPTER          36
#define IO_MAX_NUMBER_ADAPTORS          37
#else           /* GISP_SVGA */

/* Adapter for SoundBlaster Null Driver */

#ifdef SWIN_SNDBLST_NULL
#define SNDBLST_ADAPTER         36
#endif

#ifndef IO_MAX_NUMBER_ADAPTORS
#define IO_MAX_NUMBER_ADAPTORS  37      /* make this equal to the highest used plus one please! */
#endif

#endif          /* GISP_SVGA */
#endif  /* NTVDM */
#else   /* SFELLOW */

/*
 * StringFellow doesn't need most of the emulated hardware, as
 * it has the real thing.
 */

#define EMPTY_ADAPTOR                                   0
#define HW_ADAPTOR_DW                                   1
#define HW_ADAPTOR_W                                    2
#define HW_ADAPTOR_B                                    3
#define KEY64_ADAPTOR                                   4
#define KEY60_ADAPTOR                                   5
#define DMA_ADAPTOR                                     6
#define PPI_ADAPTOR                                     7
#define CMOS_ADAPTOR                                    8
#define MFG_ADAPTOR                                     9
#define PCI_CONFIG_ADDRESS_ADAPTOR                      10
#define PCI_CONFIG_PORT_ADAPTOR                         11
#define PCI_CONFIG_DATA_ADAPTOR0                        12
#define PCI_CONFIG_DATA_ADAPTOR13                       13
#define PCI_CONFIG_DATA_ADAPTOR2                        14
#define PIC_SLAVE_ADAPTOR                               15
#define PIC_MASTER_ADAPTOR                              16
#define SF_EGA_GC_ADAP_INDEX                            17
#define SF_EGA_GC_ADAP_DATA                             18
#define IO_MAX_NUMBER_ADAPTORS  19      /* make this equal to the highest used plus one please! */

#endif /*SFELLOW */
#endif // !NEC_98

#if defined(NEC_98)
#define CMOS_ADAPTOR            27
#endif // !NEC_98

/*
 * The Bit masks for specifying Read/Write access when connecting ports
 * to the IO bus.
 */

#define IO_READ         1
#define IO_WRITE        2
#define IO_READ_WRITE   (IO_READ | IO_WRITE)

/*
 * Values to return if no adaptor is connected to a port
 */

#define IO_EMPTY_PORT_BYTE_VALUE        0xFF
#define IO_EMPTY_PORT_WORD_VALUE        0xFFFF

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

IMPORT void     inb IPT2(io_addr, io_address, half_word *, value);
IMPORT void     outb IPT2(io_addr, io_address, half_word, value);
IMPORT void     inw IPT2(io_addr, io_address, word *, value);
IMPORT void     outw IPT2(io_addr, io_address, word, value);
#ifdef SPC386
IMPORT void     ind IPT2(io_addr, io_address, IU32 *, value);
IMPORT void     outd IPT2(io_addr, io_address, IU32, value);
#endif /* SPC386 */

IMPORT void     io_define_inb
(
#ifdef  ANSI
        half_word adapter,
        void (*func) IPT2(io_addr, io_address, half_word *, value)
#endif  /* ANSI */
);

#ifdef SFELLOW
IMPORT void     io_define_inw
(
#ifdef  ANSI
        half_word adapter,
        void (*func) IPT2(io_addr, io_address, word *, value)
#endif  /* ANSI */
);

IMPORT void     io_define_ind
(
#ifdef  ANSI
        half_word adapter,
        void (*func) IPT2(io_addr, io_address, IU32 *, value)
#endif  /* ANSI */
);
#endif  /* SFELLOW */

IMPORT void     io_define_in_routines
(
#ifdef  ANSI
        half_word adapter,
        void (*inb_func) IPT2(io_addr, io_address, half_word *, value),
        void (*inw_func) IPT2(io_addr, io_address, word *, value),
        void (*insb_func) IPT3(io_addr, io_address, half_word *, valarray,
                word, count),
        void (*insw_func) IPT3(io_addr, io_address, word *, valarray,
                word, count)
#endif  /* ANSI */
);

IMPORT void     io_define_outb
(
#ifdef  ANSI
        half_word adapter,
        void (*func) IPT2(io_addr, io_address, half_word, value)
#endif  /* ANSI */
);

#ifdef SFELLOW
IMPORT void     io_define_outw
(
#ifdef  ANSI
        half_word adapter,
        void (*func) IPT2(io_addr, io_address, word, value)
#endif  /* ANSI */
);

extern void     io_define_outd
(
#ifdef  ANSI
        half_word adapter,
        void (*func) IPT2(io_addr, io_address, IU32, value)
#endif  /* ANSI */
);
#endif  /* SFELLOW */

IMPORT void     io_define_out_routines
(
#ifdef  ANSI
        half_word adapter,
        void (*outb_func) IPT2(io_addr, io_address, half_word, value),
        void (*outw_func) IPT2(io_addr, io_address, word, value),
        void (*outsb_func) IPT3(io_addr, io_address, half_word *, valarray,
                word, count),
        void (*outsw_func) IPT3(io_addr, io_address, word *, valarray,
                word, count)
#endif  /* ANSI */
);

#ifdef NTVDM
IMPORT IBOOL    io_connect_port IPT3(io_addr, io_address, half_word, adapter,
        half_word, mode);
#else
IMPORT void     io_connect_port IPT3(io_addr, io_address, half_word, adapter,
        half_word, mode);
#endif  /* NTVDM */

IMPORT void     io_disconnect_port IPT2(io_addr, io_address, half_word, adapter);
IMPORT void     io_init IPT0();

/* Externs and macros for io_redefine_inb/outb */
#ifdef MAC68K
IMPORT char     *Ios_in_adapter_table;
IMPORT char     *Ios_out_adapter_table;
#else
IMPORT char     Ios_in_adapter_table[];
IMPORT char     Ios_out_adapter_table[];
#endif

IMPORT void     (*Ios_inb_function  [])
        IPT2(io_addr, io_address, half_word *, value);
IMPORT void     (*Ios_inw_function  [])
        IPT2(io_addr, io_address, word *, value);
extern void     (*Ios_ind_function  [])
        IPT2(io_addr, io_address, IU32 *, value);
IMPORT void     (*Ios_insb_function [])
        IPT3(io_addr, io_address, half_word *, valarray, word, count);
IMPORT void     (*Ios_insw_function [])
        IPT3(io_addr, io_address, word *, valarray, word, count);

IMPORT void     (*Ios_outb_function [])
        IPT2(io_addr, io_address, half_word, value);
IMPORT void     (*Ios_outw_function [])
        IPT2(io_addr, io_address, word, value);
extern void     (*Ios_outd_function [])
        IPT2(io_addr, io_address, IU32, value);
IMPORT void     (*Ios_outsb_function[])
        IPT3(io_addr, io_address, half_word *, valarray, word, count);
IMPORT void     (*Ios_outsw_function[])
        IPT3(io_addr, io_address, word *, valarray, word, count);

/* FAST_FUNC_ADDR() used on the Mac to avoid routing by the jump table every time... */
#ifndef FAST_FUNC_ADDR
#define FAST_FUNC_ADDR(func)    func
#endif  /* FAST_FUNC_ADDR */

#define io_redefine_outb(adaptor,func)  Ios_outb_function[adaptor] = FAST_FUNC_ADDR(func)
#define io_redefine_inb(adaptor,func)   Ios_inb_function[adaptor] = FAST_FUNC_ADDR(func)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\kybdmtx.h ===
/*[
 *      Name:		kybdmtx.h
 *
 *      Derived From:	DEC 3.0 kybdmtx.gi and kybdcpu.gi
 *
 *      Author:         Justin Koprowski
 *
 *      Created On:	18th February 1992
 *
 *      Sccs ID:        @(#)kybdmtx.h	1.2 08/10/92
 *
 *      Purpose:	Host keyboard definitions
 *
 *      (c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
]*/
   
/* the type of keyboard being used	*/

#define KY83		83
#define KY101		101
#define KY102		102

/* keyboard matrix actions		*/

#define KYINIT		0
#define KYSWITCHUP	1
#define KYSWITCHDN	2
#define KYLOCK		3
#define KYLOCK1		4
#define KYUNLK		6
#define KYUNLK1		7
#define KYUNLK2		8
#define KYTOGLOCK	9
#define KYTOGLOCK1	10
#define KYTOGLOCK2	11
#define KYALOCK1	12

IMPORT VOID kyhot IPT0();
IMPORT VOID kyhot2 IPT0();
IMPORT VOID kyhot3 IPT0();
IMPORT VOID kybdmtx IPT2(LONG, action, LONG, qualify);
IMPORT VOID kybdcpu101 IPT2(int, stat, unsigned int, pos);

#define	OPEN	0
#define CLOSED	1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\keyboard.h ===
/*
 * SoftPC Revision 2.0
 *
 * Title        : keyboard.h
 *
 * Description  : defines for keyboard translations
 *
 * Author       : Simon Frost
 *
 * Notes        :
 *
 */

/* SccsID[]="@(#)keyboard.h	1.7 10/08/92 Copyright Insignia Solutions Ltd."; */


#define KH_BUFFER_SIZE  32

/*
 * Constants
 */

#define PC_KEY_UP	0x80		/* PC scan code up marker	*/
#define OVERFLOW	0xFF		/* PPI error indicator		*/

/*
 * Keyboard shift state veriable
 */

#define	kb_flag		0x417
/*#define	kb_flag		M[0x417]*/

/*
 * Significance of bits in above
 */

#define INS_STATE	0x80		/* insert state */
#define CAPS_STATE	0x40		/* caps lock on */
#define NUM_STATE	0x20		/* num lock on */
#define SCROLL_STATE	0x10		/* scroll lock on */
#define ALT_SHIFT	0x08		/* alt key depressed */
#define CTL_SHIFT	0x04		/* control key depressed */
#define LEFT_SHIFT	0x02		/* left shift key depressed */
#define RIGHT_SHIFT	0x01		/* right shift key depressed */
#define LR_SHIFT	0x03		/* both/either shift keys */

/*
 * Second status byte
 */

#define	kb_flag_1		0x418
/*#define kb_flag_1	M[0x418]*/

/*
 * Bit significance
 */

#define	INS_SHIFT	0x80		/* Insert key depressed */
#define CAPS_SHIFT	0x40		/* Caps Lock key depressed */
#define NUM_SHIFT	0x20		/* Num lock depressed */
#define	SCROLL_SHIFT	0x10		/* scroll lock key depressed */
#define HOLD_STATE	0x08		/* ctl-num lock pressed */

#define SYS_SHIFT	0x04		/* system key pressed and held	*/
/*
 * Third status byte	Keyboard LED flags
 */

#define	kb_flag_2		0x497
/*#define kb_flag_2	M[0x497]*/

/*
 * Bit significance
 */

#define KB_LEDS		0x07		/* Keyboard LED state bits 	*/
#define KB_FA		0x10		/* Acknowledgment received	*/
#define KB_FE 		0x20  		/* Resend received flag		*/
#define KB_PR_LED	0x40		/* Mode indicator update	*/
#define KB_ERR		0x80		/* Keyboard transmit error flag	*/

/*
 * Fourth status byte	Keyboard mode status and type flags
 */

#define	kb_flag_3		0x496
/*#define kb_flag_3	M[0x496]*/

/*
 * Bit significance
 */

#define LC_E1  		0x01		/* Last code was the E1 code	*/
#define LC_E0		0x02		/* Last code was the E0 code	*/
#define R_CTL_SHIFT	0x04		/* Right control key down	*/
#define GRAPH_ON 	0x08		/* All graphics key down	*/
#define KBX   	 	0x10		/* KBX installed               	*/
#define SET_NUM_LK	0x20		/* Force Num lock		*/
#define LC_AB		0x40		/* Last char was 1st ID char.	*/
#define RD_ID		0x80		/* Doing a read ID		*/

/*
 * Keyboard/LED commands
 */
#define KB_RESET	0xff		/* self diagnostic command	*/
#define KB_RESEND	0xfe		/* resend command		*/
#define KB_MAKE_BREAK	0xfa		/* typamatic comand		*/
#define KB_ENABLE	0xf4		/* keyboard enable		*/
#define KB_TYPA_RD	0xf3		/* typamatic rate/delay cmd	*/
#define KB_READ_ID	0xf2		/* read keyboard ID command	*/
#define KB_ECHO		0xee		/* echo command			*/
#define LED_CMD		0xed		/* LED write command		*/

/*
 * 8042 commands
 */
#define DIS_KBD		0xad		/* disable keyboard command	*/
#define ENA_KBD		0xae		/* enable keyboard command	*/

/*
 * 8042 response
 */
#define KB_OVER_RUN	0xff		/* over run scan code		*/
#define KB_RESEND	0xfe		/* resend request		*/
#define	KB_ACK		0xfa		/* acknowledge from transmsn.	*/

/*
 * enhanced keyboard scan codes
 */
#define ID_1		0xab		/* 1st ID character for KBX	*/
#define ID_2		0x41		/* 2nd ID character for KBX	*/
#define ID_2A		0x54		/* alt. 2nd ID char. for KBX	*/
#define F11_M		87		/* F11 make			*/
#define F12_M		88		/* F12 make			*/
#define MC_E0		224		/* general marker code		*/
#define MC_E1		225		/* pause key marker code	*/


/*
 * Storage for ALT + keypad sequence entry
 */

#define	alt_input 0x419
/*#define alt_input	M[0x419]*/

/*
 * Key definitions for U.S. keyboard
 */

#define NUM_KEY		69		/* Num lock scan code */
#define SCROLL_KEY	70		/* scroll lock scan code */
#define ALT_KEY		56		/* alt key scan code */
#define CTL_KEY		29		/* control key scan code */
#define CAPS_KEY	58		/* caps lock   scan code */
#define	LEFT_SHIFTKEY	42		/* left shift  key code */
#define RIGHT_SHIFTKEY	54		/* right shift key code */
#define INS_KEY		82		/* insert key  scan code */
#define DEL_KEY		83		/* delete key  scan code */
#define COMMA_KEY	51		/* comma key scan code */
#define DOT_KEY		52		/* fullstop key scan code */

#define SPACEBAR	57		/* space bar  scan code */
#define HOME_KEY	71		/* keypad home key scan code */
#define TAB_KEY		15		/* Tab/Back tab key  scan code */
#define PRINT_SCR_KEY	55		/* print screen / * key code */
#define KEY_PAD_PLUS	78		/* plus key on num keypad */
#define KEY_PAD_MINUS	74		/* minus key on num keypad */
#define TOP_1_KEY	2		/* number 1 at top */
#define BS_KEY		14		/* backspace key */
#define F1_KEY		59		/* 1st function key */
#define UPARR8		72		/* up arrow / '8' */
#define LARR4		75		/* left arrow / '4' */
#define RARR6		77		/* right arrow / '6' */
#define DOWNARR2	80		/* down arrow / '2' */
#define KEY_PAD_ENTER	28
#define KEY_PAD_SLASH	53		/* / on num keypad	*/
#define F10_KEY		68		/* 10th function key	*/
#define F11_KEY		87
#define F12_KEY		88
#define WT_KEY		86
#define SYS_KEY 	84		/* system key		*/
/* Bit 7 = 1 if break key hit */
#define	bios_break	 0x471
/*#define bios_break	M[0x471]*/

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

typedef struct
{
	void (*kb_prepare) IPT0();
	void (*kb_restore) IPT0();
	void (*kb_init) IPT0();
	void (*kb_shutdown) IPT0();
	void (*kb_light_on) IPT1(half_word,pattern);
	void (*kb_light_off) IPT1(half_word,pattern);
} KEYBDFUNCS;

extern KEYBDFUNCS *working_keybd_funcs;

#define host_kybd_prepare()		(*working_keybd_funcs->kb_prepare)()
#define host_kybd_restore()		(*working_keybd_funcs->kb_restore)()
#define host_kb_init()		(*working_keybd_funcs->kb_init)()
#define host_kb_shutdown()		(*working_keybd_funcs->kb_shutdown)()
#define host_kb_light_on(pat)	(*working_keybd_funcs->kb_light_on)(pat)
#define host_kb_light_off(pat)	(*working_keybd_funcs->kb_light_off)(pat)

/*
 * Undefine these GWI defines if the host isn't using the GWI interface
 */

#include	"host_gwi.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\lm_attr.h ===
/* This file comes from Highland Software ... Applies to FLEXlm Version 2.4c */
/* @(#)lm_attr.h	1.1 05/19/93 */
/******************************************************************************

	    COPYRIGHT (c) 1990, 1992 by Globetrotter Software Inc.
	This software has been provided pursuant to a License Agreement
	containing restrictions on its use.  This software contains
	valuable trade secrets and proprietary information of 
	Globetrotter Software Inc and is protected by law.  It may 
	not be copied or distributed in any form or medium, disclosed 
	to third parties, reverse engineered or used in any manner not 
	provided for in said License Agreement except with the prior 
	written authorization from Globetrotter Software Inc.

 *****************************************************************************/
/*	
 *	Module:	lm_attr.h v3.4
 *
 *	Description: 	Attribute tags for FLEXlm setup parameters.
 *
 *	M. Christiano
 *	5/3/90
 *
 *	Last changed:  8/13/92
 *
 */

#define LM_A_DECRYPT_FLAG	1	/* (short) */
#define LM_A_DISABLE_ENV	2	/* (short) */
#define LM_A_LICENSE_FILE	3	/* (char *) */
#define LM_A_CRYPT_CASE_SENSITIVE 4	/* (short) */
#define LM_A_GOT_LICENSE_FILE	5	/* (short) */
#define LM_A_CHECK_INTERVAL	6	/* (int) */
#define LM_A_RETRY_INTERVAL	7	/* (int) */
#define LM_A_TIMER_TYPE		8	/* (int) */
#define LM_A_RETRY_COUNT	9	/* (int) */
#define	LM_A_CONN_TIMEOUT	10	/* (int) */
#define	LM_A_NORMAL_HOSTID	11	/* (short) */
#define LM_A_USER_EXITCALL	12	/* PTR to func returning int */
#define	LM_A_USER_RECONNECT	13	/* PTR to func returning int */
#define LM_A_USER_RECONNECT_DONE 14	/* PTR to func returning int */
#define LM_A_USER_CRYPT		15	/* PTR to func returning (char *) */
#define	LM_A_USER_OVERRIDE	16	/* (char *) */
#define LM_A_HOST_OVERRIDE	17	/* (char *) */
#define LM_A_PERIODIC_CALL	18	/* PTR to func returning int */
#define LM_A_PERIODIC_COUNT	19	/* (int) */
#define LM_A_NO_DEMO		20	/* (short) */
#define LM_A_NO_TRAFFIC_ENCRYPT	21	/* (short) */
#define LM_A_USE_START_DATE	22	/* (short) */
#define LM_A_MAX_TIMEDIFF	23	/* (int) */
#define LM_A_DISPLAY_OVERRIDE	24	/* (char *) */
#define LM_A_ETHERNET_BOARDS	25	/* (char **) */
#define LM_A_ANY_ENABLED	26	/* (short) */
#define LM_A_LINGER		27	/* (long) */
#define LM_A_CUR_JOB		28	/* (LM_HANDLE *) */
#define LM_A_SETITIMER		29	/* PTR to func returning void, eg PFV */
#define LM_A_SIGNAL		30	/* PTR to func returning PTR to */
					/*    function returning void, eg:
					      PFV (*foo)(); 	*/
#define LM_A_TRY_COMM		31	/* (short) Try old comm versions */
#define LM_A_VERSION		32	/* (short) FLEXlm version */
#define LM_A_REVISION		33	/* (short) FLEXlm revision */
#define LM_A_COMM_TRANSPORT	34	/* (short) Communications transport */
					/*	  to use (LM_TCP/LM_UDP) */
#define LM_A_CHECKOUT_DATA	35	/* (char *) Vendor-defined checkout  */
					/*				data */

#ifdef VMS
#define LM_A_EF_1		1001	/* (int) */
#define LM_A_EF_2		1002	/* (int) */
#define LM_A_EF_3		1003	/* (int) */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\keyba.h ===
/*
 * SoftPC AT Revision 2.0
 *
 * Title        : Keyboard Adpator definitions
 *
 * Description  : Definitions for users of the keyboard Adaptor
 *
 * Author       : WTG Charnell
 *
 * Notes        : None
 */



/* @(#)keyba.h	1.10 08/10/92 Copyright Insignia Solutions Ltd."; */


#define RESEND_CODE 0xfe
#define ACK_CODE 0xfa
#define BAT_COMPLETION_CODE 0xaa

extern void kbd_inb IPT2( io_addr, port, half_word *, val );
extern void kbd_outb IPT2( io_addr, port, half_word, val );
#ifndef REAL_KBD
extern void ( *host_key_down_fn_ptr ) IPT1( int, key );
extern void ( *host_key_up_fn_ptr ) IPT1( int, key );
#endif
extern void ( *do_key_repeats_fn_ptr ) IPT0();
extern void keyboard_init IPT0();
extern void keyboard_post IPT0();
extern void AT_kbd_init IPT0();
extern void AT_kbd_post IPT0();

#ifdef HUNTER
/*
** AT Hunter uses these two functions.
** AT keyboard is different so slight mods for AT Hunter.
**
*/
/*
** Puts a scan code (type is half_word) into Keyboard Buffer.
** Returns success; either TRUE or FALSE.
*/
extern int hunter_codes_to_translate IPT1(half_word, scan_code);
/*
** Returns number of chars in the keyboard buffer that the BIOS
** reads. Will only be 1 or 0.
*/
extern int buffer_status_8024();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\jformate.h ===
/*[
 *	Name:           jformatE.h
 *
 *      Derived From:   (original)
 *
 *      Author:        	Jerry Kramskoy
 *
 *      Created On:    	16 April 1993
 *
 *      Sccs ID:        @(#)jformatE.h	1.16 04/21/95
 *
 *      Purpose:      	describes the file format for the host binary
 *			emitted by 'jcc'.
 *
 *      Design document:/HWRD/SWIN/JCODE/jcobjfmt
 *
 *      Test document:
 *
 *      (c) Copyright Insignia Solutions Ltd., 1993. All rights reserved
]*/


/* 

   History:
   ===================================================
   	version 04/21/95:	extended object file format.
   ===================================================

   if JLD_OBJFILE_HDR.magic == JLD_OBJ_MAGIC, then no JLD_OBJFILE_EXT or JLD_SECTION_EXT records are present.

   If JLD_OBJFILE_HDR.magic == JLD_OBJ_MAGIC_X, this is an extended object file format ...
   then a JLD_OBJFILE_EXT record immediately follows the JLD_OBJFILE_HDR, and
   a JLD_SECTION_EXT record immediately follows a JLD_SECTION_HDR.

   For extended format, the first code segment in the file is ALWAYS aligned to a cache-line boundary.

 */


/*
	The object file contains the target-machine binary emitted via
	jcc, along with header information.

	the input file to jcc may contain many sections of jcode.  jcc emits
	code/data into one of 8 selectable segments associated with one
	section.  These segment types (enum JLD_SEGTYPES) are:

	(IF NEW EXECUTABLE TYPES OF SEGMENT ARE ADDED, UPDATE the macro
	JLD_IS_EXECUTABLE below)

		JLD_CODE		-- inline host code derived from Jcode 
		JLD_CODEOUTLINE		-- out of line host code derived from Jcode
		JLD_DATA		-- host data derived from Jcode
		JLD_APILOOKUP		-- api lookup data

		JLD_IMPORTS		-- externals required for section
		JLD_EXPORTS		-- addresses exported from section to OTHER sections
		JLD_STRINGSPACE		-- string space to hold all symbol names defd/refd in section
		JLD_INTELBIN		-- intel binary as labelled Jcode data for debugging
		JLD_INTELSYM		-- intel symbolic as labelled Jcode data for debugging
		JLD_SYMJCODE		-- generated streamed Jcode as labelled Jcode data
					   for debugging
		JLD_DEBUGTAB		-- tuples of JADDRS pointing to labels in the above
					   three segment types and the generated host code
					   for debugging
		JLD_D2SCRIPT		-- debug test script information encoded as a stream
		JLD_CLEANUP		-- cleanup records
		JLD_PATCH		-- compiler-generated patch up requests
					   of data bytes in JDATA form, no labels.

	jcc allows separate compilations of sections from the input file
	to produce separate object files. e.g; sections 1,2 ->file A
	section 3 -> file B, and sections 4->20 in file C.

	This format describes the contents of one of these files.  The file
	layout is:

		----------------------
		! obj.file hdr       !
		---------------------- <=== extension file hdr, if present
		! section hdr for 1st!
		! section	     !
		---------------------- <=== extension section 1 hdr, if present
		! segments for 1st   !
		! section	     !
		----------------------
		! section hdr for 2nd!
		! section	     !
		---------------------- <=== extension section 2 hdr, if present
		! segments for 2nd   !
		! section	     !
		----------------------
		!		     !
		!	etc.	     !
		!		     !
		----------------------
		! section hdr for Nth!
		! section	     !
		---------------------- <=== extension section 3 hdr, if present
		! segments for Nth   !
		! section	     !
		----------------------

	Linking amalgamates the sections into one section for all the files
	presented to the process.  Files are processed in order of occurrence in
	the command line.  Per file the following actions occur ...

	The sections are processed in order of occurrence in the file.
	This produces one section for the file.

	Within a section, segments are always processed in order,
	from lowest enum value (JLD_CODE) upto, but excluding JLD_NSEGS.

	Normally, each segment has its own space allocation, so that all the contents
	of JLD_DATA segments are grouped together in an area separate to, say, the
	contents for JLD_IMPORTS.  As a section is processed, the contents of its
	different segment types are concatenated into their respective spaces.
	However, different segment types can be GROUPED to SHARE the SAME space.
	If segment type X is attributed with segment group X, then its space allocation
	is taken from X's overall space.  If segment type X is attributed with segment
	group Y, then this causes the following to happen ...

		1]. No memory is allocated for segment type X.
		2]. The size of segment type X is totalled in with the size of
		    segment type Y.
		3]. The segment contents for X get concatenated into Y.  The order of
		    this concatenation is governed by where segment type X occurs in 
		    the segment processing order, based upon its enum, as stated above.

	For example, suppose we only have 5 segment types ... A,B,C,D and E.  Let's
	suppose we set the segment attributes as {A, C, D all map to segment group of type A}, 
	{B maps to segment group of type B}, and {E maps to segment group of type E}.
	Also suppose our segment types are enumerated in the order {B=0,C,A,E,D}.
	Finally suppose we have a file with 2 sections, where

1.		(sect #1, segType A is 100 bytes long),
2.		(sect #1, segType B is 200 bytes long),
3.		(sect #1, segType C is 300 bytes long),
4.		(sect #1, segType D is 400 bytes long),
5.		(sect #1, segType E is 500 bytes long),
6.		(sect #2, segType A is 110 bytes long),
7.		(sect #2, segType B is 120 bytes long),
8.		(sect #2, segType C is 130 bytes long),
9.		(sect #2, segType D is 140 bytes long),
10.		(sect #2, segType E is 0 bytes long),

	Overall sizing would add up the sizes of all segments, attributing the space
	to the segment type of the group to which the segment belongs.  Hence we get the
	following total sizes ...

		segType A needs sz(1) + sz(3) + sz(4) + sz(6) + sz(8) + sz(9) = 1180 bytes
		segType B needs sz(2) + sz(7) = 320 bytes
		segType C needs 0 bytes (allocated out of segType A)
		segType D needs 0 bytes (ditto)
		segType E needs 500 bytes.

	We hence have a requirement for 'globally allocated segments' of types A,B and E
	of sizes 1180,320 and 500 bytes respectively.

	As sect #1 is processed, we process segment types in the order B,C,A,E,D as per
	the enum.  We use the segment group associated with the segment type to select
	which actual segment type to copy the segment contents into, so we would be
	allocating (2) out of B, then (3) out of A, then (1) out of A, then (5) out of E,
	and finally (4) out of A giving ...

	A:			B:			E:
		------------		-------------		--------------
	0	! cont(3)  !	0	! cont(2)   !  	0	! cont(5)    !
		------------  		-------------		--------------
	300	! cont(1)  !	200	! free	    !	500	! free	     !
		------------  		-------------		--------------
	400	! cont(4)  !
		------------
	800	! free     !
		------------
	

	Then section #2 is processed in the same manner, and we allocate the space
	the same way, allocating (7) out of B, then (8) out of A, then (6) out of A, then (10) out of E,
	and finally (9) out of A giving ...
	
	A:			B:			E:
		------------		-------------		--------------
	0	! cont(3)  !	0	! cont(2)   !  	0	! cont(5)    !
		------------  		-------------		--------------
	300	! cont(1)  !	200	! cont(7)   !	500	! free       !
		------------  		-------------		--------------
	400	! cont(4)  !	320	! free      !
		------------		-------------
	800	! cont(8)  !
		------------
	930	! cont(6)  !
		------------
	1040	! cont(9)  !
		------------
	1180	! free	   !
		------------

	Currently, we are grouping JLD_CODE and JLD_CODEOUTLINE together, to share the
	JLD_CODE segment type.  This allows pc-relative branching to be used to access
	the out-of-line code from the in-line code.  If these weren't grouped, then the
	JLD_CODEOUTLINE segment would load after all the inline code (given current enums)
	and would probably be unreachable efficiently.

	Other files would concatenate into these segments in the exactly the same manner.

	If we are linking, rather than loading, then the output binary file contains 1 section,
	with five segments, two which are empty, and the other three are of segment types
	A,B and E, of sizes 1180, 320 and 500 respectively.  LINKING MUST ALWAYS BE DONE, when
	more than one section is involved.

	On loading, the order these segments occur in memory is also controlled by the segment
	type enum.  Lower value enums appear lower in memory.  The loader only expects ONE linked
	binary file, and hence will refuse to load if the file contains more than one section.
	This section is executable PROVIDED that all unresolved references (i.e;
	extant IMPORTs and Intel relocs) can be resolved dynamically at load time.  The loader
	can be called at any time, but for patching up of Intel relocatable values, this
	must be after Windows has loaded within Softwin.  

	
	When loaded, the section is laid out, within the DATA space of the process, as 

			--------------------
			!	code seg   !
			--------------------
			!	data seg   !
			--------------------
			!   api lookup seg !
			--------------------
*/


/*===========================================================================*/
/*			INTERFACE DATA TYPES				     */
/*===========================================================================*/
/* version 0 does NOT support extension records */
#define JLD_VERSION_NUMBER	1

#define JLD_MAX_INPUTFILES	1000

/* segment types */
/* ------------- */

/* These should be cast to IU16 values, before emitting in obj.file */

/* NOTE: the patch segment should follow the others, since the binary
 * code generation assumes that any labels used in the PATCH segment
 * are defined earlier.
 */

typedef enum
{

JLD_CODE=0,			/* inline host code derived from Jcode */
JLD_CODEOUTLINE,		/* out of line host code derived from Jcode */
JLD_DATA,			/* host data derived from Jcode */
JLD_APILOOKUP,			/* api lookup data		*/
JLD_STRINGSPACE,		/* string space to hold all symbol names defd/refd in section */
JLD_EXPORTS,			/* addresses exported from section to OTHER sections */
JLD_IMPORTS,			/* externals required for section */

/* segments providing information for debugging tools */
JLD_INTELBIN,		/* the original intel binary being turned into Jcode by
					   flowBm, packaged as a set of JDATA operations, one per`
					   byte of Intel instruction. The first byte of each Intel
					   instruction is preceeded by a JLABEL with a symbol of
					   the form "IBnnnn" for the nnnn'th Intel instruction
					   being processed. */
JLD_INTELSYM,		/* the binary from above disassembled and packaged as
					   JDATA operations, with labels of the form "ISnnnn"
					   preceeding the first byte of the nnnn'th Intel 
					   instruction */
JLD_SYMJCODE,		/* the streamed Jcode generated, with labels of the form
					   "SJnnnn" inserted at the start of the code generated 
					   from the nnnn'th Intel instruction */
JLD_DEBUGTAB,		/* a set of four JADDR operations for each Intel 
					   instruction, the addresses in the tuple for the nnnn'th
					   Intel instruction, are thos of the labels "IBnnnn",
					   "ISnnnn", "JBnnnn", and "SJnnnn". The "JBnnnn" labels
					   are inserted in the real Jcode which will be compiled`						   into host binary. These tuples will allow debugging 
					   software to do things like print the Intel binary and/or
					   symbolic instructions that generated a particular host
					   instruction. see typedef for JLD_DEBUGTUPLE below */
JLD_D2SCRIPT,		/* d2Bm script information for running the test "API"
					   compiled into the other segments */

JLD_CLEANUP,			/* cleanup records */
JLD_PATCH,			/* compiler-generated patch up requests */

JLD_NSEGS,			/* #.of above segments */

/* The following don't take any segment space in obj.file.
 * they are only required to specify type of IMPORTed symbol
 * in IMPORT_ENTRYs, for accessing static addresses (determined at
 * process load time)
 */

JLD_CCODE,			/* IMPORT a 'C' static code address */
JLD_CDATA,			/* IMPORT a 'C' static data address */

JLD_ACODE,			/* IMPORT an assembler static code address */
JLD_ADATA,			/* IMPORT an assembler static data address */

JLD_ALLSEGS			/* total #.of different segments	   */

} JLD_SEGTYPES;


typedef enum
{
	RS_8=0,
	RS_16,
	RS_32,
	RS_64,
	RS_UU
} RELOC_SZ;
	


typedef	enum
{
	PATCHABLE=1,
	EXPORTABLE=2,
	DISCARDABLE=4,
	ALLOCATE_ONLY=8
} SEGATTR;


typedef struct 
{
	IUH		attributes;
	JLD_SEGTYPES	segmentGroup;
	CHAR		*name;
} JLD_SEGATTRIBUTES;


typedef struct 
{
	IUH 		*ibPtr;
	CHAR		*isPtr;
	IUH 		*jbPtr;
	CHAR		*sjPtr;
} JLD_DEBUGTUPLE;


typedef struct {
	IU32	segLength[JLD_NSEGS];		/* #.bytes in each segment */
	IU32	segStart[JLD_NSEGS];		/* byte offset into file for each segment */
	IU32	nextSectHdrOffset;		/* file offset to next header (0 if no more) */
} JLD_SECTION_HDR;

/* alignments for code layout */

typedef enum {
	AL_INST=1,
	AL_CACHE_LINE=2,
	AL_PAGE_BOUNDARY=3
} JLD_ALIGN;

#define	JLD_OBJ_MAGIC	0xafaffafa	/* no extension records */
#define	JLD_OBJ_MAGIC_X	0xafaffafb	/* contains extension records */

/* machine types */
#define JLD_HPPA	1
#define JLD_SPARC	2
#define JLD_68K		3
#define JLD_PPC		4
#define JLD_MIPS	5
#define JLD_AXP		6
#define JLD_VAX		7

typedef struct {
	IU32	magic;				/* identify as jcode obj.file 		*/
	IU32	jccVersion;			/* compiler version	      		*/
	IU32	flowBmVersion;			/* flowBm version			*/
	IU32	machine;			/* machine to run this binary on 	*/
	IU32	nSections;			/* #.sections in file			*/
	IU32	firstSectHdrOffset;		/* file offset to first section header  */
} JLD_OBJFILE_HDR;






/* ============================================================================================= */
/*			OBJECT FILE EXTENSIONS							 */
/* ============================================================================================= */

typedef enum {					/* version numbers for obj.file hdr extension record */
	OextVers1=1				/* add new version numbers as required		     */
} JLD_OBJFILE_EXT_VERSIONS;




typedef enum {					/* version numbers for section hdr extension record */
	SextVers1=1				/* add new version numbers as required		    */
} JLD_SECTION_EXT_VERSIONS;




/* extension records */

typedef struct {
	IU32	recLength;			/* size of record, in bytes (includes this IU32) */
	IU32	version;			/* version number for this record */
} JLD_OBJFILE_EXT_Vers1;

typedef struct {
	IU32	recLength;			/* size of record, in bytes (includes this IU32) */
	IU32	version;			/* version number for this record */
	IU32	codeAlign;			/* alignment for code segment ... (IU32)(JLD_ALIGN) */
	IU32	groupId;			/* subroutine sorting group for this section */
	IU32	groupOrdinal;			/* ordinal of this subroutine within sorting group */
} JLD_SECTION_EXT_Vers1;

/* NOTE: A new version derived from current structure MUST contain current structure
 * at top of new structure !!!! ... DO NOT DELETE OLDER VERSION STRUCTURES
 */


/* the current structures that reflects the latest extensions should be indicated
 * here ... ditto for version numbers.
 */
#define	JLD_CURRENT_OBJEXT_VERSION		OextVers1
#define JLD_CURRENT_SECTION_EXT_VERSION		SextVers1


/* compiler and linker output current versions ... */
typedef	JLD_OBJFILE_EXT_Vers1		JLD_CURRENT_OBJEXT;
typedef JLD_SECTION_EXT_Vers1		JLD_CURRENT_SECTION_EXT;

/* the linker/loader understands current and older versions */





/* ============================================================================================= */
/*			RELOCATION								 */
/* ============================================================================================= */

typedef enum
{
	RT_ATTR_NONE=0,
	RT_ATTR_IMPORT_OFFSET=1,
	RT_ATTR_SEG_TYPE=2,
	RT_ATTR_HEX=4
} RTATTRS;

/* attributes for relocation types */
/* see SegRTAttr[] below.  The 'name' is used by jld when printing out relocation
 * type.  The attrib field also controls how reloc.info is printed.
 * If attribute RT_ATTR_IMPORT_OFFSET, then it expects to find an IMPORT_ENTRY with
 * offset into STRINGSPACE, where name is stored.
 * If RT_ATTR_SEGTYPE, then it interprets value as segment type.
 * If RT_ATTR_HEX, it prints value as %08x.
 */

#define JLD_NPATCHVALUES	2

typedef struct 
{
	CHAR 	*name;
	RTATTRS	attrib[JLD_NPATCHVALUES];
} JLDRTATTR;

/* patch up request entry */
/* these reside within segment type JLD_PATCH only */
/* (sect_hdr->segLength[JLD_PATCH] / sizeof(PATCH_ENTRY) gives the number
 * of relocation entries in the 'patching' segment.
 */

typedef struct {
	IU16		section;		/* section id in which this PATCH_ENTRY occurs		*/
	IU16		segType;		/* which segment requires the patch applied to it 	*/
	IU16		relocSize;		/* the size of the value to be patched in (RELOC_SZ)	*/
	IU16		chainCount;		/* number of records compressed into following PATCH_ENTRY spaces
				*/
	IU32		segOffset;		/* offset to place to patch in this seg		*/
	IU32		patchInfo;		/* private info.to host patcher indicating instruction 	*/
						/* (pair) format that needs patching			*/
	IU32		relocType;		/* how to derive the value to be passed to the patcher	*/
	IU32		value1;			/* relocation value (interpreted based on relocType)	*/
	IU32		value2;			/* relocation value (interpreted based on relocType)	*/
} PATCH_ENTRY;

/* The PATCH_ENTRYs may be compressed, so that entries which differ only in
 * the segOffset will be represented as a PATCH_ENTRY for the first segOffset
 * followed by additional PATCH_ENTRY records used as arrays of IU32s for
 * the additional offsets. The total number of IU32 entries represented
 * is recorded in the leading PATCH_ENTRY in chainCount: a chainCount of
 * zero means "no chain". The number JLD_CHAIN_MAX is the number of IU32s
 * stored in a single PATCH_ENTRY.
 */
#define JLD_CHAIN_MAX	7	


 /* relocType values */
 /* ---------------- */
#define RT_RSVD	0

#define RT_SELID	1
#define RT_RELOC1	2
#define RT_RELOC2	3
#define RT_RELOC3	4
#define RT_RELOC4	5
#define RT_RELOC5	6
#define RT_HGLBL_ABS	7
#define RT_HGLBL_PCREL	8
#define RT_HLCL_ABS	9
#define RT_HLCL_PCREL	10
#define RT_HGLBL_SEGOFF 11
#define RT_LAST		12


/*
The following can be used to patch JLD_CODE, JLD_DATA and JLD_APILOOKUP segments to get
Intel information or related descriptor cache information.

Relocation types				Patch action (and when patched)
-----------------				-------------------------------
RT_RSVD						Reserved for internal use by the linker.

RT_SELID,  value1.			    	(Windows init.) Map value1 (nominal selector) ->
						actual 16-bit selector.  Patch in this value. 

RT_RELOC1, value1, value2.			(Windows init.) Map value1 as above.  Get ea24
						corresponding to base of this Intel segment.
						Patch in 'ea24 + value2'. value2 is a 16-bit
						Intel ip.

RT_RELOC2, value1, value2.			(Windows init.) Map value1 as above.  Get ea24
						corresponding to base of this Intel segment.
						Patch in 'ea24<<4 + value2'. 

RT_RELOC3, value1, 0				(Windows init). Map value1 as above.  Get corresponding
						compiled desc.cache entry address (host-sized addr)
						and patch in.

RT_RELOC4, value1, value2.			(Windows init.) Map value1 as above.  
						Patch in 'mapped value<<16 + value2'. 


RT_RELOC5, value1, value2.			(Windows init.) Map value1 as above.  Get ea32b
						corresponding to base of this Intel segment.
						Patch in 'ea32b {+} value2'. value2 is a 16-bit
						Intel ip.



The following can be used to patch JLD_CODE, JLD_CODEOUTLINE, JLD_DATA and JLD_APILOOKUP segments to
get host addresses (such as 'C' externals and procedures, or CPU infrastructure
offline code, or other jcode exports).  pc-relative patchups (*_PCREL) are only legal when
within JLD_CODE, and then only when the value to be patched in corresponds to
a jcode export)

RT_HGLBL_ABS, 	value1,value2.			value1 is segment offset in corresponding IMPORTS segment
						to byte 0 of entry.
RT_HGLBL_PCREL, value1,value2.			value1 is segment offset in corresponding IMPORTS segment
						to byte 0 of entry.

The following can be used to patch JLD_CODE, JLD_CODEOUTLINE, JLD_DATA and JLD_APILOOKUP
segments with host addresses of other symbols LOCAL to the section.  Here, 'value1' and
'value2' indicate the segment offset and type, in which some symbol X is DEFINED.  The
PATCH_ENTRY identifies that the address of X needs to be patched into some LOCAL segment,
of type 'segType', at offset 'segOffset'.  *_ABS will cause the loader to patch in the loaded
address of X.  *_PCREL will cause the linker to patch in the relative displacement from the
patched object to X.

RT_HLCL_ABS, 	value1,value2.			value1 is segment offset in segment, whose type is given
						by value2.
RT_HLCL_PCREL, 	value1,value2.			value1 is segment offset in segment, whose type is given
						by value2.

The linker converts RT_HGLBL_ABS into RT_HGLBL_SEGOFF, when it sees a definition for the
symbol IMPORTED by the RT_HGLBL_ABS.
RT_HGLBL_SEGOFF,value1,value2.			value1 is segment offset in segment, whose type is given
						by value2.



*/


/* locally scoped definitions and references 
 * ----------------------------------------- 
 * This corresponds to all non-GLOBAL symbols defined and referenced within
 * a section.  'jcc' handles these by use of RT_HLCL_* relocation requests
 * for all references, where the entry embeds the seg.offset and type of the 
 * defn.address of the symbol (as determined by jcc).  The linker/loader
 * just needs to relocate this by a). its location within the overall
 * global segment allocation, and then b). by the base address of that
 * segment when loaded.
 */


/* globally scoped definitions
 * ---------------------------
 * all named symbols here can be accessed from other sections.
 * these entries reside within segment type JLD_EXPORTS only
 * (sect_hdr->segLength[JLD_EXPORTS] / sizeof(EXPORT_ENTRY) gives the number
 * of entries in the 'exports' segment.
 */
typedef struct {
	IU16		section;		/* section in which this EXPORT_ENTRY occurs */
	IU16		segType;		/* segment within which exported symbol is defined */
	IU32		nameOffset;		/* offset within JLD_STRINGS segment to 'C' string for name */
	IU32		segOffset;		/* offset into segment where symbol is defined */
} EXPORT_ENTRY;






/* global references entry
 * -----------------------
 * all named symbols here are defined in another section.
 * these entries reside within segment type JLD_IMPORTS only 
 * (sect_hdr->segLength[JLD_IMPORTS] / sizeof(IMPORT_ENTRY) gives the number
 * of relocation entries in the 'imports' segment.
 *
 * NB: this is the only segment allowed to mention segType values JLD_CCODE, JLD_CDATA,
 * JLD_ACODE and JLD_ADATA.
 */
typedef struct {
	IU16		section;		/* section in which this IMPORT_ENTRY occurs */
	IU16		padding;		/* for alignment...  	*/
	IU32		nameOffset;		/* offset within JLD_STRINGS segment to 'C' string for name */
} IMPORT_ENTRY;




#define	JLD_NOFILE_ERR		1			/* missing file */
#define	JLD_BADFILE_ERR		2			/* bad file format */
#define JLD_UNRESOLVED_ERR	3			/* could not resolve all addresses */
#define JLD_BADMACH_ERR		4			/* wrong machine type for binary */
#define JLD_DUPSYMB_ERR		5			/* wrong machine type for binary */
#define JLD_INTERNAL_ERR	6			/* fatal error !! */
#define JLD_SPACE_ERR	 	7			/* not enough memory */
#define JLD_PATCH_ERR	 	8			/* patcher encountered relocation error */
#define JLD_INTERSEGREL_ERR	9			/* relative relocation request between
							 * DIFFERENT segment types
							 */
#define JLD_VERSION_MISMATCH	10			/* api.bin version no match */


/* following typedef gives segment information */
/* size of segments for all sections in all files (indexed by segment type) */
/* pointers to loaded areas for these segments (indexed by segment type) */
/* next free offset into loaded areas (indexed by segment type) */
typedef struct
{
	IHPE	free_base;	/* base of original malloc */
	IHPE	base;		/* aligned base */
	IU32	size;
	IU32	segOffset;
	IU32	alignment;	/* required alignment for this segment */
} SEGINFO;


/* loader symbol table entry format (for a defined symbol) */
typedef struct {
	IU16	section;
	IU16	segType;
	IUH	segOffset;
	CHAR 	*file;
} LDSYMB;


/*===========================================================================*/
/*			INTERFACE GLOBALS   				     */
/*===========================================================================*/
#ifdef JLD_PRIVATE		/* ONLY defined from within lnkload.c */


GLOBAL 	JLD_SEGATTRIBUTES SegAttributes[JLD_ALLSEGS] =
{
	/* JLD_CODE */
	{PATCHABLE|EXPORTABLE, JLD_CODE, "JC"},

	/* JLD_CODEOUTLINE */
	/* Note: grouped with JLD_CODE segment for section */
	{PATCHABLE|EXPORTABLE, JLD_CODE, "JK"},

	/* JLD_DATA */
	{PATCHABLE|EXPORTABLE, JLD_DATA, "JD"},

	/* JLD_APILOOKUP */
	{PATCHABLE|EXPORTABLE|ALLOCATE_ONLY, JLD_APILOOKUP, "JA"},

	/* JLD_STRINGSPACE */
	{DISCARDABLE, JLD_STRINGSPACE, "JS"},

	/* JLD_EXPORTS */
	{DISCARDABLE, JLD_EXPORTS, "JX"},

	/* JLD_IMPORTS */
	{DISCARDABLE, JLD_IMPORTS, "JI"},

	/* JLD_INTELBIN */
	{0, JLD_INTELBIN, "IB"},

	/* JLD_INTELSYM */
	{0, JLD_INTELSYM, "IS"},

	/* JLD_SYMJCODE */
	{0, JLD_SYMJCODE, "SJ" },

	/* JLD_DEBUGTAB */
	{PATCHABLE, JLD_DEBUGTAB, "DT"},

	/* JLD_D2SCRIPT */
	{0, JLD_D2SCRIPT, "DS" },

	/* JLD_CLEANUP */
	{PATCHABLE|ALLOCATE_ONLY, JLD_CLEANUP, "CR" },

	/* JLD_PATCH */
	{DISCARDABLE, JLD_PATCH, "JP"},

	/* JLD_NSEGS */
	{0, JLD_NSEGS, ""},

	/* JLD_CCODE */
	{0, JLD_CCODE, "CC"},

	/* JLD_CDATA */
	{0, JLD_CDATA, "CD"},

	/* JLD_ACODE */
	{0, JLD_ACODE, "AC"},

	/* JLD_ADATA */
	{0, JLD_ADATA, "AD"}
};


/* How relocSize is printed out */
GLOBAL	CHAR *SegSizeAttr[RS_UU+1] = 
{
	"08",	/* RS_8 */
	"16",	/* RS_16 */
	"32", 	/* RS_32 */
	"64",   /* RS_64 */
	"??"	/* RS_UU  */
};


/* How relocType is printed out */
/* if SYMBOLIC, then name extracted from namespace */
GLOBAL	JLDRTATTR SegRTAttr[RT_LAST+1] =
{
	{"    rsvd", RT_ATTR_NONE, RT_ATTR_NONE},
	{"   selid", RT_ATTR_HEX, RT_ATTR_NONE},
	{"  reloc1", RT_ATTR_HEX, RT_ATTR_HEX},
	{"  reloc2", RT_ATTR_HEX, RT_ATTR_HEX},
	{"  reloc3", RT_ATTR_HEX, RT_ATTR_NONE},
	{"  reloc4", RT_ATTR_HEX, RT_ATTR_HEX},
	{"  reloc5", RT_ATTR_HEX, RT_ATTR_HEX},
	{" glb.abs", RT_ATTR_IMPORT_OFFSET, RT_ATTR_HEX},
	{" glb.pcr", RT_ATTR_IMPORT_OFFSET, RT_ATTR_HEX},
	{" lcl.abs", RT_ATTR_HEX, RT_ATTR_SEG_TYPE},
	{" lcl.pcr", RT_ATTR_HEX, RT_ATTR_SEG_TYPE},
	{"glb.segr", RT_ATTR_HEX, RT_ATTR_SEG_TYPE},
	{"????????", RT_ATTR_NONE, RT_ATTR_NONE}
};

#endif

IMPORT 	JLD_SEGATTRIBUTES SegAttributes[];
IMPORT	CHAR 		  *SegSizeAttr[];
IMPORT	JLDRTATTR	  SegRTAttr[];


/* global segment allocation information */
extern	SEGINFO	GlblSegInfo[JLD_NSEGS];

/* indicates lnk/load error occurred */
IMPORT  IBOOL   JLdErr;

/* indicates what the error was */
IMPORT  IU32    JLdErrCode;

/* whether linking or loading */
IMPORT	IBOOL	Loading;

/* machine patcher is targeted for */
IMPORT	IUH	PatchingMachine;

/* tracing*/
IMPORT	IBOOL	DumpImports;
IMPORT	IBOOL	DumpExports;
IMPORT	IBOOL	DumpPatch;
IMPORT	IBOOL	DumpCode;
IMPORT	IBOOL	DumpDebug;
 





/*===========================================================================*/
/*			INTERFACE PROCEDURES				     */
/*===========================================================================*/

/* GroupSeg */
/* Concatenate */
IMPORT	void	PatchUp IPT0();


/* following macro indicates whether a given segment is executable */
#define	JLD_IS_EXECUTABLE(segNo)	((segNo == JLD_CODE) || (segNo == JLD_CODEOUTLINE))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\lock.h ===
/*
	
FILE NAME	: lock.h
DESCRIPTION	: Interface for locking functions.

	THIS INCLUDE SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER	: J. Koprowski
DATE		: June 1990


=========================================================================

AMENDMENTS	:

=========================================================================
*/

/* SccsID[]="@(#)lock.h	1.7 09/24/92 Copyright Insignia Solutions Ltd."; */

#ifdef ANSI
extern boolean gain_ownership(int);
extern void release_ownership(int);
extern void critical_region(void);
extern boolean host_place_lock(int, CHAR *);
extern boolean host_check_for_lock(int);
extern void host_clear_lock(int);
#else
extern boolean gain_ownership();
extern void release_ownership();
extern void critical_region();
extern boolean host_place_lock();
extern boolean host_check_for_lock();
extern void host_clear_lock();
#endif /* ANSI */
extern int host_get_hostname_from_stat IPT4(struct stat *,filestat, CHAR *,hostname, CHAR *, pathname, int, fd);
IMPORT BOOL host_ping_lockd_for_file IPT1(CHAR *,path);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\lm_clien.h ===
/* This file comes from Highland Software ... Applies to FLEXlm Version 2.4c */
/* @(#)lm_client.h	1.2 12/23/93 */
/******************************************************************************


	    COPYRIGHT (c) 1988, 1992 by Highland Software Inc.
	This software has been provided pursuant to a License Agreement
	containing restrictions on its use.  This software contains
	valuable trade secrets and proprietary information of 
	Highland Software Inc and is protected by law.  It may 
	not be copied or distributed in any form or medium, disclosed 
	to third parties, reverse engineered or used in any manner not 
	provided for in said License Agreement except with the prior 
	written authorization from Highland Software Inc.

 *****************************************************************************/
/*
 *	Module:	lm_client.h v3.21
 *
 *	Description: Definitions for the license manager programs.
 *
 *	M. Christiano
 *	2/13/88
 *
 *	Last changed:  9/29/92
 *
 */

#ifndef _LM_CLIENT_H_
#define _LM_CLIENT_H_

#ifdef VMS
#include "param.h"
#else
#include <sys/param.h>
#endif

#if defined (sgi) || defined (MIPS)
#include <sys/types.h>
#endif

#if defined(MOTO_88K)
#define MAXPATHLEN 1024
#endif
#if defined(sco)
#define MAXPATHLEN PATHSIZE
#endif

/*
 *	FLEXlm version
 */

#define FLEXLM_VERSION 2
#define FLEXLM_REVISION 4
#define FLEXLM_PATCH "a"
extern float FLEXlm_VERSION;	/* Actual version #, in lmgr.a */

/*
 *	Codes returned from all client library routines
 */

#define	NOCONFFILE	-1	/* Can't find license file */
#define BADFILE		-2	/* License file corrupted */
#define NOSERVER	-3	/* Cannot connect to a license server */
#define MAXUSERS	-4	/* Maximum number of users reached */
#define NOFEATURE	-5	/* No such feature exists */
#define NOSERVICE	-6	/* No TCP/IP service "license" */
#define NOSOCKET	-7	/* No socket to talk to server on */
#define BADCODE		-8	/* Bad encryption code */
#define	NOTTHISHOST	-9	/* l_host failure code */
#define	LONGGONE	-10	/* Software Expired */
#define	BADDATE		-11	/* Bad date in license file */
#define	BADCOMM		-12	/* Bad return from server */
#define NO_SERVER_IN_FILE -13	/* No servers specified in license file */
#define BADHOST		-14	/* Bad SERVER hostname in license file */
#define CANTCONNECT	-15	/* Cannot connect to server */
#define CANTREAD	-16	/* Cannot read from server */
#define CANTWRITE	-17	/* Cannot write to server */
#define NOSERVSUPP	-18	/* Server does not support this feature */
#define SELECTERR	-19	/* Error in select system call */
#define SERVBUSY	-20	/* Application server "busy" (connecting) */
#define OLDVER		-21	/* Config file doesn't support this version */
#define CHECKINBAD	-22	/* Feature checkin failed at daemon end */
#define BUSYNEWSERV	-23	/* Server busy/new server connecting */
#define USERSQUEUED	-24	/* Users already in queue for this feature */
#define	SERVLONGGONE	-25	/* Version not supported at server end */
#define	TOOMANY		-26	/* Request for more licenses than supported */
#define CANTREADKMEM	-27	/* Cannot read /dev/kmem */
#define CANTREADVMUNIX	-28	/* Cannot read /vmunix */
#define CANTFINDETHER	-29	/* Cannot find ethernet device */
#define NOREADLIC	-30	/* Cannot read license file */
#define	TOOEARLY	-31	/* Start date for feature not reached */
#define	NOSUCHATTR	-32	/* No such attr for lm_set_attr/ls_get_attr */
#define	BADHANDSHAKE	-33	/* Bad encryption handshake with server */
#define CLOCKBAD	-34	/* Clock difference too large between 
							client/server */
#define FEATQUEUE	-35	/* We are in the queue for this feature */
#define FEATCORRUPT	-36	/* Feature database corrupted in daemon */
#define BADFEATPARAM	-37	/* dup_select mismatch for this feature */
#define FEATEXCLUDE	-38	/* User/host on EXCLUDE list for feature */
#define FEATNOTINCLUDE	-39	/* User/host not in INCLUDE list for feature */
#define CANTMALLOC	-40	/* Cannot allocate dynamic memory */
#define NEVERCHECKOUT	-41	/* Feature never checked out (lm_status()) */
#define BADPARAM	-42	/* Invalid parameter */
#define NOKEYDATA	-43	/* No FLEXlm key data */
#define BADKEYDATA	-44	/* Invalid FLEXlm key data */
#define FUNCNOTAVAIL	-45	/* FLEXlm function not available */
#define DEMOKIT		-46	/* FLEXlm software is demonstration version */
#define NOCLOCKCHECK	-47	/* Clock check not available in daemon */
#define BADPLATFORM	-48	/* FLEXlm platform not enabled */
#define DATE_TOOBIG	-49	/* Date too late for binary format */
#define EXPIREDKEYS	-50	/* FLEXlm key data has expired */
#define NOFLEXLMINIT	-51	/* FLEXlm not initialized */
#define NOSERVRESP	-52	/* Server did not respond to message */
#define CHECKOUTFILTERED -53	/* Request rejected by vendor-defined filter */
#define NOFEATSET 	-54	/* No FEATURESET line present in license file */
#define BADFEATSET 	-55	/* Incorrect FEATURESET line in license file */
#define CANTCOMPUTEFEATSET -56	/* Cannot compute FEATURESET line */
#define SOCKETFAIL	-57	/* socket() call failed */
#define SETSOCKFAIL	-58	/* setsockopt() failed */
#define BADCHECKSUM	-59	/* message checksum failure */
#define SERVBADCHECKSUM	-60	/* server message checksum failure */
#define SERVNOREADLIC	-61	/* Cannot read license file from server */
#define NONETWORK	-62	/* Network software (tcp/ip) not available */
#define NOTLICADMIN	-63	/* Not a license administrator */
#define REMOVETOOSOON	-64	/* lmremove request too soon */

/*
 *	Values for the "flag" parameter in the lm_checkout() call
 */

#define LM_CO_NOWAIT	0	/* Don't wait, report status */
#define LM_CO_WAIT	1	/* Don't return until license is available */
#define LM_CO_QUEUE	2	/* Put me in the queue, return immediately */
#define LM_CO_LOCALTEST	3	/* Perform local checks, no checkout */
#define LM_CO_TEST	4	/* Perform all checks, no checkout */

/*
 *	Parameter values for the checkout "group_duplicates" parameter
 *	In order to specify what constitutes a duplicate, 'or' together
 *	from the set { LM_DUP_USER LM_DUP_HOST LM_DUP_DISP LM_DUP_VENDOR}, 
 *	or use:
 *		LM_DUP_NONE or LM_DUP_SITE.  
 */
#define LM_DUP_NONE 0x4000	/* Don't allow any duplicates */
#define LM_DUP_SITE   0		/* Nothing to match => everything matches */
#define LM_DUP_USER   1		/* Allow dup if user matches */
#define LM_DUP_HOST   2		/* Allow dup if host matches */
#define LM_DUP_DISP   4		/* Allow dup if display matches */
#define LM_DUP_VENDOR 8		/* Allow dup if vendor-defined matches */
#define LM_COUNT_DUP_STRING "16384"	/* For ls_vendor.c: LM_DUP_NONE */
#define LM_NO_COUNT_DUP_STRING "3"	/* For ls_vendor.c: _USER | _HOST */

#define RESERVED_SERVER "SERVER"
#define RESERVED_PROG "DAEMON"
#define RESERVED_FEATURE "FEATURE"
#define RESERVED_FEATURESET "FEATURESET"

#define MAX_FEATURE_LEN 30		/* Longest featurename string */
#define DATE_LEN	11		/* dd-mmm-yyyy */
#define MAX_CONFIG_LINE	200		/* Maximum length of a configuration 
							file line */
#define	MAX_SERVER_NAME	32		/* Maximum FLEXlm length of hostname */
#define	MAX_HOSTNAME	64		/* Maximum length of a hostname */
#define	MAX_DISPLAY_NAME 32		/* Maximum length of a display name */
#define MAX_USER_NAME 20		/* Maximum length of a user name */
#define MAX_VENDOR_CHECKOUT_DATA 32	/* Maximum length of vendor-defined */
					/*		checkout data       */
#define MAX_DAEMON_NAME 10		/* Max length of DAEMON string */
#define MAX_SERVERS	5		/* Maximum number of servers */
#define MAX_USER_DEFINED 64		/* Max size of vendor-defined string */
#define MAX_VER_LEN 10			/* Maximum length of a version string */
#define MAX_LONG_LEN 10			/* Length of a long after sprintf */
#define MAX_SHORT_LEN 5			/* Length of a short after sprintf */
#define MAX_INET 16			/* Maximum length of INET addr string */
#define MAX_BINDATE_YEAR 2027		/* Binary date has 7-bit year */

/*
 *	License file location
 */

#define LM_DEFAULT_ENV_SPEC "LM_LICENSE_FILE"	/* How a user can specify */

#ifdef VMS
#define LM_DEFAULT_LICENSE_FILE "SYS$COMMON:[SYSMGR]FLEXLM.DAT"
#else
#define LM_DEFAULT_LICENSE_FILE "/usr/local/flexlm/licenses/license.dat"
#endif

/*
 *	V1/V2 compatibility macros
 */
#define _lm_errno lm_cur_job->lm_errno
#define uerrno lm_cur_job->u_errno   /* Unix errno corresponding to _lm_errno */

/*
 *	Structure types
 */

#define VENDORCODE_BIT64	1	/* 64-bit code */
#define VENDORCODE_BIT64_CODED	2	/* 64-bit code with feature data */
#define LM_DAEMON_INFO_TYPE	101	/* DAEMON_INFO data structure */
#define LM_JOB_HANDLE_TYPE	102	/* Job handle */
#define LM_LICENSE_HANDLE_TYPE	103	/* License handle */
#define LM_FEATURE_HANDLE_TYPE	104	/* Feature handle */
/*
 *	Host identification data structure
 */
typedef struct hostid {			/* Host ID data */
			short override;	/* Hostid checking override type */
#define NO_EXTENDED 1			/* Turn off extended hostid */
#define DEMO_SOFTWARE 2			/* DEMO software, no hostid */
			short type;	/* Type of HOST ID */
#define	NOHOSTID 0
#define HOSTID_LONG 1			/* Longword hostid, eg, SUN */
#define HOSTID_ETHER 2			/* Ethernet address, eg, VAX */
#define HOSTID_ANY 3			/* Any hostid */
#define HOSTID_USER 4			/* Username */
#define HOSTID_DISPLAY 5		/* Display */
#define HOSTID_HOSTNAME 6		/* Node name */
			union {
				long data;
#define ETHER_LEN 6			/* Length of an ethernet address */
				unsigned char e[ETHER_LEN];
				char user[MAX_USER_NAME+1];
				char display[MAX_DISPLAY_NAME+1];
				char host[MAX_HOSTNAME+1];
			      } id;
#define hostid_value id.data
#define hostid_eth id.e
#define hostid_user id.user
#define hostid_display id.display
#define hostid_hostname id.host
		      } HOSTID;
#define HOSTID_USER_STRING "USER="
#define HOSTID_HOSTNAME_STRING "HOSTNAME="
#define HOSTID_DISPLAY_STRING "DISPLAY="

#define MAX_CRYPT_LEN 20	/* use 8 bytes of encrypted return string to
				   produce a 16 char HEX representation  + 4 */

/*
 *	Vendor encryption seed
 */

typedef struct vendorcode {
			    short type;	    /* Type of structure */
			    long data[2];   /* 64-bit code */
			  } VENDORCODE;

typedef struct vendorcode2 {
			    short type;	   /* Type of structure */
			    long data[2];  /* 64-bit code */
			    long keys[3];  
					   
					   
			  } VENDORCODE2;

#define LM_CODE(name, x, y, k1, k2, k3)  static VENDORCODE2 name = \
						{ VENDORCODE_BIT64_CODED, \
						  (x), (y), (k1), (k2), (k3) }

#define LM_CODE_GLOBAL(name, x, y, k1, k2, k3)  VENDORCODE2 name = \
						{ VENDORCODE_BIT64_CODED, \
						  (x), (y), (k1), (k2), (k3) }

/*
 *	Server data from the license file FEATURE file
 */
typedef struct lm_server {		/* License servers */
			    char name[MAX_HOSTNAME+1];	/* Hostname */
			    struct hostid id;		/* hostid */
			    struct lm_server *next;	/* NULL =none */
				/* Fields below are only used in servers */
			    int fd1;	/* File descriptor for output */
			    int fd2;	/* File descriptor for input */
			    int state;	/* State of connection on fd1 */
			    int us;	/* "the host we are running on" flag */
			    int port;	/* What internet port # to use */
			    long exptime; /* When this connection attempt
						times out */
			  } LM_SERVER;

/*
 *	Feature data from the license file FEATURE file
 */
typedef struct config {			/* Feature data line */
			char feature[MAX_FEATURE_LEN+1]; /* Ascii name */
			double version;			/* Feature's version */
			char daemon[MAX_DAEMON_NAME+1];	/* DAEMON to serve */
			char date[DATE_LEN+1];		/* Expiration date */
			int users;			/* Licensed # users */
			char code[MAX_CRYPT_LEN+1];	/* encryption code */
			char user_string[MAX_USER_DEFINED+1];
						    /* User-defined string */
			struct hostid id;		/* Licensed host */
			LM_SERVER *server;		/* License server(s) */
			int lf;				/* License file index */
			struct config *next;		/* Ptr to next one */
		      } CONFIG;

/*
 *	License file pointer returned by l_open_file()
 */

#ifndef FILE
#include <stdio.h>
#endif

typedef struct license_file {
			      struct license_file *next;
			      int type;	/* Type of pointer */
#define LF_NO_PTR	0			/* Nothing */
#define LF_FILE_PTR	1			/* (FILE *) */
#define LF_STRING_PTR	2			/* In-memory string */
			      union {
					FILE *f;
					struct str {
							char *s;
							char *cur;
						   } str;
				    } ptr;
			    } LICENSE_FILE, *LF_POINTER;

/*
 *	User customization - CLIENT LIBRARY use only
 */
typedef void (*PFV)();

typedef struct lm_options {

#ifdef VMS
	int ef_1;		/* Three event flags for various timers */
	int ef_2;
	int ef_3;
#endif
	short decrypt_flag;	/* Controls whether encryption/decryption
							happens on lm_start */
	short disable_env;	/* Don't allow LM_LICENSE_FILE as location */
	char config_file[MAXPATHLEN+1];	/* The license file */
	short crypt_case_sensitive; 
				/* If <>0, encryption code in license file
						is case-sensitive. */
	short got_config_file;	/* Flag to indicate whether config_file
							is filled in */
	int check_interval;	/* Check interval (sec) (- implies no check) */
	int retry_interval;	/* Reconnection retry interval */
	int timer_type;
	int retry_count;	/* Number of reconnection retrys */
	int conn_timeout;	/* How long to wait for connect to complete */
	short normal_hostid;	/* 0 for extended, <> 0 for normal checking */
	int (*user_exitcall)();	/* Pointer to (user-supplied) exit handler */
	int (*user_reconnect)();	/* Pointer to (user) reconnection handler */
	int (*user_reconnect_done)();	
				/* Pointer to reconnection-complete handler */
	char *(*user_crypt)();	/* Pointer to (user-supplied) encryption 
							routine */
	char user_override[MAX_USER_NAME+1];	/* Override username */
	char host_override[MAX_SERVER_NAME+1];	/* Override hostname */
	char display_override[MAX_DISPLAY_NAME+1];	/* Override display */
	char vendor_checkout_data[MAX_VENDOR_CHECKOUT_DATA+1];	
				/* vendor-defined checkout data */
	int (*periodic_call)();	/* User-supplied call every few times
							thru lm_timer() */
	int periodic_count;	/* # of lm_timer() per periodic_call() */
	short no_demo;		/* Do not allow demo software */
	short any_enabled;	/* Allow "ANY" as hostid */
	short no_traffic_encrypt;	/* Do not encrypt traffic */
	short use_start_date;	/* Enforce the start date in the license file */
	int max_timediff;	/* Maximum time diff: client/server (minutes) */
	char **ethernet_boards;	/* User-supplied Ethernet device table */
				/*  list of string ptrs, ending with a
						NULL pointer */ 
	long linger_interval;	/* How long license lingers after program exit
						or checkin (seconds) */
	void (*setitimer)();	/* Substitute for setitimer() */
	PFV (*sighandler)();	/* Substitute for signal() */
	short try_old_comm;	/* Does l_connect() try old comm version code */
	short cache_file;	/* Does l_init_file() cache the LF data --
						lmgrd ONLY */
 	} LM_OPTIONS;

/*
 *	Data associated with a VENDOR (connection info, license file
 *		data pointers, etc.) - CLIENT LIBRARY use only
 */

typedef struct lm_daemon_info {
	short type;			/* Structure ID */
	struct lm_daemon_info *next;	/* Forward ptr */
	int commtype;			/* Communications type */
#define LM_TCP			1	/* TCP */
#define LM_UDP			2	/* UDP */
	int socket;			/* Socket file descriptor */
	int usecount;			/* Socket use count */
	int serialno;			/* Socket "serial #" */
	LM_SERVER *server;		/* servers associated with socket */
	char daemon[MAX_DAEMON_NAME+1]; /* Which daemon socket refers to */
	long encryption;		/* Handshake encryption code */
	int comm_version;		/* Communications version of server */
	int comm_revision;		/* Communications rev of server */
	int our_comm_version;		/* Our current comm version */
	int our_comm_revision;		/* Our current comm rev */
	short heartbeat;		/* Send heartbeat messages (== 1 except 
							for utility programs) */
		       } LM_DAEMON_INFO;

/*
 *	Handles returned by FLEXlm
 */

typedef struct lm_handle {
			   int type;		/* Type of struct */
			   LM_DAEMON_INFO *daemon; /* Daemon data */
			   LM_OPTIONS *options;	/* Options for this job */
			   int lm_errno;	/* Most recent error */
			   int u_errno;		/* unix error (errno) 
						   corresponding to lm_errno */
			   CONFIG *line;	/* Pointer to list of license 
							file lines */
			   char **lic_files;	/* Array of license file names*/
			   int lfptr;		/* Current license file ptr */
			   LF_POINTER license_file_pointers;
						/* LF data pointers */
#define LFPTR_INIT -1
#define LFPTR_FILE1 0 
			   VENDORCODE code;	/* Encryption code */
			 } LM_HANDLE;	/* Handle returned by certain calls */

typedef struct lm_license_handle {
				   int type;	/* LM_LICENSE_HANDLE_TYPE */
				   int handle;	/* License handle from daemon */
				 } LM_LICENSE_HANDLE;
		
typedef struct lm_feature_handle {
				   int type;	/* LM_FEATURE_HANDLE_TYPE */
				   char *code;	/* Encryption code from license
						   file line */
				 } LM_FEATURE_HANDLE;
		

/*
 *	User data returned from the license server
 */
typedef struct lm_users {
			   struct lm_users *next;
			   char name[MAX_USER_NAME + 1];
			   char node[MAX_SERVER_NAME + 1];
			   char display[MAX_DISPLAY_NAME + 1];
			   char vendor_def[MAX_VENDOR_CHECKOUT_DATA + 1];
			   int nlic;	/* Number of licenses */
			   short opts;	/* options flag */
#define INQUEUE		0x1	/* User is in queue */
#define HOSTRES		0x2	/* Reservation for a host "node" */
#define USERRES		0x4	/* Reservation for user "name" */
#define DISPLAYRES	0x8	/* Reservation for display "name" */
#define GROUPRES	0x10	/* Reservation for group "name" */
#define INTERNETRES	0x20	/* Reservation for internet "name" */
#define lm_isres(x) ((x) & (HOSTRES | USERRES | DISPLAYRES | GROUPRES | INTERNETRES))
						/* This is a reservation */
			   long time;		/* Seconds value from timeval */
			   double version;	/* Version of software */
			   long linger;		/* Linger interval */
			   LM_SERVER *server;	/* License server */
			   LM_LICENSE_HANDLE license; /* License handle */
			   LM_FEATURE_HANDLE feature; /* feature handle */
			 } LM_USERS;


typedef struct _lm_setup_data {			/* OBSOLETE in FLEXlm v2.0 */
				short decrypt_flag;	
				int timer_type;
				int check_interval, retry_count, retry_interval;
				int (*reconnect)(), (*reconnect_done)();
				int (*exitcall)();
				char *(*crypt)();
				short crypt_case_sensitive;
				int conn_timeout;
				char config_file[MAXPATHLEN+1];
				short disable_env, normal_hostid;
				char user_override[MAX_USER_NAME+1];
				char host_override[MAX_SERVER_NAME+1];
				int (*periodic_call)(), periodic_count;
				short no_demo, no_traffic_encrypt;
				short use_start_date;
				int max_timediff;
				char display_override[MAX_DISPLAY_NAME+1];
#ifdef VMS
				int ef_1, ef_2, ef_3;
#endif
			} SETUP_DATA;

/*
 *	These definitions are here so client software doesn't need
 *	<sys/time.h>
 */
#define LM_REAL_TIMER    1234
#define LM_VIRTUAL_TIMER 4321

/*
 *	Some function types
 */

extern CONFIG *lm_auth_data();
extern char *lm_daemon();
extern char *lm_display();
extern char *lm_errstring();
extern char **lm_feat_list();
extern char *lm_feat_set();
extern CONFIG *lm_get_config();
extern HOSTID *lm_gethostid();
extern HOSTID *lm_getid_type();
extern char *lm_hostname();
extern char *lm_lic_where();
extern CONFIG *lm_next_conf();
extern CONFIG *lm_test_conf();
extern LM_USERS *lm_userlist();
/*
 *	The current job handle
 */
extern LM_HANDLE *lm_cur_job;

extern char *lm_username();
typedef struct hosttype { 
			  int code; 	/* machine type (see lm_hosttype.h) */
			  char *name; 	/* Machine name, eg. sun 3/50 */
#define MAX_HOSTTYPE_NAME 50		/* Longest hosttype name length */
			  int flexlm_speed; /* Speed determined at run time */
			  int vendor_speed; /* Speed claim by vendor */
			} HOSTTYPE;
extern HOSTTYPE *lm_hosttype();

/*
 *	Alternate definitions for SPARC COMPLIANT code
 */
#ifdef SPARC_COMPLIANT
#define LIS_HELLO		LM_HELLO
#define LIS_REREAD		LM_REREAD
#define LIS_TRY_ANOTHER		LM_TRY_ANOTHER
#define LIS_OK			LM_OK
#define LIS_NO_SUCH_FEATURE	LM_NO_SUCH_FEATURE
#ifndef SPARC_COMPLIANT_FUNCS
#define SPARC_COMPLIANT_FUNCS
#define lm_daemon lis_daemon
#define lm_feat_list lis_feat_list
#define lm_flush_config lis_flush_config
#define lm_free_daemon_list lis_free_daemon_list
#define lm_get_config lis_get_config
#define lm_get_dlist lis_get_dlist
#define l_master_list lis_master_list
#define lm_next_conf lis_next_conf
#endif	/* ndef SPARC_COMPLIANT_FUNCS */
#endif /* SPARC_COMPLIANT */

#endif /* _LM_CLIENT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\loader.h ===
/*[
 *	Name:           loader.h
 *
 *      Author:        	Jerry Kramskoy
 *
 *      Created On:    	22 April 1993
 *
 *      Sccs ID:        @(#)loader.h	1.8 03/02/95
 *
 *      Purpose:      	dynamic loader for jcode derived binary
 *
 *      Design document:/HWRD/SWIN/JCODE/lnkload
 *
 *      Test document:
 *
 *      (c) Copyright Insignia Solutions Ltd., 1993. All rights reserved
]*/



/*===========================================================================*/
/*			INTERFACE DATA TYPES				     */
/*===========================================================================*/




/*===========================================================================*/
/*			INTERFACE GLOBALS   				     */
/*===========================================================================*/


/*===========================================================================*/
/*			HOST PROVIDED PROCEDURES			     */
/*===========================================================================*/

extern VOID host_set_data_execute IPT2(IU8, *base, IU32, size);


/*===========================================================================*/
/*			INTERFACE PROCEDURES				     */
/*===========================================================================*/

/* link/load jcode object files */

typedef void (*VFUNC)();

extern	IBOOL	JLd IPT4(CHAR *, executable, IUH, version, IU32 *, err,
	VFUNC, allocCallback);

/* get load address of base of typed segment */
extern	IUH	JSegBase 	IPT1(IUH, segType);

/* get load address of base of typed segment */
extern	IUH	JSegLength	IPT1(IUH, segType);

/* free up loader data structures once all address queries have been done */
extern	void	JLdRelease	IPT0();

/* free up segments regardless of discardable attribute */
extern void   JLdReleaseAll IPT0();

extern IUH JCodeSegBase IPT0();
extern IUH JCodeSegLength IPT0();
extern IUH JLookupSegBase IPT0();
extern IUH JLookupSegLength IPT0();
extern IUH JCleanupSegBase IPT0();
extern IUH JCleanupSegLength IPT0();

/* interface notes
   ---------------

   To load an already linked jcode object file:

   CHAR *ldReqs[] = {
	"fileA"
   };

   IBOOL loadSuccess = Jld("fileA", &err);
   if (!loadSuccess)
   {
	if (err == JLD_NOFILE_ERR)
		missing file ...
	else
	if (err == JLD_BADFILE_ERR)
		errors in obj.file ...
	else
	if (err == JLD_UNRESOLVED_ERR)
		cant use, cos unresolved refs ...
	else
	if (err == JLD_BADMACH_ERR)
		cant use, cos binary is for wrong machine type!!!
	else
	if (err == JLD_VERSION_MISMATCH)
		cant use, cos binary does not match KRNL286.EXE
   }


   Then query for addresses ...

   apiLookUpBase = JSegBase(JLD_APILOOKUP);

   Once all addresses have been determined ...

   JLdRelease();

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\lm_code.h ===
/* This file comes from Highland Software ... Applies to FLEXlm Version 2.4c */
/* @(#)lm_code.h	1.4 08/19/94 */
/******************************************************************************

	    COPYRIGHT (c) 1990, 1992 by Globetrotter Software Inc.
	This software has been provided pursuant to a License Agreement
	containing restrictions on its use.  This software contains
	valuable trade secrets and proprietary information of 
	Globetrotter Software Inc and is protected by law.  It may 
	not be copied or distributed in any form or medium, disclosed 
	to third parties, reverse engineered or used in any manner not 
	provided for in said License Agreement except with the prior 
	written authorization from Globetrotter Software Inc.

 *****************************************************************************/
/*	
 *	Module:	lm_code.h v3.3
 *
 *	Description: 	Encryption codes to be used in a VENDORCODE macro 
 *			for FLEXlm daemons, create_license, lm_init(),
 *			and lm_checkout() call - modify these values 
 *			for your own use.  (The VENDOR_KEYx values
 *			are assigned by Highland Software).
 *
 *	example LM_CODE() macro:
 *
 *		LM_CODE(var_name, ENCRYPTION_CODE_1, ENCRYPTION_CODE_2,
 *				VENDOR_KEY1, VENDOR_KEY2, VENDOR_KEY3);
 *
 */

/*
 *	VENDOR's private encryption seed
 */

#define ENCRYPTION_CODE_1 0x75ac39bf
#define ENCRYPTION_CODE_2 0x4fd10552

/*
 * Encryption keys for DOS application licensing
 */

#define DAL_ENCRYPTION_CODE_1 0xf26b9ea0
#define DAL_ENCRYPTION_CODE_2 0x4c251cb6

/*
 *	FLEXlm vendor keys
 */

#define VENDOR_KEY1 0x2751aaa6
#define VENDOR_KEY2 0x984ecf13
#define VENDOR_KEY3 0x23916ef3

/*
 *	FLEXlm vendor name
 */

#define VENDOR_NAME "insignia"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\lq2500.h ===
/*[
 *		Name:			LQ2500.h
 *
 *		Derived from:	nowhere
 *
 *		Author:			Chris Paterson
 *
 *		Created on:		11:44:05  25/7/1991
 *
 *		Purpose:		This file is the interface to the base part of an LQ-2500 printer
 *						emulator.  It takes a text stream from the host_get_next_print_byte
 *						routine in host code and calls a set of host dependent routines
 *						that provide a generic interface to the host's printing facilities.
 *
 *		SccsId:			@(#)LQ2500.h	1.3 09/02/94
 *		(c) Copyright Insignia Solutions Ltd., 1991.  All rights reserved.
]*/


/* constants */

#define	EPSON_STANDARD	0		/* character sets */
#define	EPSON_IBM		1
#define	USER_DEFINED	2

#define	USA			0
#define	FRANCE		1
#define	GERMANY		2
#define	UK			3
#define	DENMARK_1	4
#define	SWEDEN		5
#define	ITALY		6
#define	SPAIN_1		7
#define	JAPAN		8
#define	NORWAY		9
#define	DENMARK_2	10
#define	SPAIN_2		11
#define	LATIN_AMERICA	12
#define	MAX_COUNTRY	12

#define	FONT_NAME_SIZE	31		/* characters in a pstring */


/* Types... */

/* LQ2500-specific initial settings struct... */
typedef struct LQconfig {
	IU8	autoLF;
	UTINY	font;			// not used
	TINY	pitch;
	IU8	condensed;
	USHORT	pageLength;		// in half-inch units
	USHORT	leftMargin;		// in columns
	USHORT	rightMargin;
	TINY	cgTable;
	TINY	country;
	/* These are used by the host bit of the LQ2500: */
	SHORT	monoSize;
	SHORT	propSize;
	CHAR	monoFont[FONT_NAME_SIZE+1];			// pascal strings
	CHAR	proportionalFont[FONT_NAME_SIZE+1];
} LQconfig;


/*  Globals... */
IMPORT LQconfig SelecType;


/* Prototypes: */

IMPORT	VOID		Emulate_LQ2500(VOID);
IMPORT	VOID		Reset_LQ2500(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\low_intp.h ===
/* File             : low_intp.h
 *
 * Description      : Low-level routines for emulators called from host_print_doc().
 *
 * Author           : David Rees
 *
 * SccsId			: @(#)low_intp.h	1.6 09/23/94
 *
 * Mods:
 *		<chrisP 27Jul91>
 *		Added LQ2500 emulation - insignia.h'ified, etc
 *		These routines are sort of printer independent.  The idea is that when
 *		a new printer emulation is added, these routines can be added to,
 *		stubbed out, and change their behaviour depending on the currently
 *		selected printer.  The same goes for the #DEFINEs.
 */

/* constants */

#define	CONDENSED	0x01		/* squash chars down to 60% */
#define	DOUBLE_WIDTH	0x02	/* expand chars up to 200% */

#define	EMPHASIZED	0x01		/* like bold */
#define	DOUBLE_STRIKE	0x02	/* like bold */
#define	UNDERLINE	0x04
#define	ITALIC		0x08
#define	SUPER		0x10		/* super and sub script */
#define	SUB			0x20

#define	PROPORTIONAL	-1
#define	PICA		0
#define	ELITE		1
#define	CPI15		2			/* 15 Char per inch */

#define	LQ_ROMAN		0		/* EPSON LQ font numbers */
#define	LQ_SANS_SERIF	1
#define	LQ_COURIER		2
#define	LQ_PRESTIGE		3
#define	LQ_SCRIPT		4
#define	MAX_FONT		4

/* printer emulation globals... */

IMPORT	SHORT	PrintError;			/* set to tell emulations to abort */
IMPORT	SHORT	HResolution;		/* set by emulation to establish scaling ... */
IMPORT	SHORT	VResolution;		/* ... for MoveHead() routine. */

IMPORT	SHORT	CurrentCol;			/* current print head position ... */
IMPORT	SHORT	CurrentRow;			/* ... at emulated printer resolution */
IMPORT	SHORT	BufferWidth;		/* width of chars in print buffer (ditto) */

/* Prototypes... */

IMPORT	BOOL	host_auto_LF_for_print(VOID);
IMPORT	SHORT	host_get_next_print_byte(VOID);

IMPORT	VOID		host_PrintChar(IU8 ch);
IMPORT	VOID		host_PrintBuffer(IU8 mode);
IMPORT	VOID		host_EjectPage(VOID);
IMPORT	VOID		host_CancelBuffer(VOID);
IMPORT	VOID		host_DeleteCharacter(VOID);
IMPORT	VOID		host_SetScale(SHORT type);
IMPORT	VOID		host_ReSetScale(SHORT type);
IMPORT	VOID		host_SetStyle(SHORT type);
IMPORT	VOID		host_ReSetStyle(SHORT type);
IMPORT	VOID		host_SelectPitch(TINY Pitch);
IMPORT	VOID		host_SelectFont(TINY Font);
IMPORT	VOID		host_ProcessGraphics(TINY mode, SHORT colLeft);
IMPORT	VOID		host_LqClearUserDefined(VOID);
IMPORT	VOID		host_LqPrintUserDefined(IU8 ch);
IMPORT	BOOL		host_LqDefineUserDefined(SHORT offset, SHORT columns, IU8 ch);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\mark_ima.h ===
/*[
	Name:		mark_image.h
	Derived From:	base 2.0 (markformicon)
	Author:		gvdl
	Created On:	7 May 1991
	Sccs ID:	08/10/92 @(#)mark_image.h	1.3
	Purpose:	Defines an image for hunter error marking.
	Notes:		insignia.h must be included prior to this file.

	Format_version:		1
	Width:			64
	Height:			64
	Depth:			1
	Valid_bits_per_item:	16

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

#define MARK_HEIGHT	64
#define MARK_WIDTH	64
#define MARK_DEPTH	1
#define MARK_BYTES	8

LOCAL USHORT mark_image[256] =
{
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x000E, 0x0000, 0x0000, 0x7000, 0x000F, 0x0000, 0x0000, 0xF000,
	0x000F, 0x8000, 0x0001, 0xF000, 0x0007, 0xC000, 0x0003, 0xE000,
	0x0003, 0xE000, 0x0007, 0xC000, 0x0001, 0xE000, 0x0007, 0x8000,
	0x0000, 0xF000, 0x000F, 0x0000, 0x0000, 0x3800, 0x001C, 0x0000,
	0x0000, 0x1C00, 0x0038, 0x0000, 0x0000, 0x0C00, 0x0030, 0x0000,
	0x0000, 0x0200, 0x0040, 0x0000, 0x0000, 0x0100, 0x0080, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0100, 0x0080, 0x0000, 0x0000, 0x0200, 0x0040, 0x0000,
	0x0000, 0x0C00, 0x0030, 0x0000, 0x0000, 0x1C00, 0x0038, 0x0000,
	0x0000, 0x3800, 0x001C, 0x0000, 0x0000, 0xF000, 0x000F, 0x0000,
	0x0001, 0xE000, 0x0007, 0x8000, 0x0003, 0xE000, 0x0007, 0xC000,
	0x0007, 0xC000, 0x0003, 0xE000, 0x000F, 0x8000, 0x0001, 0xF000,
	0x000F, 0x0000, 0x0000, 0xF000, 0x000E, 0x0000, 0x0000, 0x7000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\make_dis.h ===
/*[
 *	Name:		make_disk.h
 *	Derived From:	Original
 *	Author:		Philippa Watson
 *	Created On:	7 February 1992
 *	Sccs Id:	@(#)make_disk.h	1.7 08/19/94
 *	Purpose:	Interface file for make_disk.c.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
 *
]*/

#ifndef SOURCE
/* this set of macros allow to do some fancy stuff for HD creation 
   other than just simply read the data from the Data File (e.g de-compression on the fly)
   The default set is, however, equivalent to the simple case. These macros may be 
   overwritten in host_fio.h.
 */
#define	SOURCE 												HOST_FILE
#define SOURCE_DESC 										HOST_FILE_DESC
#define SOURCE_OPEN(source_desc)							host_fopen_for_read(source_desc)
#define SOURCE_READ_HEADER(buffer, size, length, source) 	host_fread_buffer(buffer, size, length, source)
#define SOURCE_READ_DATA(buffer, size, length, source) 		host_fread_buffer(buffer, size, length, source)
#define SOURCE_END(source)									host_feof(source)
#define SOURCE_CLOSE(source)								host_fclose(source)
#define SOURCE_FSEEK_ABS(source, pos)						host_fseek_abs(source, pos)
#define SOURCE_LAST_MOD_TIME(source)						getDosTimeDate(source)
#endif /* ! SOURCE */

/* This function returns 0 if the disk is successfully created; non-zero
** otherwise.
*/
IMPORT int MakeDisk IPT5(
	HOST_FILE_DESC, diskFileDesc,	/* C string, name of disk to create */
	unsigned, 	size,		/* size in Mb, no upper limit */
	char, 		disktype,	/* b for bootable, n non-bootable,
				  	v just return DOS version ID. */
	SOURCE_DESC, dataFileDesc,	/* file where the compressed Dos and */
					/* Insignia data lives */
	char, 		zeroFill );		/* z to fill disk with zeros, n don't.*/

IMPORT int MakeDiskWithDelete IPT6(
	HOST_FILE_DESC, diskFileDesc,	/* C string, name of disk to create */
	unsigned, 	size,		/* size in Mb, no upper limit */
	char, 		disktype,	/* b for bootable, n non-bootable,
				  	v just return DOS version ID. */
	SOURCE_DESC, dataFileDesc,	/* file where the compressed Dos and */
					/* Insignia data lives */
	char, 		zeroFill , /* z to fill disk with zeros, n don't, */
					/* dont and truncate the disk. */
	int , delete_source_b /* If true then delete HD source files after use. */
	) ;

#ifndef DeleteHDDataFile
IMPORT void DeleteHDDataFile IPT1( HOST_FILE_DESC , dataFileDesc ) ;
#endif /* ! DeleteHDDataFile */
#ifndef FeedbackHDCreation
IMPORT void FeedbackHDCreation IPT1( int , file_number ) ;
#endif /* ! FeedbackHDCreation */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\mda.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: Mono Display Adaptor declarations
 *
 * Description	: Definitions for users of the MDA
 *
 * Author	: David Rees
 *
 * Notes	: None
 */


/* SccsID[]="@(#)mda.h	1.4 02/23/93 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/* None */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

IMPORT VOID mda_init IPT0();
IMPORT VOID mda_term IPT0();
IMPORT VOID mda_inb IPT2(io_addr, address, half_word *, value);
IMPORT VOID mda_outb IPT2(io_addr, address, half_word, value);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\mouse16b.h ===
/*[
 *
 *	File		:	mouse16b.h
 *
 *	Derived from:	(original)
 *
 *	Purpose		:	Header file to define the interface to
 *				the 32 side bit of the 16 bit mouse driver
 *
 *				This is required because we still need the 
 *				BOPs so that the inport emulation is kept
 *				up to date
 *
 *	Author		:	Rog
 *	Date		:	22 Feb 1992
 *
 *	SCCS Gumph	:	@(#)mouse16b.h	1.2 01/11/94
 *
 *	(c) Copyright Insignia Solutions Ltd., 1992 All rights reserved
 *
 *	Modifications	:	
 *
]*/


#ifndef _MOUSE_16B_H_
#define _MOUSE_16B_H_

/* prototypes */

void mouse16bInstall IPT0( );
void mouse16bSetBitmap IPT3( MOUSE_SCALAR * , hotspotX ,
				MOUSE_SCALAR * , hotspotY ,
					word * , bitmapAddr );
void mouse16bDrawPointer IPT1( MOUSE_CURSOR_STATUS , * cursorStat );
void mouse16bShowPointer IPT1( MOUSE_CURSOR_STATUS , * cursorStat );
void mouse16bHidePointer IPT0( );

/* Data */

/* Structure containing all the entry points into the 16 bit code */

struct mouseIOTag {
	sys_addr	mouse_io;
	sys_addr	mouse_video_io;
	sys_addr	mouse_int1;
	sys_addr	mouse_version;
	sys_addr	mouse_copyright;
	sys_addr	video_io;
	sys_addr	mouse_int2;
	sys_addr	entry_point_from_32bit;
	sys_addr	int33function0;
	sys_addr	int33function1;
	sys_addr	int33function2;
	sys_addr	int33function9;
	sys_addr	current_position_x;
	sys_addr	current_position_y;
	sys_addr	mouseINB;
	sys_addr	mouseOUTB;
	sys_addr	mouseOUTW;
}	mouseIOData;

        
#endif _MOUSE_16B_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\msw_dbg.h ===
/*[
 * 	Name:		msw_dbg.h
 *
 *	Derived From:	debug.h
 *
 *	Author:		P. Ivimey-Cook
 *
 *	Created On:	7/6/94
 *
 *	SCCS ID:	@(#)msw_dbg.h	1.4 08/19/94
 *
 *	Coding Stds:	2.0
 *
 *	Purpose:	
 *			
 *
 *    Copyright Insignia Solutions Limited 1994. All rights reserved.
 *
]*/

#ifndef MSW_DBG_H
#define MSW_DBG_H

#include <stdio.h>
#include "trace.h"

/*
 * -----------------------------------------------------------------------------
 * Error & debug entry points for display driver low level functions 
 * -----------------------------------------------------------------------------
 */

#ifndef PROD

#define msw_error0(p1)		{ fputs("MSWDVR ERROR: ", trace_file); fprintf(trace_file,p1); fputc('\n', trace_file); }
#define msw_error1(p1,p2)	{ fputs("MSWDVR ERROR: ", trace_file); fprintf(trace_file,p1,p2); fputc('\n', trace_file); }
#define msw_error2(p1,p2,p3)	{ fputs("MSWDVR ERROR: ", trace_file); fprintf(trace_file,p1,p2,p3); fputc('\n', trace_file); }
#define msw_error3(p1,p2,p3,p4)	{ fputs("MSWDVR ERROR: ", trace_file); fprintf(trace_file,p1,p2,p3,p4); fputc('\n', trace_file); }

#else

#define msw_error0(p1)
#define msw_error1(pl,p2)
#define msw_error2(pl,p2,p3)
#define msw_error3(pl,p2,p3,p4)

#endif

#if !defined(PROD) && defined(MSWDVR_DEBUG)

#ifndef	newline
#define	newline	fprintf(trace_file, "\n")
#endif

extern IU32 msw_verbose;	/* general trace flags */
extern IU32 msw_enterexit;	/* enter / leave trace flags */
extern int mswdvr_debug;

/*
 * Debug levels. Higher levels get more output. Controlled by
 * variable 'mswdvr_debug'.
 */
#define MSWDLEV_SILENT	0
#define MSWDLEV_MIN	1
#define MSWDLEV_AVG	2
#define MSWDLEV_MAX	3

/* cf:  unused?? I think so. PIC
 * #define QUIET	1
 * #define MILD	(QUIET + 1)
 * #define VERBOSE (MILD + 1)
 */

/*
 * Functional Unit flags: Basically the frontend API calls.
 */
#define MSW_MISC_VERBOSE		0x00000001	/* Any Functional unit not otherwise covered */
#define MSW_BITBLT_VERBOSE		0x00000002	/* BitBlt call */
#define MSW_COLOUR_VERBOSE		0x00000004	/* ColorInfo call */
#define MSW_CONTROL_VERBOSE		0x00000008	/* Control call */
#define MSW_ENAB_DISAB_VERBOSE		0x00000010	/* Enable and Disable calls */
#define MSW_ENUM_VERBOSE		0x00000020	/* EnumDFonts and EnumObj calls */
#define MSW_OUTPUT_VERBOSE		0x00000040	/* Output call */
#define MSW_PIXEL_VERBOSE		0x00000080	/* Pixel call */
#define MSW_BITMAP_VERBOSE		0x00000100	/* Bitmap, BitmapBits calls */
#define MSW_REALIZEOBJECT_VERBOSE	0x00000200	/* RealizeObject call */
#define MSW_SCANLR_VERBOSE		0x00000400	/* ScanLR call */
#define MSW_DEVICEMODE_VERBOSE		0x00000800	/* DeviceMode call */
#define MSW_INQUIRE_VERBOSE		0x00001000	/* Inquire call */
#define MSW_CURSOR_VERBOSE		0x00002000	/* {Set,Move,Check}Cursor calls */
#define MSW_TEXT_VERBOSE		0x00004000	/* StrBlt, ExtTextOut, GetCharWidth calls */
#define MSW_DEVICEBITMAP_VERBOSE	0x00008000	/* DeviceBitmap, DeviceBitmapBits, SetDIBits, SaveScreenBitmap calls */
#define MSW_FASTBORDER_VERBOSE		0x00010000	/* FastBorder call */
#define MSW_ATTRIBUTE_VERBOSE		0x00020000	/* SetAttribute call */
#define MSW_PALETTE_VERBOSE		0x00040000	/* {Get,Set} Palette call */

/*
 * Other (lower-level) Verbose flags
 */
#define MSW_MEMTOMEM_VERBOSE		0x00080000	/* Code dealing with memory bitmaps specifically */
#define MSW_LOWLEVEL_VERBOSE		0x00100000	/* Code performing low level ops - e.g. XLib calls */
#define MSW_CONVERT_VERBOSE		0x00200000	/* (Bitmap) Conversion code */
#define MSW_INTELIO_VERBOSE		0x00400000	/* Code dealing with reading/writing M */
#define MSW_OBJECT_VERBOSE		0x00800000	/* Object routines (e.g. ObjPBrushAccess() */
#define MSW_RESOURCE_VERBOSE		0x01000000	/* Resource routines (e.g. ResAllocateXXX() */
#define MSW_WINDOW_VERBOSE		0x02000000	/* Routines dealing with windows e.g. WinOpen(), WinUMap() */
#define MSW_CACHE_VERBOSE		0x04000000	/* Routines dealing with GDI brush/pen cache */

/*
 * Generic tracing stuff to avoid nasty defines everywhere
 */

#define msw_cond(bit)		((msw_verbose & (bit)) != 0)
#define msw_cond_lev(bit, lev)	(((msw_verbose & (bit)) != 0) && (mswdvr_debug >= (lev)))
#define msw_cond_enter(bit)	((msw_enterexit & (bit)) != 0)
#define msw_cond_leave(bit)	((msw_enterexit & (bit)) != 0)
#define msw_entering_msg(fn)	fprintf(trace_file, "Entering: %s ", fn)
#define msw_exiting_msg(fn)	fprintf(trace_file, "Exiting : %s ", fn)

#define msw_do_trace(trace_bit, call)			if (msw_cond(trace_bit)) { call; }
#define msw_do_lev_trace(trace_bit, lev,call)		if (msw_cond_lev(trace_bit,lev)) { call; }

#define msw_trace_enter(trace_bit,fnname) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			newline; \
		}
#define msw_trace_enter0(trace_bit,fnname,str) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str); \
			newline; \
		}
#define msw_trace_enter1(trace_bit,fnname,str,p0) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0); \
			newline; \
		}
#define msw_trace_enter2(trace_bit,fnname,str,p0,p1) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1); \
			newline; \
		}
#define msw_trace_enter3(trace_bit,fnname,str,p0,p1,p2)	\
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2); \
			newline; \
		}
#define msw_trace_enter4(trace_bit,fnname,str,p0,p1,p2,p3) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3); \
			newline; \
		}
#define msw_trace_enter5(trace_bit,fnname,str,p0,p1,p2,p3,p4) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3,p4); \
			newline; \
		}
#define msw_trace_enter6(trace_bit,fnname,str,p0,p1,p2,p3,p4,p5) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3,p4,p5); \
			newline; \
		}
#define msw_trace_enter7(trace_bit,fnname,str,p0,p1,p2,p3,p4,p5,p6) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3,p4,p5,p6); \
			newline; \
		}
#define msw_trace_enter8(trace_bit,fnname,str,p0,p1,p2,p3,p4,p5,p6,p7) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3,p4,p5,p6,p7); \
			newline; \
		}
#define msw_trace_enter9(trace_bit,fnname,str,p0,p1,p2,p3,p4,p5,p6,p7,p8) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3,p4,p5,p6,p7,p8); \
			newline; \
		}
#define msw_trace_enter10(trace_bit,fnname,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9); \
			newline; \
		}
#define msw_trace_enter11(trace_bit,fnname,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10); \
			newline; \
		}
#define msw_trace_enter12(trace_bit,fnname,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11) \
		if (msw_cond_enter(trace_bit)) { \
			msw_entering_msg(fnname); \
			fprintf(trace_file,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11); \
			newline; \
		}

#define msw_trace_leave(trace_bit,fnname)		if (msw_cond_leave(trace_bit)) { msw_exiting_msg(fnname);newline; }
#define msw_trace_leave0(trace_bit,fnname,str)		if (msw_cond_leave(trace_bit)) { msw_exiting_msg(fnname);fprintf(trace_file,str); newline;}
#define msw_trace_leave1(trace_bit,fnname,str, r0)	if (msw_cond_leave(trace_bit)) { msw_exiting_msg(fnname);fprintf(trace_file,str, r0); newline;}

#define	msw_trace0(trace_bit,str)			if (msw_cond(trace_bit)) { fprintf(trace_file, str); newline; }
#define	msw_trace1(trace_bit,str,p0)			if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0);newline; }
#define	msw_trace2(trace_bit,str,p0,p1)			if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0,p1);newline; }
#define	msw_trace3(trace_bit,str,p0,p1,p2)		if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0,p1,p2);newline; }
#define	msw_trace4(trace_bit,str,p0,p1,p2,p3)		if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0,p1,p2,p3);newline; }
#define	msw_trace5(trace_bit,str,p0,p1,p2,p3,p4)	if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0,p1,p2,p3,p4);newline; }
#define	msw_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5)	if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0,p1,p2,p3,p4,p5);newline; }
#define	msw_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6)	if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6);newline; }
#define	msw_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7) \
			if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6,p7); newline; }
#define	msw_trace9(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7,p8) \
			if (msw_cond(trace_bit)) { fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6,p7,p8); newline; }

#define	msw_lev_trace0(trace_bit,lev,str)		if (msw_cond_lev(trace_bit,lev)) {  fprintf(trace_file, str); newline; }
#define	msw_lev_trace1(trace_bit,lev,str,p0)		if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0);newline; }
#define	msw_lev_trace2(trace_bit,lev,str,p0,p1)		if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0,p1);newline; }
#define	msw_lev_trace3(trace_bit,lev,str,p0,p1,p2)	if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0,p1,p2);newline; }
#define	msw_lev_trace4(trace_bit,lev,str,p0,p1,p2,p3)	if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0,p1,p2,p3);newline; }
#define	msw_lev_trace5(trace_bit,lev,str,p0,p1,p2,p3,p4) \
			if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0,p1,p2,p3,p4);newline; }
#define	msw_lev_trace6(trace_bit,lev,str,p0,p1,p2,p3,p4,p5) \
			if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0,p1,p2,p3,p4,p5);newline; }
#define	msw_lev_trace7(trace_bit,lev,str,p0,p1,p2,p3,p4,p5,p6) \
			if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6);newline; }
#define	msw_lev_trace8(trace_bit,lev,str,p0,p1,p2,p3,p4,p5,p6,p7) \
			if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6,p7); newline; }
#define	msw_lev_trace9(trace_bit,lev,str,p0,p1,p2,p3,p4,p5,p6,p7,p8) \
			if (msw_cond_lev(trace_bit,lev)) { fprintf(trace_file, str,p0,p1,p2,p3,p4,p5,p6,p7,p8); newline; }


/*
** The _no_nl macros also print messages when appropriate, but they do
** not put a new line afterwards.
*/
#define	msw_trace0_no_nl(trace_bit, str)				\
		if (msw_cond(trace_bit)){ 				\
 			fprintf(trace_file, str);			\
			fflush( trace_file );				\
		}
#define	msw_trace1_no_nl(trace_bit, str, p0)				\
		if (msw_cond(trace_bit)){ 				\
 			fprintf(trace_file, str, p0);			\
			fflush( trace_file );				\
		}
#define	msw_trace2_no_nl(trace_bit, str, p0, p1)			\
		if (msw_cond(trace_bit)){	 			\
 			fprintf(trace_file, str, p0, p1);		\
			fflush( trace_file );				\
		}
#define	msw_trace3_no_nl(trace_bit, str, p0, p1, p2)			\
		if (msw_cond(trace_bit)){	 			\
 			fprintf(trace_file, str, p0, p1, p2);		\
			fflush( trace_file );				\
		}
#define	msw_trace4_no_nl(trace_bit, str, p0, p1, p2, p3)		\
		if (msw_cond(trace_bit)){	 			\
 			fprintf(trace_file, str, p0, p1, p2, p3);	\
			fflush( trace_file );				\
		}

#define	msw_lev_trace0_no_nl(trace_bit, lev, str)			\
		if (msw_cond(trace_bit,lev)){ 				\
 			fprintf(trace_file, str);			\
			fflush( trace_file );				\
		}
#define	msw_lev_trace1_no_nl(trace_bit, lev, str, p0)			\
		if (msw_cond(trace_bit,lev)){ 				\
 			fprintf(trace_file, str, p0);			\
			fflush( trace_file );				\
		}
#define	msw_lev_trace2_no_nl(trace_bit, lev, str, p0, p1)		\
		if (msw_cond(trace_bit,lev)){	 			\
 			fprintf(trace_file, str, p0, p1);		\
			fflush( trace_file );				\
		}
#define	msw_lev_trace3_no_nl(trace_bit, lev, str, p0, p1, p2)		\
		if (msw_cond(trace_bit,lev)){	 			\
 			fprintf(trace_file, str, p0, p1, p2);		\
			fflush( trace_file );				\
		}
#define	msw_lev_trace4_no_nl(trace_bit, lev, str, p0, p1, p2, p3)	\
		if (msw_cond(trace_bit,lev)){	 			\
 			fprintf(trace_file, str, p0, p1, p2, p3);	\
			fflush( trace_file );				\
		}

#else   /* !defined(PROD) && !defined(MSWDVR_DEBUG) */

/*
 * PROD or non_MSWDVR-debug flags.
 */
#define	msw_trace_enter(trace_bit,nm)
#define	msw_trace_enter0(trace_bit,nm,str)
#define	msw_trace_enter1(trace_bit,nm,str,p0)
#define	msw_trace_enter2(trace_bit,nm,str,p0,p1)
#define	msw_trace_enter3(trace_bit,nm,str,p0,p1,p2)
#define	msw_trace_enter4(trace_bit,nm,str,p0,p1,p2,p3)
#define	msw_trace_enter5(trace_bit,nm,str,p0,p1,p2,p3,p4)
#define	msw_trace_enter6(trace_bit,nm,str,p0,p1,p2,p3,p4,p5)
#define	msw_trace_enter7(trace_bit,nm,str,p0,p1,p2,p3,p4,p5,p6)
#define	msw_trace_enter8(trace_bit,nm,str,p0,p1,p2,p3,p4,p5,p6,p7)
#define	msw_trace_enter9(trace_bit,nm,str,p0,p1,p2,p3,p4,p5,p6,p7,p8)
#define	msw_trace_enter10(trace_bit,nm,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9)
#define	msw_trace_enter11(trace_bit,nm,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10)
#define	msw_trace_enter12(trace_bit,nm,str,p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11)
#define	msw_trace_leave(trace_bit,nm)
#define	msw_trace_leave0(trace_bit,nm,str)
#define	msw_trace_leave1(trace_bit,nm,str,p0)

#define msw_do_trace(trace_bit,call)
#define msw_do_lev_trace(trace_bit,lev,call)

#define	msw_trace0(trace_bit,str)
#define	msw_trace1(trace_bit,str,p0)
#define	msw_trace2(trace_bit,str,p0,p1)
#define	msw_trace3(trace_bit,str,p0,p1,p2)
#define	msw_trace4(trace_bit,str,p0,p1,p2,p3)
#define	msw_trace5(trace_bit,str,p0,p1,p2,p3,p4)
#define	msw_trace6(trace_bit,str,p0,p1,p2,p3,p4,p5)
#define	msw_trace7(trace_bit,str,p0,p1,p2,p3,p4,p5,p6)
#define	msw_trace8(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7)
#define	msw_trace9(trace_bit,str,p0,p1,p2,p3,p4,p5,p6,p7,p8)
#define	msw_trace0_no_nl(trace_bit,str)
#define	msw_trace1_no_nl(trace_bit,str,p0)
#define	msw_trace2_no_nl(trace_bit,str,p0,p1)
#define	msw_trace3_no_nl(trace_bit,str,p0,p1,p2)
#define	msw_trace4_no_nl(trace_bit,str,p0,p1,p2,p3)
#define	msw_lev_trace0(trace_bit,lev,str)
#define	msw_lev_trace1(trace_bit,lev,str,p0)
#define	msw_lev_trace2(trace_bit,lev,str,p0,p1)
#define	msw_lev_trace3(trace_bit,lev,str,p0,p1,p2)
#define	msw_lev_trace4(trace_bit,lev,str,p0,p1,p2,p3)
#define	msw_lev_trace5(trace_bit,lev,str,p0,p1,p2,p3,p4)
#define	msw_lev_trace6(trace_bit,lev,str,p0,p1,p2,p3,p4,p5)
#define	msw_lev_trace7(trace_bit,lev,str,p0,p1,p2,p3,p4,p5,p6)
#define	msw_lev_trace8(trace_bit,lev,str,p0,p1,p2,p3,p4,p5,p6,p7)
#define	msw_lev_trace9(trace_bit,lev,str,p0,p1,p2,p3,p4,p5,p6,p7,p8)
#define	msw_lev_trace0_no_nl(trace_bit,lev,str)
#define	msw_lev_trace1_no_nl(trace_bit,lev,str,p0)
#define	msw_lev_trace2_no_nl(trace_bit,lev,str,p0,p1)
#define	msw_lev_trace3_no_nl(trace_bit,lev,str,p0,p1,p2)
#define	msw_lev_trace4_no_nl(trace_bit,lev,str,p0,p1,p2,p3)

#endif  /* !defined(PROD) && !defined(MSWDVR_DEBUG) */

#endif	/* MSW_DBG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\msw_keyb.h ===
/*[
 *
 * SoftPC-AT revision 3.0
 *
 * Title        : Definitions for MS-Windows keyboard driver functions.
 *
 * Description  : This file contains the definitions for msw_keybd.c.
 *
 * Author       : Jerry Sexton
 *
 * Notes        :
 *
]*/

/* SccsID[]="@(#)msw_keybd.h	1.2 08/10/92 Copyright Insignia Solutions Ltd."; */

/*
=========================================================================
 Macros.
=========================================================================
 */

/* Null pointers. */
#define TINY_NULL	((TINY *) 0)

/* General definitions. */
#define NO_NUMLOCK	0
#define NUMLOCK		1

/* Virtual keys. */

#define VK_LBUTTON	0x01
#define VK_RBUTTON	0x02
#define VK_CANCEL	0x03

/* 4..7 undefined */

#define VK_BACK		0x08
#define VK_TAB		0x09

/* 0x0a .. 0x0b undefined */

#define VK_CLEAR	0x0c
#define VK_RETURN	0x0d

#define VK_SHIFT	0x10
#define VK_CONTROL	0x11
#define VK_MENU		0x12
#define VK_PAUSE	0x13
#define VK_CAPITAL	0x14
		/* 0x15..0x1a */
#define VK_ESCAPE	0x1b
		/* 0x1c..0x1f */
#define VK_SPACE	0x20
#define VK_PRIOR	0x21	/* page up */
#define VK_NEXT		0x22	/* page down */
#define VK_END		0x23
#define VK_HOME		0x24
#define VK_LEFT		0x25
#define VK_UP		0x26
#define VK_RIGHT	0x27
#define VK_DOWN		0x28
#define VK_SELECT	0x29
#define VK_PRINT	0x2a
#define VK_EXECUTE	0x2b
#define VK_SNAPSHOT	0x2c	/* Printscreen key.. */

#define VK_INSERT	0x2d
#define VK_DELETE	0x2e
#define VK_HELP		0x2f
#define VK_0		0x30
#define VK_1		0x31
#define VK_2		0x32
#define VK_3		0x33
#define VK_4		0x34
#define VK_5		0x35
#define VK_6		0x36
#define VK_7		0x37
#define VK_8		0x38
#define VK_9		0x39
		/* 0x40 */
#define VK_A		0x41
#define VK_B		0x42
#define VK_C		0x43
#define VK_D		0x44
#define VK_E		0x45
#define VK_F		0x46
#define VK_G		0x47
#define VK_H		0x48
#define VK_I		0x49
#define VK_J		0x4a
#define VK_K		0x4b
#define VK_L		0x4c
#define VK_M		0x4d
#define VK_N		0x4e
#define VK_O		0x4f
#define VK_P		0x50
#define VK_Q		0x51
#define VK_R		0x52
#define VK_S		0x53
#define VK_T		0x54
#define VK_U		0x55
#define VK_V		0x56
#define VK_W		0x57
#define VK_X		0x58
#define VK_Y		0x59
#define VK_Z		0x5a
		/* 0x5b..0x5f */
#define VK_NUMPAD0	0x60
#define VK_NUMPAD1	0x61
#define VK_NUMPAD2	0x62
#define VK_NUMPAD3	0x63
#define VK_NUMPAD4	0x64
#define VK_NUMPAD5	0x65
#define VK_NUMPAD6	0x66
#define VK_NUMPAD7	0x67
#define VK_NUMPAD8	0x68
#define VK_NUMPAD9	0x69
#define VK_MULTIPLY	0x6a
#define VK_ADD		0x6b
#define VK_SEPARATER	0x6c
#define VK_SUBTRACT	0x6d
#define VK_DECIMAL	0x6e
#define VK_DIVIDE	0x6f

#define VK_F1		0x70
#define VK_F2		0x71
#define VK_F3		0x72
#define VK_F4		0x73
#define VK_F5		0x74
#define VK_F6		0x75
#define VK_F7		0x76
#define VK_F8		0x77
#define VK_F9		0x78
#define VK_F10		0x79
#define VK_F11		0x7a
#define VK_F12		0x7b
#define VK_F13		0x7c
#define VK_F14		0x7d
#define VK_F15		0x7e
#define VK_F16		0x7f

#define VK_OEM_F17	0x80
#define VK_OEM_F18	0x81
#define VK_OEM_F19	0x82
#define VK_OEM_F20	0x83
#define VK_OEM_F21	0x84
#define VK_OEM_F22	0x85
#define VK_OEM_F23	0x86
#define VK_OEM_F24	0x87

/* 0x88..0x8f unassigned */

#define VK_NUMLOCK	0x90
#define VK_OEM_SCROLL	0x91		/* ScrollLock */

/* 0x92..0xb9 unassigned */

#define VK_OEM_1	0xba		/* ';:' for US */
#define VK_OEM_PLUS	0xbb		/* '+' any country */
#define VK_OEM_COMMA	0xbc		/* ',' any country */
#define VK_OEM_MINUS	0xbd		/* '-' any country */
#define VK_OEM_PERIOD	0xbe		/* '.' any country */
#define VK_OEM_2	0xbf		/* '/?' for US */
#define VK_OEM_3	0xc0		/* '`~' for US */

/* 0xc1..0xda unassigned */

#define VK_OEM_4	0xdb		/* '[{' for US */
#define VK_OEM_5	0xdc		/* '\|' for US */
#define VK_OEM_6	0xdd		/* ']}' for US */
#define VK_OEM_7	0xde		/* ''"' for US */
#define VK_OEM_8	0xdf

/* codes various extended or enhanced keyboards */
#define VK_F17		0xe0		/* F17 key on ICO, win 2.xx */
#define VK_F18		0xe1		/* F18 key on ICO, win 2.xx */

#define VK_OEM_102	0xe2		/* "<>" or "\|" on RT 102-key kbd. */

#define VK_ICO_HELP	0xe3		/* Help key on ICO */
#define VK_ICO_00	0xe4		/* 00 key on ICO */

/* E5h unassigned */

#define VK_ICO_CLEAR	0xe6 */

/* E7h .. E8h unassigned */

/*	Nokia/Ericsson definitions */

#define VK_ERICSSON_BASE 0xe8

#define VK_OEM_RESET	(VK_ERICSSON_BASE + 1)	/* e9 */
#define VK_OEM_JUMP	(VK_ERICSSON_BASE + 2)	/* ea */
#define VK_OEM_PA1	(VK_ERICSSON_BASE + 3)	/* eb */
#define VK_OEM_PA2	(VK_ERICSSON_BASE + 4)	/* ec */
#define VK_OEM_PA3	(VK_ERICSSON_BASE + 5)	/* ed */
#define VK_OEM_WSCTRL	(VK_ERICSSON_BASE + 6)	/* ee */
#define VK_OEM_CUSEL	(VK_ERICSSON_BASE + 7)	/* ef */
#define VK_OEM_ATTN	(VK_ERICSSON_BASE + 8)	/* f0 */
#define VK_OEM_FINNISH	(VK_ERICSSON_BASE + 9)	/* f1 */
#define VK_OEM_COPY	(VK_ERICSSON_BASE + 10)	/* f2 */
#define VK_OEM_AUTO	(VK_ERICSSON_BASE + 11)	/* f3 */
#define VK_OEM_ENLW	(VK_ERICSSON_BASE + 12)	/* f4 */
#define VK_OEM_BACKTAB	(VK_ERICSSON_BASE + 13)	/* f5 */


/* F6h..FEh unassigned. */

/* Defines for inquireData structure. */
#define BEGINRANGE1		255
#define ENDRANGE1		254
#define BEGINRANGE2		255
#define ENDRANGE2		254
#define TO_ASCII_STATE_SIZE	4

/*
=========================================================================
 Keyboard driver structure definitions.
=========================================================================
 */
typedef struct tagKBINFO
{
	UTINY	 Begin_First_Range;
	UTINY	 End_First_Range;
	UTINY	 Begin_Second_Range;
	UTINY	 End_Second_Range;
	SHORT	 StateSize;		/* size of ToAscii state block. */
} KBINFO;

#define INTEL_KBINFO_SIZE	6	/* Size of KBINFO structure in INTEL. */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\mouse.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	:  mouse.h
 *
 * Description	: Microsoft Mouse
 *
 * Author	: 
 *
 * Notes	:
 */

/* SccsID[]="@(#)mouse.h	1.7 08/10/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

/* Mouse port number definitions. */
#if defined(NEC_98)
#define NMODE_BASE              0x7FD9
#define HMODE_BASE              0x61
#define MOUSE_PORT_START        0
#define MOUSE_PORT_END          6
#define MOUSE_PORT_0            0
#define MOUSE_PORT_1            2
#define MOUSE_PORT_2            4
#define MOUSE_PORT_3            6

#define NEC98_CPU_MOUSE_INT2     6   //INT2 Master PIC
#define NEC98_CPU_MOUSE_INT6     5   //INT6 Slave PIC

#define NEC98_CPU_MOUSE_ADAPTER0 0
#define NEC98_CPU_MOUSE_ADAPTER1 1
#else  // !NEC_98
#define MOUSE_PORT_0		0x023c
#define MOUSE_PORT_1		0x023d
#define MOUSE_PORT_2		0x023e
#define MOUSE_PORT_3		0x023f

#define MOUSE_PORT_START	0x023c
#define MOUSE_PORT_END		0x023f
#endif // !NEC_98

/* Internal mouse status word bits. */
#define LEFT_BUTTON_DOWN	0x04
#define LEFT_BUTTON_CHANGE	0x20
#define RIGHT_BUTTON_DOWN	0x01
#define RIGHT_BUTTON_CHANGE	0x08
#define MOVEMENT		0x40

/* Internal mode register word bits. */
#define HOLD			0x20

/* Inport internal registers. */
#define INTERNAL_MOUSE_STAT_REG	0x0
#define INTERNAL_DATA1_REG	0x1
#define INTERNAL_DATA2_REG	0x2
#define INTERNAL_DATA3_REG	0x3
#define INTERNAL_DATA4_REG	0x4
#define INTERFACE_STATUS_REG	0x5
#define INTERFACE_CONTROL_REG	0x6
#define INTERNAL_MODE_REG	0x7

/*
 * Maximum acceleration threshold - treated as unsigned word by supplied
 * handler routine so 0xffff is large rather than -1.
 */
#define MAX_THRESHOLD		0xffff


/* Count of the number of different bop functions. */
#define NUM_MOUSE_FUNCS		(sizeof(mouse_functions)/sizeof(SHORT (*)()))

/*
 * Definitions below are copied from MS-Windows Intel mouse driver and are
 * required to acknowledge mouse interrupts.
 */
#define ACK_PORT		0x0020
#define ACK_SLAVE_PORT		0x00a0
#define EOI			0x20
#define PMODE_WINDOWS		1
#define INPORT_MAX_INTERRUPTS	30

/*
 * Machine word bit definitions.
 */
#define BIT0	(1 << 0)
#define BIT1	(1 << 1)
#define BIT2	(1 << 2)
#define BIT3	(1 << 3)
#define BIT4	(1 << 4)
#define BIT5	(1 << 5)
#define BIT6	(1 << 6)
#define BIT7	(1 << 7)
#define BIT8	(1 << 8)
#define BIT9	(1 << 9)
#define BIT10	(1 << 10)
#define BIT11	(1 << 11)
#define BIT12	(1 << 12)
#define BIT13	(1 << 13)
#define BIT14	(1 << 14)
#define BIT15	(1 << 15)

/* Microsoft Inport mouse driver assumes mouse has 2 buttons so so do we. */
#define INPORT_NUMBER_BUTTONS	2

/* Size of Intel MOUSEINFO structure. */
#define MOUSEINFO_SIZE		14

/* Offset of fuunction parameters from frame pointer in Intel. */
#define PARAM_OFFSET		6

IMPORT void mouse_init IPT0();
IMPORT void mouse_inb IPT2(io_addr, port, half_word *, value);
IMPORT void mouse_outb IPT2(io_addr, port, half_word, value);
IMPORT void mouse_send IPT4(int, Delta_x, int, Delta_y, int, left, int, right);

IMPORT ULONG mouse_last;  /* remembers last time mouse was processed */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\mouse_io.h ===
/*
 * SoftPC Revision 3.0
 *
 * Title	: Mouse Driver Definitions
 *
 * Description	: Definitions of constants and structures used in SoftPC's 
 *		  emulation of the Microsoft Mouse Driver
 *
 * Author	: Ross Beresford
 *
 * Notes	: Values were derived from the following sources:
 *		     Microsoft Mouse User's Guide
 *		     IBM PC-XT Technical Reference Manuals
 *		     Microsoft InPort Technical Note
 */
 
/*
 * char SccsID[] = "@(#)mouse_io.h	1.27 12/21/94 Copyright Insignia Solutions Ltd."
 */

/*
 *	CONSTANTS USED IN IO FUNCTION EMULATION
 *	=======================================
 */

/*
 *	function definitions
 */
#define	MOUSE_RESET				0
#define	MOUSE_SHOW_CURSOR			1
#define	MOUSE_HIDE_CURSOR			2
#define	MOUSE_GET_POSITION			3
#define	MOUSE_SET_POSITION			4
#define	MOUSE_GET_PRESS				5
#define	MOUSE_GET_RELEASE			6
#define	MOUSE_SET_RANGE_X			7
#define	MOUSE_SET_RANGE_Y			8
#define	MOUSE_SET_GRAPHICS			9
#define	MOUSE_SET_TEXT				10
#define	MOUSE_READ_MOTION			11
#define	MOUSE_SET_SUBROUTINE			12
#define	MOUSE_LIGHT_PEN_ON			13
#define	MOUSE_LIGHT_PEN_OFF			14
#define	MOUSE_SET_RATIO				15
#define	MOUSE_CONDITIONAL_OFF			16
#define	MOUSE_UNRECOGNISED			17
#define	MOUSE_UNRECOGNISED_2			18
#define	MOUSE_SET_DOUBLE_SPEED			19
#define MOUSE_SWAP_SUBROUTINE			20
#define MOUSE_GET_STATE_SIZE			21
#define MOUSE_SAVE_STATE			22
#define MOUSE_RESTORE_STATE			23
#define MOUSE_SET_ALT_SUBROUTINE		24
#define MOUSE_GET_ALT_SUBROUTINE		25
#define MOUSE_SET_SENSITIVITY			26
#define MOUSE_GET_SENSITIVITY			27
#define MOUSE_SET_INT_RATE			28
#define MOUSE_SET_POINTER_PAGE			29
#define MOUSE_GET_POINTER_PAGE			30
#define MOUSE_DRIVER_DISABLE			31
#define MOUSE_DRIVER_ENABLE			32
#define MOUSE_SOFT_RESET			33
#define MOUSE_SET_LANGUAGE			34
#define MOUSE_GET_LANGUAGE			35
#define MOUSE_GET_INFO				36
#define	MOUSE_GET_DRIVER_INFO			37
#define	MOUSE_GET_MAX_COORDS			38
#define MOUSE_GET_MASKS_AND_MICKEYS		39
#define MOUSE_SET_VIDEO_MODE			40
#define MOUSE_ENUMERATE_VIDEO_MODES		41
#define MOUSE_GET_CURSOR_HOT_SPOT		42
#define MOUSE_LOAD_ACCELERATION_CURVES		43
#define MOUSE_READ_ACCELERATION_CURVES		44
#define MOUSE_SET_GET_ACTIVE_ACCELERATION_CURVE	45
#define MOUSE_MICROSOFT_INTERNAL		46
#define MOUSE_HARDWARE_RESET			47
#define MOUSE_SET_GET_BALLPOINT_INFO		48
#define MOUSE_GET_MIN_MAX_VIRTUAL_COORDS	49
#define MOUSE_GET_ACTIVE_ADVANCED_FUNCTIONS	50
#define MOUSE_GET_SWITCH_SETTINGS		51
#define MOUSE_GET_MOUSE_INI			52

#define	MOUSE_FUNCTION_MAXIMUM		53

#define	mouse_function_in_range(function)	\
	(function >= 0 && function < MOUSE_FUNCTION_MAXIMUM)

#define	MOUSE_SPECIAL_COPYRIGHT		0x4d
#define	MOUSE_SPECIAL_VERSION		0x6d

/*
 *	button definitions
 */
#define	MOUSE_LEFT_BUTTON		0
#define	MOUSE_RIGHT_BUTTON		1
#define	MOUSE_LEFT_BUTTON_DOWN_BIT	(1 << MOUSE_LEFT_BUTTON)
#define MOUSE_RIGHT_BUTTON_DOWN_BIT	(1 << MOUSE_RIGHT_BUTTON)

#define	mouse_button_description(x)	(x ? "DOWN" : "UP")

#define	MOUSE_BUTTON_MAXIMUM		2

#define	mouse_button_in_range(button)	\
	(button >= 0 && button < MOUSE_BUTTON_MAXIMUM)

/*
 *	mickey to pixel ratio definitions
 */
#define	MOUSE_RATIO_X_DEFAULT		8
#define	MOUSE_RATIO_Y_DEFAULT		16
#define	MOUSE_RATIO_SCALE_FACTOR	8

/*
 * The upper limit of this has been commented out, as it is redundant
 * when applied to a signed short.
 */
#define	mouse_ratio_in_range(ratio)	(ratio > 0/* && ratio <= 32767*/)
 
/*
 *	mouse sensitivity definitions
 */
#define MOUSE_SENS_MULT			100
#define MOUSE_SENS_MIN			1
#define MOUSE_SENS_MIN_VAL		(MOUSE_SENS_MULT* 1/32)
#define MOUSE_SENS_DEF			50
#define MOUSE_SENS_DEF_VAL		(MOUSE_SENS_MULT* 1)
#define MOUSE_SENS_MAX			100
#define MOUSE_SENS_MAX_VAL		(MOUSE_SENS_MULT* 14/4)

#define	mouse_sens_in_range(sens)	(sens >= MOUSE_SENS_MIN && sens <= MOUSE_SENS_MAX)

#define MOUSE_DOUBLE_DEF		50

/*
 *	text cursor definitions
 */

#define	MOUSE_TEXT_CURSOR_TYPE_SOFTWARE	0
#define	MOUSE_TEXT_CURSOR_TYPE_HARDWARE	1

#define	MOUSE_TEXT_CURSOR_TYPE_DEFAULT	MOUSE_TEXT_CURSOR_TYPE_SOFTWARE
#define	MOUSE_TEXT_CURSOR_TYPE_MAXIMUM	2

#define	mouse_text_cursor_type_in_range(type)	\
	(type >= 0 && type < MOUSE_TEXT_CURSOR_TYPE_MAXIMUM)

#define	MOUSE_TEXT_SCREEN_MASK_DEFAULT	0xffff
#define	MOUSE_TEXT_CURSOR_MASK_DEFAULT	0x7700

/*
 *	graphics cursor definitions
 */

#define	MOUSE_GRAPHICS_HOT_SPOT_X_DEFAULT	-1
#define	MOUSE_GRAPHICS_HOT_SPOT_Y_DEFAULT	-1
#define	MOUSE_GRAPHICS_CURSOR_WIDTH		16
#define	MOUSE_GRAPHICS_CURSOR_DEPTH		16

#define	MOUSE_GRAPHICS_SCREEN_MASK_DEFAULT	\
{ 0x3fff, 0x1fff, 0x0fff, 0x07ff, \
  0x03ff, 0x01ff, 0x00ff, 0x007f, \
  0x003f, 0x001f, 0x01ff, 0x10ff, \
  0x30ff, 0xf87f, 0xf87f, 0xfc3f }
#define	MOUSE_GRAPHICS_CURSOR_MASK_DEFAULT	\
{ 0x0000, 0x4000, 0x6000, 0x7000, \
  0x7800, 0x7c00, 0x7e00, 0x7f00, \
  0x7f80, 0x7fc0, 0x7c00, 0x4600, \
  0x0600, 0x0300, 0x0300, 0x0000 }

/*
 *	call mask definitions
 */
#define	MOUSE_CALL_MASK_POSITION_BIT		(1 << 0)
#define	MOUSE_CALL_MASK_LEFT_PRESS_BIT		(1 << 1)
#define	MOUSE_CALL_MASK_LEFT_RELEASE_BIT	(1 << 2)
#define	MOUSE_CALL_MASK_RIGHT_PRESS_BIT		(1 << 3)
#define	MOUSE_CALL_MASK_RIGHT_RELEASE_BIT	(1 << 4)
#define MOUSE_CALL_MASK_SHIFT_KEY_BIT		(1 << 5)
#define MOUSE_CALL_MASK_CTRL_KEY_BIT		(1 << 6)
#define MOUSE_CALL_MASK_ALT_KEY_BIT		(1 << 7)
#define	MOUSE_CALL_MASK_SIGNIFICANT_BITS \
	(MOUSE_CALL_MASK_POSITION_BIT	  |	\
	 MOUSE_CALL_MASK_LEFT_PRESS_BIT	  |	\
	 MOUSE_CALL_MASK_LEFT_RELEASE_BIT |	\
	 MOUSE_CALL_MASK_RIGHT_PRESS_BIT  |	\
	 MOUSE_CALL_MASK_RIGHT_RELEASE_BIT)
#define MOUSE_CALL_MASK_KEY_BITS \
	(MOUSE_CALL_MASK_SHIFT_KEY_BIT |	\
	 MOUSE_CALL_MASK_CTRL_KEY_BIT  |	\
	 MOUSE_CALL_MASK_ALT_KEY_BIT)
#define NUMBER_ALT_SUBROUTINES			3


/*
 *	virtual screen definitions
 */
#define	MOUSE_VIRTUAL_SCREEN_ORIGIN_X	0
#define	MOUSE_VIRTUAL_SCREEN_ORIGIN_Y	0
#define	MOUSE_VIRTUAL_SCREEN_WIDTH	640
#define MOUSE_VIRTUAL_SCREEN_DEPTH      200
/* for CGA this is used all the time, for EGA it's replaced by a variable and only used for default initialisations */


/*
 *	double speed definitions
 */
#define	MOUSE_TIMER_INTERRUPTS_PER_SECOND	30
#define	MOUSE_DOUBLE_SPEED_THRESHOLD_DEFAULT	4
#define	MOUSE_DOUBLE_SPEED_SCALE		2

/*
 *	driver state definitions
 */
#define	MOUSE_CURSOR_DISPLAYED	0
#define	MOUSE_CURSOR_DEFAULT	(MOUSE_CURSOR_DISPLAYED - 1)

#define	MOUSE_UNINSTALLED	0
#define	MOUSE_INSTALLED		(~MOUSE_UNINSTALLED)

#define MOUSE_TYPE_INPORT	3

/*
 *	conditional off area definitions
 */
#define	MOUSE_CONDITIONAL_OFF_MARGIN_X	24
#define	MOUSE_CONDITIONAL_OFF_MARGIN_Y	8

/*
 *	CONSTANTS USED IN BIOS ACCESS
 *	=============================
 */

/*
 *	Video io function numbers
 */
#define	MOUSE_VIDEO_SET_MODE		0
#ifdef V7VGA
#define	MOUSE_V7_VIDEO_SET_MODE		0x6f05
#endif /* V7VGA */
#define	MOUSE_VIDEO_SET_CURSOR		1
#define	MOUSE_VIDEO_READ_LIGHT_PEN	4
#define	MOUSE_VIDEO_WRITE_TELETYPE	14
#define	MOUSE_VIDEO_LOAD_FONT		17

/*
 *	Number of valid video modes
 */

#ifdef EGG
#ifdef VGG
#define	MOUSE_VIDEO_MODE_MAXIMUM	0x14
#else
#define	MOUSE_VIDEO_MODE_MAXIMUM	0x11	
#endif /* VGG */
#else
#define	MOUSE_VIDEO_MODE_MAXIMUM	8	
#endif


/*
 *	Video variable addresses in BIOS data area
 */
#define	MOUSE_VIDEO_CRT_MODE		0x449
#define	MOUSE_VIDEO_CRT_START		0x44e
#define	MOUSE_VIDEO_CARD_BASE		0x463

/*
 *	CONSTANTS USED IN ADAPTER ACCESS
 *	================================
 */

/*
 *	graphics adapter (CGA or MDA) definitions
 */
#define	MOUSE_CURSOR_HIGH_BYTE		0xe
#define	MOUSE_CURSOR_LOW_BYTE		0xf

#define	MOUSE_GRAPHICS_MODE_PITCH	640

/*
 *	InPort (bus mouse) adapter definitions
 */
#define	MOUSE_INPORT_ADDRESS_REG	0x23c
#define	MOUSE_INPORT_DATA_REG		0x23d
#define	MOUSE_INPORT_ID_REG		0x23e
#define	MOUSE_INPORT_TEST_REG		0x23f

#define	MOUSE_INPORT_ADDRESS_RESET_BIT	(1 << 7)

#define	MOUSE_INPORT_ADDRESS_STATUS	0x0
#define	MOUSE_INPORT_ADDRESS_DATA1	0x1
#define	MOUSE_INPORT_ADDRESS_DATA2	0x2
#define	MOUSE_INPORT_ADDRESS_DATA3	0x3
#define	MOUSE_INPORT_ADDRESS_DATA4	0x4
#define	MOUSE_INPORT_ADDRESS_IF_STATUS	0x5
#define	MOUSE_INPORT_ADDRESS_IF_CONTROL	0x6
#define	MOUSE_INPORT_ADDRESS_MODE	0x7

#define	MOUSE_INPORT_MODE_HOLD_BIT	(1 << 5)

#define	MOUSE_INPORT_STATUS_B3_STATUS_BIT	(1 << 0)
#define	MOUSE_INPORT_STATUS_B2_STATUS_BIT	(1 << 1)
#define	MOUSE_INPORT_STATUS_B1_STATUS_BIT	(1 << 2)
#define	MOUSE_INPORT_STATUS_B3_DELTA_BIT	(1 << 3)
#define	MOUSE_INPORT_STATUS_B2_DELTA_BIT	(1 << 4)
#define	MOUSE_INPORT_STATUS_B1_DELTA_BIT	(1 << 5)
#define	MOUSE_INPORT_STATUS_MOVEMENT_BIT	(1 << 6)
#define	MOUSE_INPORT_STATUS_COMPLETE_BIT	(1 << 7)

#define	MOUSE_INPORT_STATUS_B1_TRANSITION_MASK	\
	(MOUSE_INPORT_STATUS_B1_STATUS_BIT | MOUSE_INPORT_STATUS_B1_DELTA_BIT)

#define	MOUSE_INPORT_STATUS_B1_UP	\
	(0 | 0)
#define	MOUSE_INPORT_STATUS_B1_PRESSED	\
	(MOUSE_INPORT_STATUS_B1_STATUS_BIT | MOUSE_INPORT_STATUS_B1_DELTA_BIT)
#define	MOUSE_INPORT_STATUS_B1_DOWN	\
	(MOUSE_INPORT_STATUS_B1_STATUS_BIT | 0)
#define	MOUSE_INPORT_STATUS_B1_RELEASED	\
	(0 | MOUSE_INPORT_STATUS_B1_DELTA_BIT)

#define	MOUSE_INPORT_STATUS_B3_TRANSITION_MASK	\
	(MOUSE_INPORT_STATUS_B3_STATUS_BIT | MOUSE_INPORT_STATUS_B3_DELTA_BIT)

#define	MOUSE_INPORT_STATUS_B3_UP	\
	(0 | 0)
#define	MOUSE_INPORT_STATUS_B3_PRESSED	\
	(MOUSE_INPORT_STATUS_B3_STATUS_BIT | MOUSE_INPORT_STATUS_B3_DELTA_BIT)
#define	MOUSE_INPORT_STATUS_B3_DOWN	\
	(MOUSE_INPORT_STATUS_B3_STATUS_BIT | 0)
#define	MOUSE_INPORT_STATUS_B3_RELEASED	\
	(0 | MOUSE_INPORT_STATUS_B3_DELTA_BIT)

#define	MOUSE_INPORT_ID_SIGNATURE	0xde

#define	MOUSE_INPORT_MODE_VALUE		0x09


/* Conditions to determine if the mouse pointer emulation is enabled */
/*@ACW*/

#define POINTER_EMULATION_OS	 1  /* use O.S. pointer for input   */
#define POINTER_EMULATION_SOFTPC 0  /* use softpc pointer emulation */



/*
 *	DECLARATION OF PUBLIC FUNCTIONS
 *	===============================
 */

/*
 *	NB functions called via BOP instructions are declared in bios.h
 */
extern boolean mouse_tester();

/*
 *	DEFINITION OF OBJECT TYPES USED IN THE EMULATION
 *	================================================
 */

/*
 *	A bit address relative to the start of the CGA regen buffer in 
 *	graphics mode
 */
typedef sys_addr MOUSE_BIT_ADDRESS;

/*
 *	A byte address relative to the start of the CGA regen buffer in 
 *	text or graphics mode
 */
typedef sys_addr MOUSE_BYTE_ADDRESS;

/*
 *	A scalar value
 */
typedef short MOUSE_SCALAR;

/*
 *	A counter value
 */
typedef short MOUSE_COUNT;

/*
 *	A state value
 */
typedef	short MOUSE_STATE;

/*
 *	A speed value in Mickeys per timer interval
 */
typedef	short MOUSE_SPEED;

/*
 *	A user subroutine call mask
 */
typedef	unsigned short MOUSE_CALL_MASK;

/*
 *	A word of screen data
 */

typedef	unsigned short MOUSE_SCREEN_DATA;

/*
 *	32 bits of screen data for graphics mode - 1 byte replicated four times
 */

typedef	IU32 MOUSE_SCREEN_DATA_GR;

/*
 *	A vector
 */
typedef struct
{
	MOUSE_SCALAR 		x;
	MOUSE_SCALAR 		y;
} MOUSE_VECTOR;

/*
 *	A virtual screen position
 */
typedef struct
{
	MOUSE_SCALAR 		x;
	MOUSE_SCALAR 		y;
} MOUSE_POINT;

/*
 *	A virtual screen area
 */
typedef struct
{
	MOUSE_POINT 		top_left;
	MOUSE_POINT 		bottom_right;
} MOUSE_AREA;

/*
 *	A cursor status frame
 */
typedef struct
{
	MOUSE_POINT 		position;
	MOUSE_STATE 		button_status;
} MOUSE_CURSOR_STATUS;

/*
 *	A button status frame
 */
typedef struct
{
	MOUSE_POINT 		press_position;
	MOUSE_POINT 		release_position;
	MOUSE_COUNT 		press_count;
	MOUSE_COUNT 		release_count;
} MOUSE_BUTTON_STATUS;

/*
 *	A text cursor
 */
typedef struct
{
	MOUSE_SCREEN_DATA 	screen;
	MOUSE_SCREEN_DATA 	cursor;
} MOUSE_SOFTWARE_TEXT_CURSOR;

/*
 *	A graphics cursor
 */
typedef struct
{
	MOUSE_POINT 			hot_spot;
	MOUSE_VECTOR 			size;
	MOUSE_SCREEN_DATA			screen[MOUSE_GRAPHICS_CURSOR_DEPTH];
	MOUSE_SCREEN_DATA 		cursor[MOUSE_GRAPHICS_CURSOR_DEPTH];
	MOUSE_SCREEN_DATA_GR		screen_lo[MOUSE_GRAPHICS_CURSOR_DEPTH];
	MOUSE_SCREEN_DATA_GR		screen_hi[MOUSE_GRAPHICS_CURSOR_DEPTH];
	MOUSE_SCREEN_DATA_GR		cursor_lo[MOUSE_GRAPHICS_CURSOR_DEPTH];
	MOUSE_SCREEN_DATA_GR		cursor_hi[MOUSE_GRAPHICS_CURSOR_DEPTH];
} MOUSE_GRAPHICS_CURSOR;

/*
 *	An InPort data frame
 */
typedef struct
{
	half_word		status;
	signed_char		data_x;
	signed_char		data_y;
} MOUSE_INPORT_DATA;

/*
 *	DEFINITION OF METHODS THAT MAY BE APPLIED TO THE OBJECT TYPES
 *	=============================================================
 */

/*
 *	MOUSE_POINT methods
 */

/*
 *	Coerce the point object "*point_ptr" to lie within the
 *	area object "*area_ptr"
 */
#define	point_coerce_to_area(point_ptr, area_ptr)		\
{								\
	if ((point_ptr)->x < (area_ptr)->top_left.x)		\
		(point_ptr)->x = (area_ptr)->top_left.x;	\
	else if ((point_ptr)->x > (area_ptr)->bottom_right.x)	\
		(point_ptr)->x = (area_ptr)->bottom_right.x;\
								\
	if ((point_ptr)->y < (area_ptr)->top_left.y)		\
		(point_ptr)->y = (area_ptr)->top_left.y;	\
	else if ((point_ptr)->y > (area_ptr)->bottom_right.y)	\
		(point_ptr)->y = (area_ptr)->bottom_right.y;\
}

/*
 *	Coerce the point object "*point_ptr" to lie on the grid
 *	defined by the vector object "*grid_ptr"
 */
#define point_coerce_to_grid(point_ptr, grid_ptr)		\
{								\
	(point_ptr)->x -= (point_ptr)->x % (grid_ptr)->x;	\
	(point_ptr)->y -= (point_ptr)->y % (grid_ptr)->y;	\
}

/*
 *	Copy "*source_ptr" to "*destination_ptr"
 */
#define	point_copy(source_ptr, destination_ptr)			\
{								\
	(destination_ptr)->x = (source_ptr)->x;			\
	(destination_ptr)->y = (source_ptr)->y;			\
}

/*
 *	Move "*point_ptr" by "*offset_ptr"
 */
#define point_translate(point_ptr, offset_ptr)			\
{								\
	(point_ptr)->x += (offset_ptr)->x;			\
	(point_ptr)->y += (offset_ptr)->y;			\
}

/*
 *	Move "*point_ptr" back by "*offset_ptr"
 */
#define point_translate_back(point_ptr, offset_ptr)		\
{								\
	(point_ptr)->x -= (offset_ptr)->x;			\
	(point_ptr)->y -= (offset_ptr)->y;			\
}

/*
 *	Set "*point_ptr" from the "x_value" and "y_value"
 */
#define	point_set(point_ptr, x_value, y_value)			\
{								\
	(point_ptr)->x = x_value;				\
	(point_ptr)->y = y_value;				\
}



/*
 *	MOUSE_AREA methods
 */

/*
 *	Transform the area "*source_ptr" so that the top left point
 *	really does lie above and to the left of the bottom right
 *	point
 */
#define	area_normalise(area_ptr)				\
{								\
	MOUSE_SCALAR temp;					\
								\
	if ((area_ptr)->top_left.x > (area_ptr)->bottom_right.x)\
	{							\
		temp = (area_ptr)->top_left.x;			\
		(area_ptr)->top_left.x = (area_ptr)->bottom_right.x;\
		(area_ptr)->bottom_right.x = temp;		\
	}							\
								\
	if ((area_ptr)->top_left.y > (area_ptr)->bottom_right.y)\
	{							\
		temp = (area_ptr)->top_left.y;			\
		(area_ptr)->top_left.y = (area_ptr)->bottom_right.y;\
		(area_ptr)->bottom_right.y = temp;		\
	}							\
}

/*
 *	Copy "*source_ptr" to "*desination_ptr"
 */
#define	area_copy(source_ptr, destination_ptr) 			\
	memcpy(destination_ptr,source_ptr, sizeof(MOUSE_AREA))

/*
 *	Answer whether "*area1_ptr" intersects "*area2_ptr"
 */
#define area_is_intersected_by_area(area1_ptr, area2_ptr)	\
(    ((area1_ptr)->bottom_right.x > (area2_ptr)->top_left.x)	\
  && ((area1_ptr)->bottom_right.y > (area2_ptr)->top_left.y)	\
  && ((area1_ptr)->top_left.x < (area2_ptr)->bottom_right.x)	\
  && ((area1_ptr)->top_left.y < (area2_ptr)->bottom_right.y))

/*
 *	Clip "*area1_ptr" so that it lies fully within "*area2_ptr"
 */
#define area_coerce_to_area(area1_ptr, area2_ptr)			\
{									\
	if ((area1_ptr)->top_left.x < (area2_ptr)->top_left.x)		\
		(area1_ptr)->top_left.x = (area2_ptr)->top_left.x;	\
	else if ((area1_ptr)->top_left.x > (area2_ptr)->bottom_right.x)	\
		(area1_ptr)->top_left.x = (area2_ptr)->bottom_right.x;	\
									\
	if ((area1_ptr)->bottom_right.x < (area2_ptr)->top_left.x)	\
		(area1_ptr)->bottom_right.x = (area2_ptr)->top_left.x;	\
	else if ((area1_ptr)->bottom_right.x > (area2_ptr)->bottom_right.x)\
		(area1_ptr)->bottom_right.x = (area2_ptr)->bottom_right.x;\
									\
	if ((area1_ptr)->top_left.y < (area2_ptr)->top_left.y)		\
		(area1_ptr)->top_left.y = (area2_ptr)->top_left.y;	\
	else if ((area1_ptr)->top_left.y > (area2_ptr)->bottom_right.y)	\
		(area1_ptr)->top_left.y = (area2_ptr)->bottom_right.y;	\
									\
	if ((area1_ptr)->bottom_right.y < (area2_ptr)->top_left.y)	\
		(area1_ptr)->bottom_right.y = (area2_ptr)->top_left.y;	\
	else if ((area1_ptr)->bottom_right.y > (area2_ptr)->bottom_right.y)\
		(area1_ptr)->bottom_right.y = (area2_ptr)->bottom_right.y;\
}

/*
 *	Return the width of "*area_ptr"
 */
#define area_width(area_ptr)					\
((area_ptr)->bottom_right.x - (area_ptr)->top_left.x)

/*
 *	Return the depth of "*area_ptr"
 */
#define	area_depth(area_ptr)					\
((area_ptr)->bottom_right.y - (area_ptr)->top_left.y)




/*
 *	MOUSE_VECTOR methods
 */

/*
 *	Multiply "*vector1_ptr" by "*vector2_ptr"
 */
#define vector_multiply_by_vector(vector1_ptr, vector2_ptr)	\
{								\
	(vector1_ptr)->x *= (vector2_ptr)->x;			\
	(vector1_ptr)->y *= (vector2_ptr)->y;			\
}

/*
 *	Divide "*vector1_ptr" by "*vector2_ptr"
 */
#define vector_divide_by_vector(vector1_ptr, vector2_ptr)	\
{								\
	(vector1_ptr)->x /= (vector2_ptr)->x;			\
	(vector1_ptr)->y /= (vector2_ptr)->y;			\
}

/*
 *	Make "*vector1_ptr" the modulus of the division of "*vector1_ptr" 
 *	by "*vector2_ptr"
 */
#define vector_mod_by_vector(vector1_ptr, vector2_ptr)		\
{								\
	(vector1_ptr)->x %= (vector2_ptr)->x;			\
	(vector1_ptr)->y %= (vector2_ptr)->y;			\
}

/*
 *	Scale "*vector_ptr" by scale factor "scale"
 */
#define vector_scale(vector_ptr, scale)				\
{								\
	(vector_ptr)->x *= scale;				\
	(vector_ptr)->y *= scale;				\
}

/*
 *	Set "*vector_ptr" from the "x_value" and "y_value"
 */
#define	vector_set(vector_ptr, x_value, y_value)		\
{								\
	(vector_ptr)->x = x_value;				\
	(vector_ptr)->y = y_value;				\
}




/*
 *	MOUSE_SCALAR methods
 */

#define scalar_absolute(x) ((x) >= 0 ? (x) : -(x))




/*
 *	MOUSE_SOFTWARE_TEXT_CURSOR and MOUSE_GRAPHICS_CURSOR methods
 */

#define	software_text_cursor_copy(source_ptr, destination_ptr)	\
{								\
	(destination_ptr)->screen = (source_ptr)->screen;	\
	(destination_ptr)->cursor = (source_ptr)->cursor;	\
}

#define	graphics_cursor_copy(source_ptr, destination_ptr)	\
	memcpy(destination_ptr,source_ptr, sizeof(MOUSE_GRAPHICS_CURSOR))
	
#define SHIFT_VAL	((IU32)0xff0000ff)

/*
 * Not all platforms support cursor larger than 16 x 16. Some do, some don't.
 * We keep a list of vendors with the boolean cursor_is_big set to TRUE if
 * 32 x 32 cursors are supported.
 */

struct VENDOR_INFO
{
	char	*vendor_name;
	boolean	cursor_is_big;
};

	/* used to determine whether adapter is in text or graphics mode, by peeping at the BIOS mode variable */
#define	in_text_mode()	(sas_hw_at_no_check(vd_video_mode) < 4 || sas_hw_at_no_check(vd_video_mode) == 7)

typedef struct
{
	void (*restore_cursor) IPT0();
	void (*deinstall) IPT0();
	BOOL (*installed) IPT0();
	BOOL (*in_use) IPT0();
	void (*reset) IPT0();
	void (*set_position) IPT2(USHORT,newx, USHORT,newy);
	void (*set_graphics) IPT3(MOUSE_SCALAR *,xptr,MOUSE_SCALAR *,yptr,word *,ba);
	void (*cursor_display) IPT0();
	void (*cursor_undisplay) IPT0();
	void (*cursor_mode_change) IPT0();
} HOSTMOUSEFUNCS;

#if defined(HOST_MOUSE) || defined(NTVDM)

IMPORT HOSTMOUSEFUNCS	*working_mouse_funcs;

#define host_mouse_restore_cursor()\
	(working_mouse_funcs->restore_cursor)()

#define host_deinstall_host_mouse()\
	(working_mouse_funcs->deinstall)()

#define host_mouse_installed()\
	(working_mouse_funcs->installed)()

#define host_mouse_in_use()\
	(working_mouse_funcs->in_use)()

#define host_mouse_reset()\
	(working_mouse_funcs->reset)()

#define host_mouse_set_position(x,y)\
	(working_mouse_funcs->set_position)(x,y)

#define host_mouse_set_graphics(x,y,z)\
	(working_mouse_funcs->set_graphics)(x,y,z)

#define host_mouse_cursor_display()\
	(working_mouse_funcs->cursor_display)()

#define host_mouse_cursor_undisplay()\
	(working_mouse_funcs->cursor_undisplay)()

#define host_mouse_cursor_mode_change()\
	(working_mouse_funcs->cursor_mode_change)()
	
#else	/* HOST_MOUSE */

#define host_mouse_restore_cursor()

#define host_deinstall_host_mouse()

#define host_mouse_installed()	FALSE

#define host_mouse_in_use()	FALSE

#define host_mouse_reset()

#define host_mouse_set_position(x,y)

#define host_mouse_set_graphics(x,y,z)

#define host_mouse_cursor_display()

#define host_mouse_cursor_undisplay()

#define host_mouse_cursor_mode_change()
	
#endif	/* HOST_MOUSE */

#ifdef NTVDM
VOID host_enable_delta_motion IPT0();
VOID host_disable_delta_motion IPT0();
#ifdef X86GFX
extern  void host_mouse_conditional_off_enabled(void);
#else
extern  void mouse_video_mode_changed(int new_mode);
#endif

#endif	/* NTVDM */


/*
   Define (if not already defined EGA register sizes). Unfortunately
   a wide range of files include this file and historically it has
   just become a large unstructured lump of definitions. Given many
   users don't need the following Instance Variable Definitions, avoid
   making all these files include egavideo.h by copying the relevant
   definitions here.
 */

#ifndef EGA_PARMS_SEQ_SIZE
#define EGA_PARMS_SEQ_SIZE 4
#endif

#ifndef EGA_PARMS_CRTC_SIZE
#define EGA_PARMS_CRTC_SIZE 25
#endif

#ifndef EGA_PARMS_ATTR_SIZE
#define EGA_PARMS_ATTR_SIZE 20
#endif

#ifndef EGA_PARMS_GRAPH_SIZE
#define EGA_PARMS_GRAPH_SIZE 9
#endif


/*
   Structure to represent the acceleration data.
 */
#define NR_ACCL_CURVES		4
#define NR_ACCL_MICKEY_COUNTS	32
#define NR_ACCL_SCALE_FACTORS	32
#define NR_ACCL_NAME_CHARS	16
typedef struct
  {
  half_word ac_length[NR_ACCL_CURVES];
  half_word ac_count[NR_ACCL_CURVES][NR_ACCL_MICKEY_COUNTS];
  half_word ac_scale[NR_ACCL_CURVES][NR_ACCL_SCALE_FACTORS];
  half_word ac_name[NR_ACCL_CURVES][NR_ACCL_NAME_CHARS];
  } ACCELERATION_CURVE_DATA;

/*
   Structure which represents the saved mouse state (context) for DOS
   programs.

   button_transitions - For functions 5 & 6.
   mouse_gear - Mickey to Pixel Ratio Declarations. NB all mouse gears are
		scaled by MOUSE_RATIO_SCALE_FACTOR.
   mouse_sens - Sensitivity. NB Sensitivity is multiplied in BEFORE Mickey to
		Pixels ratios.
   text_cursor_type - This is either HARDWARE or SOFTWARE.
   black_hole - Conditional off area.
   cursor_flag - Internal cursor flag.
   cursor_status - Cursor button status and virtual screen position.
   cursor_window - Virtual screen window constraining the cursor.
   light_pen_mode - Light pen emulation mode.
   mouse_motion - Accumulated Mickey counts for function 11.
   mouse_raw_motion - Accumulated raw Mickey counts for func 39.
   cursor_position, cursor_fractional_position - Integral and fractional parts
						 of raw cursor position.
   cursor_page - Video page mouse pointer is currently on.
   active_acceleration_curve - Currently active acceleration curve. In
			       range 1-4.
   acceleration_curve_data - The acceleration curve data.
   next_video_mode - Tracks enumerated video modes for func 41.
 */
typedef struct
   {
   MOUSE_BUTTON_STATUS MC_button_transitions[MOUSE_BUTTON_MAXIMUM];
   MOUSE_VECTOR        MC_mouse_gear;
   MOUSE_VECTOR        MC_mouse_sens;
   MOUSE_VECTOR        MC_mouse_sens_val;
   word                MC_mouse_double_thresh;
   MOUSE_STATE         MC_text_cursor_type;
   MOUSE_SOFTWARE_TEXT_CURSOR MC_software_text_cursor;
   MOUSE_GRAPHICS_CURSOR      MC_graphics_cursor;
   word                MC_user_subroutine_segment;
   word                MC_user_subroutine_offset;
   MOUSE_CALL_MASK     MC_user_subroutine_call_mask;
   boolean             MC_alt_user_subroutines_active;
   word                MC_alt_user_subroutine_segment[NUMBER_ALT_SUBROUTINES];
   word                MC_alt_user_subroutine_offset[NUMBER_ALT_SUBROUTINES];
   MOUSE_CALL_MASK     MC_alt_user_subroutine_call_mask[NUMBER_ALT_SUBROUTINES];
   MOUSE_AREA          MC_black_hole;
   MOUSE_SPEED         MC_double_speed_threshold;
   int                 MC_cursor_flag;
   MOUSE_CURSOR_STATUS MC_cursor_status;
   MOUSE_AREA          MC_cursor_window;
   boolean             MC_light_pen_mode;
   MOUSE_VECTOR        MC_mouse_motion;
   MOUSE_VECTOR        MC_mouse_raw_motion;
   MOUSE_POINT         MC_cursor_position_default;
   MOUSE_POINT         MC_cursor_position;
   MOUSE_POINT         MC_cursor_fractional_position;
   int                 MC_cursor_page;
   int		       MC_active_acceleration_curve;
   ACCELERATION_CURVE_DATA   MC_acceleration_curve_data;
   int                 MC_next_video_mode;
   } MOUSE_CONTEXT;

/*
   Instance Variables for Mickey Mouse (MM) Driver, ie those variables which
   must be set up for each Virtual Machine under Windows 3.x. The NIDDB Manager
   (cf virtual.c) basically forces us to define these in one memory area.

   text_cursor_background - Area from which background can be restored.
   graphics_cursor_background - Area from which background can be restored.
   save_area - Actual area of screen covered by graphics cursor.
   black_hole_default - Conditional off area.
   ega_default_crtc  - Pointers to default EGA register values.
   ega_default_seq   - 
   ega_default_graph - 
   ega_default_attr  - 
   ega_default_misc  - 
   ega_current_crtc  - Current EGA register state, according to mouse driver.
   ega_current_graph - 
   ega_current_seq   - 
   ega_current_attr  - 
   ega_current_misc  - 
   cursor_EM_disabled - Indicates cursor should be disabled inside a
			windowed Enhanced Mode DOS box. This overrides
			the cursor_flag variable.
 */
typedef struct
   {
   MOUSE_CONTEXT     MM_IN_mouse_context;
   USHORT            MM_IN_mouse_driver_disabled;
   SHORT             MM_IN_current_video_mode;
   MOUSE_SCREEN_DATA MM_IN_text_cursor_background;
   MOUSE_SCREEN_DATA MM_IN_graphics_cursor_background[MOUSE_GRAPHICS_CURSOR_DEPTH];
   boolean           MM_IN_save_area_in_use;
   MOUSE_POINT       MM_IN_save_position;
   MOUSE_AREA        MM_IN_save_area;
   boolean           MM_IN_user_subroutine_critical;
   MOUSE_CALL_MASK   MM_IN_last_condition_mask;
   word              MM_IN_saved_AX;
   word              MM_IN_saved_BX;
   word              MM_IN_saved_CX;
   word              MM_IN_saved_DX;
   word              MM_IN_saved_SI;
   word              MM_IN_saved_DI;
   word              MM_IN_saved_ES;
   word              MM_IN_saved_BP;
   word              MM_IN_saved_DS;
   MOUSE_AREA        MM_IN_virtual_screen;
   MOUSE_VECTOR      MM_IN_cursor_grid;
   MOUSE_VECTOR      MM_IN_text_grid;
   MOUSE_AREA        MM_IN_black_hole_default;
   word              MM_IN_saved_int33_segment;
   word              MM_IN_saved_int33_offset;
   word              MM_IN_saved_int10_segment;
   word              MM_IN_saved_int10_offset;
   word              MM_IN_saved_int0A_segment;
   word              MM_IN_saved_int0A_offset;
   IBOOL             MM_IN_int10_chained;

#ifdef	MOUSE_16_BIT
   IBOOL             MM_IN_is_graphics_mode;
#endif	/* MOUSE_16_BIT */ 

#ifdef EGG
#ifndef REAL_VGA
#ifdef VGG
   UTINY             MM_IN_vga_background
			[MOUSE_GRAPHICS_CURSOR_DEPTH][MOUSE_GRAPHICS_CURSOR_WIDTH];
#endif /* VGG */

   MOUSE_SCREEN_DATA_GR MM_IN_ega_backgrnd_lo[MOUSE_GRAPHICS_CURSOR_DEPTH];
   MOUSE_SCREEN_DATA_GR MM_IN_ega_backgrnd_mid[MOUSE_GRAPHICS_CURSOR_DEPTH];
   MOUSE_SCREEN_DATA_GR MM_IN_ega_backgrnd_hi[MOUSE_GRAPHICS_CURSOR_DEPTH];
#endif /* nREAL_VGA */

   sys_addr          MM_IN_ega_default_crtc;
   sys_addr          MM_IN_ega_default_seq;
   sys_addr          MM_IN_ega_default_graph;
   sys_addr          MM_IN_ega_default_attr;
   sys_addr          MM_IN_ega_default_misc;
   half_word         MM_IN_ega_current_crtc[EGA_PARMS_CRTC_SIZE];
   half_word         MM_IN_ega_current_graph[EGA_PARMS_GRAPH_SIZE];
   half_word         MM_IN_ega_current_seq[EGA_PARMS_SEQ_SIZE];
   half_word         MM_IN_ega_current_attr[EGA_PARMS_ATTR_SIZE];
   half_word         MM_IN_ega_current_misc;
#endif /* EGG */

#ifdef HERC
   MOUSE_AREA        MM_IN_HERC_graphics_virtual_screen;
#endif /* HERC */
   boolean           MM_IN_cursor_EM_disabled;
   } MM_INSTANCE_DATA, **MM_INSTANCE_DATA_HANDLE;

/*
   Define access to instance variables via handle.
 */

IMPORT MM_INSTANCE_DATA_HANDLE mm_handle;

#define button_transitions \
   ((*mm_handle)->MM_IN_mouse_context.MC_button_transitions)
#define mouse_gear \
   ((*mm_handle)->MM_IN_mouse_context.MC_mouse_gear)
#define mouse_sens \
   ((*mm_handle)->MM_IN_mouse_context.MC_mouse_sens)
#define mouse_sens_val \
   ((*mm_handle)->MM_IN_mouse_context.MC_mouse_sens_val)
#define mouse_double_thresh \
   ((*mm_handle)->MM_IN_mouse_context.MC_mouse_double_thresh)
#define text_cursor_type \
   ((*mm_handle)->MM_IN_mouse_context.MC_text_cursor_type)
#define software_text_cursor \
   ((*mm_handle)->MM_IN_mouse_context.MC_software_text_cursor)
#define graphics_cursor \
   ((*mm_handle)->MM_IN_mouse_context.MC_graphics_cursor)
#define user_subroutine_segment \
   ((*mm_handle)->MM_IN_mouse_context.MC_user_subroutine_segment)
#define user_subroutine_offset \
   ((*mm_handle)->MM_IN_mouse_context.MC_user_subroutine_offset)
#define user_subroutine_call_mask \
   ((*mm_handle)->MM_IN_mouse_context.MC_user_subroutine_call_mask)
#define alt_user_subroutines_active \
   ((*mm_handle)->MM_IN_mouse_context.MC_alt_user_subroutines_active)
#define alt_user_subroutine_segment \
   ((*mm_handle)->MM_IN_mouse_context.MC_alt_user_subroutine_segment)
#define alt_user_subroutine_offset \
   ((*mm_handle)->MM_IN_mouse_context.MC_alt_user_subroutine_offset)
#define alt_user_subroutine_call_mask \
   ((*mm_handle)->MM_IN_mouse_context.MC_alt_user_subroutine_call_mask)
#define black_hole \
   ((*mm_handle)->MM_IN_mouse_context.MC_black_hole)
#define double_speed_threshold \
   ((*mm_handle)->MM_IN_mouse_context.MC_double_speed_threshold)
#define cursor_flag \
   ((*mm_handle)->MM_IN_mouse_context.MC_cursor_flag)
#define cursor_status \
   ((*mm_handle)->MM_IN_mouse_context.MC_cursor_status)
#define cursor_window \
   ((*mm_handle)->MM_IN_mouse_context.MC_cursor_window)
#define light_pen_mode \
   ((*mm_handle)->MM_IN_mouse_context.MC_light_pen_mode)
#define mouse_motion \
   ((*mm_handle)->MM_IN_mouse_context.MC_mouse_motion)
#define mouse_raw_motion \
   ((*mm_handle)->MM_IN_mouse_context.MC_mouse_raw_motion)
#define cursor_position_default \
   ((*mm_handle)->MM_IN_mouse_context.MC_cursor_position_default)
#define cursor_position \
   ((*mm_handle)->MM_IN_mouse_context.MC_cursor_position)
#define cursor_fractional_position \
   ((*mm_handle)->MM_IN_mouse_context.MC_cursor_fractional_position)
#define cursor_page \
   ((*mm_handle)->MM_IN_mouse_context.MC_cursor_page)
#define active_acceleration_curve \
   ((*mm_handle)->MM_IN_mouse_context.MC_active_acceleration_curve)
#define acceleration_curve_data \
   ((*mm_handle)->MM_IN_mouse_context.MC_acceleration_curve_data)
#define next_video_mode \
   ((*mm_handle)->MM_IN_mouse_context.MC_next_video_mode)

#define mouse_context              ((*mm_handle)->MM_IN_mouse_context)
#define mouse_driver_disabled      ((*mm_handle)->MM_IN_mouse_driver_disabled)
#define current_video_mode         ((*mm_handle)->MM_IN_current_video_mode)
#define text_cursor_background     ((*mm_handle)->MM_IN_text_cursor_background)
#define graphics_cursor_background ((*mm_handle)->MM_IN_graphics_cursor_background)
#define save_area_in_use           ((*mm_handle)->MM_IN_save_area_in_use)
#define save_position              ((*mm_handle)->MM_IN_save_position)
#define save_area                  ((*mm_handle)->MM_IN_save_area)
#define user_subroutine_critical   ((*mm_handle)->MM_IN_user_subroutine_critical)
#define last_condition_mask        ((*mm_handle)->MM_IN_last_condition_mask)
#define saved_AX                   ((*mm_handle)->MM_IN_saved_AX)
#define saved_BX                   ((*mm_handle)->MM_IN_saved_BX)
#define saved_CX                   ((*mm_handle)->MM_IN_saved_CX)
#define saved_DX                   ((*mm_handle)->MM_IN_saved_DX)
#define saved_SI                   ((*mm_handle)->MM_IN_saved_SI)
#define saved_DI                   ((*mm_handle)->MM_IN_saved_DI)
#define saved_ES                   ((*mm_handle)->MM_IN_saved_ES)
#define saved_BP                   ((*mm_handle)->MM_IN_saved_BP)
#define saved_DS                   ((*mm_handle)->MM_IN_saved_DS)
#define virtual_screen             ((*mm_handle)->MM_IN_virtual_screen)
#define cursor_grid                ((*mm_handle)->MM_IN_cursor_grid)
#define text_grid                  ((*mm_handle)->MM_IN_text_grid)
#define black_hole_default         ((*mm_handle)->MM_IN_black_hole_default)
#define saved_int33_segment        ((*mm_handle)->MM_IN_saved_int33_segment)
#define saved_int33_offset         ((*mm_handle)->MM_IN_saved_int33_offset)
#define saved_int10_segment        ((*mm_handle)->MM_IN_saved_int10_segment)
#define saved_int10_offset         ((*mm_handle)->MM_IN_saved_int10_offset)
#define saved_int0A_segment        ((*mm_handle)->MM_IN_saved_int0A_segment)
#define saved_int0A_offset         ((*mm_handle)->MM_IN_saved_int0A_offset)
#define int10_chained              ((*mm_handle)->MM_IN_int10_chained)

#ifdef	MOUSE_16_BIT
#define is_graphics_mode           ((*mm_handle)->MM_IN_is_graphics_mode)
#endif	/* MOUSE_16_BIT */ 

#ifdef EGG
#ifndef REAL_VGA
#ifdef VGG
#define vga_background             ((*mm_handle)->MM_IN_vga_background)
#endif /* VGG */

#define ega_backgrnd_lo            ((*mm_handle)->MM_IN_ega_backgrnd_lo)
#define ega_backgrnd_mid           ((*mm_handle)->MM_IN_ega_backgrnd_mid)
#define ega_backgrnd_hi            ((*mm_handle)->MM_IN_ega_backgrnd_hi)
#endif /* nREAL_VGA */

#define ega_default_crtc           ((*mm_handle)->MM_IN_ega_default_crtc)
#define ega_default_seq            ((*mm_handle)->MM_IN_ega_default_seq)
#define ega_default_graph          ((*mm_handle)->MM_IN_ega_default_graph)
#define ega_default_attr           ((*mm_handle)->MM_IN_ega_default_attr)
#define ega_default_misc           ((*mm_handle)->MM_IN_ega_default_misc)
#define ega_current_crtc           ((*mm_handle)->MM_IN_ega_current_crtc)
#define ega_current_graph          ((*mm_handle)->MM_IN_ega_current_graph)
#define ega_current_seq            ((*mm_handle)->MM_IN_ega_current_seq)
#define ega_current_attr           ((*mm_handle)->MM_IN_ega_current_attr)
#define ega_current_misc           ((*mm_handle)->MM_IN_ega_current_misc)
#endif /* EGG */

#ifdef HERC
#define HERC_graphics_virtual_screen ((*mm_handle)->MM_IN_HERC_graphics_virtual_screen)
#endif /* HERC */

#define cursor_EM_disabled         ((*mm_handle)->MM_IN_cursor_EM_disabled)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\msw_snd.h ===
/*[
 *	Product:		SoftWindows Revision 2.0
 *
 *	Name:			msw_sound.h
 *
 *	Derived From:	Original
 *
 *	Authors:		Rob Tizzard
 *
 *	Created On:		16th April 1994
 *
 *	Purpose:		All definitions for the SoftWindows Windows audio 
 *					wave driver interface.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1994. All rights reserved.
 *
]*/

#ifdef SCCSID
static char SccsID[]="@(#)msw_snd.h	1.1 07/13/94";
#endif

/*
 * -----------------------------------------------------------------------------
 * Function return values.
 * -----------------------------------------------------------------------------
 */
 
/* Signal host error */

#define WAVE_SUCCESS    (IU32) 0
#define WAVE_FAILURE    (IU32) 1

/* Base error codes */

#define MMSYSERR_BASE 		0 
#define WAVERR_BASE		  	32 

/* Waveform audio error return values */

#define WAVERR_BADFORMAT      (WAVERR_BASE + 0)    /* unsupported wave format */
#define WAVERR_STILLPLAYING   (WAVERR_BASE + 1)    /* still something playing */
#define WAVERR_UNPREPARED     (WAVERR_BASE + 2)    /* header not prepared */
#define WAVERR_SYNC           (WAVERR_BASE + 3)    /* device is synchronous */
#define WAVERR_LASTERROR      (WAVERR_BASE + 3)    /* last error in range */

/* General error return values */

#define MMSYSERR_NOERROR      0                    /* no error */
#define MMSYSERR_ERROR        (MMSYSERR_BASE + 1)  /* unspecified error */
#define MMSYSERR_BADDEVICEID  (MMSYSERR_BASE + 2)  /* device ID out of range */
#define MMSYSERR_NOTENABLED   (MMSYSERR_BASE + 3)  /* driver failed enable */
#define MMSYSERR_ALLOCATED    (MMSYSERR_BASE + 4)  /* device already allocated */
#define MMSYSERR_INVALHANDLE  (MMSYSERR_BASE + 5)  /* device handle is invalid */
#define MMSYSERR_NODRIVER     (MMSYSERR_BASE + 6)  /* no device driver present */
#define MMSYSERR_NOMEM        (MMSYSERR_BASE + 7)  /* memory allocation error */
#define MMSYSERR_NOTSUPPORTED (MMSYSERR_BASE + 8)  /* function isn't supported */
#define MMSYSERR_BADERRNUM    (MMSYSERR_BASE + 9)  /* error value out of range */
#define MMSYSERR_INVALFLAG    (MMSYSERR_BASE + 10) /* invalid flag passed */
#define MMSYSERR_INVALPARAM   (MMSYSERR_BASE + 11) /* invalid parameter passed */
#define MMSYSERR_LASTERROR    (MMSYSERR_BASE + 11) /* last error in range */

/*
 * -----------------------------------------------------------------------------
 * Windows Data structure sizes.
 * -----------------------------------------------------------------------------
 */

#define MAXPNAMELEN		32		/* Product Name string length */
#define SIZEOF_MMTIME	6		/* Size of MMTIME structure in bytes */

/*
 * -----------------------------------------------------------------------------
 * Flags for dwSupport field of WAVEOUTCAPS.
 * -----------------------------------------------------------------------------
 */

#define WAVECAPS_PITCH          0x0001   /* supports pitch control */
#define WAVECAPS_PLAYBACKRATE   0x0002   /* supports playback rate control */
#define WAVECAPS_VOLUME         0x0004   /* supports volume control */
#define WAVECAPS_LRVOLUME       0x0008   /* separate left-right volume control */
#define WAVECAPS_SYNC           0x0010	 /* Synchronous device */

/*
 * -----------------------------------------------------------------------------
 * Manufacturer IDs, Product IDs & driver version numbers
 * -----------------------------------------------------------------------------
 */

#define MM_INSIGNIA          2       /* Insignia Solutions */

#define MM_SOFTWIN_WAVEOUT  13       /* SoftWindows waveform output */
#define MM_SOFTWIN_WAVEIN   13       /* SoftWindows waveform input */

#define WAV_OUT_VERSION	    0x0100   /* Output Wave Sound Driver Version */
#define WAV_IN_VERSION	    0x0100   /* Input Wave Sound Driver Version */

/*
 * -----------------------------------------------------------------------------
 * Defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS
 * -----------------------------------------------------------------------------
 */

#define WAVE_INVALIDFORMAT     0x00000000       /* invalid format */
#define WAVE_FORMAT_1M08       0x00000001       /* 11.025 kHz, Mono,   8-bit  */
#define WAVE_FORMAT_1S08       0x00000002       /* 11.025 kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_1M16       0x00000004       /* 11.025 kHz, Mono,   16-bit */
#define WAVE_FORMAT_1S16       0x00000008       /* 11.025 kHz, Stereo, 16-bit */
#define WAVE_FORMAT_2M08       0x00000010       /* 22.05  kHz, Mono,   8-bit  */
#define WAVE_FORMAT_2S08       0x00000020       /* 22.05  kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_2M16       0x00000040       /* 22.05  kHz, Mono,   16-bit */
#define WAVE_FORMAT_2S16       0x00000080       /* 22.05  kHz, Stereo, 16-bit */
#define WAVE_FORMAT_4M08       0x00000100       /* 44.1   kHz, Mono,   8-bit  */
#define WAVE_FORMAT_4S08       0x00000200       /* 44.1   kHz, Stereo, 8-bit  */
#define WAVE_FORMAT_4M16       0x00000400       /* 44.1   kHz, Mono,   16-bit */
#define WAVE_FORMAT_4S16       0x00000800       /* 44.1   kHz, Stereo, 16-bit */

/*
 * -----------------------------------------------------------------------------
 * Defines for wave formats
 * -----------------------------------------------------------------------------
 */

#define WAVE_FORMAT_PCM     1

/* General wave format datastructure */

typedef struct  {
    IU16   wFormatTag;        /* format type */
    IU16   nChannels;         /* number of channels (i.e. mono, stereo, etc.) */
    IU32   nSamplesPerSec;    /* sample rate */
    IU32   nAvgBytesPerSec;   /* for buffer estimation */
    IU16   nBlockAlign;       /* block size of data */
} WAVEFORMAT;

/* PCM wave datastructure */

typedef struct  {
    WAVEFORMAT  wf;
    IU16        wBitsPerSample;
} PCMWAVEFORMAT;

/*
 * -----------------------------------------------------------------------------
 * Per allocation structure for wave
 * -----------------------------------------------------------------------------
 */

typedef struct {
    IU32           dwCallback;     /* client's callback */
    IU32           dwInstance;     /* client's instance data */
    IU32           hWave;          /* handle for stream */
    IU32           dwFlags;        /* allocation flags */
	IU32			dwByteCount;	/* byte count since last reset */
    PCMWAVEFORMAT  pcmwf;          /* format of wave data */
}WAVEALLOC;

/*
 * -----------------------------------------------------------------------------
 * Wave header structure.
 * -----------------------------------------------------------------------------
 */

/* flags for dwFlags field of WAVEHDR */

#define WHDR_DONE       0x00000001  /* done bit */
#define WHDR_PREPARED   0x00000002  /* set if this header has been prepared */
#define WHDR_BEGINLOOP  0x00000004  /* loop start block */
#define WHDR_ENDLOOP    0x00000008  /* loop end block */
#define WHDR_INQUEUE    0x00000010  /* reserved for driver */

typedef struct WAVHDR {
    LIN_ADDR	    lpData;          /* pointer to locked data buffer */
    IU32       		dwBufferLength;  /* length of data buffer */
    IU32       		dwBytesRecorded; /* used for input only */
    IU32       		dwUser;          /* for client's use */
    IU32       		dwFlags;         /* assorted flags (see defines) */
    IU32       		dwLoops;         /* loop control counter */
	LIN_ADDR		lpNext;         /* reserved for driver */
    IU32       		reserved;        /* reserved for driver */
} WAVEHDR;

/*
 * -----------------------------------------------------------------------------
 * Types for wType field in MMTIME struct
 * -----------------------------------------------------------------------------
 */
 
#define TIME_MS         0x0001  /* time in milliseconds */
#define TIME_SAMPLES    0x0002  /* number of wave samples */
#define TIME_BYTES      0x0004  /* current byte offset */
#define TIME_SMPTE      0x0008  /* SMPTE time */
#define TIME_MIDI       0x0010  /* MIDI time */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\m_errorp.h ===
#ifndef _x_ERROR_H
#define _x_ERROR_H

struct _buttonCap {
	swidget *w;
	int  opt;
};

LOCAL SHORT X_error_conf();
LOCAL SHORT X_error();
LOCAL SHORT X_error_ext();

#define BAD_FORM ((swidget) -1)

#endif /* _x_ERROR_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\ms_windo.h ===
/*[
 *	Product:	SoftPC-AT Revision 3.0
 *
 *	Name:		ms_windows.h
 *
 *	Derived From:	Alpha MS-Windows Driver by Ross Beresford
 *
 *	Author:		Rob Tizzard
 *
 *	Created On:	1st November 1990
 *
 *	SCCS ID:	@(#)ms_windows.h	1.66 07/06/94
 *
 *	Purpose:	This module defines the interface between the MS-Windows
 *		  	GDI and its dedicated display driver. 
 *
 * 	Notes:	 	The identifiers used in "windows.inc" are adopted here
 *		  	wherever possible; "windows.inc" is the definitions
 *		  	file supplied with the MS-Windows Software Development
 *		  	Kit.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
]*/

#ifdef MSWDVR
/*
 * -----------------------------------------------------------------------------
 * MS-Windows definitions
 * -----------------------------------------------------------------------------
 */

/* Windows versions */

#define WINDOWS2        0x0100
#define WINDOWS3        0x0300

/*  Binary raster ops */

#define  R2_BLACK             1               /*  0       */
#define  R2_NOTMERGEPEN       2               /* DPon     */
#define  R2_MASKNOTPEN        3               /* DPna     */
#define  R2_NOTCOPYPEN        4               /* PN       */
#define  R2_MASKPENNOT        5               /* PDna     */
#define  R2_NOT               6               /* Dn       */
#define  R2_XORPEN            7               /* DPx      */
#define  R2_NOTMASKPEN        8               /* DPan     */
#define  R2_MASKPEN           9               /* DPa      */
#define  R2_NOTXORPEN         10              /* DPxn     */
#define  R2_NOP               11              /* D        */
#define  R2_MERGENOTPEN       12              /* DPno     */
#define  R2_COPYPEN           13              /* P        */
#define  R2_MERGEPENNOT       14              /* PDno     */
#define  R2_MERGEPEN          15              /* DPo      */
#define  R2_WHITE             16              /*  1       */

/*  Ternary raster operations - interesting byte only */

#define  BLACKNESS   0x00  /* dest <- BLACK                       */
#define  NOTSRCERASE 0x11  /* dest <- (NOT source) AND (NOT dest) */
#define  MASKNOTSRC  0x22  /* dest <- (NOT source) AND dest       */
#define  NOTSRCCOPY  0x33  /* dest <- (NOT source)                */
#define  SRCERASE    0x44  /* dest <- source AND (NOT dest )      */
#define  DSTINVERT   0x55  /* dest <- (NOT dest)                  */
#define  SRCINVERT   0x66  /* dest <- source XOR      dest        */
#define  NOTMASKSRC  0x77  /* dest <- NOT (source AND dest)       */
#define  SRCAND      0x88  /* dest <- source AND dest             */
#define  NOTXORSRC   0x99  /* dest <- (NOT source) XOR dest       */
#define  NOP         0xAA  /* dest <- dest                        */
#define  MERGEPAINT  0xBB  /* dest <- (NOT source) OR dest        */
#define  SRCCOPY     0xCC  /* dest <- source                      */
#define  MERGESRCNOT 0xDD  /* dest <- source OR (NOT dest)        */
#define  SRCPAINT    0xEE  /* dest <- source OR dest              */
#define  WHITENESS   0xFF  /* dest <- WHITE                       */

#define  PATINVERT   0x5A  /* dest <- pattern XOR     dest        */
#define  OP6A        0x6A  /* dest <- (src AND pattern) XOR dest  */
#define  OPB8        0xB8  /* dest <- (p XOR dst) AND src) XOR p  */
#define  MERGECOPY   0xC0  /* dest <- (source AND pattern)        */
#define  OPE2        0xE2  /* dest <- (p XOR dst) AND src) XOR dst*/
#define  PATCOPY     0xF0  /* dest <- pattern                     */
#define  PATMERGE    0xFA  /* dest <- dst OR pat                  */
#define  PATPAINT    0xFB  /* dest <- DPSnoo                      */

#define	ISBINARY(rop) ((rop & 0x0F) == ((rop & 0xF0) >> 4))
#define	TOBINARY(rop) ((rop & 0x0F) + 1)

/* GDI data structure values */

#define GDIINFOSIZE	55				/* GDIINFO data structure size in words */
#define NUMBRUSHES	~0				/* Number of brushes = infinite */
#define NUMPENS		NUMCOLOURS*5			/* Number pens = NUMCOLOURS * 5 styles */
#define	XSIZ		240				/* Display width in millimeters */
#define	YSIZ		175				/* Display depth in millimeters */
#define	XRES		640				/* Display width in pixels */
#define	YRES		350				/* Display depth in scan lines */
#define	HYPOTENUSE	61				/* Distance moving X and Y */
#define	Y_MAJOR_DIST	48				/* Distance moving Y only */
#define	X_MAJOR_DIST	38				/* Distance moving X only */
#define	MAX_STYLE_ERR	HYPOTENUSE*2			/* Segment length for line styles */

/* GDI logical object definitions */

#define OBJ_PEN         1
#define OBJ_BRUSH       2
#define OBJ_FONT        3
#ifdef SWIN_DEVBMP
#define OBJ_PBITMAP		5

/*
 * BitmapBits parameter for the bit transfer operation
 */
#define DBB_SET         1
#define DBB_GET         2
#define DBB_COPY        4
#endif /* SWIN_DEVBMP */

/* GDI Brush Style definitions */

#define BS_SOLID	0
#define BS_HOLLOW	1
#define BS_HATCHED	2
#define BS_PATTERN	3

/* GDI Pen Style definitions */

#define LS_SOLID	0
#define	LS_DASHED	1
#define LS_DOTTED	2
#define LS_DOTDASHED	3
#define	LS_DASHDOTDOT	4
#define LS_NOLINE	5
#define LS_INSIDEFRAME	6

/* GDI Hatch Style definitions. */

#define HS_HORIZONTAL	0	/* ----- */
#define HS_VERTICAL	1	/* ||||| */
#define HS_FDIAGONAL	2	/* ///// */
#define HS_BDIAGONAL	3	/* \\\\\ */
#define HS_CROSS	4	/* +++++ */
#define HS_DIAGCROSS	5	/* xxxxx */

/* GDI Pen Style definitions */

#define PS_SOLID	0	/* _______ */
#define PS_DASH		1	/* ------- */
#define PS_DOT		2	/* ....... */
#define PS_DASHDOT	3	/* _._._._ */
#define PS_DASHDOTDOT	4	/* _.._.._ */
#define PS_NULL		5	/*         */

/* GDI Background type */

#define     TRANSPARENT         1
#define     OPAQUE              2

/* GDI Output Objects */

#define OS_ARC		3
#define OS_SCANLINES	4
#define OS_RECTANGLE	6
#define OS_ELLIPSE	7
#define OS_POLYLINE	18
#define OS_WINDPOLYGON	20
#define OS_ALTPOLYGON	22
#define OS_PIE		23
#define OS_CHORD	39
#define OS_CIRCLE	55
#define OS_ROUNDRECT	72
#define	OS_BEGINNSCAN	80
#define	OS_ENDNSCAN	81

/* GDI ScanLR flags */

#define	SCAN_LEFT	2
#define SCAN_RIGHT	0
#define SCAN_COLOUR	1
#define SCAN_NOTCOLOUR	0

/* GDI Save Screen Bitmap flags */

#define	SSB_SAVE	0
#define	SSB_RESTORE	1
#define	SSB_IGNORE	2

/* GDI Font Offsets */

#define	FONT_HEADER_SIZE	66
#define	FONT_CHARTABLE_OFFSET	52

/* GDI Extended Text Output options */

#define	ETO_OPAQUE_FILL	(1 << 1)
#define	ETO_OPAQUE_CLIP (1 << 2)

/* Brush Width & Height */

#define BRUSH_WIDTH	8
#define BRUSH_HEIGHT	8

/* Windows 3.0 static colours */

#define STATICCOLOURS	20

/* RLE DIB formats */

#define BI_RGB	 0x00
#define BI_RLE8	 0x01
#define BI_RLE4	 0x02

/*
 * GDI Control Escapes. The list of code numbers extracted directly out
 * of the Windows 3.1 DDK guide.
 */

#define ABORTDOC		(2)
#define BANDINFO		(24)
#define BEGIN_PATH		(4096)
#define CLIP_TO_PATH		(4097)
#define DRAFTMODE		(7)
#define DRAWPATTERNRECT		(25)
#define ENABLEDUPLEX		(28)
#define ENABLEPAIRKERNING	(769)
#define ENABLERELATIVEWIDTHS	(768)
#define END_PATH		(4098)
#define ENDDOC			(11)
#define ENUMPAPERBINS		(31)
#define ENUMPAPERMETRICS	(34)
#define ENUMPAPERMETRICS	(34)
#define EPSPRINTING		(33)
#define EXT_DEVICE_CAPS		(4099)
#define FLUSHOUTPUT		(6)
#define GETCOLORTABLE		(5)
#define GETEXTENDEDTEXTMETRICS	(256)
#define GETEXTENTTABLE		(257)
#define GETFACENAME		(513)
#define GETPAIRKERNTABLE	(258)
#define GETPHYSPAGESIZE		(12)
#define GETPRINTINGOFFSET	(13)
#define GETSCALINGFACTOR	(14)
#define GETSETPAPERBINS		(29)
#define GETSETPAPERMETRICS	(35)
#define GETSETPRINTORIENT	(30)
#define GETTECHNOLOGY		(20)
#define GETTRACKKERNTABLE	(259)
#define GETVECTORBRUSHSIZE	(27)
#define GETVECTORPENSIZE	(26)
#define NEWFRAME		(1)
#define NEXTBAND		(3)
#define PASSTHROUGH		(19)
#define QUERYESCSUPPORT		(8)
#define RESETDEVICE		(128)
#define RESTORE_CTM		(4100)
#define SAVE_CTM		(4101)
#define SET_ARC_DIRECTION	(4102)
#define SET_BACKGROUND_COLOR	(4103)
#define SET_BOUNDS		(4109)
#define SET_CLIP_BOX		(4108)
#define SET_POLY_MODE		(4104)
#define SET_SCREEN_ANGLE	(4105)
#define SET_SPREAD		(4106)
#define SETABORTPROC		(9)
#define SETALLJUSTVALUES	(771)
#define SETCOLORTABLE		(4)
#define SETCOPYCOUNT		(17)
#define SETKERNTRACK		(770)
#define SETLINECAP		(21)
#define SETLINEJOIN		(22)
#define SETMITERLIMIT		(23)
/* #define SETPRINTERDC		(9)  printers only - same code == SETABORTPROC */
#define STARTDOC		(10)
#define TRANSFORM_CTM		(4107)

/* 
 * -----------------------------------------------------------------------------
 * GDIINFO data structure flags
 * -----------------------------------------------------------------------------
 */ 

/*
 * 'dpTechnology' values
 */
#define DT_PLOTTER	(0)
#define DT_RASDISPLAY	(1)
#define DT_RASPRINTER	(2)
#define DT_RASCAMERA	(3)
#define DT_CHARSTREAM	(4)
#define DT_METAFILE	(5)
#define DT_DISPFILE	(6)

/*
 * 'dpLines' style flags
 */
#define LC_NONE		0x0000
#define LC_POLYLINE	0x0002
#define LC_WIDE		0x0010
#define LC_STYLED	0x0020
#define LC_WIDESTYLED	0x0040
#define LC_INTERIORS	0x0080

/*
 * 'dpPolygonals' style flags
 */
#define PC_NONE		0x0000
#define PC_ALTPOLYGON	0x0001
#define PC_RECTANGLE	0x0002
#define PC_WINDPOLYGON	0x0004
#define PC_SCANLINE	0x0008
#define PC_WIDE		0x0010
#define PC_STYLED	0x0020
#define PC_WIDESTYLED	0x0040
#define PC_INTERIORS	0x0080

/*
 * 'dpCurves' style flags
 */
#define CC_NONE		0x0000
#define CC_CIRCLES	0x0001
#define CC_PIE		0x0002
#define CC_CHORD	0x0004
#define CC_ELLIPSES	0x0008
#define CC_WIDE		0x0010
#define CC_STYLED	0x0020
#define CC_WIDESTYLED	0x0040
#define CC_INTERIORS	0x0080
#define CC_ROUNDRECT	0x0100

/*
 * 'dpText' style flags
 */
#define TC_OP_CHARACTER	0x0001	/* see ddag sect 2.1.9.1 */
#define TC_OP_STROKE	0x0002	/* see ddag sect 2.1.9.1 */
#define TC_CP_STROKE	0x0004
#define TC_CR_90	0x0008
#define TC_CR_ANY	0x0010
#define TC_SF_X_YINDEP	0x0020
#define TC_SA_DOUBLE	0x0040
#define TC_SA_INTEGER	0x0080
#define TC_SA_CONTIN	0x0100
#define TC_EA_DOUBLE	0x0200
#define TC_IA_ABLE	0x0400
#define TC_UA_ABLE	0x0800
#define TC_SO_ABLE	0x1000
#define TC_RA_ABLE	0x2000
#define TC_VA_ABLE	0x4000
#define TC_RESERVED	0x8000

/*
 * 'dpClip' values
 */
#define CP_NONE		(0)
#define CP_RECTANGLE	(1)
#define CP_REGION	(2)

/*
 * 'dpRaster' flag values
 */
#define RC_NONE		0x0000
#define RC_BITBLT	0x0001
#define RC_BANDING	0x0002
#define RC_SCALING	0x0004
#define RC_BITMAP64	0x0008
#define RC_GDI20_OUTPUT	0x0010
#define RC_GDI20_STATE	0x0020
#define RC_SAVEBITMAP	0x0040
#define RC_DI_BITMAP	0x0080
#define RC_PALETTE	0x0100
#define RC_DIBTODEV	0x0200
#define RC_BIGFONT	0x0400
#define RC_STRETCHBLT	0x0800
#define RC_FLOODFILL	0x1000
#define RC_STRETCHDIB	0x2000
#define RC_OP_DX_OUTPUT	0x4000
#define RC_DEVBITS	0x8000

/*
 * 'dpDCManage' values. These are NOT OR-able values!
 */
#define DC_MULTIPLE	(0)		/* this is my name - MSWIN doesn't give one. -- pic */
#define DC_SPDEVICE	(1)
#define DC_1PDEVICE	(2)
#define DC_IGNOREDFNP	(4)
#define DC_ONLYONE	(6)		/* this is my name - MSWIN doesn't give one. -- pic */

/*
 * 'dpCaps1' flag values.
 */
#define C1_TRANSPARENT	0x0001
#define TC_TT_ABLE	0x0002

/* 
 * -----------------------------------------------------------------------------
 * PDEVICE data structure 
 * -----------------------------------------------------------------------------
 */

#ifdef SWIN_DEVBMP
#define PDEVICESIZE	36			/* size of intel data structure in bytes */
#define PDEVICEBITMAP	0x4000	/* device type indication of a device bitmap */
#else /* SWIN_DEVBMP */
#define PDEVICESIZE	26		/* Data structure size in bytes */
#endif /* SWIN_DEVBMP */

#define PDEVICEMAGIC	0x2000		/* Device type display */

/*
 * -----------------------------------------------------------------------------
 * Windows return status codes
 * -----------------------------------------------------------------------------
 */

#define MSWSUCCESS	1
#define MSWFAILURE	0
#define MSWSIMULATE	-1

/* 
 * -----------------------------------------------------------------------------
 *  GDI Logo Layout 
 * -----------------------------------------------------------------------------
 */

#define	LOGOSTRPROD1	0
#define	LOGOSTRPROD2	(LOGOSTRPROD1 + 1)
#define	LOGOSTRPRODMAX	(LOGOSTRPROD2 + 1)
#define	LOGOSTRCOPY1	(LOGOSTRPROD2 + 1)
#define	LOGOSTRCOPY2	(LOGOSTRCOPY1 + 1)
#define	LOGOSTRCOPY3	(LOGOSTRCOPY2 + 1)
#define	LOGOSTRCOPY4	(LOGOSTRCOPY3 + 1)
#define	LOGOSTRCOPY5	(LOGOSTRCOPY4 + 1)
#define	LOGOSTRCOPY6	(LOGOSTRCOPY5 + 1)
#define	LOGOSTRMAX	(LOGOSTRCOPY6 + 1)

#define	LOGOMAGIC	1

#define	LOGO_MERGE_Y	64
#define	LOGO_PROD_Y	196
#define	LOGO_COPY_Y	266
#define	LOGO_LEADING	16

/*
 * -----------------------------------------------------------------------------
 * General definitions  
 * -----------------------------------------------------------------------------
 */

#ifndef min
#define min(a,b)                ((a)>(b) ? (b) : (a))
#endif

#ifndef max
#define max(a,b)                ((a)<(b) ? (b) : (a))
#endif

/*
 * -----------------------------------------------------------------------------
 * Memory definitions 
 * -----------------------------------------------------------------------------
 */

/* Memory masks */

#define HGHNIBMASK	0xF0
#define LOWNIBMASK	0x0F
#define HGHWORDMASK	0xFFFF0000
#define LOWWORDMASK	0x0000FFFF
#define BYTEMASK	((half_word) ~(0))
#define WORDMASK	((word) ~(0))
#define DOUBLEWORDMASK	((double_word) ~(0))

/* Bits per byte, word, double word  */

#define BITSPERNIBBLE	4
#define BITSPERBYTE	8
#define BITSPERWORD	16
#define BITSPERRGB	24

#ifdef SWIN_TEXT_OPTS
IMPORT ULONG	Seg_0_base32b;
#endif /* SWIN_TEXT_OPTS */

/* Components in byte */

#define NIBBLEPERBYTE	2

/* Macros for accessing Intel memory */

#define getbprm(stk,byt,var)	var = sas_hw_at_no_check((stk)+(byt));

#define getprm(stk,wrd,var)	var = sas_w_at_no_check(((stk)+((wrd)<<1)));

#define getlprm(stk,wrd,var)	var = sas_dw_at_no_check(stk+(wrd<<1))
/*
				{ word prvtmpoff, prvtmpseg; \
				prvtmpoff = sas_w_at_no_check((stk)+((wrd)<<1)); \
				prvtmpseg = sas_w_at_no_check((stk)+(((wrd)+1)<<1)); \
				var = ((double_word) prvtmpseg << BITSPERWORD) + (double_word) prvtmpoff; \
				}
*/
#define getptr(stk,wrd,var)	{ word prvtmpoff, prvtmpseg; \
				prvtmpoff = sas_w_at_no_check((stk)+((wrd)<<1)); \
				prvtmpseg = sas_w_at_no_check((stk)+(((wrd)+1)<<1)); \
				var = effective_addr(prvtmpseg, prvtmpoff); \
				}

#define getrgbcol(stk,wrd,var) 	{ \
				getlprm(stk,wrd,var); \
				ReverseRGB(var); \
				}

#define putbprm(stk,byt,var)	{ \
				sas_store_no_check((stk)+(byt),(var)); \
				}
#define putprm(stk,wrd,var) 	sas_storew_no_check((stk)+((wrd)<<1), (var))
#define putarry(addr,var) 	sas_storew_no_check((addr)+idx, (var)); \
				idx += WORD_SIZE
#define putlprm(stk,wrd,var)	sas_storedw_no_check((stk)+((wrd)<<1), var)
/*
				{ \
				sas_storew_no_check((stk)+((wrd)<<1), ((var) & LOWWORDMASK)); \
				sas_storew_no_check((stk)+(((wrd)+1)<<1),((var) >> BITSPERWORD)); \
				}
*/
#define putrgbcol(stk,wrd,var)	{ \
				ReverseRGB(var); \
				putlprm(stk,wrd,var); \
				}
				
#define getSegment(addr)	(word) ((addr & HGHWORDMASK) >> BITSPERWORD)
#define getOffset(addr)		(word) (addr & LOWWORDMASK)

/* Initial size of memory to malloc */

#define INITMEMALLOC    1024

/* Bit select macro */

#define BIT(num)        ((0x01)<<(num))

/* BITS <-> BYTES conversion macros */

#define BITSTOBYTES8(x)         (((x) + 0x7)>>3)
#define BITSTOBYTES16(x)        ((((x) + 0xf) & ~0xf)>>3)
#define BITSTOBYTES32(x)        ((((x) + 0x1f) & ~0x1f)>>3)
#define BYTESTOBITS(x)          ((x)<<3)

/* Expand memory allocation if needed */

#define ExpandMemory(addr, size, newsize, type)  \
\
{ \
type *tempAddr; \
if ((size) < ((newsize) * sizeof(type))) {\
        size = (newsize) * sizeof(type);        \
        while ((tempAddr = (type *) host_realloc((void *)addr, (size_t)size)) == NULL) \
        {       \
                host_error(EG_MALLOC_FAILURE, ERR_CONT | ERR_QUIT, ""); \
        } \
                addr = tempAddr; \
                }       }

/*
 * Converts a ROP3 to a ROP2, assuming no Source component. (i.e. Dest/Pat combinations only)
 */
#define ROP3toROP2(x)	(((x)>>2)&0x0F)+1

/*
 * -----------------------------------------------------------------------------
 * Window definitions
 * -----------------------------------------------------------------------------
 */

/* CRT mode byte data address */

#define CRT_MODE_BYTE_ADDR      0x0449

/*
 * Window_state defines whether the driver window is opened and
 * mapped. At a SoftPC reset,the state should become UNENABLED; when
 * the driver is first used,the driver window will be opened and
 * mapped,and the state should become ENABLED. If the driver is disabled,
 * the window is unmapped but not closed,and the state should become
 * DISABLED. */

#define WINDOW_STATE_UNENABLED  0
#define WINDOW_STATE_ENABLED    (WINDOW_STATE_UNENABLED + 1)
#define WINDOW_STATE_DISABLED   (WINDOW_STATE_ENABLED + 1)
#define WINDOW_STATE_ERROR   	(WINDOW_STATE_DISABLED + 1)

/* Host Independent Functions */

IMPORT word     WinFillGDIInfo IPT2(sys_addr,arg1,LONG,arg2);
IMPORT word     WinFillPDEVInfo IPT2(sys_addr,arg1,LONG,arg2);

/* Host dependent Functions */

IMPORT VOID     WinOpen IPT0();
IMPORT VOID     WinClose IPT0();
IMPORT VOID     WinMap IPT0();
IMPORT VOID     WinUmap IPT0();
IMPORT VOID     WinDirtyUpdate IPT5(BOOL,arg1,LONG,arg2,LONG,arg3,ULONG,arg4,ULONG,arg5);
IMPORT VOID     WinDirtyFlush IPT0();
IMPORT VOID     WinResize IPT0();
IMPORT VOID     WinSizeRestore IPT0();
IMPORT void     HostWEP IPT0();

/*
 * -----------------------------------------------------------------------------
 * BitBlt & FastBorder  definitions
 * -----------------------------------------------------------------------------
 */

/* Maximum number of border rectangles */

#define BORDER_RECT_MAX 4

/* ROP Logical Operation Table Dimensions */

#define NUMROPS         256
#define ROPTABLEWIDTH  	16 

/* Valid operands for ROP3 */

#define NONE    0       /* None */
#define SRC     1       /* Source */
#define DST     2       /* Destination */
#define PAT     3       /* Patterned brush */
#define SCTCH   4       /* Scratch area */
#define SSCTCH  5       /* Subsidurary scratch area */

/* Valid logical operators for ROP3 */

#define NOT	0
#define AND	1
#define OR 	2	
#define XOR	3
#define SET	4
#define CLEAR	5
#define COPY	6

#ifdef SWIN_MEMTOMEM_ROPS
/*
 * BCN 2482- these defines removed - 'D' conflicts with the
 * CCPU register variable 'D' (DX reg).
 *
 * Defines for Bitblt operands defined by the rop3 value
 *
 *  #define P       ((IU8) 0xf0)
 *  #define S       ((IU8) 0xcc)
 *  #define D       ((IU8) 0xaa)
 */

IMPORT VOID (*BmpRop3Supported[]) IPT5(
				BITMAP_MAPPING *,srcBitmap,
				BITMAP_MAPPING *,dstBitmap,
				Rectangle *, srcRect,
				Rectangle *, dstRect,
				BRUSH_MAPPING *, bp
				);
IMPORT IU8 BmpOperandTable[];

IMPORT IU8  *convertedLine;
IMPORT ULONG    convertedLineSize;

extern VOID	
BmpRop3MemToMem IPT6(BITMAP_MAPPING *,srcBitmap,BITMAP_MAPPING *,dstBitmap,
Rectangle *, srcRect, Rectangle *,dstRect, IU8, rop3, BRUSH_MAPPING *, bp);
extern BOOL
DirRectFill IPT6(BITMAP_MAPPING *,dstBitmap,BRUSH_MAPPING *,bp, 
LONG,x,LONG,y,ULONG,xExt,ULONG, yExt);
#endif /* SWIN_MEMTOMEM_ROPS */

/*
 * -----------------------------------------------------------------------------
 * Bitmap definitions
 * -----------------------------------------------------------------------------
 */

/* Mapping types */

#define MAP_NULL        0
#define MAP_BITMAP      1
#define MAP_DISPLAY     2

/* BmpOpen flag parameter bit fields */

#define BMPNONE         0x0
#define BMPTRANS        0x1
#define BMPOVRRD        0x2

/* Bitmap formats */

#define MAX_BITMAP_TYPES	4

/* Note that BITMAP16 format is not currently supported (2/12/92) */

#define MONOCHROME	1	/* bits per pixel=1 */
#define BITMAP4		4	/* bits per pixel=4 */
#define BITMAP8		8	/* bits per pixel=8 */
#define BITMAP16        16      /* bits per pixel=16 */
#define BITMAP24	24	/* bits per pixel=24 */

/* Bitmap line conversion functions */

IMPORT VOID	ConvBitmapFormat IPT2(BITMAP_MAPPING *,arg1, ULONG *,arg2);
IMPORT VOID	Conv1To1 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv1To4 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv1To8 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv1To24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv4To1 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv4To4 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv4To8 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv4To24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv8To1 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv8To4 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv8To8 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv8To24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv24To1 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv24To4 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv24To8 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     Conv24To24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     DibConvE24ToI1 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     DibConvE24ToI4 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     DibConvE24ToI8 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     DibConvE24ToI24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     DibConvI1ToE24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     DibConvI4ToE24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     DibConvI8ToE24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     DibConvI24ToE24 IPT3(UTINY *,arg1, UTINY *,arg2, ULONG,arg3);
IMPORT VOID     ConvTrans1To1 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans1To4 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans1To8 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans1To24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans4To1 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans4To4 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans4To8 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans4To24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans8To1 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans8To4 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans8To8 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans8To24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans24To1 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans24To4 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans24To8 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     ConvTrans24To24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     DibConvTransE24ToI1 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     DibConvTransE24ToI4 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     DibConvTransE24ToI8 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     DibConvTransE24ToI24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     DibConvTransI24ToE24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     DibConvTransI1ToE24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     DibConvTransI4ToE24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);
IMPORT VOID     DibConvTransI8ToE24 IPT4(UTINY *,arg1, UTINY *,arg2, ULONG,arg3, MSWPIXEL *,arg4);

/* Host Independent Functions */

IMPORT  VOID    BmpPatternedBrush IPT4(sys_addr,arg1,BRUSH_MAPPING *,arg2,MSWPIXEL,arg3,MSWPIXEL,arg4);
IMPORT  VOID    BmpClip IPT8(SHORT *,arg1,SHORT *,arg2,SHORT *,arg3,SHORT *,arg4,USHORT *,arg5,USHORT *,arg6,USHORT,arg7,USHORT,arg8);
IMPORT  VOID    BmpBitmapToBitmap IPT9(BITMAP_MAPPING *,arg1,BITMAP_MAPPING *,arg2,ULONG,arg3,LONG,arg4,LONG,arg5,ULONG,arg6,ULONG,arg7,LONG,arg8,LONG,arg9);
IMPORT  VOID    BmpLoadBitmap IPT2(sys_addr,arg1,BITMAP_MAPPING *,arg2);
IMPORT	VOID	BmpLoadBitmapHeader IPT2(sys_addr,bmptr,BITMAP_MAPPING *,bitmap);
IMPORT  VOID    BmpSaveBitmap IPT1(BITMAP_MAPPING *,arg1);
IMPORT  VOID    BmpDestroyBitmap IPT1(BITMAP_MAPPING *,arg1);
IMPORT	LONG	BmpMSWType IPT1(sys_addr,bmptr);

#ifdef SWIN_DEVBMP
IMPORT  VOID    BmpSetBitmapBits IPT3(sys_addr, lpDevice, double_word, lpBits, double_word, dwCount);
IMPORT  VOID    BmpGetBitmapBits IPT3(sys_addr, lpDevice, double_word, lpBits, double_word, dwCount);
IMPORT  VOID    BmpCopyBitmapBits IPT3(sys_addr, lpDevice, double_word, lpBits, double_word, dwCount);
#endif /* SWIN_DEVBMP */


/* Array of Binary ROP Functions supported for BitmapToBitmap
 * NB. 0 means "not supported"
 */

IMPORT	VOID	(*MoveLine[]) IPT7(SHIFTUNIT *,srcbits, SHIFTUNIT *,dstbits, ULONG,srcoffset,ULONG,dstoffset,ULONG,lshift,ULONG,rshift,ULONG,width);


/* Host dependent Functions */

IMPORT  BOOL    BmpFastDspToBmp IPT11(sys_addr,bmptr,IU8,rop,
	sys_addr,lpPBrush,HOSTPIXEL,fg,HOSTPIXEL,bg,
	LONG,bx,LONG,by,ULONG,xext,ULONG,yext,LONG,dx,LONG,dy);
IMPORT  BOOL    BmpFastBmpToDsp IPT11(sys_addr,bmptr,IU8,rop,
	sys_addr,lpPBrush,HOSTPIXEL,fg,HOSTPIXEL,bg,
	LONG,bx,LONG,by,ULONG,xext,ULONG,yext,LONG,dx,LONG,dy);
#ifdef SWIN_MEMTOMEM_ROPS
extern  BOOL    BmpFastBmpToBmp IPT12(sys_addr,srcdev,sys_addr,dstdev,
	IU8,rop,sys_addr,lpPBrush,HOSTPIXEL,fg,HOSTPIXEL,bg,
	SHORT,sx,SHORT,sy,USHORT,xext,USHORT,yext, SHORT,dx,SHORT,dy);
#else
IMPORT  BOOL    BmpFastBmpToBmp IPT12(sys_addr,srcdev,sys_addr,dstdev,
	IU8,rop,sys_addr,lpPBrush,HOSTPIXEL,fg,HOSTPIXEL,bg,
	LONG,sx,LONG,sy,ULONG,xext,ULONG,yext, LONG,dx,LONG,dy);
#endif
IMPORT  BOOL    BmpFastDspToDsp IPT10(sys_addr,srcdev,sys_addr,dstdev,
	IU8,rop,sys_addr,lpPBrush,LONG,sx,LONG,sy,ULONG,xext,ULONG,yext,
	LONG,dx,LONG,dy);
IMPORT  VOID    BmpOpen IPT9(sys_addr,bmptr,HOSTPIXEL,fg,HOSTPIXEL,bg,
	LONG,active_x,LONG,active_y,ULONG,active_width,ULONG,active_height,
	ULONG,flags,BITMAP_MAPPING *,bm_return);
IMPORT  VOID    BmpClose IPT1(BITMAP_MAPPING *,bitmap);
IMPORT  VOID    BmpCancel IPT1(BITMAP_MAPPING *,bitmap);
IMPORT  VOID    BmpInit IPT0();
IMPORT  VOID    BmpTerm IPT0();
#ifdef SWIN_BMPTOXIM
IMPORT  VOID    BmpPutMSWBitmap IPT4(BITMAP_MAPPING *,bitmap, IU8,rop,
	SHORT,src_x, SHORT,src_y);
#else
IMPORT  VOID    BmpPutMSWBitmap IPT4(BITMAP_MAPPING *,bitmap, IU8,rop,
	LONG,src_x, LONG,src_y);
#endif
IMPORT  VOID    BmpGetMSWBitmap IPT5(BITMAP_MAPPING *,bitmap, IU8,rop,
	LONG,dst_x, LONG,dst_y, BRUSH_MAPPING *,bp);
IMPORT	VOID	BmpFastSolidFill IPT6(BITMAP_MAPPING *,bm,BRUSH_MAPPING *,bp,LONG,x,LONG,y,IS32,xext,FAST IS32,yext);

/*
 * -----------------------------------------------------------------------------
 * Colour definitions
 * -----------------------------------------------------------------------------
 */

/* Valid colour formats supported */

#define COLOUR2         2
#define COLOUR8         8
#define COLOUR16        16
#define COLOUR256       256
#define COLOURTRUE24	0xFFFF

/* RGB shift values */

#define RGB_FLAGS_SHIFT         24
#define RGB_RED_SHIFT           16
#define RGB_GREEN_SHIFT         8
#define RGB_BLUE_SHIFT          0
#define RGB_SHIFT      		BITSPERBYTE

/* RGB values */

#define RGB_BLACK       (MSWCOLOUR) (0x00000000)
#define RGB_BLUE        (MSWCOLOUR) (0x000000FF)
#define RGB_GREEN       (MSWCOLOUR) (0x0000FF00)
#define RGB_RED         (MSWCOLOUR) (0x00FF0000)
#define RGB_WHITE       (MSWCOLOUR) (0x00FFFFFF)
#define RGB_FLAGS       (MSWCOLOUR) (0xFF000000)

/* Masks */

#define RGB_MASK        (UTINY) (BYTEMASK)
#define PAL_INDEX_MASK  ~(DOUBLEWORDMASK << mswdvr.bitsPixel)

/* Colour to monochrome threshold */

#define BW_THRESHOLD    (RGB_MASK*3)/2

/* Make sure no palette translation occurs for a colour */

#define ColNoTranslate(colour) (colour & ~(RGB_FLAGS))

/* RGB <-> BGR */

#define ReverseRGB(rgb) \
\
{ half_word     loByte, miByte, hiByte; \
  if ((rgb & RGB_FLAGS) != RGB_FLAGS) { \
  	hiByte = (rgb & RGB_RED) >> RGB_RED_SHIFT; \
  	miByte = (rgb & RGB_GREEN) >> RGB_GREEN_SHIFT; \
  	loByte = (rgb & RGB_BLUE) >> RGB_BLUE_SHIFT; \
  	rgb = ((MSWCOLOUR) loByte << RGB_RED_SHIFT) | \
              ((MSWCOLOUR) miByte << RGB_GREEN_SHIFT) | \
	      ((MSWCOLOUR) hiByte << RGB_BLUE_SHIFT); } }

/* Swap macro */

#define swap(a, b)      { ULONG tempDWord=a; a = b; b = tempDWord; }

/* Host Independent Functions */

IMPORT VOID             ColDitherBrush IPT2(MSWCOLOUR,arg1, BRUSH_MAPPING *,arg2);
IMPORT HOSTPIXEL        ColPixel IPT1(MSWCOLOUR,arg1);
IMPORT MSWPIXEL         ColLogPixel IPT1(MSWCOLOUR,arg1);
IMPORT MSWCOLOUR        ColRGB IPT1(MSWPIXEL,arg1);
IMPORT MSWCOLOUR        ColLogRGB IPT1(MSWPIXEL,arg1);

/* Host dependent Functions */

IMPORT VOID		ColSetColourmapEntry IPT2(MSWCOLOURMAP *,arg1, MSWCOLOUR,arg2);
IMPORT BOOL             ColInit IPT0();
IMPORT VOID             ColTerm IPT0();
IMPORT VOID             ColTranslateBrush IPT1(BRUSH_MAPPING *,arg1);
IMPORT VOID             ColTranslatePen IPT1(PEN_MAPPING *,arg1);
IMPORT VOID		ColUpdatePalette IPT2(word,arg1, word,arg2);
IMPORT MSWPIXEL		ColMono IPT1(MSWCOLOUR,arg1);

/*
 * -----------------------------------------------------------------------------
 * Text definitions
 * -----------------------------------------------------------------------------
 */

/* Host independent Functions */

IMPORT VOID     TxtMergeRectangle IPT2(Rectangle *,arg1, Rectangle *,arg2);

/* Host dependent Functions */

IMPORT VOID     TxtInit IPT0();
IMPORT VOID     TxtTerm IPT0();
IMPORT VOID	TxtOpaqueRectangle IPT3(BITMAP_MAPPING *,arg1, Rectangle *,arg2, MSWCOLOUR,arg3);
IMPORT VOID	TxtPutTextBitmap IPT4(BITMAP_MAPPING *,arg1, BITMAP_MAPPING *,arg2, ULONG,arg3, ULONG,arg4);
IMPORT VOID	TxtTextAccess IPT4(MSWCOLOUR,arg1, MSWCOLOUR,arg2, word,arg3, Rectangle *,arg4);

/*
 * -----------------------------------------------------------------------------
 * DIB definitions
 * -----------------------------------------------------------------------------
 */

/* Host dependent Functions */

IMPORT VOID DibInit IPT0();
IMPORT VOID DibTerm IPT0();

/*
 * -----------------------------------------------------------------------------
 * Object definitions
 * -----------------------------------------------------------------------------
 */

/* Host independent Functions */

IMPORT VOID	ObjGetRect IPT2(sys_addr,arg1, Rectangle *,arg2);
#ifdef SWIN_DEVBMP
IMPORT word     ObjPBitmapOpen IPT1(sys_addr, arg1);
IMPORT VOID     ObjPBitmapRestore IPT2(sys_addr, arg1, word *, arg2);
IMPORT VOID     ObjPBitmapSave IPT3(sys_addr, arg1, sys_addr, arg2, word, arg3);
IMPORT VOID     ObjPBitmapClose IPT1(word, arg1);
IMPORT BITMAP_MAPPING   *ObjPBitmapAccess IPT1(sys_addr, lpPBitmap);
#endif /* SWIN_DEVBMP */


/* Host dependent Functions */

IMPORT VOID             ObjInit IPT0();
IMPORT VOID             ObjTerm IPT0();
IMPORT BRUSH_MAPPING    *ObjPBrushAccess IPT4(sys_addr,pbr,BITMAP_MAPPING *,bmp,IU8,rop2,sys_addr,clip);
IMPORT PEN_MAPPING      *ObjPPenAccess IPT5(sys_addr,pp,BITMAP_MAPPING *,bmp,IU8,rop2,sys_addr,clip,word,back_mode);
IMPORT word		ObjPenOpen IPT1(sys_addr,arg1);
IMPORT VOID		ObjPenClose IPT1(word,arg1);
IMPORT word		ObjBrushOpen IPT3(sys_addr,arg1, word,arg2, word,arg3);
IMPORT VOID		ObjBrushClose IPT1(word,arg1);
IMPORT VOID 		ObjPPenSave IPT2(sys_addr,arg1, word,arg2);
IMPORT VOID		ObjPPenRestore IPT2(sys_addr,arg1, word *,arg2);
IMPORT VOID 		ObjPBrushSave IPT2(sys_addr,arg1, word,arg2);
IMPORT VOID		ObjPBrushRestore IPT2(sys_addr,arg1, word *,arg2);
IMPORT	BOOL		ObjValidPPen IPT1(sys_addr,ppen);

#ifdef SWIN_MEM_POLYLINE
IMPORT	BOOL		ObjDirPPen IPT1(sys_addr,ppen);
#endif /* SWIN_MEM_POLYLINE */


/*
 * -----------------------------------------------------------------------------
 * Pattern Library definitions
 * -----------------------------------------------------------------------------
 */

/* Host independent Functions */

IMPORT  VOID    LibHatchedTile IPT4(BRUSH_MAPPING *,arg1, word,arg2, MSWPIXEL,arg3, MSWPIXEL,arg4);

/* Host dependent Functions */

IMPORT  VOID    LibPatLibInit IPT0();
IMPORT  VOID    LibPatLibTerm IPT0();

/*
 * -----------------------------------------------------------------------------
 * Save screen bitmap definitions
 * -----------------------------------------------------------------------------
 */

IMPORT  VOID    SavInit IPT0();
IMPORT  VOID    SavTerm IPT0();

/*
 * -----------------------------------------------------------------------------
 * Pointer definitions
 * -----------------------------------------------------------------------------
 */

/* Host dependent Functions */

IMPORT	VOID	PtrInit IPT0();
IMPORT	VOID	PtrTerm IPT0();
                    
/*
 * -----------------------------------------------------------------------------
 * Resource defintions
 * -----------------------------------------------------------------------------
 */

/* Host dependent Functions */

IMPORT VOID     ResInit IPT0();
IMPORT VOID     ResTerm IPT0();
IMPORT VOID	ResAllocateBitmapMapping IPT3(BITMAP_MAPPING *,arg1, ULONG,arg2, ULONG,arg3);
IMPORT VOID	ResDeallcateBitmapMapping IPT1(BITMAP_MAPPING *, arg1);
IMPORT VOID	ResAllocateBitmapMemory IPT1(BITMAP_MAPPING *,arg1);
IMPORT VOID	ResDeallcateBitmapMemory IPT1(BITMAP_MAPPING *, arg1);

/*
 * -----------------------------------------------------------------------------
 * Global variables
 * -----------------------------------------------------------------------------
 */

/* Windows driver global data area */

IMPORT MSW_DATA	mswdvr;

/* Bitmap line conversion function tables */

IMPORT VOID     (*convFuncs[MAX_BITMAP_TYPES][MAX_BITMAP_TYPES])();
IMPORT VOID     (*convTransFuncs[MAX_BITMAP_TYPES][MAX_BITMAP_TYPES])();
IMPORT VOID     (*DibconvFuncsEToI[MAX_BITMAP_TYPES][MAX_BITMAP_TYPES])();
IMPORT VOID     (*DibconvFuncsIToE[MAX_BITMAP_TYPES][MAX_BITMAP_TYPES])();
IMPORT VOID     (*DibconvTransFuncsEToI[MAX_BITMAP_TYPES][MAX_BITMAP_TYPES])();
IMPORT VOID     (*DibconvTransFuncsIToE[MAX_BITMAP_TYPES][MAX_BITMAP_TYPES])();

/* Context information set in ms_windows.c to provide global information
 * about the overall operation. Note that this information is independent
 * of the host implementation and is therefore defined in the Base include
 * file.
 */
typedef struct {
	int	dest_depth;		/* format changes in BitBlt */
	IBOOL	translate_palette;	/* needed for index colours? */
	IBOOL	dest_is_display;	/* used by Mac etc */
} MSW_CONTEXT;

IMPORT MSW_CONTEXT msw_context;

#ifdef SWIN_DEVBMP
IMPORT BITMAP_MAPPING   *ppbitmap;
IMPORT ULONG            ppbitmapEntries;
IMPORT ULONG            ppbitmapSize;
#endif /* SWIN_DEVBMP */

IMPORT IBOOL		mode_exit;	/* tells us if exite due to video mode change */

/*
 * -----------------------------------------------------------------------------
 * MS-Windows Driver Top Level Functions
 * -----------------------------------------------------------------------------
 */

IMPORT VOID	BltBitblt IPT11(sys_addr,lpDestDev,word,wDestX,word,wDestY,sys_addr,lpSrcDev,word,wSrcX,word,wSrcY,word,wXext,word,wYext,IU8,rop3,sys_addr,lpPBrush,sys_addr,lpDrawMode);

IMPORT VOID 	BltStretchBlt IPT14(sys_addr,dstdev,word,dx,word,dy,word,xext,word,yext,sys_addr,arg6,word,arg7,word,arg8,word,arg9,word,arg10,
                    IU8,rop,sys_addr,pbrush,sys_addr,drawmode,sys_addr,cliprect);

IMPORT VOID	BltFastBorder IPT11(sys_addr,dstdev,word,dx,word,dy,word,xext,
		word,yext,word,bt,word,vbt,IU8,rop,sys_addr,pbrush,
		sys_addr,drawmode,sys_addr,cliprect);

IMPORT VOID	ColColorInfo IPT3(sys_addr,arg1,double_word,arg2,sys_addr,arg3);
IMPORT VOID 	ColSetPalette IPT3(word,arg1,word,arg2,sys_addr,arg3);
IMPORT VOID	ColGetPalette IPT3(word,arg1,word,arg2,sys_addr,arg3);
IMPORT VOID	ColSetPalTrans IPT1(sys_addr,arg1);
IMPORT VOID	ColGetPalTrans IPT1(sys_addr,arg1);
IMPORT VOID	ColUpdateColors IPT5(word,arg1,word,arg2,word,arg3,word,arg4,sys_addr,arg5);

IMPORT VOID	DibDeviceBitmapBits IPT8(sys_addr,arg1,word,arg2,word,arg3,word,arg4,double_word,arg5,sys_addr,arg6,sys_addr,arg7,sys_addr,arg8);
IMPORT VOID	DibSetDIBitsToDevice IPT10(sys_addr,arg1,word,arg2,word,arg3,word,arg4,word,arg5,sys_addr,arg6,sys_addr,arg7,double_word,arg8,sys_addr,arg9,sys_addr,arg10);

IMPORT VOID	LgoLogo IPT1(sys_addr,arg1);

IMPORT VOID	ObjRealizeObject IPT5(word,arg1,sys_addr,arg2,sys_addr,arg3,word,arg4,word,arg5);

IMPORT VOID	OutOutput IPT8(sys_addr,arg1,word,arg2,word,arg3,sys_addr,arg4,sys_addr,arg5,sys_addr,arg6,sys_addr,arg7,sys_addr,arg8);

IMPORT VOID	PtrCheckCursor IPT0();

IMPORT VOID	PtrMoveCursor IPT2(word,arg1,word,arg2);

IMPORT VOID	PtrSetCursor IPT1(sys_addr,arg1);

IMPORT VOID	SavSaveScreenBitmap IPT5(word,arg1,word,arg2,word,arg3,word,arg4,word,arg5);

IMPORT VOID	TxtExtTextOut IPT12(sys_addr,arg1,word,arg2,word,arg3,sys_addr,arg4,sys_addr,arg5,word,arg6,sys_addr,arg7,sys_addr,arg8,sys_addr,arg9,
			      sys_addr,arg10,sys_addr,arg11,word,arg12);

IMPORT VOID	TxtGetCharWidth IPT7(sys_addr,arg1,sys_addr,arg2,word,arg3,word,arg4,sys_addr,arg5,sys_addr,arg6,sys_addr,arg7);

IMPORT VOID	TxtStrblt IPT9(sys_addr,arg1,word,arg2,word,arg3,sys_addr,arg4,sys_addr,arg5,word,arg6,sys_addr,arg7,sys_addr,arg8,sys_addr,arg9);

IMPORT VOID	WinControl IPT4(sys_addr,arg1,word,arg2,sys_addr,arg3,sys_addr,arg4);
IMPORT VOID	WinDisable IPT1(sys_addr,arg1);
IMPORT VOID	WinEnable IPT5(sys_addr,arg1,word,arg2,sys_addr,arg3,sys_addr,arg4,sys_addr,arg5);
IMPORT VOID	WinPixel IPT5(sys_addr,arg1,word,arg2,word,arg3,MSWCOLOUR,arg4,sys_addr,arg5);
IMPORT VOID	WinScanlr IPT5(sys_addr,arg1,word,arg2,word,arg3,MSWCOLOUR,arg4,word,arg5);

#ifdef SWIN_DEVBMP
IMPORT VOID ObjBitmapBits IPT4(sys_addr,lpDevice,double_word,fFlags,double_word,dwCount,double_word,lpBits);
IMPORT VOID ObjSelectBitmap IPT4(sys_addr,lpDevice,sys_addr,lpPrevBitmap,sys_addr,lpBitmap,double_word,fFlags);
#endif /* SWIN_DEVBMP */

/*
 * -----------------------------------------------------------------------------
 * MS-Windows Driver Low Level Functions (Totally host dependent)
 * -----------------------------------------------------------------------------
 */

IMPORT MSWCOLOUR	LowGetPixel IPT3(BITMAP_MAPPING *,arg1,ULONG,arg2,ULONG,arg3);
IMPORT VOID	     	LowSetPixel IPT5(BITMAP_MAPPING *,arg1,ULONG,arg2,ULONG,arg3,ULONG,arg4,MSWCOLOUR,arg5);
IMPORT VOID 		LowStretchArea IPT3(BITMAP_MAPPING *,arg1, BITMAP_MAPPING *,arg2, Rectangle *,arg3);
IMPORT VOID		LowFillArea IPT2(BITMAP_MAPPING *,arg1, BRUSH_MAPPING *,arg2);
IMPORT VOID	     	LowCopyArea IPT3(BITMAP_MAPPING *,arg1,BITMAP_MAPPING *,arg2, ULONG,arg3);
IMPORT VOID		LowFillRectangle IPT6(BITMAP_MAPPING *,arg1, BRUSH_MAPPING *,arg2,LONG,arg3,LONG,arg4,ULONG,arg5,ULONG,arg6);
IMPORT VOID		LowDrawRectangle IPT6(BITMAP_MAPPING *,arg1, PEN_MAPPING *,arg2,LONG,arg3,LONG,arg4,ULONG,arg5,ULONG,arg6);
IMPORT VOID 		LowFillRoundRect IPT8(BITMAP_MAPPING *,arg1, BRUSH_MAPPING *,arg2,LONG,arg3,LONG,arg4,ULONG,arg5,ULONG,arg6,ULONG,arg7,ULONG,arg8);
IMPORT VOID		LowDrawRoundRect IPT8(BITMAP_MAPPING *,arg1,PEN_MAPPING *,arg2,LONG,arg3,LONG,arg4,ULONG,arg5,ULONG,arg6,ULONG,arg7,ULONG,arg8);
IMPORT VOID		LowFillRectangles IPT4(BITMAP_MAPPING *,arg1, BRUSH_MAPPING *,arg2,Rectangle *,arg3, ULONG,arg4);
IMPORT VOID		LowDrawLine IPT6(BITMAP_MAPPING *,arg1, PEN_MAPPING *,arg2, LONG,arg3,LONG,arg4,LONG,arg5,LONG,arg6);
IMPORT VOID		LowFillEllipse IPT6(BITMAP_MAPPING *,arg1, BRUSH_MAPPING *,arg2, LONG,arg3,LONG,arg4,ULONG,arg5,ULONG,arg6);
IMPORT VOID		LowDrawEllipse IPT6(BITMAP_MAPPING *,arg1, PEN_MAPPING *,arg2, LONG,arg3,LONG,arg4,ULONG,arg5,ULONG,arg6);
IMPORT VOID		LowDrawScanline IPT5(BITMAP_MAPPING *,arg1, PEN_MAPPING *,arg2, LONG,arg3,LONG,arg4,ULONG,arg5);
IMPORT VOID		LowFillScanline IPT5(BITMAP_MAPPING *,arg1, BRUSH_MAPPING *,arg2, LONG,arg3,LONG,arg4,ULONG,arg5);

/*
 *------------------------------------------------------------------------------
 * SmartCopy specific defines, global variables and externs
 *------------------------------------------------------------------------------
 */

#ifndef HostProcessClipData
/* List of #defines from "windows.h" v3.10 */
 
#define CF_NULL              0
#define CF_TEXT		     1
#define CF_BITMAP            2
#define CF_METAFILEPICT      3
#define CF_SYLK              4
#define CF_DIF               5
#define CF_TIFF              6
#define CF_OEMTEXT           7
#define CF_DIB               8
#define CF_PALETTE           9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12
 
#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT          0x0081
#define CF_DSPBITMAP        0x0082
#define CF_DSPMETAFILEPICT  0x0083
 
/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST      0x02FF
 
/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST      0x0300
#define CF_GDIOBJLAST       0x03FF
 
#define POLL_UPDATE_HOST_CLIPBOARD 0
#define POLL_UPDATE_WINDOWS_CLIPBOARD 1
#define POLL_UPDATE_WINDOWS_DISPLAY	2

#ifndef HOST_CLIPBOARD_TIMEOUT
#define HOST_CLIPBOARD_TIMEOUT 40
#endif

/* types of clipbop */
 
#define GETPOLLADDR             0
#define PROCESSCLIPBOARD        1
#define POLLFORCINPUT           2
#define GETCBDATA               3
#define REMOVEPOLLADDR          4
#define GETPOLLREASON           5
#define EMPTYCLIPBOARD			6
#define DONEPROCESSING			7
 
extern BOOL 	smcpyInitialised;	/* SmartCopy initialised ? */
extern BOOL 	smcpyMissedPoll;
extern int  Reasonforpoll;	/* Why has smartcopy been polled */

extern VOID HostProcessClipData();
extern IBOOL HostClipboardChanged();
extern VOID HostResetClipboardChange();
extern VOID HostInitClipboardChange();
extern VOID HostGetClipData();
extern IBOOL HostAssessClipData();
extern VOID HostGetPollReason();
extern VOID msw_causepoll();
extern IBOOL msw_stillpolling();

#endif /* HostProcessClipData */
#endif /* MSWDVR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\m_keybdp.h ===
/*[
	Name:		M_keybdP.h
	Derived From:	Cut out of M_keybd.c
	Author:		gvdl
	Created On:	30 July 1991
	Sccs ID:	08/10/92 @(#)M_keybdP.h	1.4
	Purpose:	Default KeySym to AT matrix keycode mapping table.

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

In the table below the index of the entry is the AT matrix code as returned
to the keyboard internal CPU.
]*/

/*
 * Local variables used in X keycode to PC keycode conversion
 */
LOCAL KeySym KeySymTable[] = 
{
	XK_BackSpace,		/*   0  0x00 */
	XK_grave,		/*   1  0x01 */
	XK_1,			/*   2  0x02 */
	XK_2,			/*   3  0x03 */
	XK_3,			/*   4  0x04 */
	XK_4,			/*   5  0x05 */
	XK_5,			/*   6  0x06 */
	XK_6,			/*   7  0x07 */
	XK_7,			/*   8  0x08 */
	XK_8,			/*   9  0x09 */
	XK_9,			/*  10  0x0a */
	XK_0,			/*  11  0x0b */
	XK_minus,		/*  12  0x0c */
	XK_equal,		/*  13  0x0d */
	0,			/*  14  0x0e */
	XK_BackSpace,		/*  15  0x0f */
	XK_Tab,			/*  16  0x10 */
	XK_q,			/*  17  0x11 */
	XK_w,			/*  18  0x12 */
	XK_e,			/*  19  0x13 */
	XK_r,			/*  20  0x14 */
	XK_t,			/*  21  0x15 */
	XK_y,			/*  22  0x16 */
	XK_u,			/*  23  0x17 */
	XK_i,			/*  24  0x18 */
	XK_o,			/*  25  0x19 */
	XK_p,			/*  26  0x1a */
	XK_bracketleft,		/*  27  0x1b */
	XK_bracketright,	/*  28  0x1c */
	XK_backslash,		/*  29  0x1d */
	XK_Caps_Lock,		/*  30  0x1e */
	XK_a,			/*  31  0x1f */
	XK_s,			/*  32  0x20 */
	XK_d,			/*  33  0x21 */
	XK_f,			/*  34  0x22 */
	XK_g,			/*  35  0x23 */
	XK_h,			/*  36  0x24 */
	XK_j,			/*  37  0x25 */
	XK_k,			/*  38  0x26 */
	XK_l,			/*  39  0x27 */
	XK_semicolon,		/*  40  0x28 */
	XK_apostrophe,		/*  41  0x29 */
	0,			/*  42  0x2a */
	XK_Return,		/*  43  0x2b */
	XK_Shift_L,		/*  44  0x2c */
	0,			/*  45  0x2d */
	XK_z,			/*  46  0x2e */
	XK_x,			/*  47  0x2f */
	XK_c,			/*  48  0x30 */
	XK_v,			/*  49  0x31 */
	XK_b,			/*  50  0x32 */
	XK_n,			/*  51  0x33 */
	XK_m,			/*  52  0x34 */
	XK_comma,		/*  53  0x35 */
	XK_period,		/*  54  0x36 */
	XK_slash,		/*  55  0x37 */
	0,			/*  56  0x38 */
	XK_Shift_R,		/*  57  0x39 */
	XK_Control_L,		/*  58  0x3a */
	0,			/*  59  0x3b */
	XK_Alt_L,		/*  60  0x3c */
	XK_space,		/*  61  0x3d */
	XK_Alt_R,		/*  62  0x3e */
	0,			/*  63  0x3f */
	XK_Control_R,		/*  64  0x40 */
	0,			/*  65  0x41 */
	0,			/*  66  0x42 */
	0,			/*  67  0x43 */
	0,			/*  68  0x44 */
	0,			/*  69  0x45 */
	0,			/*  70  0x46 */
	0,			/*  71  0x47 */
	0,			/*  72  0x48 */
	0,			/*  73  0x49 */
	0,			/*  74  0x4a */
	XK_Insert,		/*  75  0x4b */
	XK_Delete,		/*  76  0x4c */
	0,			/*  77  0x4d */
	0,			/*  78  0x4e */
	XK_Left,		/*  79  0x4f */
	XK_Home,		/*  80  0x50 */
	XK_End,			/*  81  0x51 */
	0,			/*  82  0x52 */
	XK_Up,			/*  83  0x53 */
	XK_Down,		/*  84  0x54 */
	XK_Prior,		/*  85  0x55 */
	XK_Next,		/*  86  0x56 */
	0,			/*  87  0x57 */
	0,			/*  88  0x58 */
	XK_Right,		/*  89  0x59 */
	XK_Num_Lock,		/*  90  0x5a */
	XK_KP_7,		/*  91  0x5b */
	XK_KP_4,		/*  92  0x5c */
	XK_KP_1,		/*  93  0x5d */
	0,			/*  94  0x5e */
	XK_KP_Divide,		/*  95  0x5f */
	XK_KP_8,		/*  96  0x60 */
	XK_KP_5,		/*  97  0x61 */
	XK_KP_2,		/*  98  0x62 */
	XK_KP_0,		/*  99  0x63 */
	XK_KP_Multiply,		/* 100  0x64 */
	XK_KP_9,		/* 101  0x65 */
	XK_KP_6,		/* 102  0x66 */
	XK_KP_3,		/* 103  0x67 */
	XK_KP_Decimal,		/* 104  0x68 */
	XK_KP_Subtract,		/* 105  0x69 */
	XK_KP_Add,		/* 106  0x6a */
	0,			/* 107  0x6b */
	XK_KP_Enter,		/* 108  0x6c */
	0,			/* 109  0x6d */
	XK_Escape,		/* 110  0x6e */
	0,			/* 111  0x6f */
	XK_F1,			/* 112  0x70 */
	XK_F2,			/* 113  0x71 */
	XK_F3,			/* 114  0x72 */
	XK_F4,			/* 115  0x73 */
	XK_F5,			/* 116  0x74 */
	XK_F6,			/* 117  0x75 */
	XK_F7,			/* 118  0x76 */
	XK_F8,			/* 119  0x77 */
	XK_F9,			/* 120  0x78 */
	XK_F10,			/* 121  0x79 */
	XK_F11,			/* 122  0x7a */
	XK_F12,			/* 123  0x7b */
	XK_Print,		/* 124  0x7c */
	XK_Scroll_Lock,		/* 125  0x7d */
	XK_Pause,		/* 126  0x7e */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\m_fs.h ===
#ifndef _x_FS_H
#define _x_FS_H

typedef enum {
	NEW_DISK_SEL = 0,
	OPEN_C_SEL,
	OPEN_D_SEL,
	OPEN_FSA_SEL,
	KEYB_FILE_SEL,
	LAST_SEL
} titleEnum;

#endif /* _x_FS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\m_lpcmp.h ===
#ifndef _M_LPCMp_H
#define _M_LPCMp_H

typedef struct {
	Widget menu, text;
	UTINY nameID, typeID;
	BOOL checked, active;
} lpcmEntry;

#define MAX_BUTTONS 10

#ifdef ANSI
IMPORT VOID lpcmVerifyEntry();
IMPORT VOID lpcmRefreshPanel(lpcmEntry entry[], UTINY numEntries);
#else /* ANSI */
IMPORT VOID lpcmVerifyEntry();
IMPORT VOID lpcmRefreshPanel();
#endif /* ANSI */

#endif /* _M_LPCMp_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\novell.h ===
/*[
 *	Name:			novell.h
 *
 *	Derived From:	original
 *
 *	Author:			David Linnard
 *
 *	Created On:		28th May, 1992
 *
 *	Purpose :		Main Novell include file
 *
 *  Interface:
 *
 *	(c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
]*/

/* SccsID[]="@(#)novell.h	1.11 05/15/95 Copyright Insignia Solutions Ltd."; */

/*
 * Constants and macros to access Transmit Control Blocks (TCBs)
 */


/* TCB fields */
#define TCBDriverWS			0	/* 6 bytes of driver workspace - unused by us */
#define TCBDataLength		6	/* Total frame length - But use CX for real value for Ethernet */
#define TCBFragStrucPtr		8	/* FAR pointer to Fragment Structure */
#define TCBMediaHeaderLen	12	/* Length of Media header - which comes next. May be zero */
#define TCBMediaHeader		14	/* The media header */

#define getTCBDataLength(TCB)	sas_w_at(TCB+TCBDataLength)
#define getTCBFragStruc(TCB)	effective_addr( sas_w_at( TCB+TCBFragStrucPtr + 2 ), sas_w_at( TCB+TCBFragStrucPtr ) )
#define getTCBMediaHdrLen(TCB)	sas_w_at(TCB+TCBMediaHeaderLen)
#define getTCBMediaHdr(TCB,i)	sas_hw_at(TCB+TCBMediaHeader+i)

/* Fragment structure fields */
#define FFragmentCount		0	/* Number of fragments. Cannot be zero */
#define FFrag0Address 		2	/* FAR pointer to first fragment data */
#define	FFrag0Length		6	/* Length of first fragment */

#define getnTFrags(FF)		sas_w_at(FF+FFragmentCount)
#define getTFragPtr(FF,i)	effective_addr( sas_w_at( FF+FFrag0Address+6*i+2 ), sas_w_at( FF+FFrag0Address+6*i ) )
#define getTFragLen(FF,i)	sas_w_at(FF+FFrag0Length+6*i)

/*
 * Constants and macros to access Receive Control Blocks (RCBs)
 */

/* RCB fields */
#define RCBDriverWS			0	/* 8 bytes of driver workspace - unused by us */
#define RCBReserved			8	/* 36 bytes of reserved space */
#define RCBFragCount		44	/* Number of fragments */
#define RCBFrag0Addr		46	/* Pointer to first fragment */
#define RCBFrag0Len			50	/* Length of first fragment */

#define getnRFrags(RCB)		sas_w_at(RCB+RCBFragCount)
#define getRFragPtr(RCB,i)	effective_addr( sas_w_at( RCB+RCBFrag0Addr+6*i+2 ), sas_w_at( RCB+RCBFrag0Addr+6*i ) )
#define getRFragLen(RCB,i)	sas_w_at(RCB+RCBFrag0Len+6*i)

/* Media/Frame types as defined in Appendix B-2 of ODI Developer's Guide */
#define VIRTUAL_LAN		0	/* Used for 'tunnelled' IPX on APpleTalk */
#define	ENET_II			2
#define ENET_802_2		3
#define	ENET_802_3		5
#define ENET_SNAP		10
#define TOKN_RING		4
#define TOKN_RING_SNAP	11

/* Max number of active protocols - Should be plenty!! */
#define	MAX_PROTOS		10

/* AddProtocolID errors as defined on p. 15-8 of ODI Developer's Guide */
#define LSLERR_OUT_OF_RESOURCES	0x8001
#define LSLERR_BAD_PARAMETER	0x8002
#define LSLERR_DUPLICATE_ENTRY	0x8009

/* network hardware defines */
#define	ENET_HARDWARE			1
#define	TOKN_HARDWARE			2

/* size of standard IPX header */
#define	IPX_HDRSIZE				30

/* maximum Ethernet multicast addresses */
#define	MAX_ENET_MC_ADDRESSES	16

/************************  typedefs  ***********************/

typedef struct
{
	IU16	frameID;
	IU8		protoID[6];
	int		fd;
} ODIproto;

/* define a 6 byte quantity for use in the wds hdr */
typedef unsigned char   netAddr[6];

typedef	unsigned long	netNo	;

/* Note that word quantities in IPX headers are BIGEND */
typedef struct
{
	IU16		checksum	;	/* Checksum - always FFFF */
	IU16	 	IPXlength	;	/* Length according to IPX */
	IU8			transport	;	/* Count of bridges enountered? */
	IU8			type		;	/* Packet type - usually 0 or 4 */
	netNo		destNet		;	/* Destination network */
	netAddr		destNode	;	/* Destination Ethernet address */
	IU16		destSock	;	/* Destination socket */
	netNo		srcNet		;	/* Source network */
	netAddr		srcNode		;	/* Source Ethernet address */
	IU16		srcSock		;	/* Source socket */	
	IU8		 	data[547]	;	/* The packet */
} IPXPacket_s ;


typedef struct rcvPacket_t
{
	IU8			length[2];		/* Packet length if any */
	IU8			MAChdr[14];		/* MAC size - right for E2 & 802.3 */
	IPXPacket_s	pack;			/* The received IPX packet */
} rcvPacket_s ;


/* Host routine declarations */
extern	IU32	host_netInit IPT2 (IU16, frame, IU8 *, nodeAddr);
extern	void	host_termNet IPT0 ();

extern	IU32 	host_AddProtocol IPT2
	(IU16, frameType, IU8 *, protoID) ;
extern	void 	host_DelProtocol IPT2
	(IU16, frameType, IU8 *, protoID) ;

extern	void	host_sendPacket IPT2
	(sys_addr, theTCB, IU32, packLen) ;

extern	void	host_AddEnetMCAddress IPT1 (IU8 *, address);
extern	void	host_DeleteEnetMCAddress IPT1 (IU8 *, address);

extern	void	host_changeToknMultiCast IPT2
	(IU16, addrPt1, IU16, addrPt2);

extern	void	host_changePromiscuous IPT2
	(IU16, boardNo, IU16, enableDisableMask ) ;

extern	IU16	host_OpenSocket IPT1 (IU16, socketNumber);
extern	void	host_CloseSocket IPT1 (IU16, socketNumber);

/* Base routine declarations */
extern	void	movReadBuffIntoM IPT0 ();
extern	void	DriverInitialize IPT0 ();
extern	void	DriverSendPacket IPT0 ();
extern	void	DriverReadPacket IPT0 ();
extern	void	DriverMulticastChange IPT0 ();
extern	void	DriverShutdown IPT0 ();
extern	void	DriverAddProtocol IPT0 ();
extern	void	DriverChangePromiscuous IPT0 ();
extern	void	DriverCheckForMore IPT0 ();
#ifdef V4CLIENT
extern	void	ODIChangeIntStatus IPT1 ( IU16, status ) ;
#endif	/* V4CLIENT */
extern	void	net_term IPT0 ();

/* misc defines */

#ifndef PROD
#define		NOT_FOR_PRODUCTION( someCode )  someCode ;
#else
#define		NOT_FOR_PRODUCTION( someCode ) 
#endif

/********************** end of novell.h *************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\ppi.h ===
/*
 * VPC-XT Revision 2.0
 *
 * Title	: PPI Adpator definitions
 *
 * Description	: Definitions for users of the PPI Adaptor 
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 */

/* SccsID[]="@(#)ppi.h	1.4 08/10/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/* None */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#ifdef ANSI
extern void ppi_init(void);
extern void ppi_inb(io_addr,half_word *);
extern void ppi_outb(io_addr,half_word);
#else
extern void ppi_init();
extern void ppi_inb();
extern void ppi_outb();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\printer.h ===
#ifdef	PRINTER

/*
 * SoftPC Revision 2.0
 *
 * Title	: IBM PC Parallel Printer Adaptor definitions
 *
 * Description	: This module contains declarations that are used in
 *		  accessing the Parallel Printer adaptor emulation
 *
 * Author(s)	: Ross Beresford
 *
 * Notes	:
 */ 

/* SccsID[]="@(#)printer.h	1.7 11/14/94 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */


/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#if defined(NEC_98)
extern  void printer_init();
extern  void printer_post();
extern  void printer_status_changed();

#define LPT1_READ_DATA          0x40
#define LPT1_WRITE_DATA         0x40
#define LPT1_READ_SIGNAL1       0x42
#define LPT1_READ_SIGNAL2       0x44
#define LPT1_WRITE_SIGNAL2      0x44
#define LPT1_WRITE_SIGNAL1      0x46
#else  // !NEC_98
#ifdef ANSI
extern	void printer_init(int);
extern	void printer_post(int);
extern	void printer_status_changed(int);
#else
extern	void printer_init();
extern	void printer_post();
extern	void printer_status_changed();
#endif

#ifdef PS_FLUSHING
extern void printer_psflush_change IPT2(IU8,hostID, IBOOL,apply);
#endif	/* PS_FLUSHING */

/*
 * The following 6 defines refer to the address in the BIOS data area
 * at which the LPT port addresses and timeout values can be found.
 * The actual values for the port addresses (LPT1_PORT_START and  ..._END)
 * are defined in host_lpt.h
 */
#define LPT1_PORT_ADDRESS	(BIOS_VAR_START + 8)
#define LPT2_PORT_ADDRESS	(BIOS_VAR_START + 0xa)
#define LPT3_PORT_ADDRESS	(BIOS_VAR_START + 0xc)

#define LPT1_TIMEOUT_ADDRESS	(BIOS_VAR_START + 0x78)
#define LPT2_TIMEOUT_ADDRESS	(BIOS_VAR_START + 0x79)
#define LPT3_TIMEOUT_ADDRESS	(BIOS_VAR_START + 0x7a)

#if defined(NTVDM)
extern void printer_is_being_closed(int adapter);
#endif
#endif // !NEC_98

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\quick_ev.h ===
/*[
************************************************************************
	Name:			quick_ev.h
	Author:			WTG Charnell
	Created:		Unknown
	Sccs ID:		@(#)quick_ev.h	1.20 06/08/95

	(c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.

	Purpose:		Quick Event Manager definitions
	Description:		Definitions for users of the quick
				event manager

************************************************************************
]*/

#include	"host_qev.h"	/* for q_ev_handle typedef */

typedef void (*Q_CALLBACK_FN) IPT1(long, parm);

extern void q_event_init IPT0();
extern void delete_q_event IPT1(q_ev_handle, handle);
extern void dispatch_q_event IPT0();
extern void delete_tic_event IPT1(q_ev_handle, handle);
extern void tic_event_init IPT0();
extern q_ev_handle add_tic_event IPT3(Q_CALLBACK_FN, func, unsigned long, time, long, param);
extern q_ev_handle add_q_event_i IPT3(Q_CALLBACK_FN, func, unsigned long, time, long, param);
extern q_ev_handle add_q_event_t IPT3(Q_CALLBACK_FN, func, unsigned long, time, long, param);

#ifndef NTVDM
extern q_ev_handle add_q_ev_int_action IPT5(unsigned long, time, Q_CALLBACK_FN, func, IU32, adapter, IU32, line, IU32, param);
#endif

#ifndef CPU_40_STYLE
/*
 * Host access routines for 3.0 CPU (4.0 supplies its own prototypes
 * in generated include files).
 */
#ifndef host_calc_q_ev_inst_for_time
extern ULONG host_calc_q_ev_inst_for_time IPT1( ULONG, time );
#endif /* host_calc_q_ev_inst_for_time */
#ifdef NTVDM
extern ULONG host_calc_q_ev_time_for_inst IPT1(ULONG, inst);
#endif

extern void host_q_ev_set_count IPT1( ULONG, count );
extern ULONG host_q_ev_get_count IPT0();

#else	/* CPU_40_STYLE */
extern IU32 calc_q_inst_for_time IPT1(IU32, time);
extern IU32 calc_q_time_for_inst IPT1(IU32, inst);
#define host_calc_q_ev_inst_for_time      calc_q_inst_for_time
#define host_calc_q_ev_time_for_inst      calc_q_time_for_inst
#endif	/* CPU_40_STYLE */

#ifndef NTVDM
#ifdef CPU_40_STYLE

/* data structure used to control add_q_ev_int_action requests */
typedef struct aqeia_req {
	IS32 ident;		/* queue identifier, 0 - unused */
	Q_CALLBACK_FN func;
	IU32 adapter;
	IU32 line;
	IU32 param;
	struct aqeia_req *next;
} Q_INT_ACT_REQ, *Q_INT_ACT_REQ_PTR;

#define Q_INT_ACT_NULL	((Q_INT_ACT_REQ_PTR)0)

#endif  /* CPU_40_STYLE */

#endif  /* !NTVDM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\rommap.h ===
/*[
 *
 *	File		:	rommap.h
 *
 *	Derived from	:	(original)
 *
 *	Purpose		:	structure for full screen host api to fill in
 *				describing the location of host ROMs
 *
 *	Author		:	Rog
 *	Date		:	15 March 1992
 *
 *	RCS Gumph	:	
 *		$Source: /MasterNeXT486/RCStree/base/inc/rommap.h,v $
 *		$Revision: 1.1 $
 *		$Date: 93/03/18 12:18:26 $
 *		$Author: rog $
 *	
 *	(c) Copyright Insignia Solutions Ltd., 1992 All rights reserved
 *
 *	Modifications	:	
 *
]*/

#ifndef _ROMMAP_H_
#define _ROMMAP_H_


/* Structure to hold a PC address range to describe a single mapping */

typedef struct
{
	unsigned int	startAddress;
	unsigned int	endAddress;
} mapRange , * pMapRange;


/*
	Structure to describe the state of the host machines IVT after boot up
	and a *all* the mappings performed

	Note that size of structure in use will be sizeof( romMapInfo ) + 
		numberROMS * sizeof( mapRange ) ....
*/

typedef struct
{
	unsigned char	* initialIVT;	/* ptr to read only 4k buffer...*/
	unsigned int	numberROMs;	/* Number of discrete mappings */
	mapRange	ROMaddresses[ 0 ];
}
ROMMapInfo , * pROMMapInfo;

#endif		/* _ROMMAP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\rom.h ===
/*
 * VPC-XT Revision 1.0
 *
 * Title	: ROM Space definitions
 *
 * Description	: Definitions for users of the Saved ROM
 *
 * Author	: Paul Huckle
 *
 * Mods: (r3.2) : On the Mac II running MultiFinder, we can't have much
 *                static storage, so big arrays are verboten. Hence use
 *                malloc() to grab storage from the heap, and declare
 *                pointers instead.		  
 */

/* SccsID[]="@(#)rom.h	1.9 10/30/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */


/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#ifndef macintosh
    extern half_word ROM_BIOS1[];
    extern half_word ROM_BIOS2[];
#endif

IMPORT void rom_init IPT0();
IMPORT void rom_checksum IPT0();
IMPORT void copyROM IPT0();
IMPORT void search_for_roms IPT0();
IMPORT void read_video_rom IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\rs232.h ===
#ifndef _RS232_H
#define _RS232_H

/*[
	Name:		rs232.h
	Derived From:	Base 2.0
	Author:		Paul Huckle
	Created On:	
	Sccs ID:	05/11/94 @(#)rs232.h	1.14
	Purpose:	Definitions for users of the RS232 Adapter Module

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

#ifndef NEC_98
/* register type definitions follow: */

typedef half_word BUFFER_REG;

#ifdef LITTLEND
typedef union {
   word all;
   struct {
      WORD_BIT_FIELD LSByte:8;
      WORD_BIT_FIELD MSByte:8;
   } byte;
} DIVISOR_LATCH;
#endif
#ifdef BIGEND
typedef union {
   word all;
   struct {
      WORD_BIT_FIELD MSByte:8;
      WORD_BIT_FIELD LSByte:8;
   } byte;
} DIVISOR_LATCH;
#endif
#else //NEC_98
/* register type definitions follow: */

// Date read/write port
//      I/O port address ch.1 = 0x30 , ch.2 = 0xB1 , ch.3 = 0xB9
typedef half_word BUFFER_REG;

// Timer counter image table
//      I/O port address ch.1 = 0x75 (ch.1 only)
#ifdef LITTLEND
typedef union {
   word all;
   struct {
      WORD_BIT_FIELD LSByte:8;
      WORD_BIT_FIELD MSByte:8;
   } byte;
} DIVISOR_LATCH;
#endif
#ifdef BIGEND
typedef union {
   word all;
   struct {
      WORD_BIT_FIELD MSByte:8;
      WORD_BIT_FIELD LSByte:8;
   } byte;
} DIVISOR_LATCH;
#endif

// Command port bit image table
//      I/O port address ch.1 = 0x32 , ch.2 = 0xB3 , ch.3 = 0xBB
#ifdef BIT_ORDER2
typedef union {                             // Command port 8251
    half_word all;
    struct {
         HALF_WORD_BIT_FIELD tx_enable:1;
         HALF_WORD_BIT_FIELD ER:1;
         HALF_WORD_BIT_FIELD rx_enable:1;
         HALF_WORD_BIT_FIELD send_break:1;
         HALF_WORD_BIT_FIELD error_reset:1;
         HALF_WORD_BIT_FIELD RS:1;
         HALF_WORD_BIT_FIELD inter_reset:1;
         HALF_WORD_BIT_FIELD pad:1;
           } bits;
      } COMMAND8251;
#endif
#ifdef BIT_ORDER1
typedef union {                             // Command port 8251
   half_word all;
    struct {
         HALF_WORD_BIT_FIELD pad:1;
         HALF_WORD_BIT_FIELD inter_reset:1;
         HALF_WORD_BIT_FIELD RS:1;
         HALF_WORD_BIT_FIELD error_reset:1;
         HALF_WORD_BIT_FIELD send_break:1;
         HALF_WORD_BIT_FIELD rx_enable:1;
         HALF_WORD_BIT_FIELD ER:1;
         HALF_WORD_BIT_FIELD tx_enable:1;
           } bits;
      } COMMAND8251;
#endif

// Mode set port bit image table.
//      I/O port address ch.1 = 0x32 , ch.2 = 0xB3 , ch.3 = 0xBB
#ifdef BIT_ORDER2
typedef union {                                 // Mode port 8251
    half_word all;
    struct {

         HALF_WORD_BIT_FIELD baud_rate:2;
         HALF_WORD_BIT_FIELD char_length:2;
         HALF_WORD_BIT_FIELD parity_enable:1;
         HALF_WORD_BIT_FIELD parity_even:1;
         HALF_WORD_BIT_FIELD stop_bit:2;
           } bits;
      } MODE8251;
#endif
#ifdef BIT_ORDER1
typedef union {                                 // Mode port 8251
    half_word all;
    struct {

         HALF_WORD_BIT_FIELD stop_bit:2;
         HALF_WORD_BIT_FIELD parity_even:1;
         HALF_WORD_BIT_FIELD parity_enable:1;
         HALF_WORD_BIT_FIELD char_length:2;
         HALF_WORD_BIT_FIELD baud_rate:2;
           } bits;
      } MODE8251;
#endif

// Mask set port bit image table.
//      I/O port address ch.1 = 0x35 , ch.2 = 0xB0 , ch.3 = 0xB2
//                                      (ch.2,3 is write only)
#ifdef BIT_ORDER2
typedef union {                                 // Mask port 8251
    half_word all;
    struct {

         HALF_WORD_BIT_FIELD RXR_enable:1;
         HALF_WORD_BIT_FIELD TXE_enable:1;
         HALF_WORD_BIT_FIELD TXR_enable:1;
         HALF_WORD_BIT_FIELD pad:5;
           } bits;
      } MASK8251;
#endif
#ifdef BIT_ORDER1
typedef union {                                 // Mask port 8251
    half_word all;
    struct {

         HALF_WORD_BIT_FIELD pad:5;
         HALF_WORD_BIT_FIELD TXR_enable:1;
         HALF_WORD_BIT_FIELD TXE_enable:1;
         HALF_WORD_BIT_FIELD RXR_enable:1;
           } bits;
      } MASK8251;
#endif

// Read status port bit image table
//      I/O port address ch.1 = 0x32 , ch.2 = 0xB3 , ch.3 = 0xBB
#ifdef BIT_ORDER2
typedef union {                                 // Read status 8251
    half_word all;
    struct {
         HALF_WORD_BIT_FIELD tx_ready:1;
         HALF_WORD_BIT_FIELD rx_ready:1;
         HALF_WORD_BIT_FIELD tx_empty:1;
         HALF_WORD_BIT_FIELD parity_error:1;
         HALF_WORD_BIT_FIELD overrun_error:1;
         HALF_WORD_BIT_FIELD framing_error:1;
         HALF_WORD_BIT_FIELD break_detect:1;
         HALF_WORD_BIT_FIELD DR:1;
           } bits;
      } STATUS8251;
#endif
#ifdef BIT_ORDER1
typedef union {                                 // Read status 8251
    half_word all;
    struct {
         HALF_WORD_BIT_FIELD DR:1;
         HALF_WORD_BIT_FIELD break_detect:1;
         HALF_WORD_BIT_FIELD framing_error:1;
         HALF_WORD_BIT_FIELD overrun_error:1;
         HALF_WORD_BIT_FIELD parity_error:1;
         HALF_WORD_BIT_FIELD tx_empty:1;
         HALF_WORD_BIT_FIELD rx_ready:1;
         HALF_WORD_BIT_FIELD tx_ready:1;
           } bits;
      } STATUS8251;
#endif

// Read signal port bit image table.
//      I/O port address ch.1 = 0x33 , ch.2 = 0xB0 , ch.3 = 0xB2
//                               (ch.2,3 is bard IR level sence)
#ifdef BIT_ORDER2
typedef union {                                 // Read signal 8251
    half_word all;
    struct {

         HALF_WORD_BIT_FIELD IR:2;
         HALF_WORD_BIT_FIELD pad:3;
         HALF_WORD_BIT_FIELD CD:1;
         HALF_WORD_BIT_FIELD CS:1;
         HALF_WORD_BIT_FIELD RI:1;
           } bits;
      } SIGNAL8251;
#endif
#ifdef BIT_ORDER1
typedef union {                                 // Read signal 8251
    half_word all;
    struct {

         HALF_WORD_BIT_FIELD RI:1;
         HALF_WORD_BIT_FIELD CS:1;
         HALF_WORD_BIT_FIELD CD:1;
         HALF_WORD_BIT_FIELD pad:3;
         HALF_WORD_BIT_FIELD IR:2;
           } bits;
      } SIGNAL8251;
#endif

// Timer mode set port bit image table.
//      I/O port address ch.1 = 0x77
//                               (ch.1 only)
#ifdef BIT_ORDER2
typedef union {                                 // Timer mode set
    half_word all;
    struct {

         HALF_WORD_BIT_FIELD bin:1;
         HALF_WORD_BIT_FIELD mode:3;
         HALF_WORD_BIT_FIELD latch:2;
         HALF_WORD_BIT_FIELD counter:2;
           } bits;
      } TIMER_MODE;
#endif
#ifdef BIT_ORDER1
typedef union {                                 // Timer mode set
    half_word all;
    struct {

         HALF_WORD_BIT_FIELD counter:2;
         HALF_WORD_BIT_FIELD latch:2;
         HALF_WORD_BIT_FIELD mode:3;
         HALF_WORD_BIT_FIELD bin:1;
           } bits;
      } TIMER_MODE;
#endif
#endif //NEC_98

#ifdef BIT_ORDER2
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD data_available:1;
		 HALF_WORD_BIT_FIELD tx_holding:1;
		 HALF_WORD_BIT_FIELD rx_line:1;
		 HALF_WORD_BIT_FIELD modem_status:1;
		 HALF_WORD_BIT_FIELD pad:4;
	       } bits;
      } INT_ENABLE_REG;
#endif
#ifdef BIT_ORDER1
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD pad:4;
		 HALF_WORD_BIT_FIELD modem_status:1;
		 HALF_WORD_BIT_FIELD rx_line:1;
		 HALF_WORD_BIT_FIELD tx_holding:1;
		 HALF_WORD_BIT_FIELD data_available:1;
	       } bits;
      } INT_ENABLE_REG;
#endif

#if defined(NTVDM) && defined(FIFO_ON)
#ifdef BIT_ORDER2
typedef union {
    half_word all;
    struct {
         HALF_WORD_BIT_FIELD no_int_pending:1;
         HALF_WORD_BIT_FIELD interrupt_ID:3;
         HALF_WORD_BIT_FIELD pad:2;
         HALF_WORD_BIT_FIELD fifo_enabled:2;
           } bits;
      } INT_ID_REG;
#endif
#ifdef BIT_ORDER1
typedef union {
    half_word all;
    struct {
         HALF_WORD_BIT_FIELD fifo_enabled:2;
         HALF_WORD_BIT_FIELD pad:2;
         HALF_WORD_BIT_FIELD interrupt_ID:3;
         HALF_WORD_BIT_FIELD no_int_pending:1;
           } bits;
      } INT_ID_REG;
#endif
#else   /* NTVDM */

#ifdef BIT_ORDER2
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD no_int_pending:1;
		 HALF_WORD_BIT_FIELD interrupt_ID:2;
		 HALF_WORD_BIT_FIELD pad:5;
	       } bits;
      } INT_ID_REG;
#endif
#ifdef BIT_ORDER1
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD pad:5;
		 HALF_WORD_BIT_FIELD interrupt_ID:2;
		 HALF_WORD_BIT_FIELD no_int_pending:1;
	       } bits;
      } INT_ID_REG;
#endif

#endif  /* ifdef NTVDM */

#ifdef BIT_ORDER2
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD word_length:2;
		 HALF_WORD_BIT_FIELD no_of_stop_bits:1;
		 HALF_WORD_BIT_FIELD parity_enabled:1;
		 HALF_WORD_BIT_FIELD even_parity:1;
		 HALF_WORD_BIT_FIELD stick_parity:1;
		 HALF_WORD_BIT_FIELD set_break:1;
		 HALF_WORD_BIT_FIELD DLAB:1;
	       } bits;
      } LINE_CONTROL_REG;
#endif
#ifdef BIT_ORDER1
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD DLAB:1;
		 HALF_WORD_BIT_FIELD set_break:1;
		 HALF_WORD_BIT_FIELD stick_parity:1;
		 HALF_WORD_BIT_FIELD even_parity:1;
		 HALF_WORD_BIT_FIELD parity_enabled:1;
		 HALF_WORD_BIT_FIELD no_of_stop_bits:1;
		 HALF_WORD_BIT_FIELD word_length:2;
	       } bits;
      } LINE_CONTROL_REG;
#endif

#ifdef BIT_ORDER2
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD DTR:1;
		 HALF_WORD_BIT_FIELD RTS:1;
		 HALF_WORD_BIT_FIELD OUT1:1;
		 HALF_WORD_BIT_FIELD OUT2:1;
		 HALF_WORD_BIT_FIELD loop:1;
		 HALF_WORD_BIT_FIELD pad:3;
	       } bits;
      } MODEM_CONTROL_REG;
#endif
#ifdef BIT_ORDER1
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD pad:3;
		 HALF_WORD_BIT_FIELD loop:1;
		 HALF_WORD_BIT_FIELD OUT2:1;
		 HALF_WORD_BIT_FIELD OUT1:1;
		 HALF_WORD_BIT_FIELD RTS:1;
		 HALF_WORD_BIT_FIELD DTR:1;
	       } bits;
      } MODEM_CONTROL_REG;
#endif

#ifdef BIT_ORDER2
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD data_ready:1;
		 HALF_WORD_BIT_FIELD overrun_error:1;
		 HALF_WORD_BIT_FIELD parity_error:1;
		 HALF_WORD_BIT_FIELD framing_error:1;
		 HALF_WORD_BIT_FIELD break_interrupt:1;
		 HALF_WORD_BIT_FIELD tx_holding_empty:1;
		 HALF_WORD_BIT_FIELD tx_shift_empty:1;
#if defined(NTVDM) && defined(FIFO_ON)
		 HALF_WORD_BIT_FIELD fifo_error:1;
#else
		 HALF_WORD_BIT_FIELD pad:1;
#endif
	       } bits;
      } LINE_STATUS_REG;
#endif
#ifdef BIT_ORDER1
typedef union {
 	half_word all;
	struct {
#if defined(NTVDM) && defined(FIFO_ON)
		 HALF_WORD_BIT_FIELD fifo_error:1;
#else
		 HALF_WORD_BIT_FIELD pad:1;
#endif
		 HALF_WORD_BIT_FIELD tx_shift_empty:1;
		 HALF_WORD_BIT_FIELD tx_holding_empty:1;
		 HALF_WORD_BIT_FIELD break_interrupt:1;
		 HALF_WORD_BIT_FIELD framing_error:1;
		 HALF_WORD_BIT_FIELD parity_error:1;
		 HALF_WORD_BIT_FIELD overrun_error:1;
		 HALF_WORD_BIT_FIELD data_ready:1;
	       } bits;
      } LINE_STATUS_REG;
#endif

#ifdef BIT_ORDER2
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD delta_CTS:1;
		 HALF_WORD_BIT_FIELD delta_DSR:1;
		 HALF_WORD_BIT_FIELD TERI:1;
		 HALF_WORD_BIT_FIELD delta_RLSD:1;
		 HALF_WORD_BIT_FIELD CTS:1;
		 HALF_WORD_BIT_FIELD DSR:1;
		 HALF_WORD_BIT_FIELD RI:1;
		 HALF_WORD_BIT_FIELD RLSD:1;
	       } bits;
      } MODEM_STATUS_REG;
#endif
#ifdef BIT_ORDER1
typedef union {
 	half_word all;
	struct {
		 HALF_WORD_BIT_FIELD RLSD:1;
		 HALF_WORD_BIT_FIELD RI:1;
		 HALF_WORD_BIT_FIELD DSR:1;
		 HALF_WORD_BIT_FIELD CTS:1;
		 HALF_WORD_BIT_FIELD delta_RLSD:1;
		 HALF_WORD_BIT_FIELD TERI:1;
		 HALF_WORD_BIT_FIELD delta_DSR:1;
		 HALF_WORD_BIT_FIELD delta_CTS:1;
	       } bits;
      } MODEM_STATUS_REG;
#endif

#if defined(NEC_98)
/* register select code definitions follow: */

#define RS232_CH1_TX_RX         0x30            //
#define RS232_CH2_TX_RX         0xB1            // Data read/write port address
#define RS232_CH3_TX_RX         0xB9            //

#define RS232_CH1_CMD_MODE      0x32            // Command write ,
#define RS232_CH2_CMD_MODE      0xB3            //  mode set port address
#define RS232_CH3_CMD_MODE      0xBB            //

#define RS232_CH1_STATUS        0x32            //
#define RS232_CH2_STATUS        0xB3            //  status read  port address
#define RS232_CH3_STATUS        0xBB            //

#define RS232_CH1_MASK          0x35            //
#define RS232_CH2_MASK          0xB0            // IR mask set port address
#define RS232_CH3_MASK          0xB2            //

#define RS232_CH1_SIG           0x33            //
#define RS232_CH2_SIG           0xB0            // Signal read port address
#define RS232_CH3_SIG           0xB2            //

#define RS232_CH1_TIMERSET      0x77            // Timer set port address (ch.1 only)
#define RS232_CH1_TIMERCNT      0x75            // Timer counter set port address (ch.1 only)

#else  // !NEC_98
#if defined(NTVDM) && defined(FIFO_ON)
/* refer to NS 16550A data sheet for fifo control register description
   DMA is not supported because so far there are not such a COMM adapter with
   DMA channel  out there
*/
#ifdef BIT_ORDER2
typedef union {
    half_word all;
    struct {
         HALF_WORD_BIT_FIELD enabled:1;
         HALF_WORD_BIT_FIELD rx_reset:1;
         HALF_WORD_BIT_FIELD tx_reset:1;
         HALF_WORD_BIT_FIELD dma_mode_selected:1;
         HALF_WORD_BIT_FIELD pad:2;
         HALF_WORD_BIT_FIELD trigger_level:2;
           } bits;
      } FIFO_CONTROL_REG;
#endif
#ifdef BIT_ORDER1
typedef union {
    half_word all;
    struct {
         HALF_WORD_BIT_FIELD trigger_level:2;
         HALF_WORD_BIT_FIELD pad:2;
         HALF_WORD_BIT_FIELD dma_mode_selected:1
         HALF_WORD_BIT_FIELD tx_reset:1;
         HALF_WORD_BIT_FIELD rx_reset:1
         HALF_WORD_BIT_FIELD enabled:1;
           } bits;
      } FIFO_CONTROL_REG;
#endif

#endif

/* register select code definitions follow: */

#define RS232_TX_RX	0
#define RS232_IER	1
#define RS232_IIR	2
#if defined(NTVDM) && defined(FIFO_ON)
#define RS232_FIFO  2
#endif
#define RS232_LCR	3
#define RS232_MCR	4
#define RS232_LSR	5
#define RS232_MSR	6
#define RS232_SCRATCH	7
#endif // !NEC_98

#define RS232_COM1_TIMEOUT (BIOS_VAR_START + 0x7c)
#define RS232_COM2_TIMEOUT (BIOS_VAR_START + 0x7d)
#define RS232_COM3_TIMEOUT (BIOS_VAR_START + 0x7e)
#define RS232_COM4_TIMEOUT (BIOS_VAR_START + 0x7f)
#define RS232_PRI_TIMEOUT (BIOS_VAR_START + 0x7c)
#define RS232_SEC_TIMEOUT (BIOS_VAR_START + 0x7d)

#define GO 0           /* We can emulate requested configuration */
#define NO_GO_SPEED 1  /* We can't emulate requested line speed */
#define NO_GO_LINE  2  /* We can't emulate requested line setup */

#if defined(NTVDM) && defined(FIFO_ON)
/* fifo size defined in NS16550 data sheet */
#define FIFO_SIZE   16
/* the real fifo size in our simulation code. Increase this will get
   a better performance(# rx interrupts going down and read call count to
   the serial driver also going down). However, if application is using
   h/w handshaking, we may still delivery extra chars to it. This may provoke
   the app. By using 16bytes fifo, we are safe because the application
   must have logic to handle it.
*/

#define FIFO_BUFFER_SIZE    FIFO_SIZE
#endif

#define OFF 0
#define ON 1
#define LEAVE_ALONE 2
#define	change_state(external_state, internal_state) \
	((external_state == internal_state) ? LEAVE_ALONE : external_state)

#if defined(NTVDM) && defined(FIFO_ON)
#define FIFO_INT 6   /* fifo rda time out interrupt ID */
#endif

#define RLS_INT 3     /* receiver line status interrupt ID */
#define RDA_INT 2     /* data available interrupt ID */
#define THRE_INT 1    /* tx holding register empty interrupt ID */
#define MS_INT 0      /* modem status interrupt ID */

#define DATA5 0       /* line control setting for five data bits */
#define DATA6 1       /* line control setting for six data bits */
#define DATA7 2       /* line control setting for seven data bits */
#define DATA8 3       /* line control setting for eight data bits */

#define STOP1 0       /* line control setting for one stop bit */
#define STOP2 1       /* line control setting for one and a half or two
                         stop bits */

#ifdef NTVDM
// collision with winbase.h PARITY_ON define
#define PARITYENABLE_ON 1   /* line control setting for parity enabled */
#define PARITYENABLE_OFF 0  /* line control setting for parity disabled */
#else
#define PARITY_ON 1   /* line control setting for parity enabled */
#define PARITY_OFF 0  /* line control setting for parity disabled */
#endif

#ifdef NTVDM
// collision with winbase.h PARITY_ODD define
#define EVENPARITY_ODD 0  /* line control setting for odd parity */
#define EVENPARITY_EVEN 1 /* line control setting for even parity */
#else
#define PARITY_ODD 0  /* line control setting for odd parity */
#define PARITY_EVEN 1 /* line control setting for even parity */
#endif

#define PARITY_STICK 1  /* line control setting for stick(y) parity */

#define PARITY_FIXED 2  /* Internal state setting for fixed parity */

#if defined(NEC_98)
#define COM1 0
#define COM2 1
#define COM3 2
#else  // !NEC_98
#define COM1 0
#define COM2 1
#if (NUM_SERIAL_PORTS > 2)
#define COM3 2
#define COM4 3
#endif
#endif // !NEC_98

#if defined(NTVDM) && defined(FIFO_ON)
typedef     struct _FIFORXDATA{
    half_word   data;
    half_word   error;
}FIFORXDATA, *PFIFORXDATA;
#endif

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

extern void com_init IPT1(int, adapter);
extern void com_post IPT1(int, adapter);

extern void com_flush_printer IPT1(int, adapter);

extern void com_inb IPT2(io_addr, port, half_word *, value);
extern void com_outb IPT2(io_addr, port, half_word, value);

extern void com_recv_char IPT1(int, adapter);
extern void recv_char IPT1(long, adapter);
extern void com_modem_change IPT1(int, adapter);
extern void com_save_rxbytes IPT2(int,n, CHAR *,buf);
extern void com_save_txbyte IPT1(CHAR,value);

#ifdef PS_FLUSHING
extern void com_psflush_change IPT2(IU8,hostID, IBOOL,apply);
#endif	/* PS_FLUSHING */

#ifdef NTVDM
extern void com_lsr_change(int adapter);
#endif

#if defined(NEC_98)
#define adapter_for_port(port) \
        (( (port == 0x30) || (port == 0x32) || (port == 0x33) || (port == 0x35) || (port == 0x75) ) ? COM1 :\
    (( (port == 0xB0) || (port == 0xB1) || (port == 0xB3) ) ? COM2 : COM3))

#ifdef SHORT_TRACE
#define id_for_adapter(adapter)         (adapter + '1')
#endif

#else  // !NEC_98
#if (NUM_SERIAL_PORTS > 2)
#define	adapter_for_port(port) \
	(((port & 0x300) == 0x300) ? \
		(((port & 0xf8) == 0xf8) ? COM1 : COM3) \
		        : \
		(((port & 0xf8) == 0xf8) ? COM2 : COM4))

#ifdef SHORT_TRACE
#define	id_for_adapter(adapter)	 	(adapter + '1')
#endif

#else

#define	adapter_for_port(port)	(((port) >= RS232_PRI_PORT_START && (port) <= RS232_PRI_PORT_END) ? COM1 : COM2)


#ifdef SHORT_TRACE
#define	id_for_adapter(adapter)	(adapter == COM1 ? 'P' : 'S')
#endif
#endif /* more than 2 serial ports */
#endif // !NEC_98

#ifdef IRET_HOOKS
/*
 * A macro we need for IRET hooks, the number of bits in a an async
 * character on a comms line, which is about 8 (for the character)
 * plus two stop bits.
 */
#define BITS_PER_ASYNC_CHAR 10
#endif /* IRET_HOOKS */

/* BCN 2730 define generic macros which can be SVID3 or old style
 * in either case the structure used should be a termios
 */

#ifdef SVID3_TCGET
#define	TCGET TCGETS
#define	TCSET TCSETS
#define	TCSETF TCSETSF
#else
#define	TCGET TCGETA
#define	TCSET TCSETA
#define	TCSETF TCSETAF
#endif	/* SVID3_TCGET */

#endif /* _RS232_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\profile.h ===
/*[
*************************************************************************

	Name:		profile.h
	Author:		Simon Frost
	Created:	September 1993
	Derived from:	Original
	Sccs ID:	@(#)profile.h	1.9 01/31/95
	Purpose:	Include file for the Profiling system & Interfaces

	(c)Copyright Insignia Solutions Ltd., 1993. All rights reserved.

*************************************************************************
]*/

/* ------------------- Data Structures & Types -------------------- */
typedef ISM32 EOIHANDLE;
typedef ISM32 SOIHANDLE;

/*
 * Two IUHs to allow for variety of host timestamp data. May be secs/usecs
 * or large integer or whatever is appropriate.
 */
typedef struct {
    IUH data[2];
} PROF_TIMESTAMP, *PROF_TIMEPTR;

typedef struct {
    IUH eoiHandle;
    PROF_TIMESTAMP timestamp;
    IUH arg;
} EOI_BUFFER_FORMAT;

typedef struct eoinode EOINODE, *EOINODE_PTR;	/* forward decln */
typedef struct eoiarg EOIARG, *EOIARG_PTR;	/* ditto */
typedef struct graphlist GRAPHLIST, *GRAPHLIST_PTR;	/* ditto */

/* Active SOIs (Sequences Of Interest) stored in list of these nodes */
typedef struct soinode {

    SOIHANDLE handle;		/* SOI identifier */
    EOIHANDLE startEOI;		/* EOI of start event */
    EOIHANDLE endEOI;		/* EOI of end event */
    EOIARG_PTR startArg;	/* extra level graphing - start arg */
    EOIARG_PTR endArg;		/* extra level graphing - end arg */
    IUM32 startCount;		/* # of times start EOI occured */
    IUM32 endCount;		/* # of times end EOI occured */
    PROF_TIMESTAMP soistart;	/* timestamp of SOI start */
    struct soinode *next;	/* pointer to next SOI */
    IU8 flags;			/* flags for this SOI */
    DOUBLE time;		/* usecs spent in SOI - daft times ignored */
    DOUBLE maxtime;		/* longest valid elapsed time */
    DOUBLE mintime;		/* shortest elapsed time */
    DOUBLE bigmax;		/* longest invalid time */
    DOUBLE bigtime;		/* total contributed by daft times */
    IUM32 discardCount;		/* # of discarded times */

} SOINODE, *SOINODE_PTR;

#define SOIPTRNULL (SOINODE_PTR)0

/* Active Events linked to Active SOIs by pointers to SOI structures */
typedef struct soilist {

    SOINODE_PTR soiLink;	/* SOI that this event starts/ends */
    struct soilist *next;	/* next active SOI */

} SOILIST, *SOILIST_PTR;

#define SLISTNULL (SOILIST_PTR)0

/* Events which contain arguments hold them in sorted list of these nodes */
struct eoiarg {

    struct eoiarg *next;	/* pointer to next argument value */
    struct eoiarg *back;	/* previous argument node */
    IUM32 count;		/* how many events have had this value */
    IUM32 value;		/* event argument this node represents */
    SOILIST_PTR startsoi;	/* SOIs which this arg starts if auto SOI */
    SOILIST_PTR endsoi;		/* SOIs which this arg ends if auto SOI */
    GRAPHLIST_PTR graph;	/* pointer into graph list for this node */

};

#define ARGPTRNULL (EOIARG_PTR)0

/*
 * This structure is used to form the list used in EOI graphing.
 * It gives two links for 'free' and then goes off down a chain of more 
 * succession links. (This gives loops & if's in one struct).
 * Pointers to these nodes can be found in EOI nodes and EOI argument nodes.
 */
struct graphlist {
    struct graphlist *next;	/* list connecting pointer -not graph related */
    EOINODE_PTR  graphEOI;	/* EOI for graph node */
    EOIARG_PTR graphArg;	/* EOI argument if relevant */
    IUM32 numpred;		/* how many predecessors */
    IUM32 numsucc;		/* how many succecessors */
    struct graphlist *succ1;	/* pointer to first successor */
    IUM32 succ1Count;		/* # of times first successor found */
    struct graphlist *succ2;	/* pointer to second successor */
    IUM32 succ2Count;		/* # of times second successor found */
    struct graphlist *extra;	/* if two successors not enuf look here */
    ISM32 indent;		/* for report printing */
    IU8 state;			/* flags for node state */
};

/* defines for graph state (bits) on reporting */
#define GR_SUCC1_TROD	1
#define GR_SUCC2_TROD	2
#define GR_TRAMPLED    (GR_SUCC1_TROD|GR_SUCC2_TROD)
#define GR_PRINTED	4

#define GRAPHPTRNULL	(GRAPHLIST_PTR)0

/*
 * If a SOI is registered at the arg level & collects sequences between 'same valued'
 * args, the endEOI of the pair must be available from the start EOI. The start EOI
 * contains a pointer to a list in the following format.
 */
struct soiargends {
	EOIHANDLE endEOI;
	struct soiargends *next;
};

typedef struct soiargends SOIARGENDS, *SOIARGENDS_PTR;

#define SOIARGENDNULL	(SOIARGENDS_PTR)0

/*
 * Active Events registered for profiling run are stored in list(s) of these
 * nodes.
 */
struct eoinode {

    struct eoinode *next;	/* pointer to next event */
    struct eoinode *back;	/* pointer to previous event */
    IUM32 count;		/* # of times EOI occured */
    EOIHANDLE handle;		/* EOI identifier */
    CHAR *tag;			/* 'real world' identifier */
    EOIARG_PTR args;		/* list of arguments to event (may be null) */
    EOIARG_PTR lastArg;		/* last argument node accessed */
    PROF_TIMESTAMP timestamp;	/* time of last EOI (usec) */
    SOILIST_PTR startsoi;	/* SOI pointers which this event starts */
    SOILIST_PTR endsoi;		/* SOI pointers which this event ends */
    GRAPHLIST_PTR graph;	/* pointer to graph list for this node */
    SOIARGENDS_PTR argsoiends;	/* arg level 'same value' end list */
    IU16 flags;			/* characteristics of this EOI */

};

#define EOIPTRNULL (EOINODE_PTR)0

/*
 * This structure mirrors the initial elements of those lists we may
 * want to sort into 'popularity' order (based on the 'count' element).
 * This is intended to reduce search times for common elements
 */
typedef struct sortlist {
    struct sortlist *next;	/* pointer to next element */
    struct sortlist *back;	/* pointer to previous element */
    IUM32 count;		/* # of times element occured */
} *SORTSTRUCT, **SORTSTRUCT_PTR;

/* New SOI flags */
#define SOI_DEFAULTS	0	/* No flags  - default settings */
#define SOI_AUTOSOI	0x20	/* SOI generated by AUTOSOI */
#define SOI_FROMARG	0x40	/* SOI generated by arg level connection */

/* New EOI 'capability' flags */
#define EOI_DEFAULTS	0	/* No flags  - default settings */
#define EOI_DISABLED	1	/* Delay EIO until enable call. */
#define EOI_KEEP_GRAPH	2	/* Track Predecessors for graphing */
#define EOI_KEEP_ARGS	4	/* Keep & count arguments passed */
#define EOI_ENABLE_ALL	8	/* Trigger enable of all EOIs */
#define EOI_DISABLE_ALL	0x10	/* Trigger disable of all EOIs */
#define EOI_AUTOSOI	0x20	/* Make SOIs automatically out of like EOIs */
#define EOI_HOSTHOOK	0x40	/* Hook out to host profiling system */
#define EOI_NOTIME	0x80	/* No timestamps needed (not in SOI) */

/* The above get used in the EOI node flag element. This also contains 
 * extra info as specified below.
 */
#define EOI_HAS_SOI	0x100	/* some SOI associated with this EOI */
#define EOI_NEW_ARGS_START_SOI	0x200	/* arg level soi with 'same value' ends */

/* Mask used to clear new eoi flags for enable table */
#define ENABLE_MASK (EOI_DISABLED|EOI_ENABLE_ALL|EOI_DISABLE_ALL|EOI_HOSTHOOK)

/* ---------------------- Interfaces -------------------------- */
extern IBOOL Profiling_enabled;           /* conventional profiling Disabled?  */

extern EOIHANDLE NewEOI IPT2(CHAR *, tag, IU8, flags);

extern void SetEOIAsHostTrigger IPT1(EOIHANDLE, handle);
extern void ClearEOIAsHostTrigger IPT1(EOIHANDLE, handle);
extern void SetEOIAutoSOI IPT1(EOIHANDLE, handle);
extern void ClearEOIAutoSOI IPT1(EOIHANDLE, handle);
extern void EnableEOI IPT1(EOIHANDLE, handle);
extern void EnableAllEOIs IPT0();
extern void DisableEOI IPT1(EOIHANDLE, handle);
extern void DisableAllEOIs IPT0();
extern void ResetEOI IPT1(EOIHANDLE, handle);
extern void ResetAllEOIs IPT0();
extern void ResetAllSOIs IPT0();

extern void AtEOIPoint IPT1(EOIHANDLE, handle);
extern void AtEOIPointArg IPT2(EOIHANDLE, handle, IUH, arg);

extern CHAR *GetEOIName IPT1(EOIHANDLE, handle);

extern SOIHANDLE AssociateAsSOI IPT2(EOIHANDLE, start, EOIHANDLE, end);
extern SOIHANDLE AssociateAsArgSOI IPT5(EOIHANDLE, start, EOIHANDLE, end,
				IUM32, startArg, IUM32, endArg, IBOOL, sameArgs);

extern void GenerateAllProfileInfo IPT1(FILE *, stream);
extern void CollateFrequencyList IPT2(FILE *, stream, IBOOL, reportstyle);
extern void CollateSequenceGraph IPT1(FILE *, stream);
extern void SummariseEvent IPT2(FILE *, stream, EOIHANDLE, handle);
extern void SummariseSequence IPT2(FILE *, stream, SOIHANDLE, handle);
extern void SummariseAllSequences IPT1(FILE *, stream);
extern void OrderedSequencePrint IPT3(SOIHANDLE, startEOI, SOIHANDLE, endEOI, FILE *, stream);
extern void dump_profile IPT0();
extern void reset_profile IPT0();

/* support fns for Frag Profiling */
extern void EnableFragProf IPT0();
extern void DisableFragProf IPT0();
extern void DumpFragProfData IPT0();


extern void ProcessProfBuffer IFN0();
extern void ProfileInit IFN0();

extern EOI_BUFFER_FORMAT **GdpProfileInit IPT3 (EOI_BUFFER_FORMAT, *rawDataBuf,
			 EOI_BUFFER_FORMAT, *endRawData,
			 IU8, *enable);
extern EOI_BUFFER_FORMAT **GdpProfileUpdate IPT2 (EOI_BUFFER_FORMAT, *rawDataBuf, IU8, *enable);


/* Declns for host i/f */
#ifdef NTVDM
extern void HostEnterProfCritSec IPT0();
extern void HostLeaveProfCritSec IPT0();
#else
#define HostEnterProfCritSec()	/* Nothing */
#define HostLeaveProfCritSec()	/* Nothing */
#endif
extern PROF_TIMEPTR HostTimestampDiff IPT2(PROF_TIMEPTR, tbegin, PROF_TIMEPTR, tend);
extern void HostAddTimestamps IPT2(PROF_TIMEPTR, tbase, PROF_TIMEPTR, taddn);
extern void HostSlipTimestamp IPT2(PROF_TIMEPTR, tbase, PROF_TIMEPTR, tdelta);
extern void HostWriteTimestamp IPT1(PROF_TIMEPTR, addr);
extern void HostPrintTimestamp IPT2(FILE *, stream, PROF_TIMEPTR, stamp);
extern char *HostProfInitName IPT0();
extern void HostProfHook IPT0();
extern void HostProfArgHook IPT1(IUH, arg);
extern double HostProfUSecs IPT1(PROF_TIMEPTR, stamp);
extern IU32 HostGetClocksPerSec IPT0();
extern IU32 HostGetProfsPerSec IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\sasp.h ===
/*[
 * File Name		: sasp.h
 *
 * Derived From		: Template
 *
 * Author		: Mike
 *
 * Creation Date	: October 93
 *
 * SCCS Version		: @(#)sasp.h	1.2 12/20/93
 *!
 * Purpose
 *	This module holds and maintains the SAS function pointers.
 *
 *! (c)Copyright Insignia Solutions Ltd., 1993. All rights reserved.
]*/

extern void SasSetPointers IPT1(struct SasVector *, newPointers);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\sas.h ===
/*
*
*	Ade Brownlow	
*	Tue Dec 11 90	
*
*	sas.h 
*
*	This file replaces the old sas.h. Macros are no longer used for
*	the sas functions they are always functions. This file takes
*	into account backward M .
*
*	Mike - Oct 93
*	A lot of these interfaces aren't used in 3.0, so we'll cut them out
*	of 4.0 altogether.  Use of them in the base is hence depricated!
*
*	4.0 also switches to function pointers, so there's a pretty big
*	#ifdef CPU_40_STYLE in here.
*
*	By the way, Jeremy has documented this interface in
*	HWRD/SOFT486(SAS)/DES
*
*	SccsID: @(#)sas.h	1.70 07/07/95
*
*/

#include "host_sas.h"

/* memory types for sas */

#ifdef CPU_40_STYLE

typedef enum  { 
	SAS_RAM, 
	SAS_VIDEO, 
	SAS_ROM, 
	SAS_WRAP, 
	SAS_IO, 
	SAS_MM_LIM, 
	SAS_INACCESSIBLE,
	SAS_DANGEROUS 
} SAS_MEM_TYPE;
#define SAS_VDD SAS_IO
#define SAS_MAX_TYPE		SAS_DANGEROUS

#else /* CPU_40_STYLE */

#define SAS_RAM			0
#define SAS_VIDEO		1
#define SAS_ROM			2
#define SAS_WRAP		3
#define SAS_IO			4
#define SAS_MM_LIM		5
#define SAS_INACCESSIBLE	6
#define SAS_DANGEROUS		7
#define SAS_MAX_TYPE		SAS_DANGEROUS

#endif /* CPU_40_STYLE else */

#define SAS_TYPE_TO_STRING(type) (\
		((type) == SAS_RAM)? "RAM" :\
		((type) == SAS_VIDEO)? "VIDEO" :\
		((type) == SAS_ROM)? "ROM" :\
		((type) == SAS_WRAP)? "WRAP" :\
		((type) == SAS_IO)? "IO" :\
		((type) == SAS_MM_LIM)? "MM_LIM" :\
		((type) == SAS_INACCESSIBLE)? "INACCESSIBLE" :\
		((type) == SAS_DANGEROUS)? "DANGEROUS" :\
		"UNKNOWN TYPE")


/* one #defined function */
#define sas_disconnect_memory(l,h) sas_connect_memory(l,h,SAS_INACCESSIBLE);

#ifdef CPU_40_STYLE


/********************************************************/
/*
 * This interface now uses function pointers, so we need to set up
 * a set of macros with the traditional SAS names that will pick-up
 * the functions pointed to.
 *
 * sas_init and sas_term don't use pointers
 */

#define sas_load(addr, val) *val = sas_hw_at(addr)
#define sas_loadw(addr, val) *val = sas_w_at(addr)
#define sas_loaddw(addr, val) *val = sas_dw_at(addr)

extern void sas_init IPT1(PHY_ADDR, size);
extern void sas_term IPT0();

#include	<sas4gen.h>

#ifdef NTVDM
#ifdef CCPU
extern IU8 *c_GetLinAdd IPT1(IU32, lin_addr);
#define NtGetPtrToLinAddrByte(x) c_GetLinAdd(x)
#else /* !CCPU */
extern IU8 *NtGetPtrToLinAddrByte IPT1(IU32, lin_addr);
#endif /* CCPU */
#endif /* NTVDM */

/*
 * TEMPORARY FOR NT!!!!!
 */

extern host_addr Start_of_M_area;       /* host addr (char *) of start of M */
extern  IHPE    Length_of_M_area;       /* offset of end of M */
#else /* CPU_40_STYLE */
#define sas_set_buf(buf,addr)	buf=get_byte_addr(addr)

extern host_addr Start_of_M_area;	/* host addr (char *) of start of M */
#ifdef	GISP_CPU
extern	IHPE	Length_of_M_area;	/* offset of end of M */
#else
extern sys_addr Length_of_M_area;	/* sys addr (long) offset of end of M */
#endif	/* GISP_CPU */

/* the following is for integration only */

#ifdef CHEAT
#ifdef M_IS_POINTER
extern half_word *M;
#else
extern half_word M[];
#endif /* M_IS_POINTER */
#endif /* CHEAT */

/*
	The following is to allow hosts to redefine the sas_interface to
	function pointers is they so wish
*/

#if !defined(HOST_SAS) || defined(BASE_SAS)

/********************************************************/
/* pointer manipulation macros */
/*
 * Note that the PHY_ADDR casts in get_byte_addr shouldn't need to be
 * there, but I've put them in to reduce BCN 2275's impact on other files.
 * I'll take them out in a future BCN.
 *
 *						Mike.
 */

#ifdef BACK_M
#define inc_M_ptr(p,o)	(p-(o))
#define get_byte_addr(addr) ((IU8 *)((IHPE)Start_of_M_area + Length_of_M_area - 1 - (PHY_ADDR)(addr)))
#define M_get_dw_ptr(address) ((IHPE)Start_of_M_area + Length_of_M_area - 1 - (long)(address) - 3)
#else /* BACK_M */
#define inc_M_ptr(p,o)	(p+(o))
#define get_byte_addr(addr) ((IU8 *)((IHPE)Start_of_M_area + (PHY_ADDR)(addr)))
#define M_get_dw_ptr(address) ((IHPE)Start_of_M_area + (long)(address))
#endif /* BACK_M */

/********************************************************/

/********************************************************/

/*
 * These function prototypes and macros were taken out to make implementation
 * of 4.0 easier.  We'll leave them in for builds prior to 3.0 though.
 *
 */
#ifndef CPU_30_STYLE
#define M_low (long)Start_of_M_area
#define M_high (long)(Length_of_M_area-1)
#ifdef BACK_M
#define get_addr(type,address) (M_low+M_high- (long)(address) - (sizeof(type)-1))
#define get_offset_into_M(p) (M_high - p)
#else /* BACK_M */
#define get_addr(type,address) (M_low+ (long)(address))
#define get_offset_into_M(p) (p - M_low)
#endif /* BACK_M */
#define M_index_hw(p,a) (*(get_byte_addr(get_offset_into_M(p)+a))) 
#define M_index_w(p,a) (*(get_word_addr(get_offset_into_M(p)+(a*sizeof (word))))) 
#define M_index_dw(p,a) (*(get_double_word_addr(get_offset_into_M(p)+(a*sizeof(double_word)))))
#define M_index(t,p,a) (*(get_addr(t,get_offset_into_M(p)+(a*sizeof(t)))))
#define M_get_hw_ptr(a) get_byte_addr(a)
#define M_get_w_ptr(a) get_word_addr(a)
#define get_word_addr(address) ((host_addr)get_addr(word,address))
#define get_double_word_addr(address) ((host_addr)get_addr(double_word,address))

extern void sas_part_enable_20_bit_wrap IPT3(BOOL, for_write,
	sys_addr, start_offset, sys_addr, end_offset);
extern void sas_part_disable_20_bit_wrap IPT3(BOOL, for_write,
	sys_addr, start_offset, sys_addr, end_offset);
extern void sas_move_bytes_backward IPT3(sys_addr, src, sys_addr, dest,
	sys_addr, len);
extern void sas_move_words_backward IPT3(sys_addr, src, sys_addr, dest,
	sys_addr, len);
#endif /* !CPU_30_STYLE */

/********************************************************/
/* function declarations */
extern void sas_init IPT1(sys_addr, size);
extern void sas_term IPT0();
#ifdef	GISP_CPU
extern IHPE sas_memory_size IPT0 ();
#else
extern sys_addr sas_memory_size IPT0();
#endif	/* GISP_CPU */
extern void sas_connect_memory IPT3(sys_addr, low, sys_addr, high,
	half_word, type);
extern void sas_overwrite_memory IPT2(sys_addr, addr, int, type);

#ifdef NTVDM
/* We call xms functions(which in turn, will call sas functions) to
   manage the A20 line wrapping. The reason is that we want to keep
   the A20 line current state in himem.sys so that we don't have to
   bop to 32 bits side to get the state.
*/
extern void xmsEnableA20Wrapping(void);
extern void xmsDisableA20Wrapping(void);
#endif  /* NTVDM */

extern half_word sas_memory_type IPT1(sys_addr, addr);
extern void sas_enable_20_bit_wrapping IPT0();
extern void sas_disable_20_bit_wrapping IPT0();
extern BOOL sas_twenty_bit_wrapping_enabled IPT0();
extern half_word sas_hw_at IPT1(sys_addr, addr);
extern word sas_w_at IPT1(sys_addr, addr);
extern double_word sas_dw_at IPT1(sys_addr, addr);
extern half_word sas_hw_at_no_check IPT1(sys_addr, addr);
extern word sas_w_at_no_check IPT1(sys_addr, addr);
extern double_word sas_dw_at_no_check IPT1(sys_addr, addr);
extern void sas_load IPT2(sys_addr, addr, half_word *, val);
extern void sas_store IPT2(sys_addr, addr, half_word, val);
extern void sas_store_no_check IPT2(sys_addr, addr24, half_word, val);
#ifndef SUN_VA
extern void sas_loadw IPT2(sys_addr, addr, word *, val);
extern void sas_storew IPT2(sys_addr, addr, word, val);
extern void sas_storew_no_check IPT2(sys_addr, addr24, word, val);
#else
extern void sas_loadw_swap IPT2(sys_addr, addr, word *, val);
extern void sas_storew_swap IPT2(sys_addr, addr, word, val);
#endif	/* SUN_VA */
extern void sas_storedw IPT2(sys_addr, addr, double_word, val);
extern void sas_loads IPT3(sys_addr, src, host_addr, dest, sys_addr, len);
extern void sas_stores IPT3(sys_addr, dest, host_addr, src, sys_addr, len);
extern int sas_strlen IPT1(sys_addr, str_ptr);
extern void sas_move_bytes_forward IPT3(sys_addr, src, sys_addr, dest,
	sys_addr, len);
extern void sas_move_words_forward IPT3(sys_addr, src, sys_addr, dest,
	sys_addr, len);
extern void sas_fills IPT3(sys_addr, addr, half_word, val, sys_addr, len);
extern void sas_fillsw IPT3(sys_addr, addr, word, val, sys_addr, len);
extern host_addr sas_scratch_address IPT1(sys_addr, length);
extern host_addr sas_transbuf_address IPT2(sys_addr, intel_dest_addr, sys_addr, length);
extern void sas_loads_to_transbuf IPT3(sys_addr, src, host_addr, dest, sys_addr, len);
extern void sas_stores_from_transbuf IPT3(sys_addr, dest, host_addr, src, sys_addr, len);

#endif /* HOST_SAS */

/*
 * These are the physical memory interfaces introduced in 4.0.  As
 * physical and linear addresses are the same before 4.0, we can
 * just point them at the appropriate linear addresses.
 */

#define sas_PR8		sas_hw_at
#define sas_PR16	sas_w_at
#define sas_PR32	sas_dw_at
#define sas_PW8		sas_store
#define sas_PW16	sas_storew
#define sas_PW32	sas_storedw
#define sas_PWS		sas_stores
#define sas_PRS		sas_loads

#endif /* ! CPU_40_STYLE */

/********************************************************/
/* this marco is used as a replacement for cpu_sw_interrupt */

#define exec_sw_interrupt(c,i)	\
{				\
    word cs,ip;			\
				\
    cs = getCS(); ip = getIP(); \
				\
    setCS(c); setIP(i); 	\
    host_simulate();		\
				\
    setCS(cs); setIP(ip);	\
}


/********************************************************/
/* Size of memory array in half-words */
#define PC_MEM_SIZE 	0x100000L		/* 1 Mbyte 	*/
#define MEMORY_TOP      0xA0000L                /* 640K DOS limit */

/* Memory bounds for the colour graphics adaptor */

#ifdef BACK_M

#ifndef HERC_REGEN_BUFF
#define CGA_REGEN_BUFF	0xBBFFFL
#define MDA_REGEN_BUFF	0xB7FFFL
#define HERC_REGEN_BUFF	0xBFFFFL
#endif /* HERC_REGEN_BUFF */

#else

#ifndef HERC_REGEN_BUFF
#define CGA_REGEN_BUFF	0xB8000L
#define MDA_REGEN_BUFF	0xB0000L
#define HERC_REGEN_BUFF	0xB0000L
#endif /* HERC_REGEN_BUFF */

#endif /* BACK_M */

#define CGA_REGEN_START	0xB8000L
#define CGA_REGEN_END		0xBBFFFL
#define CGA_REGEN_LENGTH	(CGA_REGEN_END - CGA_REGEN_START + 1L)

#define MDA_REGEN_START	0xB0000L
#define MDA_REGEN_END		0xB7FFFL
#define MDA_REGEN_LENGTH	(MDA_REGEN_END - MDA_REGEN_START + 1L)

#define HERC_REGEN_START	0xB0000L
#define HERC_REGEN_END	0xBFFFFL
#define HERC_REGEN_LENGTH	(HERC_REGEN_END - HERC_REGEN_START + 1L)

/*
 * Constants used by the sas initialisation function.  These consist of
 * memory locations and PC instructions for the BIOS calling structure.
 *
 * The BIOS calls are via the BOP pseudo instruction and these are 
 * positioned at the real entry points for the PC.  See the BIOS module
 * for a more detailed description of the calling mechanism.
 */

/* General Intel memory parameters */


#if defined(NEC_98)
#define BIOSN_START             0xE8000L
#define BIOSH_START             0xF0000L
#else  // !NEC_98
#define BIOS_START_OFFSET	0x0000L
#define BIOS1_END_SEGMENT	0xF000L
#define BIOS1_END_OFFSET 	0x7000L 	/* End of 1st half of ROM */
#define BIOS2_START_SEGMENT	0xF000L
#define BIOS2_START_OFFSET 	0xE000L		/* 2nd half of BIOS ROM	*/
#endif // !NEC_98
#define	BAD_OP			0xC5		/* filling RAM for the use of */

#if defined(NEC_98)
#define ROM_START               0xE8000L
#else  // !NEC_98
#define	BASIC_ROM		0xFE000L	/* Start of Basic Rom */
#define ROM_START		0xC0000L	/* Start of Expansion ROM @ 768k */
#endif // !NEC_98

#define FIXED_DISK_START	0xC8000L	/* Start fixed disk BIOS*/
#define FIXED_DISK_END		0xCA000L	/* End fixed disk BIOS +1 */

#define	START_SEGMENT		0xF000		/* 8088 start address */
#define	START_OFFSET		0xFFF0

#if defined(NEC_98)
#define MEMORY_SWITCH_START_N   0xA3FE0L
#define MEMORY_SWITCH_START_H   0xE3FE0L
#endif // NEC_98

/*
 * The follwoing are the offsets for the entry points to the
 * BIOS function calls.  These will be loaded into the interrupt vector
 * table.  
 * the Segments are defined later, depending upon GISP_SVGA
 * for which they will be the global Rom address variables
 */

#define COPYRIGHT_OFFSET	0xE008
#define RESET_OFFSET		0xE05B
#define BOOT_STRAP_OFFSET	0xE6F2
#define DOS_OFFSET		0x7C00
#define KEYBOARD_IO_OFFSET	0xE82E
#define DISKETTE_IO_OFFSET	0xEC49
#ifndef GISP_SVGA
#define VIDEO_IO_OFFSET		0xF065
#else		/* GISP_SVGA */
#define VIDEO_IO_OFFSET		0x0810
#define CGA_VIDEO_IO_OFFSET	0xF065
#endif		/* GISP_SVGA  */
#define VIDEO_IO_RE_ENTRY	0xF06C
#define MEMORY_SIZE_OFFSET	0xF841
#define EQUIPMENT_OFFSET	0xF84D
#define TIME_OF_DAY_OFFSET	0xFE6E
#define DISK_IO_OFFSET		0x0256
#define RS232_IO_OFFSET		0xE739
#define CASSETTE_IO_OFFSET	0xF859
#define PRINTER_IO_OFFSET	0xEFD2
#define PRINT_SCREEN_OFFSET	0xFF54
#define BASIC_OFFSET		0xEC00
#define VIDEO_PARM_OFFSET	0xF0A4
#define DISKETTE_TB_OFFSET	0xEFC7
#define DISK_TB_OFFSET		0x03E7
#define EXTEND_CHAR_OFFSET	0x0000
#define MOUSE_VIDEO_IO_OFFSET	0xED80

#if defined(NTVDM) && !defined(X86GFX)
#define MOUSE_IO_INTERRUPT_SEGMENT  0xF000
#define MOUSE_IO_INTERRUPT_OFFSET   0xED00
#endif

#define KEYBOARD_BREAK_INT_OFFSET   0xFF35
#define PRINT_SCREEN_INT_OFFSET	    0xFF3B
#define USER_TIMER_INT_OFFSET	    0xFF41

/* ... and the device interrupts...  */
#define UNEXP_INT_OFFSET	0x6f00
#define DUMMY_INT_OFFSET	0xFF4B
#define TIMER_INT_OFFSET	0xFEA5
#define ILL_OP_INT_OFFSET       0xFF30
#define KB_INT_OFFSET		0xE987
#define DISKETTE_INT_OFFSET	0xEF57
#define DISK_INT_OFFSET		0x0760
#define MOUSE_INT1_OFFSET	0xEE00
#define MOUSE_INT2_OFFSET	0xEE80
#define	MOUSE_VERSION_OFFSET	0xED20
#define	MOUSE_COPYRIGHT_OFFSET	0xED40
#define RTC_INT_OFFSET		0x4B1B
#define D11_INT_OFFSET		0x1BE0
#define	REDIRECT_INT_OFFSET	0x1C2F
#define X287_INT_OFFSET		0x1C38

/* ...and the dummy return for address compatibility */
#define ADDR_COMPATIBILITY_OFFSET  0xFF53

/* define the location of the code that the recursive CPU will start at */
#define RCPU_POLL_OFFSET	0xe850
#define RCPU_NOP_OFFSET		0xe950
#define RCPU_INT15_OFFSET	0xe970
#define RCPU_INT4A_OFFSET	0x4B30

/* ...and the data tables */
#define CONF_TABLE_OFFSET       0xE6F5

#define	DR_TYPE_OFFSET		0x0C50

#define MD_TBL1_OFFSET          (DR_TYPE_OFFSET + 0x15)
#define MD_TBL2_OFFSET          (MD_TBL1_OFFSET + 0xd)
#define MD_TBL3_OFFSET          (MD_TBL2_OFFSET + 0xd)
#define MD_TBL4_OFFSET          (MD_TBL3_OFFSET + 0xd)
#define MD_TBL5_OFFSET          (MD_TBL4_OFFSET + 0xd)
#define MD_TBL6_OFFSET          (MD_TBL5_OFFSET + 0xd)

#define RCPU_WAIT_INT_OFFSET    0x0CE0

/*
 * ROM locations of disk parameter blocks
 */

#define	DISKIO_OFFSET		0x2e86
#define	DISKISR_OFFSET		0x33b7
#define	DISKWAIT_OFFSET		0x329f	/* DISKIO_OFFSET + 0x419 */
#define	DPB0_OFFSET		0x0421
#define	DPB1_OFFSET		0x0431

/* Video MODE Table stuff etc (CGA) */

#define VID_PARMS_OFFSET	0xF0A4
#define VID_LENS_OFFSET		0xF0E4
#define VID_COLTAB_OFFSET	0xF0EC
#define VID_MODTAB_OFFSET	0xF0F4
#define	CHAR_GEN_OFFSET		0xFA6E


/* Location of EGA entry point for INT 10 */
#ifndef GISP_SVGA 
#define EGA_ENTRY_OFF	0x0898
#else	 	/* GISP_SVGA */
#define EGA_ENTRY_OFF	0x0800
#endif		/* GISP_SVGA */

/* Off set info for EGA character tables */
#define EGA_CGMN_OFF	0x2230
#define EGA_CGMN_FDG_OFF 0x3030
#define EGA_CGDDOT_OFF	0x3160
#define EGA_HIFONT_OFF	0x3990
#define EGA_INT1F_OFF	0x3560

/*
* To enable our drivers to output messages generated from
* our bops we use a scratch area inside our rom.
*/

#define DOS_SCRATCH_PAD_OFFSET		0x6400
#define DOS_SCRATCH_PAD_END_OFFSET	0x6fff

#ifndef GISP_SVGA

#define BIOS_START_SEGMENT	0xF000
#define	SYSROM_SEG		0xF000
#define	SYSROMORG_SEG		0xFe00
#define COPYRIGHT_SEGMENT	0xF000
#define RESET_SEGMENT		0xF000
#define BOOT_STRAP_SEGMENT	0xF000
#define DOS_SEGMENT		0x0000
#define KEYBOARD_IO_SEGMENT	0xF000
#define DISKETTE_IO_SEGMENT	0xF000
#define VIDEO_IO_SEGMENT	0xF000
#define VIDEO_IO_RE_ENTRY	0xF06C
#define MEMORY_SIZE_SEGMENT	0xF000
#define EQUIPMENT_SEGMENT	0xF000
#define TIME_OF_DAY_SEGMENT	0xF000
#define DISK_IO_SEGMENT		0xC800
#define RS232_IO_SEGMENT	0xF000
#define CASSETTE_IO_SEGMENT	0xF000
#define PRINTER_IO_SEGMENT	0xF000
#define PRINT_SCREEN_SEGMENT	0xF000
#define BASIC_SEGMENT		0xF000
#define VIDEO_PARM_SEGMENT	0xF000
#define DISKETTE_TB_SEGMENT	0xF000
#define DISK_TB_SEGMENT		0xC800
#define EXTEND_CHAR_SEGMENT	0xF000
#ifndef MOUSE_VIDEO_IO_SEGMENT
#define MOUSE_VIDEO_IO_SEGMENT	0xF000
#endif /* MOUSE_VIDEO_IO_SEGMENT */

#define KEYBOARD_BREAK_INT_SEGMENT  0xF000
#define PRINT_SCREEN_INT_SEGMENT    0xF000
#define USER_TIMER_INT_SEGMENT	    0xF000

/* ... and the device interrupts...  */
#define UNEXP_INT_SEGMENT	0xF000
#define DUMMY_INT_SEGMENT	0xF000
#define TIMER_INT_SEGMENT	0xF000
#define ILL_OP_INT_SEGMENT      0xF000
#define KB_INT_SEGMENT		0xF000
#define DISKETTE_INT_SEGMENT	0xF000
#define DISK_INT_SEGMENT	0xC800
#ifndef MOUSE_INT1_SEGMENT
#define MOUSE_INT1_SEGMENT	0xF000
#endif /* MOUSE_INT1_SEGMENT */
#ifndef MOUSE_INT2_SEGMENT
#define MOUSE_INT2_SEGMENT	0xF000
#endif /* MOUSE_INT2_SEGMENT */
#ifndef	MOUSE_VERSION_SEGMENT
#define	MOUSE_VERSION_SEGMENT	0xF000
#endif /* MOUSE_VERSION_SEGMENT */
#ifndef	MOUSE_COPYRIGHT_SEGMENT
#define	MOUSE_COPYRIGHT_SEGMENT	0xF000
#endif /* MOUSE_COPYRIGHT_SEGMENT */
#define RTC_INT_SEGMENT		0xF000
#define D11_INT_SEGMENT		0xF000
#define	REDIRECT_INT_SEGMENT	0xF000
#define	X287_INT_SEGMENT	0xF000

/* ...and the dummy return for address compatibility */
#define ADDR_COMPATIBILITY_SEGMENT 0xF000

/* define the location of the code that the recursive CPU will start at */
#define RCPU_POLL_SEGMENT	KB_INT_SEGMENT
#define RCPU_NOP_SEGMENT	KB_INT_SEGMENT
#define RCPU_INT15_SEGMENT	KB_INT_SEGMENT
#define RCPU_INT4A_SEGMENT	RTC_INT_SEGMENT

/* ...and the data tables */
#define CONF_TABLE_SEGMENT	0xF000

#define	DISKETTE_IO_1_SEGMENT	0xFE00
#define	DR_TYPE_SEGMENT		DISKETTE_IO_1_SEGMENT

#define MD_TBL1_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL2_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL3_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL4_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL5_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL6_SEGMENT         DISKETTE_IO_1_SEGMENT
#define DPB0_SEGMENT		0xF000
#define DPB1_SEGMENT		0xF000

#define RCPU_WAIT_INT_SEGMENT	DISKETTE_IO_1_SEGMENT

/* Video MODE Table stuff etc (CGA) */

#define VID_PARMS_SEGMENT	0xF000
#define VID_LENS_SEGMENT	0xF000
#define	VID_COLTAB_SEGMENT	0xF000
#define VID_MODTAB_SEGMENT	0xF000
#define	CHAR_GEN_SEGMENT	0xF000

/* Off set info for EGA character tables */
#define EGA_CGMN_OFF	0x2230
#define EGA_CGMN_FDG_OFF 0x3030
#define EGA_CGDDOT_OFF	0x3160
#define EGA_HIFONT_OFF	0x3990
#define EGA_INT1F_OFF	0x3560

#define DOS_SCRATCH_PAD_SEGMENT          0xF000
#define DOS_SCRATCH_PAD_END_SEGMENT      0xF000

/* ...and the 20 bit address corresponding to the above */

#define BIOS_START		(sys_addr)(BIOS_START_SEGMENT * 16L) + \
					(sys_addr)BIOS_START_OFFSET
#define BIOS1_END		(sys_addr)(BIOS1_END_SEGMENT * 16L) + \
					(sys_addr)BIOS1_END_OFFSET
#define BIOS2_START		(sys_addr)(BIOS2_START_SEGMENT * 16L) + \
					(sys_addr)BIOS2_START_OFFSET
#define START_ADDR 		(sys_addr)(START_SEGMENT * 16L) + \
					(sys_addr)START_OFFSET
#define COPYRIGHT_ADDR 		(sys_addr)(COPYRIGHT_SEGMENT * 16L) + \
					(sys_addr)COPYRIGHT_OFFSET
#define RESET_ADDR 		(sys_addr)(RESET_SEGMENT * 16L) + \
					(sys_addr)RESET_OFFSET
#define BOOT_STRAP_ADDR		(sys_addr)(BOOT_STRAP_SEGMENT * 16L)  + \
					(sys_addr)BOOT_STRAP_OFFSET
#define KEYBOARD_IO_ADDR	(sys_addr)(KEYBOARD_IO_SEGMENT * 16L) + \
					(sys_addr)KEYBOARD_IO_OFFSET
#define DISKETTE_IO_ADDR	(sys_addr)(DISKETTE_IO_SEGMENT * 16L) + \
					(sys_addr)DISKETTE_IO_OFFSET
#define VIDEO_IO_ADDR		(sys_addr)(VIDEO_IO_SEGMENT * 16L) + \
					(sys_addr)VIDEO_IO_OFFSET
#define MEMORY_SIZE_ADDR	(sys_addr)(MEMORY_SIZE_SEGMENT * 16L) + \
					(sys_addr)MEMORY_SIZE_OFFSET
#define EQUIPMENT_ADDR		(sys_addr)(EQUIPMENT_SEGMENT * 16L) + \
					(sys_addr)EQUIPMENT_OFFSET
#define TIME_OF_DAY_ADDR	(sys_addr)(TIME_OF_DAY_SEGMENT * 16L) + \
					(sys_addr)TIME_OF_DAY_OFFSET
#define DISK_IO_ADDR		(sys_addr)(DISK_IO_SEGMENT * 16L) + \
					(sys_addr)DISK_IO_OFFSET
#define RS232_IO_ADDR		(sys_addr)(RS232_IO_SEGMENT * 16L) + \
					(sys_addr)RS232_IO_OFFSET
#define CASSETTE_IO_ADDR	(sys_addr)(CASSETTE_IO_SEGMENT * 16L) + \
					(sys_addr)CASSETTE_IO_OFFSET
#define PRINTER_IO_ADDR		(sys_addr)(PRINTER_IO_SEGMENT * 16L) + \
					(sys_addr)PRINTER_IO_OFFSET
#define PRINT_SCREEN_ADDR	(sys_addr)(PRINT_SCREEN_SEGMENT * 16L) + \
					(sys_addr)PRINT_SCREEN_OFFSET
#define BASIC_ADDR		(sys_addr)(BASIC_SEGMENT * 16L) + \
					(sys_addr) BASIC_OFFSET
#define DISKETTE_TB_ADDR	(sys_addr)(DISKETTE_TB_SEGMENT * 16L) + \
					(sys_addr)DISKETTE_TB_OFFSET
#define DISK_TB_ADDR		(sys_addr)(DISK_TB_SEGMENT * 16L) + \
					(sys_addr)DISK_TB_OFFSET
#define MOUSE_VIDEO_IO_ADDR	(sys_addr)(MOUSE_VIDEO_IO_SEGMENT * 16L) + \
					(sys_addr)MOUSE_VIDEO_IO_OFFSET
#define DUMMY_INT_ADDR		(sys_addr)(DUMMY_INT_SEGMENT * 16L) + \
					(sys_addr)DUMMY_INT_OFFSET
#define TIMER_INT_ADDR		(sys_addr)(TIMER_INT_SEGMENT * 16L) + \
					(sys_addr)TIMER_INT_OFFSET
#define KB_INT_ADDR		(sys_addr)(KB_INT_SEGMENT * 16L) + \
					(sys_addr)KB_INT_OFFSET
#define DISKETTE_INT_ADDR	(sys_addr)(DISKETTE_INT_SEGMENT * 16L) + \
					(sys_addr)DISKETTE_INT_OFFSET
#define DISK_INT_ADDR		(sys_addr)(DISK_INT_SEGMENT * 16L) + \
					(sys_addr)DISK_INT_OFFSET
#define UNEXP_INT_ADDR		(sys_addr)(UNEXP_INT_SEGMENT * 16L) + \
					(sys_addr)UNEXP_INT_OFFSET
#define MOUSE_INT1_ADDR		(sys_addr)(MOUSE_INT1_SEGMENT * 16L) + \
					(sys_addr)MOUSE_INT1_OFFSET
#define MOUSE_INT2_ADDR		(sys_addr)(MOUSE_INT2_SEGMENT * 16L) + \
					(sys_addr)MOUSE_INT2_OFFSET
#define MOUSE_VERSION_ADDR	(sys_addr)(MOUSE_VERSION_SEGMENT * 16L) + \
					(sys_addr)MOUSE_VERSION_OFFSET
#define MOUSE_COPYRIGHT_ADDR	(sys_addr)(MOUSE_COPYRIGHT_SEGMENT * 16L) + \
					(sys_addr)MOUSE_COPYRIGHT_OFFSET
#define ADDR_COMPATIBILITY_ADDR	(sys_addr)(ADDR_COMPATIBILITY_SEGMENT * 16L) + \
					(sys_addr)ADDR_COMPATIBILITY_OFFSET
#define CONF_TABLE_ADDR   	(sys_addr)(CONF_TABLE_SEGMENT * 16L) + \
					(sys_addr)CONF_TABLE_OFFSET
#define DISK_BASE_ADDR          (sys_addr)(DISK_BASE_SEGMENT * 16L) + \
					(sys_addr)DISK_BASE_OFFSET
#define DR_TYPE_ADDR            (sys_addr)(DR_TYPE_SEGMENT * 16L) + \
					(sys_addr)DR_TYPE_OFFSET
#define DISKETTE_IO_1_ADDR      (sys_addr)(DISKETTE_IO_SEGMENT * 16L) + \
					(sys_addr)DISKETTE_IO_OFFSET
#define MD_TBL1_ADDR            (sys_addr)(MD_TBL1_SEGMENT * 16L) + \
					(sys_addr)MD_TBL1_OFFSET
#define MD_TBL2_ADDR            (sys_addr)(MD_TBL2_SEGMENT * 16L) + \
					(sys_addr)MD_TBL2_OFFSET
#define MD_TBL3_ADDR            (sys_addr)(MD_TBL3_SEGMENT * 16L) + \
					(sys_addr)MD_TBL3_OFFSET
#define MD_TBL4_ADDR            (sys_addr)(MD_TBL4_SEGMENT * 16L) + \
					(sys_addr)MD_TBL4_OFFSET
#define MD_TBL5_ADDR            (sys_addr)(MD_TBL5_SEGMENT * 16L) + \
					(sys_addr)MD_TBL5_OFFSET
#define MD_TBL6_ADDR            (sys_addr)(MD_TBL6_SEGMENT * 16L) + \
					(sys_addr)MD_TBL6_OFFSET
#define RCPU_WAIT_INT_ADDR      (sys_addr)(RCPU_WAIT_INT_SEGMENT * 16L) + \
					(sys_addr)RCPU_WAIT_INT_OFFSET
#define	DPB0		0xfe421	
#define	DPB1		0xfe431

/* Addresses in Intel memory of constant keyboard tables */
#define K6     0xFE87EL
#define K7     0xFE886L
#define K8     0xFE88EL
#define K9     0xFE8C8L
#define K10    0xFE8E6L
#define K11    0xFE98AL
#define K30    0xFEA87L

/* Video Stuff CGA */

#define VID_PARMS	(sys_addr)(VID_PARMS_SEGMENT * 16L) + \
						(sys_addr)VID_PARMS_OFFSET
#define	VID_LENS			(sys_addr)(VID_LENS_SEGMENT * 16L) + \
					(sys_addr)VID_LENS_OFFSET
#define	VID_COLTAB			(sys_addr)(VID_COLTAB_SEGMENT * 16L) + \
					(sys_addr)VID_COLTAB_OFFSET
#define	VID_MODTAB			(sys_addr)(VID_COLTAB_SEGMENT * 16L) + \
					(sys_addr)VID_MODTAB_OFFSET
#define	CHAR_GEN_ADDR			(sys_addr)(CHAR_GEN_SEGMENT * 16L) + \
					(sys_addr)CHAR_GEN_OFFSET

#define DOS_SCRATCH_PAD (sys_addr)(DOS_SCRATCH_PAD_SEGMENT * 16L) + \
					(sys_addr)DOS_SCRATCH_PAD_OFFSET
#define DOS_SCRATCH_PAD_END (sys_addr)(DOS_SCRATCH_PAD_END_SEGMENT * 16L) + \
					(sys_addr)DOS_SCRATCH_PAD_END_OFFSET

#ifdef EGG
#define EGA_ROM_START		0xC0000L	/* start of EGA BIOS ROM */
#ifdef STINGER
#define EGA_ROM_END		0xC4A00L	/* end of EGA BIOS ROM +1 */
#else		/* ~STINGER */
#ifdef V7VGA
#define EGA_ROM_END		0xC5000L	/* end of EGA BIOS ROM +1 */
#else
#define EGA_ROM_END		0xC4000L	/* end of EGA BIOS ROM +1 */
#endif /* V7VGA */
#endif		/* STINGER */
#endif		/* EGG */

#ifdef EGG

#define EGA_SEG	0xC000			/* Segment Address For the ega ROM */

/* EGA Font stuff */

#define EGA_CGMN	0xC2230
#define EGA_CGDDOT	0xC3160
#define EGA_HIFONT	0xC3990		/* 8x16 font for 640x480 ext */

#endif		/* EGG */



#else		/* GISP_SVGA */

/* The segment which the bios is gonna be loaded into */
extern word	Bios1Segment;
extern word	Bios2Segment;
extern word	EgaROMSegment;
extern word	EgaFontSegment;

/* Define all the segment address values to be out variables, just in case */

#define COPYRIGHT_SEGMENT	Bios1Segment
#define RESET_SEGMENT		Bios1Segment
#define BOOT_STRAP_SEGMENT	Bios1Segment
#define DOS_SEGMENT		0x0000
#define KEYBOARD_IO_SEGMENT	Bios1Segment
#define DISKETTE_IO_SEGMENT	Bios1Segment
#define VIDEO_IO_SEGMENT	Bios1Segment
#define VIDEO_IO_RE_ENTRY	0xF06C
#define MEMORY_SIZE_SEGMENT	Bios1Segment
#define EQUIPMENT_SEGMENT	Bios1Segment
#define TIME_OF_DAY_SEGMENT	Bios1Segment
#define DISK_IO_SEGMENT		0xC800
#define RS232_IO_SEGMENT	Bios1Segment
#define CASSETTE_IO_SEGMENT	Bios1Segment
#define PRINTER_IO_SEGMENT	Bios1Segment
#define PRINT_SCREEN_SEGMENT	Bios1Segment
#define BASIC_SEGMENT		Bios1Segment
#define VIDEO_PARM_SEGMENT	Bios1Segment
#define DISKETTE_TB_SEGMENT	Bios1Segment
#define DISK_TB_SEGMENT		0xC800
#define EXTEND_CHAR_SEGMENT	Bios1Segment
#ifndef MOUSE_VIDEO_IO_SEGMENT
#define MOUSE_VIDEO_IO_SEGMENT	Bios1Segment
#endif /* MOUSE_VIDEO_IO_SEGMENT */

#define KEYBOARD_BREAK_INT_SEGMENT  Bios1Segment
#define PRINT_SCREEN_INT_SEGMENT    Bios1Segment
#define USER_TIMER_INT_SEGMENT	    Bios1Segment

/* ... and the device interrupts...  */
#define UNEXP_INT_SEGMENT	Bios1Segment
#define DUMMY_INT_SEGMENT	Bios1Segment
#define TIMER_INT_SEGMENT	Bios1Segment
#define ILL_OP_INT_SEGMENT      Bios1Segment
#define KB_INT_SEGMENT		Bios1Segment
#define DISKETTE_INT_SEGMENT	Bios1Segment
#define DISK_INT_SEGMENT	0xC800
#ifndef MOUSE_INT1_SEGMENT
#define MOUSE_INT1_SEGMENT	Bios1Segment
#endif /* MOUSE_INT1_SEGMENT */
#ifndef MOUSE_INT2_SEGMENT
#define MOUSE_INT2_SEGMENT	Bios1Segment
#endif /* MOUSE_INT2_SEGMENT */
#ifndef	MOUSE_VERSION_SEGMENT
#define	MOUSE_VERSION_SEGMENT	Bios1Segment
#endif /* MOUSE_VERSION_SEGMENT */
#ifndef	MOUSE_COPYRIGHT_SEGMENT
#define	MOUSE_COPYRIGHT_SEGMENT	Bios1Segment
#endif /* MOUSE_COPYRIGHT_SEGMENT */
#define RTC_INT_SEGMENT		Bios1Segment
#define D11_INT_SEGMENT		Bios1Segment
#define	REDIRECT_INT_SEGMENT	Bios1Segment
#define	X287_INT_SEGMENT	Bios1Segment

/* ...and the dummy return for address compatibility */
#define ADDR_COMPATIBILITY_SEGMENT Bios1Segment

/* define the location of the code that the recursive CPU will start at */
#define RCPU_POLL_SEGMENT	KB_INT_SEGMENT
#define RCPU_NOP_SEGMENT	KB_INT_SEGMENT
#define RCPU_INT15_SEGMENT	KB_INT_SEGMENT
#define RCPU_INT4A_SEGMENT	RTC_INT_SEGMENT

/* ...and the data tables */
#define CONF_TABLE_SEGMENT	Bios1Segment

#define	DISKETTE_IO_1_SEGMENT	Bios2Segment
#define	DR_TYPE_SEGMENT		DISKETTE_IO_1_SEGMENT

#define MD_TBL1_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL2_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL3_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL4_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL5_SEGMENT         DISKETTE_IO_1_SEGMENT
#define MD_TBL6_SEGMENT         DISKETTE_IO_1_SEGMENT
#define DPB0_SEGMENT		Bios1Segment
#define DPB1_SEGMENT		Bios1Segment

#define RCPU_WAIT_INT_SEGMENT	DISKETTE_IO_1_SEGMENT

/* Video MODE Table stuff etc (CGA) */

#define VID_PARMS_SEGMENT	Bios1Segment
#define VID_LENS_SEGMENT	Bios1Segment
#define	VID_COLTAB_SEGMENT	Bios1Segment
#define VID_MODTAB_SEGMENT	Bios1Segment
#define	CHAR_GEN_SEGMENT	Bios1Segment

/*
	All the entrypoints and table locations for the roms are held in
	this structure (romAddress) - it should be initialised in
	host_rom_init() 
*/

extern struct romAddressTag {
	sys_addr	startAddr;
	sys_addr	bios1StartAddr;
	sys_addr	bios2StartAddr;
	sys_addr	copyrightAddr;
	sys_addr	resetAddr;
	sys_addr	bootStrapAddr;
	sys_addr	keyboardIOAddr;
	sys_addr	disketteIOAddr;
	sys_addr	videoIOAddr;
	sys_addr	memorySizeAddr;
	sys_addr	equipmentAddr;
	sys_addr	timeOfDayAddr;
	sys_addr	diskIOAddr;
	sys_addr	rs232IOAddr;
	sys_addr	cassetteIOAddr;
	sys_addr	printerIOAddr;
	sys_addr	printScreenAddr;
	sys_addr	basicAddr;
	sys_addr	disketteTbAddr;
	sys_addr	diskTbAddr;
	sys_addr	mouseIOIntAddr;
	sys_addr	mouseVideoIOAddr;
	sys_addr	dummyIntAddr;
	sys_addr	timerIntAddr;
	sys_addr	kbIntAddr;
	sys_addr	diskettIntAddr;
	sys_addr	diskIntAddr;
	sys_addr	unexpIntAddr;
	sys_addr	mouseInt1Addr;
	sys_addr	mouseInt2Addr;
	sys_addr	mouseVersionAddr;
	sys_addr	mouseCopyrightAddr;
	sys_addr	addrCompatAddr;
	sys_addr	k6;
	sys_addr	k7;
	sys_addr	k8;
	sys_addr	k9;
	sys_addr	k10;
	sys_addr	k11;
	sys_addr	k30;
	sys_addr	confTableAddr;
	sys_addr	diskBaseAddr;
	sys_addr	drTypeAddr;
	sys_addr	disketteIO1Addr;
	sys_addr	mdTbl1Addr;
	sys_addr	mdTbl2Addr;
	sys_addr	mdTbl3Addr;
	sys_addr	mdTbl4Addr;
	sys_addr	mdTbl5Addr;
	sys_addr	mdTbl6Addr;
	sys_addr	rcpuWaitIntAddr;
	sys_addr	diskParamBlock0;
	sys_addr	diskParamBlock1;
	sys_addr	vidParms;
	sys_addr	vidLens;
	sys_addr	vidColTab;
	sys_addr	vidModTab;
	sys_addr	charGen;
#ifdef EGG
	sys_addr	egaStart;
	sys_addr	egaEnd;
	sys_addr	egaFonts;
	sys_addr	egaCgmn;
	sys_addr	egaCgDot;
	sys_addr	egaHiFont;
#endif		/* EGG */
	sys_addr	dosScratchPad;
	sys_addr	dosScratchPadEnd;
}	romAddress;

/* Define out all the 20 bit addresses to be our structure */

#define BIOS_START_SEGMENT		Bios1Segment
#define	SYSROM_SEG			Bios1Segment
#define	SYSROMORG_SEG			Bios2Segment
#define	START_ADDR			romAddress.startAddr
#define BIOS_START			romAddress.bios1StartAddr
#define BIOS2_START			romAddress.bios2StartAddr
#define COPYRIGHT_ADDR 			romAddress.copyrightAddr
#define RESET_ADDR 			romAddress.resetAddr
#define BOOT_STRAP_ADDR			romAddress.bootStrapAddr
#define KEYBOARD_IO_ADDR		romAddress.keyboardIOAddr
#define DISKETTE_IO_ADDR		romAddress.disketteIOAddr
#define VIDEO_IO_ADDR			romAddress.videoIOAddr
#define MEMORY_SIZE_ADDR		romAddress.memoryIOAddr
#define EQUIPMENT_ADDR			romAddress.equipmentAddr
#define TIME_OF_DAY_ADDR		romAddress.timeOfDayAddr
#define DISK_IO_ADDR			romAddress.diskIOAddr
#define RS232_IO_ADDR			romAddress.rs232IOAddr
#define CASSETTE_IO_ADDR		romAddress.cassetteIOAddr
#define PRINTER_IO_ADDR			romAddress.printerIOAddr
#define PRINT_SCREEN_ADDR		romAddress.printScreenAddr
#define BASIC_ADDR			romAddress.basicAddr
#define DISKETTE_TB_ADDR		romAddress.disketteTbAddr
#define DISK_TB_ADDR			romAddress.diskTbAddr
#define MOUSE_VIDEO_IO_ADDR		romAddress.mouseVideoIntAddr
#define DUMMY_INT_ADDR			romAddress.dummyIntAddr
#define TIMER_INT_ADDR			romAddress.timerIntAddr
#define KB_INT_ADDR			romAddress.kbIntAddr
#define DISKETTE_INT_ADDR		romAddress.disketteIntAddr
#define DISK_INT_ADDR			romAddress.diskIntAddr
#define UNEXP_INT_ADDR			romAddress.unexpIntAddr
#define MOUSE_INT1_ADDR			romAddress.mouseInt1Addr
#define MOUSE_INT2_ADDR			romAddress.mouseInt2Addr
#define MOUSE_VERSION_ADDR		romAddress.mouseVersionAddr
#define MOUSE_COPYRIGHT_ADDR		romAddress.mouseCopyrightAddr
#define ADDR_COMPATIBILITY_ADDR		romAddress.addrCompatAddr
#define CONF_TABLE_ADDR   		romAddress.confTableAddr
#define DISK_BASE_ADDR			romAddress.diskBaseAddr
#define DR_TYPE_ADDR           		romAddress.drTypeAddr
#define DISKETTE_IO_1_ADDR		romAddress.disketteIO1Addr
#define MD_TBL1_ADDR			romAddress.mdTbl1Addr
#define MD_TBL2_ADDR           		romAddress.mdTbl2Addr
#define MD_TBL3_ADDR		        romAddress.mdTbl3Addr
#define MD_TBL4_ADDR            	romAddress.mdTbl4Addr
#define MD_TBL5_ADDR            	romAddress.mdTbl5Addr
#define MD_TBL6_ADDR            	romAddress.mdTbl6Addr
#define RCPU_WAIT_INT_ADDR		romAddress.rcpuWaitAddr
#define DPB0				romAddress.diskParamBlock0
#define DPB1				romAddress.diskParamBlock1
#define VID_PARMS			romAddress.vidParms
#define VID_LENS			romAddress.vidLens
#define VID_COLTAB			romAddress.vidColTab
#define VID_MODTAB			romAddress.vidModTab
#define	CHAR_GEN_ADDR			romAddress.charGen
#define DOS_SCRATCH_PAD			romAddress.dosScratchPad
#define DOS_SCRATCH_PAD_END		romAddress.dosScratchPadEnd

/* Addresses in Intel memory of constant keyboard tables */

#define K6		romAddress.k6
#define K7		romAddress.k7
#define K8		romAddress.k8
#define K9		romAddress.k9
#define K10		romAddress.k10
#define K11		romAddress.k11
#define	K30		romAddress.k30

/* The Video Rom Stuff */

#ifdef 	EGG
#define EGA_SEG		EgaROMSegment
#define EGA_ROM_START	romAddress.egaStart	/* start of EGA BIOS ROM */
#define EGA_ROM_END	romAddress.egaEnd	/* end of EGA BIOS ROM +1 */
#define EGA_CGMN	romAddress.egaCgmn
#define EGA_CGDDOT	romAddress.egaCgDot
#define EGA_HIFONT	romAddress.egaHiFont
#endif		/* EGG */

#endif /* GISP_SVGA */

/*
 * Offsets for a set of instructions that are used in virtualisation
 * of our bios accesses (eg IO) on 386 & later processors.
 */

#define BIOS_STI_OFFSET   0x3000
#define BIOS_CLI_OFFSET   0x3010
#define BIOS_INB_OFFSET   0x3020
#define BIOS_INW_OFFSET   0x3030
#define BIOS_IND_OFFSET   0x3040
#define BIOS_OUTB_OFFSET  0x3050
#define BIOS_OUTW_OFFSET  0x3060
#define BIOS_OUTD_OFFSET  0x3070
#define BIOS_WRTB_OFFSET  0x3080
#define BIOS_WRTW_OFFSET  0x3090
#define BIOS_WRTD_OFFSET  0x30a0
#define BIOS_RDB_OFFSET   0x30b0
#define BIOS_RDW_OFFSET   0x30c0
#define BIOS_RDD_OFFSET   0x30d0
#define BIOS_YIELD_OFFSET 0x30e0
#define BIOS_STOSB_OFFSET 0x30f0
#define BIOS_STOSW_OFFSET 0x3110
#define BIOS_STOSD_OFFSET 0x3130
#define BIOS_BAD_OFFSET   0x3200	/* Must be added to sas.h + bios1.rom */


/* The addresses of the Bios timer/motor count variables in 8088 space */
#define TIMER_LOW 	BIOS_VAR_START + 0x6c
#define TIMER_HIGH 	BIOS_VAR_START + 0x6e
#define TIMER_OVFL 	BIOS_VAR_START + 0x70
#define MOTOR_STATUS	BIOS_VAR_START + 0x3F
#define MOTOR_COUNT	BIOS_VAR_START + 0x40


/*
 *  SAS Block Operations
 */
#define SAS_BLKOP_CHECKSUM 1

/*
 * Offset entry point for DEC's PCSA.
 */
#define PCSA_OFFSET	0x170

/* Union for accessing an entry in the Interrupt Vector table */
#ifdef BACK_M

#ifdef BIGEND
typedef union   {
		double_word all;
		struct  {
			half_word hw0;
			half_word hw1;
			half_word hw2;
			half_word hw3;
	        	} hwords;
		} IVT_ENTRY;
#endif

#ifdef LITTLEND
typedef union   {
		double_word all;
		struct  {
			half_word hw3;
			half_word hw2;
			half_word hw1;
			half_word hw0;
	        	} hwords;
		} IVT_ENTRY;
#endif

#else /* BACK_M */

#ifdef BIGEND
typedef union   {
		double_word all;
		struct  {
			half_word hw3;
			half_word hw2;
			half_word hw1;
			half_word hw0;
	        	} hwords;
		} IVT_ENTRY;
#endif

#ifdef LITTLEND
typedef union   {
		double_word all;
		struct  {
			half_word hw0;
			half_word hw1;
			half_word hw2;
			half_word hw3;
	        	} hwords;
		} IVT_ENTRY;
#endif
#endif /* BACK_M */

#if defined(NEC_98)

#ifndef RL_ROM

#define N_INT00_OFFSET  0x0936
#define N_INT01_OFFSET  0x0936
#define N_INT02_OFFSET  0x08f0
#define N_INT03_OFFSET  0x0936
#define N_INT04_OFFSET  0x0936
#define N_INT05_OFFSET  0x0936
#define N_INT06_OFFSET  0x0936
#define N_INT07_OFFSET  0x0936
#define N_INT08_OFFSET  0x0603
#define N_INT09_OFFSET  0x0E59
#define N_INT0A_OFFSET  0x0937
#define N_INT0B_OFFSET  0x0937
#define N_INT0C_OFFSET  0x1833
#define N_INT0D_OFFSET  0x0937
#define N_INT0E_OFFSET  0x0937
#define N_INT0F_OFFSET  0x0937
#define N_INT10_OFFSET  0x0937
#define N_INT11_OFFSET  0x0937
#define N_INT12_OFFSET  0x0937
#define N_INT13_OFFSET  0x0937
#define N_INT14_OFFSET  0x0937
#define N_INT15_OFFSET  0x0937
#define N_INT16_OFFSET  0x0937
#define N_INT17_OFFSET  0x0937
#define N_INT18_OFFSET  0x0ABD
#define N_INT19_OFFSET  0x1596
#define N_INT1A_OFFSET  0x0680
#define N_INT1B_OFFSET  0x1A82
#define N_INT1C_OFFSET  0x0500
#define N_INT1D_OFFSET  0x0936
#define N_INT1E_OFFSET  0x0000
#define N_INT1F_OFFSET  0x0200

#define H_INT00_OFFSET  0x01F3
#define H_INT01_OFFSET  0x01F3
#define H_INT02_OFFSET  0x0119
#define H_INT03_OFFSET  0x01F3
#define H_INT04_OFFSET  0x01F3
#define H_INT05_OFFSET  0x01F3
#define H_INT06_OFFSET  0x01F3
#define H_INT07_OFFSET  0x01F3
#define H_INT08_OFFSET  0x195b
#define H_INT09_OFFSET  0x08A8
#define H_INT0A_OFFSET  0x01F4
#define H_INT0B_OFFSET  0x01F4
#define H_INT0C_OFFSET  0x13F7
#define H_INT0D_OFFSET  0x01F4
#define H_INT0E_OFFSET  0x01F4
#define H_INT0F_OFFSET  0x01F4
#define H_INT10_OFFSET  0x2B05
#define H_INT11_OFFSET  0x01F4
#define H_INT12_OFFSET  0x01F4
#define H_INT13_OFFSET  0x01F4
#define H_INT14_OFFSET  0x01F4
#define H_INT15_OFFSET  0x01F4
#define H_INT16_OFFSET  0x01F4
#define H_INT17_OFFSET  0x01F4
#define H_INT18_OFFSET  0x0430
#define H_INT19_OFFSET  0x0D7A
#define H_INT1A_OFFSET  0x2AC0
#define H_INT1B_OFFSET  0x1B78
#define H_INT1C_OFFSET  0x1780
#define H_INT1D_OFFSET  0x0000
#define H_INT1E_OFFSET  0x01F3
#define H_INT1F_OFFSET  0x5DD0

#else

#define N_INT00_OFFSET  0x0936
#define N_INT01_OFFSET  0x0936
#define N_INT02_OFFSET  0x08F0
#define N_INT03_OFFSET  0x0936
#define N_INT04_OFFSET  0x0936
#define N_INT05_OFFSET  0x0936
#define N_INT06_OFFSET  0x0936
#define N_INT07_OFFSET  0x0936
#define N_INT08_OFFSET  0x064E
#define N_INT09_OFFSET  0x0E44
#define N_INT0A_OFFSET  0x0937
#define N_INT0B_OFFSET  0x0937
#define N_INT0C_OFFSET  0x183D
#define N_INT0D_OFFSET  0x0937
#define N_INT0E_OFFSET  0x0937
#define N_INT0F_OFFSET  0x0937
#define N_INT10_OFFSET  0x0936
#define N_INT11_OFFSET  0x0936
#define N_INT12_OFFSET  0x2369
#define N_INT13_OFFSET  0x22F7
#define N_INT14_OFFSET  0x0937
#define N_INT15_OFFSET  0x0937
#define N_INT16_OFFSET  0x0937
#define N_INT17_OFFSET  0x0937
#define N_INT18_OFFSET  0x0ABD
#define N_INT19_OFFSET  0x1596
#define N_INT1A_OFFSET  0x0680
#define N_INT1B_OFFSET  0x1A82
#define N_INT1C_OFFSET  0x0500
#define N_INT1D_OFFSET  0x0936
#define N_INT1E_OFFSET  0x0000
#define N_INT1F_OFFSET  0x0200

#define H_INT00_OFFSET  0x01BF
#define H_INT01_OFFSET  0x01BF
#define H_INT02_OFFSET  0x00E5
#define H_INT03_OFFSET  0x01BF
#define H_INT04_OFFSET  0x01BF
#define H_INT05_OFFSET  0x01BF
#define H_INT06_OFFSET  0x01BF
#define H_INT07_OFFSET  0x01BF
#define H_INT08_OFFSET  0x1876
#define H_INT09_OFFSET  0x07D8
#define H_INT0A_OFFSET  0x01C0
#define H_INT0B_OFFSET  0x01C0
#define H_INT0C_OFFSET  0x131E
#define H_INT0D_OFFSET  0x01C0
#define H_INT0E_OFFSET  0x01C0
#define H_INT0F_OFFSET  0x01C0
#define H_INT10_OFFSET  0x2755
#define H_INT11_OFFSET  0x0021
#define H_INT12_OFFSET  0x24FC
#define H_INT13_OFFSET  0x23E7
#define H_INT14_OFFSET  0x01C0
#define H_INT15_OFFSET  0x01C0
#define H_INT16_OFFSET  0x01C0
#define H_INT17_OFFSET  0x01C0
#define H_INT18_OFFSET  0x0360
#define H_INT19_OFFSET  0x0C80
#define H_INT1A_OFFSET  0x2710
#define H_INT1B_OFFSET  0x1A20
#define H_INT1C_OFFSET  0x1690
#define H_INT1D_OFFSET  0x0000
#define H_INT1E_OFFSET  0x01BF
#define H_INT1F_OFFSET  0x6400

#endif

#define N_BIOS_SEGMENT  0xFD80
#define BASIC_SEGMENT   0xE800
#define H_BIOS_SEGMENT  0xF800
#define H_GBIO_SEGMENT  0xF000

#define BIOS_MODE       0x0AC0
#define MACHINE_FLAG    0x0AB7
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\rtc_bios.h ===
/* @(#)rtc_bios.h	1.4 08/10/92 Copyright Insignia Solutions Ltd.

FILE NAME	: rtc_bios.h

	THIS INCLUDE SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS INC.

DESIGNER	: J.P.Box
DATE		: OCT '88


=========================================================================

AMMENDMENTS	:

=========================================================================
*/
#define	USER_FLAG		(BIOS_VAR_START + 0x98)
#define USER_FLAG_SEG		(BIOS_VAR_START + 0x9A)
#define RTC_LOW			(BIOS_VAR_START + 0x9C)
#define	RTC_HIGH		(BIOS_VAR_START + 0x9E)
#define RTC_WAIT_FLAG_ADDR	(BIOS_VAR_START + 0xA0)

#define rtc_wait_flag		RTC_WAIT_FLAG_ADDR

#define TIME_DEC		50000L		/* 1000000/20 assumes 20 interrupts/sec	*/

typedef	union	{
		double_word	total;
		struct	{ 
			word	high;
			word	low;
			}	half;
		} DOUBLE_TIME;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\smeg_hea.h ===
/*[
************************************************************************

        Name:           smeg_head.h
        Author:         W. Plummer
        Created:        May 1992
        Sccs ID:        @(#)smeg_head.h	1.4 08/10/92
        Purpose:        Stats Gathering for the SMEG utility

        (c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.

************************************************************************
]*/

#ifdef SMEG

/*
 * Smeg Variables....
 */

#define SMEG_IN_DELTA			0
#define SMEG_IN_VIDEO			1
#define SMEG_IN_IDLE			2
#define SMEG_IN_PM			3
#define SMEG_IN_DELTA_COMPILER		4
#define SMEG_IN_USER		5
#define SMEG_IN_GDI		6
#define SMEG_IN_KERNEL		7
#define SMEG_IN_OTHER		8
#define NR_OF_SAMPLE_TYPES		SMEG_IN_OTHER + 1

#define SMEG_NR_OF_THREADED_COMPS	9
#define SMEG_NR_OF_WRITECHECK_CALLS	10
#define SMEG_NR_OF_DESCR_COMPS		11
#define SMEG_NR_OF_REGN_INDEX_UPDS	12
#define SMEG_NR_OF_STACKCHECK_CALLS	13
#define SMEG_NR_OF_INTRPT_CHECKS_FAST	14
#define SMEG_NR_OF_INTRPT_CHECKS_SLOW	15
#define SMEG_NR_OF_FRAG_ENTRIES		16
#define SMEG_NR_OF_REGN_UPDS		17
#define SMEG_NR_OF_OVERWRITES		18
#define SMEG_NR_OF_CHECKOUTS		19
#define SMEG_NR_OF_STRINGWRITE_CALLS	20
#define SMEG_NR_OF_STRINGREAD_CALLS	21
#define SMEG_NR_OF_STRUCTCHECK_CALLS	22
#define SMEG_NR_OF_READCHECK_CALLS	23

#define SMEG_WIN_APIS			24



#define SMEG_START		(GG_FIRST+20)
#define SMEG_SAVE		(SMEG_START)
#define SMEG_BASE		((SMEG_SAVE)+2*sizeof(ULONG))

/*
 * Smeg Macros
 */

/* increment GDP variable */

#define SMEG_INC(smeg_id)						\
    {									\
	<*(Gdp + ^(SMEG_SAVE)) = X1>					\
	<X1 = *(Gdp + ^(SMEG_BASE + (smeg_id)*sizeof(ULONG)))>		\
	<nop_after_load>						\
	<X1 += 1>							\
	<*(Gdp + ^(SMEG_BASE + (smeg_id)*sizeof(ULONG))) = X1>		\
	<X1 = *(Gdp + ^(SMEG_SAVE))>					\
	<nop_after_load>						\
    }


/* set GDP variable non zero */

#define SMEG_SET(smeg_id)						\
    {									\
	<*(Gdp + ^(SMEG_BASE + (smeg_id)*sizeof(ULONG))) = Sp>		\
    }


/* set GDP variable to zero */

#define SMEG_CLEAR(smeg_id)						\
    {									\
	<*(Gdp + ^(SMEG_BASE + (smeg_id)*sizeof(ULONG))) = Zero>	\
    }


#else /* SMEG */

#define SMEG_INC(smeg_id)		/* SMEG_INC == NOP */
#define SMEG_SET(smeg_id)		/* SMEG_SET == NOP */
#define SMEG_CLEAR(smeg_id)		/* SMEG_CLEAR == NOP */

#endif /* SMEG */

#define SMEG_TRUE  1
#define SMEG_FALSE 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\spcfile.h ===
/*
	SccsID @(#)host_unix.h	1.1 10/2/90 Copyright Insignia Solutions Ltd
*/
#define STANDARD	1234
#define SILENT		2345
#define CONT_AND_QUIT	3456

extern char *host_find_file();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\smeg.h ===
/*			INSIGNIA MODULE SPECIFICATION
			-----------------------------


	THIS PROGRAM SOURCE FILE  IS  SUPPLIED IN CONFIDENCE TO THE
	CUSTOMER, THE CONTENTS  OR  DETAILS  OF  ITS OPERATION MUST
	NOT BE DISCLOSED TO ANY  OTHER PARTIES  WITHOUT THE EXPRESS
	AUTHORISATION FROM THE DIRECTORS OF INSIGNIA SOLUTIONS LTD.


DESIGNER		: Jeremy Maiden

REVISION HISTORY	:
First version		: May 1992


MODULE NAME		: smeg

SOURCE FILE NAME	: smeg.h

PURPOSE			: spy on cpus and things

SccsID			: @(#)smeg.h	1.5 08/10/92

*/

#include TypesH
#include SignalH
#include FCntlH
#include IpcH
#include ShmH
#include TimeH

#include <errno.h>

#define	SMEG_EOT	0
#define	SMEG_STRING	1
#define	SMEG_NUMBER	2
#define	SMEG_RATE	3
#define	SMEG_BOOL	4
#define	SMEG_ROBIN	5
#define	SMEG_PROFILE	6
#define	SMEG_DANGER	7


struct	SMEG_ITEM
{
	CHAR	name[32];
	ULONG	type;
	ULONG	colour;
	ULONG	sm_min, sm_max, sm_value, previous_sm_value;
};

#define	MAX_SMEG_ITEM	50

#define	BLACK	0
#define	RED	1
#define	GREEN	2
#define	YELLOW	3
#define	BLUE	4
#define	WHITE	5


#define	SHM_KEY	123456789

#define	COLLECT_DATA	0
#define	FREEZE_DATA		1

LOCAL	INT	shmid;		/* shared memory */
LOCAL	struct	SMEG_ITEM	*smegs;
LOCAL	ULONG	*pidptr;
LOCAL	ULONG	*cntrlptr;


/* sets up shared memory for communication with SoftPC in the same machine */
LOCAL	VOID	shm_init()

{
	/* if shared memory doesn't exist we'll have to invent it */
	shmid = shmget(SHM_KEY, MAX_SMEG_ITEM * sizeof(struct SMEG_ITEM), 0777);
	if (shmid  < 0)
	{
		shmid = shmget(SHM_KEY, MAX_SMEG_ITEM * sizeof(struct SMEG_ITEM), 0777 | IPC_CREAT);
		if (shmid < 0)
		{
			perror( "smeg" );
			printf("Can't create shared memory - exiting\n");
			exit(-1);
		}
	}
	pidptr = (ULONG *) shmat(shmid, NULL, 0);
	cntrlptr = pidptr + 1;
	smegs = (struct SMEG_ITEM *)( pidptr + 2 );
}


LOCAL	INT	shm_in_contact()

{
	struct	shmid_ds	desc;

	shmctl(shmid, IPC_STAT, &desc);
	return(desc.shm_nattch > 1);
}


LOCAL	VOID	shm_terminate()

{
	struct	shmid_ds	desc;

	shmdt(smegs);	/* detach from shared memory */
	shmctl(shmid, IPC_STAT, &desc);
	if (desc.shm_nattch == 0)	/* if we're the last, delete it */
		shmctl(shmid, IPC_RMID, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\sndblst.h ===
/***************************************************************************
*
*    nt_sb.h
*
*    Copyright (c) 1991-1996 Microsoft Corporation.  All Rights Reserved.
*
*    This code provides VDD support for SB 2.0 sound output, specifically:
*        DSP 2.01+ (excluding SB-MIDI port)
*        Mixer Chip CT1335 (not strictly part of SB 2.0, but apps seem to like it)
*        FM Chip OPL2 (a.k.a. Adlib)
*
***************************************************************************/

/*
*    Hardware and version information
*    In DOS terms: SET BLASTER=A220 I5 D1 T3
*/

#define SB_VERSION          0x201       // SB 2.0 (DSP 2.01+)
#define VSB_INTERRUPT       0x05        // Interrupt 5
#define VSB_DMA_CHANNEL     0x01        // DMA Channel 1
#define NO_DEVICE_FOUND     0xFFFF      // returned if no device found

/*****************************************************************************
*
*    Function Prototypes
*
*****************************************************************************/

extern USHORT SbDmaChannel;
extern USHORT SbInterrupt;

/*
*    General function prototypes
*/

BOOL
SbInitialize(
    VOID
    );

VOID
SbTerminate(
    VOID
    );

VOID
SbGetDMAPosition(
    VOID
    );

VOID
ResetAll(
    VOID
    );

/*****************************************************************************
*
*    #DSP related definitions
*
*****************************************************************************/

/*
*    DSP Ports
*/

#define RESET_PORT          0x06        // used to reset SoundBlaster
#define READ_STATUS         0x0E        // 0xFF-data to read, 0x7F-no data to read
#define READ_DATA           0x0A        // App reads data from this port
#define WRITE_STATUS        0x0C        // 0x7f-port ready, 0xFF-port not ready
#define WRITE_PORT          0x0C        // Data or command

/*
*    Only implemented commands are defined
*/

/*
*    DSP commands - miscellaneous
*/

#define DSP_GET_VERSION     0xE1    // dsp version command
#define DSP_CARD_IDENTIFY   0xE0    // byte inverter
#define DSP_TABLE_MUNGE     0xE2    // jump table munging
#define DSP_LOAD_RES_REG    0xE4    // load byte into reserved register
#define DSP_READ_RES_REG    0xE8    // read byte from reserved register
#define DSP_GENERATE_INT    0xF2    // generate an interrupt

/*
*    DSP commands - speaker
*/

#define DSP_SPEAKER_ON      0xD1    // speaker on command
#define DSP_SPEAKER_OFF     0xD3    // speaker off command

/*
*    DSP commands - DMA mode
*/

#define DSP_SET_SAMPLE_RATE 0x40    // set the sample rate (one byte format)
#define DSP_SET_BLOCK_SIZE  0x48    // set dma block size
#define DSP_PAUSE_DMA       0xD0    // pause dma
#define DSP_CONTINUE_DMA    0xD4    // continue dma
#define DSP_STOP_AUTO       0xDA    // Stop auto init dma

#define DSP_WRITE           0x14    // Start single cycle output (8-bit PCM mono)
#define DSP_WRITE_HS        0x91    // Start single cycle high-speed output (8-bit PCM mono)
#define DSP_WRITE_AUTO      0x1C    // Start auto init output (8-bit PCM mono)
#define DSP_WRITE_HS_AUTO   0x90    // Start auto init high=speed output (8-bit PCM mono)
#define DSP_READ            0x24    // Start single cycle input (not implemented)

//
// DSP commands - MIDI
//

#define MIDI_READ_POLL                          0x30
#define MIDI_READ_INTERRUPT                     0x31
#define MIDI_READ_TIMESTAMP_POLL        0x32
#define MIDI_READ_TIMESTAMP_INTERRUPT   0x33
#define MIDI_READ_POLL_WRITE_POLL_UART  0x34
#define MIDI_READ_INTERRUPT_WRITE_POLL_UART     0x35
#define MIDI_READ_TIMESTAMP_INTERRUPT_WRITE_POLL_UART   0x37
#define MIDI_WRITE_POLL                         0x38

#define MPU_RESET                               0xFF    // Enables & Sets MIDI to use both ports
#define MPU_PASSTHROUGH_MODE    0x3F    // Starts dumb mode; only active command is set path
#define MPU_GET_VERSION                 0xAC    // Returns version number after acknowledge
#define MPU_GET_REVISION                0xAD    // BUGBUG: Returns 0x09, for some unknown reason!
#define MPU_PORTS_AVAILABLE             0xAE    // Which ports are available? (bit0=port1, bit1=port2)
#define MPU_SET_MIDI_PATH               0xEB    // Sets which port(s) will be used
#define MPU_DUMB_WAVETABLE              0xF1    // Turns on wavetable synth for dumb mode
#define MPU_DUMB_EXTERNAL               0xF2    // Turns on external MIDI for dumb mode
#define MPU_DUMB_BOTH                   0xF3    // Turns on both wavetable synth and external MIDI

/*
*    Performance parameters for single and auto-init DMA fine tuning
*/
#define AUTO_BLOCK_SIZE     0x200   // size of each buffer in auto
#define DEFAULT_LOOKAHEAD   0x600   // target # of bytes to queue to kernel driver
#define MAX_WAVE_BYTES      0x3000  // maximum # of bytes to queue to kernel driver
#define SINGLE_PIECES       2       // number of pieces in each single write
#define SINGLE_SLEEP_ADJ    15      // number of overhead milliseconds in single
#define DSP_BUFFER_TOTAL_BURSTS (MAX_WAVE_BYTES / AUTO_BLOCK_SIZE)

/*****************************************************************************
*
*    #FM related definitions
*
*****************************************************************************/

/*
*    OPL2/Adlib Ports
*/

#define ADLIB_REGISTER_SELECT_PORT 0x388 // select the register to write data
#define ADLIB_STATUS_PORT          0x388 // read to determine opl2 status
#define ADLIB_DATA_PORT            0x389 // write data port

/*
*    FM information
*/

#define AD_MASK             0x04    // adlib register used to control opl2
#define AD_NEW              0x105   // used to determine if app entering opl3 mode
#define BATCH_SIZE          40      // how much data is batched to opl2

typedef struct {                    // structure written to fm device
    unsigned short IoPort;
    unsigned short PortData;
} SYNTH_DATA, *PSYNTH_DATA;

/*****************************************************************************
*
*    #Mixer related definitions
*
*****************************************************************************/

/*
*    Mixer Ports
*/

#define MIXER_ADDRESS       0x04        // Mixer address port
#define MIXER_DATA          0x05        // Mixer data port

/*
*    Mixer Commands
*/

#define MIXER_RESET         0x00    // reset mixer to initial state
#define MIXER_MASTER_VOLUME 0x02    // set master volume
#define MIXER_FM_VOLUME     0x06    // set opl2 volume
#define MIXER_CD_VOLUME     0x08    // set cd volume
#define MIXER_VOICE_VOLUME  0x0A    // set wave volume


//
// Midi ports
//

#define MPU401_DATA_PORT        0x330
#define ALT_MPU401_DATA_PORT    0x300
#define MPU401_COMMAND_PORT     0x331
#define ALT_MPU401_COMMAND_PORT 0x301

#define MPU_INTELLIGENT_MODE    0
#define MPU_UART_MODE           1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\standard.h ===
/*
*	MODULE:		standard.h
*
*	PURPOSE:	Some macros and forward declarations to make
*				life a bit easier.
*
*	AUTHOR:		Jason Proctor
*
*	DATE:		Fri Aug 11 1989
*/

/* SccsID[]="@(#)standard.h	1.4 08/10/92 Copyright Insignia Solutions Ltd."; */

#ifndef FILE
#include <stdio.h>
#endif

/* boolean stuff */
#define bool int		/* best way I have for declaring bools */
#define NOT		!

#ifndef TRUE
#define FALSE	0
#define TRUE	!0
#endif /* ! TRUE */

/* for system calls etc */
#undef SUCCESS
#undef FAILURE
#define SUCCESS	0
#define FAILURE	~SUCCESS

/* equivalence testing */
#define EQ		==
#define NE		!=
#define LT		<
#define GT		>
#define LTE		<=
#define GTE		>=

/* operators */
#define AND		&&
#define OR		||
#define XOR		^
#define MOD		%

/* hate single quotes! */
#define SPACE	' '
#define LF		'\n'
#define TAB		'\t'
#define Null	'\0'
#define SINGLEQ	'\''
#define DOUBLEQ	'"'
#define SHRIEK	'!'
#define DOLLAR	'$'
#define HYPHEN	'-'
#define USCORE	'_'
#define DECPOINT	'.'

/* for ease in deciphering ioctl-infested listings etc */
#define STDIN	0
#define STDOUT	1
#define STDERR	2

/* for readability only */
#define NOWORK
#define NOBREAK
#define TYPECAST

/* null pointer as a long */
#undef NULL
#define NULL	0L

/* to escape compiler warnings and lint errors etc */
#define CNULL	TYPECAST (char *) 0L
#define FNULL	TYPECAST (int (*) ()) 0L

/* some stuff to help out */
#define streq(x, y)	(strcmp (x, y) == 0)

/* standard stuff */
extern char *malloc ();
extern char *getenv ();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\suplib.h ===
/*[
 *	Name:		suplib.h
 *
 *	Derived from:	None
 *
 *	Author:		James Bowman
 *
 *	Created on:	17 Nov 93
 *
 *	Sccs ID:	@(#)suplib.h	1.5 08/19/94
 *
 *	Coding stds:	2.0
 *
 *	Purpose:	Declarations for functions in the sup library
 *
 *	Copyright Insignia Solutions Ltd., 1993.  All rights reserved.
]*/

#ifndef	_SUPLIB_H
#define _SUPLIB_H

/* Try to guess a PATHSEP_CHAR, if we don't already have one.
 * Use Mac or NT correct values, otherwise use UNIX '/'
 */

#ifndef PATHSEP_CHAR

#ifdef macintosh
#define	PATHSEP_CHAR 	':'
#endif

#ifdef NTVDM
#define PATHSEP_CHAR	'\\'
#endif

#ifndef PATHSEP_CHAR
#define PATHSEP_CHAR	'/'	/* default UNIX separator */
#endif

#endif /* PATHSEP_CHAR */

typedef char HOST_PATH;

/*
 * Path completion module
 */

GLOBAL HOST_PATH *Host_path_complete IPT3(
    HOST_PATH *, buf,		/* buffer for resulting pathname */ 
    HOST_PATH *, dirPath,		/* directory pathname */
    char *, fileName		/* file name to be appended */
);


/*
 * Generated File module
 */

typedef IBOOL (*DifferProc) IPT4(IUM32, where, IU8 *, oldData, IU8 *, newData, IUM32, size);

GLOBAL FILE *GenFile_fopen IPT4(
  char *, true_name,
  char *, mode,
  DifferProc, ignoreDifference,
  int, verbosity);
GLOBAL void GenFileAbortAllFiles IPT0();
GLOBAL void GenFileAbortFile IPT1(FILE *, file);
GLOBAL int  GenFile_fclose IPT1(FILE *, file);
GLOBAL int GenFile_fclose IPT1(FILE *, file);
#endif	/* _SUPLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\swinhelp.h ===
/*(
 * ============================================================================
 * 
 * 	Name:		swinhelp.h
 *
 * 	Author:		Anthony Shaughnessy
 *
 * 	Created on:	4th July 1994
 *
 * 	Sccs ID:	@(#)swinhelp.h	1.1 07/13/94
 *
 * 	Purpose:	Manifest constants to be used with context sensitive
 * 			help.  The numbers are the contexts, which are passed
 * 			to the context help system to give the relevant help.
 *			Designed to be used with HyperHelp from Bristol.
 *
 *	(c) Copyright Insignia Solutions Ltd., 1994.  All rights reserved.
 *
 * ============================================================================
)*/

/*[
 * ============================================================================
 *
 *	Numbers in here can be changed, but take care to avoid conflicts with
 *	other numbers defined in the project file.  Note that if any numbers
 *	are changed, both the SoftWindows executable and the HyperHelp (.hlp)
 *	file must be recompiled.
 *
 *	It is suggested that any additional values defined in your project
 *	file or another include file should be above 200 to avoid conflict.
 *
 * ============================================================================
]*/

/*[
 * ============================================================================
 *
 *	Contexts which we think may be called from scripts etc. which invoke
 *	the hyperhelp executable - may be passed on the command line:
 *
 *			hyperhelp helpfile.hlp -c 1
 *
 *	May also be called from within the executable.
 *
 * ============================================================================
]*/

#define HELP_MAIN	1		/* Contents page */
#define HELP_INSTALL	2		/* Installing SoftWindows */

/*[
 * ============================================================================
 *
 *	Contexts that are called from within our executable:
 *
 *		WinHelp(Display, helpfile, HELP_CONTEXT, HELP_DISPLAY);
 *
 * ============================================================================
]*/

#define HELP_DISPLAY	101		/* Display dialog */
#define HELP_OPEN	102		/* Open disk dialog */
#define HELP_NEW	103		/* New disk dialog */
#define HELP_PRINTER	104		/* Printer types dialog */
#define HELP_COM	105		/* Com ports dialog */
#define HELP_KEYBOARD	106		/* Keyboard map file dialog */
#define HELP_MEMORY	107		/* Memory dialog */
#define HELP_AUTOFLUSH	108		/* Autoflush dialog */
#define HELP_FILESELECT	109		/* Generic file selection box */
#define HELP_SOUND	110		/* Sound device dialog */
#define HELP_MENUS	111		/* Main menu bar */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\spc_icon.h ===
/*[
************************************************************************
	Name:			spc_icon.h	(Originally SoftPC_icon.h)
	Author/Designer:	SoftPC		Unknown
				SoftWindows	Bruce Anderson
	Sccs ID:		@(#)spc_icon.h	1.4 06/29/94

	(c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.

	Purpose:		SoftPC's default icon bitmap
************************************************************************
]*/
#ifdef SOFTWINDOWS
#define icon_mask_width 80
#define icon_mask_height 48
static unsigned char icon_mask_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38,
   0x00, 0xfc, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xe1, 0xff,
   0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xf8, 0xff, 0xef, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
   0xff, 0xe7, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xe7,
   0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
   0xff, 0xef, 0x7d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xe7,
   0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xe7, 0x79, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
   0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff,
   0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x1f, 0x7e, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x07, 0x78, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xf8, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xf8, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
   0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x7f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x7f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
   0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff,
   0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x7f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
#define spc_icon_width 80
#define spc_icon_height 48
static unsigned char spc_icon_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0xf8,
   0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x40, 0xfe, 0x1f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x74, 0xff, 0x3f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x40, 0x76, 0xc7, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x10, 0x12, 0xc3, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90,
   0x40, 0xc3, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x74, 0xc3,
   0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x76, 0xc3, 0x30, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x12, 0xf3, 0x33, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x90, 0x40, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xc0, 0x74, 0xc7, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
   0x76, 0xc3, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x12, 0xc3,
   0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x40, 0xc3, 0x30, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x74, 0xc3, 0x30, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x40, 0x76, 0xfb, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x10, 0x12, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90,
   0x40, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x74, 0x0f,
   0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x76, 0x03, 0x30, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xb0, 0x7d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50,
   0x25, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x2d, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x24, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x50, 0xa5, 0x31, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x50, 0xad, 0x4a, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
   0xb5, 0x4a, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0xa5, 0x31,
   0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

#else /* Not SOFTWINDOWS */
#define spc_icon_width 48
#define spc_icon_height 48
static unsigned char spc_icon_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00,
   0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x00,
   0x00, 0x00, 0xf8, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x1f, 0x00, 0x00,
   0x00, 0x00, 0xfe, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xff, 0x7f, 0x00, 0x00,
   0x00, 0x80, 0xff, 0xff, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0x01, 0x00,
   0x00, 0xe0, 0xff, 0xff, 0x03, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x07, 0x00,
   0x00, 0xf8, 0xff, 0xff, 0x0f, 0x00, 0x00, 0xfc, 0xff, 0xff, 0x1f, 0x00,
   0x00, 0xfe, 0xff, 0xff, 0x3f, 0x00, 0x00, 0xff, 0xff, 0xff, 0x7f, 0x00,
   0x80, 0xff, 0xff, 0xff, 0xff, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x01,
   0xe0, 0xff, 0xff, 0xff, 0x3f, 0x03, 0xf0, 0xff, 0xff, 0xff, 0xdf, 0x07,
   0xf8, 0xff, 0xff, 0xff, 0xdf, 0x0f, 0xfc, 0xff, 0xff, 0xff, 0xdf, 0x1f,
   0xfe, 0xff, 0xff, 0xff, 0xa3, 0x37, 0xfc, 0xff, 0xff, 0xff, 0x5d, 0x17,
   0xf8, 0xff, 0xff, 0xff, 0xd9, 0x08, 0xf0, 0xff, 0xff, 0xff, 0xc3, 0x07,
   0xe0, 0xff, 0xff, 0xff, 0xe7, 0x03, 0xc0, 0xff, 0xff, 0xff, 0xcf, 0x01,
   0x80, 0xff, 0xff, 0x5f, 0x9c, 0x00, 0x00, 0xff, 0xff, 0xef, 0x5c, 0x00,
   0x00, 0xfe, 0xff, 0x6f, 0x2d, 0x00, 0x00, 0xfc, 0xff, 0x1f, 0x13, 0x00,
   0x00, 0xf8, 0xff, 0x9f, 0x0f, 0x00, 0x00, 0xf0, 0xff, 0x5f, 0x05, 0x00,
   0x00, 0xe0, 0xff, 0xe3, 0x02, 0x00, 0x00, 0xc0, 0x9f, 0x5d, 0x01, 0x00,
   0x00, 0x80, 0xcf, 0xdd, 0x00, 0x00, 0x00, 0x00, 0xef, 0x5d, 0x00, 0x00,
   0x00, 0x00, 0x0e, 0x22, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x1c, 0x00, 0x00,
   0x00, 0x00, 0xf8, 0x0d, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x04, 0x00, 0x00,
   0x00, 0x00, 0x60, 0x02, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x00,
   0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
#endif /* SOFTWINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\tcpip.h ===
/*[
 *	Product:		SoftPC-AT Revision 3.0
 *	Name:			tcpip.h
 *	Derived From:	Original
 *	Author:			Jase
 *	Created On:		Jan 22 1993
 *	Sccs ID:		07/14/93 @(#)tcpip.h	1.3
 *	Purpose:		Defines & typedefs for the TCP/IP implementation.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.
 *
 *	Rcs ID:			
 *			$Source$
 *			$Revision$
 *			$Date$
 *			$Author$
 ]*/

/********************************************************/

/* DEFINES */

/* LAN Workplace function codes */
#define kTCPAccept					0x01
#define kTCPBind					0x02
#define kTCPClose					0x03
#define kTCPConnect					0x04
#define kTCPGetMyIPAddr				0x05
#define kTCPGetMyMacAddr			0x06
#define kTCPGetPeerName				0x07
#define kTCPGetSockName				0x08
#define kTCPGetSockOpt				0x09
#define kTCPGetSubnetMask			0x0a
#define kTCPIoctl					0x0b
#define kTCPListen					0x0c
#define kTCPSelect					0x0d
#define kTCPSetMyIPAddr				0x0e
#define kTCPSetSockOpt				0x0f
#define kTCPShutdown				0x10
#define kTCPSocket					0x11
#define kTCPRecv					0x12
#define kTCPRecvFrom				0x13
#define kTCPSend					0x14
#define kTCPSendTo					0x15
#define kTCPGetBootpVSA				0x16
#define kTCPGetSNMPInfo				0x17
#define kTCPGetPathInfo				0x18

/* LAN Workplace ioctl selectors */
#define	kIoctlFionRead				26239
#define	kIoctlFionBIO				26238
#define	kIoctlAtMark				29477
#define	kIoctlSetUrgHandler			3

/* LAN Workplace error numbers Unix doesn't have */
#define	EOK							0

/* LAN Workplace error numbers */
#define	kEOK			        	0
#define	kEBADF						9
#define	kEINVAL						22
#define	kEWOULDBLOCK				35
#define	kEINPROGRESS				36
#define	kEALREADY					37
#define	kENOTSOCK					38
#define	kEDESTADDRREQ				39
#define	kEMSGSIZE					40
#define	kEPROTOTYPE					41
#define	kENOPROTOOPT				42
#define	kEPROTONOSUPPORT			43
#define	kESOCKTNOSUPPORT			44
#define	kEOPNOTSUPP					45
#define	kEPFNOSUPPORT				46
#define	kEAFNOSUPPORT				47
#define	kEADDRINUSE					48
#define	kEADDRNOTAVAIL				49
#define	kENETDOWN					50
#define	kENETUNREACH				51
#define	kENETRESET					52
#define	kECONNABORTED				53
#define	kECONNRESET					54
#define	kENOBUFS					55
#define	kEISCONN					56
#define	kENOTCONN					57
#define	kESHUTDOWN					58
#define	kETOOMANYREFS				59
#define	kETIMEDOUT					60
#define	kECONNREFUSED				61
#define	kELOOP						62
#define	kENAMETOOLONG				63
#define	kEHOSTDOWN					64
#define	kEHOSTUNREACH				65
#define	kEASYNCNOTSUPP				67

/* items in error table */
#define	kErrorTableEntries \
	(sizeof (ErrorTable) / sizeof (ErrorTable [0]))

/* asynchronous request mask */
#define	kNoWaitMask					0x80

/* maximum packet size */
#define kInitialTCPBufferSize		1024

/* config keys */
#define	sScriptKey					"SCRIPT"
#define	sProfileKey					"PROFILE"
#define	sLWPCFGKey					"LWP_CFG"
#define	sTCPCFGKey					"TCP_CFG"
#define	sLANGCFGKey					"LANG_CFG"

/* default values for config keys */
#define	sDefaultScriptPath			"C:\\NET\\SCRIPT"
#define	sDefaultProfilePath			"C:\\NET\\PROFILE"
#define	sDefaultLWPCFGPath			"C:\\NET\\HSTACC"
#define	sDefaultTCPCFGPath			"C:\\NET\\TCP"
#define	sDefaultLANGCFGPath			"C:\\NET\\BIN"

/********************************************************/

/* TYPEDEFS */

typedef struct
{
	IBOOL			tcpInitialised;
	int				tcpBufSize;
	char			*tcpBuffer;

} TCPGlobalRec;

typedef struct
{
	IU8				hostError;
	IU8				lanwError;

}	ErrorConvRec;

/********************************************************/

/* PROTOTYPES */

/* GLOBAL */

/* TCP/IP entry points */
GLOBAL void			TCPInit IPT0 ();
GLOBAL void			TCPEntry IPT0 ();
GLOBAL void			TCPInterrupt IPT0 ();
GLOBAL void			TCPTick IPT0 ();
GLOBAL void			TCPEvent IPT0 ();

#ifndef	PROD
extern void			force_yoda IPT0 ();
#endif

/* host functions accessed */
extern void			host_raise_sigio_exception IPT0 ();

/********************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\tgdc.h ===
#if defined(NEC_98)
/* TEXT GDC include file */

/* TGDC port address     */
#define TGDC_READ_STATUS                        0x60
#define TGDC_WRITE_PARAMETER            0x60
#define TGDC_WRITE_COMMAND                      0x62
#define TGDC_READ_DATA                          0x62
#define TGDC_CRT_INTERRUPT                      0x64
#define TGDC_WRITE_MODE1                        0x68
#define TGDC_WRITE_BORDER                       0x6C

/* TGDC command number */
#define GDC_RESET0              0x00
#define GDC_RESET1              0x01
#define GDC_RESET2              0x09

#define GDC_SYNC0               0x0E
#define GDC_SYNC1               0x0F

#define GDC_START0              0x6B
#define GDC_START1              0x0D

#define GDC_STOP0               0x0c
#define GDC_STOP1               0x05

#define GDC_SCROLL              0x70

#define GDC_CSRFORM             0x4B

#define GDC_PITCH               0x47

#define GDC_VECTW               0x4C

#define GDC_CSRW                0x49

#define GDC_CSRR                0xE0

#define GDC_WRITE               0x20

#define GDC_READ                0xA0

/* TGDC structures */

typedef struct
{
                        unsigned char   command;
                        int                             count;
                        unsigned char   param[16];
} NOW_COMMAND;

typedef struct
{
                        unsigned char   border;
                        unsigned char   sync[8];
                        unsigned char   scroll[16];
                        unsigned char   pitch;
                        unsigned char   csrform[3];
                        BOOL                    startstop;
                        NOW_COMMAND             now;
} TGDC_GLOBS;

extern TGDC_GLOBS tgdcglobs;

typedef struct
{
        unsigned char   modeff_data[8];
        unsigned char   modeff2_data[7];
} MODEFF_GLOBS;

extern MODEFF_GLOBS modeffglobs;

IMPORT void text_gdc_init IPT0();
IMPORT void text_gdc_inb IPT2(io_addr, port, half_word *, value);
IMPORT void text_gdc_outb IPT2(io_addr, port, half_word *, value);
IMPORT void text_gdc_post IPT0();

IMPORT void VSYNC_beats IPT0();
#endif // NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\swinmgre.h ===
/*[
 *      Name:           swinmgrE.h
 *
 *      Derived From:   (original);
 *
 *      Author:         Antony Helliwell
 *
 *      Created On:     22 Apr 1993
 *
 *      Sccs ID:        @(#)swinmgrE.h	1.1 8/2/93
 *
 *      Purpose:        External Interface to SoftWindows CPU routines
 *
 *	Design document:
 *			-
 *
 *	Test document:
 *
 *      (c); Copyright Insignia Solutions Ltd., 1993. All rights reserved
]*/

/* Enable patching to pre-compiled Windows fragments */
GLOBAL VOID	ApiEnable IPT0();
/* Disable patching to pre-compiled Windows fragments */
GLOBAL VOID	ApiDisable IPT0();
/* Clear the table of recorded Windows segment information */
GLOBAL VOID	ApiResetWindowsSegment IPT0();
/* Register a Windows segment with the CPU. */
GLOBAL VOID	ApiRegisterWinSeg IPT2(ULONG, nominal_sel, ULONG, actual_sel);
/* Register a fixed Windows segment with the CPU. */
GLOBAL VOID	ApiRegisterFixedWinSeg IPT2(ULONG, actual_sel, ULONG, length);
/* Compile all fixed Windows segment descriptors */
GLOBAL VOID	ApiCompileFixedDesc IPT0();
/* Get the Windows segment selector for the given nominal selector */
GLOBAL ULONG	ApiGetRealSelFromNominalSel IPT1(ULONG, nominal_sel);
/* Get the Windows segment base ea32b for the given nominal selector */
GLOBAL IHP	ApiGetSegEa32FromNominalSel IPT1(ULONG, nominal_sel);
/* Get the Windows segment base ea24 for the given nominal selector */
GLOBAL ULONG	ApiGetSegBaseFromNominalSel IPT1(ULONG, nominal_sel);
/* Get the Windows descriptor base for the given nominal selector */
GLOBAL IHP	ApiGetDescBaseFromNominalSel IPT1(ULONG, nominal_sel);
/* Get the Windows segment base ea24 for the given actual selector */
GLOBAL ULONG	ApiSegmentBase IPT1(ULONG, actual_sel);
/* Get the Windows descriptor base for the given actual selector */
GLOBAL IHP	ApiDescriptorBase IPT1(ULONG, actual_sel);
/* Return the maximum number of fixed Windows segments supported */
GLOBAL ULONG	ApiFixedDescriptors IPT0();

GLOBAL VOID	ApiBindBinary IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\tape_io.h ===
/*
 * SoftPC Revision 2.0
 *
 * Title	: IBM PC Cassette IO BIOS declarations
 *
 * Description	: This module contains definitions that are used in
 *		  accessing the Cassette IO BIOS. In the AT BIOS, the
 *		  original Cassette IO functionality has been greatly
 *		  extended to provide support for multi-tasking systems.
 *
 * Author(s)	: Ross Beresford
 *
 * Notes	: For a detailed description of the XT and AT Cassette IO
 *		  BIOS functions, refer to the following manuals:
 *
 *		  - IBM PC/XT Technical Reference Manual
 *				(Section A-72 System BIOS)
 *		  - IBM PC/AT Technical Reference Manual
 *				(Section 5-164 BIOS1)
 */

/* SccsID[]="@(#)tape_io.h	1.3 08/10/92 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * Cassette I/O Functions
 */

#define	INT15_INVALID			0x86
#ifdef JAPAN
#define INT15_GET_BIOS_TYPE		0x49
#define INT15_KEYBOARD_INTERCEPT	0x4f
#define INT15_GETSET_FONT_IMAGE		0x50
#define INT15_EMS_MEMORY_SIZE		512
#endif // JAPAN

/*
 * Multi-tasking Extensions
 */

/* device open */
#define	INT15_DEVICE_OPEN		0x80

/* device close */
#define	INT15_DEVICE_CLOSE		0x81

/* program termination */
#define	INT15_PROGRAM_TERMINATION	0x82

/* event wait */
#define	INT15_EVENT_WAIT		0x83
#define	INT15_EVENT_WAIT_SET		0x00
#define	INT15_EVENT_WAIT_CANCEL		0x01

/* joystick support */
#define	INT15_JOYSTICK			0x84
#define	INT15_JOYSTICK_SWITCH		0x00
#define	INT15_JOYSTICK_RESISTIVE	0x01

/* system request key pressed */
#define	INT15_REQUEST_KEY		0x85
#define	INT15_REQUEST_KEY_MAKE		0x00
#define	INT15_REQUEST_KEY_BREAK		0x01

/* timed wait */
#define	INT15_WAIT			0x86

/* block move */
#define	INT15_MOVE_BLOCK		0x87

/* extended memory size determine */
#define	INT15_EMS_DETERMINE		0x88

/* processor to virtual mode */
#define	INT15_VIRTUAL_MODE		0x89

/* device busy loop and interrupt complete */
#define	INT15_DEVICE_BUSY		0x90
#define	INT15_INTERRUPT_COMPLETE	0x91
#define	INT15_DEVICE_DISK		0x00
#define	INT15_DEVICE_FLOPPY		0x01
#define	INT15_DEVICE_KEYBOARD		0x02
#define	INT15_DEVICE_NETWORK		0x80
#define	INT15_DEVICE_FLOPPY_MOTOR	0xfd
#define	INT15_DEVICE_PRINTER		0xfe

/* return configuration parameters pointer */
#define	INT15_CONFIGURATION		0xc0

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

/*
 *	void cassette_io()
 *	{
 *		This routine performs the Cassette I/O BIOS function. When
 *		an INT 15 occurs, the assembler BIOS calls this function to
 *		do the actual work involved using a BOP instruction.
 *
 *		As no Cassette device is implemented on SoftPC, the
 *		Cassette I/O functions just return with an appropriate error.
 *
 *		On the AT, INT 15 is used to provide multi-tasking support
 *		as an extension to the Cassette I/O functionality. Most
 *		of these functions are supported in the same way as in
 *		real AT BIOS.
 *	}
 */
extern	void cassette_io();

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\timeval.h ===
/*
 * SoftPC/SoftWindows
 *
 * Name:        : timeval.h
 *
 * Title        : Host Time structure definitions
 *
 * Sccs ID:     : @(#)timeval.h 1.5 04/20/94
 *
 * Description  : Definitions for users of host-specific time functions.
 *
 * Author       : David Rees
 *
 * Notes        : Make time structures available: host_timeval,
 *                host_timezone, host_tm.
 */

/* SccsID[]="@(#)timeval.h	1.5 04/20/94 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

struct host_timeval {
    IS32 tv_sec;
    IS32 tv_usec;
};



struct host_timezone {
    int tz_minuteswest;
    int tz_dsttime;
};

#ifndef NTVDM
struct host_tm {
	int     tm_sec;
	int     tm_min;
	int     tm_hour;
	int     tm_mday;
	int     tm_mon;
	int     tm_year;
	int     tm_wday;
	int     tm_yday;
	int     tm_isdst;
};
#endif


/*
 * External Declarations
 */

extern time_t host_time IPT1(time_t *, tloc);
extern struct host_tm *host_localtime IPT1(time_t *, clock);

#ifndef NTVDM
extern void host_gettimeofday IPT2(struct host_timeval *, time,
				   struct host_timezone *, zone);
#else
extern void host_GetSysTime(struct host_timeval *);
#define host_gettimeofday(timeval, timezn) host_GetSysTime((timeval))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\tmstrobe.h ===
/*
 * SoftPC-AT Revision 2.0
 *
 * Title	: time_strobe.h
 *
 * Description	: Interface specification for routines to be
 *		  called from the timeri tick. 
 *
 * Author(s)	: Leigh Dworkin
 *
 * Notes	: 
 */
 
/* SccsID[]="@(#)tmstrobe.h	1.3 08/10/92 Copyright Insignia Solutions Ltd."; */
/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

/*
 *	void time_strobe()
 *	{
 *		This function comprises all the base functions to
 *		be performed in the timer tick. Every PC tick (about 20Hz)
 *		this routine is called from the host in xxx_timer.c
 *	}
 */
extern	void time_strobe();

/*
 *	void callback(num_pc_ticks, routine)
 *	long num_pc_ticks;
 *	void (*routine)();
 *	{
 *		This function calls the routine when num_pc_ticks have
 *		elapsed.
 *	}
 */
extern	void callback();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\tredltr.h ===
typedef union  {
	struct node *nod;	/* node */
	CHAR *str;		/* string */
	CHAR *ide;		/* identifier */
	IBOOL boo;		/* boolean */
	IHPE lit;		/* literal */
} YYSTYPE;
extern YYSTYPE yylval;
# define c_case 257
# define c_endcase 258
# define c_fallthrough 259
# define c_default 260
# define c_else 261
# define c_endif 262
# define c_endswitch 263
# define c_if 264
# define c_then 265
# define c_switch 266
# define c_control 267
# define c_identifier 268
# define c_hook 269
# define c_trace 270
# define ADDR 271
# define ADDRESSOF 272
# define ALIGN 273
# define ARRAYBASE 274
# define ASM 275
# define ASSERT 276
# define BEGIN 277
# define CALL 278
# define COCALL 279
# define MACRO 280
# define CONTROL 281
# define DATA 282
# define DEPART 283
# define DO 284
# define ELSE 285
# define ELIPSIS 286
# define END 287
# define ENDIF 288
# define ENDWHILE 289
# define ENUM 290
# define EMBED 291
# define EXTERNAL 292
# define FP32 293
# define FP64 294
# define FP80 295
# define FPH 296
# define I_FALSE 297
# define GENERATOR 298
# define GETMEMBER 299
# define GOTO 300
# define GT_EQ 301
# define I_HBIT 302
# define IF 303
# define IN 304
# define INOUT 305
# define INCREMENT 306
# define INLINE 307
# define INVOKE 308
# define LABEL 309
# define LOC 310
# define I_BOOL 311
# define I_LS16 312
# define I_LS32 313
# define I_LS8 314
# define LT_EQ 315
# define MODULE 316
# define I_MS8 317
# define OP 318
# define OPERAND 319
# define OPERATOR 320
# define OUT 321
# define PRESERVE 322
# define RECORD 323
# define REF 324
# define RESTORE_STACK 325
# define RETURN 326
# define ROTATE_LEFT 327
# define ROTATE_RIGHT 328
# define SAVE_STACK 329
# define SECTION_LABEL 330
# define SHIFT_LEFT 331
# define SHIFT_RIGHT 332
# define SIZEOF 333
# define SUBROUTINE 334
# define COROUTINE 335
# define TABLE 336
# define THEN 337
# define I_TRUE 338
# define TYPE 339
# define TYPEOF 340
# define TYPESET 341
# define VAR 342
# define WHILE 343
# define REPEAT 344
# define CONSTANT 345
# define BOOLEAN 346
# define IDENTIFIER 347
# define STRING 348
# define CONFIGURATION 349
# define SAD 350
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\trace.h ===
#ifndef _TRACE_H
#define _TRACE_H
/*
 * VPC-XT Revision 2.0
 *
 * Title	: Trace module definitions
 *
 * Description	: Definitions for users of the trace module
 *
 * Author	: Henry Nash
 *
 * Notes	: None
 */

/* SccsID[]="@(#)trace.h	1.13 10/28/94 06/27/93 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/*
 * Trace codes 
 */

#define DUMP_NONE	0x00		/* Dump no data		*/
#define DUMP_REG	0x01		/* Dump the registers	*/
#define DUMP_CODE	0x02		/* Dump the last 16 words of code */
#define DUMP_SCREEN	0x04		/* Dump the screen buffer */
#define DUMP_FLAGS 	0x08		/* Dump the flags */
#define DUMP_INST  	0x10   	        /* Dump the next instruction */
#define DUMP_CSIP	0x20		/* Dump CS:IP to backtrace file */
#define DUMP_NPX        0x40            /* Dump NPX Registers */
#define LAST_DEST       0x80            /* dump out last destination addr DELTA */
#define DUMP_ALL	0xFF		/* Dump the lot		*/

/*
 * Verbose bit masks - set the following bits in the io_verbose
 * variable to produce the following trace outputs:
 */

#define GENERAL_VERBOSE 	0x01L	/* General I/O		*/
#define TIMER_VERBOSE 		0x02L	/* Print I/O for timers */
#define ICA_VERBOSE 		0x04L	/* Print I/O for Int Controller Adapt */
#define CGA_VERBOSE		0x08L	/* Print I/O for Colour graphics Adap */
#define FLA_VERBOSE		0x10L	/* Print I/O for Floppy disk Adaptor  */
#define HDA_VERBOSE		0x20L	/* Print I/O for Hard disk Adaptor    */
#define RS232_VERBOSE		0x40L	/* Print I/O for RS232 Adaptor        */
#define PRINTER_VERBOSE		0x80L	/* Print I/O for Printer Adaptor      */
#define PPI_VERBOSE		0x100L	/* Print I/O for PPI Adaptor          */
#define DMA_VERBOSE		0x200L	/* Print I/O for PPI Adaptor          */
#define GFI_VERBOSE		0x400L	/* Print I/O for GFI modules	      */
#define MOUSE_VERBOSE		0x800L	/* Print I/O for Mouse modules	      */
#define MDA_VERBOSE		0x1000L	/* Print I/O for Mono Display Adapter */
#define ICA_VERBOSE_LOCK	0x2000L	/* message for ica lock flag set */
#define DISKBIOS_VERBOSE 	0x4000L	/* Print disk bios messages 	*/
#define EGA_PORTS_VERBOSE	0x8000L	/* Print out EGA port accesses	*/
#define EGA_WRITE_VERBOSE	0x10000L /* Print out EGA write state	*/
#define EGA_READ_VERBOSE	0x20000L /* Print out EGA read state	*/
#define EGA_DISPLAY_VERBOSE	0x40000L /* Print out EGA display state	*/
#define EGA_ROUTINE_ENTRY	0x80000L /* Print out EGA routine trace	*/
#define EGA_VERY_VERBOSE	0xf8000L /* Print out all EGA stuff	*/
#define FLOPBIOS_VERBOSE	0x100000L /* Print floppy bios messages 	*/
#define AT_KBD_VERBOSE		0x200000L /* Print AT keyboard messages	*/
#define BIOS_KB_VERBOSE		0x400000L /* Print BIOS keyboard messages  */
#define CMOS_VERBOSE		0x800000L /* Cmos and real-time clock */
#define HUNTER_VERBOSE		0x1000000L /* Hunter verbosity */
#define PTY_VERBOSE		0x2000000L /* Print Pesudo-terminal messages */
#define GEN_DRVR_VERBOSE	0x4000000L /* Generic driver messages */
#ifdef HERC
#define HERC_VERBOSE		0x8000000L /* Hercules graphics board */
#endif
#define IPC_VERBOSE		0x10000000L /* Interproc communication debug */
#define LIM_VERBOSE		0x20000000L /* LIM messages */
#define HFX_VERBOSE		0x40000000L /* severity of HFX messages */
#define NET_VERBOSE		0x80000000L /* Print out LAN driver messages */

/* sub message types */

#define MAP_VERBOSE		0x1L	/* map messages */
#define CURSOR_VERBOSE		0x2L	/* cursor manipulation messages */
#define NHFX_VERBOSE		0x4L	/* subsid HFX messages */
#define CDROM_VERBOSE		0x8L	/* cdrom **VERY** verbose */
#define CGA_HOST_VERBOSE	0x10L	/* Get host CGA messages */
#define EGA_HOST_VERBOSE	0x20L	/* Get host EGA messages */
#define Q_EVENT_VERBOSE		0x40L   /* quick event manager messages */
#define WORM_VERBOSE		0x80L   /* Worm Drive messages */
#define WORM_VERY_VERBOSE	0x100L  /* Worm Verbose Drive messages */
#define HERC_HOST_VERBOSE	0x200L	/* Get host HERC messages */
#define GORE_VERBOSE		0x400L	/* Get GORE messages */
#define GORE_ERR_VERBOSE	0x800L	/* Get GORE error messages */
#define GLUE_VERBOSE		0x1000L	/* Get glue messages */
#define SAS_VERBOSE		0x2000L	/* Get sas messages */
#define IOS_VERBOSE		0x4000L	/* Get ios messages */
#define SCSI_VERBOSE		0x8000L	/* SCSI messages */
#define SWIN_VERBOSE		0x10000L	/* SoftWindows messages */
#define GISPSVGA_VERBOSE	0x20000L	/* GISP SVGA */
#define DPMI_VERBOSE		0x40000L	/* standalone DPMI host */
#define HWCPU_VERBOSE		0x80000L	/* H/W CPU */
#define	MSW_VERBOSE		0x100000L	/* windows driver */
#define	API_VERBOSE		0x200000L	/* pre-compiled apis */

/*
 * To get adapter independent tracings
 */

#define ALL_ADAPT_VERBOSE	HERC_HOST_VERBOSE | CGA_HOST_VERBOSE | EGA_HOST_VERBOSE

/*
 * Error strings
 */

#define ENOT_SUPPORTED	"BIOS function not supported in Rev 1.0"
#define EBAD_VIDEO_MODE "Video mode not supported in Rev 1.0"
#define EUNEXPECTED_INT "Unexpected interrupt occurred"

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

#ifdef ANSI
extern void trace(char *, int);
extern void trace_init(void);

#ifdef DELTA
extern void file_back_trace(char *);
extern void print_back_trace(void);
#endif /* DELTA */

#else
extern void trace();
extern void trace_init();

#ifdef DELTA
extern void file_back_trace();
extern void print_back_trace();
#endif /* DELTA */

#endif /* ANSI */
extern FILE *trace_file;

IMPORT IU32 sub_io_verbose;

#endif /* _TRACE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\timer.h ===
/*
 * SoftPC Revision 3.0
 *
 * Title	: Timer Adaptor definitions
 *
 * Description	: Definitions for users of the Timer Adaptor 
 *
 * Author	: Jerry Kramskoy
 *
 * Notes	: None
 *
 * Mods: (r3.2) : Export the variable timer_video_enabled, which is
 *                set in mda.c and cga.c when the bit in the mode
 *                register of the 6845 chip which controls whether
 *                the video display is on or off is flipped. (SCR 257).
 *
 *       (r3.3) : Remove definition of struct timeval and stuct timezone
 *                for SYSTEMV. Equivalent host_ structures are now declared
 *                in host_time.h.
 */
/* SccsID[]="@(#)timer.h	1.15 10/27/93 Copyright Insignia Solutions Ltd."; */
/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */
/*
 * Information about the PC timer itself
 */
#define TIMER_CLOCK_RATE        1193180L	/* Count rate of timer chip Hz */
#define TIMER_MICROSECS_PER_TICK (1000000.0 / TIMER_CLOCK_RATE)
#define MIN_COUNTER_VAL         65536L           /* This many ticks at TIMER_CLOCK_RATE = 18.2 ms */
#define PC_TICK_INTV		(MIN_COUNTER_VAL * (1000000.0 / TIMER_CLOCK_RATE))
#define TIMER_BIT_MASK 0x3e3
#define GATE_SIGNAL_LOW		0
#define GATE_SIGNAL_HIGH	1
#define GATE_SIGNAL_RISE	2

/*
 * Our internal structures
 */

typedef struct
{
	word nticks;
	unsigned long wrap;
} Timedelta;

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */

extern ULONG get_DOS_ticks IPT0(); /* get current DOS ticks */

extern void timer_init IPT0();
extern void timer_post IPT0();
extern void axe_ticks IPT1(int, ticks);
extern void SWTMR_init_funcptrs IPT0();
extern void SWTMR_inb IPT2(io_addr, port, half_word *, value);
extern void SWTMR_outb IPT2(io_addr, port, half_word, value);
extern void SWTMR_gate IPT2(io_addr, port, half_word, value);
extern void SWTMR_time_tick IPT0();
extern void host_release_timeslice IPT0();

#ifndef host_block_timer
extern void host_block_timer IPT0();
#endif /* host_block_timer */

#ifndef host_release_timer
extern void host_release_timer IPT0();
#endif /* host_release_timer */

extern void host_timer2_waveform IPT5(unsigned int, a, unsigned long, b,
	unsigned long, c, int, d, int, e);
#ifdef NTVDM
void HostPpiState(half_word);
#else
extern void host_enable_timer2_sound IPT0();
extern void host_disable_timer2_sound IPT0();
#endif
extern void host_ring_bell IPT1(long, a);
extern void host_alarm IPT1(long, a);
extern unsigned long host_idealAlarm IPT0();

extern IU32 host_speed IPT1( IU32, ControlMachineNumber );

extern void host_timer_init IPT0();
#ifdef SWIN_MOUSE_OPTS
extern void host_timer_setup IPT1(BOOL, fast_timer);
extern void generic_timer_setup IPT1(BOOL, fast_timer);
#else
extern void host_timer_setup IPT0();
extern void generic_timer_setup IPT0();
#endif /* SWIN_MOUSE_OPTS */
extern void host_timer_shutdown IPT0();
extern void host_timer_event IPT0();
extern void generic_timer_event IPT0();

#ifdef HUNTER
extern word timer_batch_count;
#endif /* HUNTER */

extern int timer_int_enabled;
extern boolean timer_video_enabled;

#define timer_inb(port,val)                     ((*timer_inb_func) (port,val))
#define timer_outb(port,val)                    ((*timer_outb_func) (port,val))
#define timer_gate(port,val)                    ((*timer_gate_func) (port,val))
#define time_tick()				((*timer_tick_func) ())


/*
 *  TIMER access functions needed for HW & SW
 */
extern void (*timer_inb_func) IPT2(io_addr, port, half_word *, value);
extern void (*timer_outb_func) IPT2(io_addr, port, half_word, value);
extern void (*timer_gate_func) IPT2(io_addr, port, half_word, value);
extern void (*timer_tick_func) IPT0();

#ifdef NTVDM
extern ULONG EoiIntsPending;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\timestmp.h ===
/*[
*************************************************************************

	Name:		timestmp.h
	Author:		Simon Frost
	Created:	May 1994
	Derived from:	Original
	Sccs ID:	@(#)timestmp.h	1.1 06/27/94
	Purpose:	Include file for timestamp data structures & functions

	(c)Copyright Insignia Solutions Ltd., 1994. All rights reserved.

Note: these timestamp functions are used by the quick event system to 
recalibrate the time convertion. Functionally, they may be the same as
those used for the profiling system, but are declared seperately as the
same mechanism may not be suitable for both uses.
*************************************************************************
]*/
/* main data structure for timestamp functions to manipulate */
typedef struct {
	IUH data[2];
} QTIMESTAMP, *QTIMESTAMP_PTR;

void host_q_timestamp_init IPT0();
IUH host_q_timestamp_diff IPT2(QTIMESTAMP_PTR, tbegin, QTIMESTAMP_PTR, tend);
void host_q_write_timestamp IPT1(QTIMESTAMP_PTR, stamp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\umb.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    UMB.H

Abstract:

    Header file for UMB management functions

Author:

    William Hsieh (williamh) Created 21-Sept-1992

[Environment:]



[Notes:]



Revision History:


--*/
#ifndef DWORD
#define DWORD	unsigned long
#endif
#ifndef WORD
#define WORD	unsigned short
#endif
#ifndef PVOID
#define PVOID	void *
#endif

#define     UMB_BASE_ADDRESS	0xC0000 // UMB base address
#define     UMB_MAX_OFFSET	0x40000 // UMB max. valid offset + 1

#define     UMB_PAGE_PROTECTION PAGE_EXECUTE_READWRITE

#define     HOST_PAGE_SIZE		0x1000	// 4KB
#define CONFIG_DATA_STRING L"Configuration Data"
#define KEY_VALUE_BUFFER_SIZE 2048


// We keep UMB in a list with each block has the following structure
typedef struct _UMBNODE {
    DWORD   Base;			// block base address(linear address)
    DWORD   Size;			// block size in bytes
    WORD    Owner;			// Misc flags
    DWORD   Mask;			// page mask, bit 0 -> first page
					// bit on -> page committed
    struct _UMBNODE *Next;		// pointer to next block
} UMBNODE, *PUMBNODE;

// A ROM block can't be owned by anybody, the address space is reserved
// no memory are committed. To own a ROM block, the caller has to
// include the ROM block first and then reserve the block
// A RAM block can only be owned by XMS. The address space is reserved
// and committed. UMBs allocated for XMS should be reserved and committed
// all the time.
// The address space for EMM block is NOT reserved.
#define     UMB_OWNER_NONE	0xFFFF	// nobody own the block
#define     UMB_OWNER_ROM	0xFFFE	// UMB is a ROM block
#define     UMB_OWNER_RAM	0xFFFD	// UMB is a RAM block
#define     UMB_OWNER_EMM	0xFFFC	// UMB owned by EMM
#define     UMB_OWNER_XMS	0xFFFB	// UMB owned by XMS
#define     UMB_OWNER_VDD	0xFFFA	// UMB owned by VDD

// Function prototype definitions
BOOL
VDDCommitUMB(
PVOID	Address,
DWORD	Size
);

BOOL
VDDDeCommitUMB(
PVOID	Address,
DWORD	Size
);

BOOL
ReserveUMB(
WORD Owner,
PVOID *Address,
DWORD *Size
);

BOOL
ReleaseUMB(
WORD  Owner,
PVOID Address,
DWORD Size
);

BOOL
GetUMBForEMM(VOID);

BOOL
InitUMBList(VOID);

PUMBNODE CreateNewUMBNode
(
DWORD	BaseAddress,
DWORD	Size,
WORD	Owner
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\unix_asy.h ===
/*[
 *      Name:		unix_async.h
 *
 *      Derived From:	DEC 3.0 host_async.h
 *
 *      Author:         Justin Koprowski
 *
 *      Created On:	19th February 1992
 *
 *      Sccs ID:        @(#)unix_async.h	1.5 03/14/94
 *
 *      Purpose:	Unix specific async definitions.
 *
 *      (c)Copyright Insignia Solutions Ltd., 1992. All rights reserved.
]*/

#define ASYNC_NOMEM		1
#define ASYNC_NBIO		2	
#define ASYNC_AIOOWN		3
#define ASYNC_AIOSTAT		4
#define ASYNC_BADHANDLE		5
#define ASYNC_NDELAY		6
#define ASYNC_BADHANDLER	7
#define ASYNC_BADOPN		8
#define ASYNC_FCNTL		9

#define ASYNC_XON		0
#define ASYNC_XOFF		1
#define ASYNC_IGNORE		2
#define ASYNC_RAW		3

#ifdef	ANSI
IMPORT  ULONG     addAsyncEventHandler(int fd,int (*eventhandler)(),VOID (*errhandler)(),int mode,CHAR *buf,int bufsiz,int opn,int *err);
IMPORT int     (*changeAsyncEventHandler(ULONG handle, int (*eventhandler)(), char *buf, int bufsiz, int opn, int *err)) ();
#else	/* ANSI */
IMPORT	ULONG 	addAsyncEventHandler();
IMPORT  int     (*changeAsyncEventHandler())();
#endif	/* ANSI */
IMPORT  VOID	initAsyncMgr IPT0();
IMPORT  int     AsyncOperationMode IPT3(ULONG, handle, int, opn, int *, err);
IMPORT  int     removeAsyncEventHandler IPT2(ULONG, handle, int *, err);
IMPORT  VOID    AsyncMgr IPT0();
IMPORT  VOID    terminateAsyncMgr IPT0();
extern	void	AsyncEventMgr IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\unix_loc.h ===
/*[
 * ============================================================================
 *
 *	Name:		unix_lock.h
 *
 *	Derived From:	lock.h(part)
 *
 *	Author:		Andrew Ogle
 *
 *	Created On:	18th Febuary 1993
 *
 *	Sccs ID:	@(#)unix_lock.h	1.1 02/22/93
 *
 *	Purpose:
 *
 *		Define procedures related to UNIX locking that are called
 *		from UNIX specific code in the base but where the code
 *		must be provided by the host.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1993. All rights reserved.
 *
 * ============================================================================
]*/

IMPORT int host_get_hostname_from_stat IPT4(struct stat *, filestat,
		CHAR *, hostname, CHAR *, pathname, int, fd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\unix_cnf.h ===
/*
 *	Name:		unix_cnf.h
 *	Derived From:	HP 3.0 hp_config.h (Philipa Watson)
 *	Author:		gvdl
 *	Created On:	09 March 1991
 *	Sccs ID:	@(#)unix_cnf.h	1.7 10/27/93
 *	Purpose:	Host side config defines
 *
 *	(c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
 */

/*
 * HOST defines for resource value option names. These are host specific and may
 * be changed or added to without base recompilation as long as the method used
 * below is adhered to.
 */

/* Host specific hostID #defines. */
#define C_LAST_OPTION   LAST_BASE_CONFIG_DEFINE+1

/************************************/
/* Defines for host specific things */
/************************************/

/* The name of the resource file for this host machine. */
#ifndef USER_HOME
#define USER_HOME	"HOME"
#endif /* USER_HOME */

#ifndef SYSTEM_HOME
#define SYSTEM_HOME	"SPCHOME"
#endif /* SYSTEM_HOME */

#ifdef HUNTER
#ifndef SYSTEM_CONFIG
#define SYSTEM_CONFIG	"$SPCHOME/trap.spcconfig"
#endif /* SYSTEM_CONFIG */
#else
#ifndef SYSTEM_CONFIG
#define SYSTEM_CONFIG	"$SPCHOME/sys.spcconfig"
#endif /*SYSTEM_CONFIG */
#endif /* HUNTER */

#ifndef USER_CONFIG
#define USER_CONFIG	"$HOME/.spcconfig"
#endif /* USER_CONFIG */

#ifdef HUNTER
IMPORT VOID
#ifdef ANSI
loadNlsString(CHAR **strP, USHORT catEntry);
#else /* ANSI */
loadNlsString();
#endif /* ANSI */
#endif /* HUNTER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\vga_dac.h ===
/* SccsID = @(#)vga_dac.h	1.4 08/10/92 */

/* this stuff isn't required for the Macintosh */
/* as we load the DACs in individually as required */

#ifndef	macintosh

byte vga_dac[0x300] = {
/* 00  */ 0x00, 0x00, 0x00, 
/* 01  */ 0x00, 0x00, 0x2a, 
/* 02  */ 0x00, 0x2a, 0x00, 
/* 03  */ 0x00, 0x2a, 0x2a, 
/* 04  */ 0x2a, 0x00, 0x00, 
/* 05  */ 0x2a, 0x00, 0x2a, 
/* 06  */ 0x2a, 0x2a, 0x00, 
/* 07  */ 0x2a, 0x2a, 0x2a, 
/* 08  */ 0x00, 0x00, 0x15, 
/* 09  */ 0x00, 0x00, 0x3f, 
/* 10  */ 0x00, 0x2a, 0x15, 
/* 11  */ 0x00, 0x2a, 0x3f, 
/* 12  */ 0x2a, 0x00, 0x15, 
/* 13  */ 0x2a, 0x00, 0x3f, 
/* 14  */ 0x2a, 0x2a, 0x15, 
/* 15  */ 0x2a, 0x2a, 0x3f, 
/* 16  */ 0x00, 0x15, 0x00, 
/* 17  */ 0x00, 0x15, 0x2a, 
/* 18  */ 0x00, 0x3f, 0x00, 
/* 19  */ 0x00, 0x3f, 0x2a, 
/* 20  */ 0x2a, 0x15, 0x00, 
/* 21  */ 0x2a, 0x15, 0x2a, 
/* 22  */ 0x2a, 0x3f, 0x00, 
/* 23  */ 0x2a, 0x3f, 0x2a, 
/* 24  */ 0x00, 0x15, 0x15, 
/* 25  */ 0x00, 0x15, 0x3f, 
/* 26  */ 0x00, 0x3f, 0x15, 
/* 27  */ 0x00, 0x3f, 0x3f, 
/* 28  */ 0x2a, 0x15, 0x15, 
/* 29  */ 0x2a, 0x15, 0x3f, 
/* 30  */ 0x2a, 0x3f, 0x15, 
/* 31  */ 0x2a, 0x3f, 0x3f, 
/* 32  */ 0x15, 0x00, 0x00, 
/* 33  */ 0x15, 0x00, 0x2a, 
/* 34  */ 0x15, 0x2a, 0x00, 
/* 35  */ 0x15, 0x2a, 0x2a, 
/* 36  */ 0x3f, 0x00, 0x00, 
/* 37  */ 0x3f, 0x00, 0x2a, 
/* 38  */ 0x3f, 0x2a, 0x00, 
/* 39  */ 0x3f, 0x2a, 0x2a, 
/* 40  */ 0x15, 0x00, 0x15, 
/* 41  */ 0x15, 0x00, 0x3f, 
/* 42  */ 0x15, 0x2a, 0x15, 
/* 43  */ 0x15, 0x2a, 0x3f, 
/* 44  */ 0x3f, 0x00, 0x15, 
/* 45  */ 0x3f, 0x00, 0x3f, 
/* 46  */ 0x3f, 0x2a, 0x15, 
/* 47  */ 0x3f, 0x2a, 0x3f, 
/* 48  */ 0x15, 0x15, 0x00, 
/* 49  */ 0x15, 0x15, 0x2a, 
/* 50  */ 0x15, 0x3f, 0x00, 
/* 51  */ 0x15, 0x3f, 0x2a, 
/* 52  */ 0x3f, 0x15, 0x00, 
/* 53  */ 0x3f, 0x15, 0x2a, 
/* 54  */ 0x3f, 0x3f, 0x00, 
/* 55  */ 0x3f, 0x3f, 0x2a, 
/* 56  */ 0x15, 0x15, 0x15, 
/* 57  */ 0x15, 0x15, 0x3f, 
/* 58  */ 0x15, 0x3f, 0x15, 
/* 59  */ 0x15, 0x3f, 0x3f, 
/* 60  */ 0x3f, 0x15, 0x15, 
/* 61  */ 0x3f, 0x15, 0x3f, 
/* 62  */ 0x3f, 0x3f, 0x15, 
/* 63  */ 0x3f, 0x3f, 0x3f, 
/* 64  */ 0x3f, 0x1f, 0x1f, 
/* 65  */ 0x3f, 0x27, 0x1f, 
/* 66  */ 0x3f, 0x2f, 0x1f, 
/* 67  */ 0x3f, 0x37, 0x1f, 
/* 68  */ 0x3f, 0x3f, 0x1f, 
/* 69  */ 0x37, 0x3f, 0x1f, 
/* 70  */ 0x2f, 0x3f, 0x1f, 
/* 71  */ 0x27, 0x3f, 0x1f, 
/* 72  */ 0x1f, 0x3f, 0x1f, 
/* 73  */ 0x1f, 0x3f, 0x27, 
/* 74  */ 0x1f, 0x3f, 0x2f, 
/* 75  */ 0x1f, 0x3f, 0x37, 
/* 76  */ 0x1f, 0x3f, 0x3f, 
/* 77  */ 0x1f, 0x37, 0x3f, 
/* 78  */ 0x1f, 0x2f, 0x3f, 
/* 79  */ 0x1f, 0x27, 0x3f, 
/* 80  */ 0x2d, 0x2d, 0x3f, 
/* 81  */ 0x31, 0x2d, 0x3f, 
/* 82  */ 0x36, 0x2d, 0x3f, 
/* 83  */ 0x3a, 0x2d, 0x3f, 
/* 84  */ 0x3f, 0x2d, 0x3f, 
/* 85  */ 0x3f, 0x2d, 0x3a, 
/* 86  */ 0x3f, 0x2d, 0x36, 
/* 87  */ 0x3f, 0x2d, 0x31, 
/* 88  */ 0x3f, 0x2d, 0x2d, 
/* 89  */ 0x3f, 0x31, 0x2d, 
/* 90  */ 0x3f, 0x36, 0x2d, 
/* 91  */ 0x3f, 0x3a, 0x2d, 
/* 92  */ 0x3f, 0x3f, 0x2d, 
/* 93  */ 0x3a, 0x3f, 0x2d, 
/* 94  */ 0x36, 0x3f, 0x2d, 
/* 95  */ 0x31, 0x3f, 0x2d, 
/* 96  */ 0x2d, 0x3f, 0x2d, 
/* 97  */ 0x2d, 0x3f, 0x31, 
/* 98  */ 0x2d, 0x3f, 0x36, 
/* 99  */ 0x2d, 0x3f, 0x3a, 
/* 100  */ 0x2d, 0x3f, 0x3f, 
/* 101  */ 0x2d, 0x3a, 0x3f, 
/* 102  */ 0x2d, 0x36, 0x3f, 
/* 103  */ 0x2d, 0x31, 0x3f, 
/* 104  */ 0x00, 0x00, 0x1c, 
/* 105  */ 0x07, 0x00, 0x1c, 
/* 106  */ 0x0e, 0x00, 0x1c, 
/* 107  */ 0x15, 0x00, 0x1c, 
/* 108  */ 0x1c, 0x00, 0x1c, 
/* 109  */ 0x1c, 0x00, 0x15, 
/* 110  */ 0x1c, 0x00, 0x0e, 
/* 111  */ 0x1c, 0x00, 0x07, 
/* 112  */ 0x1c, 0x00, 0x00, 
/* 113  */ 0x1c, 0x07, 0x00, 
/* 114  */ 0x1c, 0x0e, 0x00, 
/* 115  */ 0x1c, 0x15, 0x00, 
/* 116  */ 0x1c, 0x1c, 0x00, 
/* 117  */ 0x15, 0x1c, 0x00, 
/* 118  */ 0x0e, 0x1c, 0x00, 
/* 119  */ 0x07, 0x1c, 0x00, 
/* 120  */ 0x00, 0x1c, 0x00, 
/* 121  */ 0x00, 0x1c, 0x07, 
/* 122  */ 0x00, 0x1c, 0x0e, 
/* 123  */ 0x00, 0x1c, 0x15, 
/* 124  */ 0x00, 0x1c, 0x1c, 
/* 125  */ 0x00, 0x15, 0x1c, 
/* 126  */ 0x00, 0x0e, 0x1c, 
/* 127  */ 0x00, 0x07, 0x1c, 
/* 128  */ 0x0e, 0x0e, 0x1c, 
/* 129  */ 0x11, 0x0e, 0x1c, 
/* 130  */ 0x15, 0x0e, 0x1c, 
/* 131  */ 0x18, 0x0e, 0x1c, 
/* 132  */ 0x1c, 0x0e, 0x1c, 
/* 133  */ 0x1c, 0x0e, 0x18, 
/* 134  */ 0x1c, 0x0e, 0x15, 
/* 135  */ 0x1c, 0x0e, 0x11, 
/* 136  */ 0x1c, 0x0e, 0x0e, 
/* 137  */ 0x1c, 0x11, 0x0e, 
/* 138  */ 0x1c, 0x15, 0x0e, 
/* 139  */ 0x1c, 0x18, 0x0e, 
/* 140  */ 0x1c, 0x1c, 0x0e, 
/* 141  */ 0x18, 0x1c, 0x0e, 
/* 142  */ 0x15, 0x1c, 0x0e, 
/* 143  */ 0x11, 0x1c, 0x0e, 
/* 144  */ 0x0e, 0x1c, 0x0e, 
/* 145  */ 0x0e, 0x1c, 0x11, 
/* 146  */ 0x0e, 0x1c, 0x15, 
/* 147  */ 0x0e, 0x1c, 0x18, 
/* 148  */ 0x0e, 0x1c, 0x1c, 
/* 149  */ 0x0e, 0x18, 0x1c, 
/* 150  */ 0x0e, 0x15, 0x1c, 
/* 151  */ 0x0e, 0x11, 0x1c, 
/* 152  */ 0x14, 0x14, 0x1c, 
/* 153  */ 0x16, 0x14, 0x1c, 
/* 154  */ 0x18, 0x14, 0x1c, 
/* 155  */ 0x1a, 0x14, 0x1c, 
/* 156  */ 0x1c, 0x14, 0x1c, 
/* 157  */ 0x1c, 0x14, 0x1a, 
/* 158  */ 0x1c, 0x14, 0x18, 
/* 159  */ 0x1c, 0x14, 0x16, 
/* 160  */ 0x1c, 0x14, 0x14, 
/* 161  */ 0x1c, 0x16, 0x14, 
/* 162  */ 0x1c, 0x18, 0x14, 
/* 163  */ 0x1c, 0x1a, 0x14, 
/* 164  */ 0x1c, 0x1c, 0x14, 
/* 165  */ 0x1a, 0x1c, 0x14, 
/* 166  */ 0x18, 0x1c, 0x14, 
/* 167  */ 0x16, 0x1c, 0x14, 
/* 168  */ 0x14, 0x1c, 0x14, 
/* 169  */ 0x14, 0x1c, 0x16, 
/* 170  */ 0x14, 0x1c, 0x18, 
/* 171  */ 0x14, 0x1c, 0x1a, 
/* 172  */ 0x14, 0x1c, 0x1c, 
/* 173  */ 0x14, 0x1a, 0x1c, 
/* 174  */ 0x14, 0x18, 0x1c, 
/* 175  */ 0x14, 0x16, 0x1c, 
/* 176  */ 0x00, 0x00, 0x10, 
/* 177  */ 0x04, 0x00, 0x10, 
/* 178  */ 0x08, 0x00, 0x10, 
/* 179  */ 0x0c, 0x00, 0x10, 
/* 180  */ 0x10, 0x00, 0x10, 
/* 181  */ 0x10, 0x00, 0x0c, 
/* 182  */ 0x10, 0x00, 0x08, 
/* 183  */ 0x10, 0x00, 0x04, 
/* 184  */ 0x10, 0x00, 0x00, 
/* 185  */ 0x10, 0x04, 0x00, 
/* 186  */ 0x10, 0x08, 0x00, 
/* 187  */ 0x10, 0x0c, 0x00, 
/* 188  */ 0x10, 0x10, 0x00, 
/* 189  */ 0x0c, 0x10, 0x00, 
/* 190  */ 0x08, 0x10, 0x00, 
/* 191  */ 0x04, 0x10, 0x00, 
/* 192  */ 0x00, 0x10, 0x00, 
/* 193  */ 0x00, 0x10, 0x04, 
/* 194  */ 0x00, 0x10, 0x08, 
/* 195  */ 0x00, 0x10, 0x0c, 
/* 196  */ 0x00, 0x10, 0x10, 
/* 197  */ 0x00, 0x0c, 0x10, 
/* 198  */ 0x00, 0x08, 0x10, 
/* 199  */ 0x00, 0x04, 0x10, 
/* 200  */ 0x08, 0x08, 0x10, 
/* 201  */ 0x0a, 0x08, 0x10, 
/* 202  */ 0x0c, 0x08, 0x10, 
/* 203  */ 0x0e, 0x08, 0x10, 
/* 204  */ 0x10, 0x08, 0x10, 
/* 205  */ 0x10, 0x08, 0x0e, 
/* 206  */ 0x10, 0x08, 0x0c, 
/* 207  */ 0x10, 0x08, 0x0a, 
/* 208  */ 0x10, 0x08, 0x08, 
/* 209  */ 0x10, 0x0a, 0x08, 
/* 210  */ 0x10, 0x0c, 0x08, 
/* 211  */ 0x10, 0x0e, 0x08, 
/* 212  */ 0x10, 0x10, 0x08, 
/* 213  */ 0x0e, 0x10, 0x08, 
/* 214  */ 0x0c, 0x10, 0x08, 
/* 215  */ 0x0a, 0x10, 0x08, 
/* 216  */ 0x08, 0x10, 0x08, 
/* 217  */ 0x08, 0x10, 0x0a, 
/* 218  */ 0x08, 0x10, 0x0c, 
/* 219  */ 0x08, 0x10, 0x0e, 
/* 220  */ 0x08, 0x10, 0x10, 
/* 221  */ 0x08, 0x0e, 0x10, 
/* 222  */ 0x08, 0x0c, 0x10, 
/* 223  */ 0x08, 0x0a, 0x10, 
/* 224  */ 0x0b, 0x0b, 0x10, 
/* 225  */ 0x0c, 0x0b, 0x10, 
/* 226  */ 0x0d, 0x0b, 0x10, 
/* 227  */ 0x0f, 0x0b, 0x10, 
/* 228  */ 0x10, 0x0b, 0x10, 
/* 229  */ 0x10, 0x0b, 0x0f, 
/* 230  */ 0x10, 0x0b, 0x0d, 
/* 231  */ 0x10, 0x0b, 0x0c, 
/* 232  */ 0x10, 0x0b, 0x0b, 
/* 233  */ 0x10, 0x0c, 0x0b, 
/* 234  */ 0x10, 0x0d, 0x0b, 
/* 235  */ 0x10, 0x0f, 0x0b, 
/* 236  */ 0x10, 0x10, 0x0b, 
/* 237  */ 0x0f, 0x10, 0x0b, 
/* 238  */ 0x0d, 0x10, 0x0b, 
/* 239  */ 0x0c, 0x10, 0x0b, 
/* 240  */ 0x0b, 0x10, 0x0b, 
/* 241  */ 0x0b, 0x10, 0x0c, 
/* 242  */ 0x0b, 0x10, 0x0d, 
/* 243  */ 0x0b, 0x10, 0x0f, 
/* 244  */ 0x0b, 0x10, 0x10, 
/* 245  */ 0x0b, 0x0f, 0x10, 
/* 246  */ 0x0b, 0x0d, 0x10, 
/* 247  */ 0x0b, 0x0c, 0x10, 
/* 248  */ 0x00, 0x00, 0x00, 
/* 249  */ 0x00, 0x00, 0x00, 
/* 250  */ 0x00, 0x00, 0x00, 
/* 251  */ 0x00, 0x00, 0x00, 
/* 252  */ 0x00, 0x00, 0x00, 
/* 253  */ 0x00, 0x00, 0x00, 
/* 254  */ 0x00, 0x00, 0x00, 
/* 255  */ 0x00, 0x00, 0x00, 
};

byte vga_low_dac[0x300] = {
/* 00  */ 0x00, 0x00, 0x00, 
/* 01  */ 0x00, 0x00, 0x2a, 
/* 02  */ 0x00, 0x2a, 0x00, 
/* 03  */ 0x00, 0x2a, 0x2a, 
/* 04  */ 0x2a, 0x00, 0x00, 
/* 05  */ 0x2a, 0x00, 0x2a, 
/* 06  */ 0x2a, 0x15, 0x00, 
/* 07  */ 0x2a, 0x2a, 0x2a, 
/* 08  */ 0x00, 0x00, 0x00, 
/* 09  */ 0x00, 0x00, 0x2a, 
/* 10  */ 0x00, 0x2a, 0x00, 
/* 11  */ 0x00, 0x2a, 0x2a, 
/* 12  */ 0x2a, 0x00, 0x00, 
/* 13  */ 0x2a, 0x00, 0x2a, 
/* 14  */ 0x2a, 0x15, 0x00, 
/* 15  */ 0x2a, 0x2a, 0x2a, 
/* 16  */ 0x15, 0x15, 0x15, 
/* 17  */ 0x15, 0x15, 0x3f, 
/* 18  */ 0x15, 0x3f, 0x15, 
/* 19  */ 0x15, 0x3f, 0x3f, 
/* 20  */ 0x3f, 0x15, 0x15, 
/* 21  */ 0x3f, 0x15, 0x3f, 
/* 22  */ 0x3f, 0x3f, 0x15, 
/* 23  */ 0x3f, 0x3f, 0x3f, 
/* 24  */ 0x15, 0x15, 0x15, 
/* 25  */ 0x15, 0x15, 0x3f, 
/* 26  */ 0x15, 0x3f, 0x15, 
/* 27  */ 0x15, 0x3f, 0x3f, 
/* 28  */ 0x3f, 0x15, 0x15, 
/* 29  */ 0x3f, 0x15, 0x3f, 
/* 30  */ 0x3f, 0x3f, 0x15, 
/* 31  */ 0x3f, 0x3f, 0x3f, 
/* 32  */ 0x00, 0x00, 0x00, 
/* 33  */ 0x00, 0x00, 0x2a, 
/* 34  */ 0x00, 0x2a, 0x00, 
/* 35  */ 0x00, 0x2a, 0x2a, 
/* 36  */ 0x2a, 0x00, 0x00, 
/* 37  */ 0x2a, 0x00, 0x2a, 
/* 38  */ 0x2a, 0x15, 0x00, 
/* 39  */ 0x2a, 0x2a, 0x2a, 
/* 40  */ 0x00, 0x00, 0x00, 
/* 41  */ 0x00, 0x00, 0x2a, 
/* 42  */ 0x00, 0x2a, 0x00, 
/* 43  */ 0x00, 0x2a, 0x2a, 
/* 44  */ 0x2a, 0x00, 0x00, 
/* 45  */ 0x2a, 0x00, 0x2a, 
/* 46  */ 0x2a, 0x15, 0x00, 
/* 47  */ 0x2a, 0x2a, 0x2a, 
/* 48  */ 0x15, 0x15, 0x15, 
/* 49  */ 0x15, 0x15, 0x3f, 
/* 50  */ 0x15, 0x3f, 0x15, 
/* 51  */ 0x15, 0x3f, 0x3f, 
/* 52  */ 0x3f, 0x15, 0x15, 
/* 53  */ 0x3f, 0x15, 0x3f, 
/* 54  */ 0x3f, 0x3f, 0x15, 
/* 55  */ 0x3f, 0x3f, 0x3f, 
/* 56  */ 0x15, 0x15, 0x15, 
/* 57  */ 0x15, 0x15, 0x3f, 
/* 58  */ 0x15, 0x3f, 0x15, 
/* 59  */ 0x15, 0x3f, 0x3f, 
/* 60  */ 0x3f, 0x15, 0x15, 
/* 61  */ 0x3f, 0x15, 0x3f, 
/* 62  */ 0x3f, 0x3f, 0x15, 
/* 63  */ 0x3f, 0x3f, 0x3f, 
/* 64  */ 0x3f, 0x1f, 0x1f, 
/* 65  */ 0x3f, 0x27, 0x1f, 
/* 66  */ 0x3f, 0x2f, 0x1f, 
/* 67  */ 0x3f, 0x37, 0x1f, 
/* 68  */ 0x3f, 0x3f, 0x1f, 
/* 69  */ 0x37, 0x3f, 0x1f, 
/* 70  */ 0x2f, 0x3f, 0x1f, 
/* 71  */ 0x27, 0x3f, 0x1f, 
/* 72  */ 0x1f, 0x3f, 0x1f, 
/* 73  */ 0x1f, 0x3f, 0x27, 
/* 74  */ 0x1f, 0x3f, 0x2f, 
/* 75  */ 0x1f, 0x3f, 0x37, 
/* 76  */ 0x1f, 0x3f, 0x3f, 
/* 77  */ 0x1f, 0x37, 0x3f, 
/* 78  */ 0x1f, 0x2f, 0x3f, 
/* 79  */ 0x1f, 0x27, 0x3f, 
/* 80  */ 0x2d, 0x2d, 0x3f, 
/* 81  */ 0x31, 0x2d, 0x3f, 
/* 82  */ 0x36, 0x2d, 0x3f, 
/* 83  */ 0x3a, 0x2d, 0x3f, 
/* 84  */ 0x3f, 0x2d, 0x3f, 
/* 85  */ 0x3f, 0x2d, 0x3a, 
/* 86  */ 0x3f, 0x2d, 0x36, 
/* 87  */ 0x3f, 0x2d, 0x31, 
/* 88  */ 0x3f, 0x2d, 0x2d, 
/* 89  */ 0x3f, 0x31, 0x2d, 
/* 90  */ 0x3f, 0x36, 0x2d, 
/* 91  */ 0x3f, 0x3a, 0x2d, 
/* 92  */ 0x3f, 0x3f, 0x2d, 
/* 93  */ 0x3a, 0x3f, 0x2d, 
/* 94  */ 0x36, 0x3f, 0x2d, 
/* 95  */ 0x31, 0x3f, 0x2d, 
/* 96  */ 0x2d, 0x3f, 0x2d, 
/* 97  */ 0x2d, 0x3f, 0x31, 
/* 98  */ 0x2d, 0x3f, 0x36, 
/* 99  */ 0x2d, 0x3f, 0x3a, 
/* 100  */ 0x2d, 0x3f, 0x3f, 
/* 101  */ 0x2d, 0x3a, 0x3f, 
/* 102  */ 0x2d, 0x36, 0x3f, 
/* 103  */ 0x2d, 0x31, 0x3f, 
/* 104  */ 0x00, 0x00, 0x1c, 
/* 105  */ 0x07, 0x00, 0x1c, 
/* 106  */ 0x0e, 0x00, 0x1c, 
/* 107  */ 0x15, 0x00, 0x1c, 
/* 108  */ 0x1c, 0x00, 0x1c, 
/* 109  */ 0x1c, 0x00, 0x15, 
/* 110  */ 0x1c, 0x00, 0x0e, 
/* 111  */ 0x1c, 0x00, 0x07, 
/* 112  */ 0x1c, 0x00, 0x00, 
/* 113  */ 0x1c, 0x07, 0x00, 
/* 114  */ 0x1c, 0x0e, 0x00, 
/* 115  */ 0x1c, 0x15, 0x00, 
/* 116  */ 0x1c, 0x1c, 0x00, 
/* 117  */ 0x15, 0x1c, 0x00, 
/* 118  */ 0x0e, 0x1c, 0x00, 
/* 119  */ 0x07, 0x1c, 0x00, 
/* 120  */ 0x00, 0x1c, 0x00, 
/* 121  */ 0x00, 0x1c, 0x07, 
/* 122  */ 0x00, 0x1c, 0x0e, 
/* 123  */ 0x00, 0x1c, 0x15, 
/* 124  */ 0x00, 0x1c, 0x1c, 
/* 125  */ 0x00, 0x15, 0x1c, 
/* 126  */ 0x00, 0x0e, 0x1c, 
/* 127  */ 0x00, 0x07, 0x1c, 
/* 128  */ 0x0e, 0x0e, 0x1c, 
/* 129  */ 0x11, 0x0e, 0x1c, 
/* 130  */ 0x15, 0x0e, 0x1c, 
/* 131  */ 0x18, 0x0e, 0x1c, 
/* 132  */ 0x1c, 0x0e, 0x1c, 
/* 133  */ 0x1c, 0x0e, 0x18, 
/* 134  */ 0x1c, 0x0e, 0x15, 
/* 135  */ 0x1c, 0x0e, 0x11, 
/* 136  */ 0x1c, 0x0e, 0x0e, 
/* 137  */ 0x1c, 0x11, 0x0e, 
/* 138  */ 0x1c, 0x15, 0x0e, 
/* 139  */ 0x1c, 0x18, 0x0e, 
/* 140  */ 0x1c, 0x1c, 0x0e, 
/* 141  */ 0x18, 0x1c, 0x0e, 
/* 142  */ 0x15, 0x1c, 0x0e, 
/* 143  */ 0x11, 0x1c, 0x0e, 
/* 144  */ 0x0e, 0x1c, 0x0e, 
/* 145  */ 0x0e, 0x1c, 0x11, 
/* 146  */ 0x0e, 0x1c, 0x15, 
/* 147  */ 0x0e, 0x1c, 0x18, 
/* 148  */ 0x0e, 0x1c, 0x1c, 
/* 149  */ 0x0e, 0x18, 0x1c, 
/* 150  */ 0x0e, 0x15, 0x1c, 
/* 151  */ 0x0e, 0x11, 0x1c, 
/* 152  */ 0x14, 0x14, 0x1c, 
/* 153  */ 0x16, 0x14, 0x1c, 
/* 154  */ 0x18, 0x14, 0x1c, 
/* 155  */ 0x1a, 0x14, 0x1c, 
/* 156  */ 0x1c, 0x14, 0x1c, 
/* 157  */ 0x1c, 0x14, 0x1a, 
/* 158  */ 0x1c, 0x14, 0x18, 
/* 159  */ 0x1c, 0x14, 0x16, 
/* 160  */ 0x1c, 0x14, 0x14, 
/* 161  */ 0x1c, 0x16, 0x14, 
/* 162  */ 0x1c, 0x18, 0x14, 
/* 163  */ 0x1c, 0x1a, 0x14, 
/* 164  */ 0x1c, 0x1c, 0x14, 
/* 165  */ 0x1a, 0x1c, 0x14, 
/* 166  */ 0x18, 0x1c, 0x14, 
/* 167  */ 0x16, 0x1c, 0x14, 
/* 168  */ 0x14, 0x1c, 0x14, 
/* 169  */ 0x14, 0x1c, 0x16, 
/* 170  */ 0x14, 0x1c, 0x18, 
/* 171  */ 0x14, 0x1c, 0x1a, 
/* 172  */ 0x14, 0x1c, 0x1c, 
/* 173  */ 0x14, 0x1a, 0x1c, 
/* 174  */ 0x14, 0x18, 0x1c, 
/* 175  */ 0x14, 0x16, 0x1c, 
/* 176  */ 0x00, 0x00, 0x10, 
/* 177  */ 0x04, 0x00, 0x10, 
/* 178  */ 0x08, 0x00, 0x10, 
/* 179  */ 0x0c, 0x00, 0x10, 
/* 180  */ 0x10, 0x00, 0x10, 
/* 181  */ 0x10, 0x00, 0x0c, 
/* 182  */ 0x10, 0x00, 0x08, 
/* 183  */ 0x10, 0x00, 0x04, 
/* 184  */ 0x10, 0x00, 0x00, 
/* 185  */ 0x10, 0x04, 0x00, 
/* 186  */ 0x10, 0x08, 0x00, 
/* 187  */ 0x10, 0x0c, 0x00, 
/* 188  */ 0x10, 0x10, 0x00, 
/* 189  */ 0x0c, 0x10, 0x00, 
/* 190  */ 0x08, 0x10, 0x00, 
/* 191  */ 0x04, 0x10, 0x00, 
/* 192  */ 0x00, 0x10, 0x00, 
/* 193  */ 0x00, 0x10, 0x04, 
/* 194  */ 0x00, 0x10, 0x08, 
/* 195  */ 0x00, 0x10, 0x0c, 
/* 196  */ 0x00, 0x10, 0x10, 
/* 197  */ 0x00, 0x0c, 0x10, 
/* 198  */ 0x00, 0x08, 0x10, 
/* 199  */ 0x00, 0x04, 0x10, 
/* 200  */ 0x08, 0x08, 0x10, 
/* 201  */ 0x0a, 0x08, 0x10, 
/* 202  */ 0x0c, 0x08, 0x10, 
/* 203  */ 0x0e, 0x08, 0x10, 
/* 204  */ 0x10, 0x08, 0x10, 
/* 205  */ 0x10, 0x08, 0x0e, 
/* 206  */ 0x10, 0x08, 0x0c, 
/* 207  */ 0x10, 0x08, 0x0a, 
/* 208  */ 0x10, 0x08, 0x08, 
/* 209  */ 0x10, 0x0a, 0x08, 
/* 210  */ 0x10, 0x0c, 0x08, 
/* 211  */ 0x10, 0x0e, 0x08, 
/* 212  */ 0x10, 0x10, 0x08, 
/* 213  */ 0x0e, 0x10, 0x08, 
/* 214  */ 0x0c, 0x10, 0x08, 
/* 215  */ 0x0a, 0x10, 0x08, 
/* 216  */ 0x08, 0x10, 0x08, 
/* 217  */ 0x08, 0x10, 0x0a, 
/* 218  */ 0x08, 0x10, 0x0c, 
/* 219  */ 0x08, 0x10, 0x0e, 
/* 220  */ 0x08, 0x10, 0x10, 
/* 221  */ 0x08, 0x0e, 0x10, 
/* 222  */ 0x08, 0x0c, 0x10, 
/* 223  */ 0x08, 0x0a, 0x10, 
/* 224  */ 0x0b, 0x0b, 0x10, 
/* 225  */ 0x0c, 0x0b, 0x10, 
/* 226  */ 0x0d, 0x0b, 0x10, 
/* 227  */ 0x0f, 0x0b, 0x10, 
/* 228  */ 0x10, 0x0b, 0x10, 
/* 229  */ 0x10, 0x0b, 0x0f, 
/* 230  */ 0x10, 0x0b, 0x0d, 
/* 231  */ 0x10, 0x0b, 0x0c, 
/* 232  */ 0x10, 0x0b, 0x0b, 
/* 233  */ 0x10, 0x0c, 0x0b, 
/* 234  */ 0x10, 0x0d, 0x0b, 
/* 235  */ 0x10, 0x0f, 0x0b, 
/* 236  */ 0x10, 0x10, 0x0b, 
/* 237  */ 0x0f, 0x10, 0x0b, 
/* 238  */ 0x0d, 0x10, 0x0b, 
/* 239  */ 0x0c, 0x10, 0x0b, 
/* 240  */ 0x0b, 0x10, 0x0b, 
/* 241  */ 0x0b, 0x10, 0x0c, 
/* 242  */ 0x0b, 0x10, 0x0d, 
/* 243  */ 0x0b, 0x10, 0x0f, 
/* 244  */ 0x0b, 0x10, 0x10, 
/* 245  */ 0x0b, 0x0f, 0x10, 
/* 246  */ 0x0b, 0x0d, 0x10, 
/* 247  */ 0x0b, 0x0c, 0x10, 
/* 248  */ 0x00, 0x00, 0x00, 
/* 249  */ 0x00, 0x00, 0x00, 
/* 250  */ 0x00, 0x00, 0x00, 
/* 251  */ 0x00, 0x00, 0x00, 
/* 252  */ 0x00, 0x00, 0x00, 
/* 253  */ 0x00, 0x00, 0x00, 
/* 254  */ 0x00, 0x00, 0x00, 
/* 255  */ 0x00, 0x00, 0x00, 
};

byte vga_256_dac[0x300] =
{
/* 00 */ 0x00,0x00,0x00,
/* 01 */ 0x00,0x00,0x2a,
/* 02 */ 0x00,0x2a,0x00,
/* 03 */ 0x00,0x2a,0x2a,
/* 04 */ 0x2a,0x00,0x00,
/* 05 */ 0x2a,0x00,0x2a,
/* 06 */ 0x2a,0x15,0x00,
/* 07 */ 0x2a,0x2a,0x2a,
/* 08 */ 0x15,0x15,0x15,
/* 09 */ 0x15,0x15,0x3f,
/* 10 */ 0x15,0x3f,0x15,
/* 11 */ 0x15,0x3f,0x3f,
/* 12 */ 0x3f,0x15,0x15,
/* 13 */ 0x3f,0x15,0x3f,
/* 14 */ 0x3f,0x3f,0x15,
/* 15 */ 0x3f,0x3f,0x3f,
/* 16 */ 0x00,0x00,0x00,
/* 17 */ 0x05,0x05,0x05,
/* 18 */ 0x08,0x08,0x08,
/* 19 */ 0x0b,0x0b,0x0b,
/* 20 */ 0x0e,0x0e,0x0e,
/* 21 */ 0x11,0x11,0x11,
/* 22 */ 0x14,0x14,0x14,
/* 23 */ 0x18,0x18,0x18,
/* 24 */ 0x1c,0x1c,0x1c,
/* 25 */ 0x20,0x20,0x20,
/* 26 */ 0x24,0x24,0x24,
/* 27 */ 0x28,0x28,0x28,
/* 28 */ 0x2d,0x2d,0x2d,
/* 29 */ 0x32,0x32,0x32,
/* 30 */ 0x38,0x38,0x38,
/* 31 */ 0x3f,0x3f,0x3f,
/* 32 */ 0x00,0x00,0x3f,
/* 33 */ 0x10,0x00,0x3f,
/* 34 */ 0x1f,0x00,0x3f,
/* 35 */ 0x2f,0x00,0x3f,
/* 36 */ 0x3f,0x00,0x3f,
/* 37 */ 0x3f,0x00,0x2f,
/* 38 */ 0x3f,0x00,0x1f,
/* 39 */ 0x3f,0x00,0x10,
/* 40 */ 0x3f,0x00,0x00,
/* 41 */ 0x3f,0x10,0x00,
/* 42 */ 0x3f,0x1f,0x00,
/* 43 */ 0x3f,0x2f,0x00,
/* 44 */ 0x3f,0x3f,0x00,
/* 45 */ 0x2f,0x3f,0x00,
/* 46 */ 0x1f,0x3f,0x00,
/* 47 */ 0x10,0x3f,0x00,
/* 48 */ 0x00,0x3f,0x00,
/* 49 */ 0x00,0x3f,0x10,
/* 50 */ 0x00,0x3f,0x1f,
/* 51 */ 0x00,0x3f,0x2f,
/* 52 */ 0x00,0x3f,0x3f,
/* 53 */ 0x00,0x2f,0x3f,
/* 54 */ 0x00,0x1f,0x3f,
/* 55 */ 0x00,0x10,0x3f,
/* 56 */ 0x1f,0x1f,0x3f,
/* 57 */ 0x27,0x1f,0x3f,
/* 58 */ 0x2f,0x1f,0x3f,
/* 59 */ 0x37,0x1f,0x3f,
/* 60 */ 0x3f,0x1f,0x3f,
/* 61 */ 0x3f,0x1f,0x37,
/* 62 */ 0x3f,0x1f,0x2f,
/* 63 */ 0x3f,0x1f,0x27,
/* 64 */ 0x3f,0x1f,0x1f,
/* 65 */ 0x3f,0x27,0x1f,
/* 66 */ 0x3f,0x2f,0x1f,
/* 67 */ 0x3f,0x37,0x1f,
/* 68 */ 0x3f,0x3f,0x1f,
/* 69 */ 0x37,0x3f,0x1f,
/* 70 */ 0x2f,0x3f,0x1f,
/* 71 */ 0x27,0x3f,0x1f,
/* 72 */ 0x1f,0x3f,0x1f,
/* 73 */ 0x1f,0x3f,0x27,
/* 74 */ 0x1f,0x3f,0x2f,
/* 75 */ 0x1f,0x3f,0x37,
/* 76 */ 0x1f,0x3f,0x3f,
/* 77 */ 0x1f,0x37,0x3f,
/* 78 */ 0x1f,0x2f,0x3f,
/* 79 */ 0x1f,0x27,0x3f,
/* 80 */ 0x2d,0x2d,0x3f,
/* 81 */ 0x31,0x2d,0x3f,
/* 82 */ 0x36,0x2d,0x3f,
/* 83 */ 0x3a,0x2d,0x3f,
/* 84 */ 0x3f,0x2d,0x3f,
/* 85 */ 0x3f,0x2d,0x3a,
/* 86 */ 0x3f,0x2d,0x36,
/* 87 */ 0x3f,0x2d,0x31,
/* 88 */ 0x3f,0x2d,0x2d,
/* 89 */ 0x3f,0x31,0x2d,
/* 90 */ 0x3f,0x36,0x2d,
/* 91 */ 0x3f,0x3a,0x2d,
/* 92 */ 0x3f,0x3f,0x2d,
/* 93 */ 0x3a,0x3f,0x2d,
/* 94 */ 0x36,0x3f,0x2d,
/* 95 */ 0x31,0x3f,0x2d,
/* 96 */ 0x2d,0x3f,0x2d,
/* 97 */ 0x2d,0x3f,0x31,
/* 98 */ 0x2d,0x3f,0x36,
/* 99 */ 0x2d,0x3f,0x3a,
/* 100 */ 0x2d,0x3f,0x3f,
/* 101 */ 0x2d,0x3a,0x3f,
/* 102 */ 0x2d,0x36,0x3f,
/* 103 */ 0x2d,0x31,0x3f,
/* 104 */ 0x00,0x00,0x1c,
/* 105 */ 0x07,0x00,0x1c,
/* 106 */ 0x0e,0x00,0x1c,
/* 107 */ 0x15,0x00,0x1c,
/* 108 */ 0x1c,0x00,0x1c,
/* 109 */ 0x1c,0x00,0x15,
/* 110 */ 0x1c,0x00,0x0e,
/* 111 */ 0x1c,0x00,0x07,
/* 112 */ 0x1c,0x00,0x00,
/* 113 */ 0x1c,0x07,0x00,
/* 114 */ 0x1c,0x0e,0x00,
/* 115 */ 0x1c,0x15,0x00,
/* 116 */ 0x1c,0x1c,0x00,
/* 117 */ 0x15,0x1c,0x00,
/* 118 */ 0x0e,0x1c,0x00,
/* 119 */ 0x07,0x1c,0x00,
/* 120 */ 0x00,0x1c,0x00,
/* 121 */ 0x00,0x1c,0x07,
/* 122 */ 0x00,0x1c,0x0e,
/* 123 */ 0x00,0x1c,0x15,
/* 124 */ 0x00,0x1c,0x1c,
/* 125 */ 0x00,0x15,0x1c,
/* 126 */ 0x00,0x0e,0x1c,
/* 127 */ 0x00,0x07,0x1c,
/* 128 */ 0x0e,0x0e,0x1c,
/* 129 */ 0x11,0x0e,0x1c,
/* 130 */ 0x15,0x0e,0x1c,
/* 131 */ 0x18,0x0e,0x1c,
/* 132 */ 0x1c,0x0e,0x1c,
/* 133 */ 0x1c,0x0e,0x18,
/* 134 */ 0x1c,0x0e,0x15,
/* 135 */ 0x1c,0x0e,0x11,
/* 136 */ 0x1c,0x0e,0x0e,
/* 137 */ 0x1c,0x11,0x0e,
/* 138 */ 0x1c,0x15,0x0e,
/* 139 */ 0x1c,0x18,0x0e,
/* 140 */ 0x1c,0x1c,0x0e,
/* 141 */ 0x18,0x1c,0x0e,
/* 142 */ 0x15,0x1c,0x0e,
/* 143 */ 0x11,0x1c,0x0e,
/* 144 */ 0x0e,0x1c,0x0e,
/* 145 */ 0x0e,0x1c,0x11,
/* 146 */ 0x0e,0x1c,0x15,
/* 147 */ 0x0e,0x1c,0x18,
/* 148 */ 0x0e,0x1c,0x1c,
/* 149 */ 0x0e,0x18,0x1c,
/* 150 */ 0x0e,0x15,0x1c,
/* 151 */ 0x0e,0x11,0x1c,
/* 152 */ 0x14,0x14,0x1c,
/* 153 */ 0x16,0x14,0x1c,
/* 154 */ 0x18,0x14,0x1c,
/* 155 */ 0x1a,0x14,0x1c,
/* 156 */ 0x1c,0x14,0x1c,
/* 157 */ 0x1c,0x14,0x1a,
/* 158 */ 0x1c,0x14,0x18,
/* 159 */ 0x1c,0x14,0x16,
/* 160 */ 0x1c,0x14,0x14,
/* 161 */ 0x1c,0x16,0x14,
/* 162 */ 0x1c,0x18,0x14,
/* 163 */ 0x1c,0x1a,0x14,
/* 164 */ 0x1c,0x1c,0x14,
/* 165 */ 0x1a,0x1c,0x14,
/* 166 */ 0x18,0x1c,0x14,
/* 167 */ 0x16,0x1c,0x14,
/* 168 */ 0x14,0x1c,0x14,
/* 169 */ 0x14,0x1c,0x16,
/* 170 */ 0x14,0x1c,0x18,
/* 171 */ 0x14,0x1c,0x1a,
/* 172 */ 0x14,0x1c,0x1c,
/* 173 */ 0x14,0x1a,0x1c,
/* 174 */ 0x14,0x18,0x1c,
/* 175 */ 0x14,0x16,0x1c,
/* 176 */ 0x00,0x00,0x10,
/* 177 */ 0x04,0x00,0x10,
/* 178 */ 0x08,0x00,0x10,
/* 179 */ 0x0c,0x00,0x10,
/* 180 */ 0x10,0x00,0x10,
/* 181 */ 0x10,0x00,0x0c,
/* 182 */ 0x10,0x00,0x08,
/* 183 */ 0x10,0x00,0x04,
/* 184 */ 0x10,0x00,0x00,
/* 185 */ 0x10,0x04,0x00,
/* 186 */ 0x10,0x08,0x00,
/* 187 */ 0x10,0x0c,0x00,
/* 188 */ 0x10,0x10,0x00,
/* 189 */ 0x0c,0x10,0x00,
/* 190 */ 0x08,0x10,0x00,
/* 191 */ 0x04,0x10,0x00,
/* 192 */ 0x00,0x10,0x00,
/* 193 */ 0x00,0x10,0x04,
/* 194 */ 0x00,0x10,0x08,
/* 195 */ 0x00,0x10,0x0c,
/* 196 */ 0x00,0x10,0x10,
/* 197 */ 0x00,0x0c,0x10,
/* 198 */ 0x00,0x08,0x10,
/* 199 */ 0x00,0x04,0x10,
/* 200 */ 0x08,0x08,0x10,
/* 201 */ 0x0a,0x08,0x10,
/* 202 */ 0x0c,0x08,0x10,
/* 203 */ 0x0e,0x08,0x10,
/* 204 */ 0x10,0x08,0x10,
/* 205 */ 0x10,0x08,0x0e,
/* 206 */ 0x10,0x08,0x0c,
/* 207 */ 0x10,0x08,0x0a,
/* 208 */ 0x10,0x08,0x08,
/* 209 */ 0x10,0x0a,0x08,
/* 210 */ 0x10,0x0c,0x08,
/* 211 */ 0x10,0x0e,0x08,
/* 212 */ 0x10,0x10,0x08,
/* 213 */ 0x0e,0x10,0x08,
/* 214 */ 0x0c,0x10,0x08,
/* 215 */ 0x0a,0x10,0x08,
/* 216 */ 0x08,0x10,0x08,
/* 217 */ 0x08,0x10,0x0a,
/* 218 */ 0x08,0x10,0x0c,
/* 219 */ 0x08,0x10,0x0e,
/* 220 */ 0x08,0x10,0x10,
/* 221 */ 0x08,0x0e,0x10,
/* 222 */ 0x08,0x0c,0x10,
/* 223 */ 0x08,0x0a,0x10,
/* 224 */ 0x0b,0x0b,0x10,
/* 225 */ 0x0c,0x0b,0x10,
/* 226 */ 0x0d,0x0b,0x10,
/* 227 */ 0x0f,0x0b,0x10,
/* 228 */ 0x10,0x0b,0x10,
/* 229 */ 0x10,0x0b,0x0f,
/* 230 */ 0x10,0x0b,0x0d,
/* 231 */ 0x10,0x0b,0x0c,
/* 232 */ 0x10,0x0b,0x0b,
/* 233 */ 0x10,0x0c,0x0b,
/* 234 */ 0x10,0x0d,0x0b,
/* 235 */ 0x10,0x0f,0x0b,
/* 236 */ 0x10,0x10,0x0b,
/* 237 */ 0x0f,0x10,0x0b,
/* 238 */ 0x0d,0x10,0x0b,
/* 239 */ 0x0c,0x10,0x0b,
/* 240 */ 0x0b,0x10,0x0b,
/* 241 */ 0x0b,0x10,0x0c,
/* 242 */ 0x0b,0x10,0x0d,
/* 243 */ 0x0b,0x10,0x0f,
/* 244 */ 0x0b,0x10,0x10,
/* 245 */ 0x0b,0x0f,0x10,
/* 246 */ 0x0b,0x0d,0x10,
/* 247 */ 0x0b,0x0c,0x10,
/* 248 */ 0x00,0x00,0x00,
/* 249 */ 0x00,0x00,0x00,
/* 250 */ 0x00,0x00,0x00,
/* 251 */ 0x00,0x00,0x00,
/* 252 */ 0x00,0x00,0x00,
/* 253 */ 0x00,0x00,0x00,
/* 254 */ 0x00,0x00,0x00,
/* 255 */ 0x00,0x00,0x00
};

#endif	/* ! macintosh */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\vgaports.h ===
#ifdef	VGG
/* This file is not used for a non-VGA port. */

/*[
	Name:		vgaports.h
	Derived From:	original
	Author:		Phil Taylor
	Created On:	December 1990
	Sccs ID:	@(#)vgaports.h	1.13 01/13/95
	Purpose:	VGA ports definitions.
	
	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

#ifdef BIT_ORDER1

/* CRTC Mode Control Register. Index 0x17 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned hardware_reset		: 1,	/* NO		*/
		word_or_byte_mode		: 1,	/* YES 		*/
		address_wrap			: 1,	/* NO 		*/
		not_used			: 1,
		count_by_two			: 1,	/* NO		*/
		horizontal_retrace_select	: 1,	/* NO		*/
		select_row_scan_counter		: 1,	/* NO		*/
		compatibility_mode_support	: 1;	/* YES - CGA graphics banks		*/
	} as_bfld;
} MODE_CONTROL;

/* CRTC Overflow Register. Index 7 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned vertical_retrace_start_bit_9	: 1,	/* NO	*/
		vertical_display_enab_end_bit_9	: 1,	/* YES	*/
		vertical_total_bit_9		: 1,	/* NO	*/
		line_compare_bit_8		: 1,	/* YES	*/
		start_vertical_blank_bit_8	: 1,	/* NO	*/
		vertical_retrace_start_bit_8	: 1,	/* NO	*/
		vertical_display_enab_end_bit_8	: 1,	/* YES	*/
		vertical_total_bit_8		: 1;	/* NO	*/
	} as_bfld;
} CRTC_OVERFLOW;

/* CRTC Max Scan Line Register. Index 9 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned double_scanning		: 1,	/* pixel height * 2 */
		line_compare_bit_9			: 1,	/* YES	*/
		start_vertical_blank_bit_9		: 1,	/* NO	*/
		maximum_scan_line			: 5;	/* YES	*/
	} as_bfld;
} MAX_SCAN_LINE;

/* CRTC Cursor Start Scan Line Register. Index A */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 2,
		cursor_off			: 1,	/* YES	*/
		cursor_start			: 5;	/* YES	*/
	} as_bfld;
} CURSOR_START;

/* CRTC Cursor End Scan Line Register. Index B */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 1,
		cursor_skew_control		: 2,	/* NO	*/
		cursor_end			: 5;	/* YES	*/
	} as_bfld;
} CURSOR_END;

/* Sequencer Reset Register. Index 0 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 6,
		synchronous_reset		: 1,		/* Ditto (could implement as enable_ram)*/
		asynchronous_reset		: 1;		/* NO - damages video and font RAM	*/
	} as_bfld;
} SEQ_RESET;

/* Sequencer Clocking Mode Register. Index 1 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned still_not_used		: 2,
		screen_off			: 1,		/* YES - */
		shift4				: 1,		/* YES - */
		dot_clock			: 1,		/* YES - distinguishes 40 or 80 chars	*/
		shift_load			: 1,		/* NO	*/
		not_used			: 1,		/* NO	*/
		eight_or_nine_dot_clocks	: 1;		/* NO - only for mono display		*/
	} as_bfld;
} CLOCKING_MODE;

/* Sequencer Map Mask (Plane Mask) register. Index 2 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		all_planes			: 4;		/* YES	*/
	} as_bfld;
} MAP_MASK;

/* Sequencer Character Map Select register. Index 3 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 2,
		ch_map_select_b_hi		: 1,		/* YES	*/
		ch_map_select_a_hi		: 1,		/* YES	*/
		character_map_select_b		: 2,		/* YES	*/
		character_map_select_a		: 2;		/* YES	*/
	} as_bfld;
	struct {
		unsigned not_used		: 2,
		map_selects			: 6;		/* YES	*/
	} character;
} CHAR_MAP_SELECT;

/* Sequencer Memory Mode Register. Index 4 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned
		not_used		: 4,	/* If above 2 not both 1, bank 0 set 2	*/
		chain4			: 1,	/* Chain all planes into 1 */
		not_odd_or_even		: 1,	/* YES (check consistency) */
		extended_memory		: 1,	/* NO - assume full 256K on board	*/
		still_not_used		: 1;
	} as_bfld;
} MEMORY_MODE;

#ifdef V7VGA
/* Sequencer Extensions Control Register. Index 6 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned
		not_used		: 7,	
		    extension_enable	: 1;	/* YES */
	} as_bfld;
} EXTN_CONTROL;
#endif /* V7VGA */

/* Graphics Controller Set/Reset register. Index 0 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		set_or_reset			: 4;	/* YES - write mode 0 only		*/
	} as_bfld;
} SET_OR_RESET;

/* Graphics Controller Enable Set/Reset register. Index 1 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		enable_set_or_reset		: 4;	/* YES - write mode 0 only		*/
	} as_bfld;
} ENABLE_SET_OR_RESET;

/* Graphics Controller Colo[u]r Compare register. Index 2 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		color_compare			: 4;	/* YES - read mode 1 only		*/
	} as_bfld;
} COLOR_COMPARE;

/* Graphics Controller Data Rotate register. Index 3 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 3,
		function_select			: 2,	/* YES - write mode 0 only		*/
		rotate_count			: 3;	/* YES - write mode 0 only		*/
	} as_bfld;
} DATA_ROTATE;

/* Graphics Controller Read Map Select register. Index 4 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used	: 6,
		map_select		: 2;	/* YES 	*/
	} as_bfld;
} READ_MAP_SELECT;

/* Graphics Controller Mode Register. Index 5 */
typedef	union
    {
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 1,	/* YES */
		shift_register_mode		: 2,	/* YES 	*/
		odd_or_even			: 1,	/* YES (check for consistency)	*/
		read_mode			: 1,	/* YES	*/
		test_condition			: 1,	/* NO	*/
		write_mode			: 2;	/* YES	*/
	} as_bfld;
} MODE;

/* Graphics Controller Miscellaneous register. Index 6 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		memory_map			: 2,	/* YES - location of EGA in M	*/
		odd_or_even			: 1,	/* YES (check consistency)	*/
		graphics_mode			: 1;	/* YES	*/
	} as_bfld;
} MISC_REG;

/* Graphics Controller Colour Don't Care register. Index 7 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		color_dont_care			: 4;	/* YES - read mode 1 only		*/
	} as_bfld;
} COLOR_DONT_CARE;

/* Attribute Controller Mode register. Index 10 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned
		select_video_bits		: 1,	/* YES	*/
		color_output_assembler		: 1,	/* from 256 colour mode */
		horiz_pan_mode			: 1,	/* NO	*/
		reserved			: 1,
		    background_intensity_or_blink	: 1,	/* NO - never blink			*/
		enable_line_graphics_char_codes: 1,	/* NO mono display only			*/
		display_type			: 1,	/* NO - always colour display		*/
		graphics_mode			: 1;	/* YES - with Sequencer Mode reg	*/
	} as_bfld;
} AC_MODE_CONTROL;


/* Attribute Controller Colour Plane Enable register. Index 12 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used			: 2,
		video_status_mux			: 2,	/* NO	*/
		color_plane_enable			: 4;	/* YES  NB. affects attrs in text mode	*/
	} as_bfld;
} COLOR_PLANE_ENABLE;

/* Attribute Controller Pixel Padding register. Index 14 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		color_top_bits			: 2,
		color_mid_bits			: 2;
	} as_bfld;
} PIXEL_PAD;

/* External Misc Output register. Address 3cc */
typedef union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned horiz_vert_retrace_polarity	: 2,		/* YES - 200/350/480 lines	*/
		page_bit_odd_even		: 1,		/* NO - selects 32k page in odd/even?*/
		/* V7VGA - YES - used to select banks */
		not_used			: 1,
		clock_select			: 2,		/* YES - only for switch address	*/
		enable_ram			: 1,		/* YES - writes to display mem ignored	*/
		io_address_select		: 1;		/* NO - only used for mono screens	*/
	} as_bfld;

} MISC_OUTPUT_REG;

typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		reserved			: 2,		/* YES - ignore	*/
		feature_control			: 2;		/* NO - device not supported	*/
	} as_bfld;
} FEAT_CONT_REG;

/* External Input Status Register 0. Address 3c2 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned crt_interrupt		: 1,		/* YES - sequence if not timing	*/
		reserved			: 2,		/* YES - all bits 1			*/
		sense_pin			: 1,		/* NO	*/
		not_used			: 4;		/* YES - all bits 1			*/
	} as_bfld;
} INPUT_STAT_REG0;

/* External Input Status Register 1. Address 3da */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,
		vertical_retrace		: 1,		/* YES - sequence only	*/
		still_not_used			: 2,		/* NO	*/
		display_enable			: 1;		/* YES - sequence only	*/
	} as_bfld;
} INPUT_STAT_REG1;

#endif /* BIT_ORDER1 */

#ifdef BIT_ORDER2
/* CRTC Mode Control Register. Index 0x17 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned compatibility_mode_support	: 1,	/* YES - CGA graphics banks	*/
		select_row_scan_counter		: 1,	/* NO	*/
		horizontal_retrace_select	: 1,	/* NO	*/
		count_by_two			: 1,	/* NO	*/
		not_used			: 1,
		address_wrap			: 1,	/* NO 	*/
		word_or_byte_mode		: 1,	/* YES 	*/
		hardware_reset			: 1;	/* NO	*/
	} as_bfld;
} MODE_CONTROL;

/* CRTC Overflow Register. Index 7 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned vertical_total_bit_8	: 1,	/* NO	*/
		vertical_display_enab_end_bit_8	: 1,	/* YES	*/
		vertical_retrace_start_bit_8	: 1,	/* NO	*/
		start_vertical_blank_bit_8	: 1,	/* NO	*/
		line_compare_bit_8		: 1,	/* YES	*/
		vertical_total_bit_9		: 1,	/* NO	*/
		vertical_display_enab_end_bit_9	: 1,	/* YES	*/
		vertical_retrace_start_bit_9	: 1;	/* NO	*/
	} as_bfld;
} CRTC_OVERFLOW;

/* CRTC Max Scan Line Register. Index 9 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned maximum_scan_line	: 5,	/* YES	*/
		start_vertical_blank_bit_9	: 1,	/* NO	*/
		line_compare_bit_9		: 1,	/* YES	*/
		double_scanning			: 1;	/* pixel height * 2 */
	} as_bfld;
} MAX_SCAN_LINE;

/* CRTC Cursor Start Scan Line Register. Index A */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned cursor_start		: 5,	/* YES	*/
		cursor_off			: 1,	/* YES	*/
		not_used			: 2;
	} as_bfld;
} CURSOR_START;

/* CRTC Cursor End Scan Line Register. Index B */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned cursor_end		: 5,	/* YES	*/
		cursor_skew_control		: 2,	/* NO	*/
		not_used			: 1;
	} as_bfld;
} CURSOR_END;

/* Sequencer Reset Register. Index 0 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned asynchronous_reset	: 1,		/* NO - damages video and font RAM	*/
		synchronous_reset		: 1,		/* Ditto (could implement as enable_ram)*/
		not_used			: 6;
	} as_bfld;
} SEQ_RESET;

/* Sequencer Clocking Mode Register. Index 1 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned eight_or_nine_dot_clocks	: 1,	/* NO - only for mono display	*/
		not_used			: 1,		/* NO	*/
		shift_load			: 1,		/* NO	*/
		dot_clock			: 1,		/* YES - distinguishes 40 or 80 chars	*/
		shift4				: 1,		/* YES - */
		screen_off			: 1,		/* YES - */
		still_not_used			: 2;
	} as_bfld;
} CLOCKING_MODE;

/* Sequencer Map Mask (Plane Mask) register. Index 2 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned all_planes		: 4,		/* YES	*/
		not_used			: 4;
	} as_bfld;
} MAP_MASK;

/* Sequencer Character Map Select register. Index 3 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned character_map_select_a	: 2,		/* YES	*/
		character_map_select_b		: 2,		/* YES	*/
		ch_map_select_a_hi		: 1,		/* YES	*/
		ch_map_select_b_hi		: 1,		/* YES	*/
		not_used			: 2;
	} as_bfld;
	struct {
		unsigned map_selects		: 6,		/* YES	*/
		not_used			: 2;
	} character;
} CHAR_MAP_SELECT;

/* Sequencer Memory Mode Register. Index 4 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned still_not_used	: 1,
		extended_memory	: 1,	/* NO - assume full 256K on board	*/
		not_odd_or_even	: 1,	/* YES (check consistency)		*/
		chain4		: 1,	/* Chain all planes into 1 */
		not_used	: 4;	/* If above 2 not both 1, bank 0 set 2	*/
	} as_bfld;
} MEMORY_MODE;

#ifdef V7VGA
/* Sequencer Extensions Control Register. Index 6 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned
		extension_enable	: 1,	/* YES */
		not_used		: 7;	
	} as_bfld;
} EXTN_CONTROL;
#endif /* V7VGA */

/* Graphics Controller Set/Reset register. Index 0 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned set_or_reset	: 4,	/* YES - write mode 0 only	*/
		not_used		: 4;
	} as_bfld;
} SET_OR_RESET;

/* Graphics Controller Enable Set/Reset register. Index 1 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned enable_set_or_reset	: 4,	/* YES - write mode 0 only	*/
		not_used			: 4;
	} as_bfld;
} ENABLE_SET_OR_RESET;

/* Graphics Controller Colo[u]r Compare register. Index 2 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned color_compare		: 4,	/* YES - read mode 1 only	*/
		not_used			: 4;
	} as_bfld;
} COLOR_COMPARE;

/* Graphics Controller Data Rotate register. Index 3 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned rotate_count		: 3,	/* YES - write mode 0 only		*/
		function_select			: 2,	/* YES - write mode 0 only		*/
		not_used			: 3;
	} as_bfld;
} DATA_ROTATE;

/* Graphics Controller Read Map Select register. Index 4 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned map_select	: 2,	/* YES - read mode 0 only		*/
		not_used		: 6;
	} as_bfld;
} READ_MAP_SELECT;

/* Graphics Controller Mode Register. Index 5 */
typedef	union
    {
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned write_mode		: 2,	/* YES	*/
		test_condition			: 1,	/* NO	*/
		read_mode			: 1,	/* YES	*/
		odd_or_even			: 1,	/* YES (check for consistency)		*/
		shift_register_mode		: 2,	/* YES 	*/
		not_used			: 1;	/* YES 	*/
	} as_bfld;
} MODE;

/* Graphics Controller Miscellaneous register. Index 6 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned graphics_mode		: 1,	/* YES	*/
		odd_or_even			: 1,	/* YES (check consistency)	*/
		memory_map			: 2,	/* YES - location of EGA in M	*/
		not_used			: 4;
	} as_bfld;
} MISC_REG;

/* Graphics Controller Colour Don't Care register. Index 7 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned color_dont_care	: 4,	/* YES - read mode 1 only	*/
		not_used			: 4;
	} as_bfld;
} COLOR_DONT_CARE;

/* Attribute Controller Mode register. Index 10 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned graphics_mode		: 1,	/* YES - with Sequencer Mode reg	*/
		display_type			: 1,	/* NO - always colour display		*/
		enable_line_graphics_char_codes	: 1,	/* NO mono display only			*/
		background_intensity_or_blink	: 1,	/* NO - never blink			*/
		reserved			: 1,
		horiz_pan_mode			: 1,	/* NO	*/
		color_output_assembler		: 1,	/* from 256 colour mode */
		select_video_bits		: 1;	/* YES	*/
	} as_bfld;
} AC_MODE_CONTROL;

/* Attribute Controller Colour Plane Enable register. Index 12 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned color_plane_enable		: 4,	/* YES  NB. affects attrs in text mode	*/
		video_status_mux			: 2,	/* NO	*/
		not_used				: 2;
	} as_bfld;
} COLOR_PLANE_ENABLE;

/* Attribute Controller Pixel Padding register. Index 14 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned color_mid_bits		: 2,
		color_top_bits			: 2,
		not_used			: 4;
	} as_bfld;
} PIXEL_PAD;

/* External Misc Output register. Address 3cc */
typedef union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned io_address_select	: 1,		/* NO - only used for mono screens	*/
		enable_ram			: 1,		/* YES - writes to display mem ignored	*/
		clock_select			: 2,		/* YES - only for switch address	*/
		not_used			: 1,
		page_bit_odd_even		: 1,		/* NO - selects 32k page in odd/even?	*/
		horiz_vert_retrace_polarity	: 2;		/* YES - 200/350/480 lines	*/
	} as_bfld;
} MISC_OUTPUT_REG;

typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned feature_control	: 2,		/* NO - device not supported	*/
		reserved			: 2,		/* YES - ignore			*/
		not_used			: 4;
	} as_bfld;
} FEAT_CONT_REG;

/* External Input Status Register 0. Address 3c2 */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned not_used		: 4,		/* YES - all bits 1	*/
		sense_pin			: 1,		/* NO	*/
		reserved			: 2,		/* YES - all bits 1		*/
		crt_interrupt			: 1;		/* YES - sequence if not timing	*/
	} as_bfld;
} INPUT_STAT_REG0;

/* External Input Status Register 1. Address 3da */
typedef	union
{
	struct {
		unsigned abyte : 8;
	} as;
	struct {
		unsigned display_enable		: 1,		/* YES - sequence only	*/
		still_not_used			: 2,		/* NO	*/
		vertical_retrace		: 1,		/* YES - sequence only	*/
		not_used			: 4;
	} as_bfld;
} INPUT_STAT_REG1;
#endif /* BIT_ORDER2 */

/* The Sequencer Registers */
#ifdef BIT_ORDER1
struct sequencer
{
#ifdef V7VGA
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned using_extensions	: 1,
			extensions_index		: 4,
			index				: 3;
		} as_bfld;
	} address;
#else
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used	: 5,
			index			: 3;
		} as_bfld;
	} address;
#endif /* V7VGA */

	SEQ_RESET		reset;
	CLOCKING_MODE	clocking_mode;
	MAP_MASK		map_mask;
	CHAR_MAP_SELECT	character_map_select;
	MEMORY_MODE		memory_mode;

#ifdef V7VGA
	EXTN_CONTROL		extensions_control;
#endif /* V7VGA */

}; 



/* The CRT Controller Registers */

struct crt_controller
{
#ifdef V7VGA
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used	: 2,
			index			: 6;
		} as_bfld;
	} address;
#else
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used				: 3,
			index				: 5;
		} as_bfld;
	} address;
#endif /* V7VGA */

	byte horizontal_total;				/* NO - screen trash if wrong value	*/
	byte horizontal_display_end;			/* YES - defines line length!!		*/
	byte start_horizontal_blanking;			/* NO	*/

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used		: 1,
			display_enable_skew_control	: 2,	/* NO	*/
			end_blanking			: 5;	/* NO	*/
		} as_bfld;
	} end_horizontal_blanking;

	byte start_horizontal_retrace;			/* NO	*/

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used			: 1,
			horizontal_retrace_delay		: 2,	/* NO	*/
			end_horizontal_retrace		: 5;	/* NO	*/
		} as_bfld;
	} end_horizontal_retrace;

	byte vertical_total;					/* NO	*/
	CRTC_OVERFLOW	crtc_overflow;

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used		: 1,
			horiz_pan_lo			: 2,
			preset_row_scan			: 5;	/* NO	*/
		} as_bfld;
	} preset_row_scan;

	MAX_SCAN_LINE	maximum_scan_line;
	CURSOR_START	cursor_start;
	CURSOR_END		cursor_end;
	byte start_address_high;					/* YES	*/
	byte start_address_low;					/* YES	*/
	byte cursor_location_high;					/* YES	*/
	byte cursor_location_low;					/* YES	*/
	byte vertical_retrace_start;				/* NO	*/
	byte light_pen_high;					/* NO	*/

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned 
			crtc_protect			: 1,
			refresh_type			: 1,
			enable_vertical_interrupt		: 1,	/* YES 	*/
			clear_vertical_interrupt		: 1,	/* YES 	*/
			vertical_retrace_end		: 4;	/* NO	*/
		} as_bfld;
	} vertical_retrace_end;

	unsigned short vertical_display_enable_end;			/* YES - defines screen height - 10 bit	*/
	byte offset;						/* ????	*/

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used				: 1,
			doubleword_mode			: 1,	/* YES	*/
			count_by_4				: 1,	/* NO	*/
			underline_location			: 5;	/* NO (mono display only)		*/
		} as_bfld;
	} underline_location;

	byte start_vertical_blanking;				/* NO	*/
	byte end_vertical_blanking;					/* NO	*/
	MODE_CONTROL	mode_control;
	unsigned short line_compare;				/* YES,10 bits*/

} ;



/* The Graphics Controller Registers */

struct graphics_controller
{
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used				: 4,
			index				: 4;
		} as_bfld;
	} address;

	SET_OR_RESET	set_or_reset;
	ENABLE_SET_OR_RESET	enable_set_or_reset;
	COLOR_COMPARE	color_compare;
	DATA_ROTATE		data_rotate;
	READ_MAP_SELECT	read_map_select;
	MODE		mode;
	MISC_REG		miscellaneous;
	COLOR_DONT_CARE	color_dont_care;
	byte bit_mask_register;					/* YES - write modes 0 & 2		*/
}; 



/* The Attribute Controller Registers */

struct attribute_controller
{
#ifdef V7VGA
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned index_state			: 1,
			unused						: 1,
			palette_address_source			: 1,
			index				: 5;
		} as_bfld;
	} address;

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			color_top_bits		: 2,	/* YES	*/
			secondary_red		: 1,	/* YES	*/
			secondary_green		: 1,	/* YES	*/
			secondary_blue		: 1,	/* YES	*/
			red				: 1,	/* YES	*/
			green				: 1,	/* YES	*/
			blue				: 1;	/* YES	*/
		} as_bfld;
	} palette[EGA_PALETTE_SIZE];
#else
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned unused				: 2,
			palette_address_source			: 1,
			index				: 5;
		} as_bfld;
	} address;

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			not_used				: 2,	/* YES	*/
			secondary_red			: 1,	/* YES	*/
			secondary_green			: 1,	/* YES	*/
			secondary_blue			: 1,	/* YES	*/
			red				: 1,	/* YES	*/
			green				: 1,	/* YES	*/
			blue				: 1;	/* YES	*/
		} as_bfld;
	} palette[EGA_PALETTE_SIZE];
#endif /* V7VGA */

	AC_MODE_CONTROL	mode_control;

#ifdef V7VGA
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned color_top_bits	: 2,	/* YES	*/
			secondary_red_border	: 1,	/* YES	*/
			secondary_green_border	: 1,	/* YES	*/
			secondary_blue_border	: 1,	/* YES	*/
			red_border			: 1,	/* YES	*/
			green_border		: 1,	/* YES	*/
			blue_border			: 1;	/* YES 	*/
		} as_bfld;
	} overscan_color;
#else
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used				: 2,
			secondary_red_border		: 1,	/* YES	*/
			secondary_green_border		: 1,	/* YES	*/
			secondary_blue_border		: 1,	/* YES	*/
			red_border				: 1,	/* YES	*/
			green_border			: 1,	/* YES	*/
			blue_border			: 1;	/* YES 	*/
		} as_bfld;
	} overscan_color;
#endif /* V7VGA */

	COLOR_PLANE_ENABLE	color_plane_enable;

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned not_used				: 4,
			horizontal_pel_panning		: 4;	/* NO	*/
		} as_bfld;
	} horizontal_pel_panning;

	PIXEL_PAD	pixel_padding;
}; 


#ifdef V7VGA
/* The V7VGA Extension Registers */

struct extensions_controller
{
	byte pointer_pattern;

	union
		{
		struct
				{
			unsigned abyte 		: 8;
		} as;
		struct
				{
			unsigned not_used		: 5,
			ptr_horiz_position	: 3;
		} as_bfld;
	} ptr_horiz_posn_hi;

	byte ptr_horiz_posn_lo;

	union
		{
		struct
				{
			unsigned abyte 		: 8;
		} as;
		struct
				{
			unsigned not_used		: 6,
			ptr_vert_position		: 2;
		} as_bfld;
	} ptr_vert_posn_hi;

	byte ptr_vert_posn_lo;

	union
		{
		struct
				{
			unsigned abyte		: 8;
		} as;
		struct
				{
			unsigned not_used		: 3,
			clock_select		: 1,
			unused			: 4;
		} as_bfld;
	} clock_select;

	union
		{
		struct
				{
			unsigned abyte		: 8;
		} as;
		struct
				{
			unsigned pointer_enable	: 1,
			not_used			: 3,
			cursor_mode			: 1,
			unused			: 2,
			cursor_blink_disable	: 1;
		} as_bfld;
	} cursor_attrs;

	union {
		struct {
			unsigned abyte	: 8;
		} as;
		struct {
			unsigned dummy	: 7,
			dac_8_bits	: 1;
		} as_bfld;
	} dac_control;

	union
		{
		struct
				{
			unsigned abyte		: 8;
		} as;
		struct
				{
			unsigned emulation_enable	: 1,
			hercules_bit_map			: 1,
			write_prot_2			: 1,
			write_prot_1			: 1,
			write_prot_0			: 1,
			nmi_enable				: 3;
		} as_bfld;
	} emulation_control;

	byte foreground_latch_0;
	byte foreground_latch_1;
	byte foreground_latch_2;
	byte foreground_latch_3;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned not_used			: 2,
			fg_latch_load_state		: 2,
			unused				: 2,
			bg_latch_load_state		: 2;
		} as_bfld;
	} fast_latch_load_state;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned unused			: 6,
			masked_write_source		: 1,
			masked_write_enable		: 1;
		} as_bfld;
	} masked_write_control;

	byte masked_write_mask;
	byte fg_bg_pattern;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned line_compare_bank_reset	: 1,
			counter_bank_enable			: 1,
			crtc_read_bank_select			: 2,
			cpu_read_bank_select			: 2,
			cpu_write_bank_select			: 2;
		} as_bfld;
	} ram_bank_select;

	byte switch_readback;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned extended_clock_output: 3,
			clock_3_on				: 1,
			external_clock_override		: 1,
			extended_clock_output_source	: 1,
			extended_clock_direction	: 1,
			clock_0_only			: 1;
		} as_bfld;
	} clock_control;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned unused			: 7,
			extended_page_select		: 1;
		} as_bfld;
	} page_select;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned unused			: 4,
			foreground_color			: 4;
		} as_bfld;
	} foreground_color;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned unused			: 4,
			background_color			: 4;
		} as_bfld;
	} background_color;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned internal_3c3_enable	: 1,
			extended_display_enable_skew	: 1,
			sequential_chain4		: 1,
			sequential_chain			: 1,
			refresh_skew_control		: 1,
			extended_256_color_enable	: 1,
			extended_256_color_mode		: 1,
			extended_attribute_enable	: 1;
		} as_bfld;
	} compatibility_control;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned graphics_8_dot_timing_state	: 4,
			text_8_dot_timing_state				: 4;
		} as_bfld;
	} timing_select;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned not_used			: 4,
			fg_bg_mode				: 2,
			fg_bg_source			: 1,
			unused				: 1;
		} as_bfld;
	} fg_bg_control;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned bus_status	: 1,
			pointer_bank_select		: 2,
			bank_enable			: 1,
			ROM_interface_enable	: 1,
			fast_write_enable			: 1,
			io_interface_enable	: 1,
			mem_interface_enable	: 1;
		} as_bfld;
	} interface_control;
}; 

#endif /* V7VGA */
#endif /* BIT_ORDER1 */

#ifdef BIT_ORDER2
struct sequencer
{
#ifdef V7VGA
	union
	{
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			index                   : 3,
			extensions_index        : 4,
			using_extensions        : 1;
		} as_bfld;
	} address;
#else
	union
	{
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			index                       : 3,
			not_used                    : 5;
		} as_bfld;
	} address;
#endif /* V7VGA */

	SEQ_RESET           reset;
	CLOCKING_MODE       clocking_mode;
	MAP_MASK            map_mask;
	CHAR_MAP_SELECT     character_map_select;
	MEMORY_MODE         memory_mode;
#ifdef V7VGA
        EXTN_CONTROL        extensions_control;
#endif /* V7VGA */

};


/* The CRT Controller Registers */

struct crt_controller
{
	 
#ifdef V7VGA
	union
	{
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			index           : 6,
			not_used        : 2;
		} as_bfld;
	} address;
#else
	union
	{
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			index       : 5,
			not_used    : 3;
		} as_bfld;
	} address;
#endif /* V7VGA */
												 
	byte horizontal_total;				/* NO - screen trash if wrong value	*/
	byte horizontal_display_end;			/* YES - defines line length!!		*/
	byte start_horizontal_blanking;			/* NO	*/

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned end_blanking		: 5,	/* NO	*/
			display_enable_skew_control	: 2,	/* NO	*/
			not_used			: 1;
		} as_bfld;
	} end_horizontal_blanking;

	byte start_horizontal_retrace;				/* NO	*/

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned end_horizontal_retrace		: 5,	/* NO	*/
			horizontal_retrace_delay		: 2,	/* NO	*/
			not_used				: 1;
		} as_bfld;
	} end_horizontal_retrace;

	byte vertical_total;					/* NO	*/
	CRTC_OVERFLOW	crtc_overflow;

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned preset_row_scan	: 5,	/* NO	*/
			horiz_pan_lo			: 2,
			not_used			: 1;
		} as_bfld;
	} preset_row_scan;

	MAX_SCAN_LINE	maximum_scan_line;
	CURSOR_START	cursor_start;
	CURSOR_END		cursor_end;
	byte start_address_high;				/* YES	*/
	byte start_address_low;					/* YES	*/
	byte cursor_location_high;				/* YES	*/
	byte cursor_location_low;				/* YES	*/
	byte vertical_retrace_start;				/* NO	*/
	byte light_pen_high;					/* NO	*/

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned vertical_retrace_end		: 4,	/* NO	*/
			clear_vertical_interrupt		: 1,	/* YES  */
			enable_vertical_interrupt		: 1,	/* YES	*/
			refresh_type			: 1,
			crtc_protect			: 1;
		} as_bfld;
	} vertical_retrace_end;

	unsigned short vertical_display_enable_end;		/* YES - defines screen height - 10 bit	*/
	byte offset;						/* ????	*/

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned underline_location	: 5,	/* NO (mono display only)		*/
			count_by_4			: 1,	/* NO	*/
			doubleword_mode			: 1,	/* YES	*/
			not_used			: 1;
		} as_bfld;
	} underline_location;

	byte start_vertical_blanking;				/* NO	*/
	byte end_vertical_blanking;				/* NO	*/
	MODE_CONTROL	mode_control;
	byte line_compare;					/* YES	*/

};



/* The Graphics Controller Registers */

struct graphics_controller
{
	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned index				: 4,
			not_used				: 4;
		} as_bfld;
	} address;

	SET_OR_RESET	set_or_reset;
	ENABLE_SET_OR_RESET	enable_set_or_reset;
	COLOR_COMPARE	color_compare;
	DATA_ROTATE		data_rotate;
	READ_MAP_SELECT	read_map_select;
	MODE		mode;
	MISC_REG		miscellaneous;
	COLOR_DONT_CARE	color_dont_care;
	byte bit_mask_register;				/* YES - write modes 0 & 2	*/
}; 



/* The Attribute Controller Registers */

struct attribute_controller
{
#ifdef V7VGA
	union
	{    
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			index                           : 5,
			palette_address_source          : 1,
			unused                          : 1,
			index_state                     : 1;
		} as_bfld;
	} address;

	union
	{    
		struct {
			unsigned abyte : 8;
			} as;
		struct {
			unsigned
			blue                    : 1,    /* YES  */
			green                   : 1,    /* YES  */
			red                     : 1,    /* YES  */
			secondary_blue          : 1,    /* YES  */
			secondary_green         : 1,    /* YES  */
			secondary_red           : 1,    /* YES  */
			color_top_bits          : 2;    /* YES  */
		} as_bfld;
	} palette[EGA_PALETTE_SIZE];
#else  
	union
	{
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			index                           : 5,
			palette_address_source		: 1,
			unused                          : 2;
		} as_bfld;
	} address;

	union
	{
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			blue                               : 1,    /* YES  */
			green                              : 1,    /* YES  */
			red                                : 1,    /* YES  */
			secondary_blue                     : 1,    /* YES  */
			secondary_green                    : 1,    /* YES  */
			secondary_red                      : 1,    /* YES  */
			not_used                           : 2;    /* YES  */
		} as_bfld;
	} palette[EGA_PALETTE_SIZE];
#endif /* V7VGA */

	AC_MODE_CONTROL	mode_control;

#ifdef V7VGA
	union
	{
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			blue_border             : 1,    /* YES  */
			green_border            : 1,    /* YES  */
			red_border              : 1,    /* YES  */
			secondary_blue_border   : 1,    /* YES  */
			secondary_green_border  : 1,    /* YES  */
			secondary_red_border    : 1,    /* YES  */
			color_top_bits          : 2;    /* YES  */
		} as_bfld;
	} overscan_color;
#else  
	union
	{
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned
			blue_border                     : 1,    /* YES  */
			green_border                    : 1,    /* YES  */
			red_border                      : 1,    /* YES  */
			secondary_blue_border           : 1,    /* YES  */
			secondary_green_border          : 1,    /* YES  */
			secondary_red_border            : 1,    /* YES  */
			not_used                        : 2;
		} as_bfld;
	} overscan_color;
#endif /* V7VGA */

	COLOR_PLANE_ENABLE	color_plane_enable;

	union
	    {
		struct {
			unsigned abyte : 8;
		} as;
		struct {
			unsigned horizontal_pel_panning		: 4,	/* NO	*/
			not_used				: 4;
		} as_bfld;
	} horizontal_pel_panning;

	PIXEL_PAD	pixel_padding;
}; 


#ifdef V7VGA
/* The V7VGA Extension Registers */

struct extensions_controller
{
	byte pointer_pattern;

	union
		{
		struct
				{
			unsigned abyte 		: 8;
		} as;
		struct
				{
			unsigned 
			ptr_horiz_position	: 3,
			not_used		: 5;
		} as_bfld;
	} ptr_horiz_posn_hi;

	byte ptr_horiz_posn_lo;

	union
		{
		struct
				{
			unsigned abyte 		: 8;
		} as;
		struct
				{
			unsigned
			ptr_vert_position	: 2,
			not_used		: 6;
		} as_bfld;
	} ptr_vert_posn_hi;

	byte ptr_vert_posn_lo;

	union
		{
		struct
				{
			unsigned abyte		: 8;
		} as;
		struct
				{
			unsigned 
			unused			: 4,
			clock_select		: 1,
			not_used		: 3;
		} as_bfld;
	} clock_select;

	union
		{
		struct
				{
			unsigned abyte		: 8;
		} as;
		struct
				{
			unsigned 
			cursor_blink_disable	: 1,
			unused			: 2,
			cursor_mode		: 1,
			not_used		: 3,
			pointer_enable		: 1;

		} as_bfld;
	} cursor_attrs;

	union {
		struct {
			unsigned abyte	: 8;
		} as;
		struct {
			unsigned dac_8_bits	: 1,
			dummy			: 7;
		} as_bfld;
	} dac_control;

	union
		{
		struct
				{
			unsigned abyte		: 8;
		} as;
		struct
				{
			unsigned 
			nmi_enable			: 3,
			write_prot_0			: 1,
			write_prot_1			: 1,
			write_prot_2			: 1,
			hercules_bit_map		: 1,
			emulation_enable		: 1;
		} as_bfld;
	} emulation_control;

	byte foreground_latch_0;
	byte foreground_latch_1;
	byte foreground_latch_2;
	byte foreground_latch_3;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			bg_latch_load_state		: 2,
			unused				: 2,
			fg_latch_load_state		: 2,
			not_used			: 2;
		} as_bfld;
	} fast_latch_load_state;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			masked_write_enable		: 1,
			masked_write_source		: 1,
			unused				: 6;
		} as_bfld;
	} masked_write_control;

	byte masked_write_mask;
	byte fg_bg_pattern;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			cpu_write_bank_select			: 2,
			cpu_read_bank_select			: 2,
			crtc_read_bank_select			: 2,
			counter_bank_enable			: 1,
			line_compare_bank_reset			: 1;
		} as_bfld;
	} ram_bank_select;

	byte switch_readback;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			clock_0_only			: 1,
			extended_clock_direction	: 1,
			extended_clock_output_source	: 1,
			external_clock_override		: 1,
			clock_3_on			: 1,
			extended_clock_output		: 3;
		} as_bfld;
	} clock_control;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			extended_page_select	: 1,
			unused			: 7;
		} as_bfld;
	} page_select;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			foreground_color	: 4,
			unused			: 4;
		} as_bfld;
	} foreground_color;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			background_color	: 4,
			unused			: 4;
		} as_bfld;
	} background_color;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			extended_attribute_enable	: 1,
			extended_256_color_mode		: 1,
			extended_256_color_enable	: 1,
			refresh_skew_control		: 1,
			sequential_chain		: 1,
			sequential_chain4		: 1,
			extended_display_enable_skew	: 1,
			internal_3c3_enable		: 1;
		} as_bfld;
	} compatibility_control;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			text_8_dot_timing_state		: 4,
			graphics_8_dot_timing_state	: 4;
		} as_bfld;
	} timing_select;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			unused			: 1,
			fg_bg_source		: 1,
			fg_bg_mode		: 2,
			not_used		: 4;
		} as_bfld;
	} fg_bg_control;

	union
		{
		struct
				{
			unsigned abyte			: 8;
		} as;
		struct
				{
			unsigned 
			mem_interface_enable	: 1,
			io_interface_enable	: 1,
			fast_write_enable	: 1,
			ROM_interface_enable	: 1,
			bank_enable		: 1,
			pointer_bank_select	: 2,
			bus_status		: 1;
		} as_bfld;
	} interface_control;
}; 

#endif /* V7VGA */

#endif /* BIT_ORDER2 */

#ifdef V7VGA
#ifdef CPU_40_STYLE
extern void set_v7_fg_latch_byte IPT2(IU8, index, IU8, value);
#define SET_FG_LATCH(n, val)	set_v7_fg_latch_byte(n, val)
#else
#ifdef BIGEND
#define SET_FG_LATCH( n, val )	(*((UTINY *) &fg_latches + (n)) = value )
#endif /* BIGEND */
#ifdef LITTLEND
#define SET_FG_LATCH( n, val )	(*((UTINY *) &fg_latches + (3 - n)) = value )
#endif /* LITTLEND */
#endif	/* CPU_40_STYLE */
#endif /* V7VGA */

#ifdef GISP_SVGA
void mapRealIOPorts IPT0( );
void mapEmulatedIOPorts IPT0( );
#endif		/* GISP_SVGA */
 
/* Global data structures to import into modules
 */
IMPORT MISC_OUTPUT_REG	miscellaneous_output_register;
IMPORT FEAT_CONT_REG	feature_control_register;
IMPORT INPUT_STAT_REG0	input_status_register_zero;
IMPORT INPUT_STAT_REG1	input_status_register_one;

IMPORT VOID init_vga_globals IPT0();
IMPORT VOID ega_mode_init IPT0();
IMPORT VOID enable_gfx_update_routines IPT0();
IMPORT VOID disable_gfx_update_routines IPT0();

#ifndef cursor_changed
IMPORT VOID cursor_changed IPT2(int, x, int, y);
#endif
IMPORT VOID update_shift_count IPT0();

#ifdef V7VGA 
IMPORT struct extensions_controller extensions_controller;
#endif /* V7VGA */ 
IMPORT struct crt_controller		crt_controller;
IMPORT struct sequencer			sequencer;
IMPORT struct attribute_controller	attribute_controller;
IMPORT struct graphics_controller	graphics_controller;

/* 
   31.3.92 MG The video-7 VGA has an undocumented ability to support either
   6 or 8 bits of data in the palette. To support this we store the number`
   of bits in the DAC_data_bits variable so that the routines which stuff
   the data onto the screen know how much to output.
*/

IMPORT	byte	DAC_data_mask;
#ifdef V7VGA
IMPORT	int	DAC_data_bits;
#endif

#endif	/* VGG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\vgastate.h ===
/*[
 *
 *	File		:	vgastate.h
 *
 *	Derived from:	(original)
 *
 *	Purpose		:	Definition of data types/constants to save and restore the 
 *					(internal) state of a VGA card.
 *
 *	Author		:	Rog
 *	Date		:	25 November 1992
 *
 *	SCCS Gumph	:	@(#)vgastate.h	1.1 08/06/93
 *	
 *	(c) Copyright Insignia Solutions Ltd., 1992 All rights reserved
 *
 *	Modifications	:	
 *
]*/

#ifndef _VGASTATE_H_
#define _VGASTATE_H_

/*(
 *
 *	typedef	:	vgastate structure
 *
 * 	purpose	:	provides storage for all the registers and data associated with
 *				any (S)VGA card
 *
 *	Format	:	The first part of the structure is a header consisting of arrays
 *				for all the standard VGA registers. There is also an array to
 *				hold the values of the IO ports between 0x3b0 and 0x3e0 (a VGA
 *				uses 3ba-3cc)
 *				There is then a set of sizes of and pointers to arrays to hold
 *				data contained in any extra registers added to the standard set
 *				for SVGA cards and a general extra data area.
 *				Finally there is a field for the size of the planes and an array
 *				of pointers to copies of the plane data.
 *
 *				All this data is held starting at the last field in the 
 *				structure (Data[])
 *
 *				Pointers should be NULL if they do not point to valid data
 *
 *				Total size of data will be 
 *					sizeof( VGAState ) + extendSequencerSize + extendCRTSize
 *						+ extendGraphSize + extendAttrSize + extendDACSize
 *							+ miscDataSize + ( 4 * planeSize )
)*/

typedef struct 
{
	unsigned char	ioPorts[ 0x30 ];		/* IO Ports 3B0 - 3E0 */
	unsigned char	sequencerData[ 5 ];		/* Sequencer registers */
	unsigned char	CRTContData[ 24 ];		/* CRT Controller registers */
	unsigned char	graphContData[ 9 ];		/* Graphics controller regs */
	unsigned char	attrContData[ 15 ];		/* Attribute Controller regs */
	unsigned char	DACData[ 3 * 256 ];		/* Data values from PEL Data reg */
	unsigned int	latch;					/* 32 bit data latch register */
	unsigned int	extendSequencerSize;	/* size in bytes of extra sequencer data */
	unsigned char	* extendSequencerData;	/* pointer to extra sequencer regs */
	unsigned int	extendCRTSize;			/* size in bytes of extra CRT data */
	unsigned char	* extendCRTData;		/* Pointer to extra CRT controller regs */
	unsigned int	extendGraphSize;		/* size in bytes of extra graph cont data */
	unsigned char	* extendGraphData;		/* pointer to extra Graph controller data */
	unsigned int	extendAttrSize;			/* size in bytes of extra attr cont data */
	unsigned char	* extendAttrData;		/* pointer to extra attribute cont data */
	unsigned int	extendDACSize;			/* size in bytes of extra sequencer data */
	unsigned char	* extendDACData;		/* Pointer to extra DAC data */
	unsigned int	miscDataSize;			/* Any other random junk */	
	unsigned char	* miscData;
	unsigned int	planeSize;				/* Size in bytes of each plane */
	unsigned char	* planeData[ 4 ];		/* Pointers to copies of plane data */
	unsigned char	data[ 1 ];				/* Data holder */

}	VGAState , *pVGAState;


/* Macros for gettting at the register values in the IoPort array */

#define		miscOutputWrite		ioPorts[ 0x12 ]
#define		miscOutputRead		ioPorts[ 0x1C ]
#define		EGAFeatureContWrite	ioPorts[ 0x2A ]
#define		VGAFeatureContWrite	ioPorts[ 0x0A ]
#define		featureContRead		ioPorts[ 0x1A ]
#define		inputStat0			ioPorts[ 0x12 ]
#define		colourInputStat1	ioPorts[ 0x2A ]
#define		monoInputStat1		ioPorts[ 0x0A ]
#define		sequencerIndex		ioPorts[ 0x14 ]
#define		sequencer			ioPorts[ 0x15 ]
#define		CRTIndexEGA			ioPorts[ 0x24 ]
#define		CRTIndexVGA			ioPorts[ 0x04 ]
#define		graphContIndex		ioPorts[ 0x1E ]
#define		graphCont			ioPorts[ 0x1F ]
#define		attrContIndexWrite	ioPorts[ 0x10 ]
#define		attrContIndexRead	ioPorts[ 0x11 ]
#define		attrCont			ioPorts[ 0x1F ]
#define		PELAddrWriteMode	ioPorts[ 0x18 ]
#define		PELAddrReadMode		ioPorts[ 0x17 ]
#define		PELData				ioPorts[ 0x19 ]
#define		DACState			ioPorts[ 0x17 ]
#define		PELMask				ioPorts[ 0x16 ]

/* Macros for the Sequencer Registers */
#define		seqReset		sequencerData[ 0 ]
#define		seqClockMode	sequencerData[ 1 ]
#define		seqMapMask		sequencerData[ 2 ]
#define		seqCharMapSel	sequencerData[ 3 ]
#define		seqMemMode		sequencerData[ 4 ]

/* Macros for the CRT controller registers */

#define horizTotal			CRTContData[ 0 ]
#define horizDisplayEnd		CRTContData[ 1 ]
#define startHorizBlank		CRTContData[ 2 ]
#define endHorizBlank		CRTContData[ 3 ]
#define startHorizRetrace	CRTContData[ 4 ]
#define endHorizRetrace		CRTContData[ 5 ]
#define vertTotal			CRTContData[ 6 ]
#define overflow			CRTContData[ 7 ]
#define presetRowScan		CRTContData[ 8 ]
#define maxScanLine			CRTContData[ 9 ]
#define cursorStart			CRTContData[ 10 ]
#define startAddressHigh	CRTContData[ 11 ]
#define startAddressLow		CRTContData[ 12 ]
#define cursLocHigh			CRTContData[ 13 ]
#define cursLocLow			CRTContData[ 14 ]
#define vertRetStart		CRTContData[ 15 ]
#define vertRetEnd			CRTContData[ 16 ]
#define vertDisplayEnd		CRTContData[ 17 ]
#define CRToffset			CRTContData[ 18 ]
#define underlineLoc		CRTContData[ 19 ]
#define startVertBlank		CRTContData[ 20 ]
#define endVertBlank		CRTContData[ 21 ]
#define CRTModeControl		CRTContData[ 22 ]
#define lineCompare			CRTContData[ 23 ]

/* Macros for Graphics Controller */

#define setReset		graphContData[ 0 ]
#define enableSetReset	graphContData[ 1 ]
#define colourCompare	graphContData[ 2 ]
#define dataRotate		graphContData[ 3 ]
#define readMapSelect	graphContData[ 4 ]
#define GCmode			graphContData[ 5 ]
#define GCmisc			graphContData[ 6 ]
#define CDC				graphContData[ 7 ]
#define GCBitMask		graphContData[ 8 ]

/* The Attribute controller registers */

#define Palette				AttrContData			/* POINTER ! */
#define AttrModeControl		AttrContData[ 16 ]
#define OverscanColour		AttrContData[ 17 ]
#define ColourPlaneEnable	AttrContData[ 18 ]
#define HorizPixPan			AttrContData[ 19 ]
#define ColourSelect		AttrContData[ 20 ]



/* Numbers of the various Registers in the Standard VGA Emulation */

#define NUM_SEQ_REGS	5
#define	NUM_CRT_REGS	24
#define	NUM_GRAPH_REGS	9
#define NUM_ATT_REGS	15
#define	DAC_ENTRIES		3 * 256

#endif 		/* _VGASTATE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\video.h ===
/* SccsID @(#)video.h	1.24 08/19/94 Copyright Insignia Solutions Inc. */

#ifndef NEC_98
/*
 * M6845 video chip registers
 */

#define R10_CURS_START	        10
#define R11_CURS_END	        11
#define CGA_R12_START_ADDRH	12
#define CGA_R13_START_ADDRL	13
#define R14_CURS_ADDRH	        14
#define R15_CURS_ADDRL	        15

#define M6845_INDEX_REG         (word)(vd_addr_6845)
#define M6845_DATA_REG          (word)(vd_addr_6845 + 1)
#define M6845_MODE_REG          (word)(vd_addr_6845 + 4)

/*
 * The individual colour adaptor registers
 */


/*
 * The clear character defines
 */

#define VD_CLEAR_TEXT 		((7 << 8) | ' ')
#define VD_CLEAR_GRAPHICS 	0


/*
 * 'tidy' define for operations on graphics memory which is stored in two banks:
 * of odd & even scan lines.
 */
#define ODD_OFF		0x2000	/* offset of odd graphics bank from even */
#define SCAN_CHAR_HEIGHT 8	/* no scanlines spanned by graphics char */

/* 4 full scanlines is the (offset/size) of one text line PER bank */
#define ONELINEOFF      320
#endif // !NEC_98


/*
 * The control character defines
 */

#define VD_BS		0x8			/* Backspace	*/
#define VD_CR		0xD			/* Return	*/
#define VD_LF		0xA			/* Line feed	*/
#define VD_BEL		0x7			/* Bell		*/

/*
 * Sound system defines
 */

#define	BEEP_LENGTH	500000L	/* 1/2 second beep */

/*
 * intel memory position defines for data stored in bios variables
 */

#if defined(NEC_98)
IMPORT void keyboard_io IPT0();             /* routed to KB BIOS        */
IMPORT void vd_NEC98_set_mode IPT0();           /* 0ah Set mode             */
IMPORT void vd_NEC98_get_mode IPT0();           /* 0bh Get mode             */
IMPORT void vd_NEC98_start_display IPT0();      /* 0ch Start display        */
IMPORT void vd_NEC98_stop_display IPT0();       /* 0dh Stop display         */
IMPORT void vd_NEC98_single_window IPT0();      /* 0eh Set single window    */
IMPORT void vd_NEC98_multi_window IPT0();       /* 0fh Set multi window     */
IMPORT void vd_NEC98_set_cursor IPT0();         /* 10h Set cursor type      */
IMPORT void vd_NEC98_show_cursor IPT0();        /* 11h Show cursor          */
IMPORT void vd_NEC98_hide_cursor IPT0();        /* 12h Hide cursor          */
IMPORT void vd_NEC98_set_cursorpos IPT0();      /* 13h Set cursor position  */
IMPORT void vd_NEC98_get_font IPT0();           /* 14h Get font             */
IMPORT void vd_NEC98_get_pen IPT0();            /* 15h Get lightpen status  */
IMPORT void vd_NEC98_init_textvram IPT0();      /* 16h Initialize text vram */
IMPORT void vd_NEC98_start_beep IPT0();         /* 17h Start beep sound     */
IMPORT void vd_NEC98_stop_beep IPT0();          /* 18h Stop beep sound      */
IMPORT void vd_NEC98_init_pen IPT0();           /* 19h Initialize lightpen  */
IMPORT void vd_NEC98_set_font IPT0();           /* 1ah Set user font        */
IMPORT void vd_NEC98_set_kcgmode IPT0();        /* 1bh Set KCG access mode  */
IMPORT void vd_NEC98_init_crt IPT0();           /* 1ch Initialize CRT    /H */
IMPORT void vd_NEC98_set_disp_width IPT0();     /* 1dh Set display size  /H */
IMPORT void vd_NEC98_set_cursor_type IPT0();    /* 1eh Set cursor type   /H */
IMPORT void vd_NEC98_get_mswitch IPT0();        /* 21h Get memory switch /H */
IMPORT void vd_NEC98_set_mswitch IPT0();        /* 22h Set memory switch /H */
IMPORT void vd_NEC98_set_beep_rate IPT0();      /* 23h Set beep rate     /H */
IMPORT void vd_NEC98_set_beep_time IPT0();      /* 24h Set beep time&ring/H */
IMPORT void video_init IPT0();

extern BOOL     HIRESO_MODE;

IMPORT void (*video_func_h[]) ();
IMPORT void (*video_func_n[]) ();

/*
 * The following table specifies data for the supported video
 * modes - ie 80x25 A/N and 640x200 APA.  It is indexed via the video
 * mode variable and a value of VD_BAD_MODE indicates that the given
 * video mode is not supported.
 */

typedef struct {
                sys_addr    start_addr;
                sys_addr    end_addr;
                word        clear_char;
                half_word   mode_control_val;
                half_word   mode_screen_cols;
                word        ncols;
                half_word   npages;
               } MODE_ENTRY;

#if 0 ///STREAM_IO codes are disabled now, till Beta-1
#ifdef NTVDM
/* this is the stream io buffer size used on RISC machines.
 * On X86, the size is determined by spckbd.asm
 */
#define STREAM_IO_BUFFER_SIZE_32	82
IMPORT void disable_stream_io(void);
IMPORT void host_enable_stream_io(void);
IMPORT void host_disable_stream_io(void);
IMPORT half_word * stream_io_buffer;
IMPORT word * stream_io_dirty_count_ptr;
IMPORT word stream_io_buffer_size;
IMPORT boolean	stream_io_enabled;
#ifdef MONITOR
IMPORT sys_addr stream_io_bios_busy_sysaddr;
#endif

#endif
#endif // zero
#else  // !NEC_98

#define	vd_video_mode	0x449
#define VID_COLS	0x44A	/* vd_cols_on_screen */
#define	VID_LEN  	0x44C	/* vd_crt_len */
#define	VID_ADDR	0x44E	/* vd_crt_start */
#define	VID_CURPOS	0x450	/* cursor table 8 pages */
#define	VID_CURMOD	0x460	/* vd_cursor_mode */
#define	vd_current_page	0x462
#define VID_INDEX	0x463	/* vd_addr_6845 */
#define	vd_crt_mode	0x465
#define	vd_crt_palette	0x466

#ifdef EGG
#define vd_rows_on_screen 0x484
#else
#define vd_rows_on_screen  24        /* Never changes */
#endif

extern IU8 Video_mode;	/* Shadow copy of BIOS video mode */

/* Where the BIOS thinks the display is in memory */
IMPORT sys_addr video_pc_low_regen,video_pc_high_regen;

/* useful defines to get at the current cursor position */
#define current_cursor_col	VID_CURPOS+2*sas_hw_at_no_check(vd_current_page)
#define current_cursor_row	VID_CURPOS+2*sas_hw_at_no_check(vd_current_page)+1

#define NO_OF_M6845_REGISTERS	16

#define	CHARS_IN_GEN	128	/* length of gen tables */
#define CHAR_MAP_SIZE	8	/* no. of bytes for one character in font */



/*
 * The function jump table for the video routines.  The video_io() function
 * uses this to route calls on the AH register
 */
IMPORT void vd_set_mode IPT0();
IMPORT void vd_set_cursor_mode IPT0();
IMPORT void vd_set_cursor_position IPT0();
IMPORT void vd_get_cursor_position IPT0();
IMPORT void vd_get_light_pen IPT0();
IMPORT void vd_set_active_page IPT0();
IMPORT void vd_scroll_up IPT0(), vd_scroll_down IPT0();
IMPORT void vd_read_attrib_char IPT0(), vd_write_char_attrib IPT0();
IMPORT void vd_write_char IPT0();
IMPORT void vd_set_colour_palette IPT0();
IMPORT void vd_read_dot IPT0(), vd_write_dot IPT0();
IMPORT void vd_write_teletype IPT0();
IMPORT void vd_get_mode IPT0();
IMPORT void vd_write_string IPT0();


IMPORT void video_init IPT0();
IMPORT void ega_video_init IPT0();
IMPORT void ega_video_io IPT0();
IMPORT void ega_graphics_write_char IPT6(int, i, int, j, int, k, int, l, int, m, int, n);
IMPORT void ega_write_dot IPT4(int, i, int, j, int, k, int , l);
IMPORT void ega_sensible_graph_scroll_up IPT6(int, i, int, j, int, k, int, l, int, m, int, n);
IMPORT void ega_sensible_graph_scroll_down IPT6(int, i, int, j, int, k, int, l, int, m, int, n);
IMPORT void ega_read_attrib_char IPT3(int, i, int, j ,int, k);
IMPORT void ega_read_attrib_dot IPT3(int, i, int, j ,int, k);
IMPORT void search_font IPT2(char *, ptr, int, i);

#ifdef VGG
IMPORT void not_imp IPT0();
#endif

#ifdef VGG
IMPORT void vga_disp_comb IPT0();
IMPORT void vga_disp_func IPT0();
IMPORT void vga_int_1C IPT0();
#endif

/* offsets into video_func */
#ifdef VGG
#define EGA_FUNC_SIZE	0x1D
#else
#define EGA_FUNC_SIZE	0x14
#endif
#define CGA_FUNC_SIZE	0x14

#define SET_MODE 0
#ifdef EGG
#define SET_EGA_PALETTE 0x10
#define CHAR_GEN	0x11
#define ALT_SELECT	0x12
#define WRITE_STRING	0x13
#endif

IMPORT void (*video_func[]) ();

/*
 * The following table specifies data for the supported video
 * modes - ie 80x25 A/N and 640x200 APA.  It is indexed via the video
 * mode variable and a value of VD_BAD_MODE indicates that the given
 * video mode is not supported.
 */

typedef struct {
		sys_addr    start_addr;
		sys_addr    end_addr;
		word	    clear_char;
		half_word   mode_control_val;
		half_word   mode_screen_cols;
		word        ncols;
		half_word   npages;
	       } MODE_ENTRY;

#define VD_BAD_MODE     1
#define VIDEO_ENABLE	0x8	/* enable bit in mode byte */

IMPORT MODE_ENTRY vd_mode_table[];
#ifdef V7VGA
IMPORT MODE_ENTRY vd_ext_text_table[];
IMPORT MODE_ENTRY vd_ext_graph_table[];
#endif /* V7VGA */

#ifdef V7VGA
#define VD_MAX_MODE	0x69
#else
#define VD_MAX_MODE	(sizeof(vd_mode_table)/sizeof(MODE_ENTRY))
#endif

/*
 * Mode macros to distinguish between alphanumeric & graphics video modes
 */

#ifdef JAPAN
// mode73h support
#define	alpha_num_mode() \
    ( (sas_hw_at_no_check(vd_video_mode) < 4) || \
      (sas_hw_at_no_check(vd_video_mode) == 7) || \
      (!is_us_mode() && sas_hw_at_no_check(DosvModePtr) == 0x73 ) )
#else // !JAPAN
#define	alpha_num_mode()	(sas_hw_at_no_check(vd_video_mode) < 4 || sas_hw_at_no_check(vd_video_mode) == 7)
#endif // !JAPAN
#define	global_alpha_num_mode()	((Video_mode < 4) || (Video_mode == 7))
#ifdef EGG
#ifdef V7VGA
#define ega_mode()	(((sas_hw_at_no_check(vd_video_mode) > 7) && \
	(sas_hw_at_no_check(vd_video_mode) < 19)) || \
	((sas_hw_at_no_check(vd_video_mode) >= 0x14) && \
	(sas_hw_at_no_check(vd_video_mode) < 0x1a)))
#else
#define ega_mode()	((sas_hw_at_no_check(vd_video_mode) > 7) && \
	(sas_hw_at_no_check(vd_video_mode) < 19))
#endif /* V7VGA */
#endif

#ifdef VGG
#ifdef V7VGA
#define vga_256_mode()		(sas_hw_at_no_check(vd_video_mode) == 19 || (sas_hw_at_no_check(vd_video_mode) > 0x19 && sas_hw_at_no_check(vd_video_mode) < 0x1e))
#else
#define vga_256_mode()		(sas_hw_at_no_check(vd_video_mode) == 19)
#endif /* V7VGA */
#endif /* VGG */

/*
 * Macro to check validity of new video mode
 */
IMPORT unsigned char	valid_modes[];

#define NO_MODES	0
#define MDA_MODE	(1<<0)
#define CGA_MODE	(1<<1)
#define CGA_MONO_MODE	(1<<2)
#define EGA_MODE	(1<<3)
#define HERCULES_MODE	(1<<4)
#define VGA_MODE	(1<<5)
#define ALL_MODES	(MDA_MODE|CGA_MODE|CGA_MONO_MODE|EGA_MODE|HERCULES_MODE|VGA_MODE)

#define is_bad_vid_mode(nm)					\
(									       \
  ((nm&0x7F) < 0) ||							       \
  ((nm&0x7F) > 19) ||							       \
  ((video_adapter == MDA)	&& !(valid_modes[(nm&0x7F)]&MDA_MODE)) ||      \
  ((video_adapter == CGA)	&& !(valid_modes[(nm&0x7F)]&CGA_MODE)) ||      \
  ((video_adapter == CGA_MONO)	&& !(valid_modes[(nm&0x7F)]&CGA_MONO_MODE)) || \
  ((video_adapter == EGA)	&& !(valid_modes[(nm&0x7F)]&EGA_MODE)) ||      \
  ((video_adapter == VGA)	&& !(valid_modes[(nm&0x7F)]&VGA_MODE)) ||	\
  ((video_adapter == HERCULES)	&& !(valid_modes[(nm&0x7F)]&HERCULES_MODE))    \
)

#ifdef V7VGA
#define is_v7vga_mode(nm)	((nm >= 0x40 && nm <= 0x45) || (nm >= 0x60 && nm <= 0x69))
#else
#define is_v7vga_mode(nm)	(FALSE)
#endif /* V7VGA */

IMPORT VOID (*bios_ch2_byte_wrt_fn) IPT2(ULONG, ch_attr, ULONG, ch_addr);
IMPORT VOID (*bios_ch2_word_wrt_fn) IPT2(ULONG, ch_attr, ULONG, ch_addr);

IMPORT VOID simple_bios_byte_wrt IPT2(ULONG, ch_attr, ULONG, ch_addr);
IMPORT VOID simple_bios_word_wrt IPT2(ULONG, ch_attr, ULONG, ch_addr);

#ifdef VGG
IMPORT VOID vga_sensible_graph_scroll_up IPT6( LONG, row, LONG, col, LONG, rowsdiff, LONG, colsdiff, LONG, lines, LONG, attr);

IMPORT VOID vga_sensible_graph_scroll_down IPT6( LONG, row, LONG, col, LONG, rowsdiff, LONG, colsdiff, LONG, lines, LONG, attr);

IMPORT VOID vga_graphics_write_char IPT6( LONG, col, LONG, row, LONG, ch, IU8, colour, LONG, page, LONG, nchs);

IMPORT VOID vga_read_attrib_char IPT3(LONG, col, LONG, row, LONG, page);
IMPORT VOID vga_read_dot IPT3(LONG, page, LONG, pixcol, LONG, row);
IMPORT VOID vga_write_dot IPT4(LONG, colour, LONG, page, LONG, pixcol, LONG, row);

#endif

#ifdef NTVDM
/* this is the stream io buffer size used on RISC machines.
 * On X86, the size is determined by spckbd.asm
 */
#define STREAM_IO_BUFFER_SIZE_32    82
IMPORT void disable_stream_io(void);
IMPORT void host_enable_stream_io(void);
IMPORT void host_disable_stream_io(void);
IMPORT half_word * stream_io_buffer;
IMPORT word * stream_io_dirty_count_ptr;
IMPORT word stream_io_buffer_size;
IMPORT boolean  stream_io_enabled;
#ifdef MONITOR
IMPORT sys_addr stream_io_bios_busy_sysaddr;
#endif /* MONITOR */

#endif /* NTVDM */
#if defined(JAPAN) || defined(KOREA)
extern int dbcs_first[];
#define is_dbcs_first( c ) dbcs_first[ 0xff & c ]

extern int BOPFromDispFlag;
extern sys_addr DBCSVectorAddr; // word
extern sys_addr DosvModePtr;    // byte
extern sys_addr DosvVramPtr;
extern int DosvVramSize;

void SetDBCSVector( int CP );
void SetVram( void );
int is_us_mode( void );
void SetModeForIME( void );
#define INT10_NOTCHANGED    0   // RAID #875
#define INT10_SBCS          1
#define INT10_DBCS_LEADING  2
#define INT10_DBCS_TRAILING 4
#define INT10_CHANGED       0x10
extern int  Int10FlagCnt;
extern byte Int10Flag[];
extern byte NtInt10Flag[];
#endif // JAPAN
#endif // NEC98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\virtual.h ===
/*
 *
 * Title	: virtual.h   Virtual Machine support for Windows 3.x.
 *
 */
 
/* SccsID[]="@(#)virtual.h	1.3 05/10/95 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/* Creation and Termination Callback prototypes */
typedef void (*NIDDB_CR_CALLBACK) IPT1(IHP *, orig_handle);
typedef void (*NIDDB_TM_CALLBACK) IPT0();


/*
 * ============================================================================
 * External declarations
 * ============================================================================
 */

/* Allocate per Virtual Machine data area for Device Driver. */
GLOBAL IHP *NIDDB_Allocate_Instance_Data IPT3
   (
   int, size,			/* Size(in bytes) of data area reqd. */
   NIDDB_CR_CALLBACK, create_cb,     /* create callback, 0 if not reqd. */
   NIDDB_TM_CALLBACK, terminate_cb   /* terminate callback, 0 if not reqd. */
   );

/* Deallocate per Virtual Machine data area for Device Driver. */
GLOBAL void NIDDB_Deallocate_Instance_Data IPT1
   (
   IHP *, handle	/* Handle to data area */
   );

/* Inform NIDDB Manager about System reboot */
GLOBAL void NIDDB_System_Reboot IPT0();

/*
   Entry point from Windows 386 Virtual Device Driver (INSIGNIA.386).
   Provide virtualising services as required.
 */
GLOBAL void virtual_device_trap IPT0();

/* Ensure correct instance in place for Device Drivers. */
/* Called by BOP handler(bios.c) for any Device Driver BOP. */
GLOBAL void virtual_swap_instance IPT0();

/* Indicate if NIDDB is active */
GLOBAL IBOOL NIDDB_is_active IPT0();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\winhelp.h ===
/*(
 * ============================================================================
 *
 *	Name:		WinHelp.h
 *
 *	Derived From:	Bristol's version of this file.  Slightly modified
 *			by Barry McIntosh.
 *
 *	Created:	July 1994
 *
 *	SCCS ID:	@(#)WinHelp.h	1.1 07/13/94
 *
 *	Purpose:	Defines the interface to the WinHelp() function.
 *			Note that non-Insignia types are used, as this is
 *			an interface to a third-party function.
 *
 * ============================================================================
)*/

#ifdef HOST_HELP

/*
**  Bristol Technology Incorporated
**  241 Ethan Allen Highway, Ridgefield, Connecticut 06877
**
**  Copyright (c) 1990,1991,1992,1993 Bristol Technology Inc.
**  Property of Bristol Technology Inc.
**  All rights reserved.
**
**  File:         WinHelp.h
**
**  Description:  Defines for WinHelp.c
**
*/

#ifndef WIN_HELP_INCLUDED
#define WIN_HELP_INCLUDED

/* Commands to pass WinHelp() */
#define HELP_CONTEXT		0x0001	/* Display topic in ulTopic */
#define HELP_QUIT		0x0002	/* Terminate help */
#define HELP_INDEX		0x0003	/* Display index (Kept for compatibility) */
#define HELP_CONTENTS		0x0003	/* Display index */
#define HELP_HELPONHELP		0x0004	/* Display help on using help */
#define HELP_SETINDEX		0x0005	/* Set the current Index for multi index help */
#define HELP_SETCONTENTS	0x0005	/* Set the current Index for multi index help */
#define HELP_CONTEXTPOPUP	0x0008
#define HELP_FORCEFILE		0x0009
#define HELP_KEY		0x0101	/* Display topic for keyword in offabData */
#define HELP_MULTIKEY   	0x0201
#define HELP_COMMAND		0x0102 
#define HELP_PARTIALKEY		0x0105
#define HELP_SETWINPOS 		0x0203

/* bristol extensions */
#define HELP_MINIMIZE		0x1000
#define HELP_MAXIMIZE		0x1001
#define HELP_RESTORE		0x1002

extern void WinHelp IPT4(Display *,	hWnd,
			char *,		lpHelpFile,
			unsigned short,	wCommand,	
			unsigned long,	dwData);

/* 
 * HH comm structs
 */
#define HHATOMNAME   "HyperHelpAtom"

typedef struct _HHInstance {
   int             pid;          /*Parent id*/
   unsigned long   HHWindow;     /*Filled by HH upon invocation*/
   unsigned long   ClientWindow; /*Optional (future HH to client communication link)*/
   int             bServer;      /*Viewer Mode*/
   char            data[1024];
#ifdef dec3000
   unsigned long   filler[2];
   int             filler2[2];
#endif
} HHInstance_t;

#define MAX_HHINSTANCES 5
typedef struct _HHServerData {
   int                  nItems;
   struct _HHInstance   HHInstance[MAX_HHINSTANCES];
} HHServerData_t;

#endif	/*WIN_HELP_INCLUDED*/
#endif	/* HOST_HELP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\winfiles.h ===
/*
 *	File :		winfiles.h
 *	Used :		Interfaces provided by winfiles.c plus local macros
 *	Author :	Mike Moreton
 *	SccsId  :	@(#)winfiles.h	1.2 05/03/94 (C)1993 Insignia Solutions Ltd.
 */

#ifdef SWIN_HFX

#define FILE_CREATE	0x3c
#define FILE_OPEN	0x3d
#define	FILE_CLOSE	0x3e
#define FILE_READ	0x3f
#define	FILE_WRITE	0x40
#define FILE_DEL	0x41
#define FILE_LSEEK	0x42
#define FILE_DUPH	0x45
#define FILE_FDUPH	0x46
#define CREATE_CHILD_PSP	0x55
#define FILE_DATETIME	0x57
#define FILE_LOCKUNLOCK	0x5c
#define FILE_COMMIT	0x68
#define FILE_EXOPEN	0x6c

/*
 * Bit set in AL during file open to indicate that the open file
 * handle should not be inherited by child processes.
 */

#define NO_INHERIT 0x80

/*
 * seek requests 
 */
#define F_SEEK_START	0x0
#define	F_SEEK_REL		0x1
#define F_SEEK_END		0x2		

extern void SwinHfxReset IPT0();
extern void SwinHfxTaskTerm IPT0();
extern void SwinRedirector IPT0();
extern void SwinFileOpened IPT0();
extern void SwinHugeIo IPT0();
extern void SwinHfxOpen IPT3(sys_addr, sftEa, IU16, date, IU16, time);
extern IBOOL SwinHfxClose IPT3(IU16, fd, IU16 *, date, IU16 *, time);

extern IBOOL SwinHfxActive;
extern IBOOL SwinFilePreOpened;

#endif /* SOFTWIN_HFX */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\worm.h ===
/*
 * SoftPC Revision 2.0
 *
 * Title	: WORM module definitions
 *
 * Description	: Definitions for users of the WORM module
 *
 * Author	: Daniel Hannigan
 *
 * Notes	: None
 */

/* SccsID[]="@(#)worm.h	1.3 08/10/92 Copyright Insignia Solutions Ltd."; */

extern half_word *gen_mode_buf;
extern half_word *mode_page;
extern half_word *vendor_id;
extern word *driver_cmd_ptr;
extern word driver_cmd;
extern half_word *sense_byte_ptr;	/* additional sense byte */
extern word *op_drv_array;		/* drive control blocks */
extern word *flag_word_ptr;


/*
 * taken from Storage Dimensions asm file OBIOS.H
 *
 * the function codes for the optical primitives.
 */
#define OPTO_TEST	0
#define OPTO_REZERO	1
#define OPTO_INIT	2
#define OPTO_RD_ERR	3
#define	OPTO_FMT_DRV	4
#define OPTO_ROM_ID	5
#define	OPTO_READ	8
#define	OPTO_WRITE	0x0a
#define	OPTO_SEEK	0x0b
#define	OPTO_INQUIRY	0x12
#define	OPTO_MOD_SEL	0x15
#define	OPTO_MOD_SENSE	0x1a
#define OPTO_REC_DIAG	0x1c
#define OPTO_SEND_DIAG	0x1d
#define OPTO_MED_REMOVE	0x1e

#define MED_REM_ALLOW	0
#define MED_REM_PREV	1


/*
 * DOS error codes
 */

#define NO_ERR		0xff

#define WRITE_PROTECT	0
#define INVALID_UNIT	1
#define DEV_NOT_READY	2
#define BAD_COMMAND	3
#define CRC_ERROR	4
#define GEN_FAIL	12
#define MEDIA_CHANGE	15
#define SEC_NOT_WRITTEN	26
#define NO_CARTRIDGE	28

/*
 * DOS device driver command codes
 */

#define INIT		0
#define MEDIA_CHECK	1
#define BUILD_BPB	2
#define IOCTL		3

/*
 * more DOS defines
 */

#define NO_ERROR	0
#define FALSE		0

#define DOS_WRITE_PROT	0
#define DOS_UKNWN_UNIT	1
#define DOS_DRIVE_NRDY	2
#define DOS_UKNWN_CMD	3
#define DOS_CRC_ERROR	4
#define DOS_CMD_LENGTH	5
#define DOS_SEEK_ERROR	6
#define DOS_UNKWN_MED	7
#define DOS_SECT_NFND	8
#define	INVALID_SENSE	9
#define DOS_WRITE_FLT	10
#define DOS_READ_FLT	11
#define DOS_GEN_FAIL	12
#define DOS_INVLD_DISK	15

#define BAD_COMMAND	3

/*
 * OP_DRV_BLK - the current state of a mounted drive
 */
#define SIZE_OP_DRV_BLK	59	/* size of OP_DRV_BLK */

#define	OFFSET_OP_DRV_PUN	0	/* phys unit ( 1-4 valid ) */
#define	OFFSET_OP_DRV_FLG	1

#ifdef ANSI
extern void worm_io ();
extern void worm_init ();
extern int enq_worm ();
#else
extern void worm_io ();
extern void worm_init ();
extern int enq_worm ();
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\xt.h ===
#ifndef _XT_H
#define _XT_H
/*[
	Name:		xt.h
	Derived From:	VPC-XT Revision 1.0 (xt.h)
	Author:		Henry Nash
	Created On:	
	Sccs ID:	@(#)xt.h	1.19 05/15/95
	Purpose:	General include file for VPC-XT
	Notes:		This file should be included by all source modules.
			It includes the host specific general include file.

	(c)Copyright Insignia Solutions Ltd., 1990. All rights reserved.

]*/

/*
 * Useful defines
 */
#define HALF_WORD_SIZE 		sizeof (half_word)
#define WORD_SIZE 		sizeof (word)
#define DOUBLE_WORD_SIZE 	sizeof (double_word)

/*
 * Used for specifying 8, 16 bit or 32 bit sizes.
 */

typedef enum {EIGHT_BIT, SIXTEEN_BIT, THIRTY_TWO_BIT} SIZE_SPECIFIER;


#ifndef TRUE
#define FALSE  	0
#define TRUE   	!FALSE
#endif /* ! TRUE */

#undef SUCCESS
#undef FAILURE
#define SUCCESS 0
#define FAILURE	~SUCCESS

#ifndef	NULL
#define	NULL	0
#endif

#ifndef NULL_STRING
#define NULL_STRING	""
#endif

#ifdef SOFTWINDOWS
#define SPC_PRODUCT_NAME "SoftWindows"
#else
#define SPC_PRODUCT_NAME "SoftPC"
#endif

/***********************************************************************\
* host_gen.h is guarenteed to be included early in every C source file.	*
* It should contain those defines which are common to all versions	*
* built for a given host, to reduce the overhead in the "m" script.	*
* Bod 15/3/89.								*
\***********************************************************************/

#include "host_gen.h"

#ifndef MAXPATHLEN
#define MAXPATHLEN    1024
#endif


/*
 * Effective address calculation stuff
 */

#ifdef CPU_30_STYLE
/* ========================================================== */

/*
   Our model for the data extracted from a decriptor entry.
 */
typedef struct
   {
   double_word base;		/* 32-bit base address */
   double_word limit;		/* 32-bit offset limit */
   word  AR;			/* 16-bit attributes/access rights */
   } DESCR;

extern LIN_ADDR effective_addr IPT2( IU16, seg,  IU32, off);
extern void read_descriptor IPT2( LIN_ADDR, addr, DESCR*, descr);
extern boolean selector_outside_table IPT2( IU16, selector, IU32*, descr_addr);


/* ========================================================== */
#else /* CPU_30_STYLE */
/* ========================================================== */

#ifdef A2CPU

/*
 * Effective address macro
 */

#define effective_addr(seg, offset) (((double_word) seg * 0x10) + offset)

#endif /* A2CPU */

#ifdef CCPU
extern sys_addr effective_addr IPT2( word, seg, word, ofs);
#endif /* CCPU */

/* ========================================================== */
#endif /* CPU_30_STYLE */


#ifdef CCPU
/*
 * CCPU has no descriptor cache - so this should just fail.
 */
#define Cpu_find_dcache_entry(seg, base)	((IBOOL)FALSE)
#else	/* not CCPU */
extern IBOOL Cpu_find_dcache_entry IPT2(word, seg, double_word *, base);
#endif

/*
 * Global Flags and Variables
 */

extern char **pargv;			/* Pointer to argv		*/
extern int *pargc;			/* Pointer to argc		*/
extern int verbose;			/* FALSE => only report errors  */
extern IU32 io_verbose;			/* TRUE => report io errors   	*/
extern IBOOL Running_SoftWindows;	/* Are we SoftWindows?		*/
extern CHAR *SPC_Product_Name;		/* "SoftPC" or "SoftWindows"	*/

/*
 * The Parity Lookup table
 */

#ifndef CPU_30_STYLE

extern half_word pf_table[]; /* shouldn't this be in host_cpu.h ? */

#endif /* CPU_30_STYLE */

/*
 * External function declarations.
 */
 
#ifdef ANSI
extern void applInit(int, char *[]);
extern void applClose(void);
extern void terminate(void);
extern void host_terminate(void);
#else
extern void applInit();
extern void applClose();
extern void terminate();
extern void host_terminate();
#endif /* ANSI */

#ifdef SPC386
extern IBOOL CsIsBig IPT1(IU16, csVal);	/* is this a 32 bit code segment? */
#endif /* SPC386 */

extern void exitswin IPT0();

#endif /* _XT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\inc\yoda.h ===
/*
 * VPC-XT Revision 0.1
 *
 * Title	: yoda.h
 *
 * Description	: The force is with you include file
 *		  (ps yoda debugging file)
 *
 * Author	: Henry Nash
 *		  Phil Bousfield
 *
 * Notes	: This file contains the debugger call definitions
 */

/* SccsID[]="@(#)yoda.h	1.6 06/30/95 Copyright Insignia Solutions Ltd."; */

/*
 * ============================================================================
 * Structure/Data definitions
 * ============================================================================
 */

/* None */

/*
 * ============================================================================
 * External declarations and macros
 * ============================================================================
 */


/*  
 * If the PROD flag is set then turn the debugger calls into null macros
 * otherwise they are external functions - see yoda.c
 */

#ifdef PROD
#define check_I() 		/*	*/
#define check_D(address, value) /*address, value*/
#define force_yoda() 		/*	*/
#else
extern void check_I();
extern void check_D();
extern void force_yoda();
#endif

/*
 * Interface definitions and enums - non-prod only.
 */

#ifndef PROD

typedef enum {YODA_RETURN, YODA_RETURN_AND_REPEAT, YODA_HELP, YODA_LOOP, YODA_LOOP_AND_REPEAT} YODA_CMD_RETURN;
#define YODA_COMMAND(name) \
	YODA_CMD_RETURN name IFN6(char *, str, char *, com, IS32, cs, \
				LIN_ADDR, ip, LIN_ADDR, len, LIN_ADDR, stop)

#ifdef MSWDVR_DEBUG
extern YODA_CMD_RETURN do_mswdvr_debug IPT6(char *,str, char *, com, IS32, cs, LIN_ADDR, ip, LIN_ADDR, len, LIN_ADDR, stop);
#endif /* MSWDVR_DEBUG */

extern IBOOL AlreadyInYoda;

extern IU32 IntelMsgDest;
#define IM_DST_TRACE	1
#define IM_DST_RING	2

#else /* !PROD */

#endif /* !PROD else*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\keymouse\keyba.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Version 2.0
 *
 * Title:	keyba.c
 *
 * Description:	AT keyboard Adaptor I/O functions.
 *		
 *		kbd_inb(port,val)
 *		int port;
 *		half_word *val;
 *				provides the next scan code from the
 *				keyboard controller (8042), or the
 *				status byte of the controller, depending
 *				on the port accessed.
 *		kbd_outb(port,val)
 *		int port;
 *		half_word val;
 *				Sends a byte to the controller or the
 *				keyboard processor (6805), depending on
 *				the port accessed.
 *		AT_kbd_init()
 *				Performs any initialisation of the
 *				keyboard code necessary.
 *
 *		The system presents an interface to the host environment
 *		which is provided with the calls:
 *
 *		host_key_down(key)
 *		int key;
 *		host_key_up(key)
 *		int key;
 *
 *		These routines provide the keyboard code with information
 *		on the events which occur on the host keyboard. The key codes
 *		are the key numbers as given in the XT286 Technical Manual.
 *
 * Author:	William Charnell
 *
 * Notes:	
 *
 */


#ifdef SCCSID
static char SccsID[]="@(#)keyba.c	1.57 06/22/95 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_PPI.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH
#include TimeH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "ios.h"
#include "ppi.h"
#include "timeval.h"
#include "timer.h"
#include "keyboard.h"
#include "error.h"
#include "config.h"
#include "ica.h"
#include "keyba.h"
#include "quick_ev.h"
#ifdef macintosh
#include "ckmalloc.h"
#endif /* macintosh */

#include "debug.h"


/* <tur 12-Jul-93> BCN 2040
** KBD_CONT_DELAY is the delay time for continuing keyboard interrupts
** when a "sloppy" read of port 0x60 occurs while the keyboard interface
** is enabled. It's the "delay" parameter to add_q_event_t(), and is
** measured in microseconds.
** Perhaps this should be settable in the host; I've allowed for that here
** by defining the delay to be 7 milliseconds unless it's already defined.
** See comments in kbd_inb() below for more details.
*/

#ifndef	KBD_CONT_DELAY
#define	KBD_CONT_DELAY	7000		/* microseconds */
#endif	/* KBD_CONT_DELAY */


#ifdef NTVDM
#include "idetect.h"
#include "nt_eoi.h"

/* exported for NT host event code */
GLOBAL VOID KbdResume(VOID);
GLOBAL BOOL bPifFastPaste=TRUE;


/* imported from NT host code */
IMPORT ULONG  WaitKbdHdw(ULONG dwTimeOut);
IMPORT ULONG  KbdHdwFull;

IMPORT VOID  HostReleaseKbd(VOID);

/* imported from keybd_io.c */
IMPORT int bios_buffer_size(void);

IMPORT BOOL bBiosOwnsKbdHdw; // our kbd bios code owns the Keyboard Mutex
word KbdInt09Seg;
word KbdInt09Off;

extern void xmsEnableA20Wrapping(void);
extern void xmsDisableA20Wrapping(void);

#undef LOCAL
#define LOCAL

// local state variables for kbd interrupt regulation
VOID KbdIntDelay(VOID);
BOOL bBiosBufferSpace = TRUE;
BOOL bKbdIntHooked = FALSE;
char KbdData = -1;
BOOL bKbdEoiPending = TRUE;   // Kbd interrupts blocked until KbdResume invoked
BOOL bDelayIntPending = FALSE;
BOOL bForceDelayInts = FALSE;
ULONG LastKbdInt=0;

// Support for extended keyboards has been added to the tables in this file:
//
// * THE BRAZILIAN ABNT keyboard has 104 keys, 2 more than 'usual'
//   0x73 ?/ key, to left of right-Shift
//   0x7E Numpad . key, below Numpad + key
//
//                  Scancode values                      Comment tag
//   Key Number   Set 1  Set 2  Set 3   Character        for tables
//   ----------   ------ ------ ------  ---------------  -----------
//    56 (0x38)    0x73   0x51   0x51   / ? Degree Sign    *56
//   107 (0x6B)    0x7E   0x6D   0x7B   NumPad .           *107
//
// * THE ITALIAN BAV keyboard has two 'extra' keys, 0x7C (00) and 0x7E (000)
//   0x7C Numpad 0 key to left of 00/Ins and 000/Del keys.
//   0x7E Numpad Nul key, below Numpad + key
//   (This is an IBM standard 122-key keyboard, it may not be specifically
//   Italian).
//
//                  Scancode values                      Comment tag
//   Key Number   Set 1  Set 2  Set 3   Character        for tables
//   ----------   ------ ------ ------  ---------------  -----------
//    94 (0x5E)    0x7C   0x68   0x68   NumPad 0           *94
//   107 (0x6B)    0x7E   0x6D   0x7B   Nul                *107
//
// See also ..\..\host\src\nt_keycd.c and
//          ..\..\..\dos\v86\cmd\keyb\keybi9c.asm
//
// The changes I made to the tables in this file are tagged on the relevant
// lines by comments (*56), (*94) and/or (*107) as appropriate.
//                                                                - IanJa.

#endif	/* NTVDM */



#define NUM_LOCK_ADD_ARRAY 127
#define L_SHIFT_ADD_ARRAY 128
#define R_SHIFT_ADD_ARRAY 129
#define CASE_4_SHIFTED_ARRAY 130
#define ALT_CASE_4_ARRAY 131
#define CASE_5_CTRLED_ARRAY 132

#define NUM_LOCK_ADD 7
#define L_SHIFT_ADD 8
#define R_SHIFT_ADD 9
#define CASE_4_SHIFTED 10
#define ALT_CASE_4 11
#define CASE_5_CTRLED 12

#define KEYBOARD_INT_ADAPTER 0
#define KEYBOARD_INT_LINE 1
#define BASE_DELAY_UNIT 5
#define DEFAULT_REPEAT_TARGET 1

#define SET_3_KEY_TYPE_SET_SEQUENCE 1
#define SET_STATUS_INDICATORS_SEQUENCE 2
#define SET_RATE_DELAY_SEQUENCE 3
#define SCAN_CODE_CHANGE_SEQUENCE 4

#define WRITE_8042_CMD_BYTE_SEQUENCE 1
#define WRITE_8042_OUTPUT_PORT_SEQUENCE 2

#define KEY_DOWN_EVENT 1
#define KEY_UP_EVENT 2

#if defined(NEC_98)
#define DEFAULT_SCAN_CODE_SET 1
#else    //NEC_98
#define DEFAULT_SCAN_CODE_SET 2
#endif   //NEC_98

#ifdef REAL_KBD
extern void send_to_real_kbd();
extern void wait_for_ack_from_kb();
#endif

/*
 * Globally available function pointers
 */
GLOBAL VOID ( *host_key_down_fn_ptr )();
GLOBAL VOID ( *host_key_up_fn_ptr )();

#ifndef NTVDM
GLOBAL VOID ( *do_key_repeats_fn_ptr )();
#endif	/* NTVDM */



#if defined(KOREA)
extern BOOL bIgnoreExtraKbdDisable; // To fix HaNa spread sheet IME hot key problem
#endif

/*
 * 6805 code buffer:
 *
 * This is a cyclic buffer storing key events that have been accepted from
 * the host operating system, but not yet requested by the keyboard BIOS.
 *
 * It is equivalent to a 16 byte buffer present in the real keyboard hardware
 * on the PC-AT.
 *
 * We make the physical size of the buffer BUFF_6805_PMAX a power of 2
 * so that a mask BUFF_6805_PMASK can be used to wrap array indices quickly.
 *
 * Each character entered at the keyboard results in at least 3 bytes of
 * event data in the keyboard buffer. Thus the PC-AT's 16 byte buffer allows
 * at most 5 characters to be typed ahead. In practice this is never used
 * as the CPU is always active, allowing character data to be moved almost
 * immediately to the BIOS type ahead buffer.
 *
 * On SoftPC, however, the CPU can become inactive for significant periods;
 * at the same time, the keyboard hardware emulation may be forced to
 * process a large number of keyboard events from the host operating system.
 *
 * In order to give a constant amount of type ahead, regardless of where the
 * type ahead information is stored in SoftPC, we make the virtual size
 * of the hardware buffer BUFF_6805_VMAX 48 bytes long (16 characters X
 * 3 bytes of event data per character).
 */

/*
   18.5.92 MG !!! TEMPORARY HACK !!! To fix windows bugs in Notepad and Word,
   set the buffer to 2k. Windows crashes when the keyboard buffer overflows,
   so we delay this for as long as sensible. It will still crash if you type
   too fast for too long.

   It works OK on a real PC, so the real reason it fails on SoftPC needs to
   be determined one day.

   20.5.92 MG - took out the hack - see below.
*/

#ifdef NTVDM	/* JonLe NT Mod */
#define	BUFF_6805_VMAX	496
#define	BUFF_6805_PMAX	512
#define	BUFF_6805_PMASK	(BUFF_6805_PMAX - 1)
#else
#define	BUFF_6805_VMAX	48
#define	BUFF_6805_PMAX	64
#define	BUFF_6805_PMASK	(BUFF_6805_PMAX - 1)
#endif	/* NTVDM */

#ifndef macintosh
static half_word buff_6805[BUFF_6805_PMAX];
#else
static half_word *buff_6805=NULL;
#endif /* macintosh */
static int buff_6805_in_ptr,buff_6805_out_ptr;

#ifdef NTVDM
static unsigned char key_marker_value = 0;
static unsigned char key_marker_buffer[BUFF_6805_PMAX];
int LastKeyDown= -1;
void Reset6805and8042(void);
#endif

#if defined(IRET_HOOKS) && defined(GISP_CPU)
extern IBOOL HostDelayKbdInt IPT1(char, scancode);
extern IBOOL HostPendingKbdInt IPT1(char *,scancode);
extern void HostResetKdbInts IPT0();

#endif /* IRET_HOOKS && GISP_CPU */

/*
   20.5.92 MG

   Real fix for my temporary hack in the last edition of this file.

   The problem with windows seems to be due to receipt of a huge
   number of overrun characters in a row, so now when we send an overrun
   character we set an 'overrun enable' flag, which is cleared when
   three bytes have been read from the buffer.

   The effect of this is to spread out the overruns, which seems to stop
   the illegal instructions occuring.

   Obviously this may have bad effects on real-mode DOS applications !!!
*/

LOCAL	BOOL	sent_overrun=FALSE;

#ifndef macintosh

#ifndef REAL_KBD
#if defined(NEC_98)
/* make arrays */
static int *make_sizes;
static half_word *make_arrays [144];

/* break arrays */
static int *break_sizes;
static half_word *break_arrays [144];
/* set 3 key states (eg. typematic, make/break, make only, typematic make/break) */
static half_word set_3_key_state [144];
#else   //NEC_98
/* make arrays */
static int *make_sizes;
static half_word *make_arrays [134];

/* break arrays */
static int *break_sizes;
static half_word *break_arrays [134];

/* set 3 key states (eg. typematic, make/break, make only, typematic make/break) */

static half_word set_3_key_state [127];
#endif    //NEC_98
#endif	/* REAL_KBD */

#if defined(NEC_98)
static int key_down_count [144];
static int key_down_dmy  [144];
       int reset_flag;
static int nt_NEC98_caps_state = 0;
static int nt_NEC98_kana_state = 0;
#else   //NEC_98
static int key_down_count [127];
#endif  //NEC_98

#else	/* macintosh */
/* make arrays */
static int *make_sizes;
static half_word **make_arrays;

/* break arrays */
static int *break_sizes;
static half_word **break_arrays;

/* set 3 key states (eg. typematic, make/break, make only, typematic make/break) */

static half_word *set_3_key_state;
static int *key_down_count;

#endif	/* macintosh */

/* anomalous state handling variables */
half_word *anomalous_array;
int anomalous_size, anom_key;
int in_anomalous_state;

/* held events (while doing multiple code 6805 commands) */
#define	HELD_EVENT_MAX	16
int held_event_count;
int held_event_key[HELD_EVENT_MAX];
int held_event_type[HELD_EVENT_MAX];

#ifdef NTVDM 	/* JonLe NTVDM Mod:remove repeat related vars */
int scan_code_6805_size;
half_word key_set;
int input_port_val;
int waiting_for_next_code, waiting_for_next_8042_code, num_lock_on;
#else
int scan_code_6805_size,repeat_delay_target,repeat_target,repeat_delay_count,repeat_count;
half_word key_set;
int typematic_key, input_port_val;
int typematic_key_valid,waiting_for_next_code, waiting_for_next_8042_code, num_lock_on;
#endif	/* NTVDM */
int shift_on, l_shift_on, r_shift_on;
int ctrl_on, l_ctrl_on, r_ctrl_on;
int alt_on, l_alt_on, r_alt_on;
int waiting_for_upcode;
int next_code_sequence_number, next_8042_code_sequence_number, set_3_key_type_change_dest;
GLOBAL int free_6805_buff_size;	/* Must be global for NT VDM */
int translating, keyboard_disabled, int_enabled, output_full;
int pending_8042, keyboard_interface_disabled, scanning_discontinued;
half_word output_contents, pending_8042_value, kbd_status, op_port_remembered_bits, cmd_byte_8042;
half_word *scan_code_6805_array;

#ifdef PM
int gate_a20_status;
#ifndef NTVDM
long reset_was_by_kbd = FALSE;
#endif
#endif

#ifndef NTVDM
LOCAL q_ev_handle       refillDelayedHandle = 0;
#endif

half_word current_light_pattern;

#ifdef macintosh
/*
** The Mac cannot cope with loads of global data. So declare these
** as pointers and load the tables up from a Mac resource.
*/
half_word *scan_codes_temp_area;
half_word *keytypes;
int       *set_1_make_sizes, *set_2_make_sizes, *set_3_make_sizes;
int       *set_1_break_sizes, *set_2_break_sizes, *set_3_break_sizes;
half_word *trans_8042, *set_3_reverse_lookup, *set_3_default_key_state, *most_set_2_make_codes;
half_word *most_set_3_make_codes, *set_1_extra_codes, *set_2_extra_codes, *set_3_extra_codes;
half_word *set_1_extra_bk_codes, *set_2_extra_bk_codes, *set_3_extra_bk_codes, *buff_overrun_6805;
half_word *most_set_1_make_codes;

#else

half_word scan_codes_temp_area[300];

#ifndef REAL_KBD
/* Data Tables */

#if defined(NEC_98)
static half_word keytypes[144] =
{ 0,0,0,0,0,0,0,0,0,0,  /* 0-9 */
  0,0,0,0,0,0,0,0,0,0,  /* 10-19 */
  0,0,0,0,0,0,0,0,0,0,  /* 20-29 */
  0,0,0,0,0,0,0,0,0,0,  /* 30-39 */
  0,0,0,0,0,0,0,0,0,0,  /* 40-49 */
  0,0,0,0,0,0,0,0,0,0,  /* 50-59 */
  0,0,0,0,0,0,0,0,0,0,  /* 60-69 */
  0,0,0,0,0,0,0,0,0,0,  /* 70-79 */
  0,0,0,0,0,0,0,0,0,0,  /* 80-89 */
  0,0,0,0,0,0,0,0,0,0,  /* 90-99 */
  0,0,0,0,0,0,0,0,0,0,  /* 100-109 */
  0,0,0,0,0,0,0,0,0,0,  /* 110-119 */
  0,0,0,0,0,0,0,0,0,0,  /* 120-129 */
  0,0,0,0,0,0,0,0,0,0,  /* 130-139 */
  0,0,0,0               /* 140-143 */
};

static int set_1_make_sizes [13]=
{ 1,1,1,1,1,1,          /* categories 1 to 6 inclusive */
  0,                    /* size for error case - non existant key */
  1,                    /* Num lock add size */
  1,                    /* Left shift add size */
  1,                    /* Right shift add size */
  1,                    /* Case 4 shifted size */
  1,                    /* Alt Case 4 size */
  1                     /* Case 5 ctrled size */
};

#else   //NEC_98
/*
 * The meaning of the keytype values as far as I can tell (IanJa) :
 *
 *   1 = extended key (rh Alt, rh Ctrl, Numpad Enter)
 *   2 = grey cursor movement keys (Insert, Home, Delete, up arrow etc.
 *   3 = NumPad /
 *   4 = Print Screen/SysRq
 *   5 = pause/Break
 *   6 = not a key
 */
static half_word keytypes[127] =
{ 0,0,0,0,0,0,0,0,0,0,  /* 0-9 */
  0,0,0,0,6,0,0,0,0,0,  /* 10-19 */
  0,0,0,0,0,0,0,0,0,0,  /* 20-29 */
  0,0,0,0,0,0,0,0,0,0,  /* 30-39 */
  0,0,0,0,0,0,0,0,0,0,  /* 40-49 */
#ifdef	JAPAN
  0,0,0,0,0,0,0,0,0,0,  /* 50-59 */
  0,0,1,6,1,0,0,0,0,0,  /* 60-69 */
#else // !JAPAN
  0,0,0,0,0,0,0,0,0,6,  /* 50-59 (*56) */
  0,0,1,6,1,6,6,6,6,6,  /* 60-69 */
#endif // !JAPAN
  6,6,6,6,6,2,2,6,6,2,  /* 70-79 */
  2,2,6,2,2,2,2,6,6,2,  /* 80-89 */
  0,0,0,0,0,3,0,0,0,0,  /* 90-99 (*94) */
  0,0,0,0,0,0,0,0,1,6,  /* 100-109 (*107) */
  0,6,0,0,0,0,0,0,0,0,  /* 110-119 */
  0,0,0,0,4,0,5         /* 120-126 */
};

static int set_1_make_sizes [13]=
{ 1,2,2,2,4,6,		/* categories 1 to 6 inclusive */
  0,			/* size for error case - non existant key */
  2,			/* Num lock add size */
  2,			/* Left shift add size */
  2,			/* Right shift add size */
  2,			/* Case 4 shifted size */
  1,			/* Alt Case 4 size */
  4			/* Case 5 ctrled size */
};
#endif   //NEC_98

static int set_2_make_sizes [13]=
{ 1,2,2,2,4,8,		/* categories 1 to 6 inclusive */
  0,			/* size for error case - non existant key */
  2,			/* Num lock add size */
  3,			/* Left shift add size */
  3,			/* Right shift add size */
  2,			/* Case 4 shifted size */
  1,			/* Alt Case 4 size */
  5			/* Case 5 ctrled size */
};

static int set_3_make_sizes [13]=
{ 1,1,1,1,1,1,		/* categories 1 to 6 inclusive */
  0,			/* size for error case - non existant key */
  0,			/* Num lock add size */
  0,			/* Left shift add size */
  0,			/* Right shift add size */
  1,			/* Case 4 shifted size */
  1,			/* Alt Case 4 size */
  1			/* Case 5 ctrled size */
};

#if defined(NEC_98)

static int set_1_break_sizes [13]=
{ 1,1,1,1,1,1,          /* categories 1 to 6 inclusive */
  0,                    /* size for error case - non existant key */
  1,                    /* Num lock add size */
  1,                    /* Left shift add size */
  1,                    /* Right shift add size */
  1,                    /* Case 4 shifted size */
  1,                    /* Alt Case 4 size */
  1                     /* Case 5 ctrled size */
};

#else    //NEC_98
static int set_1_break_sizes [13]=
{ 1,2,2,2,4,0,		/* categories 1 to 6 inclusive */
  0,			/* size for error case - non existant key */
  2,			/* Num lock add size */
  2,			/* Left shift add size */
  2,			/* Right shift add size */
  2,			/* Case 4 shifted size */
  1,			/* Alt Case 4 size */
  0			/* Case 5 ctrled size */
};
#endif    //NEC_98

static int set_2_break_sizes [13]=
{ 2,3,3,3,6,0,		/* categories 1 to 6 inclusive */
  0,			/* size for error case - non existant key */
  3,			/* Num lock add size */
  2,			/* Left shift add size */
  2,			/* Right shift add size */
  3,			/* Case 4 shifted size */
  2,			/* Alt Case 4 size */
  0			/* Case 5 ctrled size */
};

static int set_3_break_sizes [13]=
{ 2,2,2,2,2,0,		/* categories 1 to 6 inclusive */
  0,			/* size for error case - non existant key */
  0,			/* Num lock add size */
  0,			/* Left shift add size */
  0,			/* Right shift add size */
  2,			/* Case 4 shifted size */
  2,			/* Alt Case 4 size */
  2			/* Case 5 ctrled size */
};

#endif

/*
 * Map Scancode Set 2 into Scancode Set 1 values: index into this table with
 * a scancode set 2 to get the corresponding scancode set 1 value.
 * Non-existent Set 2 scancodes have entry == Set 2 value (trans_8042[x] == x)
 */
static half_word trans_8042 [256] =
{ 0xff,0x43,0x02,0x3f,0x3d,0x3b,0x3c,0x58,0x64,0x44,0x42,0x40,0x3e,0x0f,0x29,0x59,		/* 00-0f */
  0x65,0x38,0x2a,0x70,0x1d,0x10,0x02,0x5A,0x66,0x71,0x2c,0x1f,0x1e,0x11,0x03,0x5b,		/* 10-1f */
  0x20,0x2e,0x2d,0x20,0x12,0x05,0x04,0x5c,0x68,0x39,0x2f,0x21,0x14,0x13,0x06,0x5d,		/* 20-2f */
  0x69,0x31,0x30,0x23,0x22,0x15,0x07,0x5e,0x6a,0x72,0x32,0x24,0x16,0x08,0x09,0x5f,		/* 30-3f */
  0x6b,0x33,0x25,0x17,0x18,0x0b,0x0a,0x60,0x6c,0x34,0x35,0x26,0x27,0x19,0x0c,0x61,		/* 40-4f */
  0x6d,0x73,0x28,0x74,0x1a,0x0d,0x62,0x6e,0x3a,0x36,0x1c,0x1b,0x75,0x2b,0x6e,0x76,		/* 50-5f */
  0x55,0x56,0x77,0x78,0x79,0x7a,0x0e,0x7b,0x7c,0x4f,0x7d,0x4b,0x47,0x7e,0x7f,0x6f,    		/* 60-6f */
  0x52,0x53,0x50,0x4c,0x4d,0x48,0x01,0x45,0x57,0x4e,0x51,0x4a,0x37,0x49,0x46,0x54,		/* 70-7f */
  0x80,0x81,0x82,0x41,0x54,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,		/* 80-8f */
#ifdef	JAPAN
  0x7d,0x5a,0x5b,0x73,0x70,0x79,0x7b,0x77,0x71,0x72,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,		/* 90-9f */
#else // !JAPAN
  0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,		/* 90-9f */
#endif // !JAPAN
  0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,		/* a0-af */
  0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,		/* b0-bf */
  0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,		/* c0-cf */
  0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,		/* d0-df */
  0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,		/* e0-ef */
  0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff 		/* f0-ff */
};

#ifndef REAL_KBD
/*
 * Index with Scancode Set 3 to get keyboard position number.
 */
static half_word set_3_reverse_lookup [256]=
{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x6e,0x00,0x00,0x00,0x00,0x10,0x01,0x71,		/* 00-0f */
  0x00,0x3a,0x2c,0x2d,0x1e,0x11,0x02,0x72,0x00,0x3c,0x2e,0x20,0x1f,0x12,0x03,0x73,		/* 10-1f */
  0x00,0x30,0x2f,0x21,0x13,0x05,0x04,0x74,0x00,0x3d,0x31,0x22,0x15,0x14,0x06,0x75,		/* 20-2f */
  0x00,0x33,0x32,0x24,0x23,0x16,0x07,0x76,0x00,0x3e,0x34,0x25,0x17,0x08,0x09,0x77,		/* 30-3f */
  0x00,0x35,0x26,0x18,0x19,0x0b,0x0a,0x78,0x00,0x36,0x37,0x27,0x28,0x1a,0x0c,0x79,		/* 40-4f */
  0x00,0x38,0x29,0x2a,0x1b,0x0d,0x7a,0x7c,0x40,0x39,0x2b,0x1c,0x1d,0x00,0x7b,0x7d,		/* 50-5f (*56) */
  0x54,0x4f,0x7e,0x53,0x4c,0x51,0x0f,0x4b,0x5e,0x5d,0x59,0x5c,0x5b,0x56,0x50,0x55,		/* 60-6f (*94) */
  0x63,0x68,0x62,0x61,0x66,0x60,0x5a,0x5f,0x00,0x6c,0x67,0x6b,0x6a,0x65,0x64,0x00,		/* 70-7f (*107) */
  0x00,0x00,0x00,0x00,0x69,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,		/* 80-8f */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,		/* 90-9f */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,		/* a0-af */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,		/* b0-bf */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,		/* c0-cf */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,		/* d0-df */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,		/* e0-ef */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 		/* f0-ff */
};

/*
 * index by key number to get default key state:
 *   0 = not a key, 1 = typematic,  2 = make/break,  3 = make only
 */
static half_word set_3_default_key_state [127]=
{ 0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,		/* 00-0f */
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x01,		/* 10-1f */
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x01,0x01,0x01,		/* 20-2f */
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x00,0x02,0x01,0x03,0x00,		/* 30-3f (*56) */
  0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x01,0x00,0x00,0x01,		/* 40-4f */
  0x03,0x03,0x00,0x01,0x01,0x03,0x03,0x00,0x00,0x01,0x03,0x03,0x03,0x03,0x03,0x03,		/* 50-5f */
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x01,0x01,0x03,0x00,0x03,0x00,		/* 60-6f (*107) */
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03           		/* 70-7d */
};

/*
 * Index by key number, to get scancode set 1 (0 if none)
 */
#if defined(NEC_98)

static half_word most_set_1_make_codes [144]=
{ 0xFF,0x1A,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x26,0x00,0x0E,    /* 00-0f */
  0x0F,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1B,0x28,0x00,0x71,0x1D,    /* 10-1f */
  0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,0x25,0x27,0x0C,0x0D,0x1C,0x70,0xFF,0x29,0x2A,    /* 20-2f */
#if 1                                             // for 106 keyboard 950407
  0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x32,0xFF,0x70,0x74,0xFF,0x73,0x34,0x73,0x74,    /* 30-3f */  //BugFix #108131
  0x73,0xFF,0xFF,0xFF,0xFF,0x72,0xFF,0xFF,0xFF,0xFF,0xFF,0x38,0x39,0xFF,0xFF,0x3B,    /* 40-4f */
#else                                             // for 106 keyboard 950407
  0x2B,0x2C,0x2D,0x2E,0x2F,0x30,0x31,0x32,0xFF,0xFF,0x74,0xFF,0x73,0x34,0x35,0xFF,    /* 30-3f */
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x38,0x39,0xFF,0xFF,0x3B,    /* 40-4f */
#endif                                            // for 106 keyboard 950407
  0x3E,0x3F,0xFF,0x3A,0x3D,0x37,0x36,0xFF,0xFF,0x3C,0xFF,0x42,0x46,0x4A,0xFF,0x41,    /* 50-5f */
  0x43,0x47,0x4B,0x4E,0x45,0x44,0x48,0x4C,0x50,0x40,0x49,0xFF,0x1C,0xFF,0x00,0xFF,    /* 60-6f */
  0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x52,0x53,0x0D,0xFF,0xFF,0x33,    /* 70-7f */
  0x4D,0x51,0x35,0x4F,0x54,0x55,0x56,0x72,0x61,0x60,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF     /* 80-8f */  //BugFix #108131
};

#else    //NEC_98
static half_word most_set_1_make_codes [127]=
{ 0x00,0x29,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x7d,0x0e,		/* 00-0f */
  0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x2b,0x3a,0x1e,		/* 10-1f */
  0x1f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x2b,0x1c,0x2a,0x56,0x2c,0x2d,		/* 20-2f */
  0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,0x35,0x73,0x36,0x1d,0x00,0x38,0x39,0x38,0x00,		/* 30-3f (*56) */
  0x1d,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x52,0x53,0x00,0x00,0x4b,		/* 40-4f */
  0x47,0x4f,0x00,0x48,0x50,0x49,0x51,0x00,0x00,0x4d,0x45,0x47,0x4b,0x4f,0x7c,0x35,		/* 50-5f */
  0x48,0x4c,0x50,0x52,0x37,0x49,0x4d,0x51,0x53,0x4a,0x4e,0x7e,0x1c,0x00,0x01,0x00,		/* 60-6f (*107) */
  0x3b,0x3c,0x3d,0x3e,0x3f,0x40,0x41,0x42,0x43,0x44,0x57,0x58,0x00,0x46,0x00			/* 70-7e */
};
#endif    //NEC_98

static half_word most_set_2_make_codes [127]=
{ 0x00,0x0e,0x16,0x1e,0x26,0x25,0x2e,0x36,0x3d,0x3e,0x46,0x45,0x4e,0x55,0x6a,0x66,		/* 00-0f */
  0x0d,0x15,0x1d,0x24,0x2d,0x2c,0x35,0x3c,0x43,0x44,0x4d,0x54,0x5b,0x5d,0x58,0x1c,		/* 10-1f */
#ifdef	JAPAN
  0x1b,0x23,0x2b,0x34,0x33,0x3b,0x42,0x4b,0x4c,0x52,0x5d,0x5a,0x12,0x90,0x1a,0x22,		/* 20-2f */
  0x21,0x2a,0x32,0x31,0x3a,0x41,0x49,0x4a,0x93,0x59,0x14,0x97,0x11,0x29,0x11,0x00,		/* 30-3f */
  0x14,0x91,0x92,0x95,0x96,0x94,0x00,0x00,0x00,0x00,0x00,0x70,0x71,0x00,0x00,0x6b,		/* 40-4f */
#else // !JAPAN
  0x1b,0x23,0x2b,0x34,0x33,0x3b,0x42,0x4b,0x4c,0x52,0x5d,0x5a,0x12,0x61,0x1a,0x22,		/* 20-2f */
  0x21,0x2a,0x32,0x31,0x3a,0x41,0x49,0x4a,0x51,0x59,0x14,0x00,0x11,0x29,0x11,0x00,		/* 30-3f (*56) */
  0x14,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x71,0x00,0x00,0x6b,		/* 40-4f */
#endif // !JAPAN
  0x6c,0x69,0x00,0x75,0x72,0x7d,0x7a,0x00,0x00,0x74,0x77,0x6c,0x6b,0x69,0x68,0x4a,		/* 50-5f */
  0x75,0x73,0x72,0x70,0x7c,0x7d,0x74,0x7a,0x71,0x7b,0x79,0x6d,0x5a,0x00,0x76,0x00,		/* 60-6f (*107) */
  0x05,0x06,0x04,0x0c,0x03,0x0b,0x83,0x0a,0x01,0x09,0x78,0x07,0x00,0x7e,0x00			/* 70-7e */
};

static half_word most_set_3_make_codes [127]=
{ 0x00,0x0e,0x16,0x1e,0x26,0x25,0x2e,0x36,0x3d,0x3e,0x46,0x45,0x4e,0x55,0x5d,0x66,		/* 00-0f */
  0x0d,0x15,0x1d,0x24,0x2d,0x2c,0x35,0x3c,0x43,0x44,0x4d,0x54,0x5b,0x5c,0x14,0x1c,		/* 10-1f */
  0x1b,0x23,0x2b,0x34,0x33,0x3b,0x42,0x4b,0x4c,0x52,0x53,0x5a,0x12,0x13,0x1a,0x22,		/* 20-2f */
  0x21,0x2a,0x32,0x31,0x3a,0x41,0x49,0x4a,0x51,0x59,0x11,0x00,0x19,0x29,0x39,0x00,		/* 30-3f (*56) */
  0x58,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x67,0x64,0x00,0x00,0x61,		/* 40-4f */
  0x6e,0x65,0x00,0x63,0x60,0x6f,0x6d,0x00,0x00,0x6a,0x76,0x6c,0x6b,0x69,0x68,0x77,		/* 50-5f */
  0x75,0x73,0x72,0x70,0x7e,0x7d,0x74,0x7a,0x71,0x84,0x7c,0x7b,0x79,0x00,0x08,0x00,		/* 60-6f (*107) */
  0x07,0x0f,0x17,0x1f,0x27,0x2f,0x37,0x3f,0x47,0x4f,0x56,0x5e,0x57,0x5f,0x62			/* 70-7e */
};

static half_word set_1_extra_codes []=
{ 0xe0,0x2a,0xe0,0x37,				/* Case 4 norm */
  0xe1,0x1d,0x45,0xe1,0x9d,0xc5,		/* Case 5 norm */
  						/* Error case -non existant (empty) */
  0xe0,0x2a,					/* Num lock add sequence */
  0xe0,0xaa,					/* Left shift add sequence */
  0xe0,0xb6,					/* Right shift add sequence */
  0xe0,0x37,					/* case 4 shifted */
  0x54,						/* Alt case 4 */
  0xe0,0x46,0xe0,0xc6				/* Case 5 ctrled */
};

static half_word set_2_extra_codes []=
{ 0xe0,0x12,0xe0,0x7c,				/* Case 4 norm */
  0xe1,0x14,0x77,0xe1,0xf0,0x14,0xf0,0x77,	/* Case 5 norm */
  						/* Error case -non existant (empty) */
  0xe0,0x12,					/* Num lock add sequence */
  0xe0,0xf0,0x12,				/* Left shift add sequence */
  0xe0,0xf0,0x59,				/* Right shift add sequence */
  0xe0,0x7c,					/* case 4 shifted */
  0x84,						/* Alt case 4 */
  0xe0,0x7e,0xe0,0xf0,0x7e			/* Case 5 ctrled */
};


static half_word set_3_extra_codes []=
{ 0x57,						/* Case 4 norm */
  0x62,						/* Case 5 norm */
  						/* Error case -non existant (empty) */
    						/* Num lock add sequence (empty) */
  						/* Left shift add sequence (empty) */
  						/* Right shift add sequence (empty) */
  0x57,						/* case 4 shifted */
  0x57,						/* Alt case 4 */
  0x62						/* Case 5 ctrled */
};


static half_word set_1_extra_bk_codes []=
{ 0xe0,0xb7,0xe0,0xaa,				/* Case 4 norm */
  						/* Case 5 norm (empty) */
  						/* Error case -non existant (empty) */
  0xe0,0xaa,					/* Num lock add sequence */
  0xe0,0x2a,					/* Left shift add sequence */
  0xe0,0x36,					/* Right shift add sequence */
  0xe0,0xb7,					/* case 4 shifted */
  0xd4,						/* Alt case 4 */
  						/* Case 5 ctrled (empty) */
};

static half_word set_2_extra_bk_codes []=
{ 0xe0,0xf0,0x7c,0xe0,0xf0,0x12,		/* Case 4 norm */
  						/* Case 5 norm (empty) */
  						/* Error case -non existant (empty) */
  0xe0,0xf0,0x12,				/* Num lock add sequence */
  0xe0,0x12,					/* Left shift add sequence */
  0xe0,0x59,					/* Right shift add sequence */
  0xe0,0xf0,0x7c,				/* case 4 shifted */
  0xf0,0x84					/* Alt case 4 */
  						/* Case 5 ctrled (empty) */
};


static half_word set_3_extra_bk_codes []=
{ 0xf0,0x57,					/* Case 4 norm */
  						/* Case 5 norm (empty) */
  						/* Error case -non existant (empty) */
    						/* Num lock add sequence (empty) */
  						/* Left shift add sequence (empty) */
  						/* Right shift add sequence (empty) */
  0xf0,0x57,					/* case 4 shifted */
  0xf0,0x57,					/* Alt case 4 */
  0xf0,0x62					/* Case 5 ctrled */
};
#endif

static half_word buff_overrun_6805 [4]=
{
  0,0xff,0,0
};

#endif /* macintosh */

#ifdef SECURE /* { */
/*
 * This table 'secure_keytab' identifies certain characters which
 * need special treatment by Secure SoftWindows.   The table is
 * indexed by keycodes, as used by the ROM routine for the U.S. English
 * keyboard.   These codes are defined in IBM Personal Computer AT
 * Hardware Technical Reference, Section 5 System BIOS Keyboard
 * Encoding and Usage.
 *
 * Characters requiring special treatment include Ctrl-Alt-DEL,
 * Ctrl-C and the others, including keys which modify the Boot.
 * Such keys require different treatment, but can be grouped into
 * about 4 different ActionClasses.
 * Any key which would generate an undesirable code has the action
 * bit set, along with the ActionClass number.   Additionally the
 * modifier keys are also tracked with this table.
 */

#define SEC_ACTCLASS	0x07
/* Action Classes have to be sequential from 0,
 * as they are used as an index into function
 * tables 'down_class' and 'up_class'
 */
#define SEC_CLASS_0	0x00
#define SEC_CLASS_1	0x01
#define SEC_CLASS_2	0x02
#define SEC_CLASS_3	0x03
#define SEC_CLASS_4	0x04
#define SEC_CLASS_5	0x05
#define SEC_CLASS_6	0x06
#define SEC_CLASS_7	0x07
#define SEC_ACTION	0x08
#define SEC_CTRL_L	0x10
#define SEC_CTRL_R	0x20
#define SEC_ALT_L	0x40
#define SEC_ALT_R	0x80
#define SEC_MOD_MASK	(SEC_CTRL_L|SEC_CTRL_R|SEC_ALT_L|SEC_ALT_R)

LOCAL IU8 secure_keytab [] = {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* 0-15 */
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* 16-31 */
	0,0,0,0,0,0,0,0,0,0,0,0,        	/* 32-43 */
	SEC_ACTION|SEC_CLASS_3,         	/* 44(LShft) Boot Modifier. */
	0,0,0,                          	/* 45-47 */
	SEC_ACTION|SEC_CLASS_2,         	/* 48("C") Used with Cntrl. */
	0,0,0,0,0,0,0,0,                	/* 49-56 */
	SEC_ACTION|SEC_CLASS_3,         	/* 57(RShft) Boot Modifier. */
	SEC_CTRL_L,0,SEC_ALT_L,0,       	/* 58-61 */
	SEC_ALT_R,0,SEC_CTRL_R,         	/* 62-64 */
	0,0,0,0,0,0,0,0,0,0,0,          	/* 65-75 */
	SEC_ACTION|SEC_CLASS_0,         	/* 76(Delete) */
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,    	/* 77-90 */
	SEC_ACTION|SEC_CLASS_1,         	/* 91(KeyPad 7) */
	SEC_ACTION|SEC_CLASS_1,         	/* 92(KeyPad 4) */
	SEC_ACTION|SEC_CLASS_1,         	/* 93(KeyPad 1) */
	0,0,                            	/* 94-95 */
	SEC_ACTION|SEC_CLASS_1,         	/* 96(KeyPad 8) */
	SEC_ACTION|SEC_CLASS_1,         	/* 97(KeyPad 5) */
	SEC_ACTION|SEC_CLASS_1,         	/* 98(KeyPad 2) */
	SEC_ACTION|SEC_CLASS_1,         	/* 99(KeyPad 0) */
	0,                              	/* 100 */
	SEC_ACTION|SEC_CLASS_1,         	/* 101(KeyPad 9) */
	SEC_ACTION|SEC_CLASS_1,         	/* 102(KeyPad 6) */
	SEC_ACTION|SEC_CLASS_1,         	/* 103(KeyPad 3) */
	SEC_ACTION|SEC_CLASS_0,         	/* 104(KeyPad . DEL) */
	0,0,0,0,0,0,0,                  	/* 105-111 */
	SEC_ACTION|SEC_CLASS_3,         	/* 112(F1) */
	SEC_ACTION|SEC_CLASS_3,         	/* 113(F2) */
	SEC_ACTION|SEC_CLASS_3,         	/* 114(F3) */
	SEC_ACTION|SEC_CLASS_3,         	/* 115(F4) */
	SEC_ACTION|SEC_CLASS_3,         	/* 116(F5) */
	SEC_ACTION|SEC_CLASS_3,         	/* 117(F6) */
	SEC_ACTION|SEC_CLASS_3,         	/* 118(F7) */
	SEC_ACTION|SEC_CLASS_3,         	/* 119(F8) */
	SEC_ACTION|SEC_CLASS_3,         	/* 120(F9) */
	SEC_ACTION|SEC_CLASS_3,         	/* 121(F10) */
	SEC_ACTION|SEC_CLASS_3,         	/* 122(F11) */
	SEC_ACTION|SEC_CLASS_3,         	/* 123(F12) */
	0,0,                            	/* 124-125 */
	SEC_ACTION|SEC_CLASS_2,         	/* 126(Break) */
	0                               	/* 127 */
};
#endif /* SECURE } */

LOCAL VOID calc_buff_6805_left IPT0();
LOCAL VOID do_host_key_down IPT1( int,key );
LOCAL VOID do_host_key_up IPT1( int,key );
LOCAL VOID codes_to_translate IPT0();
GLOBAL VOID continue_output IPT0();
LOCAL VOID cmd_to_8042 IPT1( half_word,cmd_code );
LOCAL VOID cmd_to_6805 IPT1( half_word,cmd_code );
#ifndef HUNTER
LOCAL INT buffer_status_8042 IPT0();
#endif

#ifdef SECURE /* { */
/* Track the Modifier keys. */
LOCAL IU8 keys_down = 0;

/* Track which key downs have been supressed. */
LOCAL IU8 keys_suppressed [0x80] = {0};

/* Forward declarations keep compiler happy. */
LOCAL VOID filtered_host_key_down IPT1(int,key);
LOCAL VOID filtered_host_key_up IPT1(int,key);

/* Here are the functions for handling special keys. */
LOCAL VOID filt_dwn_reboot IFN1(int, key)
{
	/* The key is only nasty if Cntrl and Alt are down. */
	if ((keys_down & (SEC_CTRL_L | SEC_CTRL_R)) != 0 &&
	    (keys_down & (SEC_ALT_L  | SEC_ALT_R )) != 0 )
	{
		keys_suppressed[key] = 1;
	}
	else
	{
		filtered_host_key_down(key);
	}
}
LOCAL VOID filt_dwn_kpad_numerics IFN1(int, key)
{
	/* The keys are only nasty if Alt is down. */
	if ((keys_down & (SEC_CTRL_L | SEC_CTRL_R)) == 0 &&
	    (keys_down & (SEC_ALT_L  | SEC_ALT_R )) != 0 )
	{
		keys_suppressed[key] = 1;
	}
	else
	{
		filtered_host_key_down(key);
	}
}
LOCAL VOID filt_dwn_breaks IFN1(int, key)
{
	/*
	 * The keys are only nasty if Control is down.
	 * The upness of the Alt key is not checked as the
	 * typematic feature would allow ALT-CTRL-C to be held
	 * down, then ALT could be released to deliver a stream
	 * of CTRL-C.
	 */
	if ((keys_down & (SEC_CTRL_L | SEC_CTRL_R)) != 0)
	{
		keys_suppressed[key] = 1;
	}
	else
	{
		filtered_host_key_down(key);
	}
}
LOCAL VOID filt_dwn_boot_mods IFN1(int, key)
{
	/* The keys are only nasty if in Boot mode. */
	if (!has_boot_finished())
	{
		keys_suppressed[key] = 1;
	}
	else
	{
		filtered_host_key_down(key);
	}
}
LOCAL VOID filt_dwn_supress_up IFN1(int, key)
{
	if (keys_suppressed[key])
	{
		/* Key down was suppressed, do not forward key-up. */
		keys_suppressed[key] = 0;
	}
	else
	{
		filtered_host_key_up(key);
	}
}

/*
 * The following function table is indexed by the Action Class,
 * as defined in secure_keytab[].
 */
LOCAL VOID (*down_class[]) IPT1(int, key) = {
	filt_dwn_reboot,
	filt_dwn_kpad_numerics,
	filt_dwn_breaks,
	filt_dwn_boot_mods,
	filtered_host_key_down,
	filtered_host_key_down,
	filtered_host_key_down,
	filtered_host_key_down
};
LOCAL VOID (*up_class[]) IPT1(int, key) = {
	filt_dwn_supress_up,
	filt_dwn_supress_up,
	filt_dwn_supress_up,
	filt_dwn_supress_up,
	filtered_host_key_up,
	filtered_host_key_up,
	filtered_host_key_up,
	filtered_host_key_up
};
#endif /* SECURE } */

/*
 * 6805 code buffer access procedures
 */

/*(
=============================== keyba_running ==================================
PURPOSE:
	This access function is used to by other modules to check whether
keyba.c is currently passing on keyboard events, or whether it is buffering
them.  This allows calling functions to avoid filling up keyba's buffers.

INPUT:
None.

OUTPUT:
The return value is true if keystrokes are being passed on.

ALGORITHM:
If the scanning_discontinued flag is set, or if the 6905 buffer is not
empty, FALSE is returned.
================================================================================
)*/
GLOBAL BOOL
keyba_running IFN0()
{
	if (scanning_discontinued || (buff_6805_in_ptr != buff_6805_out_ptr))
		return(FALSE);
	else
		return(TRUE);
}

#define QUEUED_OUTPUT    0
#define IMMEDIATE_OUTPUT 1

LOCAL VOID add_to_6805_buff IFN2(half_word,code,int, immediate)
/* immediate --->   = 0 queue on buffer end,
		    = 1 queue on buffer start */
	{
   /* iff room in buffer */
   if (((buff_6805_out_ptr -1)& BUFF_6805_PMASK) != buff_6805_in_ptr)
      {
      if ( immediate )
	 {
	 /* queue at start */
	 buff_6805_out_ptr = (buff_6805_out_ptr - 1) & BUFF_6805_PMASK;
	 buff_6805[buff_6805_out_ptr]=code;
	 }
      else
	 {
	 /* queue at end */
	buff_6805[buff_6805_in_ptr]=code;
	buff_6805_in_ptr = (buff_6805_in_ptr + 1) & BUFF_6805_PMASK;
	}
      }
   calc_buff_6805_left();

#ifdef NTVDM	/* JonLe NTVDM Mod */
   KbdHdwFull = BUFF_6805_VMAX - free_6805_buff_size;
#endif	/* NTVDM */

   } /* end of add_to_6805_buff */

static half_word remove_from_6805_buff IFN0()
{
half_word ch;

ch=buff_6805[buff_6805_out_ptr];

#ifdef NTVDM
	key_marker_buffer[buff_6805_out_ptr]=0;
#endif

if (buff_6805_out_ptr != buff_6805_in_ptr)
	{
	buff_6805_out_ptr = (buff_6805_out_ptr +1) & BUFF_6805_PMASK;
	}
calc_buff_6805_left();

#ifdef NTVDM
   KbdHdwFull = BUFF_6805_VMAX - free_6805_buff_size;
#endif	/* NTVDM */

return (ch);
} /* end of remove_from_6805_buff */


LOCAL VOID clear_buff_6805 IFN0()
{
	/* 18/5/92 MG On a macintosh, allocate buffer space so that we're
	   not grabbing it from the global allocation. */

#ifdef macintosh
	if (buff_6805==NULL) {
		check_malloc(buff_6805,BUFF_6805_PMAX,half_word);
	}
#endif /* macintosh */

	buff_6805_in_ptr=buff_6805_out_ptr;
	free_6805_buff_size=BUFF_6805_VMAX;

#ifdef NTVDM
    KbdHdwFull = BUFF_6805_VMAX - free_6805_buff_size;

    /* Clear key marker buffer */
    {
	register int loop = sizeof(key_marker_buffer) / sizeof(unsigned char);
	while(--loop >= 0) key_marker_buffer[loop] = 0;
    }
#endif	/* NTVDM */
}

#ifdef NTVDM

#define ONECHARCODEMASK (0x80)

LOCAL VOID mark_key_codes_6805_buff IFN1(int, start)
{
   static int start_offset;

   /* Room in buffer */
   if(((buff_6805_out_ptr -1)& BUFF_6805_PMASK) != buff_6805_in_ptr)
   {

	/* Bump key start/end marker is start of seq */
	if(start)
	{
	    start_offset = buff_6805_in_ptr;
#if defined(NEC_98)
            if(++key_marker_value > 144) key_marker_value = 1;
#else    //NEC_98
	    if(++key_marker_value > 127) key_marker_value = 1;
#endif   //NEC_98
	}
	else
	{
	    /* End of seq, mark first & last byte */

	    if(start_offset != buff_6805_in_ptr)
	    {

		key_marker_buffer[start_offset] = key_marker_value;

		if(((buff_6805_in_ptr -1)& BUFF_6805_PMASK) == start_offset)
		{
		key_marker_buffer[(buff_6805_in_ptr -1)& BUFF_6805_PMASK] =
				  key_marker_value | ONECHARCODEMASK;
		}
		else
		{
		/* mult byte seq */

		key_marker_buffer[(buff_6805_in_ptr -1)& BUFF_6805_PMASK] =
				  key_marker_value;
		}
	    }
	}
   }
}

/*
 * This function returns the number of keys in the 6805 buffers
 * and also clears down these buffers
 */

GLOBAL int keys_in_6805_buff(int *part_key_transferred)
{
    int keys_in_buffer = held_event_count;  /* key to yet processed by adapter */
    int tmp_6805_out_ptr;
    char last_marker = 0;

    *part_key_transferred = FALSE;

    for(tmp_6805_out_ptr = buff_6805_out_ptr;
	tmp_6805_out_ptr != buff_6805_in_ptr;
	tmp_6805_out_ptr = (tmp_6805_out_ptr +1) & BUFF_6805_PMASK)
    {
	if(key_marker_buffer[tmp_6805_out_ptr] != 0)
	{
	    if(last_marker == 0)
	    {
		/* start of key seq found */
		if(key_marker_buffer[tmp_6805_out_ptr] & ONECHARCODEMASK)
		    keys_in_buffer++; /* one byte seq	    else */
		    last_marker = key_marker_buffer[tmp_6805_out_ptr];
	    }
	    else
	    {
		if(key_marker_buffer[tmp_6805_out_ptr] == last_marker)
		{
		    keys_in_buffer++;/* End of key seq found, bump key count */
		    last_marker = 0; /* no longer in middle of key seq */
		}
		else
		{
		    /* Scan terminate early, part key seq found */
		    *part_key_transferred = TRUE;
		    last_marker = key_marker_buffer[tmp_6805_out_ptr];
		}
	    }
	}
    }

    /* Terminated scan in middle of key seq ??? */
    if(last_marker) *part_key_transferred = TRUE;


    /* Is there currently a key in the one char 8042 buffer */
    if(output_full)
    {
	keys_in_buffer++;
    }

    Reset6805and8042();

    return(keys_in_buffer);
}

void Reset6805and8042(void)
{
    int key;

    /* Reset 6805 */

    buff_6805_out_ptr=0;
    clear_buff_6805();
    current_light_pattern=0;

    //Removed, function call attempts to push characters back into
    //the keyboard adapter, just as we are trying to reset it.
    //This problem could be fixed by clearing the keyboard interrupt
    //line after the following function call (DAB)
    //host_kb_light_on(7);

#if defined(NEC_98)
    for(key = 0; key < 144; key++)
    {
        set_3_key_state [key] = most_set_1_make_codes[key];
        key_down_dmy[key] = key_down_count[key];
    }
#else    //NEC_98
    for(key = 0; key < 127; key++)
    {
	set_3_key_state [key] = set_3_default_key_state[key];
	key_down_count[key]=0;
    }
#endif  //NEC_98

    waiting_for_next_code=waiting_for_next_8042_code=FALSE;

    shift_on = l_shift_on = r_shift_on = FALSE;
    ctrl_on = l_ctrl_on = r_ctrl_on = FALSE;
    alt_on = l_alt_on = r_alt_on = FALSE;
    waiting_for_upcode = FALSE;

    /* Reset 8042 */

#if defined(NEC_98)
    kbd_status = 0x85;
#else    //NEC_98
    kbd_status = 0x14;
#endif   //NEC_98
    cmd_byte_8042 = 0x45;
    keyboard_disabled = keyboard_interface_disabled = FALSE;
    op_port_remembered_bits = 0xc;

    pending_8042 = output_full = in_anomalous_state = FALSE;
#if defined(NEC_98)
    int_enabled = TRUE;
    translating = FALSE;
#else    //NEC_98
    int_enabled = translating = TRUE;
#endif   //NEC_98
    scanning_discontinued = FALSE;
    held_event_count = 0;

    //Removed by (DAB)
    //host_kb_light_off (5);
    num_lock_on = TRUE;
}

#endif /* NTVDM */

LOCAL VOID calc_buff_6805_left IFN0()
{
free_6805_buff_size = BUFF_6805_VMAX-((buff_6805_in_ptr - buff_6805_out_ptr) & BUFF_6805_PMASK);
if (free_6805_buff_size<0)
	{
	free_6805_buff_size=0;
	sure_note_trace0(AT_KBD_VERBOSE,"Keyboard buffer full");
	}
} /* end of calc_buff_6805_left */

LOCAL VOID add_codes_to_6805_buff IFN2(int,codes_size,half_word *,codes_buff)
{
int code_index;

if (free_6805_buff_size < codes_size)
	{

/* 20.5.92 MG Don't send the overrun if we only just sent one */

	if (!sent_overrun)
		add_to_6805_buff(buff_overrun_6805[key_set], QUEUED_OUTPUT);
	sent_overrun=TRUE;
	sure_note_trace0(AT_KBD_VERBOSE,"Keyboard buffer overrun");
	}
else
	{

/* If some characters have been read out, clear the sent_overrun flag */

	if (free_6805_buff_size>(codes_size+3))
		sent_overrun=FALSE;
	for (code_index=0;code_index<codes_size;code_index++) {
		add_to_6805_buff(codes_buff[code_index], QUEUED_OUTPUT);
		}
	}
} /* end of add_codes_to_6805_buff */


#ifndef REAL_KBD
/* initialisation code */

LOCAL VOID init_key_arrays IFN0()
{
int key;
half_word *next_free, *extra_ptr, *extra_bk_ptr;
#ifdef  JAPAN
int    ntvdm_keytype;
static half_word ax_kanji_key=0x98;
static half_word ax_kana_key =0x99;
#endif // JAPAN

sure_note_trace1(AT_KBD_VERBOSE,"Keyboard key set initialisation: key set %d",key_set);
next_free = scan_codes_temp_area;
switch (key_set)
	{
	case 1:
		make_sizes=set_1_make_sizes;
		break_sizes=set_1_break_sizes;
#if defined(NEC_98)
                for (key=0;key<144;key++) //127-->144
#else   //NEC_98
		for (key=0;key<127;key++)
#endif  //NEC_98
			{
			switch (keytypes[key])
				{
				case 0:
					make_arrays[key]= &(most_set_1_make_codes[key]);
					break_arrays[key]=next_free;
					*next_free++=(most_set_1_make_codes[key])^0x80;
					break;
				case 1:
				case 2:
				case 3:
					make_arrays[key]=next_free;
					*next_free++ = 0xe0;
					*next_free++ = most_set_1_make_codes[key];
					break_arrays[key]=next_free;
					*next_free++ = 0xe0;
					*next_free++ = (most_set_1_make_codes[key]) ^ 0x80;
					break;
				}
			}
		extra_ptr=set_1_extra_codes;
		extra_bk_ptr=set_1_extra_bk_codes;
		break;
	case 2:
#ifndef NEC_98
#ifdef	JAPAN
	        ntvdm_keytype=GetKeyboardType(0);
	        if (ntvdm_keytype==7){
	                ntvdm_keytype = GetKeyboardType(1);
	        }
	        else    ntvdm_keytype = 0;
#endif // JAPAN
#endif    //NEC_98
		make_sizes=set_2_make_sizes;
		break_sizes=set_2_break_sizes;
		for (key=0;key<127;key++)
			{
#ifndef NEC_98
#ifdef	JAPAN
/*
	AX keyboard KANJI and KANA key setting
	1993.4.6 T.Murakami
*/
			if(key==62){					/* Right ALT */
				// if((ntvdm_keytype & 0xff00)==0x0100	/* AX keyboard */
				// ||  ntvdm_keytype==0x0702){		/* 002 keyboard */
				// keyboard subtype value was changed
				if(ntvdm_keytype==0x0001		/* AX keyboard */
				|| ntvdm_keytype==0x0003		/* 002 keyboard */
				|| (ntvdm_keytype&0xff00)==0x1200	/* TOSHIBA J3100 keyboard */
				){
					make_arrays[key]= &ax_kanji_key;
					break_arrays[key]=next_free;
					*next_free++ = 0xf0;
					*next_free++ = ax_kanji_key;
					keytypes[key]=0;
					continue;
				}
				else	keytypes[key]=1;
			}
			if(key==64){					/* Right CTRL */
				// if((ntvdm_keytype & 0xff00)==0x0100){	/* AX keyboard */
				// keyboard subtype value was changed
				if(ntvdm_keytype==0x0001		/* AX keyboard */
				|| (ntvdm_keytype&0xff00)==0x1200	/* TOSHIBA J3100 keyboard */
				){
					make_arrays[key]= &ax_kana_key;
					break_arrays[key]=next_free;
					*next_free++ = 0xf0;
					*next_free++ = ax_kana_key;
					keytypes[key]=0;
					continue;
				}
				else	keytypes[key]=1;
			}
#endif // JAPAN
#endif    //NEC_98
			switch (keytypes[key])
				{
				case 0:
					make_arrays[key]= &(most_set_2_make_codes[key]);
					break_arrays[key]=next_free;
					*next_free++ = 0xf0;
					*next_free++ = most_set_2_make_codes[key];
					break;
				case 1:
				case 2:
				case 3:
					make_arrays[key]=next_free;
					*next_free++ = 0xe0;
					*next_free++ = most_set_2_make_codes[key];
					break_arrays[key]=next_free;
					*next_free++ = 0xe0;
					*next_free++ = 0xf0;
					*next_free++ = most_set_2_make_codes[key];
					break;
				}
			}
		extra_ptr=set_2_extra_codes;
		extra_bk_ptr=set_2_extra_bk_codes;
		break;
	case 3:
		make_sizes=set_3_make_sizes;
		break_sizes=set_3_break_sizes;
		for (key=0;key<127;key++)
			{
			if (keytypes[key] != 6)
				{
				make_arrays[key]= &(most_set_3_make_codes[key]);
				break_arrays[key]=next_free;
				*next_free++ = 0xf0;
				*next_free++ = most_set_3_make_codes[key];
				}
			}
		extra_ptr=set_3_extra_codes;
		extra_bk_ptr=set_3_extra_bk_codes;
		break;
	} /* end of switch */

#ifndef NEC_98
	make_arrays[124]=extra_ptr;
	extra_ptr+=make_sizes[4];
	make_arrays[126]=extra_ptr;
	extra_ptr+=make_sizes[5];
	extra_ptr+=make_sizes[6];
	make_arrays[NUM_LOCK_ADD_ARRAY]=extra_ptr;
	extra_ptr+=make_sizes[7];
	make_arrays[L_SHIFT_ADD_ARRAY]=extra_ptr;
	extra_ptr+=make_sizes[8];
	make_arrays[R_SHIFT_ADD_ARRAY]=extra_ptr;
	extra_ptr+=make_sizes[9];
	make_arrays[CASE_4_SHIFTED_ARRAY]=extra_ptr;
	extra_ptr+=make_sizes[10];
	make_arrays[ALT_CASE_4_ARRAY]=extra_ptr;
	extra_ptr+=make_sizes[11];
	make_arrays[CASE_5_CTRLED_ARRAY]=extra_ptr;
	extra_ptr+=make_sizes[12];

	break_arrays[124]=extra_bk_ptr;
	extra_bk_ptr+=break_sizes[4];
	break_arrays[126]=extra_bk_ptr;
	extra_bk_ptr+=break_sizes[5];
	extra_bk_ptr+=break_sizes[6];
	break_arrays[NUM_LOCK_ADD_ARRAY]=extra_bk_ptr;
	extra_bk_ptr+=break_sizes[7];
	break_arrays[L_SHIFT_ADD_ARRAY]=extra_bk_ptr;
	extra_bk_ptr+=break_sizes[8];
	break_arrays[R_SHIFT_ADD_ARRAY]=extra_bk_ptr;
	extra_bk_ptr+=break_sizes[9];
	break_arrays[CASE_4_SHIFTED_ARRAY]=extra_bk_ptr;
	extra_bk_ptr+=break_sizes[10];
	break_arrays[ALT_CASE_4_ARRAY]=extra_bk_ptr;
	extra_bk_ptr+=break_sizes[11];
	break_arrays[CASE_5_CTRLED_ARRAY]=extra_bk_ptr;
	extra_bk_ptr+=break_sizes[12];
#endif   //NEC_98
} /* end of init_key_arrays () */


/* Key pressed on host keyboard */

GLOBAL VOID host_key_down IFN1(int,key)
#ifdef SECURE /* { */
{
	IU8 keytab_entry;
	/* Make a note of any modifier bits. */
	keytab_entry = secure_keytab[key];
	keys_down |= keytab_entry;
	/* If any filtering action is required, go do it. */
	if (config_inquire(C_SECURE, NULL) && (keytab_entry & SEC_ACTION) != 0)
	{
		/* The key may need filtering. */
		(*down_class[keytab_entry & SEC_ACTCLASS])(key);
	}
	else
	{
		filtered_host_key_down(key);
	}
}

LOCAL VOID filtered_host_key_down IFN1(int,key)
#endif /* SECURE } */
{
if (scanning_discontinued)
	{
	held_event_type[held_event_count]=KEY_DOWN_EVENT;
	held_event_key[held_event_count++]=key;

	/* check for held event buffer overflow (SHOULD never happen) */
	if (held_event_count >= HELD_EVENT_MAX)
		{
		held_event_count = HELD_EVENT_MAX-1;
		always_trace0("host_key_down held event buffer overflow");
		}
	}
#ifdef NTVDM
else if (!keyboard_disabled) {
       //
       // Ignore contiguous repeat keys if keys are still in the 6805
       // this keeps the apps responsive to the corresponding up key
       // when it comes.
       //
       if (LastKeyDown != key || (KbdHdwFull < 8)) {
           LastKeyDown = key;
           key_down_count[key]++;
           do_host_key_down(key);
           }
    }
#else
else
	{
	do_host_key_down(key);
	}
#endif
}

GLOBAL VOID host_key_up IFN1(int,key)
#ifdef SECURE /* { */
{
	IU8 keytab_entry;
	/* Make a note of any modifier bits. */
	keytab_entry = secure_keytab[key];
	keys_down &= SEC_MOD_MASK ^ keytab_entry;
	/* If any filtering action is required, go do it. */
	if (config_inquire(C_SECURE, NULL) && (keytab_entry & SEC_ACTION) != 0)
	{
		/* The key may need filtering. */
		(*up_class[keytab_entry & SEC_ACTCLASS])(key);
	}
	else
	{
		filtered_host_key_up(key);
	}
}

LOCAL VOID filtered_host_key_up IFN1(int,key)
#endif /* SECURE } */
{
if (scanning_discontinued)
	{
	held_event_type[held_event_count]=KEY_UP_EVENT;
	held_event_key[held_event_count++]=key;

	/* check for held event buffer overflow (SHOULD never happen) */
	if (held_event_count >= HELD_EVENT_MAX)
		{
		held_event_count = HELD_EVENT_MAX-1;
		always_trace0("host_key_up held event buffer overflow");
		}
	}
#ifdef NTVDM
else if (!keyboard_disabled && key_down_count[key]) {
#else
else
	{
#endif
#ifdef NTVDM
       LastKeyDown = -1;
#endif
	do_host_key_up(key);
	}
}

#ifdef NTVDM
GLOBAL VOID RaiseAllDownKeys(VOID)
{
   int i;

   i = sizeof(key_down_count)/sizeof(int);
   while (i--) {
       if (key_down_count[i]) {
           host_key_up(i);
           }
       }
}

GLOBAL int IsKeyDown(int Key)
{
   return  key_down_count[Key];
}


#endif /* NTVDM */

LOCAL VOID do_host_key_down IFN1(int,key)
{
int overrun,keytype;

sure_note_trace1(AT_KBD_VERBOSE,"key down:%d",key);

if (!keyboard_disabled)
	{

#ifdef NTVDM
		mark_key_codes_6805_buff(TRUE);
#else
	key_down_count[key]++;
        if (key_down_count[key]==1)
                {       /* first press */
                repeat_delay_count=0;
		repeat_count=0;
                typematic_key_valid=FALSE;

#endif	/* NTVDM */
		keytype=keytypes[key];
		overrun=FALSE;
		if (in_anomalous_state)
			{
			if (anomalous_size > free_6805_buff_size)
				{ overrun=TRUE; }
			else
				{
				scan_code_6805_size = anomalous_size;
				scan_code_6805_array = anomalous_array;
				add_codes_to_6805_buff(anomalous_size,anomalous_array);
				in_anomalous_state=FALSE;
				}
			}

		switch (keytype)
			{
			case 0:
			case 1:
			case 6:
			    scan_code_6805_size=make_sizes[keytype];
			    scan_code_6805_array=make_arrays[key];
			    break;
			case 2:
			    if (num_lock_on && !shift_on)
				    {
				    scan_code_6805_size=make_sizes[NUM_LOCK_ADD];
				    scan_code_6805_array=make_arrays[NUM_LOCK_ADD_ARRAY];
				    if (scan_code_6805_size+make_sizes[keytype] >free_6805_buff_size)
					    { overrun=TRUE; }
				    else
					{
					in_anomalous_state=TRUE;
					anom_key=key;
					anomalous_array=break_arrays[NUM_LOCK_ADD_ARRAY];
					anomalous_size=break_sizes[NUM_LOCK_ADD];
					add_codes_to_6805_buff(scan_code_6805_size,scan_code_6805_array);
					}
				    }
			    if (!num_lock_on && shift_on)
				    {
				    if (l_shift_on)
					    {
					    scan_code_6805_size=make_sizes[L_SHIFT_ADD];
					    scan_code_6805_array=make_arrays[L_SHIFT_ADD_ARRAY];
					in_anomalous_state=TRUE;
					anom_key=key;
					anomalous_array=break_arrays[L_SHIFT_ADD_ARRAY];
					anomalous_size=break_sizes[L_SHIFT_ADD];
					    }
				    else
					    {
					    scan_code_6805_size=make_sizes[R_SHIFT_ADD];
					    scan_code_6805_array=make_arrays[R_SHIFT_ADD_ARRAY];
					in_anomalous_state=TRUE;
					anom_key=key;
					anomalous_array=break_arrays[R_SHIFT_ADD_ARRAY];
					anomalous_size=break_sizes[R_SHIFT_ADD];
					    }
				    if (scan_code_6805_size+make_sizes[keytype] >free_6805_buff_size)
					    {
					    overrun=TRUE;
					    in_anomalous_state=FALSE;
					    }
				    else
					    {
					    add_codes_to_6805_buff(scan_code_6805_size,scan_code_6805_array);
					    }
				    }
			    scan_code_6805_size=make_sizes[keytype];
			    scan_code_6805_array=make_arrays[key];
			    break;
			case 3:
			    if (shift_on)
				    {
				    if (l_shift_on)
					    {
					    scan_code_6805_size=make_sizes[L_SHIFT_ADD];
					    scan_code_6805_array=make_arrays[L_SHIFT_ADD_ARRAY];
					in_anomalous_state=TRUE;
					anom_key=key;
					anomalous_array=break_arrays[L_SHIFT_ADD_ARRAY];
					anomalous_size=break_sizes[L_SHIFT_ADD];
					    }
				    else
					    {
					    scan_code_6805_size=make_sizes[R_SHIFT_ADD];
					    scan_code_6805_array=make_arrays[R_SHIFT_ADD_ARRAY];
					in_anomalous_state=TRUE;
					anom_key=key;
					anomalous_array=break_arrays[R_SHIFT_ADD_ARRAY];
					anomalous_size=break_sizes[R_SHIFT_ADD];
					    }
				    if (scan_code_6805_size+make_sizes[keytype] >free_6805_buff_size)
					    {
					    overrun=TRUE;
					    in_anomalous_state=FALSE;
					    }
				    else
					    {
					    add_codes_to_6805_buff(scan_code_6805_size,scan_code_6805_array);
					    }
				    }
			    scan_code_6805_size=make_sizes[keytype];
			    scan_code_6805_array=make_arrays[key];
			    break;
			case 4:
			    if (shift_on || ctrl_on || alt_on)
				    {
				    if (shift_on || ctrl_on)
					    {
					    scan_code_6805_size=make_sizes[CASE_4_SHIFTED];
					    scan_code_6805_array=make_arrays[CASE_4_SHIFTED_ARRAY];
					    }
				    else
					    {
					    scan_code_6805_size=make_sizes[ALT_CASE_4];
					    scan_code_6805_array=make_arrays[ALT_CASE_4_ARRAY];
					    }
				    }
			    else
				    {
					in_anomalous_state=TRUE;
					anomalous_array=break_arrays[L_SHIFT_ADD_ARRAY];
					anomalous_size=break_sizes[L_SHIFT_ADD];
					anom_key=key;
				    scan_code_6805_size=make_sizes[keytype];
				    scan_code_6805_array=make_arrays[key];
				    }
			    break;
			case 5:
			    if (ctrl_on)
				    {
				    scan_code_6805_size=make_sizes[CASE_5_CTRLED];
				    scan_code_6805_array=make_arrays[CASE_5_CTRLED_ARRAY];
				    }
			    else
				    {
				    scan_code_6805_size=make_sizes[keytype];
				    scan_code_6805_array=make_arrays[key];
				    }
			    break;
			    } /* end of switch */
		if (overrun)
			{
			if (!sent_overrun)
				add_to_6805_buff(buff_overrun_6805[key_set],
					QUEUED_OUTPUT);
			sent_overrun=TRUE;

			sure_note_trace0(AT_KBD_VERBOSE,"Keyboard buffer overrun");
			}
		else
			{
			add_codes_to_6805_buff(scan_code_6805_size,scan_code_6805_array);
			}
		switch (key)
		    {
		    case 44:
			    l_shift_on =TRUE;
			    shift_on = TRUE;
			    break;
		    case 57:
			    r_shift_on = TRUE;
			    shift_on = TRUE;
			    break;
		    case 58:
			    l_ctrl_on =TRUE;
			    ctrl_on = TRUE;
			    break;
		    case 64:
			    r_ctrl_on = TRUE;
			    ctrl_on = TRUE;
			    break;
		    case 60:
			    l_alt_on =TRUE;
			    alt_on = TRUE;
			    break;
		    case 62:
			    r_alt_on =TRUE;
			    alt_on = TRUE;
			    break;
		    case 90:
			    num_lock_on = !num_lock_on;
			    break;
		    }

#ifndef NTVDM	/* JonLe NTVDM Mod */

#if defined(NEC_98)
//add key!=90(Numlock)KANA
               if ((key!=126)&&(key!=90)) {
#else     //NEC_98
		if (key!=126)
#endif    //NEC_98
		    {
		    if ((key_set != 3) || (set_3_key_state[key] == 1) || (set_3_key_state[key] == 4))
			    {
			    typematic_key = key;
			    typematic_key_valid = TRUE;
			    }
		    }
#else
		mark_key_codes_6805_buff(FALSE);
#endif	/* NTVDM */

		if (free_6805_buff_size < BUFF_6805_VMAX)
		    {
		    codes_to_translate();
		    }

#ifndef NTVDM
		} /* end of if first press */
#endif	/* NTVDM */

	} /* end of if not disabled */
} /* end of do_host_key_down */


/* Key released on host keyboard */
LOCAL VOID do_host_key_up IFN1(int,key)
{
half_word *temp_arr_array;
int temp_arr_size,keytype,overrun;

sure_note_trace1(AT_KBD_VERBOSE,"key up:%d",key);

if (!keyboard_disabled)
	{
#ifdef DEMO_COPY
	host_check_demo_expire ();
#endif
	if( key_down_count[key] == 0){
		/*
		** This will ignore extra key ups.
		*/
#ifndef PROD
		sure_note_trace1( AT_KBD_VERBOSE, "Ignored extra key up:%d", key );
#endif
	}
	else
	{
		key_down_count[key] =  0;

#ifndef NTVDM 	/* JonLe NTVDM Mod */
		if ((key==typematic_key) && typematic_key_valid)
			{
			typematic_key_valid=FALSE;
			}
#endif	/* NTVDM */

		keytype=keytypes[key];
		overrun=FALSE;
		if (!(key_set ==3) || (set_3_key_state[key]==2) || (set_3_key_state[key]==4))
			{
#ifdef NTVDM
			mark_key_codes_6805_buff(TRUE);
#endif
			switch (keytype)
				{
				case 0:
				case 1:
				case 6:
					scan_code_6805_size=break_sizes[keytype];
					scan_code_6805_array=break_arrays[key];
					break;
				case 2:
					temp_arr_size=0;
                                        temp_arr_array=(half_word *) -1;
					if (in_anomalous_state && (anom_key == key))
						{
						in_anomalous_state=FALSE;
						if (num_lock_on && !shift_on)
							{
							temp_arr_size=break_sizes[NUM_LOCK_ADD];
							temp_arr_array=break_arrays[NUM_LOCK_ADD_ARRAY];
							}
						if (!num_lock_on && shift_on)
							{
							if (l_shift_on)
								{
								temp_arr_size=break_sizes[L_SHIFT_ADD];
								temp_arr_array=break_arrays[L_SHIFT_ADD_ARRAY];
								}
							else
								{
								temp_arr_size=break_sizes[R_SHIFT_ADD];
								temp_arr_array=break_arrays[R_SHIFT_ADD_ARRAY];
								}
							}
						}
					scan_code_6805_size=break_sizes[keytype];
					scan_code_6805_array=break_arrays[key];
					if (scan_code_6805_size+temp_arr_size > free_6805_buff_size)
						{ overrun=TRUE; }
					else
						{
						add_codes_to_6805_buff(scan_code_6805_size,scan_code_6805_array);
						}
					scan_code_6805_size=temp_arr_size;
                                        scan_code_6805_array=temp_arr_array;
                                        break;

				case 3:
					temp_arr_size=0;
                                        temp_arr_array=(half_word *) -1;
					if (in_anomalous_state && (anom_key == key))
						{
						in_anomalous_state = FALSE;
						if (shift_on)
							{
							if (l_shift_on)
								{
								temp_arr_size=break_sizes[L_SHIFT_ADD];
								temp_arr_array=break_arrays[L_SHIFT_ADD_ARRAY];
								}
							else
								{
								temp_arr_size=break_sizes[R_SHIFT_ADD];
								temp_arr_array=break_arrays[R_SHIFT_ADD_ARRAY];
								}
							}
						}
					scan_code_6805_size=break_sizes[keytype];
					scan_code_6805_array=break_arrays[key];
					if (scan_code_6805_size+temp_arr_size > free_6805_buff_size)
						{ overrun=TRUE; }
					else
						{
						add_codes_to_6805_buff(scan_code_6805_size,scan_code_6805_array);
						}
					scan_code_6805_size=temp_arr_size;
                                        scan_code_6805_array=temp_arr_array;
                                        break;

				case 4:
					if (shift_on || ctrl_on || alt_on)
						{
						if (shift_on || ctrl_on)
							{
							scan_code_6805_size=break_sizes[CASE_4_SHIFTED];
							scan_code_6805_array=break_arrays[CASE_4_SHIFTED_ARRAY];
							}
						else
							{
							scan_code_6805_size=break_sizes[ALT_CASE_4];
							scan_code_6805_array=break_arrays[ALT_CASE_4_ARRAY];
							}
						}
					else
						{
						if (in_anomalous_state && (anom_key==key))
							{
							in_anomalous_state=FALSE;
							scan_code_6805_size=break_sizes[keytype];
							scan_code_6805_array=break_arrays[key];
							}
						else
							{
							scan_code_6805_size=break_sizes[CASE_4_SHIFTED];
							scan_code_6805_array=break_arrays[CASE_4_SHIFTED_ARRAY];
							}
						}
					break;
				case 5:
					scan_code_6805_size=0;
					break;
				} /* end of switch */
			if (overrun)
				{
				if (!sent_overrun)
					add_to_6805_buff(buff_overrun_6805[key_set], QUEUED_OUTPUT);
				sent_overrun=TRUE;

				sure_note_trace0(AT_KBD_VERBOSE,"Keyboard buffer overrun");
				}
			else
				{
				add_codes_to_6805_buff(scan_code_6805_size,scan_code_6805_array);
				}
#ifdef NTVDM
			mark_key_codes_6805_buff(FALSE);
#endif
			} /* end of if not set 3 etc. */
		switch (key)
			{
			case 44:
				l_shift_on =FALSE;
				if (!r_shift_on) { shift_on = FALSE; }
				break;
			case 57:
				r_shift_on = FALSE;
				if (!l_shift_on) { shift_on = FALSE; }
				break;
			case 58:
				l_ctrl_on =FALSE;
				if (!r_ctrl_on) { ctrl_on = FALSE; }
				break;
			case 64:
				r_ctrl_on = FALSE;
				if (!l_ctrl_on) { ctrl_on = FALSE; }
				break;
			case 60:
				l_alt_on =FALSE;
				if (!r_alt_on) { alt_on = FALSE; }
				break;
			case 62:
				r_alt_on =FALSE;
				if (!l_alt_on) { alt_on = FALSE; }
				break;
			} /* end of switch */

		if (free_6805_buff_size < BUFF_6805_VMAX)
			{
			codes_to_translate();
			}
		} /* end of if last release */
	} /* end of if not disabled */
} /* end of do_host_key_up */
#endif /* REAL_KBD */

#ifdef NTVDM
        /*
         *  force filling of Kbd data port just like the real kbd
         *  since we no longer clear output_full in the Kbd_inb routine
         */
LOCAL VOID AddTo6805BuffImm IFN1(half_word,code)
{
  add_to_6805_buff(code,IMMEDIATE_OUTPUT);
  output_full = FALSE;
  KbdData = -1;
}
#else
#define  AddTo6805BuffImm(code) add_to_6805_buff(code, IMMEDIATE_OUTPUT);
#endif

LOCAL VOID cmd_to_6805 IFN1(half_word,cmd_code)
{
int i,key_to_change;
half_word change_to;
unsigned int cmd_code_temp; /* Mac MPW3 compiler prefers unsigned ints in switches */

sure_note_trace1(AT_KBD_VERBOSE,"6805 received cmd:0x%x",cmd_code);

#ifndef REAL_KBD

if (waiting_for_next_code)
	{
	switch (next_code_sequence_number)
		{
		case SCAN_CODE_CHANGE_SEQUENCE:
			if (cmd_code>3 || cmd_code <0)
                                { AddTo6805BuffImm(RESEND_CODE); }
			else
				{
				 if (cmd_code == 0)
					{
					/* order of reception of scan codes is reverse their order of insertion
					 * if 'IMMEDIATE_OUTPUT' method of insertion is used
					 */
                                         AddTo6805BuffImm(key_set);
                                         AddTo6805BuffImm(ACK_CODE);
					}
				 else
					{
                                         AddTo6805BuffImm(ACK_CODE);
#ifndef NEC_98
					 key_set=cmd_code;
					 init_key_arrays();
#endif   //NEC_98
					}
				}
			break;
		case SET_3_KEY_TYPE_SET_SEQUENCE:
			sure_note_trace2(AT_KBD_VERBOSE,"Keyboard key type change: key 0x%x, new type %d",cmd_code,set_3_key_type_change_dest);
                        AddTo6805BuffImm(ACK_CODE);
			key_to_change=set_3_reverse_lookup[cmd_code];
			set_3_key_state[key_to_change]=(half_word)set_3_key_type_change_dest;
			break;
		case SET_STATUS_INDICATORS_SEQUENCE:
			if ((cmd_code & 0xf8) == 0)
			{
			sure_note_trace1(AT_KBD_VERBOSE,"Changing kbd lights to :%x",cmd_code);
			AddTo6805BuffImm(ACK_CODE);
#ifdef NTVDM
			host_kb_light_on ((IU8)((cmd_code & 0x07) | 0xf0));
#else
			cmd_code &= 0x7;
			host_kb_light_on (cmd_code);
			host_kb_light_off ((~cmd_code)&0x7);
#endif
			}
			break;
		case SET_RATE_DELAY_SEQUENCE:
#ifndef NTVDM	/* JonLe Mod */
			if ((cmd_code & 0x80)==0)
			{
			repeat_delay_target = (1+((cmd_code>>5)&3))*BASE_DELAY_UNIT;
			cmd_code &= 0x1f;
			if (cmd_code<0xb) { repeat_target =0; }
			else { if (cmd_code<0x11) { repeat_target =1; }
			else { if (cmd_code<0x19) { repeat_target=(cmd_code-0x12)/3 +3;}
			else { if (cmd_code<0x1e) { repeat_target=(cmd_code-0x1a)/2+6;}
			else { repeat_target=(cmd_code-0x1e)+8;}}}}
                        AddTo6805BuffImm(ACK_CODE);
			}
			sure_note_trace2(AT_KBD_VERBOSE,"Changing kbd rate/delay: rate = %d, dealy=%d ",repeat_target,repeat_delay_target);

#else	/* NTVDM */

			if ((cmd_code & 0x80)==0)
			{
                        AddTo6805BuffImm(ACK_CODE);
			}

#endif	/* NTVDM */
			break;
		}
		waiting_for_next_code = FALSE;
	}
	else
	{

#endif /* not REAL_KBD */

	/*
	** Mac MPW3 compiler does not like bytes sized switch
	** variables if a case matches on 0xff. It seems to
	** generate dodgy code. Different type seems OK.
	*/
	cmd_code_temp = (unsigned int)cmd_code;
	switch ( cmd_code_temp )
	{
#ifndef REAL_KBD
	case 0xf5:
		/* Default Disable */
		clear_buff_6805 ();
                AddTo6805BuffImm(ACK_CODE);
		for (key_to_change=1;key_to_change<127;key_to_change++)
			{
			set_3_key_state[key_to_change]=set_3_default_key_state[key_to_change];
			}

#ifndef NTVDM 	/* JonLe NTVDM Mod */
		repeat_delay_target=2*BASE_DELAY_UNIT;
		repeat_target=DEFAULT_REPEAT_TARGET;
		typematic_key_valid=FALSE;
#endif	/* NTVDM */

		keyboard_disabled=TRUE;
		sure_note_trace0(AT_KBD_VERBOSE,"Keyboard disabled");
		break;
	case 0xee:
		/* echo */
                AddTo6805BuffImm(0xee);
		break;
	case 0xf4:
		/* enable */
		clear_buff_6805 ();
                AddTo6805BuffImm(ACK_CODE);

#ifndef NTVDM 	/* JonLe NTVDM Mod */
		typematic_key_valid=FALSE;
#endif	/* NTVDM */

		keyboard_disabled=FALSE;
		sure_note_trace0(AT_KBD_VERBOSE,"Keyboard enabled");
		break;
#endif
	case 0xf2:
		/* Read ID */
		/* order of reception of scan codes is reverse their order of insertion
		 * if 'IMMEDIATE_OUTPUT' method of insertion is used
		 */
                AddTo6805BuffImm(0x83);
                AddTo6805BuffImm(0xab);
                AddTo6805BuffImm(ACK_CODE);
		break;
	case 0xfe:
		/* resend */
		buff_6805_out_ptr=(buff_6805_out_ptr-1) & BUFF_6805_PMASK;
		calc_buff_6805_left();
		break;
#ifndef REAL_KBD
	case 0xff:
		/* reset */
		/* order of reception of scan codes is reverse their order of insertion
		 * if 'IMMEDIATE_OUTPUT' method of insertion is used
		 */
                AddTo6805BuffImm(BAT_COMPLETION_CODE);
                AddTo6805BuffImm(ACK_CODE);
		keyboard_disabled=FALSE;
		sure_note_trace0(AT_KBD_VERBOSE,"Keyboard reset");
		break;
	case 0xf0:
		/* Select Alternate Scan Codes */
		clear_buff_6805 ();
                AddTo6805BuffImm(ACK_CODE);

#ifndef NTVDM 	/* JonLe NTVDM Mod */
		typematic_key_valid=FALSE;
#endif	/* NTVDM */

		next_code_sequence_number=SCAN_CODE_CHANGE_SEQUENCE;
		held_event_count=0;
		scanning_discontinued = waiting_for_next_code=TRUE;
		break;
	case 0xf7:
	case 0xf8:
	case 0xf9:
	case 0xfa:
		/* Set all keys */
                AddTo6805BuffImm(ACK_CODE);
		change_to=cmd_code - 0xf6;
		for (key_to_change=1;key_to_change<127;key_to_change++)
			{
			set_3_key_state[key_to_change]=change_to;
			}
		sure_note_trace1(AT_KBD_VERBOSE,"All keys set to type :0x%x",change_to);
		break;
	case 0xf6:
		/* Set Default */
		clear_buff_6805 ();
                AddTo6805BuffImm(ACK_CODE);
		for (key_to_change=1;key_to_change<127;key_to_change++)
			{
			set_3_key_state[key_to_change]=set_3_default_key_state[key_to_change];
			}

#ifndef NTVDM 	/* JonLe NTVDM Mod */
		repeat_delay_target=2*BASE_DELAY_UNIT;
		repeat_target=DEFAULT_REPEAT_TARGET;
		typematic_key_valid=FALSE;
#endif	/* NTVDM */
		keyboard_disabled=FALSE;
		sure_note_trace0(AT_KBD_VERBOSE,"Keyboard set to default (and enabled)");
		break;
	case 0xfb:
	case 0xfc:
	case 0xfd:
		/* Set key type */
		clear_buff_6805 ();
                AddTo6805BuffImm(ACK_CODE);

#ifndef NTVDM 	/* JonLe NTVDM Mod */
		typematic_key_valid=FALSE;
#endif	/* NTVDM */

		next_code_sequence_number=SET_3_KEY_TYPE_SET_SEQUENCE;
		held_event_count=0;
		scanning_discontinued = waiting_for_next_code=TRUE;
		set_3_key_type_change_dest=cmd_code - 0xfa;
		break;
	case 0xed:
		/* Set/Reset Status Indicators */
                AddTo6805BuffImm(ACK_CODE);
		next_code_sequence_number=SET_STATUS_INDICATORS_SEQUENCE;
		held_event_count=0;
		scanning_discontinued = waiting_for_next_code=TRUE;
		break;
	case 0xf3:
		/* Set typematic Rate/Delay */
                AddTo6805BuffImm(ACK_CODE);
		next_code_sequence_number=SET_RATE_DELAY_SEQUENCE;
		held_event_count=0;
		scanning_discontinued = waiting_for_next_code=TRUE;
		break;
	default :
		/* unrecognised code */
#ifdef	JOKER
		AddTo6805BuffImm(ACK_CODE);
#else	/* JOKER */
		AddTo6805BuffImm(RESEND_CODE);
#endif	/* JOKER */
		break;

#else
	default :
		/* cmd to be sent on to real kbd */
		send_to_real_kbd(cmd_code);
#endif
	} /* end of switch */
#ifndef REAL_KBD
}
#else
	waiting_for_next_code=FALSE;
#endif

#ifndef REAL_KBD
if (scanning_discontinued && !waiting_for_next_code)
	{
	if (held_event_count != 0)
		{
		for (i=0;i<held_event_count;i++)
			{
			switch (held_event_type[i])
				{
				case KEY_DOWN_EVENT:
					do_host_key_down(held_event_key[i]);
					break;
				case KEY_UP_EVENT:
					do_host_key_up(held_event_key[i]);
					break;
				}
			}
		}
	scanning_discontinued=FALSE;
	}
#endif

#ifndef NTVDM
if (free_6805_buff_size < BUFF_6805_VMAX)
	{
	codes_to_translate();
        }
#endif

} /* end of cmd_to_6805 */

/* interface to interrupts */

#ifdef NTVDM	/* JonLe NTVDM Mod */



/* KbdIntDelay
 *
 * UNDER ALL CONDITIONS we must provide a SAFE key rate that 16 bit apps
 * can handle. This must be done without looking at the bios buffer,
 * since not all apps use the bios int 9 handler.
 *
 */

LOCAL VOID KbdIntDelay(VOID)
{


       //
       // Wait until the kbd scancode has been read,
       // before invoking the next interrupt.
       //
   if (bKbdEoiPending)
       return;


   if (int_enabled) {
       bKbdEoiPending = TRUE;

       if (!bForceDelayInts) {
#if defined(NEC_98)
           kbd_status |= 0x02;     //Set Redy bit
#else    //NEC_98
           kbd_status |= 1;
#endif   //NEC_98
           ica_hw_interrupt(KEYBOARD_INT_ADAPTER, KEYBOARD_INT_LINE, 1);
           }
       else {
           ULONG ulDelay = 2000;

           if (bKbdIntHooked) {
               ulDelay += 2000;
               }

           if (KbdHdwFull > 8) {
               ulDelay += 4000;
               }

           if (!bBiosBufferSpace) {
               ulDelay += 4000;
               }

           if (!bPifFastPaste) {
               ulDelay <<= 1;
               }

           bDelayIntPending = TRUE;
           host_DelayHwInterrupt(KEYBOARD_INT_LINE,
                                 1,
                                 ulDelay
                                 );
           }

       HostIdleNoActivity();
       }
}



//This function is called by the ICA with the ica lock
void KbdEOIHook(int IrqLine, int CallCount)
{

   if (!bKbdEoiPending)  // sanity
       return;

   if (!bBiosOwnsKbdHdw && WaitKbdHdw(0xffffffff))  {
       bKbdEoiPending = FALSE;
       return;
       }

   bKbdIntHooked = KbdInt09Off != *(word *)(Start_of_M_area+0x09*4) ||
                   KbdInt09Seg != *(word *)(Start_of_M_area+0x09*4+2);

   bBiosBufferSpace = bBiosOwnsKbdHdw &&
                      (bios_buffer_size() < (bPifFastPaste ? 8 : 2));

   output_full = FALSE;
   bKbdEoiPending = FALSE;

   bForceDelayInts = TRUE;
   continue_output();
   bForceDelayInts = FALSE;

   if (!bBiosOwnsKbdHdw)
        HostReleaseKbd();
}




LOCAL VOID do_q_int(char scancode)
{
   output_full = TRUE;
   output_contents = scancode;

   KbdIntDelay();
}

#else   /* NTVDM */

LOCAL VOID do_int IFN1(long,scancode)
{
	output_contents = (char)scancode;
#if defined(NEC_98)
        kbd_status |= 0x02;     //Set Redy bit
#else    //NEC_98
	kbd_status |= 1;			/* Character now available! */
#endif   //NEC_98
	if (int_enabled)
	{
		sure_note_trace0(AT_KBD_VERBOSE,"keyboard interrupting");
		ica_hw_interrupt(KEYBOARD_INT_ADAPTER, KEYBOARD_INT_LINE, 1);
	}
}

LOCAL VOID do_q_int IFN1(char,scancode)
{
	output_full = TRUE;

#if defined(IRET_HOOKS) && defined(GISP_CPU)
	if (!HostDelayKbdInt(scancode))
	{	/* no host need to delay this kbd int, so generate one now. */
		do_int ((long) scancode);
	}

#else /* !IRET_HOOKS || !GISP_CPU */

#ifdef DELAYED_INTS
	do_int ((long) scancode);
#else
	add_q_event_i( do_int, HOST_KEYBA_INST_DELAY, (long)scancode);
#endif	/* DELAYED_INTS */

#endif /* IRET_HOOKS && GISP_CPU */
}


/* typematic keyboard repeats */

GLOBAL VOID do_key_repeats IFN0()
{
#ifndef REAL_KBD

#ifdef JOKER
	/* If there are characters available, tell Joker... */
	if (kbd_status & 1)
		do_int((long)output_contents);
#endif

if (typematic_key_valid)
	{
	if (repeat_count==repeat_target && repeat_delay_count==repeat_delay_target)
		{
		scan_code_6805_size=make_sizes[keytypes[typematic_key]];
		scan_code_6805_array=make_arrays[typematic_key];
		add_codes_to_6805_buff(scan_code_6805_size,scan_code_6805_array);
		codes_to_translate ();
		repeat_count=0;
		}
	else
		{
		if (repeat_delay_count==repeat_delay_target)
			{
			repeat_count++;
			}
		else
			{
			repeat_delay_count++;
			}
		}
	}
#endif

} /* end of do_key_repeats */

#endif	/* NTVDM */


LOCAL VOID cmd_to_8042  IFN1(half_word,cmd_code)
{
int code_to_send,code_to_send_valid;

#if defined(NEC_98)
half_word cmd_code_NEC98;
int       key;
#endif    //NEC_98

sure_note_trace1(AT_KBD_VERBOSE,"8042 received cmd:0x%x",cmd_code);

code_to_send_valid = FALSE;
#if defined(NEC_98)
cmd_code_NEC98 = cmd_code;

/* ***** KBDE ***** */
        if ( (cmd_code_NEC98 & 0x20) == 0x20 )     // Keyboard Disable(Send) ?
               {
               int_enabled=FALSE;
               keyboard_interface_disabled=TRUE;
               }
        else
               {
               int_enabled=TRUE;
               keyboard_interface_disabled=FALSE;
               }
/* ***** ER ***** */
        if ( (cmd_code_NEC98 & 0x10) == 0x10 )     // Reset ERR Flag ?
            {
            kbd_status &= ~(0x38);              //Reset error flag
            }

/* ***** RxE ***** */
        if ( (cmd_code_NEC98 & 0x04) == 0x00 )     // Keyboard Disable(Recive) ?
               {
//             int_enabled=FALSE;
               keyboard_interface_disabled=TRUE;
               }
        else
               {
//             int_enabled=TRUE;
               keyboard_interface_disabled=FALSE;
               }

/* ***** RST ***** */
//printf("reset command \n");

        if ( (cmd_code_NEC98 & 0x03a) == 0x03a )   // Keyboard Reset on ?
            {
             reset_flag = 1;                    // Reset 0 -> 1
            }
        else                                    // Keyboard Reset off !
            {
            if ( (cmd_code_NEC98 & 0x032) == 0x032 )
                    reset_flag = 2;             // Reset 1 -> 0
            }

        if ( (reset_flag == 2) && (int_enabled==TRUE) && (keyboard_interface_disabled==FALSE))

            {
            //_asm{int 3};
            reset_flag=0;
            Reset6805and8042();

            for(key = 0; key < 144; key++)
                {
                if( key_down_dmy[key] > 0x00 )
                        {
//                      printf(" resend key -> %#x\n", key);
//                      add_to_6805_buff(key, IMMEDIATE_OUTPUT);
                        //KbdWaitRead = FALSE;  //NEC 930910 >>940509
                        host_key_down(key);     //NEC 930910
                        }
                }
            }

/* ***** RTY ***** */
        if ( (cmd_code_NEC98 & 0x02) == 0x00 )     // Retry ?
            {
                buff_6805_out_ptr=(buff_6805_out_ptr-1) & BUFF_6805_PMASK;
                calc_buff_6805_left();
            }
#else    //NEC_98
if (waiting_for_next_8042_code)
	{
	switch (next_8042_code_sequence_number)
		{
		case WRITE_8042_CMD_BYTE_SEQUENCE:
			if ( (kbd_status & 0x8) == 0)
				{
				cmd_byte_8042=cmd_code;
				if ( (cmd_byte_8042 & 0x40) == 0)
					{
					translating=FALSE;
					}
				else
					{
					translating=TRUE;
					}
				if ( (cmd_byte_8042 & 0x20) != 0 || (cmd_byte_8042 & 0x10) != 0)
					{
					keyboard_interface_disabled=TRUE;
					}
				else
					{
					keyboard_interface_disabled=FALSE;
					}
				kbd_status &= 0xfb;
				kbd_status |= cmd_byte_8042 & 0x4;
				if ((cmd_byte_8042 & 1) == 0)
					{
					int_enabled=FALSE;
					}
				else
					{
					int_enabled=TRUE;
					}
				}
			else
				{
				waiting_for_next_8042_code=FALSE;
				}
			break;
		case WRITE_8042_OUTPUT_PORT_SEQUENCE:
			if ( (kbd_status & 0x8) == 0)
				{
#ifndef JOKER		/* Reset and GateA20 done in hardware for JOKER */
				if ( (cmd_code & 1) == 0)
					{
					host_error(EG_CONT_RESET,ERR_QUIT | ERR_RESET,NULL);
					}
				if ( (cmd_code & 2) == 2)
					{
#ifdef PM
				   if ( !gate_a20_status )
				      {
#ifdef NTVDM
				      /* call xms function to deal with A20 */
				      xmsDisableA20Wrapping();
#else
				      sas_disable_20_bit_wrapping();
#endif /* NTVDM */
				      gate_a20_status = 1;
					}
				   }
				else
				   {
				   if ( gate_a20_status )
				      {
#ifdef NTVDM
				      xmsEnableA20Wrapping();
#else
				      sas_enable_20_bit_wrapping();
#endif /* NTVDM */
				      gate_a20_status = 0;
				      }
#else
				   host_error(EG_GATE_A20,ERR_QUIT | ERR_RESET | ERR_CONT,NULL);
#endif /* PM */
				   }
#endif /* JOKER */

				if ( (cmd_code & 0x10) == 0)
					{
					int_enabled=FALSE;
					}
				else
					{
					int_enabled=TRUE;
					}
#ifdef PM
				op_port_remembered_bits=cmd_code & 0x2e;
#else
				op_port_remembered_bits=cmd_code & 0x2c;
#endif /* PM */
				}
			else
				{
				waiting_for_next_8042_code=FALSE;
				}
			break;
		} /* end of switch */
	}

if (!waiting_for_next_8042_code)
	{
	switch (cmd_code)
		{
		case 0x20:
			/* Read cmd byte */
			code_to_send=cmd_byte_8042;
			code_to_send_valid=TRUE;
			break;
		case 0x60:
			/* Write cmd byte */
			waiting_for_next_8042_code=TRUE;
			next_8042_code_sequence_number=WRITE_8042_CMD_BYTE_SEQUENCE;
			break;
		case 0xaa:
			/* Self Test (always returns 'pass') */
			code_to_send=0x55;
			code_to_send_valid=TRUE;
			break;
		case 0xab:
			/* Interface Test (always returns 'pass') */
			code_to_send=0x00;
			code_to_send_valid=TRUE;
			break;
		case 0xad:
			/* Disable keyboard interface */
#if defined(KOREA)
                        // To fix HaNa spread sheet IME hot key problem
                        if( bIgnoreExtraKbdDisable )
                            break;
#endif
			cmd_byte_8042 |= 0x10;
			keyboard_interface_disabled=TRUE;
			break;
		case 0xae:
			/* Enable keyboard interface */
			cmd_byte_8042 &= 0xef;
			if ((cmd_byte_8042 & 0x20) == 0)
				{
				keyboard_interface_disabled=FALSE;
				}
			break;
		case 0xc0:
			/* Read Input Port */
			/* But don't cause an interrupt */
			code_to_send_valid=TRUE;
			break;
		case 0xd0:
			/* Read Output Port */
			code_to_send=0xc1 + op_port_remembered_bits;
			code_to_send_valid=TRUE;
			break;
		case 0xd1:
			/* Write to Output Port */
			waiting_for_next_8042_code=TRUE;
			next_8042_code_sequence_number=WRITE_8042_OUTPUT_PORT_SEQUENCE;
			break;
		case 0xe0:
			/* Read Test Input */
			code_to_send=0x02;
			code_to_send_valid=TRUE;
			break;

#ifndef JOKER		/* Reset and GateA20 done in hardware for JOKER */
		case 0xf0:
		case 0xf1:
		case 0xf2:
		case 0xf3:
		case 0xf4:
		case 0xf5:
		case 0xf6:
		case 0xf7:
		case 0xf8:
		case 0xf9:
		case 0xfa:
		case 0xfb:
		case 0xfc:
		case 0xfd:
		case 0xfe:
		case 0xff:

#ifndef MONITOR
/*
 *  For reasons which I don't understand the monitor never
 *  did emulate the cpu_interrupt - HW_RESET in pr 1.0.
 *  and still doesn't in 1.0a. although maybe it should
 *  do something. Note this is required for 286 style pm.
 *  06-Dec-1993 Jonle
 *
 */

			/* Pulse Output Port bits */

			if ((cmd_code & 1) == 0)
				{
				/* pulse the reset line */
#ifdef PM
#ifndef NTVDM
				reset_was_by_kbd = TRUE;
#endif
#ifdef CPU_30_STYLE
				cpu_interrupt(CPU_HW_RESET, 0);
#else /* CPU_30_STYLE */
				cpu_interrupt_map |= CPU_RESET_EXCEPTION_MASK;
				host_cpu_interrupt();
#endif /* CPU_30_STYLE */
#endif
				sure_note_trace0(AT_KBD_VERBOSE,"CPU RESET via keyboard");
				}
#endif /* ! MONITOR */
			break;
#endif /* JOKER */

		} /* end of switch */
	}
else
	{
	waiting_for_next_8042_code=FALSE;
	}

#endif    //NEC_98
	
/*Is there a valid code to put in the 8042 output buffer? Values written
  to the 8042 output buffer as a conseqence of a 8042 command do not
	generate an interrupt. Output generated by 8042 commands must be presented to
	the application at the next INB, failure to do so it likely to result in the
  8042 being placed in an unusable state. */

if (code_to_send_valid)
	{
#ifdef NTVDM
        /*
         *  force filling of Kbd data port just like the real kbd
         *  since we no longer clear output_full in the Kbd_inb routine
         */
        output_full = FALSE;
        KbdData = -1;
#else /* NTVDM else */

	/* Transfer 8042 command output to output buffer, overwriting value
	   already in the buffer. */

		output_contents = (char)code_to_send;
		kbd_status |= 1;			/* Character now available! */

#endif /* end of NTVDM else */
	}

} /* end of cmd_to_8042 */




LOCAL half_word translate_6805_8042 IFN0()
{

half_word first_code,code;

/* performs the translation on scan codes which is done by the
   8042 keyboard controller in a real XT286 */

first_code=remove_from_6805_buff();

if (translating)
	{
	sure_note_trace1(AT_KBD_VERBOSE,"translating code %#x",first_code);
	if (first_code==0xf0)
		{
		if (free_6805_buff_size<BUFF_6805_VMAX) {
			code=remove_from_6805_buff();
			sure_note_trace1(AT_KBD_VERBOSE,"translating code %#x",code);
			if ((code != 0xfa) && (code != 0xfe)) {
				code=trans_8042[code]+0x80;
			}
			else {
				waiting_for_upcode=TRUE;
			}
			sure_note_trace1(AT_KBD_VERBOSE,"translated to %#x",code);
			waiting_for_upcode=FALSE;
			}
		else {
			waiting_for_upcode=TRUE;
			}
		}
	else
		{
		code=trans_8042[first_code];
		if (waiting_for_upcode) {
			if ((code !=0xfa) &&(code != 0xfe)){
				code+=0x80;
				waiting_for_upcode=FALSE;
			}
		}
		sure_note_trace1(AT_KBD_VERBOSE,"translated to %#x",code);
		}
	}
else
	{
	code=first_code;
	}
return (code);
} /* end of translate_6805_8042 */

#ifdef HUNTER
/*
** Put a scan code into the 8042 single char buffer.
** Called from do_hunter() in hunter.c
*/

#define HUNTER_REJECTED_CODES_LIMIT 100

int hunter_codes_to_translate IFN1( half_word, scan_code )
{
	LOCAL ULONG rejected_scan_codes = 0;

	sure_note_trace1(HUNTER_VERBOSE,"Requesting scan=%d",scan_code);

	if (!pending_8042 && !keyboard_interface_disabled && !output_full)
	{
		do_q_int(scan_code);
		sure_note_trace1( HUNTER_VERBOSE, "Accepted scan=%d", scan_code );

		rejected_scan_codes = 0;

		return( TRUE );
	}
	else
	{
		sure_note_trace0( HUNTER_VERBOSE, "Rejected scan" );

		if( rejected_scan_codes++ > HUNTER_REJECTED_CODES_LIMIT )
		{
			printf( "Application hung up - not reading scan codes\n" );
			printf( "Trapper terminating\n" );

			terminate();
		}

		return( FALSE );
	}
} /* end of hunter_codes_to_translate() */

#endif /* HUNTER */

/*
** Returns number of chars in buffer.
** As buffer is quite small there can either be 1 char or none in it.
*  This needs to be global for HUNTER, but only needs be local otherwise.
*/
#ifdef HUNTER
GLOBAL INT
#else
LOCAL INT
#endif
buffer_status_8042 IFN0()
{
	if (!pending_8042 && !keyboard_interface_disabled && !output_full)
		return( 0 );
	else
		return( 1 );
} /* END 8042_buffer_status() */

LOCAL VOID codes_to_translate  IFN0()
{
	char tempscan;

while (!pending_8042 && (free_6805_buff_size < BUFF_6805_VMAX) && !keyboard_interface_disabled && !output_full)
	{
		tempscan= translate_6805_8042();
		if (!waiting_for_upcode) {
			do_q_int(tempscan);
		}
	}
} /* end of codes_to_translate */

/* Thanks to Jonathan Lew of MS for code tidyup in this fn */
GLOBAL VOID continue_output IFN0()
{
char tempscan;

#ifdef NTVDM
if (bKbdEoiPending || keyboard_interface_disabled) {
    return;
    }
#endif

if(!output_full)
	{
	if (pending_8042)
		{
                pending_8042=FALSE;
                do_q_int(pending_8042_value);
		}
	else
		{
		if ((free_6805_buff_size < BUFF_6805_VMAX) && (!keyboard_interface_disabled))
			{
			tempscan=translate_6805_8042();
                        if (!waiting_for_upcode) {
                                do_q_int(tempscan);
                                }
			}
		}
        }
#ifdef NTVDM
else
    KbdIntDelay();
#endif

} /* end of continuous_output */


#ifdef NTVDM

/*  NT port:
 *  the host (nt_event.c) calls this to notify that
 *  it is resuming after blocking, to do any reinitialization
 *  necessary
 *
 *  - resets kbd flow regulators
 */
GLOBAL VOID KbdResume(VOID)
{
    WaitKbdHdw(0xffffffff);
    bKbdEoiPending = FALSE;
    bKbdIntHooked = FALSE;
    bBiosBufferSpace = TRUE;
    if (!keyboard_interface_disabled && output_full)
        KbdIntDelay();
    HostReleaseKbd();
}
#endif	/* NTVDM */


#ifndef NTVDM
/* allowRefill -- used in conjunction with the Delayed Quick Event
** below (kbd_inb from port 0x60 while the keyboard interface is
** enabled.) This is called 10ms after a dubious read from port 0x60
** and allows the port to be overwritten with the next scancode.
*/

LOCAL VOID allowRefill IFN1(long, unusedParam)
{
	UNUSED(unusedParam);

	/* Clear "refillDelayedHandle" so we know we're all clear... */

	refillDelayedHandle = 0;

	/* continue with filling the buffer... */
	continue_output();
}
#endif

GLOBAL VOID kbd_inb IFN2(io_addr,port,half_word *,val)
{
	sure_note_trace1(AT_KBD_VERBOSE,"kbd_inb(%#x)...", port);

#ifdef NTVDM	/* JonLe NTVDM Mod */

     if (!bBiosOwnsKbdHdw && WaitKbdHdw(0xffffffff))  {
         return;
         }


     if (!(DelayIrqLine & 0x2) || KbdData == -1) {
         if (bDelayIntPending) {
             bDelayIntPending = FALSE;
             kbd_status |= 1;
             }
         KbdData = output_contents;

         }
#endif

#if defined(NEC_98)
port &= KEYBD_STATUS_CMD;

    if (port==KEYBD_STATUS_CMD)
        {
        *val=kbd_status;
        }
    else
#else    //NEC_98
	port &= 0x64;

	if (port==0x64)
	{
		*val = kbd_status;
	}
	else									/* port == 0x60 */
#endif    //NEC_98

#ifdef NTVDM	/* JonLe NTVDM Mod */

        {

        *val=KbdData;
#if defined(NEC_98)
        kbd_status &= 0xfd;
#else    //NEC_98
        kbd_status &= 0xfe;
#endif   //NEC_98
        sure_note_trace1(AT_KBD_VERBOSE,"scan code read:0x%x",*val);


	    // Sloppy keyboard fix is not needed for the NT port. An EOI
        // hook is used to control priming of the adapter.

        }

     if (!bBiosOwnsKbdHdw)
         HostReleaseKbd();

#else	/* not NTVDM */

	{
		*val=output_contents;

		output_full = FALSE;

#if defined(NEC_98)
                kbd_status &= 0xfd;
#else    //NEC_98
		kbd_status &= 0xfe;		/* Mask out "char avail" bit */
#endif   //NEC_98

		/* Other ports should really clear this IRQ as well, but... */

#ifdef JOKER
		ica_clear_int(KEYBOARD_INT_ADAPTER, KEYBOARD_INT_LINE);
#endif	/* JOKER */

		/* <tur 06-Jul-93> BCN 2040 Replace previous horrible hack with a better one!
		**
		** The following is to cope with programs that read this port more than once
		** expecting the same value each time, while the keyboard interface is ENABLED.
		** On a real PC, this port is filled via a serial connection, and so there's at
		** least a few milliseconds before a new char arrives and the port is overwritten.
		** SoftPC, however, doesn't have this delay; ideally, we'd like to
		** refill the buffer immediately. However, if the keyboard interface is
		** enabled, we should delay refilling the buffer for a few ms.
		*/

		if (keyboard_interface_disabled) {		/* We're in business */

			/* NB: We have always assumed that anyone reading this port with the
			** Keyboard interface disabled will ONLY READ IT ONCE (like the BIOS.)
			**
			** Since this seems to work, let's just go ahead and refill the buffer.
			** (If any problems show up, we'll just have to do a quick event as in
			** the keyboard interface enabled case below.)
			*/

			/* If there is an outstanding sloppy read quick event delete it */
			if (refillDelayedHandle) {			
				delete_q_event(refillDelayedHandle);
				refillDelayedHandle = 0;
			}

			continue_output();

		}
		else {									/* keyboard interface is enabled */

			/* Do not allow port 0x60 to be overwritten for a few milliseconds.
			** Even 10 ms isn't as bad as the two whole timer ticks (100ms) which
			** is what it was doing previously.
			** Keyboard response for some games, including Windows, should now
			** be a good bit better.
			** The original code continued output after the second read of the port
			** with the interface enabled, which seems to imply that no PC apps have
			** been found which read the port more than twice while expecing the same
			** value. However, we now allow for multipe reads of the port, while enabled.
			** Under this circumstance the port will only be re-primed after the quick event
			** from the first sloppy read has been processed.
			*/

			if (!refillDelayedHandle) 			/* if we're not already delaying, delay! */
				refillDelayedHandle = add_q_event_t(allowRefill, KBD_CONT_DELAY, 0);

		}

	}
#endif	/* NTVDM */

	sure_note_trace2(AT_KBD_VERBOSE,"...kbd_inb(%#x) returns %#x", port, *val);

} /* end of kbd_inb */



GLOBAL VOID kbd_outb IFN2(io_addr,port,half_word,val)
{
	sure_note_trace2(AT_KBD_VERBOSE,"kbd_outb(%#x, %#x)", port, val);

#ifdef NTVDM
     if (!bBiosOwnsKbdHdw && WaitKbdHdw(0xffffffff))
     {
         return;
     }
#endif	/* NTVDM */

#if defined(NEC_98)
        port &= KEYBD_STATUS_CMD;
        if (port == KEYBD_STATUS_CMD)
                {
                cmd_to_8042(val);
                if (free_6805_buff_size < BUFF_6805_VMAX)
                        codes_to_translate();
                }
#else    //NEC_98
	port &= 0x64;
	if (port == 0x64)
	{
		kbd_status |= 0x08;
		cmd_to_8042(val);
	}
	else
	{
		cmd_byte_8042 &= 0xef;
		if ( !(cmd_byte_8042 & 0x20) )
			keyboard_interface_disabled=FALSE;

		kbd_status &= 0xf7;
		if (waiting_for_next_8042_code)
			cmd_to_8042(val);
		else
			cmd_to_6805(val);
	}
#endif // NEC_98

#ifndef NTVDM	/* JonLe NTVDM Mod */

	if (free_6805_buff_size < BUFF_6805_VMAX)
		codes_to_translate();

#else   /* NTVDM */

    bForceDelayInts = TRUE;
	continue_output();
    bForceDelayInts = FALSE;

        if (!bBiosOwnsKbdHdw)
             HostReleaseKbd();

#endif	/* NTVDM */

} /*end of kbd_outb */

#ifndef NTVDM
/* Nothing seems to call this. I've no idea why it's here ... Simion */
/* I have been assured that these functions are used by sun - gvdl */

GLOBAL int status_6805_buffer IFN0()
{
	int	free_space;

	free_space = BUFF_6805_VMAX-
		((buff_6805_in_ptr - buff_6805_out_ptr) & BUFF_6805_PMASK);
	if (free_space<0)
	{
		free_space=0;
		sure_note_trace0(AT_KBD_VERBOSE,"Keyboard buffer full");
	}
	return(free_space);
}

/*
 * Name: read_6805_buffer_variables
 *
 * Purpose:	To allow the host to access the state of the 6805 buffer
 *		This means eg. on Sun that cut/paste can be optimised.
 *
 * Output:	*in_ptr - value of the 6805 start pointer.
 * Output:	*out_ptr - value of the 6805 end pointer.
 * Output:	*buf_size - value of the 6805 buffer size.
 */
GLOBAL void read_6805_buffer_variables IFN3(
int	*, in_ptr,
int	*, out_ptr,
int	*, buf_size)
{
	*in_ptr = buff_6805_in_ptr;
	*out_ptr = buff_6805_out_ptr;
	*buf_size = BUFF_6805_PMASK;
}

GLOBAL VOID insert_code_into_6805_buf IFN1(half_word,code)
{
	sure_note_trace1(AT_KBD_VERBOSE,"got real keyboard scan code : %#x",code);
	add_codes_to_6805_buff(1,&code);
	sure_note_trace1(AT_KBD_VERBOSE,"new free buf size = %#x",free_6805_buff_size);
	if (code != 0xf0) {
		codes_to_translate();
	}
}
#endif /* ! NTVDM */

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

GLOBAL VOID AT_kbd_post IFN0()
{
#if defined(NEC_98)
        kbd_status = 0x85;
#else    //NEC_98
	kbd_status = 0x14;
#endif   //NEC_98

#ifndef NTVDM
	/* Clear out any pending keyboard buffer (port 0x60) refill delays */
        refillDelayedHandle = 0;
#endif
}

#if defined(IRET_HOOKS) && defined(GISP_CPU)
/*(
 *======================= KbdHookAgain() ============================
 * KbdHookAgain
 *
 * Purpose
 *	This is the function that we tell the ica to call when a keybd
 *	interrupt service routine IRETs.
 *
 * Input
 *	adapter_id	The adapter id for the line. (Note the caller doesn't
 *			know what this is, he's just returning something
 *			we gave him earlier).
 *
 * Outputs
 *	return	TRUE if there are more interrupts to service, FALSE otherwise.
 *
 * Description
 * 	Check if we have a delayed scancode, if so then generate the kbd int
 *	and return TRUE, else return FALSE
)*/

GLOBAL IBOOL		
KbdHookAgain IFN1(IUM32, adapter)
{	char scancode;

	if (HostPendingKbdInt(&scancode))
	{	/* We have a host delayed scancode, so generate a kdb int. */
		sure_note_trace0(AT_KBD_VERBOSE,"callback with saved code");
		output_full = TRUE;
		do_int ((long) scancode);
		return(TRUE);	/* more to do */
	}
	else
	{
		sure_note_trace0(AT_KBD_VERBOSE,"no saved data after IRET");
		return(FALSE);
	}
}

#endif /* IRET_HOOKS && GISP_CPU */

#ifndef NTVDM

GLOBAL VOID AT_kbd_init IFN0()
{
	int key,i;
	SHORT videoAdapt;

	sure_note_trace0(AT_KBD_VERBOSE,"AT Keyboard initialisation");

#if defined(IRET_HOOKS) && defined(GISP_CPU)
	/*
	 * Remove any existing hook call-back, and re-instate it afresh.
	 * KbdHookAgain is what gets called on a keyboard int iret.
	 */

	Ica_enable_hooking(KEYBOARD_INT_LINE, NULL, KEYBOARD_INT_ADAPTER);
	Ica_enable_hooking(KEYBOARD_INT_LINE, KbdHookAgain, KEYBOARD_INT_ADAPTER);

	/* Host routine to reset any internal data for IRET_HOOK delayed ints. */
	HostResetKdbInts();

#endif /* IRET_HOOKS && GISP_CPU */

#ifdef	macintosh
	if (!make_arrays)
	{
		/* Allocate the world and its mother. Why does something as "simple"
		** as the keyboard require more global data than the video emulation?
		** Just wondering.
		*/
		make_arrays = (half_word **)host_malloc(134*sizeof(half_word *));
		break_arrays = (half_word **)host_malloc(134*sizeof(half_word *));
		set_3_key_state = (half_word *)host_malloc(127*sizeof(half_word));
		key_down_count = (int *)host_malloc(127*sizeof(int));
		scan_codes_temp_area = (half_word *)host_malloc(300*sizeof(half_word));
	}
#endif	/* macintosh */

#ifndef NEC_98
	videoAdapt = (ULONG) config_inquire(C_GFX_ADAPTER, NULL);
#endif   //NEC_98

	buff_6805_out_ptr=0;
	clear_buff_6805 ();
	key_set=DEFAULT_SCAN_CODE_SET;
	current_light_pattern=0;
#ifdef REAL_KBD
	send_to_real_kbd(0xf6); /* set default */
	wait_for_ack_from_kb();
#endif
	host_kb_light_on (7);

#ifndef REAL_KBD
#if defined(NEC_98)
        for (key=0;key<144;key++)
        {
                set_3_key_state [key] = most_set_1_make_codes [key];
                key_down_count[key]=0;
        }
#else    //NEC_98
	for (key=0;key<127;key++)
	{
		set_3_key_state [key] = set_3_default_key_state [key];
		key_down_count[key]=0;
	}
#endif   //NEC_98
	repeat_delay_target=2*BASE_DELAY_UNIT;
	repeat_target=DEFAULT_REPEAT_TARGET;
#endif
	typematic_key_valid = waiting_for_next_code =
		waiting_for_next_8042_code=FALSE;
	shift_on = l_shift_on = r_shift_on=FALSE;
	ctrl_on = l_ctrl_on = r_ctrl_on=FALSE;
	alt_on = l_alt_on = r_alt_on=FALSE;
	waiting_for_upcode=FALSE;
	input_port_val=0xbf;
#if defined(NEC_98)
        kbd_status = 0x85;
#else    //NEC_98
	if (videoAdapt == MDA || videoAdapt == HERCULES)
		input_port_val |= 0x40;
	kbd_status = 0x10;
#endif   //NEC_98
	cmd_byte_8042=0x45;
	keyboard_disabled = keyboard_interface_disabled=FALSE;
	op_port_remembered_bits=0xc;

#ifdef PM
	if ( gate_a20_status )
	{
                sas_enable_20_bit_wrapping();
                gate_a20_status = 0;
	}
#endif

	pending_8042 = output_full = in_anomalous_state=FALSE;
#if defined(NEC_98)
        int_enabled = TRUE;
        translating = FALSE;
        scanning_discontinued=FALSE;
        held_event_count=0;


        io_define_inb(KEYB_ADAPTOR, kbd_inb);
        io_define_outb(KEYB_ADAPTOR, kbd_outb);

        for (i=KEYBD_PORT_START;i<=KEYBD_PORT_END;i+=2)
                io_connect_port(i, KEYB_ADAPTOR, IO_READ_WRITE);
#else    //NEC_98
	int_enabled = translating=TRUE;
	scanning_discontinued=FALSE;
	held_event_count=0;

	io_define_inb(AT_KEYB_ADAPTOR, kbd_inb);
	io_define_outb(AT_KEYB_ADAPTOR, kbd_outb);

	for (i=KEYBA_PORT_START;i<=KEYBA_PORT_END;i+=2)
		io_connect_port(i, AT_KEYB_ADAPTOR, IO_READ_WRITE);
#endif   //NEC_98

#ifndef REAL_KBD
	init_key_arrays();
#endif

	host_kb_light_off (5);
	num_lock_on = TRUE;

	host_key_down_fn_ptr = host_key_down;
	host_key_up_fn_ptr = host_key_up;
	do_key_repeats_fn_ptr = do_key_repeats;

} /* end of AT_kbd_init */

#else	/* NTVDM */

GLOBAL VOID AT_kbd_init()
{
       IU16 i;

       sure_note_trace0(AT_KBD_VERBOSE,"AT Keyboard initialisation");

       clear_buff_6805 ();
#if defined(NEC_98)
       key_set=DEFAULT_SCAN_CODE_SET;
       i = 144;
       while (i--)
          set_3_key_state [i] = most_set_1_make_codes [i];
       input_port_val=0xbf;
       kbd_status = 0x85;
       cmd_byte_8042=0x45;
       op_port_remembered_bits=0xc;
       int_enabled = TRUE;
       translating = FALSE;

       io_define_inb(KEYB_ADAPTOR, kbd_inb);
       io_define_outb(KEYB_ADAPTOR, kbd_outb);

       for (i=KEYBD_PORT_START;i<=KEYBD_PORT_END;i+=2)
                io_connect_port(i, KEYB_ADAPTOR, IO_READ_WRITE);

#else    //NEC_98
       key_set=2;
       i = 127;
       while (i--)
          set_3_key_state [i] = set_3_default_key_state [i];

       input_port_val=0xbf;
       kbd_status = 0x10;
       cmd_byte_8042=0x45;
       op_port_remembered_bits=0xc;

       int_enabled = translating = TRUE;

       io_define_inb(AT_KEYB_ADAPTOR, kbd_inb);
       io_define_outb(AT_KEYB_ADAPTOR, kbd_outb);

       for (i=KEYBA_PORT_START;i<=KEYBA_PORT_END;i+=2)
               io_connect_port(i, AT_KEYB_ADAPTOR, IO_READ_WRITE);
#endif //NEC_98
       init_key_arrays();

       num_lock_on = TRUE;
       host_key_down_fn_ptr = host_key_down;
       host_key_up_fn_ptr = host_key_up;

       /* Register an EOI hook for the keyboard */
       RegisterEOIHook(KEYBOARD_INT_LINE,KbdEOIHook);


} /* end of AT_kbd_init */
#endif	/* NTVDM */

#if defined(NEC_98)
//added to save caps & kana key state.
#define    CAPS_INDEX    0x1E      //970619
#define    KANA_INDEX    0x45      //970619
void nt_NEC98_save_caps_kana_state(void)
{
    nt_NEC98_caps_state = key_down_count[CAPS_INDEX];
    nt_NEC98_kana_state = key_down_count[KANA_INDEX];
    key_down_count[CAPS_INDEX] = 0;
    key_down_count[KANA_INDEX] = 0;
}

void nt_NEC98_restore_caps_kana_state(void)
{
    key_down_count[CAPS_INDEX] = nt_NEC98_caps_state;
    key_down_count[KANA_INDEX] = nt_NEC98_kana_state;
}
#endif    //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\keymouse\keybd_io.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 2.0
 *
 * File:	: keybd_io.c
 *
 * Title        : Bios Keyboard Interface function
 *
 * Sccs ID	: @(#)keybd_io.c	1.35 06/27/95
 *
 * Description  : This package contains a group of functions that provide
 *                a logical keyboard interface:
 *
 *                keyboard_init()       Initialise the keyboard interface.
 *                keyboard_int()        Deal with a character from the keyboard
 *                                      and place them in the BIOS buffer.
 *                keyboard_io()         User routine to read characters from
 *                                      the BIOS buffer.
 *		  bios_buffer_size()	How many chars in the buffer ?
 *
 * Author       : Rod Macgregor / Henry Nash
 *
 * Modified     : Jon Eyre / Jim Hatfield / Uncle Tom Cobbley and all
 *
 * Modfications : This module is now designed to be totally portable, it
 *                represents both the hardware and user interrupt interfaces.
 *                These two functions are provided by the routines
 *                keyboard_int & keyboard_io. The system will initialise
 *                itself by a call to keyboard_init.
 *
 *                The user is expected to supply the following host dependent
 *                routines for this module, tagged as follows:-
 *
 *                [HOSTSPECIFIC]
 *
 *                host_alarm(duration)
 *                long int duration ;
 *                                 - ring the host's bell.
 *
 *                host_kb_init()   - any local initialisations required when
 *                                   keyboard_init is called.
 *
 *		  Removed calls to cpu_sw_interrupt and replaced with
 *		  host_simulate
 *
 */

#ifdef SCCSID
static char SccsID[]="@(#)keybd_io.c	1.35 06/27/95 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_BIOS.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH
#include TimeH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "bios.h"
#include "ios.h"
#include "ppi.h"
#include "keyboard.h"
#include "timeval.h"
#include "timer.h"
#include "keyba.h"
#include "ica.h"
#ifndef PROD
#include "trace.h"
#endif

#include "debug.h"
#include "idetect.h"

extern void host_simulate();

/*
 * ============================================================================
 * External routines
 * ============================================================================
 */

/*
 * ============================================================================
 * Local static data and defines
 * ============================================================================
 */

#define SHIFT_KEY_SIZE 8
#define ALT_TABLE_SIZE 36

/*
 * lookup table to check if the scan code received is a shift key
 */
static sys_addr shift_keys;

/*
 * corresponding table to 'shift_keys' to set relevant bits in masks when
 * shift scan code received
 */
static sys_addr shift_masks;

/*
 * next two tables give values of chars when control key depressed. First
 * table (ctl_n_table) is for main keyboard values and second (ctl_f_table)
 * is for the function keys and keypad.
 */
static sys_addr ctl_n_table;
static sys_addr ctl_f_table;

/*
 * values of ascii keys dependiing on shift or caps states
 */
static sys_addr lowercase;
static sys_addr uppercase;


/*
 * remapping of some keys when alt key depressed. note 1st ten are for
 * keypad entries.
 */
static sys_addr alt_table;

/* Add variables for all these entry points instead of the previously used
 * defines. This allows modification of these entry points from a loaded
 * driver, when the Insignia bios may not be in the loaded in the default
 * or assumed location.
 */

#if defined(NTVDM) && defined(LOCAL)
/*
 * Make static fns and globals visible to win32 debuggers
 */
#undef LOCAL
#define LOCAL
#endif

#ifndef GISP_SVGA
LOCAL word int15_seg = RCPU_INT15_SEGMENT,
	   int15_off = RCPU_INT15_OFFSET;

LOCAL word int1b_seg = KEYBOARD_BREAK_INT_SEGMENT,
	   int1b_off = KEYBOARD_BREAK_INT_OFFSET;

LOCAL word int05_seg = PRINT_SCREEN_INT_SEGMENT,
	   int05_off =	PRINT_SCREEN_INT_OFFSET;

LOCAL word rcpu_nop_segment = RCPU_NOP_SEGMENT,
	   rcpu_nop_offset  = RCPU_NOP_OFFSET;

LOCAL word rcpu_poll_segment = RCPU_POLL_SEGMENT,
	   rcpu_poll_offset  = RCPU_POLL_OFFSET;
#else /* GISP_SVGA */
/* If we are GISP_SVGA the segments will be variables anyway */
#define int15_seg  RCPU_INT15_SEGMENT
LOCAL word	int15_off = RCPU_INT15_OFFSET;

#define int1b_seg  KEYBOARD_BREAK_INT_SEGMENT
LOCAL word   int1b_off = KEYBOARD_BREAK_INT_OFFSET;

#define int05_seg  PRINT_SCREEN_INT_SEGMENT
LOCAL word  int05_off =	PRINT_SCREEN_INT_OFFSET;

#define rcpu_nop_segment  RCPU_NOP_SEGMENT
LOCAL word  rcpu_nop_offset  = RCPU_NOP_OFFSET;

#define rcpu_poll_segment  RCPU_POLL_SEGMENT
LOCAL word rcpu_poll_offset  = RCPU_POLL_OFFSET;
#endif /* GISP_SVGA */

#if defined(IRET_HOOKS) && defined(GISP_CPU)
IMPORT VOID  HostAllowKbdInt();  /* Allow keybd Ints without an IRET */
#endif /* IRET_HOOKS && GISP_CPU */

#ifdef NTVDM

#include "error.h"

GLOBAL word wait_int_seg = RCPU_WAIT_INT_SEGMENT;
GLOBAL word wait_int_off = RCPU_WAIT_INT_OFFSET;
GLOBAL word dr_type_seg = DR_TYPE_SEGMENT;
GLOBAL word dr_type_off = DR_TYPE_OFFSET;
GLOBAL sys_addr dr_type_addr = DR_TYPE_ADDR;
/* Global var to indicate whether keyboard bios or hardware owns the keyboard mutex. */
GLOBAL BOOL bBiosOwnsKbdHdw;
IMPORT ULONG WaitKbdHdw(ULONG dwTimeOut);
IMPORT VOID  HostReleaseKbd();
IMPORT VOID  HostResetKbdNotFullEvent();
IMPORT VOID  HostSetKbdNotFullEvent();
GLOBAL VOID  TryKbdInt(VOID);
IMPORT VOID  ResumeTimerThread(VOID);
IMPORT VOID  WaitIfIdle(VOID);


#define FREEKBDHDW()	bBiosOwnsKbdHdw = \
                      ( bBiosOwnsKbdHdw ? HostReleaseKbd(), FALSE : FALSE )


/* for optimizing timer hardware interrupt generation defined in timer.c */
extern word TimerInt08Seg;
extern word TimerInt08Off;
extern word TimerInt1CSeg;
extern word TimerInt1COff;
extern word KbdInt09Seg;
extern word KbdInt09Off;
extern BOOL VDMForWOW;

void Keyb16Request(half_word BopFnCode);

/* optimizes 16 bit handler */
extern word *pICounter;
extern word *pCharPollsPerTick;
extern word *pShortIdle;
extern word *pIdleNoActivity;


// STREAM_IO codes are disabled on NEC_98.
#ifndef NEC_98
extern half_word * stream_io_buffer;
extern word * stream_io_dirty_count_ptr;
extern word stream_io_buffer_size;
extern sys_addr stream_io_bios_busy_sysaddr;
#endif // !NEC_98

#else
#define FREEKBDHDW()	/* Nothing for conventional SoftPC */
#endif	/* NTVDM */

/*
 * Mix in global defined data as well.
 */

#ifndef GISP_SVGA
GLOBAL word rcpu_int1C_seg = USER_TIMER_INT_SEGMENT;
GLOBAL word rcpu_int1C_off = USER_TIMER_INT_OFFSET;

GLOBAL word rcpu_int4A_seg = RCPU_INT4A_SEGMENT;
GLOBAL word rcpu_int4A_off = RCPU_INT4A_OFFSET;
#else /* GISP_SVGA */

/* For GISPSVGA the segs will already be variables */
#define	rcpu_int1C_seg = USER_TIMER_INT_SEGMENT;
GLOBAL word rcpu_int1C_off = USER_TIMER_INT_OFFSET;

#define	rcpu_int4A_seg = RCPU_INT4A_SEGMENT;
GLOBAL word rcpu_int4A_off = RCPU_INT4A_OFFSET;
#endif /* GISP_SVGA */

GLOBAL word dummy_int_seg = 0;
GLOBAL word dummy_int_off = 0;

#ifdef NTVDM
GLOBAL word int13h_vector_off;
GLOBAL word int13h_vector_seg;
GLOBAL word int13h_caller_off;
GLOBAL word int13h_caller_seg;
#endif /* NTVDM */
#if defined(JAPAN) && defined(NTVDM) && !defined(NEC_98)
GLOBAL word int16h_caller_off;
GLOBAL word int16h_caller_seg = 0;
#endif // JAPAN, NTVDM, !NEC_98

#if defined(NTVDM) && defined(MONITOR)
/*
** Microsoft special.
** These variables are set below in kb_setup_vectors(), to addresses
** passed by NTIO.SYS via BOP 5F -> MS_bop_F() -> kb_setup_vectors()
** Tim June 92.
*/
/*
** New ntio.sys variables for video ROM matching. Tim August 92.
*/
GLOBAL word int10_seg=0;
GLOBAL word int10_caller=0;
GLOBAL word int10_vector=0; /* Address of native int 10*/
GLOBAL word useHostInt10=0; /* var that chooses between host video ROM or BOPs */
GLOBAL word babyModeTable=0; /* Address of small mode table lives in ntio.sys */
GLOBAL word changing_mode_flag=0; /* ntio.sys var to indicate vid mode change */
GLOBAL word vga1b_seg = 0;
GLOBAL word vga1b_off = 0;   /* VGA capability table normally in ROM */
GLOBAL word conf_15_off = 0;
GLOBAL word conf_15_seg = 0; /* INT15 config table normally in ROM */

void printer_setup_table(sys_addr table_addr);

#endif /* NTVDM & MONITOR */

extern int soft_reset   ;	/* set for ctl-alt-dels			*/

/*
 * ============================================================================
 * Local macros
 * ============================================================================
 */

LOCAL VOID exit_from_kbd_int IPT0();

/*
 * Function to increment BIOS buffer pointers, returns new one
 */
LOCAL word inc_buffer_ptr IFN1(word, buf_p)
{
	buf_p += 2;
	if (buf_p == sas_w_at_no_check(BIOS_KB_BUFFER_END))
		buf_p = sas_w_at_no_check(BIOS_KB_BUFFER_START);

	return buf_p;
}





/*
 * ============================================================================
 * Internal functions
 * ============================================================================
 */


/*
 *	Routine to translate scan code pairs for standard calls
 *	Returns CF set if this scancode/char pair should be thrown away.
 */
LOCAL VOID translate_std IFN0()
{
    IU8	ah, al;
    enum {dontSetCF, setCF0, setCF1} cfSet = dontSetCF;

    ah = getAH();
    al = getAL();

    if ( ah == 0xE0 )			/* is it keypad enter or /	*/
    {
	if ( (al == 0x0D) || (al == 0x0A) )
	     setAH( 0x1C );		/* code is enter 		*/
	else
	     setAH( 0x35 );		/* must be keypad ' / '		*/

	cfSet = setCF0;
    }
    else
    {
	if ( ah > 0x84 )		/* is it an extended one     	*/
	    cfSet = setCF1;
	else
	{
	    if( al == 0xF0 )		/* is it one of the 'fill ins'  */
	    {
		if ( ah == 0)		/* AH = 0 special case		*/
		    cfSet = setCF0;
		else
		    cfSet = setCF1;	/* Delete me */
	    }
	    else
	    {
		if ( (al == 0xE0) && (ah != 0) )
		    setAL( 0 );		/* convert to compatible output	*/

		cfSet = setCF0;
	    }
	}
    }

    if (cfSet != dontSetCF)
    	setCF(cfSet == setCF1);
}


static void translate_ext()
/*
 *	Routine to translate scan code pairs for extended calls
 */
{
   if ( (getAL() == 0xF0 ) && (getAH() != 0) )
	setAL( 0 );
}

/*
 * Send command or data byte to the keyboard and await for the acknowledgemnt
 */

/*
 * Arbitrary retry limits - experiments suggest that we always succeed
 * on the first try in a pure SoftWindows.  A "real keyboard" version may
 * be different.
 */

#define WAIT_RETRY	5
#define RESEND_RETRY	3

LOCAL VOID send_data IFN1(half_word, data)
{
	int resend_retry;
	word CS_save, IP_save;
	half_word var_kb_flag_2;

        note_trace1(BIOS_KB_VERBOSE,"Cmd to kb i/o buff:0x%x",data);

	/*
	 * Save  CS:IP before calling a recursive CPU to handle the interrupt
	 * from the keyboard
	 */

	CS_save = getCS();
	IP_save = getIP();

	/*
	 * Set the retry flag ( KB_FE ) to force outb() at least once.  If
	 * we have real keyboard hardware this may get set again if the
	 * hardware didn't understand the command for some reason e.g.
	 * garbled by the serial line.
	 */

	var_kb_flag_2 = sas_hw_at(kb_flag_2) | KB_FE;
	resend_retry = RESEND_RETRY;

	do
	{
		IBOOL resend_command;
		int wait_retry;
		
		resend_command = (var_kb_flag_2 & KB_FE) != 0;
		wait_retry = WAIT_RETRY;

		/* Clear resend, acknowledge and error flags */
		var_kb_flag_2 &= ~(KB_FE + KB_FA + KB_ERR);

		/*
		 * Update Intel memory with cleared down flags *BEFORE*
		 * the outb(), which may set the acknowledge flag, if we
		 * execute enough Intel due to virtualisation.
		 */

		sas_store(kb_flag_2, var_kb_flag_2);

		/* Do the outb if necessary */

		if( resend_command )
		{
			outb(KEYBA_IO_BUFFERS, data);
		}

		/* Look for one of the flag bits to be set or time out */

		while( !(var_kb_flag_2 & (KB_FA + KB_FE + KB_ERR))
						&& ( --wait_retry > 0 ))
		{
			/*
			 * Process interrupt from kb.
			 *
			 * Note for perplexed keyboard debuggers:
			 *   Keyboard interrupts are delayed for a few
			 *   Intel instructions using quick events.  This
			 *   means that the IRR from the above outb() may
			 *   not be raised until we have done the following
			 *   sub-CPU a few times.
			 */

			setCS(rcpu_nop_segment);
			setIP(rcpu_nop_offset);
			host_simulate();

			/* Re-read flag byte to see if anything has happened */

			var_kb_flag_2 = sas_hw_at(kb_flag_2);
		}

		/* If we got an acknowledge we've succeeded */

		if (var_kb_flag_2 & KB_FA)
			break;

		/* Set up error flag (in case this is the last retry) */

		note_trace0(BIOS_KB_VERBOSE,"failed to get ack ... retry");
		var_kb_flag_2 |= KB_ERR;
	}
	while( --resend_retry > 0 );

	if (var_kb_flag_2 & KB_ERR)
	{
		note_trace0(BIOS_KB_VERBOSE,"no more retrys");

		/* Write back flags with error bit set */

		sas_store(kb_flag_2, var_kb_flag_2);
	}

	setCS(CS_save);
	setIP(IP_save);
}



LOCAL VOID check_indicators IFN1(IBOOL, eoi)
		/* end of interrupt flag - if set to non-zero 	*/
		/* 0x20 is written to port 0x20			*/
{
	half_word indicators ;
	half_word var_kb_flag_2;

	/* move switch indicators to bits 0-2	*/

	indicators = (sas_hw_at_no_check(kb_flag) & (CAPS_STATE + NUM_STATE + SCROLL_STATE)) >> 4;

	var_kb_flag_2 = sas_hw_at_no_check(kb_flag_2);
	/* compare with previous setting	*/
	if ((indicators ^ var_kb_flag_2) & KB_LEDS)
	{
		/* check if update in progress	*/
		if( (var_kb_flag_2 & KB_PR_LED) == 0)
		{
			/* No update in progress */
			var_kb_flag_2 |= KB_PR_LED;
			sas_store_no_check(kb_flag_2, var_kb_flag_2);
			if (eoi)
				outb(0x20, 0x20);

#if defined(NTVDM) || defined(GISP_CPU)
	/*
	 *  On the NT port we do not update the real kbd lights
	 *  so we don't need to do communicate with the kbd hdw (keyba.c)
	 *
	 *  If this ever changes for the NT port then do not use
	 *  send_data which forces us to switch context back to
	 *  16 bit and waits for a reply. Do this with a direct
	 *  call to the kbd Hdw
	 *
	 */

	/* set kb flag up with new status	*/

	var_kb_flag_2 = (var_kb_flag_2 & 0xf8) | indicators;
	sas_store_no_check(kb_flag_2, var_kb_flag_2);
#ifdef NTVDM
	host_kb_light_on (indicators);
#endif

#ifdef	GISP_CPU
	/*
	** We do update an emulation of the keyboard lights but we don't
	** want to do it via send_data and switching back to 16-bit.
	** We call the host routines directly.
	*/
	host_kb_light_on (indicators);
	host_kb_light_off ((~indicators)&0x7);

#endif	/* GISP_CPU */
#else	/* not NTVDM nor GISP_CPU */

			send_data(LED_CMD);

			/* set kb flag up with new status	*/
			var_kb_flag_2 = (sas_hw_at_no_check(kb_flag_2) & 0xf8) | indicators;
			sas_store_no_check(kb_flag_2, var_kb_flag_2);

			/* check error from previous send_data()	*/
			if( (var_kb_flag_2 & KB_ERR) == 0)
			{
				/* No error	*/
				send_data(indicators);

				/* test for error	*/
				if(sas_hw_at_no_check(kb_flag_2) & KB_ERR) {
					/* error!	*/
					note_trace0(BIOS_KB_VERBOSE,"got error sending change LEDs command");
					send_data(KB_ENABLE);
				}
			}
			else
				/* error!	*/
				send_data(KB_ENABLE);
#endif	/* NTVDM or GISP_CPU */

			/* turn off update indicator and error flag	*/
			sas_store_no_check (kb_flag_2, (IU8)(sas_hw_at_no_check(kb_flag_2) & ~(KB_PR_LED + KB_ERR)));
		}
	}
}

/*
 * ============================================================================
 * External functions
 * ============================================================================
 */

/*
** called from hunter.c:do_hunter()
** tells hunter about the BIOS buffer size so it will not over fill
** the BIOS buffer
** Used in no Time Stamp mode only.
**
** Also useful in host paste code to make sure keys are not pasted in too
** fast.
*/
int bios_buffer_size IPT0()
{
	word buffer_head, buffer_tail;

        buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
        buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

	note_trace2( BIOS_KB_VERBOSE, "BIOS kbd buffer head=%d tail=%d",
						buffer_head, buffer_tail );
	if( buffer_tail > buffer_head )
		return( buffer_tail - buffer_head );
	else
		return( buffer_head - buffer_tail );
}

LOCAL VOID K26A IFN0()
{
	/* Interrupt Return */
	outb(0x20, 0x20);
	outb(KEYBA_STATUS_CMD, ENA_KBD);
}

LOCAL VOID K26 IFN0()
{
	/* Reset last char H.C. flag */
	sas_store_no_check(kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3) & ~(LC_E0 + LC_E1)));

	/* (same as K26A()) */
	outb(0x20, 0x20);
	outb(KEYBA_STATUS_CMD, ENA_KBD);
}


#ifndef NTVDM

LOCAL VOID INT15 IFN0()
{
	word	saveCS, saveIP;

	saveCS = getCS();
	saveIP = getIP();

	setCS(int15_seg);
	setIP(int15_off);

	host_simulate();

	setCS(saveCS);
	setIP(saveIP);
}

#else	/* NTVDM */

void INT15(void);
word sp_int15_handler_seg = 0;
word sp_int15_handler_off = 0;

#endif	/* NTVDM */

#ifndef NTVDM
#define BEEP(message)           always_trace0(message);         \
				host_alarm(250000L);		\
				K26A()
#else   /* NTVDM */
/* NTVDM code size is too large, change this often used macro
 * to a function, as the call overhead is not justified
 */
void BEEP(char *message)
{
    note_trace0(BIOS_KB_VERBOSE,message);
    host_alarm(250000L);
    K26A();
}
#endif	/* NTVDM */



/*
** Tell ICA End of Interrupt has happened, the ICA will
** allow interupts to go off again.
** Call INT 15.
** Reenable the Keyboard serial line so Keyboard
** interrupts can go off.
** NOTE:
** this is different to the real BIOS. The real BIOS
** does ICA, Keyboard then INT 15, if we do that Keyboard
** interrupts occur too soon, during the INT 15 and blow the
** DOS stack. We effectively stop Keybd interrupts during the
** INT 15.
**
** <tur 17-Jun-93> Take a leaf outta NTVDM's book and make these
** functions rather than macros. (This reduced the size of keybd_io.c.o
** on the Mac from 38K to 12K!) After all, it isn't as if keyboards are
** highly speed sensitive!
*/
#ifndef NTVDM

LOCAL VOID PutInBufferFunc IFN2(half_word, s, half_word, v)
{
	word	buffer_head, buffer_tail, buffer_ptr;

	buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);
	buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
	buffer_ptr = inc_buffer_ptr(/* from: */buffer_tail);

	if (buffer_ptr == buffer_head) {
		BEEP("BIOS keyboard buffer overflow");
	}
	else {
		sas_store_no_check(BIOS_VAR_START + buffer_tail, v);
		sas_store_no_check(BIOS_VAR_START + buffer_tail+1, s);
		sas_storew_no_check(BIOS_KB_BUFFER_TAIL, buffer_ptr);

		outb(0x20, 0x20);
		setAX(0x9102);
		INT15();

		outb(KEYBA_STATUS_CMD, ENA_KBD);
		sas_store (kb_flag_3, sas_hw_at(kb_flag_3) & ~(LC_E0 + LC_E1));
		setIF(0);
	}

	exit_from_kbd_int();
}


#else   /* NTVDM */


/* <tur> NT's PutInBuffer seems to be slightly different to PutInBufferFunc above. */
/* So I'm Not Touching it! (Is this a good expansion of "NT"? :-) */

/* Our code size is too large, change this often used macro
 * to a function, as the call overhead is not justified
 */

void NtPutInBuffer(half_word s, half_word v)
{
        word    buffer_head, buffer_tail, buffer_ptr;

        buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);
        buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
        buffer_ptr = inc_buffer_ptr(/* from: */buffer_tail);

        if (buffer_ptr == buffer_head) {
                BEEP("BIOS keyboard buffer overflow");
        }
        else {
                sas_store_no_check(BIOS_VAR_START + buffer_tail, v);
                sas_store_no_check(BIOS_VAR_START + buffer_tail+1, s);
                sas_storew_no_check(BIOS_KB_BUFFER_TAIL, buffer_ptr);
                setAX(0x9102);
                INT15();
      K26();
      setIF(0);
        }

   exit_from_kbd_int();
}

#define PUT_IN_BUFFER(s, v) NtPutInBuffer(s,v); return
#endif	/* NTVDM */


/* <tur 17-Jun-93> Eurrgh; macros with embedded "return"s! */

#ifndef NTVDM
#define PUT_IN_BUFFER(s, v)		PutInBufferFunc(s,v); return
#endif	/* !NTVDM */

LOCAL VOID CheckAndPutInBufferFunc IFN2(half_word, s,half_word, v)
{
	if ((s == 0xff) || (v == 0xff)) {
		K26();
		exit_from_kbd_int();
	}
	else {
#ifndef NTVDM
		PutInBufferFunc(s, v);
#else /* NTVDM */
		NtPutInBuffer(s, v);
#endif /* !NTVDM */
	}
}

#define	CHECK_AND_PUT_IN_BUFFER(s,v)    CheckAndPutInBufferFunc(s, v); return


LOCAL VOID PAUSE IFN0()
{
	word   CS_save;        /* tmp. store for CS value      */
	word   IP_save;        /* tmp. store for IP value      */

	sas_store_no_check(kb_flag_1, (IU8)(sas_hw_at_no_check(kb_flag_1) | HOLD_STATE));

	outb(KEYBA_STATUS_CMD, ENA_KBD);
	outb(0x20, 0x20);

	CS_save = getCS();
	IP_save = getIP();

	FREEKBDHDW();

	do {
#if defined(IRET_HOOKS)  && defined(GISP_CPU)
		HostAllowKbdInt();	/* Allow a keypress to generate an interrupt */
#endif /* IRET_HOOKS && GISP_CPU */


#if defined(NTVDM)
                IDLE_waitio();
#endif

		setCS(rcpu_nop_segment);
		setIP(rcpu_nop_offset);
		host_simulate();

	} while (sas_hw_at_no_check(kb_flag_1) & HOLD_STATE);

	setCS(CS_save);
	setIP(IP_save);
	outb(KEYBA_STATUS_CMD, ENA_KBD);
}

#ifndef NTVDM
static int re_entry_level=0;
#endif

/*
** All exits from keyboard_int() call this first.
*/
LOCAL void exit_from_kbd_int IFN0()
{
#ifndef NTVDM
	--re_entry_level;
	if( re_entry_level >= 4 )
		always_trace1("ERROR: KBD INT bad exit level %d", re_entry_level);
#endif
	note_trace0( BIOS_KB_VERBOSE, "KBD BIOS - END" );
	setIF( 0 );
	FREEKBDHDW();	/* JonLe NTVDM Mod */
}

void keyboard_int IFN0()
{
	int	 		i;		/* loop counter			*/

	half_word		code,		/* scan code from keyboard	*/
				code_save,	/* tmp variable for above	*/
				chr,		/* ASCII char code		*/
				last_kb_flag_3,	/* kb_flag_3 saved		*/
				mask;
#ifdef	NTVDM
	word		IP_save,
                        buffer_head,    /* ptr. to head of kb buffer */
			buffer_tail;	/* ptr. to tail of kb buffer */
	half_word		BopFnCode;
#endif	/* NTVDM */



        boolean                 upper;          /* flag indicating upper case   */

#ifdef NTVDM
        BopFnCode = getAH();
        if (BopFnCode) {
            Keyb16Request(BopFnCode);
            return;
            }
#endif
#ifndef NTVDM
	++re_entry_level;
	if( re_entry_level > 4 ){
		always_trace1("ERROR: KBD BIOS re-entered at level %d\n", re_entry_level-1);
	}
#endif
	setIF(0);
        note_trace0(BIOS_KB_VERBOSE,"KBD BIOS start");

#ifdef NTVDM            /* JonLe keyboard mod */
        bBiosOwnsKbdHdw = !WaitKbdHdw(5000);
#endif  /* NTVDM */

	/* disable keyboard	*/
	outb(KEYBA_STATUS_CMD, DIS_KBD);

#ifdef NTVDM
          /*
           *  CarbonCopy traces int 9 in order to gain control
           *  over where the kbd data is coming from (the physical kbd
           *  or the serial link) The kbd_inb instruction must be visible
           *  in the 16 bit code via int 1 tracing, for CarbonCopy to work.
           *  interrupts should be kept off.
           */
        if (getTF()) {
            IP_save = getIP();
            setIP((IU16)(IP_save + 4));  /* adavance by 4 bytes, pop ax, jmp iret_com */
            host_simulate();
            setIP(IP_save);
            code = getAL();
            }
        else
#endif
            inb(KEYBA_IO_BUFFERS, &code);                           /* get scan_code        */

	/* call recursive CPU to handle int 15 call	*/
	setAH(0x4f);
	setAL(code);
        setCF(1);       /* Default return says scan code NOT consumed - needed by Freelance Plus 3.01 */
        INT15();
        code = getAL(); /* suret int 15 function can change the scan code in AL */


	if(!getCF())						/* check CF	*/
	{
		K26();
		exit_from_kbd_int();return;
	}

	if ( code == KB_RESEND )					/* check for resend	*/
	{
		sas_store_no_check (kb_flag_2, (IU8)(sas_hw_at_no_check(kb_flag_2) | KB_FE));
		K26();
		exit_from_kbd_int();return;
	}

	if( code == KB_ACK )						/* check for acknowledge	*/
	{
		sas_store_no_check (kb_flag_2, (IU8)(sas_hw_at_no_check(kb_flag_2) | KB_FA));
		K26();
		exit_from_kbd_int();return;
	}

	check_indicators(0);

	if ( code == KB_OVER_RUN )					/* test for overrun	*/
	{
		BEEP("hardware keyboard buffer overflow");
		exit_from_kbd_int();return;
	}
	last_kb_flag_3 = sas_hw_at_no_check(kb_flag_3);

	/* TEST TO SEE IF A READ_ID IS IN PROGRESS	*/
	if ( last_kb_flag_3 & (RD_ID + LC_AB) )
	{
		if ( sas_hw_at_no_check(kb_flag) & RD_ID )	/* is read_id flag on	*/
		{
			if( code == ID_1 )				/* is this the 1st ID char.	*/
				sas_store_no_check (kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3) | LC_AB));
			sas_store_no_check (kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3) & ~RD_ID));
		}
		else
		{
			sas_store_no_check (kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3) & ~LC_AB));
			if( code != ID_2A )				/* is this the 2nd ID char.	*/
			{
				if( code == ID_2 )
				{
					/* should we set NUM LOCK	*/
					if( last_kb_flag_3 & SET_NUM_LK )
					{
						sas_store_no_check (kb_flag, (IU8)(sas_hw_at_no_check(kb_flag) | NUM_STATE));
						check_indicators(1);
					}
				}
				else
				{
					K26();
					exit_from_kbd_int();return;
				}
			}
			sas_store_no_check (kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3) | KBX));	/* enhanced kbd found	*/
		}
		K26();
		exit_from_kbd_int();return;
	}

	if( code == MC_E0 )						/* general marker code?	*/
	{
		sas_store_no_check(kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3) | ( LC_E0 + KBX )));
		K26A();
		exit_from_kbd_int();return;
	}

	if( code == MC_E1 )						/* the pause key ?	*/
	{
		sas_store_no_check (kb_flag_3, (IU8)(sas_hw_at_no_check (kb_flag_3) | ( LC_E1 + KBX )));
		K26A();
		exit_from_kbd_int();return;
	}

	code_save = code;						/* turn off break bit	*/
	code &= 0x7f;

	if( last_kb_flag_3 & LC_E0)					/* last code=E0 marker?	*/
	{
		/* is it one of the shift keys	*/
		if( code == sas_hw_at_no_check(shift_keys+6) || code == sas_hw_at_no_check(shift_keys+7) )
		{
			K26();
			exit_from_kbd_int();return;
		}
	}
	else if( last_kb_flag_3 & LC_E1 )				/* last code=E1 marker?	*/
	{
		/* is it alt, ctl or one of the shift keys	*/
		if( code == sas_hw_at_no_check(shift_keys+4) || code == sas_hw_at_no_check(shift_keys+5) ||
		    code == sas_hw_at_no_check(shift_keys+6) || code == sas_hw_at_no_check(shift_keys+7) )
		{
			K26A();
			exit_from_kbd_int();return;
		}
		if( code == NUM_KEY )					/* is it the pause key	*/
		{
			/* is it the break or are we paused already	*/
			if( (code_save & 0x80) || (sas_hw_at_no_check(kb_flag_1) & HOLD_STATE) )
			{
				K26();
				exit_from_kbd_int();return;
			}
			PAUSE();
			exit_from_kbd_int();return;
		}
	}
	/* TEST FOR SYSTEM KEY	*/
	else if( code == SYS_KEY )
	{
		if( code_save & 0x80 )					/* check for break code	*/
		{
			sas_store_no_check(kb_flag_1, (IU8)(sas_hw_at_no_check(kb_flag_1) & ~SYS_SHIFT));
			K26A();
			/* call recursive CPU to call INT 15	*/
			setAX(0x8501);
			INT15();
			exit_from_kbd_int();return;
		}
		if( sas_hw_at_no_check(kb_flag_1) & SYS_SHIFT)	/* Sys key held down ?	*/
		{
			K26();
			exit_from_kbd_int();return;
		}
		sas_store_no_check (kb_flag_1, (IU8)(sas_hw_at_no_check(kb_flag_1) | SYS_SHIFT));
		K26A();
		/* call recursive CPU to call INT 15	*/
		setAX(0x8500);
		INT15();
		exit_from_kbd_int();return;
	}
	/* TEST FOR SHIFT KEYS	*/
	for( i=0; i < SHIFT_KEY_SIZE; i++)
		if ( code == sas_hw_at_no_check(shift_keys+i) )
			break;
	code = code_save;

	if( i < SHIFT_KEY_SIZE )					/* is there a match	*/
	{
		mask = sas_hw_at_no_check (shift_masks+i);
		if( code & 0x80 )					/* test for break key	*/
		{
			if (mask >= SCROLL_SHIFT)			/* is this a toggle key	*/
			{
				sas_store_no_check (kb_flag_1, (IU8)(sas_hw_at_no_check(kb_flag_1) & ~mask));
				K26();
				exit_from_kbd_int();return;
			}

			sas_store_no_check (kb_flag, (IU8)(sas_hw_at_no_check(kb_flag) & ~mask));	/* turn off shift bit	*/
			if( mask >= CTL_SHIFT)				/* alt or ctl ?		*/
			{
				if( sas_hw_at_no_check (kb_flag_3) & LC_E0 )			/* 2nd alt or ctl ?	*/
					sas_store_no_check (kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3) & ~mask));
				else
					sas_store_no_check (kb_flag_1, (IU8)(sas_hw_at_no_check(kb_flag_1) & ~(mask >> 2)));
				sas_store_no_check (kb_flag, (IU8)(sas_hw_at_no_check(kb_flag) | ((((sas_hw_at_no_check(kb_flag) >>2 ) | sas_hw_at(kb_flag_1)) << 2) & (ALT_SHIFT + CTL_SHIFT))));
			}
			if(code != (ALT_KEY + 0x80))			/* alt shift release ?	*/
			{
				K26();
				exit_from_kbd_int();return;
			}

			code = sas_hw_at_no_check(alt_input);
			if ( code == 0 )				/* input == 0 ?		*/
			{
				K26();
				exit_from_kbd_int();return;
                        }

			sas_store_no_check(alt_input, 0);		/* Zero the ALT_INPUT char */
			/* At this point, the ALT input char (now in "code") should be put in the buffer. */
                        PUT_IN_BUFFER(0, code);
#ifdef NTVDM
                        return;
#endif
		}
		/* SHIFT MAKE FOUND, DETERMINE SET OR TOGGLE	*/
		if( mask < SCROLL_SHIFT )
		{
			sas_store_no_check (kb_flag, (IU8)(sas_hw_at_no_check(kb_flag) | mask));
			if ( mask & (CTL_SHIFT + ALT_SHIFT) )
			{
				if( sas_hw_at_no_check(kb_flag_3) & LC_E0 )	/* one of the new keys ?*/
					sas_store_no_check(kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3) | mask));		/* set right, ctl alt	*/
				else
					sas_store_no_check (kb_flag_1, (IU8)(sas_hw_at_no_check(kb_flag_1) | (mask >> 2)));	/* set left, ctl alt	*/
			}
			K26();
			exit_from_kbd_int();return;
		}
		/* TOGGLED SHIFT KEY, TEST FOR 1ST MAKE OR NOT	*/
		if( (sas_hw_at_no_check(kb_flag) & CTL_SHIFT) == 0 )
		{
			if( code == INS_KEY )
			{
				if( sas_hw_at_no_check(kb_flag) & ALT_SHIFT )
					goto label1;

				if( (sas_hw_at_no_check(kb_flag_3) & LC_E0) == 0 )		/* the new insert key ?	*/
				{
					/* only continue if NUM_STATE flag set OR
					   one or both of the shift flags	*/
					if( ((sas_hw_at_no_check(kb_flag) &
						(NUM_STATE + LEFT_SHIFT + RIGHT_SHIFT))
						== NUM_STATE) ||
					    (((sas_hw_at_no_check(kb_flag) & NUM_STATE) == 0)
						&& (sas_hw_at_no_check(kb_flag) & (LEFT_SHIFT + RIGHT_SHIFT))) )
						goto label1;
				}
			}
			/* shift toggle key hit	*/
			if( mask & sas_hw_at_no_check(kb_flag_1) )	/* already depressed ?	*/
			{
				K26();
				exit_from_kbd_int();return;
			}
			sas_store_no_check (kb_flag_1, (IU8)(sas_hw_at_no_check(kb_flag_1) | mask));				/* set and toggle flags	*/
			sas_store_no_check ( kb_flag, (IU8)(sas_hw_at_no_check(kb_flag) ^ mask));
			if( mask & (CAPS_SHIFT + NUM_SHIFT + SCROLL_SHIFT) )
				check_indicators(1);

			if( code == INS_KEY )				/* 1st make of ins key	*/
				goto label2;

			K26();
			exit_from_kbd_int();return;
		}
	}
label1:	/* TEST FOR HOLD STATE */
	if( code & 0x80 )						/* test for break	*/
	{
		K26();
		exit_from_kbd_int();return;
	}
	if( sas_hw_at_no_check(kb_flag_1) & HOLD_STATE )		/* in hold state ?	*/
	{
		if( code != NUM_KEY )
			sas_store_no_check (kb_flag_1, (IU8)(sas_hw_at_no_check(kb_flag_1) & ~HOLD_STATE));
		K26();
		exit_from_kbd_int();return;
	}
label2:	/* NOT IN HOLD STATE	*/
	if( code > 88)							/* out of range ?	*/
	{
		K26();
		exit_from_kbd_int();return;
	}
	/* are we in alternate shift	*/
	if( (sas_hw_at_no_check(kb_flag) & ALT_SHIFT) && ( ((sas_hw_at_no_check(kb_flag_3) & KBX) == 0) ||
							((sas_hw_at_no_check(kb_flag_1) & SYS_SHIFT) == 0) ) )
	{
		/* TEST FOR RESET KEY SEQUENCE (CTL ALT DEL)	*/
		if( (sas_hw_at_no_check(kb_flag) & CTL_SHIFT ) && (code == DEL_KEY) )
                {
#ifndef NTVDM
                        reboot();
#else
                        K26();
#endif
			exit_from_kbd_int();return;
		}
		/* IN ALTERNATE SHIFT, RESET NOT FOUND	*/
		if( code == SPACEBAR )
		{
                        PUT_IN_BUFFER(code, ' ');
		}
		if( code == TAB_KEY )
		{
                        PUT_IN_BUFFER(0xa5, 0 );                /* special code for alt-tab     */
		}
		if( (code == KEY_PAD_MINUS) || (code == KEY_PAD_PLUS) )
		{
                        PUT_IN_BUFFER(code, 0xf0);              /* special ascii code           */
                }
		/* LOOK FOR KEYPAD ENTRY	*/
		for (i = 0; i < 10; i++ )
			if ( code == sas_hw_at_no_check (alt_table+i) )
				break;
		if( i < 10 )
		{
			if( sas_hw_at_no_check(kb_flag_3) & LC_E0 )	/* one of the new keys ?	*/
			{
                                PUT_IN_BUFFER((IU8)(code + 80), 0 );
                        }
			sas_store_no_check (alt_input, (IU8)(sas_hw_at_no_check(alt_input) * 10 + i));
			K26();
			exit_from_kbd_int();return;
		}
		/* LOOK FOR SUPERSHIFT ENTRY	*/
		for( i = 10; i < ALT_TABLE_SIZE; i++)
			if( code == sas_hw_at_no_check (alt_table+i))
				break;
		if( i < ALT_TABLE_SIZE )
		{
                        PUT_IN_BUFFER(code, 0 );
                }
                /* LOOK FOR TOP ROW OF ALTERNATE SHIFT  */
		if( code < TOP_1_KEY )
		{
                        CHECK_AND_PUT_IN_BUFFER(code, 0xf0);    /* must be escape       */
                }
		if( code < BS_KEY )
		{
                        PUT_IN_BUFFER((IU8)(code + 118), 0);
                }
		/* TRANSLATE ALTERNATE SHIFT PSEUDO SCAN CODES	*/
		if((code == F11_M) || (code == F12_M) )		/* F11 or F12		*/
		{
                        PUT_IN_BUFFER((IU8)(code + 52), 0 );
                }
		if( sas_hw_at_no_check(kb_flag_3) & LC_E0 )	/* one of the new keys ?*/
		{
			if( code == KEY_PAD_ENTER )
			{
                                PUT_IN_BUFFER(0xa6, 0);
                        }
			if( code == DEL_KEY )
			{
				PUT_IN_BUFFER((IU8)( code + 80), 0 );
                        }
			if( code == KEY_PAD_SLASH )
			{
				PUT_IN_BUFFER(0xa4, 0);
                        }
			K26();
			exit_from_kbd_int();return;
		}
		if( code < F1_KEY )
		{
			CHECK_AND_PUT_IN_BUFFER(code, 0xf0);
                }
		if( code <= F10_KEY )
		{
			PUT_IN_BUFFER( (IU8)(code + 45), 0 );
                }
		K26();
		exit_from_kbd_int();return;
	}
	/* NOT IN ALTERNATE SHIFT	*/
	if(sas_hw_at_no_check(kb_flag) & CTL_SHIFT)			/* control shift ?	*/
	{
		if( (code == SCROLL_KEY) && ( ((sas_hw_at_no_check(kb_flag_3) & KBX) == 0) || (sas_hw_at_no_check(kb_flag_3) & LC_E0) ) )
		{
			/* reset buffer to empty	*/
			sas_storew_no_check(BIOS_KB_BUFFER_TAIL, sas_w_at_no_check(BIOS_KB_BUFFER_HEAD));

			sas_store (bios_break, 0x80);			/* turn on bios brk bit	*/
			outb(KEYBA_STATUS_CMD, ENA_KBD);	/* enable keyboard	*/

			FREEKBDHDW();	/* JonLe NTVDM mod */

			exec_sw_interrupt(int1b_seg, int1b_off);

			PUT_IN_BUFFER(0, 0);
                }
		/* TEST FOR PAUSE	*/
                if( ((sas_hw_at_no_check(kb_flag_3) & KBX) == 0) && (code == NUM_KEY))
		{
			PAUSE();
			exit_from_kbd_int();return;
		}
		/* TEST SPECIAL CASE KEY 55	*/
		if( code == PRINT_SCR_KEY )
		{
			if ( ((sas_hw_at_no_check(kb_flag_3) & KBX) == 0) || (sas_hw_at_no_check(kb_flag_3) &LC_E0) )
			{
				PUT_IN_BUFFER(0x72, 0);
                        }
		}
		else
		{
			if( code != TAB_KEY )
			{
				if( (code == KEY_PAD_SLASH) && (sas_hw_at_no_check(kb_flag_3) & LC_E0) )
				{
					PUT_IN_BUFFER(0x95, 0 );
                                }
				if( code < F1_KEY )		/* is it in char table?	*/
				{
					if( sas_hw_at_no_check(kb_flag_3) & LC_E0)
					{
						CHECK_AND_PUT_IN_BUFFER(MC_E0, sas_hw_at_no_check(ctl_n_table+code - 1) );
                                        }
					else
					{
						CHECK_AND_PUT_IN_BUFFER(code, sas_hw_at_no_check(ctl_n_table+code - 1) );
                                        }
				}
			}
		}
		chr = ( sas_hw_at_no_check(kb_flag_3) & LC_E0 ) ? MC_E0 : 0;
		CHECK_AND_PUT_IN_BUFFER(sas_hw_at_no_check(ctl_n_table+code - 1), chr);
        }
	/* NOT IN CONTROL SHIFT	*/

	if( code <= CAPS_KEY )
	{
		if( code == PRINT_SCR_KEY )
		{
			if( ((sas_hw_at_no_check(kb_flag_3) & (KBX + LC_E0)) == (KBX + LC_E0)) ||
			( ((sas_hw_at_no_check(kb_flag_3) & KBX) == 0) && (sas_hw_at_no_check(kb_flag) & (LEFT_SHIFT + RIGHT_SHIFT))) )
			{
				/* print screen	*/
				outb(KEYBA_STATUS_CMD, ENA_KBD);
				outb(0x20, 0x20);

				FREEKBDHDW();	/* JonLe NTVDM Mod */

				exec_sw_interrupt(int05_seg, int05_off);

				sas_store_no_check (kb_flag_3, (IU8)(sas_hw_at_no_check(kb_flag_3)& ~(LC_E0 + LC_E1)));
				exit_from_kbd_int();return;
			}
		}
		else
		{
			if( ((sas_hw_at_no_check(kb_flag_3) & LC_E0) == 0) || (code != KEY_PAD_SLASH))
			{
				for( i = 10; i < ALT_TABLE_SIZE; i++ )
					if(code == sas_hw_at_no_check(alt_table+i))
						break;
				/* did we find one	*/
				upper = FALSE;
				if( (i < ALT_TABLE_SIZE) && (sas_hw_at_no_check(kb_flag) & CAPS_STATE) )
				{
					if( (sas_hw_at_no_check(kb_flag) & (LEFT_SHIFT + RIGHT_SHIFT)) == 0 )
						upper = TRUE;
				}
				else
				{
					if( sas_hw_at_no_check(kb_flag) & (LEFT_SHIFT + RIGHT_SHIFT) )
						upper = TRUE;
				}

				if (upper)
				{
					/* translate to upper case	*/
					if( sas_hw_at_no_check(kb_flag_3) & LC_E0)
					{
						CHECK_AND_PUT_IN_BUFFER(MC_E0, sas_hw_at_no_check(uppercase+code - 1) );
                                        }
					else
					{
						CHECK_AND_PUT_IN_BUFFER(code, sas_hw_at_no_check (uppercase+code - 1) );
                                        }
				}
			}
		}
		/* translate to lower case	*/
		if( sas_hw_at_no_check(kb_flag_3) & LC_E0)
		{
			CHECK_AND_PUT_IN_BUFFER(MC_E0, sas_hw_at_no_check (lowercase+code - 1) );
                }
		else
		{
			CHECK_AND_PUT_IN_BUFFER(code, sas_hw_at_no_check(lowercase+code - 1) );
                }
	}
	/* TEST FOR KEYS F1 - F10	*/
	/* 7.10.92 MG AND TEST FOR F11 AND F12 !!!!
	   We were shoving the code for shift-F11 or shift-F12 in if
	   you pressed unshifted keys. This has been changed so that all the
	   function keys are handled the same way, which is the correct
	   procedure.
	*/

	if( code > F10_KEY && (code != F11_KEY && code != F12_KEY) )
	{
		if( code > DEL_KEY )
		{
			if (code == WT_KEY )
			{
				if ( sas_hw_at_no_check(kb_flag) & (LEFT_SHIFT + RIGHT_SHIFT) )
				{
					/* translate to upper case	*/
					if( sas_hw_at_no_check(kb_flag_3) & LC_E0)
					{
						CHECK_AND_PUT_IN_BUFFER(MC_E0, sas_hw_at_no_check(uppercase+code - 1) );
                                        }
					else
					{
						CHECK_AND_PUT_IN_BUFFER(code, sas_hw_at_no_check(uppercase+code - 1) );
                                         }
				}
				else
				{
					/* translate to lower case	*/
					if( sas_hw_at_no_check(kb_flag_3) & LC_E0)
					{
						CHECK_AND_PUT_IN_BUFFER(MC_E0, sas_hw_at_no_check(lowercase+code - 1) );
                                        }
					else
					{
						CHECK_AND_PUT_IN_BUFFER(code, sas_hw_at_no_check(lowercase+code - 1) );
                                        }
				}
			}
			else
			{
				if( (code == 76) &&  ((sas_hw_at_no_check(kb_flag) & (LEFT_SHIFT + RIGHT_SHIFT)) == 0))
				{
					PUT_IN_BUFFER( code, 0xf0);
                                }
				/* translate for pseudo scan codes	*/
				chr = ( sas_hw_at_no_check(kb_flag_3) & LC_E0 ) ? MC_E0 : 0;

				/* Should this always be upper case ???? */

				CHECK_AND_PUT_IN_BUFFER(sas_hw_at_no_check (uppercase+code - 1), chr);
                        }
		}
		if (
			 (code == KEY_PAD_MINUS) ||
			 (code == KEY_PAD_PLUS) ||
			 ( !(sas_hw_at_no_check(kb_flag_3) & LC_E0) &&
				 (
		 			((sas_hw_at_no_check(kb_flag) & (NUM_STATE + LEFT_SHIFT + RIGHT_SHIFT)) == NUM_STATE) ||
					(((sas_hw_at_no_check(kb_flag) & NUM_STATE) == 0) && (sas_hw_at_no_check(kb_flag) & (LEFT_SHIFT + RIGHT_SHIFT)))
				 )
			 )
		   )
		{
			/* translate to upper case	*/
			if( sas_hw_at_no_check(kb_flag_3) & LC_E0)
			{
				CHECK_AND_PUT_IN_BUFFER(MC_E0, sas_hw_at_no_check(uppercase+code - 1) );
                        }
			else
			{
				CHECK_AND_PUT_IN_BUFFER(code, sas_hw_at_no_check(uppercase+code - 1) );
                        }
		}
	}
	else
	{
		if( sas_hw_at_no_check(kb_flag) & (LEFT_SHIFT + RIGHT_SHIFT) )
		{
			/* translate for pseudo scan codes	*/
			chr = ( sas_hw_at_no_check(kb_flag_3) & LC_E0 ) ? MC_E0 : 0;
			CHECK_AND_PUT_IN_BUFFER(sas_hw_at_no_check(uppercase+code - 1), chr);
                }
	}
	if ( code == 76 )
	{
		PUT_IN_BUFFER(code, 0xf0 );
        }
	/* translate for pseudo scan codes	*/
	chr = ( sas_hw_at_no_check(kb_flag_3) & LC_E0 ) ? MC_E0 : 0;
	CHECK_AND_PUT_IN_BUFFER(sas_hw_at_no_check(lowercase+code - 1), chr);

} /* end of keyboard_int() AT version */


void kb_idle_poll()
{
	/*
	 * this routine is called from bios assembler routines to
	 * cause an idle poll to occur.
	 */
	IDLE_poll();
}


#ifdef NTVDM
   /*
    *  Ntvdm has a 16-bit int 16 handler
    *  it requires a few services for idle
    *  detection from softpc...
    *
    */
void keyboard_io()
{
#ifdef JAPAN
   /* make sure we are called by OUR int16 handler in ntio.sys because we
    *  have changed the int 16 function semantics. The Japanese very
    *  popular word processor(Ichitaro) does a far call to 0xf000:e82e,
    *  the standard ROM bios int16 handler address which bypasses the
    *  entire int16 hanlder chain. On X86, it goes to ROM bios. On RISC,
    *  the softpc ROM bios bops to here. A function 3(set typematic) would
    *  cause us to flood tons of toggle keys to the application which could
    *  get choked.
    *  So the cure is to do a simulating to our	16bit handler in
    *  the NTIO.SYS.
    */

#ifndef NEC_98
   if (int16h_caller_seg == 0 || getCS() == int16h_caller_seg) {
#endif    //NEC_98
#endif // JAPAN
   switch (getAH()) {
           /*
            * The 16 bit thread has not reached idle status yet
            * but it is polling the kbd, so do some brief waits.
            */
     case 0:
       WaitIfIdle();
#ifndef NTVDM
       if (!WaitKbdHdw(0)) {
           TryKbdInt();
           HostReleaseKbd();
	   }
#endif /* NTVDM */
       break;

           /*
            *  App wants to idle, so consult idle algorithm
            */
     case 1:
       IDLE_poll();
       break;

            /*
             * App is starting a waitio
             */
     case 2:
       IDLE_waitio();
       break;

            /*
             *  update the keyboard lights,
             */
     case 3:
       host_kb_light_on (getAL());
       break;
     }
#if defined(JAPAN)  && !defined(NEC_98)
   }
   else {

	word	SaveCS;
	word	SaveIP;

	SaveIP = getIP();
	SaveCS = getCS();
	setCS(int16h_caller_seg);
	setIP(int16h_caller_off);
	host_simulate();
	setCS(SaveCS);
	setIP(SaveIP);
   }
#endif // JAPAN && !NEC_98
}

#else
void keyboard_io()
{
    /*
     * Request to keyboard.  The AH register holds the type of request:
     *
     * AH == 0          Read an character from the queue - wait if no
     *                  character available.  Return character in AL
     *                  and the scan code in AH.
     *
     * AH == 1          Determine if there is a character in the queue.
     *                  Set ZF = 0 if there is a character and return
     *                  it in AX (but leave it in the queue).
     *
     * AH == 2          Return shift state in AL.
     *
     * For AH = 0 to 2, the value returned in AH is zero. This correction
     * made in r2.69.
     *
     * NB : The order of reference/increment of buffer_head is critical to
     *      ensure we do not upset put_in_buffer().
     *
     *
     * XT-SFD BIOS Extended functions:
     *
     * AH == 5          Place ASCII char/scan code pair (CL / CH)
     *                  into tail of keyboard buffer. Return 0 in
     *                  AL if successful, 1 if buffer already full.
     *
     * AH == 0x10       Extended read for enhanced keyboard.
     *
     * AH == 0x11       Extended function 1 for enhanced keyboard.
     *
     * AH == 0x12       Extended shift status. AL contains kb_flag,
     *                  AH has bits for left/right Alt and Ctrl keys
     *                  from kb_flag_1 and kb_flag_3.
     */
    word 	buffer_head,	/* local copy of BIOS data area variable*/
    		buffer_tail,	/* local copy of BIOS data area variable*/
		buffer_ptr;	/* pointer into BIOS keyboard buffer    */

#define INT16H_DEC  0x12    /* AH decremented by this if invalid command */

    word 	CS_save,	/* CS before recursive CPU call		*/
    		IP_save;	/* IP before recursive CPU call		*/
    half_word	data,		/* byte conyaining typamatic data	*/
		status1,	/* temp variables used for storing	*/
		status2;	/* status in funtion 0x12		*/

    INT		func_index;     /* func_index == AH */


    setZF(0);
    func_index = (INT)getAH();

    note_trace1( BIOS_KB_VERBOSE, "Keyboard BIOS func 0x%x", func_index);


    switch (func_index) {

    case  0x00:			/* Read next char in Kbd buffer */

	/*
	 * The AT emulation of the BIOS uses a recursive CPU to handle
	 * the HW interrrupts, so there is no need to set the Zero Flag
	 * and return to our CPU (see original xt version )
	 */
        buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
        buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

	if (buffer_tail == buffer_head)
	{
		IDLE_waitio();

		setAX(0x9002);
		INT15();	/* call int 15h  - wait function	*/
	}

	do
	{
		check_indicators(0);	/* see if LED's need updating	*/

		buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
		buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

		if (buffer_tail == buffer_head)
		{
			CS_save = getCS();
			IP_save = getIP();

			/* wait for character in buffer		*/

        		do {
				IDLE_poll();

	       			setCS(rcpu_poll_segment);
	       			setIP(rcpu_poll_offset);
                                host_simulate();
				buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
				buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

		       	} while (buffer_tail == buffer_head);


		       	setCS(CS_save);
		       	setIP(IP_save);
		}

	       	setAX(sas_w_at_no_check(BIOS_VAR_START + buffer_head));

        	buffer_head = inc_buffer_ptr(/* from: */buffer_head);
	        sas_storew_no_check(BIOS_KB_BUFFER_HEAD, buffer_head);

		translate_std();	/*translate scan_code pairs			*/
	}
	while (getCF());		/* if CF set throw code away and start again	*/

	setIF(1);

	IDLE_init();

	break;


    case 0x01:				/* Set ZF to reflect char availability in Kbd buffer */

	do
	{
		check_indicators(1);		/* see if LED's need updating		*/
						/* and issue an   out 20h,20h		*/

		buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
		buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

	       	setAX(sas_w_at_no_check(BIOS_VAR_START + buffer_head));

		if (buffer_tail == buffer_head)
		{
			/* buffer empty - set flag and return */
			IDLE_poll();

			setZF(1);
			break;
		}
		else
			IDLE_init();

		translate_std();	/* translate scan_code pairs, returns CF if throwaway */
		if(getCF())
		{
			/* throw code away by incrementing pointer	*/
	        	buffer_head = inc_buffer_ptr(/* from: */buffer_head);
		        sas_storew_no_check(BIOS_KB_BUFFER_HEAD, buffer_head);
		}
	}
	while (getCF());		/* if CF set -  start again	*/
	setIF(1);

	break;


    case 0x02:				/* AL := Current Shift Status (really "kb_flag") */

        setAH(0);
        setAL(sas_hw_at_no_check(kb_flag));

	break;


    case 0x03:				/* Alter typematic rate */

    	/* check for correct values in registers		*/
    	if( (getAL() == 5) && !(getBX() & 0xfce0) )
    	{
		note_trace1(BIOS_KB_VERBOSE, "\talter typematic rate (BX %#x)\n", getBX());

    		send_data(KB_TYPA_RD);
    		data = (getBH() << 5) | getBL();
    		send_data(data);
    	}

	break;


    case 0x05:				/* Place ASCII + ScanCode in Kbd Buffer */

	buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
	buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

        /*
         * check for sufficient space - if no set AL
         */

        buffer_ptr = inc_buffer_ptr(/*from:*/buffer_tail);

        if( buffer_head == buffer_ptr )
             setAL( 1 );
        else {
            /*
    	     * load CX into buffer and update buffer_tail
    	     */
    	    sas_storew_no_check(BIOS_VAR_START + buffer_tail, getCX() );
    	    sas_storew_no_check(BIOS_KB_BUFFER_TAIL, buffer_ptr);
            setAL( 0 );
        }
        setAH( 0 );
	setIF(1);

	break;


    case 0x10:				/* Extended ASCII Read */

	buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
	buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

	if (buffer_tail == buffer_head)
	{
		IDLE_waitio();

		setAX(0x9002);
		INT15();	/* call int 15h  - wait function */
	}
	check_indicators(0);	/* see if LED's need updating */

	buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
	buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

	if (buffer_tail == buffer_head)
	{
		CS_save = getCS();
		IP_save = getIP();

		/* wait for character in buffer		*/
        	while (buffer_tail == buffer_head)
       		{
			IDLE_poll();

       			setCS(rcpu_poll_segment);
       			setIP(rcpu_poll_offset);
                        host_simulate();
			buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
			buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);
	       	}

		IDLE_init();

	       	setCS(CS_save);
	       	setIP(IP_save);
	}

	setAX(sas_w_at_no_check(BIOS_VAR_START + buffer_head));	/* Pickup the "current" scancode/char pair */

       	buffer_head = inc_buffer_ptr(/* from: */buffer_head);
        sas_storew_no_check(BIOS_KB_BUFFER_HEAD, buffer_head);

	translate_ext();		/* translate scan_code pairs	*/

	setIF(1);
	break;


    case 0x11:				/* Extended ASCII Status	*/

	check_indicators(1);		/* see if LED's need updating	*/
					/* and issue an   out 20h,20h	*/

	buffer_head = sas_w_at_no_check(BIOS_KB_BUFFER_HEAD);
	buffer_tail = sas_w_at_no_check(BIOS_KB_BUFFER_TAIL);

	setAX(sas_w_at_no_check(BIOS_VAR_START + buffer_head));

	if (buffer_tail == buffer_head)	/* No keys pressed */
	{
		setZF(1);
		IDLE_poll();
	}
	else 				/* Keystrokes available! */
	{
		translate_ext();	/* translate scan_code pairs	*/
		IDLE_init();
	}

	setIF(1);
	break;


    case 0x12:				/* Extended Shift Status */

        status1 = sas_hw_at_no_check(kb_flag_1) & SYS_SHIFT;	/* only leave SYS KEY	*/
        status1 <<= 5;						/* move to bit 7	*/
        status2 = sas_hw_at_no_check(kb_flag_1) & 0x73;		/* remove SYS_SHIFT, HOLD,
    			 					   STATE and INS_SHIFT  */
        status1 |= status2;					/* merge		*/
        status2 = sas_hw_at_no_check(kb_flag_3) & 0x0C;		/* remove LC_E0 & LC_E1 */
        status1 |= status2;					/* merge		*/
        setAH( status1 );
        setAL( sas_hw_at_no_check(kb_flag) );

	break;


    default:
        setAH((func_index - INT16H_DEC));
	break;
    }
}
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

void keyboard_post()
{

     /* Set up BIOS keyboard variables */

#if defined(NEC_98)
    word CS_save, IP_save;
    half_word i;
    half_word data;

    if(HIRESO_MODE){  //Hireso mode system aria Initialize

        sas_storew(BIOS_NEC98_KB_BUFFER_ADR, BIOS_NEC98_KB_KEY_BUFFER);
        sas_storew(BIOS_NEC98_KB_BUFFER_ADR+2, 0);
        sas_storew(BIOS_NEC98_KB_HEAD_POINTER, BIOS_NEC98_KB_KEY_BUFFER);
        sas_storew(BIOS_NEC98_KB_TAIL_POINTER, BIOS_NEC98_KB_KEY_BUFFER);

        sas_storew(BIOS_NEC98_KB_INT_ADR, 0x0481);
        sas_storew(BIOS_NEC98_KB_INT_ADR+2, 0xf800);

        sas_store(BIOS_NEC98_KB_RETRY_COUNTER, 0);
        sas_store(BIOS_NEC98_KB_BUFFER_COUNTER, 0);
        sas_store(BIOS_NEC98_KB_SHIFT_STS, 0);

        sas_storew(BIOS_NEC98_KB_BUFFER_SIZ, 0x0010);
        sas_storew(BIOS_NEC98_KB_ENTRY_TBL_ADR, 0x0484);
        sas_storew(BIOS_NEC98_KB_ENTRY_TBL_ADR+2, 0xf800);

        for (i=0; i<16 ; i++){
            sas_store(BIOS_NEC98_KB_KEY_STS_TBL+i,0);
        }
        sas_store(BIOS_NEC98_KB_SHIFT_COD, 0xff);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+1, 0xff);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+2, 0xff);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+3, 0x74);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+4, 0x73);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+5, 0x72);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+6, 0x71);
        sas_store(BIOS_NEC98_KB_SHIFT_COD+7, 0x70);

        kbd_outb(KEYBD_STATUS_CMD, 0x3a);       //SEND NON_RETRY_COMMAND TO 8251A
        kbd_outb(KEYBD_STATUS_CMD, 0x32);       //SEND NON_RETRY_COMMAND TO 8251A
        kbd_outb(KEYBD_STATUS_CMD, 0x16);       //SEND NON_RETRY_COMMAND TO 8251A

    }else{  //Normal mode system aria Initialize


        kbd_outb(KEYBD_STATUS_CMD, 0x3a);       //SEND NON_RETRY_COMMAND TO 8251A
        kbd_outb(KEYBD_STATUS_CMD, 0x32);       //SEND NON_RETRY_COMMAND TO 8251A
        kbd_outb(KEYBD_STATUS_CMD, 0x16);       //SEND NON_RETRY_COMMAND TO 8251A

        sas_storew(BIOS_NEC98_KB_SHFT_TBL, 0x0b3d);     ///Set offset KB_TRTBL
        sas_storew(BIOS_NEC98_KB_BUF_HEAD, BIOS_NEC98_KB_BUF);
        sas_storew(BIOS_NEC98_KB_BUF_TAIL, BIOS_NEC98_KB_BUF);
        for (i=0; i<19 ; i++){
            sas_store(BIOS_NEC98_KB_COUNT+i,0);  //BIOS_NEC98_KB_COUNT,BIOS_NEC98_KB_RETRY
                                             //BIOS_NEC98_KB_KY_STS
        }                                    //BIOS_NEC98_KB_SHFT_STS

        sas_storew(BIOS_NEC98_KB_CODE, 0x0b3d);        ///Set Offset KB_TRTBL
        sas_storew(BIOS_NEC98_KB_CODE+2, 0xfd80);      ///Set Segment KB_TRTBL

    }

#else    //NEC_98

/* Initialize the keyboard table pointers */
	shift_keys = K6;
	shift_masks = K7;
	ctl_n_table = K8;
	ctl_f_table = K9;
	lowercase = K10;
	uppercase = K11;
	alt_table = K30;

    sas_storew_no_check(BIOS_KB_BUFFER_HEAD, BIOS_KB_BUFFER);
    sas_storew_no_check(BIOS_KB_BUFFER_TAIL, BIOS_KB_BUFFER);
    sas_storew_no_check(BIOS_KB_BUFFER_START, BIOS_KB_BUFFER);
    sas_storew_no_check(BIOS_KB_BUFFER_END, BIOS_KB_BUFFER + 2*BIOS_KB_BUFFER_SIZE);

     /* The following are #defines, referring to locations in BIOS */
     /* data area.                                                 */

	sas_store_no_check (kb_flag,NUM_STATE);
	sas_store_no_check (kb_flag_1,0);
	sas_store_no_check (kb_flag_2,2);
	sas_store_no_check (kb_flag_3,KBX);
	sas_store_no_check (alt_input,0);
#endif    //NEC_98
}

void keyboard_init()
{
        /*
	** host specific keyboard initialisation
	** is now before AT base keyboard initialisation
	*/
        host_kb_init();

#if defined(CPU_40_STYLE) && !defined (NTVDM)
	ica_iret_hook_control(ICA_MASTER, CPU_KB_INT, TRUE);
#endif
}



#ifdef NTVDM

/*:::::::::::::::::::::::::::::::::::::::::::::::: Map in new keyboard tables */
/*::::::::::::::::::::::::::::::::::::::::::::::::::::: Set interrupt vectors */
/*
** The Microsoft NTIO.SYS calls this func via BOP 5F to pass
** interesting addresses to our C BIOS.
*/

#if defined(MONITOR)

IMPORT UTINY getNtScreenState IPT0();
#endif


void kb_setup_vectors(void)
{
   word        KbdSeg, w;
   word       *pkio_table;
   double_word phy_base;


   KbdSeg     = getDS();
   pkio_table = (word *) effective_addr(getCS(), getSI());

      /* IDLE variables */
    sas_loadw((sys_addr)(pkio_table + 12), &w);
    pICounter		  = (word *) (Start_of_M_area + ((KbdSeg<<4)+w));
    pCharPollsPerTick	  = (word *) (Start_of_M_area + ((KbdSeg<<4)+w+4));
    pMinConsecutiveTicks = (word *)  (Start_of_M_area + ((KbdSeg<<4)+w+8));

#if defined(MONITOR)
   phy_base   = (double_word)KbdSeg << 4;

     /* key tables */
   shift_keys  =  phy_base + *pkio_table++;
   shift_masks =  phy_base + *pkio_table++;
   ctl_n_table =  phy_base + *pkio_table++;
   ctl_f_table =  phy_base + *pkio_table++;
   lowercase   =  phy_base + *pkio_table++;
   uppercase   =  phy_base + *pkio_table++;
   alt_table   =  phy_base + *pkio_table++;

   dummy_int_seg        = KbdSeg;         /* dummy int, iret routine */
   dummy_int_off        = *pkio_table++;
   int05_seg            = KbdSeg;         /* print screen caller */
   int05_off            = *pkio_table++;
   int15_seg            = KbdSeg;         /* int 15 caller */
   int15_off            = *pkio_table++;
   rcpu_nop_segment     = KbdSeg;         /* cpu nop */
   rcpu_nop_offset      = *pkio_table++;
   sp_int15_handler_seg = KbdSeg;         /* int 15 handler */
   sp_int15_handler_off = *pkio_table++;
   pkio_table++;                          /* iDle variables, done above */
   rcpu_int4A_seg       = KbdSeg;
   rcpu_int4A_off       = *pkio_table++;   /* real time clock */

   int1b_seg    = KbdSeg;         /* kbd break handler */
   int1b_off    = *pkio_table++;
   int10_seg    = KbdSeg;
   int10_caller = *pkio_table++;
   int10_vector = *pkio_table++;

   /*
   ** Address of data in keyboard.sys, Tim August 92.
   **
   ** useHostInt10 is a one byte variable. 1 means use host video BIOS,
   ** (ie. full-screen), 0 means use SoftPC video BIOS (ie. windowed).
   ** babyModeTable is a mini version of the table in ROM that contains
   ** all the VGA register values for all the modes. The keyboard.sys
   ** version only has two entries; for 40 column text mode and 80
   ** column text mode.
   */
   useHostInt10  = *pkio_table++;
   sas_store_no_check((sys_addr)(phy_base + useHostInt10), getNtScreenState());
   babyModeTable = (int10_seg << 4) + *pkio_table++;
   changing_mode_flag = *pkio_table++;	/* indicates trying to change vid mode*/

    /* Initialise printer status table. */
   printer_setup_table(effective_addr(KbdSeg, *pkio_table++));
   wait_int_off = *pkio_table++;
   wait_int_seg = KbdSeg;
   dr_type_seg = KbdSeg;
   dr_type_off = *pkio_table++;
   dr_type_addr = (sys_addr)dr_type_seg * 16L + (sys_addr)dr_type_off;
   vga1b_seg = KbdSeg;
   vga1b_off = *pkio_table++; /* VGA capability table (normally lives in ROM) */
   conf_15_seg = KbdSeg;
   conf_15_off = *pkio_table++; /* INT15 config table (normally in ROM) */

   TimerInt08Seg = KbdSeg;
   TimerInt08Off = *pkio_table++;
   int13h_vector_seg = KbdSeg;
   int13h_caller_seg = KbdSeg;

#if defined(JAPAN) && !defined(NEC_98)
   int16h_caller_seg = KbdSeg;
#endif // JAPAN & !NEC_98

   int13h_vector_off = *pkio_table++;
   int13h_caller_off = *pkio_table++;
// STREAM_IO codes are disabled on NEC_98.
#ifndef NEC_98
   stream_io_buffer_size = *pkio_table++;
   stream_io_buffer = (half_word *)effective_addr(*pkio_table++, 0);
   stream_io_dirty_count_ptr = (word *)effective_addr(KbdSeg, *pkio_table++);
   stream_io_bios_busy_sysaddr = effective_addr(KbdSeg, *pkio_table++);
#ifdef JAPAN
   int16h_caller_off = *pkio_table++;
#endif // JAPAN
#endif    //NEC_98
#ifndef PROD
   if (*pkio_table != getAX()) {
       always_trace0("ERROR: KbdVectorTable!");
       }
#endif
   TimerInt1CSeg = KbdSeg;
   TimerInt1COff = dummy_int_off;

#else    /* ndef MONITOR */

     /* kbd bios callout optimization */
    sas_loadw(0x15*4,     &sp_int15_handler_off);
    sas_loadw(0x15*4 + 2, &sp_int15_handler_seg);

     /* timer hardware interrupt optimizations */
    sas_loadw(0x08*4,     &TimerInt08Off);
    sas_loadw(0x08*4 + 2, &TimerInt08Seg);
    sas_loadw(0x1C*4,     &TimerInt1COff);
    sas_loadw(0x1C*4 + 2, &TimerInt1CSeg);

    sas_loadw(0x13 * 4, &int13h_vector_off);
    sas_loadw(0x13 * 4 + 2, &int13h_vector_seg);
    int13h_caller_seg = KbdSeg;
    dr_type_seg = KbdSeg;
    sas_loadw((sys_addr)(pkio_table + 27), &int13h_caller_off);
    sas_loadw((sys_addr)(pkio_table + 22), &dr_type_off);
    dr_type_addr = effective_addr(dr_type_seg, dr_type_off);
#if defined(JAPAN) && defined(NTVDM) && !defined(NEC_98)
    int16h_caller_seg = KbdSeg;
    sas_loadw((sys_addr)(pkio_table + 32), &int16h_caller_off);
#endif // JAPAN & NTVDM & !NEC_98

#endif /* MONITOR */

    sas_loadw(0x09*4,     &KbdInt09Off);
    sas_loadw(0x09*4 + 2, &KbdInt09Seg);

    ResumeTimerThread();
}


/*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: Int15 caller */


/*
 *  Gives chance for other parts of NTVDM to
 *  update the kbd i15 kbd callout optimization
 */
void UpdateKbdInt15(word Seg,word Off)
{
    word int15Off, int15Seg;

    /* make sure nobody has hooked since the last time */
    /* we stored the i15 vector */
    sas_loadw(0x15*4 ,    &int15Off);
    sas_loadw(0x15*4 + 2, &int15Seg);
    if(int15Off != sp_int15_handler_off || int15Seg != sp_int15_handler_seg)
      {
#ifndef PROD
       printf("NTVDM: UpdateKbdInt15 Nuking I15 offsets\n");
#endif
       sp_int15_handler_off = sp_int15_handler_seg = 0;
       return;
       }

    sp_int15_handler_off = Off;
    sp_int15_handler_seg = Seg;
}



IMPORT void (*BIOS[])();

void INT15(void)
{
    ULONG ul;
    word CS_save, IP_save;
    word int15Off, int15Seg;

    /*:::::::::::::::::::::::::::::::::: Get location of current 15h handler */
    sas_loadw(0x15*4 ,    &int15Off);
    sas_loadw(0x15*4 + 2, &int15Seg);

    /*:::::::::::::::::::::: Does the 15h vector point to the softpc handler */
    ul = (ULONG)getAH();
    if((ul == 0x4f || ul == 0x91) &&
       int15Off == sp_int15_handler_off &&
       int15Seg == sp_int15_handler_seg)
    {
        (BIOS[0x15])();             /* Call int15 handler defined in base */
    }
    else
    {
        /*::::::::::::::::::::::::::::::::::::::::::::::: Call int15 handler */
        ul = (ULONG)bBiosOwnsKbdHdw;
        if (bBiosOwnsKbdHdw)  {
            bBiosOwnsKbdHdw = FALSE;
            HostReleaseKbd();
            }
        CS_save = getCS();          /* Save current CS,IP settings */
	IP_save = getIP();
        setCS(int15_seg);
        setIP(int15_off);
	host_simulate();	    /* Call int15 handler */
        setCS(CS_save);             /* Restore CS,IP */
        setIP(IP_save);
        if (ul)
            bBiosOwnsKbdHdw = !WaitKbdHdw(5000);
    }
}


/*
 *  32 bit services for kb16.com, the international 16 bit
 *  interrupt 9 service handler.
 *
 */
void Keyb16Request(half_word BopFnCode)
{

	/*
	 * upon entry to kb16, take ownership of kbd
	 *		       disable the kbd
	 *		       disable interrupts
	 */
    if (BopFnCode == 1) {
	bBiosOwnsKbdHdw = !WaitKbdHdw(5000);
	outb(KEYBA_STATUS_CMD, DIS_KBD);
	setIF(1);
	}

	/* K26A type exit from i9 handler */
    else if (BopFnCode == 2) {
	if (getBH()) {	/* bl == do beep */
	    host_alarm(250000L);
	    }

	outb(0x20, 0x20);    /* eoi */

	if (getBL()) {	     /* got character ? do device post */
	    setAX(0x9102);
	    INT15();
	    }
	outb(KEYBA_STATUS_CMD, ENA_KBD);
	if (bBiosOwnsKbdHdw) {
	    bBiosOwnsKbdHdw = FALSE;
	    HostReleaseKbd();
	    }
	}

	/* K27A exit notify */
    else if (BopFnCode == 3) {
	outb(0x20, 0x20);
	outb(KEYBA_STATUS_CMD, ENA_KBD);
	if (bBiosOwnsKbdHdw) {
	    bBiosOwnsKbdHdw = FALSE;
	    HostReleaseKbd();
	    }
	}

	/* K27A exit notify */
    else if (BopFnCode == 4) {
	outb(KEYBA_STATUS_CMD, ENA_KBD);
	if (bBiosOwnsKbdHdw) {
	    bBiosOwnsKbdHdw = FALSE;
	    HostReleaseKbd();
	    }
	}
}

#endif /* NTVDM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\keymouse\mouse.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Version 2.0
 *
 * Title	: Microsoft Bus Mouse Adapter
 *
 * Description	: This package contains a group of functions that provide
 *               an interface between the Microsoft Bus Mouse Card and the cpu.
 *
 *		mouse_init()	Initialise the bus mouse adapter
 *		mouse_inb() 	Supports IN's from ports in the bus mouse range
 *		mouse_outb()	Supports OUT's to ports in the bus mouse range
 *		mouse_send()	Queues data sent from the host mouse
 *
 * Author       : Henry Nash
 *
 * Notes        : See the Microsoft Inport Technical Reference Manual for
 *                further information on the hardware interface.
 *                The Bus Mouse ports are jumper selectable on the real card
 *                between (1) 023C - 023F & (2) 0238 - 023B. We only support
 *                the primary range 023C - 023F.
 *						
 *       (r3.5) : The system directory /usr/include/sys is not available
 *                on a Mac running Finder and MPW. Bracket references to
 *                such include files by "#ifdef macintosh <Mac file> #else
 *                <Unix file> #endif".
 */

#ifdef SCCSID
static char SccsID[]="@(#)mouse.c	1.17+ 07/10/95 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_MOUSE.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>
#include TypesH

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "sas.h"
#include "cga.h"
#include "bios.h"
#include "error.h"
#include "ios.h"
#include "ica.h"
#include "trace.h"
#include "video.h"
#include "mouse.h"
#include "mouse_io.h"


/*
 * The following globals are also used by xxx_input.c,
 * where xxx is the host machine name.
 */

int button_left  = 0;	/* Current state of left button */
int button_right = 0;	/* Current state of right button */
int delta_x = 0, delta_y = 0;	/* Current mouse delta moves */

#ifndef PROD
static char buff[132];
#endif

static half_word data1_reg = 0,
		 data2_reg = 0,
		 mouse_status_reg = 0;

#if defined(NEC_98)

static half_word NEC98_data_reg = 0,
                 NEC98_mouse_status_reg = 0,
                 InterruptFlag=0;
                 InitializeFlag=0;              //930914


static word    MouseIoBase;


#endif    //NEC_98
static half_word
		 last_button_left  = 0,
		 last_button_right = 0;

static half_word
                 mouse_mode_reg          = 0, /* mode register 		*/
		 address_reg       = 0; /* address pointer register	*/

static int
		loadsainterrupts = 5;
/* count of how many times we will send bursts of interrupts to please Windows, per reset */


static int mouse_inb_toggle = 0;

void mouse_inb IFN2(io_addr, port, half_word *, value)
{
#if defined(NEC_98)

   if (port == MouseIoBase + MOUSE_PORT_0) { /* Normal:7FD9h,Hireso:0061h */

       *value = NEC98_data_reg;
   }

   if (port == MouseIoBase + MOUSE_PORT_1) { /* Normal:7FDBh,Hireso:0063h */

        /*
         * Internal registers
         */
       //DbgPrint("NEC not Supported: SPDSW,RAMKL bit\n");

   }

   if (port == MouseIoBase + MOUSE_PORT_2) { /* Normal:7FDDh,Hireso:0065h */

        /*
         * Internal registers
         */
       *value = NEC98_mouse_status_reg;

   }

#else   //NEC_98
    if (port == MOUSE_PORT_1) {		/* data register */

	/*
	 * Internal registers
	 */

	switch (address_reg & 0x07) {
	    case 0x00 :  /* mouse status register */
		*value = mouse_status_reg;
		break;
	    case 0x01 : /* data 1 register horizontal */
		*value = data1_reg;
		break;
	    case 0x02 : /* data 2 register vertical */
		*value = data2_reg;
		break;
	    case 0x07 : /* mode register */
		*value = mouse_mode_reg;
		break;
	    default :
#ifndef PROD
		if (io_verbose & MOUSE_VERBOSE) {
			sprintf(buff, "mouse_inb() :  Bad P");
			trace(buff,DUMP_NONE);
		}
#endif
		break;
	}
    }

	/*
	 * ID register, alternates between value 1 and value 2
	 * value 1 is the chip signature: DE hex
	 * value 2 is the chip revision: 1  and version: 0
	 */

    else
    if (port == MOUSE_PORT_2) {
	if (mouse_inb_toggle = 1 - mouse_inb_toggle)
		*value = 0xDE;
	else
		*value = 0x10;
    }

#ifndef PROD
    if (io_verbose & MOUSE_VERBOSE) {
	sprintf(buff, "mouse_inb() : port %x value %x", port, *value);
	trace(buff,DUMP_NONE);
    }
#endif
#endif    //NEC_98
}


void mouse_outb IFN2(io_addr, port, half_word, value)
{
#if defined(NEC_98)

        NEC98_mouse_status_reg = 0xff;           //930914

        if (port == MouseIoBase + MOUSE_PORT_2) { /* Write port C */
                                                  /* Normal:7FDDh,Hireso:0065h */
           NEC98_data_reg = 0;

           switch (value & 0x60) {
             case 0x00 :  /* X Low4bit */
                NEC98_data_reg = delta_x & 0x0f;
                break;

             case 0x20 :  /* X High4bit */
                NEC98_data_reg = (delta_x & 0xf0) >>4;
                break;

             case 0x40 :  /* Y Low4bit */
                NEC98_data_reg = delta_y & 0x0f;
                break;

             case 0x60 :  /* Y High4bit */
                NEC98_data_reg = (delta_y & 0xf0) >>4;
                break;

             default :
                break;

           }
           if(!button_left)
              NEC98_data_reg |= 0x80;
           if(!button_right)
              NEC98_data_reg |= 0x20;

           if(InitializeFlag){                  //930914
              NEC98_mouse_status_reg = value;
           }
        }
        else if(port == MouseIoBase + MOUSE_PORT_3)     /* address pointer register */
        {                                               /* Normal:7FDFh,Hireso:0067h */
           switch (value) {
             case 0x90 :  //
             case 0x91 :  //
             case 0x92 :  // for Z's STAFF Kid98
             case 0x93 :  /* mode set */
             case 0x94 :  //
             case 0x95 :  //
             case 0x96 :  //
             case 0x97 :  //
                InitializeFlag= 1;
                InterruptFlag = 1;              //930914
                if(HIRESO_MODE)  //Hireso mode
                        ica_clear_int(NEC98_CPU_MOUSE_ADAPTER0,NEC98_CPU_MOUSE_INT2);
                else
                        ica_clear_int(NEC98_CPU_MOUSE_ADAPTER1,NEC98_CPU_MOUSE_INT6);
                delta_x = 0;
                delta_y = 0;
                break;

             case 0x08 : /* Mouse interrupt Enable */
                InterruptFlag = 1;
                break;

             case 0x09 : /* Mouse interrupt Disable */
                InterruptFlag = 0;
                break;

             case 0x0E : /* Clear Count(non clear)*/
                break;

             case 0x0F : /* Clear Count(clear) */
                delta_x = 0;
                delta_y = 0;
                break;

             default :
                break;

           }

           if(InitializeFlag){                  //930914
              NEC98_mouse_status_reg = value;
           }

        }

#else    //NEC_98
#ifndef PROD
	if (io_verbose & MOUSE_VERBOSE) {
		if ((port == MOUSE_PORT_0)
		 || (port == MOUSE_PORT_1)
		 || (port == MOUSE_PORT_2))
			sprintf(buff, "mouse_outb() : port %x value %x", port, value);
		else
			sprintf(buff, "mouse_outb() : bad port: %x value %x", port, value);
		trace(buff,DUMP_NONE);
	}
#endif

	/*
	 * Out to an internal register
	 */

	if (port == MOUSE_PORT_1) {	/* data register */

		/*
		 * Out to Mode register
		 */
		if ( (address_reg & 0x07) == INTERNAL_MODE_REG) {

			/*
			 * Check hold bit (5) for 0 to 1 transition
			 * - Data Interrupt Enable bit is set (Mode 0)
			 * - counter values saved in Data1 & Data2 registers (Mode 0)
			 * - counters cleared
			 * - status register updated
			 */

			if ((value & 0x20) && ((mouse_mode_reg & 0x20) == 0)) {
#ifndef PROD
				if (io_verbose & MOUSE_VERBOSE) {
					sprintf(buff, "mouse_outb() : hold bit 0 -> 1");
					trace(buff,DUMP_NONE);
				}
#endif
				/* clear the interrupt */
				ica_clear_int(AT_CPU_MOUSE_ADAPTER, AT_CPU_MOUSE_INT);

				/*
				 * read next mouse deltas & buttons
				 * into the inport registers
				 */
				data1_reg = (half_word)delta_x;
				data2_reg = (half_word)delta_y;
				mouse_status_reg = 0;
				mouse_status_reg = (button_left << 2) + (button_right);
				if (delta_x!=0 || delta_y!=0) {
					mouse_status_reg |= MOVEMENT;
				}
				if (last_button_right != button_right) {
					mouse_status_reg |= RIGHT_BUTTON_CHANGE;
					last_button_right = (half_word)button_right;
				}

				if (last_button_left != button_left) {
					mouse_status_reg |= LEFT_BUTTON_CHANGE;
					last_button_left = (half_word)button_left;
				}
				delta_x = delta_y = 0;
			}
			/* 1 -> 0 transition on mode register's hold bit */
			/* ready for next read from queue, so send interrupt */
			else if ((mouse_mode_reg & 0x20) && ((value & 0x20)==0)){
#ifndef PROD
				if (io_verbose & MOUSE_VERBOSE) {
					sprintf(buff, "mouse_outb() : hold bit 1 -> 0");
					trace(buff,DUMP_NONE);
				}
#endif
			}
			/*
			 * Check timer select value (bits 210)
			 */

			switch (value & 0x7) {
			case 0x0 :		/* 0 Hz INTR low */
#ifndef PROD
				if (io_verbose & MOUSE_VERBOSE) {
					sprintf(buff, "mouse_outb() : INTR low"); trace(buff,DUMP_NONE);
				}
#endif
				ica_clear_int(AT_CPU_MOUSE_ADAPTER, AT_CPU_MOUSE_INT);
				break;

	/*
	 * In the following cases the application code is expecting to see
	 * interrupts at the requested rate. However in practice this is only
	 * required during initialisation(mouse_mode_reg = 0), and then a short burst
	 * appears to be sufficient. The 15 interupts generated comes from
	 * tests with the "WINDOWS" package, which receives about 15 during
	 * initialising, but is happy as long as it gets more than 3. The delay
	 * is necessary otherwise the interupts are generated before the
	 * application starts looking for them.

	 * Mark 2 bodge:
	   Windows 1.02 needs the burst of interrupts to occur even when mouse_mode_reg != 0,
	   but Windows 2.03 needs them not to keep happening even when it asks for them.
	   So now there's a counter called loadsainterrupts set to 5 on resets, which is
	   how many bursts will be allowed. This makes both Windows work.
	 */
			case 0x1: /* 30 Hz */
			case 0x2: /* 50 Hz */
			case 0x3: /* 100 Hz */
			case 0x4: /* 200 Hz */
/* used to be if mouse_mode_reg == 0 too, removed to make Windows 1.02 work */
			    if( (value & 0x10) && loadsainterrupts > 0)	
			    {
				loadsainterrupts--;
#ifndef PROD
				if (io_verbose & MOUSE_VERBOSE) {
					sprintf(buff, "mouse_outb() : Loadsainterrupts"); trace(buff,DUMP_NONE);
				}
#endif
				/*
				** AT version is asking for a 100 interrupts.
				** The AT ica does not handle delayed ints so
				** the IRET has been modified to not allow an
				** int to go off before the next instruction.
				*/
				ica_hw_interrupt(AT_CPU_MOUSE_ADAPTER,AT_CPU_MOUSE_INT,100);
			     }
				break;
			case 0x5: /* reserved */
#ifndef PROD
				if (io_verbose & MOUSE_VERBOSE) {
					sprintf(buff, "mouse: reserved"); trace(buff,DUMP_NONE);
					}
#endif
				break;
			case 0x6 :		/* 0 Hz INTR hi */
#ifndef PROD
				if (io_verbose & MOUSE_VERBOSE) {
					sprintf(buff, "mouse_outb() : INTR hi"); trace(buff,DUMP_NONE);
				}
#endif
				ica_hw_interrupt(AT_CPU_MOUSE_ADAPTER,AT_CPU_MOUSE_INT,1);
				break;
			case 0x7: /* externally controlled */
				break;
			default:
#ifndef PROD
				if (io_verbose & MOUSE_VERBOSE) {
					sprintf(buff,"mouse_outb() : bad mode");
					trace(buff,DUMP_NONE);
				}
#endif
				break;

			}
		mouse_mode_reg = value;

		/*
	 	 * Interface control register
	 	 */
		}
		else
		if ((address_reg & 0x07) == INTERFACE_CONTROL_REG){
#ifndef PROD
				if (io_verbose & MOUSE_VERBOSE) {
					sprintf(buff, "mouse_outb() :  interface control reg port %x value %x",port,value);
					trace(buff,DUMP_NONE);
				}
#endif
		}

	}
	else if(port == MOUSE_PORT_0)	/* address pointer register */
	{
	    if (value & 0x80)  /* is it  a reset */
	    {
		mouse_mode_reg = 0;
		loadsainterrupts = 5;	/* lets Windows initialise its mouse happily */
		address_reg = value & 0x7F;	/* clear reset bit*/
		ica_clear_int( AT_CPU_MOUSE_ADAPTER, AT_CPU_MOUSE_INT );
	    }
	    else
		address_reg = value;
	}
#endif    //NEC_98
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INPUT.seg"
#endif

void mouse_send(Delta_x,Delta_y,left,right)
int	Delta_x,Delta_y,left,right;
{
	if(Delta_x != 0 || Delta_y != 0 || button_left != left || button_right != right)
	{
#if defined(NEC_98)
                delta_x = Delta_x;
                delta_y = Delta_y;
#else    //NEC_98
		delta_x += Delta_x;
		delta_y += Delta_y;
#endif   //NEC_98

		/***
		Mouse inport registers can only handle one byte
		***/
		if (delta_x < -128)
			delta_x = -128;
		else if (delta_x > 127)
			delta_x = 127;

		if (delta_y < -128)
			delta_y = -128;
		else if (delta_y > 127)
			delta_y = 127;

		button_left = left;
		button_right = right;
#if defined(NEC_98)
                if(InterruptFlag){
                   if(HIRESO_MODE)      //Hireso mode
                      ica_hw_interrupt(NEC98_CPU_MOUSE_ADAPTER0,NEC98_CPU_MOUSE_INT2,1);
                   else
                      ica_hw_interrupt(NEC98_CPU_MOUSE_ADAPTER1,NEC98_CPU_MOUSE_INT6,1);
                }

#else    //NEC_98
		ica_hw_interrupt(AT_CPU_MOUSE_ADAPTER,AT_CPU_MOUSE_INT,1);
#endif   //NEC_98
	}
#if defined(NEC_98)
        else{
             //DbgPrint("NEC Mouse bios:mouse_send not change\n");
                delta_x = 0;
                delta_y = 0;
                if(InterruptFlag){
                   if(HIRESO_MODE)      //Hireso mode
                      ica_hw_interrupt(NEC98_CPU_MOUSE_ADAPTER0,NEC98_CPU_MOUSE_INT2,1);
                   else
                      ica_hw_interrupt(NEC98_CPU_MOUSE_ADAPTER1,NEC98_CPU_MOUSE_INT6,1);
                }
        }
#endif    //NEC_98
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif


void mouse_init IFN0()
{
    IU16 p;

#ifndef PROD
    if (io_verbose & MOUSE_VERBOSE) {
	sprintf(buff, "mouse_init()");
	trace(buff,DUMP_NONE);
    }
#endif

    mouse_inb_toggle = 0;

    io_define_inb(MOUSE_ADAPTOR, mouse_inb);
    io_define_outb(MOUSE_ADAPTOR, mouse_outb);

#if defined(NEC_98)
    if(HIRESO_MODE)  //Hireso mode
      MouseIoBase = HMODE_BASE;
    else
      MouseIoBase = NMODE_BASE;

    for(p = MouseIoBase + MOUSE_PORT_START; p <= MouseIoBase + MOUSE_PORT_END; p=p+2) {

#else    //NEC_98
    for(p = MOUSE_PORT_START; p <= MOUSE_PORT_END; p++) {
#endif   //NEC_98
	io_connect_port(p, MOUSE_ADAPTOR, (IU8)IO_READ_WRITE);

#ifdef KIPPER
#ifdef CPU_40_STYLE
  /* Enable iret hooks on mouse interrupts */
  ica_iret_hook_control(AT_CPU_MOUSE_ADAPTER, AT_CPU_MOUSE_INT, TRUE);
#endif
#endif

#ifndef PROD
	if (io_verbose & MOUSE_VERBOSE) {
	    sprintf(buff, "Mouse Port connected: %x", p);
	    trace(buff,DUMP_NONE);
	}
#endif
    }
    host_deinstall_host_mouse();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\support\get_env.c ===
/*[
 *      Name:           get_env.c
 *
 *      Derived From:   FmIit.c
 *
 *      Author:         William Charnell
 *
 *      Created On:     5th May 1995
 *
 *      Sccs ID:        @(#)get_env.c	1.2 06/16/95
 *
 *      Purpose:        Provide easy interface to env vbls
 *
 *      Design document:
 *
 *      Test document:
 *
 *      (c) Copyright Insignia Solutions Ltd., 1993. All rights reserved
]*/
#include <insignia.h>
#include <host_def.h>
#include <host_inc.h>

#include  <config.h>
#include  <error.h>
#include  <debug.h>	/* for always_trace macros */

#include <get_env.h>



#ifdef NTVDM

#ifdef LOCAL
#undef LOCAL
#endif

#else
LOCAL IBOOL verboseGetenv;
#endif

#ifndef NTVDM
LOCAL void badGetenv IFN3(char *, name, char *, type_name, char *, value)
{
	printf("Bad getenv(\"%s\") %s value \"%s\"", name, type_name, value);
}


LOCAL void setupVerboseGetenv IFN0()
{
	SAVED IBOOL firstGetenv = TRUE;
	char *env;
	char *how = "Defaulting";

	if (firstGetenv)
	{
#ifdef	PROD
		verboseGetenv = FALSE;
#else	/* PROD */
		verboseGetenv = TRUE;
#endif	/* PROD */
		env = host_getenv("VERBOSE_GETENV");
		if (env)
		{
			if (strcmp(env, "FALSE") == 0)
				verboseGetenv = FALSE;
			else if (strcmp(env, "TRUE") == 0)
				verboseGetenv = TRUE;
			else
				badGetenv("VERBOSE_GETENV", "IBOOL", env);
			how = "Setting";
		}
#ifndef	PROD
		printf("%10s %25s IBOOL value \"%s\"\n",
			      how, "VERBOSE_GETENV", verboseGetenv ? "TRUE": "FALSE");
#endif	/* PROD */
		firstGetenv = FALSE;
	}
}
#endif


GLOBAL IBOOL IBOOLgetenv IFN2(char *, name, IBOOL, default_value)
{
        char *env;
        IBOOL value;

#ifndef NTVDM
        char *how = "Defaulting";
        setupVerboseGetenv();
#endif

	value = default_value;
	env = host_getenv(name);
	if (env)
        {
#ifdef NTVDM
            value = _stricmp(env, "TRUE") == 0;
#else
                if (strcmp(env, "FALSE") == 0)
			value = FALSE;
		else if (strcmp(env, "TRUE") == 0)
                        value = TRUE;

		else
                        badGetenv(name, "IBOOL", env);

                how = "Setting";
#endif

        }

#ifndef NTVDM
	if (verboseGetenv)
	{
		printf("%10s %25s IBOOL value \"%s\"\n",
		       how, name, value ? "TRUE": "FALSE");
        }
#endif

	return (value);
}


GLOBAL ISM32 ISM32getenv IFN2(char *, name, ISM32, default_value)
{
        char *env, *ptr;
        ISM32 value;

#ifndef NTVDM
        char *how = "Defaulting";
        setupVerboseGetenv();
#endif

	value = default_value;
	env = host_getenv(name);
	if (env)
	{
		value = strtol(env, &ptr, 0);
		if (ptr == env)	/* cannot do conversion */
                        value = default_value;
#ifndef NTVDM
                how = "Setting";
#endif
        }

#ifndef NTVDM
	if (verboseGetenv)
	{
		printf("%10s %25s ISM32 value \"%d\"\n", how, name, value);
        }
#endif
	return (value);
}


GLOBAL char *STRINGgetenv IFN2(char *, name, char *, default_value)
{
        char *env;
        char *value;

#ifndef NTVDM
        char *how = "Defaulting";
        setupVerboseGetenv();
#endif

	value = default_value;
	env = host_getenv(name);
	if (env)
	{
                value = env;
#ifndef NTVDM
                how = "Setting";
#endif
        }

#ifndef NTVDM
	if (verboseGetenv)
	{
		if (value)
			printf("%10s %25s char* value \"%s\"\n", how, name, value);
		else
			printf("%10s %25s char* with no value\n", how, name, value);
        }
#endif
	return (value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\keymouse\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=keymouse
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOFTPC_TREE=$(PROJECT_ROOT)\mvdm\softpc.new

INCLUDES=$(SOFTPC_TREE)\host\inc;$(SOFTPC_TREE)\base\inc

SOURCES=..\keyba.c    \
        ..\keybd_io.c \
        ..\mouse.c    \
        ..\ppi.c      \
        ..\mouse_io.c

!INCLUDE $(SOFTPC_TREE)\obj.vdm\CDEFINE.INC

SOURCES_USED=..\sources.inc

!INCLUDE $(SOFTPC_TREE)\base\condincl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\keymouse\ppi.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Version 3.0
 *
 * Title:	ppi.c
 *
 * Description:	Read/Write port on AT System Board.
 *
 * Author:	Leigh Dworkin
 *
 * Notes:	On the XT this used to be controlled by the
 * Programmable Peripheral Interface adapter, hence the nomenclature.
 *
 */

#ifdef SCCSID
static char SccsID[]="@(#)ppi.c	1.9 08/10/92 Copyright Insignia Solutions Ltd.";
#endif

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_SUPPORT.seg"
#endif


/*
 *    O/S include files.
 */
#include <stdio.h>

/*
 * SoftPC include files
 */
#include "xt.h"
#include "ios.h"
#include "ppi.h"
#include "timer.h"
#ifndef PROD
#include "trace.h"
#endif
#include "debug.h"

/*
 * ============================================================================
 * Global data
 * ============================================================================
 */

/*
 * ============================================================================
 * Static data and defines
 * ============================================================================
 */

/*
 * This holds the current state of the io port
 */

static half_word ppi_register;

#define PPI_BIT_MASK	0x3F1

static boolean gate_2_was_low = TRUE;	/* state of timer 2 gate */
#ifndef NTVDM
static boolean SPKRDATA_was_low = TRUE;	/* speaker data for sound */
#endif

/*
 * ============================================================================
 * Internal functions 
 * ============================================================================
 */

/*
 * ============================================================================
 * External functions 
 * ============================================================================
 */

void ppi_inb IFN2(io_addr, port, half_word *, value)
{
#ifndef NEC_98
#ifdef PROD
	UNUSED(port);
#endif
	/*
 	 * The bits are assigned as follows:
 	 *
	 * Bit No	Use										Supported
	 * ------	---										---------
	 * 0-3		Value written to output port bits 0-3	yes
	 * 4		Refresh detect toggle					yes
	 * 5 		Timer 2 output level					no
	 * 6		IO channel error status					yes - 0
	 * 7		RAM parity error status					yes - 0
	 *
	 */

    port = port & PPI_BIT_MASK;		/* clear unused bits */
    ppi_register ^= 0x30;
    *value = ppi_register;

    note_trace2(PPI_VERBOSE, "ppi_inb() - port %x, returning val %x", port, *value);
#endif   //NEC_98
}

void ppi_outb IFN2(io_addr, port, half_word, value)
{
#ifndef NEC_98
    port = port & PPI_BIT_MASK;		/* clear unused bits */

    if (port == PPI_GENERAL)
    {
		ppi_register = value & 0x0f;

        note_trace2(PPI_VERBOSE, "ppi_outb() - port %x, val %x", port, value);
	/*
 	 * The bits are assigned as follows:
 	 *
	 * Bit No	Use							Supported
	 * ------	---							---------
	 * 0		Timer Gate to speaker		Yes 
	 * 1		Speaker Data				Yes
	 * 2 		Enable RAM Parity Check		No need - always OK
	 * 3		Enable I/0 Check			No need - always OK
	 * 4-7		Not used.
	 *
	 */

	/*
	 * Tell sound logic whether sound is enabled or not
	 */

#ifndef NTVDM
		if ( (value & 0x02) && SPKRDATA_was_low)
		{
			host_enable_timer2_sound();
			SPKRDATA_was_low = FALSE;
		}
		else
		if ( !(value & 0x02) && !SPKRDATA_was_low)
		{
			host_disable_timer2_sound();
			SPKRDATA_was_low = TRUE;
		}
#endif

		/*
		 * Now gate the ppi signal to the timer.
		 */
	
		if ( (value & 0x01) && gate_2_was_low)
		{

		    timer_gate(TIMER2_REG, GATE_SIGNAL_RISE); 
		    gate_2_was_low = FALSE;
		}
		else
		if ( !(value & 0x01) && !gate_2_was_low)
	
		{
		    timer_gate(TIMER2_REG, GATE_SIGNAL_LOW); 
		    gate_2_was_low = TRUE;
		}
#ifdef NTVDM
                /*
                 *  Tell the host the full PpiState because this effects
                 *  whether we are playing Timer 2 Freq, Ppi Freq or both.
                 *  Do this after calling timer_gate to avoid playing old
                 *  frequencies.
                 */
                HostPpiState(value);
#endif	
	}
    else
	    note_trace2(PPI_VERBOSE, "ppi_outb() - Value %x to unsupported port %x", value, port);
#endif   //NEC_98
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

void ppi_init IFN0()
{
#ifndef NEC_98
    io_addr i;
    io_define_inb(PPI_ADAPTOR, ppi_inb);
    io_define_outb(PPI_ADAPTOR, ppi_outb);

    for(i = PPI_PORT_START+1; i <= PPI_PORT_END; i+=2)
		io_connect_port(i, PPI_ADAPTOR, IO_READ_WRITE);

    ppi_register = 0x00;
#endif   //NEC_98
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\keymouse\mouse_io.c ===
#include "insignia.h"
#include "host_def.h"
/*
 * SoftPC Revision 3.0
 *
 * Title        : Mouse Driver Emulation
 *
 * Emulated Version     : 8.00
 *
 *
 * Description  : This module provides an emulation of the Microsoft
 *                Mouse Driver: the module is accessed using the following
 *                BOP calls from the BIOS:
 *
 *              mouse_install1()        | Mouse Driver install
 *              mouse_install2()        | routines
 *
 *              mouse_int1()            | Mouse Driver hardware interrupt
 *              mouse_int2()            | handling routines
 *
 *              mouse_io_interrupt()    | Mouse Driver io function assembler
 *              mouse_io_language()     | and high-level language interfaces
 *
 *              mouse_video_io()        | Intercepts video io function
 *
 *                Since a mouse driver can only be installed AFTER the
 *                operating system has booted, a small Intel program must
 *                run to enable the Insignia Mouse Driver. This program
 *                calls BOP mouse_install2 if an existing mouse driver
 *                is detected; otherwise BOP mouse_install1 is called to
 *                start the Insignia Mouse Driver.
 *
 *                When the Insignia Mouse Driver is enabled, interrupts
 *                are processed as follows
 *
 *              INT 0A (Mouse hardware interrupt)       BOP mouse_int1-2
 *              INT 10 (Video IO interrupt)             BOP mouse_video_io
 *              INT 33 (Mouse IO interrupt)             BOP mouse_io_interrupt
 *
 *                High-level languages can call a mouse io entry point 2 bytes
 *                above the interrupt entry point: this call is handled
 *                using a BOP mouse_io_language.
 *
 * Author       : Ross Beresford
 *
 * Notes        : The functionality of the Mouse Driver was established
 *                from the following sources:
 *                   Microsoft Mouse User's Guide
 *                   IBM PC-XT Technical Reference Manuals
 *                   Microsoft InPort Technical Note
 *
 */

/*
 * static char SccsID[]="07/04/95 @(#)mouse_io.c        1.72 Copyright Insignia Solutions Ltd.";
 */


#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_MOUSE.seg"
#endif


/*
 *    O/S include files.
 */

#include <stdio.h>
#include TypesH
#include StringH

/*
 * SoftPC include files
 */
#include "xt.h"
#include "ios.h"
#include "bios.h"
#include "sas.h"
#include CpuH
#include "trace.h"
#include "debug.h"
#include "gvi.h"
#include "cga.h"
#ifdef EGG
#include "egacpu.h"
#include "egaports.h"
#include "egavideo.h"
#endif
#include "error.h"
#include "config.h"
#include "mouse_io.h"
#include "ica.h"
#include "video.h"
#include "gmi.h"
#include "gfx_upd.h"
#include "egagraph.h"
#include "vgaports.h"
#include "keyboard.h"
#include "virtual.h"

#ifdef NTVDM
#include "nt_event.h"
#include "nt_mouse.h"

#ifdef MONITOR
/*
 * We're running with real ROMs on the monitor and so all the hard coded ROM
 * addresses defined below don't work. Pick up the real addresses of this stuff
 * which is now resident in the driver and put it into the MOUSE_ tokens which
 * have been magically changed into variables.
 */
#undef MOUSE_INT1_SEGMENT
#undef MOUSE_INT1_OFFSET
#undef MOUSE_INT2_SEGMENT
#undef MOUSE_INT2_OFFSET
#undef MOUSE_IO_INTERRUPT_OFFSET
#undef MOUSE_IO_INTERRUPT_SEGMENT
#undef MOUSE_VIDEO_IO_OFFSET
#undef MOUSE_VIDEO_IO_SEGMENT
#undef MOUSE_COPYRIGHT_SEGMENT
#undef MOUSE_COPYRIGHT_OFFSET
#undef MOUSE_VERSION_SEGMENT
#undef MOUSE_VERSION_OFFSET
#undef VIDEO_IO_SEGMENT
#undef VIDEO_IO_RE_ENTRY

LOCAL word   MOUSE_INT1_SEGMENT, MOUSE_INT1_OFFSET,
             MOUSE_IO_INTERRUPT_OFFSET, MOUSE_IO_INTERRUPT_SEGMENT,
             MOUSE_VIDEO_IO_SEGMENT, MOUSE_VIDEO_IO_OFFSET,
             MOUSE_COPYRIGHT_SEGMENT, MOUSE_COPYRIGHT_OFFSET,
             MOUSE_VERSION_SEGMENT, MOUSE_VERSION_OFFSET,
             MOUSE_INT2_SEGMENT, MOUSE_INT2_OFFSET,
             VIDEO_IO_SEGMENT,  VIDEO_IO_RE_ENTRY;

/* @ACW */
word DRAW_FS_POINTER_OFFSET; /* holds segment:offset for the Intel code which */
word DRAW_FS_POINTER_SEGMENT;/* draws the fullscreen mouse cursor */
word POINTER_ON_OFFSET;
word POINTER_ON_SEGMENT;
word POINTER_OFF_OFFSET;
word POINTER_OFF_SEGMENT;
WORD F0_OFFSET,F0_SEGMENT;
word F9_OFFSET,F9_SEGMENT;
word CP_X_O,CP_Y_O;
word CP_X_S,CP_Y_S;
word savedtextsegment,savedtextoffset;
word button_off,button_seg;
#ifdef JAPAN
sys_addr saved_ac_sysaddr = 0, saved_ac_flag_sysaddr = 0;
#endif // JAPAN

static word mouseINBsegment, mouseINBoffset;
static word mouseOUTBsegment, mouseOUTBoffset;
static word mouseOUTWsegment, mouseOUTWoffset;
sys_addr mouseCFsysaddr;
sys_addr conditional_off_sysaddr;

#endif  /* MONITOR */

extern void host_simulate();

void GLOBAL mouse_ega_mode(int curr_video_mode);

IMPORT void host_m2p_ratio(word *,word *,word *,word *);
IMPORT void host_x_range(word *,word *,word *,word *);
IMPORT void host_y_range(word *,word *,word *,word *);
void   host_show_pointer(void);
void   host_hide_pointer(void);
GLOBAL  VOID    host_os_mouse_pointer(MOUSE_CURSOR_STATUS *,MOUSE_CALL_MASK *,
                                      MOUSE_VECTOR *);

LOCAL word              saved_int71_segment;
LOCAL word              saved_int71_offset;

#endif /* NTVDM */

#include "host_gfx.h"

#ifdef MOUSE_16_BIT
#include HostHwVgaH
#include "hwvga.h"
#include "mouse16b.h"
#endif          /* MOUSE_16_BIT */

/*
 * Tidy define to optimise port accesses, motivated by discovering
 * how bad it is to run out of register windows on the SPARC.
 */

#ifdef CPU_40_STYLE

/* IO virtualisation is essential - no optimisation allowed. */
#define OUTB(port, val) outb(port, val)

#else

IMPORT VOID (**get_outb_ptr())();
#define OUTB(port, val) (**get_outb_ptr(port))(port, val)

#endif /* CPU_40_STYLE */

/*
   Offsets to data buffers held in MOUSE.COM (built from
   base/intel/mouse/uf.mouse.asm).
 */
#define OFF_HOOK_POSN        0x103
#define OFF_ACCL_BUFFER      0x105
#define OFF_MOUSE_INI_BUFFER 0x249

/*
   Data values for mouse functions.
 */
#define MOUSE_M1 (0xffff)
#define MOUSE_M2 (0xfffe)

#define MAX_NR_VIDEO_MODES 0x7F

#ifdef EGG
LOCAL BOOL jap_mouse=FALSE;             /* flag if need to fake text cursor */
IMPORT IU8 Currently_emulated_video_mode; /* as set in ega_set_mode() */
#endif /* EGG */

/*
 *      MOUSE DRIVER LOCAL STATE DATA
 *      =============================
 */

/*
 *      Function Declarations
 */
LOCAL void mouse_reset IPT4(word *,installed_ptr,word *,nbuttons_ptr,word *,junk3,word *,junk4);

LOCAL void mouse_show_cursor IPT4(word *,junk1,word *,junk2,word *,junk3,word *,junk4);

LOCAL void mouse_hide_cursor IPT4(word *,junk1,word *,junk2,word *,junk3,word *,junk4);

LOCAL void mouse_get_position IPT4(word *,junk1,MOUSE_STATE *,button_status_ptr,MOUSE_SCALAR *,cursor_x_ptr,MOUSE_SCALAR *,cursor_y_ptr);

LOCAL void mouse_set_position IPT4(word *,junk1,word *,junk2,MOUSE_SCALAR *,cursor_x_ptr,MOUSE_SCALAR *,cursor_y_ptr);

LOCAL void mouse_get_press IPT4(MOUSE_STATE *,button_status_ptr,MOUSE_COUNT *,button_ptr,MOUSE_SCALAR *,cursor_x_ptr,MOUSE_SCALAR *,cursor_y_ptr);

LOCAL void mouse_get_release IPT4(MOUSE_STATE *,button_status_ptr,MOUSE_COUNT *,button_ptr,MOUSE_SCALAR *,cursor_x_ptr,MOUSE_SCALAR *,cursor_y_ptr);

LOCAL void mouse_set_range_x IPT4(word *,junk1,word *,junk2,MOUSE_SCALAR *,minimum_x_ptr,MOUSE_SCALAR *,maximum_x_ptr);

LOCAL void mouse_set_range_y IPT4(word *,junk1,word *,junk2,MOUSE_SCALAR *,minimum_y_ptr,MOUSE_SCALAR *,maximum_y_ptr);

LOCAL void mouse_set_graphics IPT4(word *,junk1,MOUSE_SCALAR *,hot_spot_x_ptr,MOUSE_SCALAR *,hot_spot_y_ptr,word *,bitmap_address);

LOCAL void mouse_set_text IPT4(word *,junk1,MOUSE_STATE *,text_cursor_type_ptr,MOUSE_SCREEN_DATA *,parameter1_ptr,MOUSE_SCREEN_DATA *,parameter2_ptr);

LOCAL void mouse_read_motion IPT4(word *,junk1,word *,junk2,MOUSE_COUNT *,motion_count_x_ptr,MOUSE_COUNT *,motion_count_y_ptr);

LOCAL void mouse_set_subroutine IPT4(word *,junk1,word *,junk2,word *,call_mask,word *,subroutine_address);

LOCAL void mouse_light_pen_on IPT4(word *,junk1,word *,junk2,word *,junk3,word *,junk4);

LOCAL void mouse_light_pen_off IPT4(word *,junk1,word *,junk2,word *,junk3,word *,junk4);

LOCAL void mouse_set_ratio IPT4(word *,junk1,word *,junk2,MOUSE_SCALAR *,ratio_x_ptr,MOUSE_SCALAR *,ratio_y_ptr);

LOCAL void mouse_conditional_off IPT4(word *,junk1,word *,junk2,MOUSE_SCALAR *,upper_x_ptr,MOUSE_SCALAR *,upper_y_ptr);

LOCAL void mouse_unrecognised IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_set_double_speed IPT4(word *,junk1,word *,junk2,word *,junk3,word *,threshold_speed);

LOCAL void mouse_get_and_set_subroutine IPT4(word *,junk1,word *,junk2,word *,call_mask,word *,subroutine_address);

LOCAL void mouse_get_state_size IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_save_state IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_restore_state IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_set_alt_subroutine IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_get_alt_subroutine IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_set_sensitivity IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_get_sensitivity IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_set_int_rate IPT4(word *,m1,word *,int_rate_ptr,word *,m3,word *,m4);

LOCAL void mouse_set_pointer_page IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_get_pointer_page IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_driver_disable IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_driver_enable IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_set_language IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_get_language IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_get_info IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_get_driver_info IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_get_max_coords IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void mouse_get_masks_and_mickeys IPT4
   (
   MOUSE_SCREEN_DATA *, screen_mask_ptr,        /* aka start line */
   MOUSE_SCREEN_DATA *, cursor_mask_ptr,        /* aka stop line */
   MOUSE_SCALAR *,      raw_horiz_count,
   MOUSE_SCALAR *,      raw_vert_count
   ); /* FUNC 39 */

LOCAL void mouse_set_video_mode IPT4
   (
   word *, m1,
   word *, m2,
   word *, video_mode_ptr,
   word *, font_size_ptr
   ); /* FUNC 40 */

LOCAL void mouse_enumerate_video_modes IPT4
   (
   word *, m1,
   word *, m2,
   word *, video_nr_ptr,
   word *, offset_ptr
   ); /* FUNC 41 */

LOCAL void mouse_get_cursor_hot_spot IPT4
   (
   word *,         fCursor_ptr,
   MOUSE_SCALAR *, hot_spot_x_ptr,
   MOUSE_SCALAR *, hot_spot_y_ptr,
   word *,         mouse_type_ptr
   ); /* FUNC 42 */

LOCAL void mouse_load_acceleration_curves IPT4
   (
   word *, success_ptr,
   word *, curve_ptr,
   word *, m3,
   word *, m4
   ); /* FUNC 43 */

LOCAL void mouse_read_acceleration_curves IPT4
   (
   word *, success_ptr,
   word *, curve_ptr,
   word *, m3,
   word *, m4
   ); /* FUNC 44 */

LOCAL void mouse_set_get_active_acceleration_curve IPT4
   (
   word *, success_ptr,
   word *, curve_ptr,
   word *, m3,
   word *, m4
   ); /* FUNC 45 */

LOCAL void mouse_microsoft_internal IPT4
   (
   word *, m1,
   word *, m2,
   word *, m3,
   word *, m4
   ); /* FUNC 46 */

LOCAL void mouse_hardware_reset IPT4
   (
   word *, status_ptr,
   word *, m2,
   word *, m3,
   word *, m4
   );   /* FUNC 47 */

LOCAL void mouse_set_get_ballpoint_info IPT4
   (
   word *, status_ptr,
   word *, rotation_angle_ptr,
   word *, button_mask_ptr,
   word *, m4
   );   /* FUNC 48 */

LOCAL void mouse_get_min_max_virtual_coords IPT4
   (
   MOUSE_SCALAR *, min_x_ptr,
   MOUSE_SCALAR *, min_y_ptr,
   MOUSE_SCALAR *, max_x_ptr,
   MOUSE_SCALAR *, max_y_ptr
   ); /* FUNC 49 */

LOCAL void mouse_get_active_advanced_functions IPT4
   (
   word *, active_flag1_ptr,
   word *, active_flag2_ptr,
   word *, active_flag3_ptr,
   word *, active_flag4_ptr
   ); /* FUNC 50 */

LOCAL void mouse_get_switch_settings IPT4
   (
   word *, status_ptr,
   word *, m2,
   word *, buffer_length_ptr,
   word *, offset_ptr
   ); /* FUNC 51 */

LOCAL void mouse_get_mouse_ini IPT4
   (
   word *, status_ptr,
   word *, m2,
   word *, m3,
   word *, offset_ptr
   ); /* FUNC 52 */

LOCAL void do_mouse_function IPT4(word *,m1,word *,m2,word *,m3,word *,m4);

LOCAL void load_acceleration_curve IPT3
   (
   word, seg,
   word, off,
   ACCELERATION_CURVE_DATA *, hcurve
   );

LOCAL void store_acceleration_curve IPT3
   (
   word, seg,
   word, off,
   ACCELERATION_CURVE_DATA *, hcurve
   );

LOCAL void mouse_EM_move IPT0();

LOCAL void mouse_update IPT1(MOUSE_CALL_MASK, event_mask);

LOCAL void cursor_undisplay IPT0();

LOCAL void cursor_mode_change IPT1(int,new_mode);

LOCAL void inport_get_event IPT1(MOUSE_INPORT_DATA *,event);

LOCAL void cursor_update IPT0();

LOCAL void jump_to_user_subroutine IPT3(MOUSE_CALL_MASK,condition_mask,word,segment,word,offset);

LOCAL void cursor_display IPT0();

LOCAL void inport_reset IPT0();

GLOBAL void software_text_cursor_display IPT0();

GLOBAL void software_text_cursor_undisplay IPT0();

GLOBAL void hardware_text_cursor_display IPT0();

GLOBAL void hardware_text_cursor_undisplay IPT0();

LOCAL void graphics_cursor_display IPT0();

LOCAL void graphics_cursor_undisplay IPT0();

LOCAL void      get_screen_size IPT0();

LOCAL void clean_all_regs IPT0();

LOCAL void dirty_all_regs IPT0();

LOCAL void copy_default_graphics_cursor IPT0();

#ifdef EGG
LOCAL VOID VGA_graphics_cursor_display IPT0();
LOCAL VOID VGA_graphics_cursor_undisplay IPT0();
void LOCAL EGA_graphics_cursor_undisplay IPT0();
void LOCAL EGA_graphics_cursor_display IPT0();
#endif

#ifdef HERC
LOCAL void HERC_graphics_cursor_display IPT0();
LOCAL void HERC_graphics_cursor_undisplay IPT0();
#endif /* HERC */

void (*mouse_int1_action) IPT0();
void (*mouse_int2_action) IPT0();


        /* jump table */
SAVED void (*mouse_function[MOUSE_FUNCTION_MAXIMUM])() =
{
        /*  0 */ mouse_reset,
        /*  1 */ mouse_show_cursor,
        /*  2 */ mouse_hide_cursor,
        /*  3 */ mouse_get_position,
        /*  4 */ mouse_set_position,
        /*  5 */ mouse_get_press,
        /*  6 */ mouse_get_release,
        /*  7 */ mouse_set_range_x,
        /*  8 */ mouse_set_range_y,
        /*  9 */ mouse_set_graphics,
        /* 10 */ mouse_set_text,
        /* 11 */ mouse_read_motion,
        /* 12 */ mouse_set_subroutine,
        /* 13 */ mouse_light_pen_on,
        /* 14 */ mouse_light_pen_off,
        /* 15 */ mouse_set_ratio,
        /* 16 */ mouse_conditional_off,
        /* 17 */ mouse_unrecognised,
        /* 18 */ mouse_unrecognised,
        /* 19 */ mouse_set_double_speed,
        /* 20 */ mouse_get_and_set_subroutine,
        /* 21 */ mouse_get_state_size,
        /* 22 */ mouse_save_state,
        /* 23 */ mouse_restore_state,
        /* 24 */ mouse_set_alt_subroutine,
        /* 25 */ mouse_get_alt_subroutine,
        /* 26 */ mouse_set_sensitivity,
        /* 27 */ mouse_get_sensitivity,
        /* 28 */ mouse_set_int_rate,
        /* 29 */ mouse_set_pointer_page,
        /* 30 */ mouse_get_pointer_page,
        /* 31 */ mouse_driver_disable,
        /* 32 */ mouse_driver_enable,
        /* 33 */ mouse_reset,
        /* 34 */ mouse_set_language,
        /* 35 */ mouse_get_language,
        /* 36 */ mouse_get_info,
        /* 37 */ mouse_get_driver_info,
        /* 38 */ mouse_get_max_coords,
        /* 39 */ mouse_get_masks_and_mickeys,
        /* 40 */ mouse_set_video_mode,
        /* 41 */ mouse_enumerate_video_modes,
        /* 42 */ mouse_get_cursor_hot_spot,
        /* 43 */ mouse_load_acceleration_curves,
        /* 44 */ mouse_read_acceleration_curves,
        /* 45 */ mouse_set_get_active_acceleration_curve,
        /* 46 */ mouse_microsoft_internal,
        /* 47 */ mouse_hardware_reset,
        /* 48 */ mouse_set_get_ballpoint_info,
        /* 49 */ mouse_get_min_max_virtual_coords,
        /* 50 */ mouse_get_active_advanced_functions,
        /* 51 */ mouse_get_switch_settings,
        /* 52 */ mouse_get_mouse_ini,
};


/*
 *      Mickey to Pixel Ratio Declarations
 */

        /* NB all mouse gears are scaled by MOUSE_RATIO_SCALE_FACTOR */
LOCAL MOUSE_VECTOR mouse_gear_default =
{
        MOUSE_RATIO_X_DEFAULT,
        MOUSE_RATIO_Y_DEFAULT
};

/*
 *      Sensitivity declarations
 */

#define mouse_sens_calc_val(sens)                                                                               \
/* This macro converts a sensitivity request (1-100) to a multiplier value */                                   \
        (MOUSE_SCALAR)(                                                                                                 \
         (sens < MOUSE_SENS_DEF) ?                                                                              \
                ((IS32)MOUSE_SENS_MIN_VAL + ( ((IS32)sens - (IS32)MOUSE_SENS_MIN)*(IS32)MOUSE_SENS_MULT *       \
                                        ((IS32)MOUSE_SENS_DEF_VAL - (IS32)MOUSE_SENS_MIN_VAL) /                 \
                                        ((IS32)MOUSE_SENS_DEF     - (IS32)MOUSE_SENS_MIN) ) )                   \
        :                                                                                                       \
                ((IS32)MOUSE_SENS_DEF_VAL + ( ((IS32)sens - (IS32)MOUSE_SENS_DEF)*(IS32)MOUSE_SENS_MULT *       \
                                        ((IS32)MOUSE_SENS_MAX_VAL - (IS32)MOUSE_SENS_DEF_VAL) /                 \
                                        ((IS32)MOUSE_SENS_MAX     - (IS32)MOUSE_SENS_DEF) ) )                   \
        )

/*
 *      Text Cursor Declarations
 */

LOCAL MOUSE_SOFTWARE_TEXT_CURSOR software_text_cursor_default =
{
        MOUSE_TEXT_SCREEN_MASK_DEFAULT,
        MOUSE_TEXT_CURSOR_MASK_DEFAULT
};

/*
 *      Graphics Cursor Declarations
 */
LOCAL MOUSE_GRAPHICS_CURSOR graphics_cursor_default =
{
        {
                MOUSE_GRAPHICS_HOT_SPOT_X_DEFAULT,
                MOUSE_GRAPHICS_HOT_SPOT_Y_DEFAULT
        },
        {
                MOUSE_GRAPHICS_CURSOR_WIDTH,
                MOUSE_GRAPHICS_CURSOR_DEPTH
        },
        MOUSE_GRAPHICS_SCREEN_MASK_DEFAULT,
        MOUSE_GRAPHICS_CURSOR_MASK_DEFAULT
};

        /* grid the cursor must lie on */
LOCAL MOUSE_VECTOR cursor_grids[MOUSE_VIDEO_MODE_MAXIMUM] =
{
        { 16, 8 },      /* mode 0 */
        { 16, 8 },      /* mode 1 */
        {  8, 8 },      /* mode 2 */
        {  8, 8 },      /* mode 3 */
        {  2, 1 },      /* mode 4 */
        {  2, 1 },      /* mode 5 */
        {  1, 1 },      /* mode 6 */
        {  8, 8 },      /* mode 7 */
#ifdef EGG
        {  0, 0 },      /* mode 8, not on EGA */
        {  0, 0 },      /* mode 9, not on EGA */
        {  0, 0 },      /* mode A, not on EGA */
        {  0, 0 },      /* mode B, not on EGA */
        {  0, 0 },      /* mode C, not on EGA */
        {  2, 1 },      /* mode D */
        {  1, 1 },      /* mode E */
        {  1, 1 },      /* mode F */
        {  1, 1 },      /* mode 10 */
#endif
#ifdef VGG
        {  1, 1 },      /* mode 11 */
        {  1, 1 },      /* mode 12 */
        {  2, 1 },      /* mode 13 */
#endif
};
#ifdef V7VGA
LOCAL MOUSE_VECTOR v7text_cursor_grids[6] =
{
        {  8, 8 },      /* mode 40 */
        {  8, 14 },     /* mode 41 */
        {  8, 8 },      /* mode 42 */
        {  8, 8 },      /* mode 43 */
        {  8, 8 },      /* mode 44 */
        {  8, 14 },     /* mode 45 */
};
LOCAL MOUSE_VECTOR v7graph_cursor_grids[10] =
{
        {  1, 1 },      /* mode 60 */
        {  1, 1 },      /* mode 61 */
        {  1, 1 },      /* mode 62 */
        {  1, 1 },      /* mode 63 */
        {  1, 1 },      /* mode 64 */
        {  1, 1 },      /* mode 65 */
        {  1, 1 },      /* mode 66 */
        {  1, 1 },      /* mode 67 */
        {  1, 1 },      /* mode 68 */
        {  1, 1 },      /* mode 69 */
};
#endif /* V7VGA */

        /* grid for light pen response */
LOCAL MOUSE_VECTOR text_grids[MOUSE_VIDEO_MODE_MAXIMUM] =
{
        { 16, 8 },      /* mode 0 */
        { 16, 8 },      /* mode 1 */
        {  8, 8 },      /* mode 2 */
        {  8, 8 },      /* mode 3 */
        { 16, 8 },      /* mode 4 */
        { 16, 8 },      /* mode 5 */
        {  8, 8 },      /* mode 6 */
        {  8, 8 },      /* mode 7 */
#ifdef EGG
        {  0, 0 },      /* mode 8, not on EGA */
        {  0, 0 },      /* mode 9, not on EGA */
        {  0, 0 },      /* mode A, not on EGA */
        {  0, 0 },      /* mode B, not on EGA */
        {  0, 0 },      /* mode C, not on EGA */
        {  8, 8 },      /* mode D */
        {  8, 8 },      /* mode E */
        {  8, 14 },     /* mode F */
        {  8, 14 },     /* mode 10 */
#endif
#ifdef VGG
        {  8, 8 },      /* mode 11 */
        {  8, 8 },      /* mode 12 */
        {  8, 16 },     /* mode 13 */
#endif
};
#ifdef V7VGA
LOCAL MOUSE_VECTOR v7text_text_grids[6] =
{
        {  8, 8 },      /* mode 40 */
        {  8, 14 },     /* mode 41 */
        {  8, 8 },      /* mode 42 */
        {  8, 8 },      /* mode 43 */
        {  8, 8 },      /* mode 44 */
        {  8, 14 },     /* mode 45 */
};
LOCAL MOUSE_VECTOR v7graph_text_grids[10] =
{
        {  8, 8 },      /* mode 60 */
        {  8, 8 },      /* mode 61 */
        {  8, 8 },      /* mode 62 */
        {  8, 8 },      /* mode 63 */
        {  8, 8 },      /* mode 64 */
        {  8, 8 },      /* mode 65 */
        {  8, 16 },     /* mode 66 */
        {  8, 16 },     /* mode 67 */
        {  8, 8 },      /* mode 68 */
        {  8, 8 },      /* mode 69 */
};
#endif /* V7VGA */

/* Default acceleration curve */
LOCAL ACCELERATION_CURVE_DATA default_acceleration_curve =
   {
   /* length */
   {  1,  8, 12, 16 },
   /* mickey counts */
   {{  1, 127, 127, 127, 127, 127, 127, 127,
     127, 127, 127, 127, 127, 127, 127, 127,
     127, 127, 127, 127, 127, 127, 127, 127,
     127, 127, 127, 127, 127, 127, 127, 127},
    {  1,   5,   9,  13,  17,  21,  25,  29,
     127, 127, 127, 127, 127, 127, 127, 127,
     127, 127, 127, 127, 127, 127, 127, 127,
     127, 127, 127, 127, 127, 127, 127, 127},
    {  1,   4,   7,  10,  13,  16,  19,  22,
      25,  28,  31,  34, 127, 127, 127, 127,
     127, 127, 127, 127, 127, 127, 127, 127,
     127, 127, 127, 127, 127, 127, 127, 127},
    {  1,   3,   5,   7,   9,  11,  13,  15,
      17,  19,  21,  23,  25,  27,  29,  31,
     127, 127, 127, 127, 127, 127, 127, 127,
     127, 127, 127, 127, 127, 127, 127, 127}},
   /* scale factors */
   {{ 16,  16,  16,  16,  16,  16,  16,  16,
      16,  16,  16,  16,  16,  16,  16,  16,
      16,  16,  16,  16,  16,  16,  16,  16,
      16,  16,  16,  16,  16,  16,  16,  16},
    { 16,  20,  24,  28,  32,  36,  40,  44,
      16,  16,  16,  16,  16,  16,  16,  16,
      16,  16,  16,  16,  16,  16,  16,  16,
      16,  16,  16,  16,  16,  16,  16,  16},
    { 16,  20,  24,  28,  32,  36,  40,  44,
      48,  52,  56,  60,  16,  16,  16,  16,
      16,  16,  16,  16,  16,  16,  16,  16,
      16,  16,  16,  16,  16,  16,  16,  16},
    { 16,  20,  24,  28,  32,  36,  40,  44,
      48,  52,  56,  60,  64,  68,  72,  76,
      16,  16,  16,  16,  16,  16,  16,  16,
      16,  16,  16,  16,  16,  16,  16,  16}},
   /* names */
   {{'V', 'a', 'n', 'i', 'l', 'l', 'a',   0,
       0,   0,   0,   0,   0,   0,   0,   0},
    {'S', 'l', 'o', 'w',   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0},
    {'N', 'o', 'r', 'm', 'a', 'l',   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0},
    {'F', 'a', 's', 't',   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0}},
   };

#ifndef NEC_98
        /* used to get current video page size */
#define video_page_size() (sas_w_at(VID_LEN))

        /* check if page requested is valid */
#define is_valid_page_number(pg) ((pg) < vd_mode_table[sas_hw_at(vd_video_mode)].npages)
#endif // !NEC_98

/*
 *      Mouse Driver Version
 */

LOCAL half_word mouse_emulated_release  = 0x08;
LOCAL half_word mouse_emulated_version  = 0x00;
LOCAL half_word mouse_io_rev;                   /* Filled in from SCCS ID */
LOCAL half_word mouse_com_rev;                  /* Passed in from MOUSE.COM */

LOCAL char              *mouse_id        = "%s Mouse %d.01 installed\015\012";
LOCAL char              *mouse_installed = "%s Mouse %d.01 already installed\015\012";

/*
 *      Context save stuff
 */
        /* magic cookie for saved context */
LOCAL char mouse_context_magic[] = "ISMMC"; /* Insignia Solutions Mouse Magic Cookie */
#define MOUSE_CONTEXT_MAGIC_SIZE        5
#define MOUSE_CONTEXT_CHECKSUM_SIZE     1

/* size of our context (in bytes) */
#define mouse_context_size (MOUSE_CONTEXT_MAGIC_SIZE + sizeof(MOUSE_CONTEXT) + \
                            MOUSE_CONTEXT_CHECKSUM_SIZE)


LOCAL half_word mouse_interrupt_rate;


/*
   Handle to data instanced for each Virtual Machine.
 */
MM_INSTANCE_DATA_HANDLE mm_handle;

static initial_mouse_screen_mask[MOUSE_GRAPHICS_CURSOR_DEPTH] =
   MOUSE_GRAPHICS_SCREEN_MASK_DEFAULT;

static initial_mouse_cursor_mask[MOUSE_GRAPHICS_CURSOR_DEPTH] =
   MOUSE_GRAPHICS_CURSOR_MASK_DEFAULT;

extern void host_memset(char *, char, int);

/* Initialisation and Termination Procedures */
GLOBAL void mouse_driver_initialisation IFN0()
   {
   int i;

   /* Set up instance memory */
   mm_handle = (MM_INSTANCE_DATA_HANDLE)NIDDB_Allocate_Instance_Data(
                  sizeof(MM_INSTANCE_DATA),
                  (NIDDB_CR_CALLBACK)0,
                  (NIDDB_TM_CALLBACK)0);

   if ( mm_handle == (MM_INSTANCE_DATA_HANDLE)0 )
      {
      host_error(EG_OWNUP, ERR_QUIT,
                 "mouse_io: NIDDB_Allocate_Instance_Data() failed.");
      }

   /* TMM: belt and braces fix, some variables don't get set to zero when perhaps they should */
   host_memset ((char *)(*mm_handle), 0, sizeof(MM_INSTANCE_DATA));

   /* Initialise Variables */
   for ( i = 0; i < MOUSE_BUTTON_MAXIMUM; i++)
      {
      button_transitions[i].press_position.x = 0;
      button_transitions[i].press_position.y = 0;
      button_transitions[i].release_position.x = 0;
      button_transitions[i].release_position.y = 0;
      button_transitions[i].press_count = 0;
      button_transitions[i].release_count = 0;
      }

   mouse_gear.x = MOUSE_RATIO_X_DEFAULT;
   mouse_gear.y = MOUSE_RATIO_Y_DEFAULT;

   mouse_sens.x = MOUSE_SENS_DEF;
   mouse_sens.y = MOUSE_SENS_DEF;

   mouse_sens_val.x = MOUSE_SENS_DEF_VAL;
   mouse_sens_val.y = MOUSE_SENS_DEF_VAL;

   mouse_double_thresh = MOUSE_DOUBLE_DEF;
   text_cursor_type = MOUSE_TEXT_CURSOR_TYPE_SOFTWARE;

   software_text_cursor.screen = MOUSE_TEXT_SCREEN_MASK_DEFAULT;
   software_text_cursor.cursor = MOUSE_TEXT_CURSOR_MASK_DEFAULT;

   graphics_cursor.hot_spot.x = MOUSE_GRAPHICS_HOT_SPOT_X_DEFAULT;
   graphics_cursor.hot_spot.y = MOUSE_GRAPHICS_HOT_SPOT_Y_DEFAULT;
   graphics_cursor.size.x = MOUSE_GRAPHICS_CURSOR_WIDTH;
   graphics_cursor.size.y = MOUSE_GRAPHICS_CURSOR_DEPTH;

   for (i = 0; i < MOUSE_GRAPHICS_CURSOR_DEPTH; i++)
      {
      graphics_cursor.screen[i] = (USHORT)initial_mouse_screen_mask[i];
      graphics_cursor.cursor[i] = (USHORT)initial_mouse_cursor_mask[i];
      }

   user_subroutine_segment = 0;
   user_subroutine_offset = 0;
   user_subroutine_call_mask = 0;

   /* TMM: Flag the alternative user subroutines as not initialised */
   alt_user_subroutines_active = FALSE;
   for (i = 0; i < NUMBER_ALT_SUBROUTINES; i++)
   {
           alt_user_subroutine_segment [i] = 0;
           alt_user_subroutine_offset [i]= 0;
           alt_user_subroutine_call_mask [i] = 0;
   }

   black_hole.top_left.x = -MOUSE_VIRTUAL_SCREEN_WIDTH;
   black_hole.top_left.y = -MOUSE_VIRTUAL_SCREEN_DEPTH;
   black_hole.bottom_right.x = -MOUSE_VIRTUAL_SCREEN_WIDTH;
   black_hole.bottom_right.y = -MOUSE_VIRTUAL_SCREEN_DEPTH;

   double_speed_threshold = MOUSE_DOUBLE_SPEED_THRESHOLD_DEFAULT;
   cursor_flag = MOUSE_CURSOR_DEFAULT;

   cursor_status.position.x = MOUSE_VIRTUAL_SCREEN_WIDTH / 2;
   cursor_status.position.y = MOUSE_VIRTUAL_SCREEN_DEPTH / 2;
   cursor_status.button_status = 0;

   cursor_window.top_left.x = cursor_window.top_left.y = 0;
   cursor_window.bottom_right.x = cursor_window.bottom_right.y = 0;

   light_pen_mode = TRUE;

   mouse_motion.x = 0;
   mouse_motion.y = 0;
   mouse_raw_motion.x = 0;
   mouse_raw_motion.y = 0;

   /* Reset to default curve */
   active_acceleration_curve = 3;   /* Back to Normal */

   memcpy(&acceleration_curve_data, &default_acceleration_curve,
      sizeof(ACCELERATION_CURVE_DATA));

   next_video_mode = 0;   /* reset video mode enumeration */

   point_set(&cursor_position_default, MOUSE_VIRTUAL_SCREEN_WIDTH / 2,
                                       MOUSE_VIRTUAL_SCREEN_DEPTH / 2);

   point_set(&cursor_position, MOUSE_VIRTUAL_SCREEN_WIDTH / 2,
                               MOUSE_VIRTUAL_SCREEN_DEPTH / 2);

   point_set(&cursor_fractional_position, 0, 0);
   cursor_page = 0;

   mouse_driver_disabled = FALSE;
   text_cursor_background = 0;

   for ( i = 0; i < MOUSE_GRAPHICS_CURSOR_DEPTH; i++)
      graphics_cursor_background[i] = 0;

   save_area_in_use = FALSE;
   point_set(&save_position, 0, 0);

   save_area.top_left.x = save_area.top_left.y = 0;
   save_area.bottom_right.x = save_area.bottom_right.y = 0;

   user_subroutine_critical = FALSE;
   last_condition_mask = 0;

   virtual_screen.top_left.x = MOUSE_VIRTUAL_SCREEN_ORIGIN_X;
   virtual_screen.top_left.y = MOUSE_VIRTUAL_SCREEN_ORIGIN_Y;
   virtual_screen.bottom_right.x = MOUSE_VIRTUAL_SCREEN_WIDTH;
   virtual_screen.bottom_right.y = MOUSE_VIRTUAL_SCREEN_DEPTH;

   cursor_grid.x = 8;
   cursor_grid.y = 8;

   text_grid.x = 8;
   text_grid.y = 8;

   black_hole_default.top_left.x = -MOUSE_VIRTUAL_SCREEN_WIDTH;
   black_hole_default.top_left.y = -MOUSE_VIRTUAL_SCREEN_DEPTH;
   black_hole_default.bottom_right.x = -MOUSE_VIRTUAL_SCREEN_WIDTH;
   black_hole_default.bottom_right.y = -MOUSE_VIRTUAL_SCREEN_DEPTH;

#ifdef HERC
   HERC_graphics_virtual_screen.top_left.x = 0;
   HERC_graphics_virtual_screen.top_left.y = 0;
   HERC_graphics_virtual_screen.bottom_right.x = 720;
   HERC_graphics_virtual_screen.bottom_right.y = 350;
#endif /* HERC */

   cursor_EM_disabled = FALSE;
   }

GLOBAL void mouse_driver_termination IFN0()
   {
   /* Just free up instance memory */
   NIDDB_Deallocate_Instance_Data((IHP *)mm_handle);
   }

/*
 *      MOUSE DRIVER EXTERNAL FUNCTIONS
 *      ===============================
 */

/*
 * Macro to produce an interrupt table location from an interrupt number
 */

#define int_addr(int_no)                (int_no * 4)

void mouse_install1()
{

        /*
         *      This function is called from the Mouse Driver program to
         *      install the Insignia Mouse Driver. The interrupt vector
         *      table is patched to divert all the mouse driver interrupts
         */
        word junk1, junk2, junk3, junk4;
        word hook_offset;
        half_word interrupt_mask_register;
        char    temp[128];
#ifdef NTVDM
    word o,s;
    sys_addr block_offset;
#endif
#ifdef JAPAN
word seg, off;
#endif // JAPAN

        note_trace0(MOUSE_VERBOSE, "mouse_install1:");

#ifdef MONITOR
        /*
         * Get addresses of stuff usually in ROM from driver
         * To minimise changes, MOUSE... tokens are now variables and
         * not defines.
         */

        block_offset = effective_addr(getCS(), getBX());

        sas_loadw(block_offset, &MOUSE_IO_INTERRUPT_OFFSET);
        sas_loadw(block_offset+2, &MOUSE_IO_INTERRUPT_SEGMENT);
        sas_loadw(block_offset+4, &MOUSE_VIDEO_IO_OFFSET);
        sas_loadw(block_offset+6, &MOUSE_VIDEO_IO_SEGMENT);
        sas_loadw(block_offset+8, &MOUSE_INT1_OFFSET);
        sas_loadw(block_offset+10, &MOUSE_INT1_SEGMENT);
        sas_loadw(block_offset+12, &MOUSE_VERSION_OFFSET);
        sas_loadw(block_offset+14, &MOUSE_VERSION_SEGMENT);
        sas_loadw(block_offset+16, &MOUSE_COPYRIGHT_OFFSET);
        sas_loadw(block_offset+18, &MOUSE_COPYRIGHT_SEGMENT);
        sas_loadw(block_offset+20, &VIDEO_IO_RE_ENTRY);
        sas_loadw(block_offset+22, &VIDEO_IO_SEGMENT);
        sas_loadw(block_offset+24, &MOUSE_INT2_OFFSET);
        sas_loadw(block_offset+26, &MOUSE_INT2_SEGMENT);
        sas_loadw(block_offset+28, &DRAW_FS_POINTER_OFFSET);
        sas_loadw(block_offset+30, &DRAW_FS_POINTER_SEGMENT);
        sas_loadw(block_offset+32, &F0_OFFSET);
        sas_loadw(block_offset+34, &F0_SEGMENT);
        sas_loadw(block_offset+36, &POINTER_ON_OFFSET);
        sas_loadw(block_offset+38, &POINTER_ON_SEGMENT);
        sas_loadw(block_offset+40, &POINTER_OFF_OFFSET);
        sas_loadw(block_offset+42, &POINTER_OFF_SEGMENT);
        sas_loadw(block_offset+44, &F9_OFFSET);
        sas_loadw(block_offset+46, &F9_SEGMENT);
        sas_loadw(block_offset+48, &CP_X_O);
        sas_loadw(block_offset+50, &CP_X_S);
        sas_loadw(block_offset+52, &CP_Y_O);
        sas_loadw(block_offset+54, &CP_Y_S);
        sas_loadw(block_offset+56, &mouseINBoffset);
        sas_loadw(block_offset+58, &mouseINBsegment);
        sas_loadw(block_offset+60, &mouseOUTBoffset);
        sas_loadw(block_offset+62, &mouseOUTBsegment);
        sas_loadw(block_offset+64, &mouseOUTWoffset);
        sas_loadw(block_offset+66, &mouseOUTWsegment);
        sas_loadw(block_offset+68, &savedtextoffset);
        sas_loadw(block_offset+70, &savedtextsegment);
        sas_loadw(block_offset+72, &o);
        sas_loadw(block_offset+74, &s);
        sas_loadw(block_offset+76, &button_off);
        sas_loadw(block_offset+78, &button_seg);

#ifdef JAPAN
        sas_loadw(block_offset+84, &off);
        sas_loadw(block_offset+86, &seg);
        saved_ac_sysaddr = effective_addr(seg, off);

        sas_loadw(block_offset+88, &off);
        sas_loadw(block_offset+90, &seg);
        saved_ac_flag_sysaddr = effective_addr(seg, off);
#endif // JAPAN
        mouseCFsysaddr = effective_addr(s,o);
        sas_loadw(block_offset+80, &o);
        sas_loadw(block_offset+82, &s);
        conditional_off_sysaddr = effective_addr(s, o);

#endif /* MONITOR */
        /*
         *      Make sure that old save area does not get re-painted!
         */
        save_area_in_use = FALSE;

        /*
         *      Get rev of MOUSE.COM
         */
        mouse_com_rev = getAL();

        /*
         *      Bus mouse hardware interrupt
         */
#ifdef NTVDM
        sas_loadw (int_addr(0x71) + 0, &saved_int71_offset);
        sas_loadw (int_addr(0x71) + 2, &saved_int71_segment);
        sas_storew(int_addr(0x71), MOUSE_INT1_OFFSET);
        sas_storew(int_addr(0x71) + 2, MOUSE_INT1_SEGMENT);
#else
        sas_loadw (int_addr(MOUSE_VEC) + 0, &saved_int0A_offset);
        sas_loadw (int_addr(MOUSE_VEC) + 2, &saved_int0A_segment);
        sas_storew(int_addr(MOUSE_VEC), MOUSE_INT1_OFFSET);
        sas_storew(int_addr(MOUSE_VEC) + 2, MOUSE_INT1_SEGMENT);

#endif NTVDM

        /*
         *      Enable mouse hardware interrupts in the ica
         */
        inb(ICA1_PORT_1, &interrupt_mask_register);
        interrupt_mask_register &= ~(1 << AT_CPU_MOUSE_INT);
        outb(ICA1_PORT_1, interrupt_mask_register);
        inb(ICA0_PORT_1, &interrupt_mask_register);
        interrupt_mask_register &= ~(1 << CPU_MOUSE_INT);
        outb(ICA0_PORT_1, interrupt_mask_register);

        /*
         *      Mouse io user interrupt
         */

        sas_loadw (int_addr(0x33) + 0, &saved_int33_offset);
        sas_loadw (int_addr(0x33) + 2, &saved_int33_segment);

#ifdef NTVDM
        sas_storew(int_addr(0x33), MOUSE_IO_INTERRUPT_OFFSET);
        sas_storew(int_addr(0x33) + 2, MOUSE_IO_INTERRUPT_SEGMENT);
#else
        /* Read offset of INT 33 procedure from MOUSE.COM */
        sas_loadw(effective_addr(getCS(), OFF_HOOK_POSN), &hook_offset);

        sas_storew(int_addr(0x33), hook_offset);
        sas_storew(int_addr(0x33) + 2, getCS());
#endif /* NTVDM */

#ifdef MOUSE_16_BIT
        /*
         *      Call 16-bit mouse driver initialisation routine
         */
        mouse16bInstall( );
#endif

#if !defined(NTVDM) || (defined(NTVDM) && !defined(X86GFX))
        /*
         *      Mouse video io user interrupt
         */
        sas_loadw (int_addr(0x10) + 0, &saved_int10_offset);
        sas_loadw (int_addr(0x10) + 2, &saved_int10_segment);
        /*
                Determine if the current int10h vector points to
                our roms. If it points elsewhere then the vector has
                been hooked and we must call the current int10h handler
                at the end of mouse_video_io().
        */
        int10_chained = TRUE;
#ifdef EGG
        if(video_adapter == EGA || video_adapter == VGA)
        {
                if ((saved_int10_segment == EGA_SEG) &&
                        (saved_int10_offset == EGA_ENTRY_OFF))
                        int10_chained = FALSE;
        }
        else
#endif
        {
                if ((saved_int10_segment == VIDEO_IO_SEGMENT) &&
                        (saved_int10_offset == VIDEO_IO_OFFSET))
                        int10_chained = FALSE;
        }
#ifndef MOUSE_16_BIT
        sas_storew(int_addr(0x10), MOUSE_VIDEO_IO_OFFSET);
        sas_storew(int_addr(0x10) + 2, MOUSE_VIDEO_IO_SEGMENT);
#else           /* MOUSE_16_BIT */
        sas_storedw(int_addr(0x10), mouseIOData.mouse_video_io );
#endif          /* MOUSE_16_BIT */

#else
        int10_chained = FALSE;          // make it initialized
#endif      /* if NTVDM && !X86GFX */

        /*
         *      Reset mouse hardware and software
         */
        junk1 = MOUSE_RESET;
        mouse_reset(&junk1, &junk2, &junk3, &junk4);

        /*
         *      Display mouse driver identification string
         */
#ifdef NTVDM
        clear_string();
#endif
        sprintf (temp, mouse_id, SPC_Product_Name, mouse_com_rev);
#ifdef NTVDM
        display_string(temp);
#endif

        note_trace0(MOUSE_VERBOSE, "mouse_install1:return()");
}




void mouse_install2()
{
        /*
         *      This function is called from the Mouse Driver program to
         *      print a message saying that an existing mouse driver
         *      program is already installed
         */
        char    temp[128];

        note_trace0(MOUSE_VERBOSE, "mouse_install2:");

        /*
         *      Make sure that old save area does not get re-painted!
         */
        save_area_in_use = FALSE;

        /*
         *      Display mouse driver identification string
         */
#ifdef NTVDM
        clear_string();
#endif
        sprintf (temp, mouse_installed, SPC_Product_Name, mouse_com_rev);
#ifdef NTVDM
        display_string(temp);
#endif

        note_trace0(MOUSE_VERBOSE, "mouse_install2:return()");
}




void mouse_io_interrupt()
{
        /*
         *      This is the entry point for mouse access via the INT 33H
         *      interface. I/O tracing is provided in each mouse function
         */
        word local_AX, local_BX, local_CX, local_DX;

// STREAM_IO codes are disabled on NEC_98.
#ifndef NEC_98
#ifdef NTVDM
    if(stream_io_enabled) {
        disable_stream_io();
    }
#endif /* NTVDM */
#endif // !NEC_98

        /*
         *      Get the parameters
         */
        local_AX = getAX();
        local_BX = getBX();
        local_CX = getCX();
        local_DX = getDX();

#ifndef NEC_98
#ifdef EGG
        jap_mouse = ((sas_hw_at(vd_video_mode) != Currently_emulated_video_mode) && alpha_num_mode());
        if (jap_mouse)
                note_trace0(MOUSE_VERBOSE, "In Japanese mode - will emulate textmouse");
#endif /* EGG */
#endif // !NEC_98

        note_trace4(MOUSE_VERBOSE,
                    "mouse function %d, position is %d,%d, button state is %d",
                    local_AX, cursor_status.position.x,
                    cursor_status.position.y, cursor_status.button_status);

        /*
         *      Do what you have to do
         */
        do_mouse_function(&local_AX, &local_BX, &local_CX, &local_DX);

        /*
         *      Set the parameters
         */
        setAX(local_AX);
        setBX(local_BX);
        setCX(local_CX);
        setDX(local_DX);
}




void mouse_io_language()
{
        /*
         *      This is the entry point for mouse access via a language.
         *      I/O tracing is provided in each mouse function
         */
        word local_SI = getSI(), local_DI = getDI();
        word m1, m2, m3, m4;
        word offset, data;
        sys_addr stack_addr = effective_addr(getSS(), getSP());

        /*
         *      Retrieve parameters from the caller's stack
         */
        sas_loadw(stack_addr+10, &offset);
        sas_loadw(effective_addr(getDS(), offset), &m1);

        sas_loadw(stack_addr+8, &offset);
        sas_loadw(effective_addr(getDS(), offset), &m2);

        sas_loadw(stack_addr+6, &offset);
        sas_loadw(effective_addr(getDS(), offset), &m3);

        switch(m1)
        {
        case MOUSE_SET_GRAPHICS:
        case MOUSE_SET_SUBROUTINE:
                /*
                 *      The fourth parameter is used directly as the offset
                 */
                sas_loadw(stack_addr+4, &m4);
                break;
        case MOUSE_CONDITIONAL_OFF:
                /*
                 *      The fourth parameter addresses a parameter block
                 *      that contains the data
                 */
                sas_loadw(stack_addr+4, &offset);
                sas_loadw(effective_addr(getDS(), offset), &m3);
                sas_loadw(effective_addr(getDS(), offset+2), &m4);
                sas_loadw(effective_addr(getDS(), offset+4), &data);
                setSI(data);
                sas_loadw(effective_addr(getDS(), offset+6), &data);
                setDI(data);
                break;
        default:
                /*
                 *      The fourth parameter addresses the data to be used
                 */
                sas_loadw(stack_addr+4, &offset);
                sas_loadw(effective_addr(getDS(), offset), &m4);
                break;
        }

        /*
         *      Do what you have to do
         */
        do_mouse_function(&m1, &m2, &m3, &m4);

        /*
         *      Store results back on the stack
         */
        sas_loadw(stack_addr+10, &offset);
        sas_storew(effective_addr(getDS(), offset), m1);

        sas_loadw(stack_addr+8, &offset);
        sas_storew(effective_addr(getDS(), offset), m2);

        sas_loadw(stack_addr+6, &offset);
        sas_storew(effective_addr(getDS(), offset), m3);

        sas_loadw(stack_addr+4, &offset);
        sas_storew(effective_addr(getDS(), offset), m4);

        /*
         *      Restore potentially corrupted registers
         */
        setSI(local_SI);
        setDI(local_DI);
}

#ifdef  MOUSE_16_BIT
/*
 *      function        :       mouse16bCheckConditionalOff
 *
 *      purpose         :       Make the 16 bit driver check the conditional
 *                              off area and either draw or hide the pointer
 *                              appropriately. This function is only called
 *                              when the cursor flag is set to
 *                              MOUSE_CURSOR_DISPLAYED.
 *
 *      inputs          :       none
 *      outputs         :       none
 *      returns         :       void
 *      globals         :       cursor_flag is decremented if the pointer has
 *                              to be hidden
 *
 *
 */
LOCAL void mouse16bCheckConditionalOff IFN0()
{
        /* If the mouse has moved into the conditional
        ** off area (the black hole) then the mouse
        ** must be hidden and the cursor flag
        ** decremented, otherwise the mouse is drawn
        ** in its new position.
        */
        if ((cursor_position.x >=
                black_hole.top_left.x) &&
                (cursor_position.x <=
                black_hole.bottom_right.x) &&
                (cursor_position.y >=
                black_hole.top_left.y) &&
                (cursor_position.y <=
                black_hole.bottom_right.y))
        {
                cursor_flag--;
                mouse16bHidePointer();
        }
        else
                mouse16bDrawPointer( &cursor_status );
}
#endif  /* MOUSE_16_BIT */

LOCAL void get_screen_size IFN0()
{
#ifdef HERC
        if (video_adapter == HERCULES){
                if (get_cga_mode() == GRAPHICS){
                        virtual_screen.bottom_right.x = 720;
                        virtual_screen.bottom_right.y = 348;
                }else{
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 348;
                }
                return;
        }
#endif /* HERC */
        switch(current_video_mode)
        {
        /*==================================================================
        ACW 17/3/93 Some code added to return a different virtual
        coordinate size for the screen if text mode is used NOT in 25 line
        mode. This really emulates the Microsoft Mouse Driver.
        Note: There are 8 x 8 virtual pixels in any character cell.
        ==================================================================*/
                case 0x2:
                case 0x3:
                case 0x7:
                   {
                   half_word no_of_lines;

                   sas_load(0x484, &no_of_lines); /* do a look up in BIOS */
                   no_of_lines &= 0xff;           /* clean up */
                   switch(no_of_lines)
                      {
                      case 24:
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 200;
                      break;
                      case 42:
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 344;
                      break;
                      case 49:
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 400;
                      break;
                      }
                   }
                break;
        /*==================================================================
        End of ACW code
        ==================================================================*/
                case 0xf:
                case 0x10:
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 350;
                        break;
                case 0x40:
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 344;
                        break;
                case 0x41:
                        virtual_screen.bottom_right.x = 1056;
                        virtual_screen.bottom_right.y = 350;
                        break;
                case 0x42:
                        virtual_screen.bottom_right.x = 1056;
                        virtual_screen.bottom_right.y = 344;
                        break;
                case 0x45:
                        virtual_screen.bottom_right.x = 1056;
                        virtual_screen.bottom_right.y = 392;
                        break;
                case 0x66:
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 400;
                        break;
                case 0x11:
                case 0x12:
                case 0x43:
                case 0x67:
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 480;
                        break;
                case 0x44:
                        virtual_screen.bottom_right.x = 800;
                        virtual_screen.bottom_right.y = 480;
                        break;
                case 0x60:
                        virtual_screen.bottom_right.x = 752;
                        virtual_screen.bottom_right.y = 410;
                        break;
                case 0x61:
                case 0x68:
                        virtual_screen.bottom_right.x = 720;
                        virtual_screen.bottom_right.y = 540;
                        break;
                case 0x62:
                case 0x69:
                        virtual_screen.bottom_right.x = 800;
                        virtual_screen.bottom_right.y = 600;
                        break;
                case 0x63:
                case 0x64:
                case 0x65:
                        virtual_screen.bottom_right.x = 1024;
                        virtual_screen.bottom_right.y = 768;
                        break;
                default:
                        virtual_screen.bottom_right.x = 640;
                        virtual_screen.bottom_right.y = 200;
                        break;
        }
}



#ifdef EGG

/*
 * Utility routine to restore EGA defaults to the saved values.
 * If to_hw == TRUE, the restored values are also sent to the EGA.
 */


LOCAL boolean dirty_crtc[EGA_PARMS_CRTC_SIZE], dirty_seq[EGA_PARMS_SEQ_SIZE],
        dirty_graph[EGA_PARMS_GRAPH_SIZE], dirty_attr[EGA_PARMS_ATTR_SIZE];

LOCAL void clean_all_regs()
{
        int i;

        for(i=0;i<EGA_PARMS_CRTC_SIZE;i++)
                dirty_crtc[i] = 0;
        for(i=0;i<EGA_PARMS_SEQ_SIZE;i++)
                dirty_seq[i] = 0;
        for(i=0;i<EGA_PARMS_GRAPH_SIZE;i++)
                dirty_graph[i] = 0;
        for(i=0;i<EGA_PARMS_ATTR_SIZE;i++)
                dirty_attr[i] = 0;
}

LOCAL void dirty_all_regs()
{
        int i;

        for(i=0;i<EGA_PARMS_CRTC_SIZE;i++)
                dirty_crtc[i] = 1;
        for(i=0;i<EGA_PARMS_SEQ_SIZE;i++)
                dirty_seq[i] = 1;
        for(i=0;i<EGA_PARMS_GRAPH_SIZE;i++)
                dirty_graph[i] = 1;
        for(i=0;i<EGA_PARMS_ATTR_SIZE;i++)
                dirty_attr[i] = 1;
}

#if defined(NTVDM) && defined(MONITOR)

#define inb(a,b) doINB(a,b)
#undef  OUTB
#define OUTB(a,b) doOUTB(a,b)
#define outw(a,b) doOUTW(a,b)

static void doINB IFN2(word, port, byte, *value)
{
word savedIP=getIP(), savedCS=getCS();
word savedAX=getAX(), savedDX=getDX();

setDX(port);
setCS(mouseINBsegment);
setIP(mouseINBoffset);
host_simulate();
setCS(savedCS);
setIP(savedIP);
*value=getAL();
setAX(savedAX);
setDX(savedDX);
}

static void doOUTB IFN2(word, port, byte, value)
{
word savedIP=getIP(), savedCS=getCS();
word savedAX=getAX(), savedDX=getDX();

setDX(port);
setAL(value);
setCS(mouseOUTBsegment);
setIP(mouseOUTBoffset);
host_simulate();
setCS(savedCS);
setIP(savedIP);
setAX(savedAX);
setDX(savedDX);
}

static void doOUTW IFN2(word, port, word, value)
{
word savedIP=getIP(), savedCS=getCS();
word savedAX=getAX(), savedDX=getDX();

setDX(port);
setAX(value);
setCS(mouseOUTWsegment);
setIP(mouseOUTWoffset);
host_simulate();
setCS(savedCS);
setIP(savedIP);
setAX(savedAX);
setDX(savedDX);
}

#endif /* NTVDM && MONITOR */

LOCAL void restore_ega_defaults(to_hw)
boolean to_hw;
{
#ifndef NEC_98
        IU8 i;
        half_word temp_word;

        sas_loads(ega_default_crtc,ega_current_crtc,EGA_PARMS_CRTC_SIZE);
        sas_loads(ega_default_seq,ega_current_seq,EGA_PARMS_SEQ_SIZE);
        sas_loads(ega_default_graph,ega_current_graph,EGA_PARMS_GRAPH_SIZE);
        sas_loads(ega_default_attr,ega_current_attr,EGA_PARMS_ATTR_SIZE);

        ega_current_misc = sas_hw_at_no_check(ega_default_misc);

        if(to_hw)
        {
                /* setup Sequencer */

                OUTB( EGA_SEQ_INDEX, 0x0 );
                OUTB( EGA_SEQ_INDEX + 1, 0x1 );

                for(i=0;i<EGA_PARMS_SEQ_SIZE;i++)
                {
                        if (dirty_seq[i])
                                {
                                OUTB( EGA_SEQ_INDEX,(IU8)(i+1));
                                OUTB( EGA_SEQ_INDEX + 1, sas_hw_at_no_check( ega_default_seq + i ));
                                }
                }

                OUTB( EGA_SEQ_INDEX, 0x0 );
                OUTB( EGA_SEQ_INDEX + 1, 0x3 );

                /* setup Miscellaneous register */

                OUTB( EGA_MISC_REG, sas_hw_at_no_check( ega_default_misc ));

                /* setup CRTC */

                for(i=0;i<EGA_PARMS_CRTC_SIZE;i++)
                {
                        if (dirty_crtc[i])
                                {
                                OUTB(EGA_CRTC_INDEX,(half_word)i);
                                OUTB( EGA_CRTC_INDEX + 1, sas_hw_at_no_check( ega_default_crtc + i ));
                                }
                }

                /* setup attribute chip - NB need to do an inb() to clear the address */

                inb(EGA_IPSTAT1_REG,&temp_word);

                for(i=0;i<EGA_PARMS_ATTR_SIZE;i++)
                {
                        if (dirty_attr[i])
                        {
                                OUTB( EGA_AC_INDEX_DATA, i );
                                OUTB( EGA_AC_INDEX_DATA, sas_hw_at_no_check( ega_default_attr + i ));
                        }
                }

                /* setup graphics chips */

                for(i=0;i<EGA_PARMS_GRAPH_SIZE;i++)
                {
                        if (dirty_graph[i])
                        {
                                OUTB( EGA_GC_INDEX, i );
                                OUTB( EGA_GC_INDEX + 1, sas_hw_at_no_check( ega_default_graph + i ));
                        }
                }

                OUTB( EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE );  /* re-enable video */
                clean_all_regs();
        }
#endif    //NEC_98
}



void LOCAL mouse_adjust_screen_size()
   {
   /* Alter mouse variables which depend on mode */
   IS32 old_depth = virtual_screen.bottom_right.y;
   IS32 old_width = virtual_screen.bottom_right.x;

   /*
      Height & width of screen in pixels is variable with EGA/(V7)VGA.

      Theoretically, punters can invent their own modes which would
      confuse the issue. However most of SoftPC seems to rely on people
      using standard BIOS modes only, with standard screen heights &
      widths.
    */

   get_screen_size();

   /* Reinitialise things that depend on screen height & width. */

   cursor_position_default.x = virtual_screen.bottom_right.x / 2;
   cursor_position_default.y = virtual_screen.bottom_right.y / 2;

   cursor_position.x = (MOUSE_SCALAR)(((IS32)cursor_position.x *
          (IS32)virtual_screen.bottom_right.x) / old_width);
   cursor_position.y = (MOUSE_SCALAR)(((IS32)cursor_position.y *
          (IS32)virtual_screen.bottom_right.y) / old_depth);

   black_hole.top_left.x = -virtual_screen.bottom_right.x;
   black_hole.top_left.y = -virtual_screen.bottom_right.y;

   black_hole_default.top_left.x = -virtual_screen.bottom_right.x;
   black_hole_default.top_left.y = -virtual_screen.bottom_right.y;

   black_hole.bottom_right.x = -virtual_screen.bottom_right.x;
   black_hole.bottom_right.y = -virtual_screen.bottom_right.y;

   black_hole_default.bottom_right.x = -virtual_screen.bottom_right.x;
   black_hole_default.bottom_right.y = -virtual_screen.bottom_right.y;
   }

#if defined(NTVDM) && !defined(X86GFX)
GLOBAL void mouse_video_mode_changed(int new_mode)
{
    IMPORT word VirtualX, VirtualY;

    current_video_mode = new_mode & 0x7F;
    mouse_ega_mode(current_video_mode);
    VirtualX = virtual_screen.bottom_right.x;
    VirtualY = virtual_screen.bottom_right.y;
}
#endif

void GLOBAL mouse_ega_mode(curr_video_mode)
int curr_video_mode;
{
        sys_addr parms_addr; /* Address of EGA register table for video mode */
        sys_addr temp_word;     /* Bit of storage to pass to inb() */

        UNUSED(curr_video_mode);

        mouse_adjust_screen_size();

        if(video_adapter == EGA || video_adapter == VGA)
        {
#ifdef NTVDM
        parms_addr = find_mode_table(current_video_mode,&temp_word);
#else
#ifdef V7VGA            /* suret */
                if( (getAH()) == 0x6F )
                        parms_addr = find_mode_table(getBL(),&temp_word);
                else
                        parms_addr = find_mode_table(getAL(),&temp_word);
#else
                parms_addr = find_mode_table(getAL(),&temp_word);
#endif
#endif /* NTVDM */
                ega_default_crtc = parms_addr + EGA_PARMS_CRTC;
                ega_default_seq = parms_addr + EGA_PARMS_SEQ;
                ega_default_graph = parms_addr + EGA_PARMS_GRAPH;
                ega_default_attr = parms_addr + EGA_PARMS_ATTR;
                ega_default_misc = parms_addr + EGA_PARMS_MISC;
                restore_ega_defaults(FALSE);    /* Load up current tables, but don't write to EGA!! */
        }
#if defined(NTVDM) && defined(MONITOR)
    sas_store(conditional_off_sysaddr, 0);
#endif

}
#endif

#if defined(NTVDM) && defined(MONITOR)
extern void host_call_bios_mode_change();
#endif

extern void host_check_mouse_buffer(void);

void mouse_video_io()
{
#ifndef NEC_98
        /*
         *      This is the entry point for video accesses via the INT 10H
         *      interface
         */
#ifdef EGG
        half_word temp_word;    /* Bit of storage to pass to inb() */
#endif /* EGG */
        IS32 mouse_video_function = getAH();

        /*
         * Switch to full screen to handle VESA video functions
         *
         */
        if (mouse_video_function == 0x4f) {

            /*
            ** Since host does not support VESA bios emulation, we will let
            ** PC's video bios to handle the vesa int10 call.
            ** For Microsoft NT this is a transition to full-screen ie. the
            ** real PC's video BIOS and graphics board.
            **
            ** After it rturns, host has done the screen switch for us.
            ** We will return to soft int10 handler to invoke the PC's BIOS
            ** vesa function.
            */
            {
                    extern VOID SwitchToFullScreen IPT1(BOOL, Restore);

                    SwitchToFullScreen(TRUE);
                    return;
            }
        }
#ifdef V7VGA
        if (mouse_video_function == MOUSE_VIDEO_SET_MODE || getAX() == MOUSE_V7_VIDEO_SET_MODE)
#else
        if (mouse_video_function == MOUSE_VIDEO_SET_MODE)
#endif /* V7VGA */
        {
                note_trace1(MOUSE_VERBOSE, "mouse_video_io:set_mode(%d)",
                            getAL());


                current_video_mode = getAL() & 0x7f;
#ifdef JAPAN
                if (!is_us_mode() && (current_video_mode == 0x72 || current_video_mode == 0x73)) {
                    /* validate video mode, for Lotus 1-2-3 R2.5J  now temporary fix */
                }
                else {
#endif // JAPAN
#ifdef V7VGA
                if (mouse_video_function == 0x6f)
                        current_video_mode = getBL() & 0x7f;
                else if (current_video_mode > 0x13)
                        current_video_mode += 0x4c;

                if (is_bad_vid_mode(current_video_mode) && !is_v7vga_mode(current_video_mode))
#else
                if (is_bad_vid_mode(current_video_mode))
#endif /* V7VGA */
                {
                        always_trace1("Bad video mode - %d.\n", current_video_mode);
#ifdef V7VGA
                        if (mouse_video_function == 0x6f)
                                setAH( 0x02 );       /* suret */
#endif /* V7VGA */
                        return;
                }

#ifdef JAPAN
                }
#endif // JAPAN
#ifdef EGG
                mouse_ega_mode(current_video_mode);
                dirty_all_regs();
#endif
                /*
                 *      Remove the old cursor from the screen, and hide
                 *      the cursor
                 */
                cursor_undisplay();

                cursor_flag = MOUSE_CURSOR_DEFAULT;

#if defined(NTVDM) && defined(MONITOR)
        sas_store(mouseCFsysaddr,(half_word)MOUSE_CURSOR_DEFAULT);
#endif
                /*
                 *      Deal with the mode change
                 */
                cursor_mode_change(current_video_mode);

#if defined(NTVDM) && defined(MONITOR)
        host_call_bios_mode_change();
#endif

#ifdef  MOUSE_16_BIT
                /* Remember whether in text or graphics mode for
                ** later use.
                */
                is_graphics_mode = ((current_video_mode > 3) &&
                        (current_video_mode != 7));
#endif  /* MOUSE_16_BIT */

                note_trace0(MOUSE_VERBOSE, "mouse_video_io:return()");
        }
        else if (    (mouse_video_function == MOUSE_VIDEO_READ_LIGHT_PEN)
                  && light_pen_mode)
        {
                note_trace0(MOUSE_VERBOSE, "mouse_video_io:read_light_pen()");

                /*
                 *      Set text row and column of "light pen" position
                 */
                setDL((UCHAR)(cursor_status.position.x/text_grid.x));
                setDH((UCHAR)(cursor_status.position.y/text_grid.y));

                /*
                 *      Set pixel column and raster line of "light pen"
                 *      position
                 */
                setBX((UCHAR)(cursor_status.position.x/cursor_grid.x));
                if (sas_hw_at(vd_video_mode)>= 0x04 && sas_hw_at(vd_video_mode)<=0x06){
                        setCH((UCHAR)(cursor_status.position.y));
                }else if (sas_hw_at(vd_video_mode)>= 0x0D && sas_hw_at(vd_video_mode)<=0x13){
                        setCX(cursor_status.position.y);
                }

                /*
                 *      Set the button status
                 */
                setAH((UCHAR)(cursor_status.button_status));

                note_trace5(MOUSE_VERBOSE,
                            "mouse_video_io:return(st=%d,ca=[%d,%d],pa=[%d,%d])",
                            getAH(), getDL(), getDH(), getBX(), cursor_status.position.y);
                return;
        }
#if defined(NTVDM) && defined(MONITOR)
    else if (mouse_video_function == MOUSE_VIDEO_LOAD_FONT)
    {
                note_trace0(MOUSE_VERBOSE, "mouse_video_io:load_font()");

        /*
         * Call the host to tell it to adjust the mouse buffer selected
         * if the number of lines on the screen have changed.
         */
        host_check_mouse_buffer();
    }
#endif /* NTVDM && MONITOR */

        /*
         *      Now do the standard video io processing
         */
        switch (mouse_video_function)
        {
#ifdef EGG
                /* Fancy stuff to access EGA registers */
                case 0xf0:      /* Read a register */
                        switch (getDX())
                        {
                                        case 0:
                                                        setBL(ega_current_crtc[getBL()]);
                                                        break;
                                        case 8:
                                                        setBL(ega_current_seq[getBL()-1]);
                                                        break;
                                        case 0x10:
                                                        setBL(ega_current_graph[getBL()]);
                                                        break;
                                        case 0x18:
                                                        setBL(ega_current_attr[getBL()]);
                                                        break;
                                        case 0x20:
                                                        setBL(ega_current_misc);
                                                        break;
                                        case 0x28:
                                                        break;
                        /* Graphics Position registers not supported. */
                                        case 0x30:
                                        case 0x38:
                                        default:
                                                        break;
                        }
                        break;
                case 0xf1:      /* Write a register */
                        switch (getDX())
                        {
                                        case 0:
                                                        outw( EGA_CRTC_INDEX, getBX() );
                                                        ega_current_crtc[getBL()] = getBH();
                                                        dirty_crtc[getBL()] = 1;
                                                        break;
                                        case 8:
                                                        outw( EGA_SEQ_INDEX, getBX() );
                                                        if(getBL()>0)
                                                        {
                                                                ega_current_seq[getBL()-1] = getBH();
                                                                dirty_seq[getBL()-1] = 1;
                                                        }
                                                        break;
                                        case 0x10:
                                                        outw( EGA_GC_INDEX, getBX() );
                                                        ega_current_graph[getBL()] = getBH();
                                                        dirty_graph[getBL()] = 1;
                                                        break;
                                        case 0x18:
                                                        inb(EGA_IPSTAT1_REG,&temp_word);        /* Clear attrib. index */

                                                        /* outw( EGA_AC_INDEX_DATA, getBX() );  this is not correct (andyw BCN 1692) */

/*=============================================================================
The attribute controller index register and data register associated
with that index are accessed through the same I/O  port = 03C0h.
The correct procedure is to map the index register to 03C0h by doing
the INB as above. Then OUTB the index of the A.C. register required.
The VGA hardware then maps in the correct data register to which
the application OUTBs the necessary data.
=============================================================================*/
                                                        OUTB( EGA_AC_INDEX_DATA, getBL() ); /* BL contains the index value */
                                                        OUTB( EGA_AC_INDEX_DATA, getBH() ); /* BH contains the data */

/*=== End of BCN 1692 ===*/
                                                        OUTB( EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE );  /* re-enable video */
                                                        ega_current_attr[getBL()] = getBH();
                                                        dirty_attr[getBL()] = 1;
                                                        break;
                                        case 0x20:
                                                        OUTB( EGA_MISC_REG, getBL() );
                                                        ega_current_misc = getBL();
                                                        break;
                                        case 0x28:
                                                        OUTB( EGA_FEAT_REG, getBL() );
                                                        break;
                        /* Graphics Position registers not supported. */
                                        case 0x30:
                                        case 0x38:
                                        default:
                                                        break;
                        }
                        break;
                case 0xf2:      /* read range */
                        switch (getDX())
                        {
                                case 0:
                                        sas_stores(effective_addr(getES(),getBX()),&ega_current_crtc[getCH()],getCL());
                                        break;
                                case 8:
                                        sas_stores(effective_addr(getES(),getBX()),&ega_current_seq[getCH()-1],getCL());
                                        break;
                                case 0x10:
                                        sas_stores(effective_addr(getES(),getBX()),&ega_current_graph[getCH()],getCL());
                                        break;
                                case 0x18:
                                        sas_stores(effective_addr(getES(),getBX()),&ega_current_attr[getCH()],getCL());
                                        break;
                                default:
                                        break;
                        }
                        break;
                case 0xf3:      /* write range */
                {
                        UCHAR first = getCH(), last = getCH()+getCL();
                        sys_addr sauce = effective_addr(getES(),getBX());
                        switch (getDX())
                        {
                                case 0:
                                        sas_loads(sauce,&ega_current_crtc[getCH()],getCL());
                                        for(;first<last;first++)
                                        {
                                                dirty_crtc[first] = 1;
                                                outw(EGA_CRTC_INDEX,(WORD)(first+(sas_hw_at(sauce++) << 8)));
                                        }
                                        break;
                                case 8:
                                        sas_loads(sauce,&ega_current_seq[getCH()-1],getCL());
                                        for(;first<last;first++)
                                        {
                                                dirty_seq[first+1] = 1;
                                                outw(EGA_SEQ_INDEX,(WORD)(first+1+(sas_hw_at(sauce++) << 8)));
                                        }
                                        break;
                                case 0x10:
                                        sas_loads(sauce,&ega_current_graph[getCH()],getCL());
                                        for(;first<last;first++)
                                        {
                                                dirty_graph[first] = 1;
                                                outw(EGA_GC_INDEX,(WORD)(first+(sas_hw_at(sauce++) << 8)));
                                        }
                                        break;
                                case 0x18:
                                        sas_loads(sauce,&ega_current_attr[getCH()],getCL());
                                        inb(EGA_IPSTAT1_REG,&temp_word);        /* Clear attrib. index */
                                        for(;first<last;first++)
                                        {
                                                dirty_attr[first] = 1;

                                                /* Using 'secret' that attrib. chip responds to it's port+1 */
#ifndef NTVDM
                                                outw(EGA_AC_INDEX_DATA,first+(sas_hw_at(sauce++) << 8));
#else
                        OUTB(EGA_AC_INDEX_DATA,first);
                        OUTB(EGA_AC_INDEX_DATA,sas_hw_at(sauce++));
#endif /* !NTVDM */
                                        }
#ifndef NTVDM
                                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);    /* re-enable video */
#else
                                        OUTB(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);    /* re-enable video */
#endif /* NTVDM */
                                        break;
                                default:
                                        break;
                        }
                }
                break;
                case 0xf4:      /* read set */
                {
                        int i =  getCX();
                        sys_addr set_def = effective_addr(getES(),getBX());
                        while(i--)
                        {
                                switch (sas_hw_at(set_def))
                                {
                                        case 0:
                                                        sas_store((set_def+3), ega_current_crtc[sas_hw_at(set_def+2)]);
                                                        break;
                                        case 8:
                                                        sas_store((set_def+3), ega_current_seq[sas_hw_at(set_def+2)-1]);
                                                        break;
                                        case 0x10:
                                                        sas_store((set_def+3), ega_current_graph[sas_hw_at(set_def+2)]);
                                                        break;
                                        case 0x18:
                                                        sas_store((set_def+3), ega_current_attr[sas_hw_at(set_def+2)]);
                                                        break;
                                        case 0x20:
                                                        sas_store((set_def+3), ega_current_misc);
                                                        setBL(ega_current_misc);
                                                        break;
                                        case 0x28:
                        /* Graphics Position registers not supported. */
                                        case 0x30:
                                        case 0x38:
                                        default:
                                                        break;
                                }
                                set_def += 4;
                        }
                }
                break;
                case 0xf5:      /* write set */
                {
                        int i =  getCX();
                        sys_addr set_def = effective_addr(getES(),getBX());
                        while(i--)
                        {
                                switch (sas_hw_at(set_def))
                                {
                                        case 0:
                                                        outw(EGA_CRTC_INDEX,(WORD)(sas_hw_at(set_def+2)+(sas_hw_at(set_def+3)<<8)));
                                                        ega_current_crtc[sas_hw_at(set_def+2)] = sas_hw_at(set_def+3);
                                                        dirty_crtc[sas_hw_at(set_def+2)] = 1;
                                                        break;
                                        case 8:
                                                        outw(EGA_SEQ_INDEX,(WORD)(sas_hw_at(set_def+2)+(sas_hw_at(set_def+3)<<8)));
                                                        if(sas_hw_at(set_def+2))
                                                                ega_current_seq[sas_hw_at(set_def+2)-1] = sas_hw_at(set_def+3);
                                                        dirty_seq[sas_hw_at(set_def+2)-1] = 1;
                                                        break;
                                        case 0x10:
                                                        outw(EGA_GC_INDEX,(WORD)(sas_hw_at(set_def+2)+(sas_hw_at(set_def+3)<<8)));
                                                        ega_current_graph[sas_hw_at(set_def+2)] = sas_hw_at(set_def+3);
                                                        dirty_graph[sas_hw_at(set_def+2)] = 1;
                                                        break;
                                        case 0x18:
                                                        inb(EGA_IPSTAT1_REG,&temp_word);        /* Clear attrib. index */
#ifndef NTVDM
                                                        outw(EGA_AC_INDEX_DATA,sas_hw_at(set_def+2)+(sas_hw_at(set_def+3)<<8)); /* Using 'secret' that attrib. chip responds to it's port+1 */
                                                        outb(EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE);    /* re-enable video */
#else

                            OUTB( EGA_AC_INDEX_DATA,sas_hw_at(set_def+2));
                            OUTB( EGA_AC_INDEX_DATA,sas_hw_at(set_def+3));
                            OUTB( EGA_AC_INDEX_DATA, EGA_PALETTE_ENABLE );  /* re-enable video */
#endif /* !NTVDM */
                                                        ega_current_attr[sas_hw_at(set_def+2)] = sas_hw_at(set_def+3);
                                                        dirty_attr[sas_hw_at(set_def+2)] = 1;
                                                        break;
                                        case 0x20:
                                                        outb(EGA_MISC_REG,sas_hw_at(set_def+2));
                                                        ega_current_misc = sas_hw_at(set_def+2);
                                                        break;
                                        case 0x28:
                                                        outb(EGA_FEAT_REG,sas_hw_at(set_def+2));
                                                        break;
                                /* Graphics Position registers not supported. */
                                        case 0x30:
                                        case 0x38:
                                        default:
                                                        break;
                                }
                                set_def += 4;
                        }
                }
                break;
                case 0xf6:
                        restore_ega_defaults(TRUE);
                        break;
                case 0xf7:
                        dirty_all_regs();
                        switch (getDX())
                        {
                                        case 0:
                                                        ega_default_crtc = effective_addr(getES(),getBX());
                                                        break;
                                        case 8:
                                                        ega_default_seq = effective_addr(getES(),getBX());
                                                        break;
                                        case 0x10:
                                                        ega_default_graph = effective_addr(getES(),getBX());
                                                        break;
                                        case 0x18:
                                                        ega_default_attr = effective_addr(getES(),getBX());
                                                        break;
                                        case 0x20:
                                                        ega_default_misc = effective_addr(getES(),getBX());
                                                        break;
                                        case 0x28: /* Feature Reg not reallt supported */
                                                        break;
                        /* Graphics Position registers not supported. */
                                        case 0x30:
                                        case 0x38:
                                        default:
                                                        break;
                        }
                        break;
#endif
                case 0xfa:
/*
 * MS word on an EGA uses this call and needs BX != 0 to make its cursor work. Real MS mouse driver returns a pointer in ES:BX
 * aimed at several bytes of unknown significance followed by a "This is Copyright 1984 Microsoft" message, which we don't have.
 * This seems to work with MS word and MS Windows, presumably non MS applications wouldn't use it as it's not documented.
 *
 * We now have a wonderful document - "The Microsoft Mouse Driver", which tells us that ES:BX should
 * point to the EGA Register Interface version number (2 bytes).
 * If BX=0 this means "no mouse driver". So returning 1 seems OK for now. WJG.
 */
                        setBX(1);
                        break;
                case 0x11:
                /*
                 * If we are issuing a TEXT MODE CHARACTER GENERATOR then this will
                 * cause a mode set. Therefore we need to recalc the screen
                 * parameters subsequently as the screen size may differ!!
                 * this occurred in DOSSHELL.
                 */
#if !defined(NTVDM) || !defined(MONITOR)
#ifdef EGG
                        if (video_adapter == EGA || video_adapter == VGA)
                        {
#ifdef GISP_SVGA
                                if( hostIsFullScreen( ) )
#endif          /* GISP_SVGA */
                                ega_video_io();
                                if (!(getAL() & 0x20))
                                        mouse_ega_mode(current_video_mode); /* only for text */
                        }
                        else
#endif
#ifdef GISP_SVGA
                                if( hostIsFullScreen( ) )
#endif          /* GISP_SVGA */
                                video_io();
#endif /* !NTVDM && !MONITOR */
                        break;

                default:
#ifndef X86GFX
                        /* Does the previous int10h vector point to our roms ? */
                        if (int10_chained == FALSE)
                        {
                                /* Yes - call our video handler */
#ifndef GISP_SVGA
#ifdef EGG
                        if (video_adapter == EGA || video_adapter == VGA)
#ifdef GISP_SVGA
                                if( hostIsFullScreen( ) )
#endif          /* GISP_SVGA */
                                ega_video_io();
                        else
#endif
#ifdef GISP_SVGA
                                if( hostIsFullScreen( ) )
#endif          /* GISP_SVGA */
                                video_io();
#else /* GISP_SVGA */
                                /* Video bios chain done from 16 bit */
                                /* NULL */;
#endif /* GISP_SVGA */
        }
                        else
                        {
                                /* No - chain the previous int10h handler       */
                                setCS(saved_int10_segment);
                                setIP(saved_int10_offset);
                        }
#else
                        break;
#endif  /* !X86GFX */
        }
#ifdef GISP_SVGA
        setCF( 1 );
#endif /* GISP_SVGA */

#endif    //NEC_98
}

#if defined(NTVDM) && defined(MONITOR)
#undef inb
#undef OUTB
#undef outw
#endif /* NTVDM && MONITOR */

void mouse_EM_callback()
   {
   note_trace1(MOUSE_VERBOSE,
      "Enhanced Mode Mouse-Support Callback Function(%x).", getAX());

   /* Windows Enhanced Mode Mouse-Support Callback */
   switch ( getAX() )
      {
   case 0x1:   /* Mouse move/Button click */
      mouse_EM_move();
      break;

   case 0x2:   /* Disable Mouse Cursor Drawing */
      if ( cursor_flag == MOUSE_CURSOR_DISPLAYED )
         cursor_undisplay();
      cursor_EM_disabled = TRUE;
      break;

   case 0x3:   /* Enable Mouse Cursor Drawing */
      cursor_EM_disabled = FALSE;
      if ( cursor_flag == MOUSE_CURSOR_DISPLAYED )
         cursor_display();
      break;

   default:    /* Unknown == Unsupported */
      break;
      }
   }

LOCAL void mouse_EM_move()
   {
   MOUSE_CALL_MASK event_mask;
   MOUSE_STATE button_state;
   MOUSE_SCALAR x_pixel;
   MOUSE_SCALAR y_pixel;
   MOUSE_VECTOR mouse_movement;

   /* Pick up parameters. */
   event_mask = getSI();
   button_state = getDX();
   x_pixel = getBX();
   y_pixel = getCX();

   note_trace4(MOUSE_VERBOSE,
      "Extended Interface: event mask(%x) button_state(%x) posn(%d,%d).",
      event_mask, button_state, x_pixel, y_pixel);

   /* Process mouse events. */
   if ( event_mask & MOUSE_CALL_MASK_LEFT_RELEASE_BIT )
      {
      point_copy(&cursor_status.position,
         &button_transitions[MOUSE_LEFT_BUTTON].release_position);
      button_transitions[MOUSE_LEFT_BUTTON].release_count++;
      }

   if ( event_mask & MOUSE_CALL_MASK_LEFT_PRESS_BIT )
      {
      point_copy(&cursor_status.position,
         &button_transitions[MOUSE_LEFT_BUTTON].press_position);
      button_transitions[MOUSE_LEFT_BUTTON].press_count++;
      }

   if ( event_mask & MOUSE_CALL_MASK_RIGHT_RELEASE_BIT )
      {
      point_copy(&cursor_status.position,
         &button_transitions[MOUSE_RIGHT_BUTTON].release_position);
      button_transitions[MOUSE_RIGHT_BUTTON].release_count++;
      }

   if ( event_mask & MOUSE_CALL_MASK_RIGHT_PRESS_BIT )
      {
      point_copy(&cursor_status.position,
         &button_transitions[MOUSE_RIGHT_BUTTON].press_position);
      button_transitions[MOUSE_RIGHT_BUTTON].press_count++;
      }

   cursor_status.button_status = button_state;

   /* Process any mouse movement. */
   if ( event_mask & MOUSE_CALL_MASK_POSITION_BIT )
      {
      /* Calculate mickeys moved. */
      point_set(&mouse_movement, x_pixel, y_pixel);
      vector_multiply_by_vector(&mouse_movement, &mouse_gear);

      /* Update micky count. */
      point_translate(&mouse_motion, &mouse_movement);

      /* Set up point in pixels, again. */
      point_set(&mouse_movement, x_pixel, y_pixel);

      /* Update raw pixel position, and go grid it. */
        cursor_position.x = x_pixel;
        cursor_position.y = y_pixel;
      cursor_update();
      }

   /* Now handle user subroutine and/or display update. */
   mouse_update(event_mask);
   }

void mouse_int1()
{
        /*
         *      The bus mouse hardware interrupt handler
         */
#ifndef NTVDM
        MOUSE_VECTOR mouse_movement;
        MOUSE_INPORT_DATA inport_event;
#else
    MOUSE_VECTOR mouse_counter = { 0, 0 };
#endif
        MOUSE_CALL_MASK condition_mask;


        note_trace0(MOUSE_VERBOSE, "mouse_int1:");

#ifdef NTVDM


//
// Okay, lets forget that the InPort adapter ever existed!
//

cursor_status.button_status = 0;
condition_mask = 0;

//
// Get the mouse motion counters back from the host side of things.
// Note: The real mouse driver returns the mouse motion counter values
// to the application in two possible ways. First, if the app uses
// int 33h function 11, a counter displacement is returned since the
// last call to this function.
// If a user subroutine is installed, the motion counters are given
// to this callback in SI and DI.
//

host_os_mouse_pointer(&cursor_status,&condition_mask,&mouse_counter);

//
// If movement during the last mouse hardware interrupt has been recorded,
// update the mouse motion counters.
//

mouse_motion.x += mouse_counter.x;
mouse_motion.y += mouse_counter.y;

//
// Update the statistics for an int 33h function 5, if one
// should occur.
// Note: The cases can't be mixed, since only one can occur
// per hardware interrupt - after all each press or release
// causes a hw int.
//

switch(condition_mask & 0x1e) // look at bits 1,2,3 and 4.
   {
   case 0x2: //left button pressed
      {
      point_copy(&cursor_status.position,
         &button_transitions[MOUSE_LEFT_BUTTON].press_position);
      button_transitions[MOUSE_LEFT_BUTTON].press_count++;
      }
   break;
   case 0x4: //left button released
      {
      point_copy(&cursor_status.position,
         &button_transitions[MOUSE_LEFT_BUTTON].release_position);
      button_transitions[MOUSE_LEFT_BUTTON].release_count++;
      }
   break;
   case 0x8: //right button pressed
      {
      point_copy(&cursor_status.position,
         &button_transitions[MOUSE_RIGHT_BUTTON].press_position);
      button_transitions[MOUSE_RIGHT_BUTTON].press_count++;
      }
   break;
   case 0x10: //right button released
      {
      point_copy(&cursor_status.position,
         &button_transitions[MOUSE_RIGHT_BUTTON].release_position);
      button_transitions[MOUSE_RIGHT_BUTTON].release_count++;
      }
   break;
   }

/*==================================================================

The old fashioned stuff

==================================================================*/

#else /* use the SoftPC emulation */
        /*
         *      Terminate the mouse hardware interrupt
         */
        outb(ICA0_PORT_0, END_INTERRUPT);

        /*
         *      Get the mouse InPort input event frame
         */
        inport_get_event(&inport_event);

        note_trace3(MOUSE_VERBOSE,
                    "mouse_int1:InPort status=0x%x,data1=%d,data2=%d",
                    inport_event.status,
                    inport_event.data_x, inport_event.data_y);

        /*
         *      Update button status and transition information and fill in
         *      button bits in the event mask
         */
        cursor_status.button_status = 0;
        condition_mask = 0;

        switch(inport_event.status & MOUSE_INPORT_STATUS_B1_TRANSITION_MASK)
        {
        case MOUSE_INPORT_STATUS_B1_RELEASED:
                condition_mask |= MOUSE_CALL_MASK_LEFT_RELEASE_BIT;
                point_copy(&cursor_status.position,
                    &button_transitions[MOUSE_LEFT_BUTTON].release_position);
                button_transitions[MOUSE_LEFT_BUTTON].release_count++;
        case MOUSE_INPORT_STATUS_B1_UP:
                break;

        case MOUSE_INPORT_STATUS_B1_PRESSED:
                condition_mask |= MOUSE_CALL_MASK_LEFT_PRESS_BIT;
                point_copy(&cursor_status.position,
                    &button_transitions[MOUSE_LEFT_BUTTON].press_position);
                button_transitions[MOUSE_LEFT_BUTTON].press_count++;
        case MOUSE_INPORT_STATUS_B1_DOWN:
                cursor_status.button_status |= MOUSE_LEFT_BUTTON_DOWN_BIT;
                break;
        }

        switch(inport_event.status & MOUSE_INPORT_STATUS_B3_TRANSITION_MASK)
        {
        case MOUSE_INPORT_STATUS_B3_RELEASED:
                condition_mask |= MOUSE_CALL_MASK_RIGHT_RELEASE_BIT;
                point_copy(&cursor_status.position,
                    &button_transitions[MOUSE_RIGHT_BUTTON].release_position);
                button_transitions[MOUSE_RIGHT_BUTTON].release_count++;
        case MOUSE_INPORT_STATUS_B3_UP:
                break;

        case MOUSE_INPORT_STATUS_B3_PRESSED:
                condition_mask |= MOUSE_CALL_MASK_RIGHT_PRESS_BIT;
                point_copy(&cursor_status.position,
                    &button_transitions[MOUSE_RIGHT_BUTTON].press_position);
                button_transitions[MOUSE_RIGHT_BUTTON].press_count++;
        case MOUSE_INPORT_STATUS_B3_DOWN:
                cursor_status.button_status |= MOUSE_RIGHT_BUTTON_DOWN_BIT;
                break;
        }

        /*
         *      Update position information and fill in position bit in the
         *      event mask
         */
        if (inport_event.data_x != 0 || inport_event.data_y != 0)
        {
                condition_mask |= MOUSE_CALL_MASK_POSITION_BIT;

                        point_set(&mouse_movement,
                                        inport_event.data_x, inport_event.data_y);

                        point_translate(&mouse_raw_motion, &mouse_movement);

                        /*
                         *      Adjust for sensitivity
                         */
                        mouse_movement.x = (MOUSE_SCALAR)(((IS32)mouse_movement.x * (IS32)mouse_sens_val.x) / MOUSE_SENS_MULT);
                        mouse_movement.y = (MOUSE_SCALAR)(((IS32)mouse_movement.y * (IS32)mouse_sens_val.y) / MOUSE_SENS_MULT);

                        /*
                         * NB. !!!
                         * We ought to apply the acceleration curve here
                         * and not the double speed set up. However mouse
                         * interrupts and mouse display are probably not
                         * fast enough anyway to make it worth while adding
                         * the acceleration fine tuning.
                         */

                        /*
                         *      Do speed doubling
                         */
                        if (    (scalar_absolute(mouse_movement.x) > double_speed_threshold)
                             || (scalar_absolute(mouse_movement.y) > double_speed_threshold))
                                vector_scale(&mouse_movement, MOUSE_DOUBLE_SPEED_SCALE);

                        /*
                         *      Update the user mouse motion counters
                         */
                        point_translate(&mouse_motion, &mouse_movement);

                        /*
                         *      Convert the movement from a mouse Mickey count vector
                         *      to a virtual screen coordinate vector, using the
                         *      previous remainder and saving the new remainder
                         */
                        vector_scale(&mouse_movement, MOUSE_RATIO_SCALE_FACTOR);
                        point_translate(&mouse_movement, &cursor_fractional_position);
                        point_copy(&mouse_movement, &cursor_fractional_position);
                        vector_divide_by_vector(&mouse_movement, &mouse_gear);
                        vector_mod_by_vector(&cursor_fractional_position, &mouse_gear);

                /*
                 *      Update the absolute cursor position and the windowed
                 *      and gridded screen cursor position
                 */
                point_translate(&cursor_position, &mouse_movement);
                cursor_update();
        }

#endif /* NTVDM*/

        /* OK mouse variables updated - go handle consequences */
        mouse_update(condition_mask);

        note_trace0(MOUSE_VERBOSE, "mouse_int1:return()");
}

LOCAL void mouse_update IFN1(MOUSE_CALL_MASK, condition_mask)
{
        MOUSE_CALL_MASK key_mask;
        boolean alt_found = FALSE;
        int i;

        note_trace4(MOUSE_VERBOSE,
                    "mouse_update():cursor status = (%d,%d), LEFT %s, RIGHT %s",
                    cursor_status.position.x, cursor_status.position.y,
                    mouse_button_description(cursor_status.button_status & MOUSE_LEFT_BUTTON_DOWN_BIT),
                    mouse_button_description(cursor_status.button_status & MOUSE_RIGHT_BUTTON_DOWN_BIT));

        if (alt_user_subroutines_active){
                /* Get current key states in correct form */
                key_mask = ((sas_hw_at(kb_flag) & LR_SHIFT)  ? MOUSE_CALL_MASK_SHIFT_KEY_BIT : 0) |
                           ((sas_hw_at(kb_flag) & CTL_SHIFT) ? MOUSE_CALL_MASK_CTRL_KEY_BIT  : 0) |
                           ((sas_hw_at(kb_flag) & ALT_SHIFT) ? MOUSE_CALL_MASK_ALT_KEY_BIT   : 0);
                for (i=0; !alt_found && i<NUMBER_ALT_SUBROUTINES; i++){
                        alt_found = (alt_user_subroutine_call_mask[i] & MOUSE_CALL_MASK_KEY_BITS) == key_mask;
                }
        }

#ifndef NTVDM

        if (alt_found){
                i--;    /* Adjust for extra inc */
                if (condition_mask & alt_user_subroutine_call_mask[i]){
                        if (!user_subroutine_critical){
                            user_subroutine_critical = TRUE;
                            jump_to_user_subroutine(condition_mask, alt_user_subroutine_segment[i], alt_user_subroutine_offset[i]);
                        }
                        return;
                }
        }else{
                if (condition_mask & user_subroutine_call_mask){
                        if (!user_subroutine_critical){
                                user_subroutine_critical = TRUE;
                                jump_to_user_subroutine(condition_mask, user_subroutine_segment, user_subroutine_offset);
                        }
                        return;
                }
        }

#else   /* NTVDM */


if (alt_found)
   {
   i--; /* Adjust for extra inc */
   if ((condition_mask & alt_user_subroutine_call_mask[i]))
      {
       SuspendMouseInterrupts();
       jump_to_user_subroutine(condition_mask, alt_user_subroutine_segment[i], alt_user_subroutine_offset[i]);
      }
   }
else
   {
   if ((condition_mask & user_subroutine_call_mask))
      {
       SuspendMouseInterrupts();
       jump_to_user_subroutine(condition_mask, user_subroutine_segment, user_subroutine_offset);
      }
   }

outb(ICA1_PORT_0, 0x20 );
outb(ICA0_PORT_0, END_INTERRUPT);
#endif

/*
 * if the OS pointer is NOT being used to supply input,
 * then get SoftPC to draw its own cursor
 */
/*@ACW*/

#ifndef NTVDM
        /*
         *      If the cursor is currently displayed, move it to the new
         *      position
         */
        if (condition_mask & MOUSE_CALL_MASK_POSITION_BIT)
                if (cursor_flag == MOUSE_CURSOR_DISPLAYED)
#ifdef  MOUSE_16_BIT
                        if (is_graphics_mode)
                                mouse16bCheckConditionalOff();
                        else
#endif  /* MOUSE_16_BIT */
                        {
                        cursor_display();
                        }
#endif /*NTVDM*/
}


void mouse_int2()
{
        /*
         *      Part 2 of the mouse hardware interrupt service routine. Control
         *      is passed to this routine when the "user subroutine" that may
         *      be called as part of the interrupt service routine completes
         */

        note_trace0(MOUSE_VERBOSE, "mouse_int2:");

#ifndef NTVDM
        user_subroutine_critical = FALSE;
#endif

        setAX(saved_AX);
        setBX(saved_BX);
        setCX(saved_CX);
        setDX(saved_DX);
        setSI(saved_SI);
        setDI(saved_DI);
        setES(saved_ES);
        setBP(saved_BP);
        setDS(saved_DS);

        /*
         *      If the cursor is currently displayed, move it to the new
         *      position
         */
        if (last_condition_mask & MOUSE_CALL_MASK_POSITION_BIT)
                if (cursor_flag == MOUSE_CURSOR_DISPLAYED)
                {
#ifdef  MOUSE_16_BIT
                        if (is_graphics_mode)
                                mouse16bCheckConditionalOff();
                        else
#endif  /* MOUSE_16_BIT */
                        {
                        cursor_display();
                        }
                }

        /*
         *      Ensure any changes to the screen image are updated immediately
         *      on the real screen, giving a "smooth" mouse response; the flush
         *      must be done here for applications such as GEM which disable
         *      the mouse driver's graphics capabilities in favour of doing
         *      their own graphics in the user subroutine.
         */
        host_flush_screen();

#ifdef NTVDM
    ResumeMouseInterrupts();
#endif

        note_trace0(MOUSE_VERBOSE, "mouse_int2:return()");
}



/*
 *      MOUSE DRIVER LOCAL FUNCTIONS
 *      ============================
 */

LOCAL void do_mouse_function IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This is the mouse function dispatcher
         */
        int function = *m1;

        switch(function)
        {
                /*
                 *      Deal with special undocumented functions
                 */
        case MOUSE_SPECIAL_COPYRIGHT:
                setES(MOUSE_COPYRIGHT_SEGMENT);
                setDI(MOUSE_COPYRIGHT_OFFSET);
                break;
        case MOUSE_SPECIAL_VERSION:
                setES(MOUSE_VERSION_SEGMENT);
                setDI(MOUSE_VERSION_OFFSET);
                break;

                /*
                 *      Deal with special undocumented functions
                 */
        default:
                if (!mouse_function_in_range(function))
                {
                        /*
                         *      Use the unrecognised function
                         */
                        function = MOUSE_UNRECOGNISED;
                }

                (*mouse_function[function])(m1, m2, m3, m4);
                break;
        }
}

LOCAL void mouse_reset IFN4(word *,installed_ptr,word *,nbuttons_ptr,word *,junk3,word *,junk4)
/*
 * *installed_ptr Holds function number on input...
 * Returns installation state.
 */
{
        /*
         *      This function resets the mouse driver, and returns
         *      the installation status of the mouse hardware and software
         */
        boolean soft_reset_only = (*installed_ptr == MOUSE_SOFT_RESET);
        half_word crt_mode;
        int button;

        UNUSED(junk3);
        UNUSED(junk4);

        note_trace1(MOUSE_VERBOSE, "mouse_io:reset(%s)",
                    soft_reset_only ? "SOFT" : "HARD");

        /*
         *      Remove the old cursor from the screen
         */
        cursor_undisplay();

        /*
         *      Set cursor position to the default position, and the button
         *      status to all buttons up
         */
        point_copy(&cursor_position_default, &cursor_position);
        point_set(&cursor_fractional_position, 0, 0);
        cursor_status.button_status = 0;

        if (host_mouse_installed())
                host_mouse_reset();

        /*
         *      Set cursor window to be the whole screen
         */
        area_copy(&virtual_screen, &cursor_window);

        /*
         *      Set cursor flag to default
         */
        cursor_flag = MOUSE_CURSOR_DEFAULT;

#if defined(MONITOR) && defined(NTVDM)
    sas_store(mouseCFsysaddr, MOUSE_CURSOR_DEFAULT);
#endif

        /*
         *      Get current video mode, and update parameters that are
         *      dependent on it
         */
        sas_load(MOUSE_VIDEO_CRT_MODE, &crt_mode);
#if !defined(NTVDM) || (defined(NTVDM) && defined(V7VGA))
        if ((crt_mode == 1) && extensions_controller.foreground_latch_1)
            crt_mode = extensions_controller.foreground_latch_1;
        else if (crt_mode > 0x13)
            crt_mode += 0x4c;
#endif

        cursor_mode_change((int)crt_mode);

        /*
         *      Update dependent cursor status
         */
        cursor_update();

        /*
         *      Set default text cursor type and masks
         */
        text_cursor_type = MOUSE_TEXT_CURSOR_TYPE_DEFAULT;
        software_text_cursor_copy(&software_text_cursor_default,
                                        &software_text_cursor);

        /*
         *      Set default graphics cursor
         */
        graphics_cursor_copy(&graphics_cursor_default, &graphics_cursor);
        copy_default_graphics_cursor();

        /*
         *      Set cursor page to zero
         */
        cursor_page = 0;

        /*
         *      Set light pen emulation mode on
         */
        light_pen_mode = TRUE;

        /*
         *      Set default Mickey to pixel ratios
         */
        point_copy(&mouse_gear_default, &mouse_gear);

        /*
         *      Clear mouse motion counters
         */
        point_set(&mouse_motion, 0, 0);
        point_set(&mouse_raw_motion, 0, 0);

        /* Reset to default acceleration curve */
        active_acceleration_curve = 3;   /* Back to Normal */

        memcpy(&acceleration_curve_data, &default_acceleration_curve,
           sizeof(ACCELERATION_CURVE_DATA));

        next_video_mode = 0;      /* reset video mode enumeration */

        /*
         *      Clear mouse button transition data
         */
        for (button = 0; button < MOUSE_BUTTON_MAXIMUM; button++)
        {
                button_transitions[button].press_position.x = 0;
                button_transitions[button].press_position.y = 0;
                button_transitions[button].release_position.x = 0;
                button_transitions[button].release_position.y = 0;
                button_transitions[button].press_count = 0;
                button_transitions[button].release_count = 0;
        }

        /*
         *      Disable conditional off area
         */
        area_copy(&black_hole_default, &black_hole);

#if defined(MONITOR) && defined(NTVDM)
    sas_store(conditional_off_sysaddr, 0);
#endif

        /*
         *      Set default sensitivity
         */
        vector_set (&mouse_sens,     MOUSE_SENS_DEF,     MOUSE_SENS_DEF);
        vector_set (&mouse_sens_val, MOUSE_SENS_DEF_VAL, MOUSE_SENS_DEF_VAL);
        mouse_double_thresh = MOUSE_DOUBLE_DEF;

        /*
         *      Set double speed threshold to the default
         */
        double_speed_threshold = MOUSE_DOUBLE_SPEED_THRESHOLD_DEFAULT;

        /*
         *      Clear subroutine call mask
         */
        user_subroutine_call_mask = 0;

        /*
         *      Reset the bus mouse hardware
         */
        if (!soft_reset_only){
                inport_reset();
        }

        /*
         *      Set return values
         */
        *installed_ptr = MOUSE_INSTALLED;
        *nbuttons_ptr = 2;

        note_trace2(MOUSE_VERBOSE, "mouse_io:return(ms=%d,nb=%d)",
                    *installed_ptr, *nbuttons_ptr);
}




LOCAL void mouse_show_cursor IFN4(word *,junk1,word *,junk2,word *,junk3,word *,junk4)
{
        /*
         *      This function is used to display the cursor, based on the
         *      state of the internal cursor flag. If the cursor flag is
         *      already MOUSE_CURSOR_DISPLAYED, then this function does
         *      nothing. If the internal cursor flag becomes
         *      MOUSE_CURSOR_DISPLAYED when incremented by 1, the cursor
         *      is revealed
         */

        UNUSED(junk1);
        UNUSED(junk2);
        UNUSED(junk3);
        UNUSED(junk4);

        note_trace0(MOUSE_VERBOSE, "mouse_io:show_cursor()");

#ifndef NTVDM
        /*
         *      Disable conditional off area
         */
        area_copy(&black_hole_default, &black_hole);

        /*
         *      Display the cursor
         */
        if (cursor_flag != MOUSE_CURSOR_DISPLAYED)
                if (++cursor_flag == MOUSE_CURSOR_DISPLAYED)
#ifdef  MOUSE_16_BIT
                        if (is_graphics_mode)
                                mouse16bShowPointer(&cursor_status);
                        else
#endif  /* MOUSE_16_BIT */
                        {
                        cursor_display();
                        }
#endif /* NTVDM */

#if defined(NTVDM) && defined(X86GFX)
    host_show_pointer();
#endif

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




LOCAL void mouse_hide_cursor IFN4(word *,junk1,word *,junk2,word *,junk3,word *,junk4)
{
        /*
         *      This function is used to undisplay the cursor, based on
         *      the state of the internal cursor flag. If the cursor flag
         *      is already not MOUSE_CURSOR_DISPLAYED, then this function
         *      does nothing, otherwise it removes the cursor from the display
         */

        UNUSED(junk1);
        UNUSED(junk2);
        UNUSED(junk3);
        UNUSED(junk4);

        note_trace0(MOUSE_VERBOSE, "mouse_io:hide_cursor()");
#ifndef NTVDM
        if (cursor_flag-- == MOUSE_CURSOR_DISPLAYED)
#ifdef  MOUSE_16_BIT
                if (is_graphics_mode)
                        mouse16bHidePointer();
                else
#endif  /* MOUSE_16_BIT */
                {
                cursor_undisplay();
                }
#endif
#if defined(NTVDM) && defined(X86GFX)
    host_hide_pointer();
#endif

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




LOCAL void mouse_get_position IFN4(word *,junk1,MOUSE_STATE *,button_status_ptr,MOUSE_SCALAR *,cursor_x_ptr,MOUSE_SCALAR *,cursor_y_ptr)
{
        /*
         *      This function returns the state of the left and right mouse
         *      buttons and the gridded position of the cursor on the screen
         */

        UNUSED(junk1);

        note_trace0(MOUSE_VERBOSE, "mouse_io:get_position()");

        *button_status_ptr = cursor_status.button_status;
        *cursor_x_ptr = cursor_status.position.x;
        *cursor_y_ptr = cursor_status.position.y;

        note_trace3(MOUSE_VERBOSE, "mouse_io:return(bs=%d,x=%d,y=%d)",
                    *button_status_ptr, *cursor_x_ptr, *cursor_y_ptr);
}




LOCAL void mouse_set_position IFN4(word *,junk1,word *,junk2,MOUSE_SCALAR *,cursor_x_ptr,MOUSE_SCALAR *,cursor_y_ptr)
{
        /*
         *      This function sets the cursor to a new position
         */

        UNUSED(junk1);
        UNUSED(junk2);

        note_trace2(MOUSE_VERBOSE, "mouse_io:set_position(x=%d,y=%d)",
                    *cursor_x_ptr, *cursor_y_ptr);


#if defined(NTVDM)

#ifndef X86GFX
        /*
         * update the cursor position. cc:Mail installtion does
         *  do {
         *     SetMouseCursorPosition(x,y)
         *     GetMouseCursorPosition(&NewX, &NewY);
         *  } while(NewX != x || NewY != y)
         *  If we don't retrun correct cursor position, this application
         *  looks hung
         *
         */
        point_set(&cursor_status.position, *cursor_x_ptr, *cursor_y_ptr);

#endif
        /*
         * For NT, the system pointer is used directly to provide
         * input except for fullscreen graphics where the host code
         * has the dubious pleasure of drawing the pointer through
         * a 16 bit device driver.
         */

         host_mouse_set_position((USHORT)*cursor_x_ptr,(USHORT)*cursor_y_ptr);
         return;  /* let's get out of this mess - FAST! */

#endif /* NTVDM */

        /*
         *      Update the current cursor position, and reflect the change
         *      in the cursor position on the screen
         */
        point_set(&cursor_position, *cursor_x_ptr, *cursor_y_ptr);
        cursor_update();

        /*
         *      If the cursor is currently displayed, move it to the new
         *      position
         */
        if (cursor_flag == MOUSE_CURSOR_DISPLAYED)
                cursor_display();

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




LOCAL void mouse_get_press IFN4(MOUSE_STATE *,button_status_ptr,MOUSE_COUNT *,button_ptr,MOUSE_SCALAR *,cursor_x_ptr,MOUSE_SCALAR *,cursor_y_ptr)
{
        /*
         *      This function returns the status of a button, the number of
         *      presses since the last call to this function, and the
         *      coordinates of the cursor at the last button press
         */
        int button = *button_ptr;

        note_trace1(MOUSE_VERBOSE, "mouse_io:get_press(button=%d)", button);

        /* Now and with 1. This is a fix for Norton Editor, but may cause
           problems for programs which use both mouse buttons pressed
           simultaneously, in which case need both bottom bits of button
           preserved, which may break Norton Editor again. sigh. */
        button &= 1;

        if (mouse_button_in_range(button))
        {
                *button_status_ptr = cursor_status.button_status;
                *button_ptr = button_transitions[button].press_count;
                button_transitions[button].press_count = 0;
                *cursor_x_ptr = button_transitions[button].press_position.x;
                *cursor_y_ptr = button_transitions[button].press_position.y;
        }

        note_trace4(MOUSE_VERBOSE, "mouse_io:return(bs=%d,ct=%d,x=%d,y=%d)",
                    *button_status_ptr, *button_ptr,
                    *cursor_x_ptr, *cursor_y_ptr);
}




LOCAL void mouse_get_release IFN4(MOUSE_STATE *,button_status_ptr,MOUSE_COUNT *,button_ptr,MOUSE_SCALAR *,cursor_x_ptr,MOUSE_SCALAR *,cursor_y_ptr)
{
        /*
         *      This function returns the status of a button, the number of
         *      releases since the last call to this function, and the
         *      coordinates of the cursor at the last button release
         */
        int button = *button_ptr;

        note_trace1(MOUSE_VERBOSE, "mouse_io:get_release(button=%d)",
                    *button_ptr);

        /* fix for norton editor, see previous comment */
        button &= 1;

        if (mouse_button_in_range(button))
        {
                *button_status_ptr = cursor_status.button_status;
                *button_ptr = button_transitions[button].release_count;
                button_transitions[button].release_count = 0;
                *cursor_x_ptr = button_transitions[button].release_position.x;
                *cursor_y_ptr = button_transitions[button].release_position.y;
        }

        note_trace4(MOUSE_VERBOSE, "mouse_io:return(bs=%d,ct=%d,x=%d,y=%d)",
                    *button_status_ptr, *button_ptr,
                    *cursor_x_ptr, *cursor_y_ptr);
}




LOCAL void mouse_set_range_x IFN4(word *,junk1,word *,junk2,MOUSE_SCALAR *,minimum_x_ptr,MOUSE_SCALAR *,maximum_x_ptr)
{
        /*
         *      This function sets the horizontal range within which
         *      movement of the cursor is to be restricted
         */

        UNUSED(junk1);
        UNUSED(junk2);

        note_trace2(MOUSE_VERBOSE, "mouse_io:set_range_x(min=%d,max=%d)",
                    *minimum_x_ptr, *maximum_x_ptr);

        /*
         *      Update the current cursor window, normalise it and validate
         *      it
         */
        cursor_window.top_left.x = *minimum_x_ptr;
        cursor_window.bottom_right.x = *maximum_x_ptr;
        area_normalise(&cursor_window);
#ifdef NTVDM
        /* make host aware of the new range setting because it is the one doing
         * clipping based on video mode setting.
         * Flight Simulator runs on 320x400 256 color mode and set the
         * cursor range to (0-13f, 0-18f). Without notifying the host,
         * the mouse cursor is always contrained to standard video mode
         * resolution which is not what the application wanted.
         */
        host_x_range(NULL, NULL, &cursor_window.top_left.x, &cursor_window.bottom_right.x);
#endif

        /*
         *      Reflect the change in the cursor position on the screen
         */
        cursor_update();

        /*
         *      If the cursor is currently displayed, move it to the new
         *      position
         */
        if (cursor_flag == MOUSE_CURSOR_DISPLAYED)
                cursor_display();

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




LOCAL void mouse_set_range_y IFN4(word *,junk1,word *,junk2,MOUSE_SCALAR *,minimum_y_ptr,MOUSE_SCALAR *,maximum_y_ptr)
{
        /*
         *      This function sets the vertical range within which
         *      movement of the cursor is to be restricted
         */

        UNUSED(junk1);
        UNUSED(junk2);

        note_trace2(MOUSE_VERBOSE, "mouse_io:set_range_y(min=%d,max=%d)",
                    *minimum_y_ptr, *maximum_y_ptr);

        /*
         *      Update the current cursor window, normalise it and validate
         *      it
         */
        cursor_window.top_left.y = *minimum_y_ptr;
        cursor_window.bottom_right.y = *maximum_y_ptr;
        area_normalise(&cursor_window);
#ifdef NTVDM
        /* make host aware of the new range setting because it is the one doing
         * clipping based on video mode setting.
         * Flight Simulator runs on 320x400 256 color mode and set the
         * cursor range to (0-13f, 0-18f). Without notifying the host,
         * the mouse cursor is always contrained to standard video mode
         * resolution which is not what the application wanted.
         */
        host_y_range(NULL, NULL, &cursor_window.top_left.y, &cursor_window.bottom_right.y);
#endif


        /*
         *      Reflect the change in the cursor position on the screen
         */
        cursor_update();

        /*
         *      If the cursor is currently displayed, move it to the new
         *      position
         */
        if (cursor_flag == MOUSE_CURSOR_DISPLAYED)
                cursor_display();

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}


LOCAL void copy_default_graphics_cursor IFN0()
{

                int line;
                UTINY temp;
                IU32 temp2;

                for (line = 0; line < MOUSE_GRAPHICS_CURSOR_DEPTH; line++)
                {
                        temp = (UTINY)((graphics_cursor.screen[line] & 0xff00) >> 8);

                        temp2 = ( (IU32) temp << 8 ) | (IU32) temp;
                        graphics_cursor.screen_lo[line] = ( temp2 << 16 ) | temp2;

                        temp = (UTINY)(graphics_cursor.screen[line] & 0xff);

                        temp2 = ( (IU32) temp << 8 ) | (IU32) temp;
                        graphics_cursor.screen_hi[line] = ( temp2 << 16 ) | temp2;

                }

                for (line = 0; line < MOUSE_GRAPHICS_CURSOR_DEPTH; line++)
                {
                        temp = (UTINY)((graphics_cursor.cursor[line] & 0xff00) >> 8);

                        temp2 = ( (IU32) temp << 8 ) | (IU32) temp;
                        graphics_cursor.cursor_lo[line] = ( temp2 << 16 ) | temp2;

                        temp = (UTINY)(graphics_cursor.cursor[line] & 0xff);

                        temp2 = ( (IU32) temp << 8 ) | (IU32) temp;
                        graphics_cursor.cursor_hi[line] = ( temp2 << 16 ) | temp2;

                }

}


LOCAL void mouse_set_graphics IFN4(word *,junk1,MOUSE_SCALAR *,hot_spot_x_ptr,MOUSE_SCALAR *,hot_spot_y_ptr,word *,bitmap_address)
{
        /*
         *      This function defines the shape, colour and hot spot of the
         *      graphics cursor
         */

        UNUSED(junk1);

#ifndef NTVDM

#ifdef MOUSE_16_BIT
        mouse16bSetBitmap( hot_spot_x_ptr , hot_spot_y_ptr , bitmap_address );
#else           /* MOUSE_16_BIT */

        if (host_mouse_installed())
        {
                host_mouse_set_graphics(hot_spot_x_ptr, hot_spot_y_ptr, bitmap_address);
        }
        else
        {
                MOUSE_SCREEN_DATA *mask_address;
                int line;
                UTINY temp;
                IU32 temp2;

                /*
                 *      Set graphics cursor hot spot
                 */
                point_set(&graphics_cursor.hot_spot, *hot_spot_x_ptr, *hot_spot_y_ptr);

                /*
                 *      Set graphics cursor screen and cursor masks
                 */
                mask_address = (MOUSE_SCREEN_DATA *)effective_addr(getES(), *bitmap_address);

                for (line = 0; line < MOUSE_GRAPHICS_CURSOR_DEPTH; line++, mask_address++)
                {
                        sas_load((sys_addr)mask_address + 1, &temp );

                        temp2 = ( (IU32) temp << 8 ) | (IU32) temp;
                        graphics_cursor.screen_lo[line] = ( temp2 << 16 ) | temp2;

                        sas_load((sys_addr)mask_address , &temp );

                        temp2 = ( (IU32) temp << 8 ) | (IU32) temp;
                        graphics_cursor.screen_hi[line] = ( temp2 << 16 ) | temp2;

                        graphics_cursor.screen[line] = ( graphics_cursor.screen_hi[line] & 0xff )
                                                                        | ( graphics_cursor.screen_lo[line] << 8 );
                }

                for (line = 0; line < MOUSE_GRAPHICS_CURSOR_DEPTH; line++, mask_address++)
                {
                        sas_load((sys_addr)mask_address + 1, &temp );

                        temp2 = ( (IU32) temp << 8 ) | (IU32) temp;
                        graphics_cursor.cursor_lo[line] = ( temp2 << 16 ) | temp2;

                        sas_load((sys_addr)mask_address , &temp );

                        temp2 = ( (IU32) temp << 8 ) | (IU32) temp;
                        graphics_cursor.cursor_hi[line] = ( temp2 << 16 ) | temp2;

                        graphics_cursor.cursor[line] = ( graphics_cursor.cursor_hi[line] & 0xff )
                                                                        | ( graphics_cursor.cursor_lo[line] << 8 );
                }

        }
#endif /* MOUSE_16_BIT */
#endif /* NTVDM */
        /*
         *      Redisplay cursor if necessary
         */
        if (cursor_flag == MOUSE_CURSOR_DISPLAYED)
                cursor_display();
}




LOCAL void mouse_set_text IFN4(word *,junk1,MOUSE_STATE *,text_cursor_type_ptr,MOUSE_SCREEN_DATA *,parameter1_ptr,MOUSE_SCREEN_DATA *,parameter2_ptr)
{
        /*
         *      This function selects the software or hardware text cursor
         */
        UNUSED(junk1);

#ifndef PROD
        if (io_verbose & MOUSE_VERBOSE)
        {
                fprintf(trace_file, "mouse_io:set_text(type=%d,",
                        *text_cursor_type_ptr);
                if (*text_cursor_type_ptr == MOUSE_TEXT_CURSOR_TYPE_SOFTWARE)
                        fprintf(trace_file, "screen=0x%x,cursor=0x%x)\n",
                                *parameter1_ptr, *parameter2_ptr);
                else
                        fprintf(trace_file, "start=%d,stop=%d)\n",
                                *parameter1_ptr, *parameter2_ptr);
        }
#endif

        if (mouse_text_cursor_type_in_range(*text_cursor_type_ptr))
        {
                /*
                 *      Remove existing text cursor
                 */
                cursor_undisplay();

                text_cursor_type = *text_cursor_type_ptr;
#ifdef EGG
                if (jap_mouse) {
                  /* we need to emulate the text cursor in the
                   * current graphics mode. Just do a block at present
                   */
                  int line;
                  for (line = 0; line < MOUSE_GRAPHICS_CURSOR_DEPTH; line++)
                    {
                      graphics_cursor.cursor[line]=0xff00;
                      graphics_cursor.screen[line]=0xffff;
                    }
                  point_set(&(graphics_cursor.hot_spot),0,0);
                  point_set(&(graphics_cursor.size),MOUSE_GRAPHICS_CURSOR_WIDTH,MOUSE_GRAPHICS_CURSOR_WIDTH);
                  copy_default_graphics_cursor();
                } else
#endif /* EGG */
                if (text_cursor_type == MOUSE_TEXT_CURSOR_TYPE_SOFTWARE)
                {
                        /*
                         *      Parameters are the data for the screen
                         *      and cursor masks
                         */
                        software_text_cursor.screen = *parameter1_ptr;
                        software_text_cursor.cursor = *parameter2_ptr;
                }
                else
                {
                        /*
                         *      Parameters are the scan line start and
                         *      stop values
                         */
                        word savedIP = getIP(), savedCS = getCS();

                        setCH((UCHAR)(*parameter1_ptr));
                        setCL((UCHAR)(*parameter2_ptr));
                        setAH(MOUSE_VIDEO_SET_CURSOR);

                        setCS(VIDEO_IO_SEGMENT);
                        setIP(VIDEO_IO_RE_ENTRY);
                        host_simulate();
                        setCS(savedCS);
                        setIP(savedIP);
                }

                /*
                 *      Put new text cursor on screen
                 */
                if (cursor_flag == MOUSE_CURSOR_DISPLAYED)
                        cursor_display();
        }

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




LOCAL void mouse_read_motion IFN4(word *,junk1,word *,junk2,MOUSE_COUNT *,motion_count_x_ptr,MOUSE_COUNT *,motion_count_y_ptr)
{
        /*
         *      This function returns the horizontal and vertical mouse
         *      motion counts since the last call; the motion counters
         *      are cleared
         */

        UNUSED(junk1);
        UNUSED(junk2);

        note_trace0(MOUSE_VERBOSE, "mouse_io:read_motion()");

        *motion_count_x_ptr = mouse_motion.x;
        mouse_motion.x = 0;
        *motion_count_y_ptr = mouse_motion.y;
        mouse_motion.y = 0;


        note_trace2(MOUSE_VERBOSE, "mouse_io:return(x=%d,y=%d)",
                    *motion_count_x_ptr, *motion_count_y_ptr);
}




LOCAL void mouse_set_subroutine IFN4(word *,junk1,word *,junk2,word *,call_mask,word *,subroutine_address)
{
        /*
         *      This function sets the call mask and subroutine address
         *      for a user function to be called when a mouse interrupt
         *      occurs
         */

        UNUSED(junk1);
        UNUSED(junk2);

        note_trace3(MOUSE_VERBOSE,
                    "mouse_io:set_subroutine(CS:IP=%x:%x,mask=0x%02x)",
                    getES(), *subroutine_address, *call_mask);

        user_subroutine_segment = getES();
        user_subroutine_offset = *subroutine_address;
        user_subroutine_call_mask = (MOUSE_CALL_MASK)((*call_mask) & MOUSE_CALL_MASK_SIGNIFICANT_BITS);

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}


/* unpublished service 20, used by Microsoft Windows */
LOCAL void mouse_get_and_set_subroutine IFN4(word *,junk1,word *,junk2,word *,call_mask,word *,subroutine_address)
{
        /*
        same as set_subroutine (function 12) but also returns previous call mask in cx (m3)
        and user subroutine address in es:dx (es:m4)
        */
        word local_segment, local_offset,  local_call_mask;

        note_trace3(MOUSE_VERBOSE,
                    "mouse_io:get_and_set_subroutine(CS:IP=%x:%x,mask=0x%02x)",
                    getES(), *subroutine_address, *call_mask);

        local_offset = user_subroutine_offset;
        local_segment = user_subroutine_segment;
        local_call_mask = user_subroutine_call_mask;
        /* save previous subroutine data so it can be returned */

        mouse_set_subroutine(junk1,junk2,call_mask,subroutine_address);
        /* set the subroutine stuff with the normal function 12 */
        *call_mask = local_call_mask;
        *subroutine_address = local_offset;
        setES(local_segment);
}



LOCAL void mouse_light_pen_on IFN4(word *,junk1,word *,junk2,word *,junk3,word *,junk4)
{
        /*
         *      This function enables light pen emulation
         */

        UNUSED(junk1);
        UNUSED(junk2);
        UNUSED(junk3);
        UNUSED(junk4);

        note_trace0(MOUSE_VERBOSE, "mouse_io:light_pen_on()");

        light_pen_mode = TRUE;

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




LOCAL void mouse_light_pen_off IFN4(word *,junk1,word *,junk2,word *,junk3,word *,junk4)
{
        /*
         *      This function disables light pen emulation
         */

        UNUSED(junk1);
        UNUSED(junk2);
        UNUSED(junk3);
        UNUSED(junk4);

        note_trace0(MOUSE_VERBOSE, "mouse_io:light_pen_off()");

        light_pen_mode = FALSE;

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




LOCAL void mouse_set_ratio IFN4(word *,junk1,word *,junk2,MOUSE_SCALAR *,ratio_x_ptr,MOUSE_SCALAR *,ratio_y_ptr)
{
        /*
         *      This function sets the Mickey to Pixel ratio in the
         *      horizontal and vertical directions
         */

        UNUSED(junk1);
        UNUSED(junk2);

        note_trace2(MOUSE_VERBOSE, "mouse_io:set_ratio(x=%d,y=%d)",
                    *ratio_x_ptr, *ratio_y_ptr);

                /*
                 *      Update the Mickey to pixel ratio in force
                 */
                if (mouse_ratio_in_range(*ratio_x_ptr))
                        mouse_gear.x = *ratio_x_ptr;
                if (mouse_ratio_in_range(*ratio_y_ptr))
                        mouse_gear.y = *ratio_y_ptr;

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




LOCAL void mouse_conditional_off IFN4(word *,junk1,word *,junk2,MOUSE_SCALAR *,upper_x_ptr,MOUSE_SCALAR *,upper_y_ptr)
{
        /*
         *      This function defines an area of the virtual screen where
         *      the mouse is automatically hidden
         */
        MOUSE_SCALAR lower_x = getSI(), lower_y = getDI();

        UNUSED(junk1);
        UNUSED(junk2);

        note_trace4(MOUSE_VERBOSE,
                    "mouse_io:conditional_off(ux=%d,uy=%d,lx=%d,ly=%d)",
                    *upper_x_ptr, *upper_y_ptr, lower_x, lower_y);

        /*
         *      Update the conditional off area and normalise it: the Microsoft
         *      driver adds a considerable "margin for error" to the left and
         *      above the conditional off area requested - we must do the same
         *      to behave compatibly
         */
        black_hole.top_left.x = (*upper_x_ptr) - MOUSE_CONDITIONAL_OFF_MARGIN_X;
        black_hole.top_left.y = (*upper_y_ptr) - MOUSE_CONDITIONAL_OFF_MARGIN_Y;
        black_hole.bottom_right.x = lower_x + 1;
        black_hole.bottom_right.y = lower_y + 1;
        area_normalise(&black_hole);

        /*
         *      If the cursor is currently displayed, redisplay taking the
         *      conditional off area into account
         */
#ifdef  MOUSE_16_BIT
        if (is_graphics_mode)
        {
                if ((cursor_position.x >= black_hole.top_left.x) &&
                        (cursor_position.x <= black_hole.bottom_right.x) &&
                        (cursor_position.y >= black_hole.top_left.y) &&
                        (cursor_position.y <= black_hole.bottom_right.y))
                        if (cursor_flag-- == MOUSE_CURSOR_DISPLAYED)
                                mouse16bHidePointer();
        }
        else
#endif  /* MOUSE_16_BIT */
        {
        if (cursor_flag == MOUSE_CURSOR_DISPLAYED)
                cursor_display();
        }
#if defined (NTVDM) && defined(MONITOR)

    sas_store(conditional_off_sysaddr, 1);
    host_mouse_conditional_off_enabled();
#endif

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}


LOCAL void mouse_get_state_size IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function returns the size of buffer the caller needs to
         *      supply to mouse function 22 (save state)
         */

        UNUSED(m1);
        UNUSED(m3);
        UNUSED(m4);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_get_state_size()");

        *m2 = (word)mouse_context_size;

        note_trace1(MOUSE_VERBOSE, "mouse_io: ...size is %d(decimal) bytes.",
                    *m2);
}


LOCAL void mouse_save_state IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function saves the state of the driver in the user-supplied
         *      buffer ready for subsequent passing to mouse function 23 (restore
         *      state)
         *
         *      Note that a magic cookie and checksum are placed in the saved state so that the
         *      restore routine can ignore invalid calls.
         */
        sys_addr                dest;
        IS32                    cs = 0;
#ifdef NTVDM
        IS32                    i;
        IU8*                    ptr;
#ifdef MONITOR

    /* real CF resides in 16 bit code */
    int             saved_cursor_flag = cursor_flag;
    IS8             copyCF;
#endif
#endif
        UNUSED(m1);
        UNUSED(m2);
        UNUSED(m3);

#if defined(NTVDM) && defined(MONITOR)
    sas_load(mouseCFsysaddr, &copyCF);
    cursor_flag = (int)copyCF;
#endif
        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_save_state()");

        dest = effective_addr (getES(), *m4);

        /* Save Cookie */
        sas_stores(dest, (IU8 *)mouse_context_magic, MOUSE_CONTEXT_MAGIC_SIZE);
        dest += MOUSE_CONTEXT_MAGIC_SIZE;

        /* Save Context Variables */
        sas_stores(dest, (IU8 *)&mouse_context, sizeof(MOUSE_CONTEXT));
        dest += sizeof(MOUSE_CONTEXT);
#ifdef NTVDM
        /* calculate checksum */
        for (i = 0; i < MOUSE_CONTEXT_MAGIC_SIZE; i++)
            cs += (IU8)(mouse_context_magic[i]);
        ptr = (IU8*)&mouse_context;
        for (i = 0; i < sizeof(MOUSE_CONTEXT); i++)
            cs += *ptr++;
#endif
        /* Save Checksum */
        sas_store (dest, (byte)(cs & 0xFF));

#if defined(NTVDM) && defined(MONITOR)
    cursor_flag = saved_cursor_flag;
#endif
}


LOCAL void mouse_restore_state IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
#ifndef NEC_98
        /*
         *      This function restores the state of the driver from the user-supplied
         *      buffer which was set up by a call to mouse function 22.
         *
         *      Note that a magic cookie and checksum were placed in the saved state so this routine
         *      checks for its presence and ignores the call if it is not found.
         */
        sys_addr                src;
        IS32                    i;
        IS32                    cs = 0;
        half_word               b;
        boolean                 valid=TRUE;

        UNUSED(m1);
        UNUSED(m2);
        UNUSED(m3);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_restore_state()");

        src = effective_addr (getES(), *m4);

        /* Check Cookie */
        for (i=0; valid && i<MOUSE_CONTEXT_MAGIC_SIZE; i++){
                sas_load (src, &b);
                valid = (b == mouse_context_magic[i]);
                src++;
        }

        if (valid){
                /* Cookie was present... check checksum */
                src = effective_addr (getES(), *m4);
                for (i=0; i<MOUSE_CONTEXT_MAGIC_SIZE; i++){
                        sas_load (src, &b);
                        cs += b;
                        src++;
                }
                for (i = 0; i < sizeof(MOUSE_CONTEXT); i++){
                        sas_load (src, &b);
                        cs += b;
                        src++;
                }
                sas_load (src, &b);     /* Pick up saved checksum */
                valid = (b == (half_word)(cs & 0xFF));
        }
        if (valid){
                /* Checksum OK, too.... load up our variables */
                cursor_undisplay();
                src = effective_addr (getES(), *m4) + MOUSE_CONTEXT_MAGIC_SIZE;
                sas_loads(src, (IU8 *)&mouse_context, sizeof(MOUSE_CONTEXT));
#ifdef EGG
                mouse_ega_mode (sas_hw_at(vd_video_mode));
#endif
#if defined(NTVDM) && defined(MONITOR)
        /* real CF resides in 16 Bit code:  */
        sas_store(mouseCFsysaddr, (half_word)cursor_flag);
        if (cursor_flag )
            cursor_flag = MOUSE_CURSOR_DEFAULT;
#endif
                if (cursor_flag == MOUSE_CURSOR_DISPLAYED){
                        cursor_display();
                }
        }else{
                /* Something failed.... ignore the call */
#ifndef PROD
                printf ("mouse_io.c: invalid call to restore context.\n");
#endif
        }
#endif   //NEC_98
}


LOCAL void mouse_set_alt_subroutine IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function sets up to 3 alternate event handlers for mouse
         *      events which occur while various combinations of the Ctrl, Shift
         *      and Alt keys are down.
         */
        boolean found_one=FALSE;
        int i;

        UNUSED(m2);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_set_alt_subroutine()");

        if (*m3 & MOUSE_CALL_MASK_KEY_BITS){
                /* Search for entry with same key combination */
                for (i=0; !found_one && i<NUMBER_ALT_SUBROUTINES; i++){
                        found_one = (*m3 & MOUSE_CALL_MASK_KEY_BITS)==(alt_user_subroutine_call_mask[i] & MOUSE_CALL_MASK_KEY_BITS);
                }

                if (!found_one){
                        /* Does not match existing entry... try to find free slot */
                        for (i=0; !found_one && i<NUMBER_ALT_SUBROUTINES; i++){
                                found_one = (alt_user_subroutine_call_mask[i] & MOUSE_CALL_MASK_KEY_BITS) == 0;
                        }
                }

                if (found_one){
                        i--;    /* Adjust for final increment */
                        alt_user_subroutine_call_mask[i] = *m3;
                        if (*m3 & MOUSE_CALL_MASK_SIGNIFICANT_BITS){
                                /* New value active */
                                alt_user_subroutines_active = TRUE;
                                alt_user_subroutine_offset[i] = *m4;
                                alt_user_subroutine_segment[i] = getES();
                        }else{
                                /* New value is not active - check if we've disabled the last one */
                                alt_user_subroutines_active = FALSE;
                                for (i=0; !alt_user_subroutines_active && i<NUMBER_ALT_SUBROUTINES; i++){
                                        alt_user_subroutines_active =
                                                (alt_user_subroutine_call_mask[i] & MOUSE_CALL_MASK_SIGNIFICANT_BITS) != 0;
                                }
                        }
                        /* Return success */
                        *m1 = 0;
                }else{
                        /* Request failed - no free slot */
                        *m1 = 0xFFFF;
                }
        }else{
                /* Error - no key bits set in request */
                *m1 = 0xFFFF;
        }
}


LOCAL void mouse_get_alt_subroutine IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function obtains the address of a specific alternate
         *      user event handling subroutine as set up by a previous call
         *      to mouse function 24.
         */
        boolean found_one=FALSE;
        int i;

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_get_alt_subroutine()");

        if (*m3 & MOUSE_CALL_MASK_KEY_BITS){
                /* Search for entry with same key combination */
                for (i=0; !found_one && i<NUMBER_ALT_SUBROUTINES; i++){
                        found_one = (*m3 & MOUSE_CALL_MASK_KEY_BITS)==(alt_user_subroutine_call_mask[i] & MOUSE_CALL_MASK_KEY_BITS);
                }

                if (found_one){
                        i--;    /* Adjust for final increment */
                        *m3 = alt_user_subroutine_call_mask[i];
                        *m2 = alt_user_subroutine_segment[i];
                        *m4 = alt_user_subroutine_offset[i];
                        /* Return success */
                        *m1 = 0;
                }else{
                        /* Request failed - not found */
                        *m1 = 0xFFFF;
                        *m2 = *m3 = *m4 = 0;
                }
        }else{
                /* Error - no key bits set in request */
                *m1 = 0xFFFF;
                *m2 = *m3 = *m4 = 0;
        }
}


LOCAL void mouse_set_sensitivity IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function sets a new value for the mouse sensitivity and
         *      double speed threshold.
         *      The sensitivity value is used before the mickeys per pixel
         *      ratio is applied.
         */

        UNUSED(m1);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_set_sensitivity()");

                if (mouse_sens_in_range(*m2))
                {
                        mouse_sens_val.x = mouse_sens_calc_val(*m2);
                        mouse_sens.x     = *m2;
                }
                else
                {
                        mouse_sens_val.x = MOUSE_SENS_DEF_VAL;
                        mouse_sens.x     = MOUSE_SENS_DEF;
                }
                if (mouse_sens_in_range(*m3))
                {
                        mouse_sens_val.y = mouse_sens_calc_val(*m3);
                        mouse_sens.y     = *m3;
                }
                else
                {
                        mouse_sens_val.y = MOUSE_SENS_DEF_VAL;
                        mouse_sens.y     = MOUSE_SENS_DEF;
                }
                /*
                 *      m4 has speed double threshold value... still needs to be implemented.
                 */
                if (mouse_sens_in_range(*m4))
                        mouse_double_thresh = *m4;
                else
                        mouse_double_thresh = MOUSE_DOUBLE_DEF;
}


LOCAL void mouse_get_sensitivity IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function returns the current value of the mouse sensitivity.
         */

        UNUSED(m1);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_get_sensitivity()");

        *m2 = mouse_sens.x;
        *m3 = mouse_sens.y;
        *m4 = mouse_double_thresh;
}


LOCAL void mouse_set_int_rate IFN4
   (
   word *, m1,
   word *, int_rate_ptr,
   word *, m3,
   word *, m4
   )
   {
   /*
      Func 28: Set Mouse Interrupt Rate.
               0 = No interrupts
               1 = 30 interrupte/sec
               2 = 50 interrupte/sec
               3 = 100 interrupte/sec
               4 = 200 interrupte/sec
               >4 = undefined
    */

   UNUSED(m1);
   UNUSED(m3);
   UNUSED(m4);

   note_trace1(MOUSE_VERBOSE, "mouse_io: set_int_rate(rate=%d)", *int_rate_ptr);

   /* Just remember rate, for later return (Func 51). We don't actually
      action it. */
   mouse_interrupt_rate = (half_word)*int_rate_ptr;

   note_trace0(MOUSE_VERBOSE, "mouse_io: return()");
   }


LOCAL void mouse_set_pointer_page IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
#ifndef NEC_98
        /*
         *      This function sets the current mouse pointer video page.
         */

        UNUSED(m1);
        UNUSED(m3);
        UNUSED(m4);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_set_pointer_page()");

        if (is_valid_page_number(*m2)){
                cursor_undisplay();
                cursor_page = *m2;
                if (cursor_flag == MOUSE_CURSOR_DISPLAYED){
                        cursor_display();
                }
        }else{
#ifndef PROD
                fprintf(trace_file, "mouse_io: Bad page requested\n");
#endif
        }
#endif    //NEC_98
}


LOCAL void mouse_get_pointer_page IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function gets the value of the current mouse pointer
         *      video page.
         */

        UNUSED(m1);
        UNUSED(m3);
        UNUSED(m4);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_get_pointer_page()");
        *m2 = (word)cursor_page;
}


LOCAL void mouse_driver_disable IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function disables the mouse driver and de-installs the
         *      interrupt vectors (bar INT 33h, whose previous value is
         *      returned to the caller to allow them to use DOS function
         *      25h to completely remove the mouse driver).
         */
        boolean         failed = FALSE;
#ifdef NTVDM
    word        current_int71_offset, current_int71_segment;
#else
        word            current_int0A_offset, current_int0A_segment;
        word            current_int10_offset, current_int10_segment;
#endif
        half_word       interrupt_mask_register;

        UNUSED(m4);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_disable()");
        mouse_driver_disabled = TRUE;

        if (!failed){
#ifdef NTVDM
        sas_loadw (int_addr(0x71) + 0, &current_int71_offset);
        sas_loadw (int_addr(0x71) + 2, &current_int71_segment);
        failed = current_int71_offset  != MOUSE_INT1_OFFSET ||
                 current_int71_segment != MOUSE_INT1_SEGMENT;
#else
                sas_loadw (int_addr(MOUSE_VEC) + 0, &current_int0A_offset);
                sas_loadw (int_addr(MOUSE_VEC) + 2, &current_int0A_segment);
                sas_loadw (int_addr(0x10) + 0, &current_int10_offset);
                sas_loadw (int_addr(0x10) + 2, &current_int10_segment);
                failed = current_int0A_offset  != MOUSE_INT1_OFFSET ||
                         current_int0A_segment != MOUSE_INT1_SEGMENT ||
                         current_int10_offset  != MOUSE_VIDEO_IO_OFFSET ||
                         current_int10_segment != MOUSE_VIDEO_IO_SEGMENT;
#endif
        }
        if (!failed){
                /*
                 *      Disable mouse H/W interrupts
                 */
                inb(ICA1_PORT_1, &interrupt_mask_register);
                interrupt_mask_register |= (1 << AT_CPU_MOUSE_INT);
                outb(ICA1_PORT_1, interrupt_mask_register);
                inb(ICA0_PORT_1, &interrupt_mask_register);
                interrupt_mask_register |= (1 << CPU_MOUSE_INT);
                outb(ICA0_PORT_1, interrupt_mask_register);
                /*
                 *      Restore interrupt vectors
                 */

#ifdef NTVDM
                sas_storew (int_addr(0x71) + 0, saved_int71_offset);
                sas_storew (int_addr(0x71) + 2, saved_int71_segment);
#else
                sas_storew (int_addr(MOUSE_VEC) + 0, saved_int0A_offset);
                sas_storew (int_addr(MOUSE_VEC) + 2, saved_int0A_segment);
                sas_storew (int_addr(0x10) + 0, saved_int10_offset);
                sas_storew (int_addr(0x10) + 2, saved_int10_segment);
#endif
                /*
                 *      Return success status and old INT33h vector
                 */
                *m1 = 0x1F;
                *m2 = saved_int33_offset;
                *m3 = saved_int33_segment;
        }else{
                /*
                 * Return failure
                 */
                *m1 = 0xFFFF;
        }
}


LOCAL void mouse_driver_enable IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function re-enables the mouse driver after a call to
         *      function 31 (disable mouse driver).
         */
        word hook_offset;
        half_word       interrupt_mask_register;

        UNUSED(m1);
        UNUSED(m2);
        UNUSED(m3);
        UNUSED(m4);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_driver_enable()");

        /*
         * This prevents an endless loop of calls to mouse_video_io() if an
         * application does a Mouse Driver Enable without first having done
         * a Mouse Driver Disable
         */
        if (!mouse_driver_disabled)
                return;

        mouse_driver_disabled = FALSE;

        /*
         *      Reload bus mouse hardware interrupt
         */

#ifdef NTVDM
    sas_loadw (int_addr(0x71) + 0, &saved_int71_offset);
    sas_loadw (int_addr(0x71) + 2, &saved_int71_segment);
    sas_storew(int_addr(0x71), MOUSE_INT1_OFFSET);
    sas_storew(int_addr(0x71) + 2, MOUSE_INT1_SEGMENT);
#else
        sas_loadw (int_addr(MOUSE_VEC) + 0, &saved_int0A_offset);
        sas_loadw (int_addr(MOUSE_VEC) + 2, &saved_int0A_segment);
        sas_storew(int_addr(MOUSE_VEC), MOUSE_INT1_OFFSET);
        sas_storew(int_addr(MOUSE_VEC) + 2, MOUSE_INT1_SEGMENT);
#endif

        /*
         *      Enable mouse hardware interrupts in the ica
         */
        inb(ICA1_PORT_1, &interrupt_mask_register);
        interrupt_mask_register &= ~(1 << AT_CPU_MOUSE_INT);
        outb(ICA1_PORT_1, interrupt_mask_register);
        inb(ICA0_PORT_1, &interrupt_mask_register);
        interrupt_mask_register &= ~(1 << CPU_MOUSE_INT);
        outb(ICA0_PORT_1, interrupt_mask_register);

        /*
         *      Mouse io user interrupt
         */

#ifndef NTVDM
        /* Read offset of INT 33 procedure from MOUSE.COM */
        sas_loadw(effective_addr(getCS(), OFF_HOOK_POSN), &hook_offset);

        sas_storew(int_addr(0x33), hook_offset);
        sas_storew(int_addr(0x33) + 2, getCS());

        /*
         *      Mouse video io user interrupt
         */
        sas_loadw (int_addr(0x10) + 0, &saved_int10_offset);
        sas_loadw (int_addr(0x10) + 2, &saved_int10_segment);
        sas_storew(int_addr(0x10), MOUSE_VIDEO_IO_OFFSET);
        sas_storew(int_addr(0x10) + 2, MOUSE_VIDEO_IO_SEGMENT);
#endif /* NTVDM */
}


LOCAL void mouse_set_language IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function is only applicable to an international version
         *      of a mouse driver... which this is not! Acts as a NOP.
         */

        UNUSED(m1);
        UNUSED(m2);
        UNUSED(m3);
        UNUSED(m4);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_set_language()");
        /* NOP */
}


LOCAL void mouse_get_language IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function is only meaningful on an international version
         *      of a mouse driver... which this is not! Always returns 0
         *      (English).
         */

        UNUSED(m1);
        UNUSED(m3);
        UNUSED(m4);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_get_language()");

#ifdef KOREA
        // Korean DOS apps want this bit(e.g. Edit.com, Multi Plan)
        // 10/14/96 bklee
        *m2 = 9;
#else   0 = English
        *m2 = 0;
#endif

        note_trace1(MOUSE_VERBOSE,
                    "mouse_io: mouse_get_language returning m2=0x%04x.", *m2);
}


LOCAL void mouse_get_info IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function obtains certain information about the mouse
         *      driver and hardware.
         */
        UNUSED(m1);
        UNUSED(m4);

        note_trace0(MOUSE_VERBOSE, "mouse_io: mouse_get_info()");

        *m2 = ((word)mouse_emulated_release << 8) | (word)mouse_emulated_version;
        *m3 = ((word)MOUSE_TYPE_INPORT << 8)      | (word)CPU_MOUSE_INT;

        note_trace2(MOUSE_VERBOSE,
                    "mouse_io: mouse_get_info returning m2=0x%04x, m3=0x%04x.",
                    *m2, *m3);
}


LOCAL void mouse_get_driver_info IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        *m1 = (current_video_mode > 3 ? 0x2000 : 0) | 0x100;
        /*      bit 15 = 0 for COM v SYS
                bit 14 = 0 for original non-integrated type
                bit 13 is 1 for graphics cursor or 0 for text
                bit 12 = 0 for software cursor
                bits 8-11 are encoded interrupt rate, 1 means 30 Hz
                bits 0-7 used only by integrated driver
        */
        *m2 = 0;        /* fCursorLock, used by driver under OS/2 */
        *m3 = 0;        /* fInMouseCode, flag for current execution path
                        being inside mouse driver under OS/2. Since the
                        driver is in a bop it can't be interrupted */
        *m4 = 0;        /* fMouseBusy, similar to *m3 */
}


LOCAL void mouse_get_max_coords IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
#ifdef NTVDM
IMPORT word VirtualX, VirtualY;
#endif

        UNUSED(m1);

#ifdef NTVDM
    *m3 = VirtualX;
    *m4 = VirtualY;
#endif

        *m2 = mouse_driver_disabled;

#ifndef NTVDM
        get_screen_size();
        *m3 = virtual_screen.bottom_right.x - 1;
        *m4 = virtual_screen.bottom_right.y - 1;
#endif
}

LOCAL void mouse_get_masks_and_mickeys IFN4
   (
   MOUSE_SCREEN_DATA *, screen_mask_ptr,
   MOUSE_SCREEN_DATA *, cursor_mask_ptr,
   MOUSE_SCALAR *,      raw_horiz_count_ptr,
   MOUSE_SCALAR *,      raw_vert_count_ptr
   )
   {
#ifndef NEC_98
   /*
      Func 39: Get Screen/Cursor Masks and Mickey Counts.
    */
   word cursor_mode;

   note_trace0(MOUSE_VERBOSE, "mouse_io: get_masks_and_mickeys");

   /* read and reset counts */
   *raw_horiz_count_ptr = mouse_raw_motion.x;
   *raw_vert_count_ptr = mouse_raw_motion.y;
   mouse_raw_motion.x = mouse_raw_motion.y = 0;

   if ( text_cursor_type == MOUSE_TEXT_CURSOR_TYPE_SOFTWARE )
      {
      *screen_mask_ptr = software_text_cursor.screen;
      *cursor_mask_ptr = software_text_cursor.cursor;

      note_trace4(MOUSE_VERBOSE,
         "mouse_io: return(screen=0x%x, mask=0x%x, raw mickeys=(%d,%d))",
         *screen_mask_ptr,
         *cursor_mask_ptr,
         *raw_horiz_count_ptr,
         *raw_vert_count_ptr);
      }
   else
      {
      /* Read BIOS data variable */
      sas_loadw((sys_addr)VID_CURMOD, &cursor_mode);

      /* Then extract start and stop from it */
      *screen_mask_ptr = cursor_mode >> 8;      /* start */
      *cursor_mask_ptr = cursor_mode & 0xff;    /* stop */

      note_trace4(MOUSE_VERBOSE,
         "mouse_io: return(start=%d, stop=%d, raw mickeys=(%d,%d))",
         *screen_mask_ptr,
         *cursor_mask_ptr,
         *raw_horiz_count_ptr,
         *raw_vert_count_ptr);
      }
#endif   //NEC_98
   }

LOCAL void mouse_set_video_mode IFN4
   (
   word *, m1,
   word *, m2,
   word *, video_mode_ptr,
   word *, font_size_ptr
   )
   {
#ifndef NEC_98
   /*
      Func 40 Set Video Mode. NB. This only sets the mouse state to
      match the video mode. Actual changes to the video mode are still
      made by the application calling the BIOS.
    */

   UNUSED(m1);
   UNUSED(m2);

   note_trace2(MOUSE_VERBOSE,
      "mouse_io: set_video_mode(mode=0x%x, font size=0x%x)",
      *video_mode_ptr, *font_size_ptr);

   /* Check validity of mode */
   if ( is_bad_vid_mode(*video_mode_ptr) && !is_v7vga_mode(*video_mode_ptr) )
      {
      /* Bad mode do nothing */
      ;
      }
   else
      {
      /* Update our parameters, as per the given mode */
      current_video_mode = *video_mode_ptr;

      mouse_adjust_screen_size();

      cursor_undisplay();
      cursor_flag = MOUSE_CURSOR_DEFAULT;
      cursor_mode_change(current_video_mode);

#ifdef MOUSE_16_BIT
      /* Remember whether in text or graphics mode for later use. */
      is_graphics_mode = ((current_video_mode > 3) &&
                          (current_video_mode != 7));
#endif /* MOUSE_16_BIT */

      *video_mode_ptr = 0;   /* Indicate success */
      }

   note_trace1(MOUSE_VERBOSE, "mouse_io: return(mode=0x%x)",
      *video_mode_ptr);
#endif    //NEC_98
   }

LOCAL void mouse_enumerate_video_modes IFN4
   (
   word *, m1,
   word *, m2,
   word *, video_nr_ptr,
   word *, offset_ptr
   )
   {
#ifndef NEC_98
   /*
      Func 41 Enumerate Video Modes.
    */

   UNUSED(m1);
   UNUSED(m2);

   note_trace1(MOUSE_VERBOSE, "mouse_io: enumerate_video_modes(mode=0x%x)", *video_nr_ptr);

   /* Do they want to reset to first entry */
   if ( *video_nr_ptr == 0 )
      {
      next_video_mode = 1;   /* Yes */
      }

   /* Blindly try all possible mode settings */
   while ( next_video_mode <= MAX_NR_VIDEO_MODES )
      {
      if ( is_bad_vid_mode(next_video_mode) && !is_v7vga_mode(next_video_mode) )
         {
         next_video_mode++;   /* keep searching */
         }
      else
         {
         break;   /* stop searching as valid mode has been found */
         }
      }

   /* Action setting found, or end of list */
   if ( next_video_mode > MAX_NR_VIDEO_MODES )
      {
      *video_nr_ptr = 0;
      }
   else
      {
      *video_nr_ptr = (word)next_video_mode;
      next_video_mode++;   /* update for next call */
      }

   /* We don't provide string descriptions */
   setES(0);
   *offset_ptr = 0;

   note_trace3(MOUSE_VERBOSE, "mouse_io: return(mode=0x%x, seg=0x%x, off=0x%x)",
      *video_nr_ptr, getES(), *offset_ptr);
#endif    //NEC_98
   }

LOCAL void mouse_get_cursor_hot_spot IFN4
   (
   word *,         fCursor_ptr,
   MOUSE_SCALAR *, hot_spot_x_ptr,
   MOUSE_SCALAR *, hot_spot_y_ptr,
   word *,         mouse_type_ptr
   )
   {
#ifndef NEC_98
   /*
      Func 42: Return cursor hot spot location, the type of mouse in
      use, and the internal counter that controls cursor visibility.
    */

   note_trace0(MOUSE_VERBOSE, "mouse_io: get_cursor_hot_spot");

   *fCursor_ptr = (word)cursor_flag;

   *hot_spot_x_ptr = graphics_cursor.hot_spot.x;
   *hot_spot_y_ptr = graphics_cursor.hot_spot.y;

   *mouse_type_ptr = MOUSE_TYPE_INPORT;

   note_trace4(MOUSE_VERBOSE,
      "mouse_io: return(cursor flag = %d, hotspot = (%d,%d), type = %d)",
      *fCursor_ptr,
      *hot_spot_x_ptr, *hot_spot_y_ptr,
      *mouse_type_ptr);
#endif    //NEC_98
   }

/* Load acceleration curve from Intel memory to Host memory */
LOCAL void load_acceleration_curve IFN3
   (
   word, seg,   /* Pointer to Intel Memory */
   word, off,
   ACCELERATION_CURVE_DATA *, hcurve   /* Pointer to Host Memory */
   )
   {
#ifndef NEC_98
   int i, j;

   /* Read lengths */
   for (i = 0; i < NR_ACCL_CURVES; i++)
      {
      hcurve->ac_length[i] = sas_hw_at(effective_addr(seg, off));
      off++;
      }

   /* Read mickey counts */
   for (i = 0; i < NR_ACCL_CURVES; i++)
      {
      for (j = 0; j < NR_ACCL_MICKEY_COUNTS; j++)
         {
         hcurve->ac_count[i][j] = sas_hw_at(effective_addr(seg, off));
         off++;
         }
      }

   /* Read scale factors */
   for (i = 0; i < NR_ACCL_CURVES; i++)
      {
      for (j = 0; j < NR_ACCL_SCALE_FACTORS; j++)
         {
         hcurve->ac_scale[i][j] = sas_hw_at(effective_addr(seg, off));
         off++;
         }
      }

   /* Read names */
   for (i = 0; i < NR_ACCL_CURVES; i++)
      {
      for (j = 0; j < NR_ACCL_NAME_CHARS; j++)
         {
         hcurve->ac_name[i][j] = sas_hw_at(effective_addr(seg, off));
         off++;
         }
      }
#endif    //NEC_98
   }

/* Store acceleration curve from Host memory to Intel memory */
LOCAL void store_acceleration_curve IFN3
   (
   word, seg,   /* Pointer to Intel Memory */
   word, off,
   ACCELERATION_CURVE_DATA *, hcurve   /* Pointer to Host Memory */
   )
   {
#ifndef NEC_98
   int i, j;

   /* Write lengths */
   for (i = 0; i < NR_ACCL_CURVES; i++)
      {
      sas_store(effective_addr(seg, off), hcurve->ac_length[i]);
      off++;
      }

   /* Write mickey counts */
   for (i = 0; i < NR_ACCL_CURVES; i++)
      {
      for (j = 0; j < NR_ACCL_MICKEY_COUNTS; j++)
         {
         sas_store(effective_addr(seg, off), hcurve->ac_count[i][j]);
         off++;
         }
      }

   /* Write scale factors */
   for (i = 0; i < NR_ACCL_CURVES; i++)
      {
      for (j = 0; j < NR_ACCL_SCALE_FACTORS; j++)
         {
         sas_store(effective_addr(seg, off), hcurve->ac_scale[i][j]);
         off++;
         }
      }

   /* Write names */
   for (i = 0; i < NR_ACCL_CURVES; i++)
      {
      for (j = 0; j < NR_ACCL_NAME_CHARS; j++)
         {
         sas_store(effective_addr(seg, off), hcurve->ac_name[i][j]);
         off++;
         }
      }
#endif    //NEC_98
   }

LOCAL void mouse_load_acceleration_curves IFN4
   (
   word *, success_ptr,
   word *, curve_ptr,
   word *, m3,
   word *, m4
   )
   {
#ifndef NEC_98
   /*
      Func 43: Load Acceleration Curves.
    */

   word c_seg;
   word c_off;

   UNUSED(m3);
   UNUSED(m4);

   note_trace1(MOUSE_VERBOSE,
      "mouse_io: load_acceleration_curve(curve=%d)", *curve_ptr);

   /* Check reason for call */
   if ( *curve_ptr == MOUSE_M1 )
      {
      /* Reset to default acceleration curve */
      active_acceleration_curve = 3;   /* Back to Normal */

      memcpy(&acceleration_curve_data, &default_acceleration_curve,
         sizeof(ACCELERATION_CURVE_DATA));

      *success_ptr = 0;   /* Completed OK */
      }
   else
      {
      /* Load new curve */
      if ( *curve_ptr >= 1 && *curve_ptr <= 4 )
         {
         /* Valid curve number - load it. */
         active_acceleration_curve = *curve_ptr;

         c_seg = getES();   /* Pick up pointer to Intel Data */
         c_off = getSI();

         /* INTEL => HOST */
         load_acceleration_curve(c_seg, c_off, &acceleration_curve_data);

         *success_ptr = 0;   /* Completed OK */
         }
      else
         {
         /* Curve number out of range */
         *success_ptr = MOUSE_M1;
         }
      }

   note_trace1(MOUSE_VERBOSE, "mouse_io: return(success=0x%x)", *success_ptr);
#endif  //NEC_98
   }

LOCAL void mouse_read_acceleration_curves IFN4
   (
   word *, success_ptr,
   word *, curve_ptr,
   word *, m3,
   word *, m4
   )
   {
#ifndef NEC_98
   /*
      Func 44: Read Acceleration Curves.
    */

   word c_seg;
   word c_off;

   UNUSED(m3);
   UNUSED(m4);

   note_trace0(MOUSE_VERBOSE, "mouse_io: read_acceleration_curves");

   *success_ptr = 0;   /* Completed OK */

   *curve_ptr = (word)active_acceleration_curve;

   c_seg = getCS();   /* Set up pointer to Intel Buffer */
   c_off = OFF_ACCL_BUFFER;

   /* INTEL <= HOST */
   store_acceleration_curve(c_seg, c_off, &acceleration_curve_data);

   setES(c_seg);
   setSI(c_off);

   note_trace4(MOUSE_VERBOSE,
      "mouse_io: return(success=0x%x, curve=%d, seg=0x%x, off=0x%x)",
      *success_ptr, *curve_ptr, getES(), getSI());
#endif //NEC_98
   }

LOCAL void mouse_set_get_active_acceleration_curve IFN4
   (
   word *, success_ptr,
   word *, curve_ptr,
   word *, m3,
   word *, m4
   )
   {
#ifndef NEC_98
   /*
      Func 45: Set/Get Active Acceleration Curve.
    */

   word c_seg;
   word c_off;

   UNUSED(m3);
   UNUSED(m4);

   note_trace1(MOUSE_VERBOSE,
      "mouse_io: set_get_active_acceleration_curve(curve=%d)", *curve_ptr);

   /* Check reason for call */
   if ( *curve_ptr == MOUSE_M1 )
      {
      /* Return currently active curve */
      *curve_ptr = (word)active_acceleration_curve;
      *success_ptr = 0;   /* Completed OK */
      }
   else
      {
      /* Set new active curve */
      if ( *curve_ptr >= 1 && *curve_ptr <= 4 )
         {
         /* Valid curve number - make active */
         active_acceleration_curve = *curve_ptr;
         *success_ptr = 0;   /* Completed OK */
         }
      else
         {
         *curve_ptr = (word)active_acceleration_curve;
         *success_ptr = MOUSE_M2;   /* Failed */
         }
      }

   /* Return name to caller */
   c_seg = getCS();   /* Set up pointer to Intel Buffer */
   c_off = OFF_ACCL_BUFFER;

   /* INTEL <= HOST */
   store_acceleration_curve(c_seg, c_off, &acceleration_curve_data);

   /* adjust pointer to select correct name */
   c_off = c_off + 4 + (4*32) + (4*32);   /* length,count,scale */
   c_off = c_off + ((active_acceleration_curve-1) * 16);

   setES(c_seg);
   setSI(c_off);

   note_trace4(MOUSE_VERBOSE,
      "mouse_io: return(success=0x%x, curve=%d, seg=0x%x, off=0x%x)",
      *success_ptr, *curve_ptr, getES(), getSI());
#endif //NEC_98
   }

LOCAL void mouse_microsoft_internal IFN4
   (
   word *, m1,
   word *, m2,
   word *, m3,
   word *, m4
   )
   {
#ifndef NEC_98
   /*
      Func 46: Microsoft Internal. We don't support it.
    */

   UNUSED(m1);
   UNUSED(m2);
   UNUSED(m3);
   UNUSED(m4);

   note_trace0(MOUSE_VERBOSE, "mouse_io: microsoft_internal NOT SUPPORTED!");
#endif    //NEC_98
   }

LOCAL void mouse_hardware_reset IFN4
   (
   word *, status_ptr,
   word *, m2,
   word *, m3,
   word *, m4
   )
   {
#ifndef NEC_98
   /*
      Func 47: Reset the mouse hardware and display variables.
      This is not a full software reset as per Func 0 or Func 33.
    */

   half_word crt_mode;

   UNUSED(m2);
   UNUSED(m3);
   UNUSED(m4);

   note_trace0(MOUSE_VERBOSE, "mouse_io: hardware_reset");

   inport_reset();   /* reset hardware */

   /* Update variables which depend on display hardware */
   sas_load(MOUSE_VIDEO_CRT_MODE, &crt_mode);
   cursor_mode_change((int)crt_mode);
   cursor_update();

   if ( cursor_flag == MOUSE_CURSOR_DISPLAYED )
      cursor_display();

   *status_ptr = MOUSE_M1;   /* ie success */

   note_trace0(MOUSE_VERBOSE, "mouse_io: return()");
#endif    //NEC_98
   }

LOCAL void mouse_set_get_ballpoint_info IFN4
   (
   word *, status_ptr,
   word *, rotation_angle_ptr,
   word *, button_mask_ptr,
   word *, m4
   )
   {
#ifndef NEC_98
   /*
      Func 48: Get/Set Ballpoint Information.
      Note: We do not support a ballpoint device.
    */

   UNUSED(m4);

   note_trace0(MOUSE_VERBOSE, "mouse_io: set_get_ballpoint_info");

   if ( *button_mask_ptr == 0 ) /* Check command request */
      {
      /* Get Status (Angle and Mask) Command */
      ;
      }
   else
      {
      /* Set Status (Angle and Mask) Command */
      note_trace2(MOUSE_VERBOSE,
         "mouse_io: Rotation Angle = %d, Button Mask = %d",
         *rotation_angle_ptr,
         *button_mask_ptr);
      }

   *status_ptr = MOUSE_M1;   /* ie not supported */
   note_trace0(MOUSE_VERBOSE, "mouse_io: return(NOT_SUPPORTED)");
#endif    //NEC_98
   }

LOCAL void mouse_get_min_max_virtual_coords IFN4
   (
   MOUSE_SCALAR *, min_x_ptr,
   MOUSE_SCALAR *, min_y_ptr,
   MOUSE_SCALAR *, max_x_ptr,
   MOUSE_SCALAR *, max_y_ptr
   )
   {
#ifndef NEC_98
   /*
      Func 49: Return minimum and maximum virtual coordinates for
      current screen mode. The values are those set by Funcs 7 and 8.
    */

   note_trace0(MOUSE_VERBOSE, "mouse_io: get_min_max_virtual_coords");

   *min_x_ptr = cursor_window.top_left.x;
   *min_y_ptr = cursor_window.top_left.y;
   *max_x_ptr = cursor_window.bottom_right.x;
   *max_y_ptr = cursor_window.bottom_right.y;

   note_trace4(MOUSE_VERBOSE, "mouse_io: return(min=(%d,%d), max=(%d,%d))",
      *min_x_ptr, *min_y_ptr,
      *max_x_ptr, *max_y_ptr);
#endif    //NEC_98
   }

LOCAL void mouse_get_active_advanced_functions IFN4
   (
   word *, active_flag1_ptr,
   word *, active_flag2_ptr,
   word *, active_flag3_ptr,
   word *, active_flag4_ptr
   )
   {
#ifndef NEC_98
   /*
      Func 50: Get Active Advanced Functions, ie define which functions
      above or equal to 37 are supported.
    */

   note_trace0(MOUSE_VERBOSE, "mouse_io: get_active_advanced_functions");

   *active_flag1_ptr = 0x8000 |   /* Func 37 supported */
                       0x4000 |   /* Func 38 supported */
                       0x2000 |   /* Func 39 supported */
                       0x1000 |   /* Func 40 supported */
                       0x0800 |   /* Func 41 supported */
                       0x0400 |   /* Func 42 supported */
                       0x0200 |   /* Func 43 supported */
                       0x0100 |   /* Func 44 supported */
                       0x0080 |   /* Func 45 supported */
                       0x0000 |   /* Func 46 NOT supported */
                       0x0020 |   /* Func 47 supported */
                       0x0010 |   /* Func 48 supported */
                       0x0008 |   /* Func 49 supported */
                       0x0004 |   /* Func 50 supported */
                       0x0002 |   /* Func 51 supported */
                       0x0001;    /* Func 52 supported */

   /* No other (ie newer) functions are supported */
   *active_flag2_ptr = *active_flag3_ptr = *active_flag4_ptr = 0;

   note_trace4(MOUSE_VERBOSE, "mouse_io: return(active=%04x,%04x,%04x,%04x)",
      *active_flag1_ptr,
      *active_flag2_ptr,
      *active_flag3_ptr,
      *active_flag4_ptr);
#endif    //NEC_98
   }

LOCAL void mouse_get_switch_settings IFN4
   (
   word *, status_ptr,
   word *, m2,
   word *, buffer_length_ptr,
   word *, offset_ptr
   )
   {
#ifndef NEC_98
   /*
      Func 51: Get switch settings. Returns output buffer (340 bytes)
      with:-

        0       Mouse Type (low nibble)         0-5
                Mouse Port (high nibble)        0-4
        1       Language                        0-8
        2       Horizontal Sensitivity          0-100
        3       Vertical Sensitivity            0-100
        4       Double Threshold                0-100
        5       Ballistic Curve                 1-4
        6       Interrupt Rate                  1-4
        7       Cursor Override Mask            0-255
        8       Laptop Adjustment               0-255
        9       Memory Type                     0-2
        10      Super VGA Support               0-1
        11      Rotation Angle                  0-359
        13      Primary Button                  1-4
        14      Secondary Button                1-4
        15      Click Lock Enabled              0-1
        16      Acceleration Curve Data
    */

   word obuf_seg;
   word obuf_off;
   half_word mem_int_type;

   UNUSED(m2);

   note_trace3(MOUSE_VERBOSE,
      "mouse_io: get_switch_settings(seg=0x%04x,off=0x%04x,len=0x%x)",
      getES(), *offset_ptr, *buffer_length_ptr);

   if ( *buffer_length_ptr == 0 )
      {
      /* Undocumented method of just finding buffer size */
      *buffer_length_ptr = 340;
      }
   else
      {
      *buffer_length_ptr = 340;

      obuf_seg = getES();   /* Pick up pointer to output buffer */
      obuf_off = *offset_ptr;

      /* Store MouseType and MousePort(=0) */
      sas_store(effective_addr(obuf_seg, obuf_off),
         (half_word)MOUSE_TYPE_INPORT);

      /* Store Language (always 0) */
      sas_store(effective_addr(obuf_seg, (obuf_off + 1)),
         (half_word)0);

      /* Store Horizontal and Vertical Sensitivity */
      sas_store(effective_addr(obuf_seg, (obuf_off + 2)),
         (half_word)mouse_sens.x);

      sas_store(effective_addr(obuf_seg, (obuf_off + 3)),
         (half_word)mouse_sens.y);

      /* Store Double Threshold */
      sas_store(effective_addr(obuf_seg, (obuf_off + 4)),
         (half_word)mouse_double_thresh);

      /* Store Ballistic Curve */
      sas_store(effective_addr(obuf_seg, (obuf_off + 5)),
         (half_word)active_acceleration_curve);

      /* Store Interrupt Rate */
      sas_store(effective_addr(obuf_seg, (obuf_off + 6)),
         (half_word)mouse_interrupt_rate);

      /* Store Cursor Override Mask */
      sas_store(effective_addr(obuf_seg, (obuf_off + 7)),
         (half_word)0);   /* Microsoft Specific Feature? */

      /* Store Laptop Adjustment */
      sas_store(effective_addr(obuf_seg, (obuf_off + 8)),
         (half_word)0);   /* What is it? */

      /* Store Memory Type */
      /* NB 0 = Low, 1 = High, 2 = Extended */
      mem_int_type = 0;

      if ( getCS() >= 0xA000 )
         mem_int_type++;

      if ( getCS() == 0xFFFF )
         mem_int_type++;

      sas_store(effective_addr(obuf_seg, (obuf_off + 9)),
         mem_int_type);

      /* Store Super VGA Support. - We don't support fancy hardware cursor */
      sas_store(effective_addr(obuf_seg, (obuf_off + 10)),
         (half_word)0);

      /* Store Rotation Angle */
      sas_storew(effective_addr(obuf_seg, (obuf_off + 11)),
         (half_word)0);

      /* Store Primary Button */
      sas_store(effective_addr(obuf_seg, (obuf_off + 13)),
         (half_word)1);

      /* Store Secondary Button */
      sas_store(effective_addr(obuf_seg, (obuf_off + 14)),
         (half_word)3);

      /* Store Click Lock Enabled */
      sas_store(effective_addr(obuf_seg, (obuf_off + 15)),
         (half_word)0);   /* What is it? */

      /* Store Acceleration Curve Data */
      store_acceleration_curve(obuf_seg, (word)(obuf_off + 16),
         &acceleration_curve_data);
      }

   note_trace1(MOUSE_VERBOSE, "mouse_io: return(bytes_returned=0x%x)",
      *buffer_length_ptr);
#endif    //NEC_98
   }

LOCAL void mouse_get_mouse_ini IFN4
   (
   word *, status_ptr,
   word *, m2,
   word *, m3,
   word *, offset_ptr
   )
   {
#ifndef NEC_98
   /*
      Func 52: Return Segment:Offset pointer to full pathname of
      MOUSE.INI.
      NB. As we do not support MOUSE.INI a pointer to a null string is
      returned.
    */

   UNUSED(m2);
   UNUSED(m3);

   note_trace0(MOUSE_VERBOSE, "mouse_io: get_mouse_ini");

   *status_ptr = 0;

   *offset_ptr = OFF_MOUSE_INI_BUFFER;
   setES(getCS());

   note_trace2(MOUSE_VERBOSE, "mouse_io: return(seg=%04x,off=%04x)",
      getES(), *offset_ptr);
#endif    //NEC_98
   }

LOCAL void mouse_unrecognised IFN4(word *,m1,word *,m2,word *,m3,word *,m4)
{
        /*
         *      This function is called when an invalid mouse function
         *      number is found
         */
#ifndef PROD
        int function = *m1;

        UNUSED(m2);
        UNUSED(m3);
        UNUSED(m4);

        fprintf(trace_file,
                "mouse_io:unrecognised function(fn=%d)\n", function);
#else
        UNUSED(m1);
        UNUSED(m2);
        UNUSED(m3);
        UNUSED(m4);
#endif
}


LOCAL void mouse_set_double_speed IFN4(word *,junk1,word *,junk2,word *,junk3,word *,threshold_speed)
{
        /*
         *      This function sets the threshold speed at which the cursor's
         *      motion on the screen doubles
         */

        UNUSED(junk1);
        UNUSED(junk2);
        UNUSED(junk3);

        note_trace1(MOUSE_VERBOSE, "mouse_io:set_double_speed(speed=%d)",
                    *threshold_speed);

                /*
                 *      Save the double speed threshold value, converting from
                 *      Mickeys per second to a rounded Mickeys per timer interval
                 *      value
                 */
                double_speed_threshold =
                        (*threshold_speed + MOUSE_TIMER_INTERRUPTS_PER_SECOND/2) /
                                                MOUSE_TIMER_INTERRUPTS_PER_SECOND;

        note_trace0(MOUSE_VERBOSE, "mouse_io:return()");
}




/*
 *      MOUSE DRIVER VIDEO ADAPTER ACCESS FUNCTIONS
 *      ===========================================
 */

LOCAL MOUSE_BYTE_ADDRESS point_as_text_cell_address IFN1(MOUSE_POINT *,point_ptr)
{
#ifndef NEC_98
        /*
         *      Return the byte offset of the character in the text mode regen
         *      buffer corresponding to the virtual screen position
         *      "*point_ptr"
         */
        MOUSE_BYTE_ADDRESS byte_address;
        word crt_start;

        /*
         *      Get pc address for the start of video memory
         */
        sas_loadw(MOUSE_VIDEO_CRT_START, &crt_start);
        byte_address = (MOUSE_BYTE_ADDRESS)crt_start;

        /*
         *      Adjust for current video page
         */
        byte_address += cursor_page * video_page_size();

        /*
         *      Add offset contributions for the cursor's row and column
         */
        byte_address += (2*get_chars_per_line() * (point_ptr->y / cursor_grid.y));
        byte_address += (point_ptr->x / cursor_grid.x) * 2;

        return(byte_address);
#endif    //NEC_98
}

LOCAL MOUSE_BIT_ADDRESS point_as_graphics_cell_address IFN1(MOUSE_POINT *,point_ptr)
{
#ifndef NEC_98
        /*
         *      Return the bit offset of the pixel in the graphics mode regen
         *      buffer (odd or even) bank corresponding to the virtual screen
         *      position "*point_ptr"
         */
        IS32 bit_address;

        /*
         *      Get offset contributions for the cursor's row and column
         */
        bit_address = ((IS32)MOUSE_GRAPHICS_MODE_PITCH * (point_ptr->y / 2)) + point_ptr->x;

        /*
         *      Adjust for current video page
         */
        bit_address += (IS32)cursor_page * (IS32)video_page_size() * 8L;

        return(bit_address);
#endif    //NEC_98
}

#ifdef HERC
LOCAL MOUSE_BIT_ADDRESS point_as_HERC_graphics_cell_address IFN1(MOUSE_POINT *,point_ptr)
{
        IMPORT half_word herc_page;

        /*
         *      Return the bit offset of the pixel in the graphics mode regen
         *      buffer (0, 1, 2, 3) bank corresponding to the virtual screen
         *      position "*point_ptr"
         */
        IS32 bit_address;

        /*
         *      Get offset contributions for the cursor's row and column
         */
        bit_address = ((IS32)720 * (point_ptr->y / 4)) + point_ptr->x;

        /*
         *      Adjust for current video page - note that for 100% correct emulation,
         *      we should read location 40:49 (the BIOS video mode)... hercules
         *      applications put a 6 here to indicate page 0 and a 5 for page 1.
         *      To avoid a performance penalty the global herc_page is used instead;
         *      this will have the side effect of making application which try to
         *      set the mouse pointer to the non-displayed page not succeed in doing so.
         */
        if (herc_page != 0){
                bit_address += 0x8000L * 8L;
        }

        return(bit_address);
}
#endif /* HERC */

LOCAL MOUSE_BIT_ADDRESS ega_point_as_graphics_cell_address IFN1(MOUSE_POINT *,point_ptr)
{
#ifndef NEC_98
        /*
         *      Return the bit offset of the pixel in the graphics mode regen
         *      buffer corresponding to the virtual screen position "*point_ptr"
         */
        MOUSE_BIT_ADDRESS bit_address;
        UTINY   video_mode = sas_hw_at(vd_video_mode);

        /*
         *      Get offset contributions for the cursor's row and column
         */
#ifdef V7VGA
        if (video_mode >= 0x40)
                bit_address = (get_bytes_per_line() * 8 * point_ptr->y) + point_ptr->x;
        else
#endif /* V7VGA */
        switch(video_mode)
        {
        case 0xd :
            bit_address = (get_actual_offset_per_line() * 8 * point_ptr->y) + point_ptr->x / 2;
            break;
        case 0x13 :
            bit_address = (get_bytes_per_line() * 1 * point_ptr->y) + point_ptr->x / 2;
            break;
        default:
            bit_address = (get_actual_offset_per_line() * 8 * point_ptr->y) + point_ptr->x;
        }

        /*
         *      Adjust for current video page
         */
        bit_address += cursor_page * video_page_size() * 8;

        return(bit_address);
#endif   //NEC_98
}


LOCAL void cursor_update IFN0()
{
#ifndef NTVDM
        /*
         *      This function is used to update the displayed cursor
         *      position on the screen following a change to the
         *      absolute position of the cursor
         */

        point_coerce_to_area(&cursor_position, &cursor_window);
        point_copy(&cursor_position, &cursor_status.position);
        point_coerce_to_grid(&cursor_status.position, &cursor_grid);

        if (host_mouse_in_use())
                host_mouse_set_position(cursor_status.position.x * mouse_gear.x * mouse_sens.x / 800,
                                                                cursor_status.position.y * mouse_gear.y * mouse_sens.y / 800);

#endif
}




LOCAL void cursor_display IFN0()
{
#ifndef NEC_98
#ifndef NTVDM
        UTINY v_mode;

        /* Check if Enhanced Mode wants to "see" cursor */
        if ( cursor_EM_disabled )
           return;

        /*
         *      Display a representation of the current mouse status on
         *      the screen
         */

        v_mode = sas_hw_at(vd_video_mode);

#ifdef  MOUSE_16_BIT
        if (is_graphics_mode)
                return;
#endif  /* MOUSE_16_BIT */

        /*
         *      Remove the old representation of the
         *      cursor from the display
         */
        cursor_undisplay();

#ifdef EGG
        if (jap_mouse) {
        /* So far DOS has had its way, but now we have to map the current
         * cursor position in terms of mode 3 onto a mode 0x12 display.
         * Go direct 'cos the selection process gets confused below...
         */
                EGA_graphics_cursor_display();
        } else
#endif /* EGG */

        if (in_text_mode())
        {
                if (text_cursor_type == MOUSE_TEXT_CURSOR_TYPE_SOFTWARE)
                {
                        software_text_cursor_display();
                }
                else
                {
                        hardware_text_cursor_display();
                }
        }
        else
        {
#ifdef MOUSE_16_BIT
        mouse16bShowPointer( );
#else /* MOUSE_16_BIT */
                if (host_mouse_installed())
                {
                        if ( cursor_position.x >= black_hole.top_left.x &&
                                        cursor_position.x <= black_hole.bottom_right.x &&
                                        cursor_position.y >= black_hole.top_left.y &&
                                        cursor_position.y <= black_hole.bottom_right.y )
                                host_mouse_cursor_undisplay();
                        else
                                host_mouse_cursor_display();
                }
                else
                {
#ifdef EGG
                        if ((video_adapter == EGA  || video_adapter == VGA) && (v_mode > 6))
                        {
#ifdef VGG
                                if (v_mode != 0x13)
                                        EGA_graphics_cursor_display();
                                else
                                        VGA_graphics_cursor_display();
#else
                                EGA_graphics_cursor_display();
#endif /* VGG */
                        }
                        else
#endif
#ifdef HERC
                        if (video_adapter == HERCULES)
                                HERC_graphics_cursor_display();
                        else
#endif /* HERC */
                                graphics_cursor_display();
                }
#endif /* MOUSE_16_BIT */
        }

        /*
         *      Ensure the cursor is updated immediately on the real screen:
         *      this gives a "smooth" response to the mouse even on ports that
         *      don't automatically update the screen regularly
         */
        host_flush_screen();
#endif /* !NTVDM */
#endif   //NEC_98
}




LOCAL void cursor_undisplay IFN0()
{
#ifndef NEC_98
#ifndef NTVDM
        UTINY v_mode;

        /* Check if Enhanced Mode wants to "see" cursor */
        if ( cursor_EM_disabled )
           return;

        v_mode = sas_hw_at(vd_video_mode);

#ifdef  MOUSE_16_BIT
        if (is_graphics_mode)
                return;
#endif  /* MOUSE_16_BIT */

        /*
         *      Undisplay the representation of the current mouse status on
         *      the screen. This routine tolerates being called when the
         *      cursor isn't actually being displayed
         */
        if (host_mouse_in_use())
        {
                host_mouse_cursor_undisplay();
        }
        else
        {
                if (save_area_in_use)
                {
                        save_area_in_use = FALSE;

#ifdef EGG
        if (jap_mouse) {
                /* If we forced an EGA cursor, we must undisplay the same.
                 * Go direct 'cos the selection process gets confused below...
                 */
                EGA_graphics_cursor_undisplay();
        } else
#endif /* EGG */

                        if (in_text_mode())
                        {
                                if (text_cursor_type == MOUSE_TEXT_CURSOR_TYPE_SOFTWARE)
                                {
                                        software_text_cursor_undisplay();
                                }
                                else
                                {
                                        hardware_text_cursor_undisplay();
                                }
                        }
                        else
                        {
#ifdef MOUSE_16_BIT
                                mouse16bHidePointer( );
#else /* MOUSE_16_BIT */
#ifdef EGG
                        if ((video_adapter == EGA  || video_adapter == VGA) && (v_mode > 6))
                        {
#ifdef VGG
                                if (v_mode != 0x13)
                                EGA_graphics_cursor_undisplay();
                                else
                                        VGA_graphics_cursor_undisplay();
#else
                                EGA_graphics_cursor_undisplay();
#endif
                        }
                        else
#endif
#ifdef HERC
                          if (video_adapter == HERCULES)
                            HERC_graphics_cursor_undisplay();
                          else
#endif /* HERC */
                            graphics_cursor_undisplay();
#endif /* MOUSE_16_BIT */
                        }
                }
        }
#endif /* !NTVDM */
#endif   //NEC_98
}




LOCAL void cursor_mode_change IFN1(int,new_mode)
{
        /*
         *      Update parameters that are dependent on the screen mode
         *      in force
         */
#ifdef V7VGA
        if (new_mode >= 0x40)
                if (new_mode >= 0x60)
                {
                        point_copy(&v7graph_cursor_grids[new_mode-0x60], &cursor_grid);
                        point_copy(&v7graph_text_grids[new_mode-0x60], &text_grid);
                }
                else
                {
                        point_copy(&v7text_cursor_grids[new_mode-0x40], &cursor_grid);
                        point_copy(&v7text_text_grids[new_mode-0x40], &text_grid);
                }
        else
#endif /* V7VGA */
        {
                point_copy(&cursor_grids[new_mode], &cursor_grid);
                point_copy(&text_grids[new_mode], &text_grid);
        }
        /*
         *      Always set page to zero
         */
        cursor_page = 0;

        if (host_mouse_in_use())
                host_mouse_cursor_mode_change();
}




GLOBAL void software_text_cursor_display IFN0()
{
#ifndef NEC_98
        /*
         *      Get the area the cursor will occupy on the
         *      screen, and display the cursor if its area
         *      overlaps the virtual screen and lies completely
         *      outside the conditional off area
         */
        MOUSE_AREA cursor_area;
        MOUSE_BYTE_ADDRESS text_address;

        /*
         *      Get area cursor will cover on screen
         */
        point_copy(&cursor_status.position, &cursor_area.top_left);
        point_copy(&cursor_status.position, &cursor_area.bottom_right);
        point_translate(&cursor_area.bottom_right, &cursor_grid);

        if (    area_is_intersected_by_area(&virtual_screen, &cursor_area)
            && !area_is_intersected_by_area(&black_hole, &cursor_area))
        {
                /*
                 *      Get new address for text cursor
                 *      Should we look at video mode? Or is 0xb8000 OK?
                 */
                text_address = 0xb8000 + sas_w_at(VID_ADDR) +
                        point_as_text_cell_address(&cursor_area.top_left);

                /*
                 *      Save area text cursor will cover
                 */
                sas_loadw(text_address, &text_cursor_background);
                save_area_in_use = TRUE;
                point_copy(&cursor_area.top_left, &save_position);

                /*
                 *      Stuff masked screen data
                 */
                sas_storew(text_address,
                    (IU16)((text_cursor_background & software_text_cursor.screen) ^
                        software_text_cursor.cursor));
        }
#endif    //NEC_98
}




GLOBAL void software_text_cursor_undisplay IFN0()
{
#ifndef NEC_98
        /*
         *      Remove old text cursor
         *      Should we look at video mode? Or is 0xb8000 OK?
         */
        MOUSE_BYTE_ADDRESS text_address;

        text_address = 0xb8000 + sas_w_at(VID_ADDR) +
                point_as_text_cell_address(&save_position);

        /*
         *      Stuff restored data and alert gvi
         */
        sas_storew(text_address, text_cursor_background);
#endif    //NEC_98
}




GLOBAL void hardware_text_cursor_display IFN0()
{
        /*
         *      Display a representation of the current mouse status on
         *      the screen using the hardware text cursor, provided the
         *      cursor overlaps the virtual screen. Since the hardware
         *      cursor display does not corrupt the Intel memory, it
         *      doesn't matter if the hardware cursor lies inside the
         *      conditional off area
         */
        MOUSE_AREA cursor_area;
        MOUSE_BYTE_ADDRESS text_address;
        word card_address;

        /*
         *      Get area cursor will cover on screen
         */
        point_copy(&cursor_status.position, &cursor_area.top_left);
        point_copy(&cursor_status.position, &cursor_area.bottom_right);
        point_translate(&cursor_area.bottom_right, &cursor_grid);

        if (area_is_intersected_by_area(&virtual_screen, &cursor_area))
        {
                /*
                 *      Get address of the base register on the active display
                 *      adaptor card
                 */
                sas_loadw(MOUSE_VIDEO_CARD_BASE, &card_address);

                /*
                 *      Get word offset of cursor position in the text mode
                 *      regen buffer
                 */
                text_address =
                        point_as_text_cell_address(&cursor_status.position) / 2;

                /*
                 *      Output the cursor address high byte
                 */
                outb(card_address++, MOUSE_CURSOR_HIGH_BYTE);
                outb(card_address--, (IU8)(text_address >> 8));

                /*
                 *      Output the cursor address low byte
                 */
                outb(card_address++, MOUSE_CURSOR_LOW_BYTE);
                outb(card_address--, (IU8)(text_address));
        }
}




GLOBAL void hardware_text_cursor_undisplay IFN0()
{
        /*
         *      Nothing to do
         */
}


#ifdef EGG
void LOCAL EGA_graphics_cursor_display IFN0()

{
#ifndef NEC_98
#ifdef REAL_VGA
#ifndef PROD
        if (io_verbose & MOUSE_VERBOSE)
            fprintf(trace_file, "oops - EGA graphics display cursor\n");
#endif /* PROD */
#else
        /*
         *      Display a representation of the current mouse status on
         *      the screen using the graphics cursor, provided the
         *      cursor overlaps the virtual screen and lies completely
         *      outside the conditional off area
         */
        MOUSE_BIT_ADDRESS bit_shift;
        MOUSE_BYTE_ADDRESS byte_offset;
        int line, line_max;
        int byte_min, byte_max;
        IU32 strip_lo, strip_mid, strip_hi;
        IU32 mask_lo, mask_hi;

        MOUSE_SCALAR saved_cursor_pos;
        MOUSE_SCALAR saved_bottom_right;

        if (jap_mouse) {
                /* fake up the mode 0x12 cursor position, saving original */
                saved_cursor_pos=cursor_status.position.y;
                saved_bottom_right=virtual_screen.bottom_right.y;

                cursor_status.position.y = saved_cursor_pos * 19 / 8;
                virtual_screen.bottom_right.y = virtual_screen.bottom_right.y * 19 / 8;
        }

        /*
         *      Get area cursor will cover on screen
         */
        point_copy(&cursor_status.position, &save_area.top_left);
        point_copy(&cursor_status.position, &save_area.bottom_right);
        point_translate(&save_area.bottom_right, &graphics_cursor.size);
        point_translate_back(&save_area.top_left, &graphics_cursor.hot_spot);
        point_translate_back(&save_area.bottom_right, &graphics_cursor.hot_spot);

        if (    area_is_intersected_by_area(&virtual_screen, &save_area)
            && !area_is_intersected_by_area(&black_hole, &save_area))
        {
                /*
                 *      Record save position and screen area
                 */
                save_area_in_use = TRUE;
                area_coerce_to_area(&save_area, &virtual_screen);
                point_copy(&save_area.top_left, &save_position);

                /*
                 *      Get cursor byte offset relative to the start of the
                 *      regen buffer, and bit shift to apply
                 */
                byte_offset = ega_point_as_graphics_cell_address(&save_position);
                bit_shift = byte_offset & 7;
                byte_offset /=  8;

                /*
                 *      Get range of cursor lines that need to be displayed
                 */
                line = save_area.top_left.y - save_position.y;
                line_max = area_depth(&save_area);
                /*
                 *      Get range of bytes that need to be displayed
                 */
                byte_min = 0;
                byte_max = 2;
                if (save_position.x < 0)
                        byte_min += (7 - save_position.x) / 8;
                else
                        if (area_width(&save_area) < MOUSE_GRAPHICS_CURSOR_WIDTH)
                                byte_max -=
                                        (8 + MOUSE_GRAPHICS_CURSOR_WIDTH - area_width(&save_area)) / 8;

                if( bit_shift )
                {
                        mask_lo = 0xff >> bit_shift;
                        mask_lo = ( mask_lo << 8 ) | mask_lo;
                        mask_lo = ~(( mask_lo << 16 ) | mask_lo);

                        mask_hi = 0xff >> bit_shift;
                        mask_hi = ( mask_hi << 8 ) | mask_hi;
                        mask_hi = ( mask_hi << 16 ) | mask_hi;
                }

                while (line < line_max)
                {
                        if (bit_shift)
                        {
                                /*
                                 *      Get save area
                                 */

                                ega_backgrnd_lo[line] = *( (IU32 *) EGA_planes + byte_offset );
                                ega_backgrnd_mid[line] = *( (IU32 *) EGA_planes + byte_offset + 1 );
                                ega_backgrnd_hi[line] = *( (IU32 *) EGA_planes + byte_offset + 2 );

                                /*
                                 *      Overlay cursor line
                                 */


                                strip_lo = ega_backgrnd_lo[line] & mask_lo;

                                strip_lo |= ~mask_lo & (( ega_backgrnd_lo[line]
                                                        & ( graphics_cursor.screen_lo[line] >> bit_shift ))
                                                        ^ ( graphics_cursor.cursor_lo[line] >> bit_shift ));

                                strip_mid = ~mask_hi & (( ega_backgrnd_mid[line]
                                                        & ( graphics_cursor.screen_lo[line] << (8 - bit_shift) ))
                                                        ^ ( graphics_cursor.cursor_lo[line] << (8 - bit_shift) ));

                                strip_mid |= ~mask_lo & (( ega_backgrnd_mid[line]
                                                        & ( graphics_cursor.screen_hi[line] >> bit_shift ))
                                                        ^ ( graphics_cursor.cursor_hi[line] >> bit_shift ));

                                strip_hi = ega_backgrnd_hi[line] & mask_hi;

                                strip_hi |= ~mask_hi & (( ega_backgrnd_hi[line]
                                                        & ( graphics_cursor.screen_hi[line] << (8 - bit_shift) ))
                                                        ^ ( graphics_cursor.cursor_hi[line] << (8 - bit_shift) ));

                                if (byte_min <= 0 && byte_max >= 0)
                                        *((IU32 *) EGA_planes + byte_offset) = strip_lo;

                                if (byte_min <= 1 && byte_max >= 1)
                                        *((IU32 *) EGA_planes + byte_offset + 1) = strip_mid;

                                if (byte_min <= 2 && byte_max >= 2)
                                        *((IU32 *) EGA_planes + byte_offset + 2) = strip_hi;
                        }
                        else
                        {
                                /*
                                 *      Get save area
                                 */

                                ega_backgrnd_lo[line] = *( (IU32 *) EGA_planes + byte_offset );
                                ega_backgrnd_hi[line] = *( (IU32 *) EGA_planes + byte_offset + 1 );

                                /*
                                 *      Create overlaid cursor line
                                 */

                                strip_lo = (ega_backgrnd_lo[line] &
                                                    graphics_cursor.screen_lo[line]) ^
                                                    graphics_cursor.cursor_lo[line];

                                strip_hi = (ega_backgrnd_hi[line] &
                                                    graphics_cursor.screen_hi[line]) ^
                                                    graphics_cursor.cursor_hi[line];

                                /*
                                 *      Draw cursor line
                                 */

                                if (byte_min <= 0 && byte_max >= 0)
                                {
                                        *((IU32 *) EGA_planes + byte_offset) = strip_lo;
                                }

                                if (byte_min <= 1 && byte_max >= 1)
                                {
                                        *((IU32 *) EGA_planes + byte_offset + 1) = strip_hi;
                                }

                        }

                        update_alg.mark_string(byte_offset, byte_offset + 2);
#ifdef V7VGA
                        if (sas_hw_at(vd_video_mode) >= 0x40)
                                byte_offset += get_bytes_per_line();
                        else
#endif /* V7VGA */
                                byte_offset += get_actual_offset_per_line();
                        line++;
                }
                if (jap_mouse) {
                        /* put things back how they should be */
                        cursor_status.position.y = saved_cursor_pos;
                        virtual_screen.bottom_right.y = saved_bottom_right;
                }
        }
#endif /* REAL_VGA */
#endif   //NEC_98
}


void LOCAL EGA_graphics_cursor_undisplay IFN0()

{
#ifndef NEC_98
#ifdef REAL_VGA
#ifndef PROD
        if (io_verbose & MOUSE_VERBOSE)
            fprintf(trace_file, "oops - EGA graphics undisplay cursor\n");
#endif /* PROD */
#else
        /*
         *      Remove the graphics cursor representation of the mouse
         *      status
         */
        MOUSE_BIT_ADDRESS bit_shift;
        MOUSE_BYTE_ADDRESS byte_offset;
        int line, line_max;
        int byte_min, byte_max;

        /*
         *      Get cursor byte offset relative to the start of the
         *      even or odd bank, and bit shift to apply
         */
        byte_offset = ega_point_as_graphics_cell_address(&save_position);
        bit_shift = byte_offset & 7;
        byte_offset /=  8;

        /*
         *      Get range of cursor lines that need to be displayed
         */
        line = save_area.top_left.y - save_position.y;
        line_max = area_depth(&save_area);

        /*
         *      Get range of bytes that need to be displayed
         */
        byte_min = 0;
        byte_max = 2;
        if (save_position.x < 0)
                byte_min += (7 - save_position.x) / 8;
        else if (area_width(&save_area) < MOUSE_GRAPHICS_CURSOR_WIDTH)
                byte_max -= (8 + MOUSE_GRAPHICS_CURSOR_WIDTH - area_width(&save_area)) / 8;

        while(line < line_max)
        {
                /*
                 *      Draw saved area
                 */

                if (bit_shift)
                {
                        if (byte_min <= 0 && byte_max >= 0)
                                *((IU32 *) EGA_planes + byte_offset) = ega_backgrnd_lo[line];

                        if (byte_min <= 1 && byte_max >= 1)
                                *((IU32 *) EGA_planes + byte_offset + 1) = ega_backgrnd_mid[line];

                        if (byte_min <= 2 && byte_max >= 2)
                                *((IU32 *) EGA_planes + byte_offset + 2) = ega_backgrnd_hi[line];
                }
                else
                {
                        if (byte_min <= 0 && byte_max >= 0)
                                *((IU32 *) EGA_planes + byte_offset) = ega_backgrnd_lo[line];

                        if (byte_min <= 1 && byte_max >= 1)
                                *((IU32 *) EGA_planes + byte_offset + 1) = ega_backgrnd_hi[line];
                }

                update_alg.mark_string(byte_offset, byte_offset + 2);
#ifdef V7VGA
                if (sas_hw_at(vd_video_mode) >= 0x40)
                        byte_offset += get_bytes_per_line();
                else
#endif /* V7VGA */
                        byte_offset += get_actual_offset_per_line();
                line++;
        }
#endif /* REAL_VGA */
#endif   //NEC_98
}

#endif


#ifdef VGG
LOCAL VOID      VGA_graphics_cursor_display IFN0()
{
#ifdef REAL_VGA
#ifndef PROD
        if (io_verbose & MOUSE_VERBOSE)
            fprintf(trace_file, "oops - VGA graphics display cursor\n");
#endif /* PROD */
#else /* REAL_VGA */

        MOUSE_BYTE_ADDRESS byte_offset;
        SHORT line, line_max, index;
        SHORT index_max = MOUSE_GRAPHICS_CURSOR_WIDTH;
        USHORT scr_strip, cur_strip;
        UTINY scr_byte, cur_byte;
        USHORT mask;


        /*
         *      Get area cursor will cover on screen
         */
        point_copy(&cursor_status.position, &save_area.top_left);
        point_copy(&cursor_status.position, &save_area.bottom_right);
        point_translate(&save_area.bottom_right, &graphics_cursor.size);
        point_translate_back(&save_area.top_left, &graphics_cursor.hot_spot);
        point_translate_back(&save_area.bottom_right, &graphics_cursor.hot_spot);

        if (    area_is_intersected_by_area(&virtual_screen, &save_area)
            && !area_is_intersected_by_area(&black_hole, &save_area))
        {
                /*
                 *      Record save position and screen area
                 */
                save_area_in_use = TRUE;
                area_coerce_to_area(&save_area, &virtual_screen);
                point_copy(&save_area.top_left, &save_position);

                /*
                 *      Get cursor byte offset relative to the start of the
                 *      regen buffer, and bit shift to apply
                 */
                byte_offset = ega_point_as_graphics_cell_address(&save_position);
        /*
         *  Get range of cursor lines that need to be displayed
         */
        line = save_area.top_left.y - save_position.y;
        line_max = area_depth(&save_area);

                if (area_width(&save_area) < MOUSE_GRAPHICS_CURSOR_WIDTH)
                        index_max = (area_width(&save_area));

                while (line < line_max)
                {
                        mask = 0x8000;

                        for(index=0;index<index_max;index++)
                        {
                                vga_background[line][index] = *(EGA_planes + byte_offset + index);
                                scr_strip = graphics_cursor.screen[line] & mask;
                                cur_strip = graphics_cursor.cursor[line] & mask;
                                if (scr_strip)
                                        scr_byte = 0xff;
                                else
                                        scr_byte = 0x0;

                                if (cur_strip)
                                        cur_byte = 0x0f;
                                else
                                        cur_byte = 0x0;

                                /*
                                 * Draw cursor byte
                                 */
                                *(EGA_planes + byte_offset + index) =
                                        ( vga_background[line][index] & scr_byte) ^ cur_byte;

                                mask >>= 1;
                        }

                        update_alg.mark_string(byte_offset, byte_offset+index);
                        line++;
                        byte_offset += get_bytes_per_line();

                }
        }
#endif /* REAL_VGA */
}

LOCAL VOID      VGA_graphics_cursor_undisplay IFN0()
{
#ifdef REAL_VGA
#ifndef PROD
        if (io_verbose & MOUSE_VERBOSE)
            fprintf(trace_file, "oops - VGA graphics undisplay cursor\n");
#endif /* PROD */
#else /* REAL_VGA */

        /*
         *      Remove the graphics cursor representation of the mouse
         *      status
         */
        MOUSE_BYTE_ADDRESS byte_offset;
        SHORT index;
        SHORT index_max = MOUSE_GRAPHICS_CURSOR_WIDTH;
        int line, line_max;

        /*
         *      Get cursor byte offset relative to the start of the EGA memory
         */

        byte_offset = ega_point_as_graphics_cell_address(&save_position);

        /*
         *      Get range of cursor lines that need to be displayed
         */
        line = save_area.top_left.y - save_position.y;
        line_max = area_depth(&save_area);

        if (area_width(&save_area) < MOUSE_GRAPHICS_CURSOR_WIDTH)
                index_max = (area_width(&save_area));

        /*
         *      Get range of bytes that need to be displayed
         */
        while (line < line_max)
        {
                for (index=0;index<index_max;index++)
                        *(EGA_planes + byte_offset + index) = vga_background[line][index];


                update_alg.mark_string(byte_offset, byte_offset+index);
                line++;
                byte_offset += get_bytes_per_line();
        }

#endif /* REAL_VGA */
}

#endif /* VGG */


LOCAL void graphics_cursor_display IFN0()
{
        /*
         *      Display a representation of the current mouse status on
         *      the screen using the graphics cursor, provided the
         *      cursor overlaps the virtual screen and lies completely
         *      outside the conditional off area
         */
        boolean even_scan_line;
        MOUSE_BIT_ADDRESS bit_shift;
        IS32 byte_offset;
        sys_addr byte_address;
        IU32 strip;
        int line, line_max;
        int byte_min, byte_max;

        /*
         *      Get area cursor will cover on screen
         */
        point_copy(&cursor_status.position, &save_area.top_left);
        point_copy(&cursor_status.position, &save_area.bottom_right);
        point_translate(&save_area.bottom_right, &graphics_cursor.size);
        point_translate_back(&save_area.top_left, &graphics_cursor.hot_spot);
        point_translate_back(&save_area.bottom_right, &graphics_cursor.hot_spot);

        if (    area_is_intersected_by_area(&virtual_screen, &save_area)
            && !area_is_intersected_by_area(&black_hole, &save_area))
        {
                /*
                 *      Record save position and screen area
                 */
                save_area_in_use = TRUE;
                point_copy(&save_area.top_left, &save_position);
                area_coerce_to_area(&save_area, &virtual_screen);

                /*
                 *      Get cursor byte offset relative to the start of the
                 *      even or odd bank, and bit shift to apply
                 */
                even_scan_line = ((save_area.top_left.y % 2) == 0);
                byte_offset = point_as_graphics_cell_address(&save_position);
                bit_shift = byte_offset & 7;
                byte_offset >>= 3;

                /*
                 *      Get range of cursor lines that need to be displayed
                 */
                line = save_area.top_left.y - save_position.y;
                line_max = area_depth(&save_area);

                /*
                 *      Get range of bytes that need to be displayed
                 */
                byte_min = 0;
                byte_max = 2;
                if (save_position.x < 0)
                        byte_min += (7 - save_position.x) / 8;
                else if (area_width(&save_area) < MOUSE_GRAPHICS_CURSOR_WIDTH)
                        byte_max -= (8 + MOUSE_GRAPHICS_CURSOR_WIDTH - area_width(&save_area)) / 8;

                while (line < line_max)
                {
                        if (even_scan_line)
                        {
                                even_scan_line = FALSE;
                                byte_address = EVEN_START + byte_offset;
                        }
                        else
                        {
                                even_scan_line = TRUE;
                                byte_address = ODD_START + byte_offset;
                                byte_offset += MOUSE_GRAPHICS_MODE_PITCH / 8;
                        }

                        if (bit_shift)
                        {
                                /*
                                 *      Get save area
                                 */
                                strip =  (IU32)sas_hw_at(byte_address) << 16;
                                strip |= (unsigned short)sas_hw_at(byte_address+1) << 8;
                                strip |= sas_hw_at(byte_address+2);
                                graphics_cursor_background[line] =
                                                (USHORT)(strip >> (8 - bit_shift));

                                /*
                                 *      Overlay cursor line
                                 */
                                strip &= (SHIFT_VAL >> bit_shift);
                                strip |= (IU32)((graphics_cursor_background[line] &
                                    graphics_cursor.screen[line]) ^
                                    graphics_cursor.cursor[line])
                                                << (8 - bit_shift);

                                /*
                                 *      Stash cursor line
                                 */
                                if (byte_min <= 0 && byte_max >= 0)
                                {
                                        sas_store(byte_address, (IU8)(strip >> 16));
                                }
                                if (byte_min <= 1 && byte_max >= 1)
                                {
                                        sas_store(byte_address+1, (IU8)(strip >> 8));
                                }
                                if (byte_min <= 2 && byte_max >= 2)
                                {
                                        sas_store(byte_address+2, (IU8)(strip));
                                }
                        }
                        else
                        {
                                /*
                                 *      Get save area
                                 */
                                graphics_cursor_background[line] = (sas_hw_at(byte_address) << 8) + sas_hw_at(byte_address+1);

                                /*
                                 *      Get overlaid cursor line
                                 */
                                strip = (graphics_cursor_background[line] &
                                    graphics_cursor.screen[line]) ^
                                    graphics_cursor.cursor[line];

                                /*
                                 *      Stash cursor line and alert gvi
                                 */
                                if (byte_min <= 0 && byte_max >= 0)
                                {
                                        sas_store(byte_address, (IU8)(strip >> 8));
                                }
                                if (byte_min <= 1 && byte_max >= 1)
                                {
                                        sas_store(byte_address+1, (IU8)(strip));
                                }
                        }
                        line++;
                }
        }
}


#ifdef HERC
LOCAL void HERC_graphics_cursor_display IFN0()
{
        /*
         *      Display a representation of the current mouse status on
         *      the screen using the graphics cursor, provided the
         *      cursor overlaps the virtual screen and lies completely
         *      outside the conditional off area
         */
        int scan_line_mod;
        MOUSE_BIT_ADDRESS bit_shift;
        IS32 byte_offset;
        sys_addr byte_address;
        IU32 strip;
        int line, line_max;
        int byte_min, byte_max;

        /*
         *      Get area cursor will cover on screen
         */
        point_copy(&cursor_status.position, &save_area.top_left);
        point_copy(&cursor_status.position, &save_area.bottom_right);
        point_translate(&save_area.bottom_right, &graphics_cursor.size);
        point_translate_back(&save_area.top_left, &graphics_cursor.hot_spot);
        point_translate_back(&save_area.bottom_right, &graphics_cursor.hot_spot);

        if (    area_is_intersected_by_area(&HERC_graphics_virtual_screen, &save_area)
            && !area_is_intersected_by_area(&black_hole, &save_area))
        {
                /*
                 *      Record save position and screen area
                 */
                save_area_in_use = TRUE;
                point_copy(&save_area.top_left, &save_position);
                area_coerce_to_area(&save_area, &HERC_graphics_virtual_screen);

                /*
                 *      Get cursor byte offset relative to the start of the
                 *      even or odd bank, and bit shift to apply
                 */
                scan_line_mod = save_area.top_left.y % 4;
                byte_offset = point_as_HERC_graphics_cell_address(&save_position);
                bit_shift = byte_offset & 7;
                byte_offset >>= 3;

                /*
                 *      Get range of cursor lines that need to be displayed
                 */
                line = save_area.top_left.y - save_position.y;
                line_max = area_depth(&save_area);

                /*
                 *      Get range of bytes that need to be displayed
                 */
                byte_min = 0;
                byte_max = 2;
                if (save_position.x < 0)
                        byte_min += (7 - save_position.x) / 8;
                else if (area_width(&save_area) < MOUSE_GRAPHICS_CURSOR_WIDTH)
                        byte_max -= (8 + MOUSE_GRAPHICS_CURSOR_WIDTH - area_width(&save_area)) / 8;

                while (line < line_max)
                {
                        switch (scan_line_mod){
                        case 0:
                                scan_line_mod++;
                                byte_address = gvi_pc_low_regen + 0x0000 + byte_offset;
                                break;
                        case 1:
                                scan_line_mod++;
                                byte_address = gvi_pc_low_regen + 0x2000 + byte_offset;
                                break;
                        case 2:
                                scan_line_mod++;
                                byte_address = gvi_pc_low_regen + 0x4000 + byte_offset;
                                break;
                        case 3:
                                scan_line_mod=0;
                                byte_address = gvi_pc_low_regen + 0x6000 + byte_offset;
                                byte_offset += 720 / 8;
                                break;
                        }

                        if (bit_shift)
                        {
                                /*
                                 *      Get save area
                                 */
                                strip =  (IU32)sas_hw_at(byte_address) << 16;
                                strip |= (unsigned short)sas_hw_at(byte_address+1) << 8;
                                strip |= sas_hw_at(byte_address+2);
                                graphics_cursor_background[line] =
                                                strip >> (8 - bit_shift);

                                /*
                                 *      Overlay cursor line
                                 */
                                strip &= (SHIFT_VAL >> bit_shift);
                                strip |= (IU32)((graphics_cursor_background[line] &
                                    graphics_cursor.screen[line]) ^
                                    graphics_cursor.cursor[line])
                                                << (8 - bit_shift);

                                /*
                                 *      Stash cursor line and alert gvi
                                 */
                                if (byte_min <= 0 && byte_max >= 0)
                                {
                                        sas_store(byte_address, strip >> 16);
                                }
                                if (byte_min <= 1 && byte_max >= 1)
                                {
                                        sas_store(byte_address+1, strip >> 8);
                                }
                                if (byte_min <= 2 && byte_max >= 2)
                                {
                                        sas_store(byte_address+2, strip);
                                }
                        }
                        else
                        {
                                /*
                                 *      Get save area
                                 */
                                graphics_cursor_background[line] = (sas_hw_at(byte_address) << 8) +
                                                                    sas_hw_at(byte_address+1);

                                /*
                                 *      Get overlaid cursor line
                                 */
                                strip = (graphics_cursor_background[line] &
                                    graphics_cursor.screen[line]) ^
                                    graphics_cursor.cursor[line];

                                /*
                                 *      Stash cursor line and alert gvi
                                 */
                                if (byte_min <= 0 && byte_max >= 0)
                                {
                                        sas_store(byte_address, strip >> 8);
                                }
                                if (byte_min <= 1 && byte_max >= 1)
                                {
                                        sas_store(byte_address+1, strip);
                                }
                        }
                        line++;
                }
        }
}


#endif /* HERC */


LOCAL void graphics_cursor_undisplay IFN0()
{
        /*
         *      Remove the graphics cursor representation of the mouse
         *      status
         */
        boolean even_scan_line;
        MOUSE_BIT_ADDRESS bit_shift;
        IS32 byte_offset;
        sys_addr byte_address;
        IU32 strip;
        int line, line_max;
        int byte_min, byte_max;

        /*
         *      Get cursor byte offset relative to the start of the
         *      even or odd bank, and bit shift to apply
         */
        even_scan_line = ((save_area.top_left.y % 2) == 0);
        byte_offset = point_as_graphics_cell_address(&save_position);
        bit_shift = byte_offset & 7;
        byte_offset >>= 3;

        /*
         *      Get range of cursor lines that need to be displayed
         */
        line = save_area.top_left.y - save_position.y;
        line_max = area_depth(&save_area);

        /*
         *      Get range of bytes that need to be displayed
         */
        byte_min = 0;
        byte_max = 2;
        if (save_position.x < 0)
                byte_min += (7 - save_position.x) / 8;
        else if (area_width(&save_area) < MOUSE_GRAPHICS_CURSOR_WIDTH)
                byte_max -= (8 + MOUSE_GRAPHICS_CURSOR_WIDTH - area_width(&save_area)) / 8;

        while(line < line_max)
        {
                if (even_scan_line)
                {
                        even_scan_line = FALSE;
                        byte_address = EVEN_START + byte_offset;
                }
                else
                {
                        even_scan_line = TRUE;
                        byte_address = ODD_START + byte_offset;
                        byte_offset += MOUSE_GRAPHICS_MODE_PITCH / 8;
                }

                if (bit_shift)
                {
                        /*
                         *      Get cursor line
                         */
                        strip =  (IU32)sas_hw_at(byte_address) << 16;
                        strip |= (unsigned short)sas_hw_at(byte_address+1) << 8;
                        strip |= sas_hw_at(byte_address+2);

                        /*
                         *      Overlay save area
                         */
                        strip &= (SHIFT_VAL >> bit_shift);
                        strip |= (IU32)graphics_cursor_background[line]
                                        << (8 - bit_shift);

                        /*
                         *      Stash cursor line and alert gvi
                         */
                        if (byte_min <= 0 && byte_max >= 0)
                        {
                                sas_store(byte_address, (IU8)(strip >> 16));
                        }
                        if (byte_min <= 1 && byte_max >= 1)
                        {
                                sas_store(byte_address+1, (IU8)(strip >> 8));
                        }
                        if (byte_min <= 2 && byte_max >= 2)
                        {
                                sas_store(byte_address+2, (IU8)(strip));
                        }
                }
                else
                {
                        /*
                         *      Stash save area and alert gvi
                         */
                        strip = graphics_cursor_background[line];
                        if (byte_min <= 0 && byte_max >= 0)
                        {
                                sas_store(byte_address, (IU8)(strip >> 8));
                        }
                        if (byte_min <= 1 && byte_max >= 1)
                        {
                                sas_store(byte_address+1, (IU8)(strip));
                        }
                }
                line++;
        }
}

#ifdef HERC

LOCAL void HERC_graphics_cursor_undisplay IFN0()
{
        /*
         *      Remove the graphics cursor representation of the mouse
         *      status
         */
        int scan_line_mod;
        MOUSE_BIT_ADDRESS bit_shift;
        IS32 byte_offset;
        sys_addr byte_address;
        IU32 strip;
        int line, line_max;
        int byte_min, byte_max;

        /*
         *      Get cursor byte offset relative to the start of the
         *      even or odd bank, and bit shift to apply
         */
        scan_line_mod = save_area.top_left.y % 4;
        byte_offset = point_as_HERC_graphics_cell_address(&save_position);
        bit_shift = byte_offset & 7;
        byte_offset >>= 3;

        /*
         *      Get range of cursor lines that need to be displayed
         */
        line = save_area.top_left.y - save_position.y;
        line_max = area_depth(&save_area);

        /*
         *      Get range of bytes that need to be displayed
         */
        byte_min = 0;
        byte_max = 2;
        if (save_position.x < 0)
                byte_min += (7 - save_position.x) / 8;
        else if (area_width(&save_area) < MOUSE_GRAPHICS_CURSOR_WIDTH)
                byte_max -= (8 + MOUSE_GRAPHICS_CURSOR_WIDTH - area_width(&save_area)) / 8;

        while(line < line_max)
        {
                        switch (scan_line_mod){
                        case 0:
                                scan_line_mod++;
                                byte_address = gvi_pc_low_regen + 0x0000 + byte_offset;
                                break;
                        case 1:
                                scan_line_mod++;
                                byte_address = gvi_pc_low_regen + 0x2000 + byte_offset;
                                break;
                        case 2:
                                scan_line_mod++;
                                byte_address = gvi_pc_low_regen + 0x4000 + byte_offset;
                                break;
                        case 3:
                                scan_line_mod=0;
                                byte_address = gvi_pc_low_regen + 0x6000 + byte_offset;
                                byte_offset += 720 / 8;
                                break;
                        }

                if (bit_shift)
                {
                        /*
                         *      Get cursor line
                         */
                        strip =  (IU32)sas_hw_at(byte_address) << 16;
                        strip |= (unsigned short)sas_hw_at(byte_address+1) << 8;
                        strip |= sas_hw_at(byte_address+2);

                        /*
                         *      Overlay save area
                         */
                        strip &= (SHIFT_VAL >> bit_shift);
                        strip |= (IU32)graphics_cursor_background[line]
                                        << (8 - bit_shift);

                        /*
                         *      Stash cursor line and alert gvi
                         */
                        if (byte_min <= 0 && byte_max >= 0)
                        {
                                sas_store(byte_address, strip >> 16);
                        }
                        if (byte_min <= 1 && byte_max >= 1)
                        {
                                sas_store(byte_address+1, strip >> 8);
                        }
                        if (byte_min <= 2 && byte_max >= 2)
                        {
                                sas_store(byte_address+2, strip);
                        }
                }
                else
                {
                        /*
                         *      Stash save area
                         */
                        strip = graphics_cursor_background[line];
                        if (byte_min <= 0 && byte_max >= 0)
                        {
                                sas_store(byte_address, strip >> 8);
                        }
                        if (byte_min <= 1 && byte_max >= 1)
                        {
                                sas_store(byte_address+1, strip);
                        }
                }
                line++;
        }
}
#endif /* HERC */


/*
 *      MOUSE DRIVER INPORT ACCESS FUNCTIONS
 *      ====================================
 */

LOCAL void inport_get_event IFN1(MOUSE_INPORT_DATA *,event)
{
        /*
         *      Get InPort event data from the Bus Mouse hardware following
         *      an interrupt
         */
        half_word inport_mode;

        /*
         *      Set hold bit in InPort mode register to transfer the mouse
         *      event data into the status and data registers
         */
        outb(MOUSE_INPORT_ADDRESS_REG, MOUSE_INPORT_ADDRESS_MODE);
        inb(MOUSE_INPORT_DATA_REG, &inport_mode);
        outb(MOUSE_INPORT_DATA_REG, (IU8)(inport_mode | MOUSE_INPORT_MODE_HOLD_BIT));

        /*
         *      Retreive the InPort mouse status, data1 and data2 registers
         */
        outb(MOUSE_INPORT_ADDRESS_REG, MOUSE_INPORT_ADDRESS_STATUS);
        inb(MOUSE_INPORT_DATA_REG, &event->status);
        outb(MOUSE_INPORT_ADDRESS_REG, MOUSE_INPORT_ADDRESS_DATA1);
        inb(MOUSE_INPORT_DATA_REG, (half_word *)&event->data_x);
        outb(MOUSE_INPORT_ADDRESS_REG, MOUSE_INPORT_ADDRESS_DATA2);
        inb(MOUSE_INPORT_DATA_REG, (half_word *)&event->data_y);

        /*
         *      Clear hold bit in mode register
         */
        outb(MOUSE_INPORT_ADDRESS_REG, MOUSE_INPORT_ADDRESS_MODE);
        inb(MOUSE_INPORT_DATA_REG, &inport_mode);
        outb(MOUSE_INPORT_DATA_REG, (IU8)(inport_mode & ~MOUSE_INPORT_MODE_HOLD_BIT));
}




LOCAL void inport_reset IFN0()
{
        /*
         *      Reset the InPort bus mouse hardware
         */

        /*
         *      Set the reset bit in the address register
         */
        outb(MOUSE_INPORT_ADDRESS_REG, MOUSE_INPORT_ADDRESS_RESET_BIT);

        /*
         *      Select the mode register, and set it to the correct value
         */
        outb(MOUSE_INPORT_ADDRESS_REG, MOUSE_INPORT_ADDRESS_MODE);
        outb(MOUSE_INPORT_DATA_REG, MOUSE_INPORT_MODE_VALUE);
}




/*
 *      USER SUBROUTINE CALL ACCESS FUNCTIONS
 *      =====================================
 */

LOCAL void jump_to_user_subroutine IFN3(MOUSE_CALL_MASK,condition_mask,word,segment,word,offset)
{
        /*
         *      This routine sets up the CPU registers so that when the CPU
         *      restarts, control will pass to the user subroutine, and when
         *      the user subroutine returns, control will pass to the second
         *      part of the mouse hardware interrupt service routine
         */

        /*
         *      Push address of second part of mouse hardware interrupt service
         *      routine
         */

        setSP((IU16)(getSP() - 2));
        sas_storew(effective_addr(getSS(), getSP()), MOUSE_INT2_SEGMENT);
        setSP((IU16)(getSP() - 2));
        sas_storew(effective_addr(getSS(), getSP()), MOUSE_INT2_OFFSET);

        /*
         *      Set CS:IP to point to the user subroutine. Adjust the IP by
         *       HOST_BOP_IP_FUDGE, since the CPU emulator will increment IP by
         *       HOST_BOP_IP_FUDGE for the BOP instruction before proceeding
         */
        setCS(segment);
#ifdef CPU_30_STYLE
        setIP(offset);
#else /* !CPU_30_STYLE */
        setIP(offset + HOST_BOP_IP_FUDGE);
#endif /* !CPU_30_STYLE */

        /*
         *      Put parameters into the registers, saving the previous contents
         *      to be restored in the second part of the mouse hardware
         *      interrupt service routine
         */
        saved_AX = getAX();
        setAX(condition_mask);
        saved_BX = getBX();
        setBX(cursor_status.button_status);
        saved_CX = getCX();
        setCX(cursor_status.position.x);
        saved_DX = getDX();
        setDX(cursor_status.position.y);
        saved_SI = getSI();
        setSI(mouse_motion.x);
        saved_DI = getDI();
        setDI(mouse_motion.y);
        saved_ES = getES();
        saved_BP = getBP();
        saved_DS = getDS();

        /*
         *      Save the condition mask so that the second part of the mouse
         *      hardware interrupt service routine can determine whether the
         *      cursor has changed position
         */

        last_condition_mask = condition_mask;

        /*
         *      Enable interrupts
         */
        setIF(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\softpc.new\base\support\ios.c ===
#include "insignia.h"
#include "host_def.h"
/*[
 *	Name:		ios.c
 *
 *	Author:		Wayne Plummer
 *
 *	Created:	7th February 1991
 *
 *	Sccs ID:	@(#)ios.c	1.29 09/27/94
 *
 *	Purpose:	This module provides a routing mechanism for Input and Ouput
 *			requests.
 *
 *	(c)Copyright Insignia Solutions Ltd., 1991. All rights reserved.
]*/

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * module will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_IOS.seg"
#endif

#include <stdio.h>
#include <stdlib.h>

/*
 * SoftPC include files
 */
#include "xt.h"
#include CpuH
#include "ios.h"
#include "trace.h"
#include "debug.h"
#include "sas.h"
#include MemoryH

#if defined(SPC386) && !defined(GISP_CPU)
#define VIRTUALISATION
#endif

#ifdef NTVDM
#define getIOInAdapter(ioaddr) (Ios_in_adapter_table[ioaddr & (PC_IO_MEM_SIZE-1)])
#define getIOOutAdapter(ioaddr) (Ios_out_adapter_table[ioaddr & (PC_IO_MEM_SIZE-1)])

BOOL HostUndefinedIo(WORD IoAddress);

#endif

/*
 *
 * ============================================================================
 * Global data
 * ============================================================================
 *
 */

/*
 *	Ios_in_adapter_table & Ios_out_adapter_table - These tables give the association
 *	between the IO address used for an IO and the SoftPC adapter ID associated with the
 *	IO subroutines.
 *
 *	Note that there are two tables here to allow for memory mapped IO locations which
 *	have an input functionality which is unrelated to the output functionality...
 *	In these cases, two connect port calls to the same IO address would be made, one with
 *	only the IO_READ flag set, the other with only the IO_WRITE flag set.
 */
#ifdef	MAC68K
GLOBAL char	*Ios_in_adapter_table = NULL;
GLOBAL char	*Ios_out_adapter_table = NULL;
#else
GLOBAL char	Ios_in_adapter_table[PC_IO_MEM_SIZE];
GLOBAL char	Ios_out_adapter_table[PC_IO_MEM_SIZE];
#endif	/* MAC68K */
#ifndef PROD
GLOBAL IU32	*ios_empty_in = (IU32 *)0;
GLOBAL IU32	*ios_empty_out = (IU32 *)0;
#endif /* PROD */

/*
 *	Ios_xxx_function - These tables are indexed by the adapter ID obtained
 *	from the Ios_in_adapter_table or Ios_in_adapter_table to yield a pointer
 *	to the IO routine to call.
 */
typedef	void (*IOS_FUNC_INB)	IPT2(io_addr, io_address, half_word *, value);
typedef	void (*IOS_FUNC_INW)	IPT2(io_addr, io_address, word *, value);
typedef	void (*IOS_FUNC_INSB)	IPT3(io_addr, io_address, half_word *, valarray, word, count);
typedef	void (*IOS_FUNC_INSW)	IPT3(io_addr, io_address, word *, valarray, word, count);
typedef	void (*IOS_FUNC_OUTB)	IPT2(io_addr, io_address, half_word, value);
typedef	void (*IOS_FUNC_OUTW)	IPT2(io_addr, io_address, word, value);
typedef	void (*IOS_FUNC_OUTSB)	IPT3(io_addr, io_address, half_word *, valarray, word, count);
typedef	void (*IOS_FUNC_OUTSW)	IPT3(io_addr, io_address, word *, valarray, word, count);
#ifdef SPC386
typedef	void (*IOS_FUNC_IND)	IPT2(io_addr, io_address, double_word *, value);
typedef	void (*IOS_FUNC_INSD)	IPT3(io_addr, io_address, double_word *, valarray, word, count);
typedef	void (*IOS_FUNC_OUTD)	IPT2(io_addr, io_address, double_word, value);
typedef	void (*IOS_FUNC_OUTSD)	IPT3(io_addr, io_address, double_word *, valarray, word, count);
#endif

LOCAL void generic_inw IPT2(io_addr, io_address, word *, value);
LOCAL void generic_insb IPT3(io_addr, io_address, half_word *, valarray, word, count);
LOCAL void generic_insw IPT3(io_addr, io_address, word *, valarray, word, count);
LOCAL void generic_outw IPT2(io_addr, io_address, word, value);
LOCAL void generic_outsb IPT3(io_addr, io_address, half_word *, valarray, word, count);
LOCAL void generic_outsw IPT3(io_addr, io_address, word *, valarray, word, count);
#ifdef SPC386
LOCAL void generic_ind IPT2(io_addr, io_address, double_word *, value);
LOCAL void generic_insd IPT3(io_addr, io_address, double_word *, valarray, word, count);
LOCAL void generic_outd IPT2(io_addr, io_address, double_word, value);
LOCAL void generic_outsd IPT3(io_addr, io_address, double_word *, valarray, word, count);
#endif

GLOBAL IOS_FUNC_INB 	Ios_inb_function  [IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_INW	Ios_inw_function  [IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_INSB	Ios_insb_function [IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_INSW	Ios_insw_function [IO_MAX_NUMBER_ADAPTORS];

GLOBAL IOS_FUNC_OUTB	Ios_outb_function [IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_OUTW	Ios_outw_function [IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_OUTSB	Ios_outsb_function[IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_OUTSW	Ios_outsw_function[IO_MAX_NUMBER_ADAPTORS];

#ifdef SPC386
GLOBAL IOS_FUNC_IND	Ios_ind_function  [IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_INSD	Ios_insd_function [IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_OUTD	Ios_outd_function [IO_MAX_NUMBER_ADAPTORS];
GLOBAL IOS_FUNC_OUTSD	Ios_outsd_function[IO_MAX_NUMBER_ADAPTORS];
#endif

/*
 *
 * ============================================================================
 * Local Subroutines
 * ============================================================================
 *
 */

#define BIT_NOT_SET(vector, bit)		\
	((vector == (IU32 *)0) ? FALSE: ((((vector[(bit) >> 5]) >> ((bit) & 0x1f)) & 1) == 0))

#define SET_THE_BIT(vector, bit)					\
	{								\
		 if (vector != (IU32 *)0)				\
		 {							\
			 vector[(bit) >> 5] |= (1 << ((bit) & 0x1f));	\
		 }							\
	}

/*
============================== io_empty_inb ==================================
    PURPOSE:
	To simulate an INB to an empty io_addr.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL void io_empty_inb IFN2(io_addr, io_address, half_word *, value)
{
#ifdef PROD
	UNUSED(io_address);

#else
#if defined(NEC_98)
        if(host_getenv("SHOW_IO")){
            printf("Empty Adaptor IN Access ");
            printf("IO_PORT: %x\n", io_address);
        };
#else !NEC_98
	if (BIT_NOT_SET(ios_empty_in, (IU16)io_address))
	{
		/* First time for this port */
		always_trace1 ("INB attempted on empty port 0x%x", io_address);
		SET_THE_BIT(ios_empty_in, (IU16)io_address);
	}
#endif   //NEC_98
#endif /* PROD */

#ifdef NTVDM
    //
    // Check to see if we should load any VDD's
    //
    if (HostUndefinedIo(io_address)) {

        //
        // VDD was loaded, retry operation
        //
		(*Ios_inb_function
			[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
							(io_address, value);

    } else
#endif // NTVDM
    {
        // Nothing dynamically loaded, just use default value
        *value = IO_EMPTY_PORT_BYTE_VALUE;
    }

}

/*
============================== io_empty_outb ==================================
    PURPOSE:
	To simulate an OUTB to an empty io_addr.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL void io_empty_outb IFN2(io_addr, io_address, half_word, value)
{
	UNUSED(value);
#ifdef PROD
	UNUSED(io_address);
#else
#if defined(NEC_98)
        if(host_getenv("SHOW_IO") && (io_address != 0x5F)) {
            printf("Empty Adaptor OUT Access ");
            printf("IO_PORT: %x ", io_address);
            printf("DATA: %x\n", value);
        };
#else !NEC_98
	if (BIT_NOT_SET(ios_empty_out, (IU16)io_address))
	{
		/* First time for this port */
		always_trace1 ("OUTB attempted on empty port 0x%x", io_address);
		SET_THE_BIT(ios_empty_out, (IU16)io_address);
	}
#endif   //NEC_98
#endif /* PROD */

#ifdef NTVDM
    //
    // Check to see if we should load any VDD's
    //
    if (HostUndefinedIo(io_address)) {
        //
        // VDD was loaded, retry operation
        //
		(*Ios_outb_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
				(io_address, value);
    }
#endif
}

/*
=============================== generic_inw ==================================
    PURPOSE:
	To simulate an INW using the appropriate INB routine.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL void generic_inw IFN2(io_addr, io_address, word *, value)
{
	reg             temp;

	(*Ios_inb_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
		(io_address, &temp.byte.low);
	io_address++;
	(*Ios_inb_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
		(io_address, &temp.byte.high);
#ifdef LITTLEND
	*((half_word *) value + 0) = temp.byte.low;
	*((half_word *) value + 1) = temp.byte.high;
#endif				/* LITTLEND */

#ifdef BIGEND
	*((half_word *) value + 0) = temp.byte.high;
	*((half_word *) value + 1) = temp.byte.low;
#endif				/* BIGEND */
}

/*
=============================== generic_outw ==================================
    PURPOSE:
	To simulate an OUTW using the appropriate OUTB routine.
    INPUT:
    OUTPUT:
	Notes: GLOBAL for JOKER.
==============================================================================
*/
LOCAL void generic_outw IFN2(io_addr, io_address, word, value)
{
	reg             temp;

	temp.X = value;
	(*Ios_outb_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
					(io_address, temp.byte.low);
	++io_address;
	(*Ios_outb_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
		(io_address, temp.byte.high);
}

#ifdef SPC386
/*
=============================== generic_ind ==================================
    PURPOSE:
	To simulate an IND using the appropriate INW routine.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL void generic_ind IFN2(io_addr, io_address, double_word *, value)
{
	word low, high;

	(*Ios_inw_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]]) (io_address, &low);
	io_address += 2;
	(*Ios_inw_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]]) (io_address, &high);
#ifdef LITTLEND
	*((word *) value + 0) = low;
	*((word *) value + 1) = high;
#endif				/* LITTLEND */

#ifdef BIGEND
	*((word *) value + 0) = high;
	*((word *) value + 1) = low;
#endif				/* BIGEND */
}
#endif /* SPC386 */

#ifdef SPC386
/*
=============================== generic_outd ==================================
    PURPOSE:
	To simulate an OUTD using the appropriate OUTW routine.
    INPUT:
    OUTPUT:
	Notes: GLOBAL for JOKER.
==============================================================================
*/
LOCAL void generic_outd IFN2(io_addr, io_address, double_word, value)
{
	word low, high;

	low = (word)(value & 0xffff);
	high = (word)((value & 0xffff0000) >> 16);

	(*Ios_outw_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]]) (io_address, low);
	io_address += 2;
	(*Ios_outw_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]]) (io_address, high);
}
#endif /* SPC386 */

/*
=============================== generic_insb ==================================
    PURPOSE:
	To simulate an INSB using the appropriate INB routine.
    INPUT:
    OUTPUT:
==============================================================================
*/

/* MS NT monitor uses these string routines {in,out}s{b,w} string io support */
#if defined(NTVDM) && defined(MONITOR)
#undef LOCAL
#define LOCAL
#endif	/* NTVDM & MONITOR */

LOCAL void generic_insb IFN3(io_addr, io_address, half_word *, valarray,
	word, count)
{
	IOS_FUNC_INB func = Ios_inb_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]];

	while (count--){
		(*func) (io_address, valarray++);
	}
}

/*
=============================== generic_outsb =================================
    PURPOSE:
	To simulate an OUTSB using the appropriate OUTB routine.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL void generic_outsb IFN3(io_addr, io_address, half_word *, valarray, word, count)
{
	IOS_FUNC_OUTB func = Ios_outb_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]];

	while (count--){
		(*func) (io_address, *valarray++);
	}
}

/*
=============================== generic_insw ==================================
    PURPOSE:
	To simulate an INSW using the appropriate INW routine.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL void generic_insw IFN3(io_addr, io_address, word *, valarray, word, count)
{
	IOS_FUNC_INW func = Ios_inw_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]];

	while (count--){
		(*func) (io_address, valarray++);
	}
}

/*
=============================== generic_outsw =================================
    PURPOSE:
	To simulate an OUTSW using the appropriate OUTW routine.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL void generic_outsw IFN3(io_addr, io_address, word *, valarray, word, count)
{
	IOS_FUNC_OUTW func = Ios_outw_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]];

	while (count--){
		(*func) (io_address, *valarray++);
	}
}

#ifdef SPC386
/*
=============================== generic_insd ==================================
    PURPOSE:
	To simulate an INSD using the appropriate IND routine.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL VOID generic_insd IFN3(io_addr, io_address, double_word *, valarray, word, count)
{
	IOS_FUNC_IND func = Ios_ind_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]];

	while (count--){
		(*func) (io_address, valarray++);
	}
}
#endif

#ifdef SPC386
/*
=============================== generic_outsd =================================
    PURPOSE:
	To simulate an OUTSD using the appropriate OUTD routine.
    INPUT:
    OUTPUT:
==============================================================================
*/
LOCAL VOID generic_outsd IFN3(io_addr, io_address, double_word *, valarray, word, count)
{
	IOS_FUNC_OUTD func = Ios_outd_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]];

	while (count--){
		(*func) (io_address, *valarray++);
	}
}
#endif

/* ensure any more LOCAL routines remain LOCAL */
#if defined(NTVDM) && defined(MONITOR)
#undef LOCAL
#define LOCAL static
/*
 *  string byte handlers for monitor
 */
VOID insb IFN3(io_addr, io_address, half_word *, valarray, word, count)
{
    (*Ios_insb_function[getIOInAdapter(io_address)])
            (io_address, valarray, count);
}

VOID outsb IFN3(io_addr, io_address, half_word *, valarray,word, count)
{
    (*Ios_outsb_function[getIOInAdapter(io_address)])
            (io_address, valarray, count);
}

VOID insw IFN3(io_addr, io_address, word *, valarray, word, count)
{
    (*Ios_insw_function[getIOInAdapter(io_address)])
            (io_address, valarray, count);
}

VOID outsw IFN3(io_addr, io_address, word *, valarray, word, count)
{
    (*Ios_outsw_function[getIOInAdapter(io_address)])
            (io_address, valarray, count);
}

#endif	/* NTVDM & MONITOR */

/*
 *
 * ============================================================================
 * Global Subroutines
 * ============================================================================
 *
 */

/*(
=================================== inb ======================================
    PURPOSE:
	To perform an INB - i.e. call the appropriate SoftPC adapter's INB
	IO routine. Note that this routine is not intended to be used by
	the assembler CPU directly - it is intended that the assembler CPU
	access the data tables above directly to discover which routine to call.

	This also needs to be true of 386 CPU, or you'll get into a very
	nasty virtualisation loop.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	inb IFN2(io_addr, io_address, half_word *, value)
{
#ifdef VIRTUALISATION
	IU32 value32;
#endif /* VIRTUALISATION */

#ifdef EGA_DUMP
	if (io_address >= MDA_PORT_START && io_address <= CGA_PORT_END)
		dump_inb(io_address);
#endif

#ifdef VIRTUALISATION

#ifdef SYNCH_TIMERS
	value32 = 0;
#endif	/* SYNCH_TIMERS */

	if (IOVirtualised(io_address, &value32, BIOS_INB_OFFSET, (sizeof(IU8))))
	{
		*value = (IU8)value32;
	}
	else
#endif /* VIRTUALISATION */
	{
		(*Ios_inb_function
			[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
							(io_address, value);
	}
}

/*(
================================== outb ======================================
    PURPOSE:
	To perform an OUTB - i.e. call the appropriate SoftPC adapter's OUTB
	IO routine. Note that this routine is not intended to be used by
	the assembler CPU directly - it is intended that the assembler CPU
	access the data tables above directly to discover which routine to call.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	outb IFN2(io_addr, io_address, half_word, value)
{
#ifdef VIRTUALISATION
	IU32 value32;
#endif /* VIRTUALISATION */

#ifdef EGA_DUMP
	if (io_address >= MDA_PORT_START && io_address <= CGA_PORT_END)
		dump_outb(io_address, value);
#endif

	sub_note_trace2( IOS_VERBOSE, "outb( %x, %x )", io_address, value );

#ifdef VIRTUALISATION
	value32 = value;

	if (IOVirtualised(io_address, &value32, BIOS_OUTB_OFFSET, (sizeof(IU8))))
		return;
	else
#endif /* VIRTUALISATION */
	{
		(*Ios_outb_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
				(io_address, value);
	}
}

/*(
=================================== inw ======================================
    PURPOSE:
	To perform an INW - i.e. call the appropriate SoftPC adapter's INW
	IO routine. Note that this routine is not intended to be used by
	the assembler CPU directly - it is intended that the assembler CPU
	access the data tables above directly to discover which routine to call.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	inw IFN2(io_addr, io_address, word *, value)
{
#ifdef VIRTUALISATION
	IU32 value32;
#endif /* VIRTUALISATION */

#ifdef EGA_DUMP
	if (io_address >= MDA_PORT_START && io_address <= CGA_PORT_END)
		dump_inw(io_address);
#endif

#ifdef VIRTUALISATION

#ifdef SYNCH_TIMERS
	value32 = 0;
#endif	/* SYNCH_TIMERS */

	if (IOVirtualised(io_address, &value32, BIOS_INW_OFFSET, (sizeof(IU16))))
	{
		*value = (IU16)value32;
	}
	else
#endif /* VIRTUALISATION */
	{
		(*Ios_inw_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
			(io_address, value);
	}
}

/*(
================================== outw ======================================
    PURPOSE:
	To perform an OUTW - i.e. call the appropriate SoftPC adapter's OUTW
	IO routine. Note that this routine is not intended to be used by
	the assembler CPU directly - it is intended that the assembler CPU
	access the data tables above directly to discover which routine to call.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	outw IFN2(io_addr, io_address, word, value)
{
#ifdef VIRTUALISATION
	IU32 value32;
#endif /* VIRTUALISATION */

#ifdef EGA_DUMP
	if (io_address >= EGA_AC_INDEX_DATA && io_address <= EGA_IPSTAT1_REG)
		dump_outw(io_address, value);
#endif

	sub_note_trace2( IOS_VERBOSE, "outw( %x, %x )", io_address, value );

#ifdef VIRTUALISATION
	value32 = value;

	if (IOVirtualised(io_address, &value32, BIOS_OUTW_OFFSET, (sizeof(IU16))))
		return;
	else
#endif /* VIRTUALISATION */
	{
		(*Ios_outw_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]])
			(io_address, value);

	}
}

#ifdef SPC386
/*(
=================================== ind ======================================
    PURPOSE:
	To perform an IND - i.e. call the appropriate SoftPC adapter's IND
	IO routine. Note that this routine is not intended to be used by
	the assembler CPU directly - it is intended that the assembler CPU
	access the data tables above directly to discover which routine to call.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	ind IFN2(io_addr, io_address, IU32 *, value)
{
	IU16 temp;

#ifdef VIRTUALISATION
	IU32 value32;

#ifdef SYNCH_TIMERS
	value32 = 0;
#endif	/* SYNCH_TIMERS */

	if (IOVirtualised(io_address, &value32, BIOS_IND_OFFSET, (sizeof(IU32))))
	{
		*value = value32;
	}
	else
#endif /* VIRTUALISATION */
	{
		inw(io_address,&temp);
		*value = (IU32)temp;
		io_address +=2;
		inw(io_address,&temp);
		*value |= ((IU32)temp << 16);
	}
}

/*(
================================== outd ======================================
    PURPOSE:
	To perform an OUTD - i.e. call the appropriate SoftPC adapter's OUTD
	IO routine. Note that this routine is not intended to be used by
	the assembler CPU directly - it is intended that the assembler CPU
	access the data tables above directly to discover which routine to call.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	outd IFN2(io_addr, io_address, IU32, value)
{
	sub_note_trace2( IOS_VERBOSE, "outd( %x, %x )", io_address, value );

#ifdef VIRTUALISATION
	if (IOVirtualised(io_address, &value, BIOS_OUTD_OFFSET, (sizeof(IU32))))
		return;
	else
#endif /* VIRTUALISATION */
	{
		word temp;

		temp = (word)(value & 0xffff);
		outw(io_address,temp);
		io_address +=2;
		temp = (word)((value >> 16));
		outw(io_address,temp);
	}
}

#endif /* SPC386 */
/*(
============================== io_define_inb =================================
    PURPOSE:
	To declare the address of the INB IO routine for the given adapter.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void
#ifdef	ANSI
io_define_inb(half_word adapter,
	void (*func) IPT2(io_addr, io_address, half_word *, value))
#else
io_define_inb(adapter, func)
half_word       adapter;
void            (*func) ();
#endif	/* ANSI */
{
	Ios_inb_function[adapter]  = FAST_FUNC_ADDR(func);
	Ios_inw_function[adapter]  = FAST_FUNC_ADDR(generic_inw);
	Ios_insb_function[adapter] = generic_insb;
	Ios_insw_function[adapter] = generic_insw;
#ifdef SPC386
	Ios_ind_function[adapter]  = generic_ind;
	Ios_insd_function[adapter] = generic_insd;
#endif	/* SPC386 */
}

/*(
========================== io_define_in_routines =============================
    PURPOSE:
	To declare the address of the input IO routine for the given adapter.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	io_define_in_routines IFN5(half_word, adapter,
					   IOS_FUNC_INB, inb_func,
					   IOS_FUNC_INW, inw_func,
					   IOS_FUNC_INSB, insb_func,
					   IOS_FUNC_INSW, insw_func)
{
	/*
	 *	Preset defaultable entries to default value.
	 */
	Ios_inw_function[adapter]  = FAST_FUNC_ADDR(generic_inw);
	Ios_insb_function[adapter] = generic_insb;
	Ios_insw_function[adapter] = generic_insw;
#ifdef SPC386
	Ios_ind_function[adapter]  = generic_ind;
	Ios_insd_function[adapter] = generic_insd;
#endif	/* SPC386 */

	/*
	 *	Process args into table entries
	 */
	Ios_inb_function[adapter]  = FAST_FUNC_ADDR(inb_func);
	if (inw_func)  Ios_inw_function[adapter]   = FAST_FUNC_ADDR(inw_func);
	if (insb_func) Ios_insb_function[adapter]  = insb_func;
	if (insw_func) Ios_insw_function[adapter]  = insw_func;
}

/*(
============================= io_define_outb =================================
    PURPOSE:
	To declare the address of the OUTB IO routine for the given adapter.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	io_define_outb IFN2(half_word, adapter, IOS_FUNC_OUTB, func)
{
	Ios_outb_function[adapter]  = FAST_FUNC_ADDR(func);
	Ios_outw_function[adapter]  = FAST_FUNC_ADDR(generic_outw);
	Ios_outsb_function[adapter] = generic_outsb;
	Ios_outsw_function[adapter] = generic_outsw;
#ifdef SPC386
	Ios_outd_function[adapter]  = generic_outd;
	Ios_outsd_function[adapter]  = generic_outsd;
#endif	/* SPC386 */
}

/*(
========================= io_define_out_routines =============================
    PURPOSE:
	To declare the address of the output IO routine for the given adapter.
    INPUT:
    OUTPUT:
==============================================================================
)*/

GLOBAL VOID	io_define_out_routines IFN5(half_word, adapter,
					    IOS_FUNC_OUTB, outb_func,
					    IOS_FUNC_OUTW, outw_func,
					    IOS_FUNC_OUTSB, outsb_func,
					    IOS_FUNC_OUTSW, outsw_func)
{
	/*
	 *	Preset defaultable entries to default value.
	 */
	Ios_outw_function[adapter]  = FAST_FUNC_ADDR(generic_outw);
	Ios_outsb_function[adapter] = generic_outsb;
	Ios_outsw_function[adapter] = generic_outsw;
#ifdef SPC386
	Ios_outd_function[adapter]  = generic_outd;
	Ios_outsd_function[adapter] = generic_outsd;
#endif	/* SPC386 */

	/*
	 *	Process args into table entries
	 */
	Ios_outb_function[adapter]  = FAST_FUNC_ADDR(outb_func);
	if (outw_func)  Ios_outw_function[adapter]   = FAST_FUNC_ADDR(outw_func);
	if (outsb_func) Ios_outsb_function[adapter]  = outsb_func;
	if (outsw_func) Ios_outsw_function[adapter]  = outsw_func;
}

#ifdef SPC386
/*(
========================= io_define_outd_routine =============================
    PURPOSE:
	To declare the address of the output IO routine for the given adapter.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL VOID	io_define_outd_routine IFN3(half_word, adapter,
					    IOS_FUNC_OUTD, outd_func, IOS_FUNC_OUTSD, outsd_func)
{
	/*
	 *	Preset defaultable entries to default value.
	 */
	Ios_outb_function[adapter]  = io_empty_outb;
	Ios_outw_function[adapter]  = generic_outw;
	Ios_outd_function[adapter]  = generic_outd;
	Ios_outsb_function[adapter] = generic_outsb;
	Ios_outsw_function[adapter] = generic_outsw;
	Ios_outsd_function[adapter] = generic_outsd;

	/*
	 *	Process args into table entries
	 */
	if (outd_func)  Ios_outd_function[adapter]   = outd_func;
	if (outsd_func) Ios_outsd_function[adapter]  = outsd_func;
}
#endif	/* SPC386 */

#ifdef SPC386
/*(
========================= io_define_ind_routine =============================
    PURPOSE:
	To declare the address of the output IO routine for the given adapter.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL VOID	io_define_ind_routine IFN3(half_word, adapter,
					    IOS_FUNC_IND, ind_func, IOS_FUNC_INSD, insd_func)
{
	/*
	 *	Preset defaultable entries to default value.
	 */
	Ios_inb_function[adapter]  = io_empty_inb;
	Ios_inw_function[adapter]  = generic_inw;
	Ios_ind_function[adapter]  = generic_ind;
	Ios_insb_function[adapter] = generic_insb;
	Ios_insw_function[adapter] = generic_insw;
	Ios_insd_function[adapter] = generic_insd;

	/*
	 *	Process args into table entries
	 */
	if (ind_func)  Ios_ind_function[adapter]   = ind_func;
	if (insd_func) Ios_insd_function[adapter]  = insd_func;
}
#endif	/* SPC386 */

/*(
============================= io_connect_port ================================
    PURPOSE:
	To associate a SoftPC IO adapter with the given IO address.
    INPUT:
    OUTPUT:
==============================================================================
)*/
#ifdef NTVDM
GLOBAL IBOOL	io_connect_port IFN3(io_addr, io_address, half_word, adapter,
	half_word, mode)
{
	if (mode & IO_READ){
		Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)] = adapter;
	}
	if (mode & IO_WRITE){
		Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)] = adapter;
	}
	return TRUE;
}
#else
GLOBAL void	io_connect_port IFN3(io_addr, io_address, half_word, adapter,
	half_word, mode)
{
	if (mode & IO_READ){
		Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)] = adapter;
	}
	if (mode & IO_WRITE){
		Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)] = adapter;
	}
}
#endif


/*(
=========================== io_disconnect_port ===============================
    PURPOSE:
	To associate the empty adapter with the given IO address.
    INPUT:
    OUTPUT:
==============================================================================
)*/
#ifdef NTVDM
GLOBAL void     io_disconnect_port IFN2(io_addr, io_address, half_word, adapter)
{
        if (adapter != Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)] &&
            adapter != Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)])
           {
            return;
           }

        Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)] = EMPTY_ADAPTOR;
        Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)] = EMPTY_ADAPTOR;
}
#else
GLOBAL void	io_disconnect_port IFN2(io_addr, io_address, half_word, adapter)
{
	UNUSED(adapter);
	Ios_in_adapter_table[io_address] = EMPTY_ADAPTOR;
	Ios_out_adapter_table[io_address] = EMPTY_ADAPTOR;
}
#endif	/* NTVDM */


/*(
=========================== get_inb_ptr ======================================
    PURPOSE:
	To return address of inb routine for the given port
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL IOS_FUNC_INB *get_inb_ptr IFN1(io_addr, io_address)
{
	return(&Ios_inb_function[Ios_in_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]]);
}

/*(
=========================== get_outb_ptr =====================================
    PURPOSE:
	To return address of outb routine for the given port
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL IOS_FUNC_OUTB *get_outb_ptr IFN1(io_addr, io_address)
{
        return(&Ios_outb_function[Ios_out_adapter_table[io_address & (PC_IO_MEM_SIZE-1)]]);
}

#ifdef SEGMENTATION
/*
 * The following #include specifies the code segment into which this
 * function will by placed by the MPW C compiler on the Mac II running
 * MultiFinder.
 */
#include "SOFTPC_INIT.seg"
#endif

/*(
================================ io_init ===================================
    PURPOSE:
	To initialise the SoftPC IO subsystem.
    INPUT:
    OUTPUT:
==============================================================================
)*/
GLOBAL void	io_init IFN0()
{
	IU32         i;	/* on some ports, PC_IO_MEM_SIZE == 0x10000, so this
			   must be a type with more than 16 bits */

	/*
	 * Set up all IO address ports with the "empty" adapter
	 */
	io_define_inb (EMPTY_ADAPTOR, io_empty_inb);
	io_define_outb(EMPTY_ADAPTOR, io_empty_outb);

#ifdef	MAC68K
	if (Ios_in_adapter_table == NULL) {				/* First time around -- allocate */
		Ios_in_adapter_table = host_malloc(PC_IO_MEM_SIZE);
		Ios_out_adapter_table = host_malloc(PC_IO_MEM_SIZE);
	}
#endif	/* MAC68K */

#ifndef PROD
	if (host_getenv("EMPTY_IO_VERBOSE") != NULL)
	{
		/* User does want empty I/O messages,
		 * so we must allocate bitmaps with one bit for every
		 * possible port number.
		 */
		ios_empty_in = (IU32 *)host_malloc((64*1024)/8);
		ios_empty_out = (IU32 *)host_malloc((64*1024)/8);
		memset((c