        TRUE


    Note that both output strings use the same string buffer memory of the
    input string, and are not necessarily null terminated.

    Based on FsRtlDissectName.

Arguments:

    RawArg - The full string to parse.

    FirstArg - The first name in the RawArg.
               Don't allocate a buffer for this string.

    RemainingArg - The rest of the RawArg after the first comma (if any).
                   Don't allocate a buffer for this string.

Return Value:

    FALSE if the RawArg is empty else TRUE (meaning FirstArg is valid).

--*/

{

#undef DEBSUB
#define DEBSUB "FrsDissectCommaList:"

    ULONG i = 0;
    ULONG RawArgLength;
    ULONG FirstArgStart;


    //
    //  Make both output strings empty for now
    //
    FirstArg->Length = 0;
    FirstArg->MaximumLength = 0;
    FirstArg->Buffer = NULL;

    RemainingArg->Length = 0;
    RemainingArg->MaximumLength = 0;
    RemainingArg->Buffer = NULL;

    RawArgLength = RawArg.Length / sizeof(WCHAR);

    //DPRINT2(5, "RawArg string: %ws {%d)\n",
    //        (RawArg.Buffer != NULL) ? RawArg.Buffer : L"<NULL>", RawArg.Length);
    //
    //  Skip over leading spaces and tabs.
    //
    while (i < RawArgLength) {
        if (( RawArg.Buffer[i] != UNICODE_SPACE ) &&
            ( RawArg.Buffer[i] != UNICODE_TAB )){
            break;
        }
        i += 1;
    }

    //
    //  Check for an empty input string
    //
    if (i == RawArgLength) {
        return FALSE;
    }

    //
    //  Now run down the input string until we hit a comma or a semicolon or
    //  the end of the string, remembering where we started.
    //
    FirstArgStart = i;
    while (i < RawArgLength) {
        if ((RawArg.Buffer[i] == L',') || (RawArg.Buffer[i] == L';')) {
            break;
        }
        i += 1;
    }

    //
    // At this point all characters up to (but not including) i are
    // in the first part.   So setup the first arg.  A leading comma returns
    // a zero length string.
    //
    FirstArg->Length = (USHORT)((i - FirstArgStart) * sizeof(WCHAR));
    FirstArg->MaximumLength = FirstArg->Length;
    FirstArg->Buffer = &RawArg.Buffer[FirstArgStart];

    //
    // If no more string is left then return zero length.  Else eat the comma and
    // return the remaining part (could be null if string ends with comma).
    //
    if (i < RawArgLength) {
        RemainingArg->Length = (USHORT)((RawArgLength - (i+1)) * sizeof(WCHAR));
        RemainingArg->MaximumLength = RemainingArg->Length;
        RemainingArg->Buffer = &RawArg.Buffer[i+1];
    }

    //DPRINT2(5, "FirstArg string: %ws {%d)\n",
    //        (FirstArg->Buffer != NULL) ? FirstArg->Buffer : L"<NULL>", FirstArg->Length);

    //DPRINT2(5, "RemainingArg string: %ws {%d)\n",
    //        (RemainingArg->Buffer != NULL) ? RemainingArg->Buffer : L"<NULL>", RemainingArg->Length);


    return TRUE;
}


BOOL
FrsCheckNameFilter(
    IN  PUNICODE_STRING Name,
    IN  PLIST_ENTRY FilterListHead
    )
/*++

Routine Description:

    Check the file name against each entry in the specified filter list.

Arguments:

    Name - The file name to check (no slashes, spaces, etc.)

    FilterListHead - The head of the filter list.

Return Value:

    TRUE if Name is found in the FilterList.

--*/
{

#undef DEBSUB
#define DEBSUB "FrsCheckNameFilter:"
    NTSTATUS Status;
    ULONG Length;
    BOOL  Found = FALSE;
    UNICODE_STRING UpcaseName;
    WCHAR  LocalBuffer[64];


    if (IsListEmpty(FilterListHead)) {
        return FALSE;
    }

    //
    // Upper case the name string.
    //
    Length = Name->Length;
    UpcaseName.Length = (USHORT) Length;
    UpcaseName.MaximumLength = (USHORT) Length;
    UpcaseName.Buffer = (Length > sizeof(LocalBuffer)) ? FrsAlloc(Length) : LocalBuffer;

    Status = RtlUpcaseUnicodeString(&UpcaseName, Name, FALSE);
    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "++ RtlUpcaseUnicodeString failed;", Status);
        FRS_ASSERT(!"RtlUpcaseUnicodeString failed");
        goto RETURN;
    }

    //
    // Walk the filter list, checking the name against each entry.
    //
    ForEachSimpleListEntry( FilterListHead, WILDCARD_FILTER_ENTRY, ListEntry,
        //
        // iterator pE is of type *WILDCARD_FILTER_ENTRY.
        //
        if (BooleanFlagOn(pE->Flags, WILDCARD_FILTER_ENTRY_IS_WILD)) {
            Found = FrsIsNameInExpression(&pE->UFileName, &UpcaseName, FALSE, NULL);
        } else {
            Found = RtlEqualUnicodeString(&pE->UFileName, &UpcaseName, FALSE);
        }

        if (Found) {
            break;
        }
    );

RETURN:

    //
    // Free the upcase buffer if we could not use the local one.
    //
    if (UpcaseName.Buffer != LocalBuffer) {
        FrsFree(UpcaseName.Buffer);
    }

    UpcaseName.Buffer = NULL;

    return Found;

}


VOID
FrsEmptyNameFilter(
    IN PLIST_ENTRY FilterListHead
)
/*++

Routine Description:

    Empty the filter list.

Arguments:

    FilterListHead - The list head to empty.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsEmptyNameFilter:"

    ForEachSimpleListEntry( FilterListHead, WILDCARD_FILTER_ENTRY, ListEntry,
        //
        // iterator pE is of type *WILDCARD_FILTER_ENTRY.
        //
        RemoveEntryList(&pE->ListEntry);
        FrsFreeType(pE);
    );

}


VOID
FrsLoadNameFilter(
    IN PUNICODE_STRING FilterString,
    IN PLIST_ENTRY FilterListHead
)
/*++

Routine Description:

    Parse the input filter string and create a new filter list.
    If the filter list passed in is not empty then it is emptied first.

Arguments:

    FilterString - The comma separated filter list.

    FilterListHead - The list head on which to create the filter entries.

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsLoadNameFilter:"

    NTSTATUS Status;
    ULONG Length;
    PWILDCARD_FILTER_ENTRY  FilterEntry;
    UNICODE_STRING UpcaseFilter, FirstArg;
    WCHAR  LocalBuffer[128];

    //
    // Empty the filter list if neessary.
    //
    FrsEmptyNameFilter(FilterListHead);

    //
    // Uppercase the new filter string.
    //
    DPRINT2(5, "++ filter string: %ws (%d)\n",
            (FilterString->Buffer != NULL) ? FilterString->Buffer : L"<NULL>",
            FilterString->Length);

    Length = FilterString->Length;
    UpcaseFilter.Length = (USHORT) Length;
    UpcaseFilter.MaximumLength = (USHORT) Length;
    UpcaseFilter.Buffer = (Length > sizeof(LocalBuffer)) ? FrsAlloc(Length) : LocalBuffer;

    Status = RtlUpcaseUnicodeString(&UpcaseFilter, FilterString, FALSE);
    if (!NT_SUCCESS(Status)) {
        DPRINT_NT(0, "++ RtlUpcaseUnicodeString failed;", Status);
        FRS_ASSERT(!"RtlUpcaseUnicodeString failed");
        goto RETURN;
    }

    //
    // Parse the comma list (skipping null entries) and create filter
    // entries for each one.
    //
    while (FrsDissectCommaList (UpcaseFilter, &FirstArg, &UpcaseFilter)) {

        Length = (ULONG) FirstArg.Length;

        if (Length == 0) {
            continue;
        }

        //DPRINT2(5, "++ FirstArg string: %ws {%d)\n",
        //        (FirstArg.Buffer != NULL) ? FirstArg.Buffer : L"<NULL>",
        //        FirstArg.Length);
        //
        // Allocate and init a wildcard filter entry.
        //
        FilterEntry = FrsAllocTypeSize(WILDCARD_FILTER_ENTRY_TYPE, Length);

        FilterEntry->UFileName.Length = FirstArg.Length;
        FilterEntry->UFileName.MaximumLength = FirstArg.MaximumLength;
        CopyMemory(FilterEntry->UFileName.Buffer, FirstArg.Buffer, Length);

        FilterEntry->UFileName.Buffer[Length/2] = UNICODE_NULL;

        //
        // Check for any wild card characters in the name.
        //
        if (FrsDoesNameContainWildCards(&FilterEntry->UFileName)) {
            SetFlag(FilterEntry->Flags, WILDCARD_FILTER_ENTRY_IS_WILD);
            //DPRINT1(5, "++ Wildcards found in %ws\n", FilterEntry->UFileName.Buffer);
        }

        //
        // Add the entry to the end of the filter list.
        //
        InsertTailList(FilterListHead, &FilterEntry->ListEntry);
    }

RETURN:

    //
    // Free the upcase buffer if we could not use the local one.
    //
    if (UpcaseFilter.Buffer != LocalBuffer) {
        FrsFree(UpcaseFilter.Buffer);
    }

    UpcaseFilter.Buffer = NULL;

    return;

}



ULONG
FrsParseIntegerCommaList(
    IN PWCHAR ArgString,
    IN ULONG MaxResults,
    OUT PLONG Results,
    OUT PULONG NumberResults,
    OUT PULONG Offset
)
/*++

Routine Description:

    Parse a list of integers separated by commas.
    The integers are returned in successive locations of the Results array.
    Null entries (e.g. ",,") return zero for the value.

Arguments:

    ArgString - The comma separated NULL terminated string with integer values.

    MaxResults - The maximum number of results that can be returned.

    Results - An array of the integer results.

    NumberResults - The number of results returned.

    Offset - The offset to the next byte to process in ArgString if there
             were not enough entries to return all the results.

Return Value:

    FrsErrorStatus.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsParseIntegerCommaList:"

    NTSTATUS Status;
    ULONG Length, i = 0;
    ULONG FStatus = FrsErrorSuccess;
    BOOL More;
    PWILDCARD_FILTER_ENTRY  FilterEntry;
    UNICODE_STRING TempUStr, FirstArg;


    RtlInitUnicodeString(&TempUStr, ArgString);
    //
    // Parse the comma list and convert each entry to a LONG.
    //
    while (More = FrsDissectCommaList (TempUStr, &FirstArg, &TempUStr) &&
           (i < MaxResults)) {

        Length = (ULONG) FirstArg.Length;
        Results[i] = 0;

        if (Length == 0) {
            i += 1;
            continue;
        }

        Status = RtlUnicodeStringToInteger (&FirstArg, 10, &Results[i]);
        if (!NT_SUCCESS(Status)) {
            DPRINT2_NT(1, "++ RtlUnicodeStringToInteger failed on arg %d of %ws :",
                    i, ArgString, Status);
            FStatus = FrsErrorBadParam;
        }

        i += 1;
    }

    *NumberResults = i;

    if (More) {
        //
        // There are more arguments to parse but we are out of the loop so
        // return MoreWork status along with the offset into ArgString where
        // we left off.
        //
        if (FStatus == FrsErrorSuccess) {
            FStatus = FrsErrorMoreWork;
        }

        *Offset = (ULONG)(FirstArg.Buffer - ArgString);
    }

    return FStatus;
}


DWORD
FrsSetFileAttributes(
    PWCHAR  Name,
    HANDLE  Handle,
    ULONG   FileAttributes
    )
/*++
Routine Description:
    This routine sets the file's attributes

Arguments:
    Name        - for error messages
    Handle      - Supplies a handle to the file that is to be marked for delete.
    Attributes  - Attributes for the file
Return Value:
    WStatus.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsSetFileAttributes:"
    IO_STATUS_BLOCK         IoStatus;
    FILE_BASIC_INFORMATION  BasicInformation;
    NTSTATUS                Status;
    DWORD                   WStatus = ERROR_SUCCESS;

    //
    // Set the attributes
    //
    ZeroMemory(&BasicInformation, sizeof(BasicInformation));
    BasicInformation.FileAttributes = FileAttributes | FILE_ATTRIBUTE_NORMAL;
    Status = NtSetInformationFile(Handle,
                                  &IoStatus,
                                  &BasicInformation,
                                  sizeof(BasicInformation),
                                  FileBasicInformation);
    if (!NT_SUCCESS(Status)) {
        WStatus = FrsSetLastNTError(Status);

        DPRINT1_NT(0, " ERROR - NtSetInformationFile(BasicInformation) failed on %ws :",
                    Name, Status);
    }
    return WStatus;
}


DWORD
FrsResetAttributesForReplication(
    PWCHAR  Name,
    HANDLE  Handle
    )
/*++
Routine Description:
    This routine turns off the attributes that prevent deletion and write

Arguments:
    Name    - for error messages
    Handle  - Supplies a handle to the file that is to be marked for delete.

Return Value:
    WStatus.
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsResetAttributesForReplication:"

    FILE_NETWORK_OPEN_INFORMATION FileInfo;
    DWORD   WStatus = ERROR_SUCCESS;

    //
    // Get the file's attributes
    //
    if (!FrsGetFileInfoByHandle(Name, Handle, &FileInfo)) {
        DPRINT1(4, "++ Can't get attributes for %ws\n", Name);
        WIN_SET_FAIL(WStatus);
        return WStatus;
    }

    //
    // Turn off the access attributes that prevent deletion and write
    //
    if (FileInfo.FileAttributes & NOREPL_ATTRIBUTES) {
        DPRINT1(4, "++ Reseting attributes for %ws\n", Name);
        WStatus = FrsSetFileAttributes(Name, Handle,
                                       FileInfo.FileAttributes &
                                       ~NOREPL_ATTRIBUTES);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT1(4, "++ Can't reset attributes for %ws\n", Name);
            return WStatus;
        }
        DPRINT1(4, "++ Attributes for %ws now allow replication\n", Name);
    } else {
        DPRINT1(4, "++ Attributes for %ws allow replication\n", Name);
    }

    return WStatus;
}


DWORD
FrsEnumerateDirectoryDeleteWorker(
    IN  HANDLE                      DirectoryHandle,
    IN  PWCHAR                      DirectoryName,
    IN  DWORD                       DirectoryLevel,
    IN  PFILE_DIRECTORY_INFORMATION DirectoryRecord,
    IN  DWORD                       DirectoryFlags,
    IN  PWCHAR                      FileName,
    IN  PVOID                       Ignored
    )
/*++
Routine Description:
    Empty a directory of non-replicating files and dirs if this is
    an ERROR_DIR_NOT_EMPTY and this is a retry change order for a
    directory delete.

Arguments:
    DirectoryHandle     - Handle for this directory.
    DirectoryName       - Relative name of directory
    DirectoryLevel      - Directory level (0 == root)
    DirectoryFlags      - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_
    DirectoryRecord     - Record from DirectoryHandle
    FileName            - From DirectoryRecord (w/terminating NULL)
    Ignored             - Context is ignored

Return Value:
    Win32 Status
--*/
{
#undef DEBSUB
#define DEBSUB  "FrsEnumerateDirectoryDeleteWorker:"
    DWORD                   WStatus;
    NTSTATUS                NtStatus;
    HANDLE                  Handle = INVALID_HANDLE_VALUE;
    UNICODE_STRING          ObjectName;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    IO_STATUS_BLOCK         IoStatusBlock;

    //
    // Depth first
    //
    if (DirectoryRecord->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        WStatus = FrsEnumerateDirectoryRecurse(DirectoryHandle,
                                               DirectoryName,
                                               DirectoryLevel,
                                               DirectoryRecord,
                                               DirectoryFlags,
                                               FileName,
                                               INVALID_HANDLE_VALUE,
                                               Ignored,
                                               FrsEnumerateDirectoryDeleteWorker);
        if (!WIN_SUCCESS(WStatus)) {
            goto CLEANUP;
        }
    }

    //
    // Relative open
    //
    ZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectName.Length = (USHORT)DirectoryRecord->FileNameLength;
    ObjectName.MaximumLength = (USHORT)DirectoryRecord->FileNameLength;
    ObjectName.Buffer = DirectoryRecord->FileName;
    ObjectAttributes.ObjectName = &ObjectName;
    ObjectAttributes.RootDirectory = DirectoryHandle;
    NtStatus = NtCreateFile(&Handle,
//                            GENERIC_READ | SYNCHRONIZE | DELETE | FILE_WRITE_ATTRIBUTES,
                            DELETE | SYNCHRONIZE | READ_ATTRIB_ACCESS | FILE_WRITE_ATTRIBUTES,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            NULL,                  // AllocationSize
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                            FILE_OPEN,
                                FILE_OPEN_FOR_BACKUP_INTENT |
                                FILE_OPEN_REPARSE_POINT |
                                FILE_SYNCHRONOUS_IO_NONALERT,
                            NULL,                  // EA buffer
                            0                      // EA buffer size
                            );

    //
    // Error opening file or directory
    //
    WStatus = FrsSetLastNTError(NtStatus);
    CLEANUP1_WS(0, "++ ERROR - NtCreateFile(%ws) failed :", FileName, WStatus, CLEANUP);

    //
    // Turn off readonly, system, and hidden
    //
    FrsResetAttributesForReplication(FileName, Handle);

    //
    // Delete the file
    //
    WStatus = FrsDeleteByHandle(FileName, Handle);
    DPRINT2(4, "++ Deleted file %ws\\%ws\n", DirectoryName, FileName);

CLEANUP:
    FRS_CLOSE(Handle);
    return WStatus;
}


DWORD
FrsEnumerateDirectoryRecurse(
    IN  HANDLE                      DirectoryHandle,
    IN  PWCHAR                      DirectoryName,
    IN  DWORD                       DirectoryLevel,
    IN  PFILE_DIRECTORY_INFORMATION DirectoryRecord,
    IN  DWORD                       DirectoryFlags,
    IN  PWCHAR                      FileName,
    IN  HANDLE                      FileHandle,
    IN  PVOID                       Context,
    IN PENUMERATE_DIRECTORY_ROUTINE Function
    )
/*++

Routine Description:

    Open the directory identified by FileName in the directory
    identified by DirectoryHandle and call FrsEnumerateDirectory().

Arguments:

    DirectoryHandle     - Handle for this directory.
    DirectoryName       - Relative name of directory
    DirectoryLevel      - Directory level
    DirectoryRecord     - From FrsEnumerateRecord()
    DirectoryFlags      - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_
    FileName            - Open this directory and recurse
    FileHandle          - Use for FileName if not INVALID_HANDLE_VALUE
    Context             - Passes global info from the caller to Function
    Function            - Called for every record

Return Value:

    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB "FrsEnumerateDirectoryRecurse:"

    DWORD               WStatus;
    NTSTATUS            NtStatus;
    HANDLE              LocalHandle   = INVALID_HANDLE_VALUE;
    UNICODE_STRING      ObjectName;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;


    //
    // Relative open
    //
    if (!HANDLE_IS_VALID(FileHandle)) {
        ZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
        ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
        ObjectName.Length = (USHORT)DirectoryRecord->FileNameLength;
        ObjectName.MaximumLength = (USHORT)DirectoryRecord->FileNameLength;
        ObjectName.Buffer = DirectoryRecord->FileName;
        ObjectAttributes.ObjectName = &ObjectName;
        ObjectAttributes.RootDirectory = DirectoryHandle;
        NtStatus = NtCreateFile(&LocalHandle,
//                                READ_ACCESS,
                                READ_ATTRIB_ACCESS | FILE_LIST_DIRECTORY,
                                &ObjectAttributes,
                                &IoStatusBlock,
                                NULL,                  // AllocationSize
                                FILE_ATTRIBUTE_NORMAL,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                FILE_OPEN,
                                    FILE_OPEN_FOR_BACKUP_INTENT |
                                    FILE_OPEN_REPARSE_POINT |
                                    FILE_SEQUENTIAL_ONLY |
                                    FILE_SYNCHRONOUS_IO_NONALERT,
                                NULL,                  // EA buffer
                                0                      // EA buffer size
                                );

        //
        // Error opening directory
        //
        if (!NT_SUCCESS(NtStatus)) {
            DPRINT1_NT(0, "++ ERROR - NtCreateFile(%ws) :", FileName, NtStatus);
            if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE) {
                //
                // Skip this directory tree
                //
                WStatus = ERROR_SUCCESS;
            } else {
                //
                // Abort the entire enumeration
                //
                WStatus = FrsSetLastNTError(NtStatus);
            }
            goto CLEANUP;
        }
        FileHandle = LocalHandle;
    }
    //
    // RECURSE
    //
    WStatus = FrsEnumerateDirectory(FileHandle,
                                    FileName,
                                    DirectoryLevel + 1,
                                    DirectoryFlags,
                                    Context,
                                    Function);
CLEANUP:
    FRS_CLOSE(LocalHandle);

    return WStatus;
}


DWORD
FrsEnumerateDirectory(
    IN HANDLE   DirectoryHandle,
    IN PWCHAR   DirectoryName,
    IN DWORD    DirectoryLevel,
    IN DWORD    DirectoryFlags,
    IN PVOID    Context,
    IN PENUMERATE_DIRECTORY_ROUTINE Function
    )
/*++

Routine Description:

    Enumerate the directory identified by DirectoryHandle, passing each
    directory record to Function. If the record is for a directory,
    call Function before recursing if ProcessBeforeCallingFunction
    is TRUE.

    Function controls the enumeration of the CURRENT directory
    by setting ContinueEnumeration to TRUE (continue) or
    FALSE (terminate).

    Function controls the enumeration of the entire directory
    tree by returning a WIN32 STATUS that is not ERROR_SUCCESS.

    FrsEnumerateDirectory() will terminate the entire directory
    enumeration by returning a WIN32 STATUS other than ERROR_SUCCESS
    when encountering an error.

    Context passes global info from the caller to Function.

Arguments:

    DirectoryHandle     - Handle for this directory.
    DirectoryName       - Relative name of directory
    DirectoryLevel      - Directory level
    DirectoryFlags      - See tablefcn.h, ENUMERATE_DIRECTORY_FLAGS_
    Context             - Passes global info from the caller to Function
    Function            - Called for every record

Return Value:

    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB "FrsEnumerateDirectory:"

    DWORD                       WStatus;
    NTSTATUS                    NtStatus;
    BOOL                        Recurse;
    PFILE_DIRECTORY_INFORMATION DirectoryRecord;
    PFILE_DIRECTORY_INFORMATION DirectoryBuffer = NULL;
    BOOLEAN                     RestartScan     = TRUE;
    PWCHAR                      FileName        = NULL;
    DWORD                       FileNameLength  = 0;
    DWORD                       NumBuffers      = 0;
    DWORD                       NumRecords      = 0;
    UNICODE_STRING              ObjectName;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    IO_STATUS_BLOCK             IoStatusBlock;
    extern LONG                 EnumerateDirectorySizeInBytes;

    DPRINT3(4, "++ Enumerating %ws at level %d using buffer size %d\n",
            DirectoryName, DirectoryLevel, EnumerateDirectorySizeInBytes);

    //
    // The buffer size is configurable with registry value
    // ENUMERATE_DIRECTORY_SIZE
    //
    DirectoryBuffer = FrsAlloc(EnumerateDirectorySizeInBytes);

NEXT_BUFFER:
    //
    // READ A BUFFER FULL OF DIRECTORY INFORMATION
    //

    NtStatus = NtQueryDirectoryFile(DirectoryHandle,   // Directory Handle
                                    NULL,              // Event
                                    NULL,              // ApcRoutine
                                    NULL,              // ApcContext
                                    &IoStatusBlock,
                                    DirectoryBuffer,
                                    EnumerateDirectorySizeInBytes,
                                    FileDirectoryInformation,
                                    FALSE,             // return single entry
                                    NULL,              // FileName
                                    RestartScan        // restart scan
                                    );
    //
    // Enumeration Complete
    //
    if (NtStatus == STATUS_NO_MORE_FILES) {
        WStatus = ERROR_SUCCESS;
        goto CLEANUP;
    }

    //
    // Error enumerating directory; return to caller
    //
    if (!NT_SUCCESS(NtStatus)) {
        DPRINT1_NT(0, "++ ERROR - NtQueryDirectoryFile(%ws) : ", DirectoryName, NtStatus);
        if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE) {
            //
            // Don't abort the entire enumeration; just this directory
            //
            WStatus = ERROR_SUCCESS;
        } else {
            //
            // Abort the entire enumeration
            //
            WStatus = FrsSetLastNTError(NtStatus);
        }
        goto CLEANUP;
    }
    ++NumBuffers;

    //
    // PROCESS DIRECTORY RECORDS
    //
    DirectoryRecord = DirectoryBuffer;
NEXT_RECORD:

    ++NumRecords;

    //
    // Filter . and ..
    //
    if (DirectoryRecord->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        //
        // Skip .
        //
        if (DirectoryRecord->FileNameLength == 2 &&
            DirectoryRecord->FileName[0] == L'.') {
            goto ADVANCE_TO_NEXT_RECORD;
        }

        //
        // Skip ..
        //
        if (DirectoryRecord->FileNameLength == 4 &&
            DirectoryRecord->FileName[0] == L'.' &&
            DirectoryRecord->FileName[1] == L'.') {
            goto ADVANCE_TO_NEXT_RECORD;
        }
    } else if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_DIRECTORIES_ONLY) {
        goto ADVANCE_TO_NEXT_RECORD;
    }

    //
    // Add a terminating NULL to the FileName (painful)
    //
    if (FileNameLength < DirectoryRecord->FileNameLength + sizeof(WCHAR)) {
        FrsFree(FileName);
        FileNameLength = DirectoryRecord->FileNameLength + sizeof(WCHAR);
        FileName = FrsAlloc(FileNameLength);
    }
    CopyMemory(FileName, DirectoryRecord->FileName, DirectoryRecord->FileNameLength);
    FileName[DirectoryRecord->FileNameLength / sizeof(WCHAR)] = UNICODE_NULL;

    //
    // Process the record
    //
    WStatus = (*Function)(DirectoryHandle,
                          DirectoryName,
                          DirectoryLevel,
                          DirectoryRecord,
                          DirectoryFlags,
                          FileName,
                          Context);
    if (!WIN_SUCCESS(WStatus)) {
        if (DirectoryFlags & ENUMERATE_DIRECTORY_FLAGS_ERROR_CONTINUE) {
            //
            // Don't abort the entire enumeration; just this entry
            //
            WStatus = ERROR_SUCCESS;
        } else {
            //
            // Abort the entire enumeration
            //
            goto CLEANUP;
        }
    }

ADVANCE_TO_NEXT_RECORD:
    //
    // Next record
    //
    if (DirectoryRecord->NextEntryOffset) {
        DirectoryRecord = (PVOID)(((PCHAR)DirectoryRecord) +
                                      DirectoryRecord->NextEntryOffset);
        goto NEXT_RECORD;
    }

    //
    // Done with this buffer; go get another one
    // But don't restart the scan for every loop!
    //
    RestartScan = FALSE;
    goto NEXT_BUFFER;

CLEANUP:
    FrsFree(FileName);
    FrsFree(DirectoryBuffer);

    DPRINT5(4, "++ Enumerating %ws at level %d has finished "
            "(%d buffers, %d records) with WStatus %s\n",
            DirectoryName, DirectoryLevel, NumBuffers, NumRecords, ErrLabelW32(WStatus));

    return WStatus;
}


DWORD
FrsFillDisk(
    IN PWCHAR   DirectoryName,
    IN BOOL     Cleanup
    )
/*++

Routine Description:

    Use all the disk space by creating a file in DirectoryName and
    allocating space down to the last byte.

    Delete the fill file if Cleanup is TRUE;

Arguments:

    DirectoryName       - Full pathname to the directory
    Cleanup             - Delete file if TRUE

Return Value:

    WIN32 STATUS (ERROR_DISK_FULL is mapped to ERROR_SUCCESS)

--*/
{
#undef DEBSUB
#define DEBSUB "FrsFillDisk:"

    DWORD               WStatus;
    NTSTATUS            NtStatus;
    DWORD               Tid;
    ULONGLONG           Eof;
    ULONGLONG           NewEof;
    ULONGLONG           IncEof;
    LARGE_INTEGER       LargeInteger;
    HANDLE              FileHandle      = INVALID_HANDLE_VALUE;
    HANDLE              DirectoryHandle = INVALID_HANDLE_VALUE;
    UNICODE_STRING      ObjectName;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    WCHAR               TidW[9];

    //
    // Open parent directory
    //
    WStatus = FrsOpenSourceFileW(&DirectoryHandle, DirectoryName, READ_ACCESS, OPEN_OPTIONS);
    CLEANUP1_WS(0, "++ DBG ERROR - Cannot open fill directory %ws;",
                DirectoryName, WStatus, CLEANUP);

    //
    // Relative open
    //
    Tid = GetCurrentThreadId();
    swprintf(TidW, L"%08x", Tid);
    ZeroMemory(&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectName.Length = (USHORT)(wcslen(TidW) * sizeof(WCHAR));
    ObjectName.MaximumLength = (USHORT)(wcslen(TidW) * sizeof(WCHAR));
    ObjectName.Buffer = TidW;
    ObjectAttributes.ObjectName = &ObjectName;
    ObjectAttributes.RootDirectory = DirectoryHandle;
    NtStatus = NtCreateFile(
        &FileHandle,
        GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE | DELETE | FILE_WRITE_ATTRIBUTES,
        &ObjectAttributes,
        &IoStatusBlock,
        NULL,                  // AllocationSize
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
            FILE_OPEN_FOR_BACKUP_INTENT |
            FILE_OPEN_REPARSE_POINT |
            FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,                  // EA buffer
        0                      // EA buffer size
        );

    //
    // Error opening file or directory
    //
    if (!NT_SUCCESS(NtStatus)) {
        WStatus = FrsSetLastNTError(NtStatus);
        CLEANUP1_NT(0, "++ DBG ERROR - NtCreateFile(%ws) : ", TidW, NtStatus, CLEANUP);
    }
    //
    // Remove fill file
    //
    if (Cleanup) {
        //
        // Turn off readonly, system, and hidden
        //
        FrsResetAttributesForReplication(TidW, FileHandle);

        //
        // Delete the file
        //
        WStatus = FrsDeleteByHandle(TidW, FileHandle);
        DPRINT2(4, "++ DBG - Deleted file %ws\\%ws\n", DirectoryName, TidW);

        LeaveCriticalSection(&DebugInfo.DbsOutOfSpaceLock);
        goto CLEANUP;
    }
    //
    // WARN: Hold the lock until the file is deleted
    //
    EnterCriticalSection(&DebugInfo.DbsOutOfSpaceLock);

    //
    // Create fill file
    //
    NewEof = 0;
    Eof = 0;
    for (IncEof = (LONGLONG)-1; IncEof; IncEof >>= 1) {
        NewEof = Eof;
        do {
            NewEof += IncEof;
            LargeInteger.QuadPart = NewEof;

            WStatus = FrsSetFilePointer(TidW, FileHandle, LargeInteger.HighPart,
                                                          LargeInteger.LowPart);
            if (!WIN_SUCCESS(WStatus)) {
                continue;
            }

            if (!SetEndOfFile(FileHandle)) {
                WStatus = GetLastError();
                continue;
            }

            DPRINT2(4, "++ DBG %ws: Allocated Eof is %08x %08x\n",
                        TidW, PRINTQUAD(NewEof));
            Eof = NewEof;
            WStatus = ERROR_SUCCESS;

        } while (WIN_SUCCESS(WStatus) && !FrsIsShuttingDown);
    }
    DPRINT3(4, "++ DBG - Allocated %d MB in %ws\\%ws\n",
            (DWORD)(Eof / (1024 * 1024)), DirectoryName, TidW);

CLEANUP:

    FRS_CLOSE(DirectoryHandle);
    FRS_CLOSE(FileHandle);

    return WStatus;
}


#define THIRTY_SECONDS      (30 * 1000)
ULONG
FrsRunProcess(
    IN PWCHAR   CommandLine,
    IN HANDLE   StandardIn,
    IN HANDLE   StandardOut,
    IN HANDLE   StandardError
    )
/*++

Routine Description:

    Run the specified command in a separate process.
    Wait for the process to complete.

Arguments:

    CommandLine  - Unicode, null terminated command line string.
    StandardIn   - Handle to use for standard in.
    StandardOut  - Handle to use for Standard Out.  NULL means use Debug log.
    StandardError - Handle to use for Standard Error.  NULL means use Debug log.

Return Value:

    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB "FrsRunProcess:"


#define MAX_CMD_LINE 1024

    ULONG               WStatus;
    LONG                WaitCount=20;
    BOOL                NeedDbgLock = FALSE;
    BOOL                CloseStandardIn = FALSE;
    BOOL                BStatus;
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION ProcessInfo;

    DWORD   Len;
    DWORD   TLen;
    WCHAR   ExpandedCmd[MAX_CMD_LINE+1];

    TLen = ARRAY_SZ(ExpandedCmd);

    //
    // Setup the process I/O Handles.
    //
    if (!HANDLE_IS_VALID(StandardIn)) {
        //
        // Provide a handle to the NUL device for input.
        //
        StandardIn = CreateFileW(
            L"NUL",                                     //  lpszName
            GENERIC_READ | GENERIC_WRITE,               //  fdwAccess
            FILE_SHARE_READ | FILE_SHARE_WRITE,         //  fdwShareMode
            NULL,                                       //  lpsa
            OPEN_ALWAYS,                                //  fdwCreate
            FILE_ATTRIBUTE_NORMAL,                      //  fdwAttrAndFlags
            NULL                                        //  hTemplateFile
            );

        if (!HANDLE_IS_VALID(StandardIn)) {
            WStatus = GetLastError();
            DPRINT_WS(0, "++ CreateFileW(NUL) failed;", WStatus);
            goto RETURN;
        }

        CloseStandardIn = TRUE;
    }

    if (!HANDLE_IS_VALID(StandardOut)) {
        StandardOut = DebugInfo.LogFILE;
        NeedDbgLock = TRUE;
    }

    if (!HANDLE_IS_VALID(StandardError)) {
        StandardError = DebugInfo.LogFILE;
        NeedDbgLock = TRUE;
    }



    memset(&StartupInfo, 0, sizeof(STARTUPINFO));

    StartupInfo.cb = sizeof(STARTUPINFO);

    StartupInfo.dwFlags = STARTF_USESTDHANDLES;
    StartupInfo.hStdInput = StandardIn;
    StartupInfo.hStdOutput = StandardOut;
    StartupInfo.hStdError = StandardError;

    //
    // Look for environment vars in command line and expand them.
    //
    Len = ExpandEnvironmentStrings(CommandLine, ExpandedCmd, TLen);
    if (Len == 0) {
        WStatus = GetLastError();
        DPRINT1_WS(1, "++ ws command not expanded.", CommandLine, WStatus);
        goto RETURN;
    }

    DPRINT1(0,"++ Running: %ws\n", ExpandedCmd);

    //
    // Get debug lock so our output stays in one piece.
    //
    if (NeedDbgLock) {DebLock();}

    BStatus = CreateProcessW(
                 NULL,                                // lpApplicationName,
                 ExpandedCmd,                         // lpCommandLine,
                 NULL,                                // lpProcessAttributes,
                 NULL,                                // lpThreadAttributes,
                 TRUE,                                // bInheritHandles,
                 DETACHED_PROCESS | CREATE_NO_WINDOW, // dwCreationFlags,
                 NULL,                                // lpEnvironment,
                 NULL,                                // lpCurrentDirectory,
                 &StartupInfo,                        // lpStartupInfo,
                 &ProcessInfo);                       // lpProcessInformation

    //
    // Close the process and thread handles
    //

    if ( !BStatus ) {
        if (NeedDbgLock) {DebUnLock();}
        WStatus = GetLastError();

        DPRINT1_WS(0, "++ CreateProcessW Failed to run: %ws,", CommandLine, WStatus);
        goto RETURN;
    }


    WStatus = WAIT_FAILED;
    while (--WaitCount > 0) {
        WStatus = WaitForSingleObject( ProcessInfo.hProcess, THIRTY_SECONDS);
        if (WStatus == WAIT_OBJECT_0) {
            break;
        }
        DPRINT_NOLOCK1(0, "++ Waiting for process complete -- Time remaining: %d seconds\n",
                WaitCount * (THIRTY_SECONDS / 1000));
    }

    if (NeedDbgLock) {DebUnLock();}

    GetExitCodeProcess( ProcessInfo.hProcess, &WStatus );

    if ( BStatus ) {
        DPRINT1(0, "++ CreateProcess( %ws) succeeds\n", CommandLine);
        DPRINT4(0, "++   ProcessInformation = hProcess %08x  hThread %08x"
                   "  ProcessId %08x  ThreadId %08x\n",
            ProcessInfo.hProcess, ProcessInfo.hThread, ProcessInfo.dwProcessId,
            ProcessInfo.dwThreadId);
    }

    if (WStatus == STILL_ACTIVE) {
        //
        // Didn't finish.  Bag it.
        //
        DPRINT(0, "++ Process failed to complete.  Terminating\n");

        WStatus = ERROR_PROCESS_ABORTED;

        if (!TerminateProcess(ProcessInfo.hProcess, WStatus)) {
            WStatus = GetLastError();
            DPRINT_WS(0, "++ Process termination request failed :", WStatus);
        }
    }  else {
        DPRINT1(0, "++ Process completed with status: %d\n", WStatus);
    }

    FRS_CLOSE( ProcessInfo.hThread  );
    FRS_CLOSE( ProcessInfo.hProcess );

RETURN:

    //
    // close stdin handle.
    //
    if (CloseStandardIn) {
        FRS_CLOSE(StandardIn);
    }

    return WStatus;

}

DWORD
FrsSetDacl(
    PWCHAR  RegName
    )
/*++

Routine Description:

    Add backup operators to the dacl for the specified registry key.

Arguments:

    RegName  - registry key (note HKEY_LOCAL_MACHINE becomes MACHINE)

Return Value:

    WIN32 STATUS


API-UPDATE  ...  API-UPDATE  ...  API-UPDATE  ...  API-UPDATE  ...  API-UPDATE  ...

From:   Anne Hopkins
Sent:   Tuesday, May 23, 2000 2:21 PM
To: Windows NT Development Announcements
Cc: Win32 API Changes Notification
Subject:    RE:  NT4 ACL API users should move to Win2K APIs

Sorry, the spec (and sample excerpt) referenced below is out-of-date

For Win2k security apis, use:
- public/sdk/inc/aclapi.h
- Platform SDK documentation (in MSDN) for reference and dev model

The reason to move to Win2k security APIs is to get the win2k Inheritance model,
with automatic propagation for File System and RGY ACLs.  (DS does its own ACL
propagation).  These APIs are also easier to use than the NT4 apis.


From:    Anne Hopkins
Sent:    Tuesday, May 23, 2000 10:49 AM
To:      Win32 API Changes Notification
Subject: NT4 ACL API users should move to Win2K APIs

If you use old NT 4 or prior ACL APIs, you should plan on updating them
to win2k APIs as described in the New Win32 Access Control API spec:

\\cpntserver\areas\Security\Authorization\Specs\access5.doc

If you can't do this for Whistler, be sure to plan for it in Blackcomb.

NT 4 API EXAMPLE:
GetNamedSecurityInfo([in]object, [out]ACL...)                                   // get the ACL from the file
BuildExplicitAccessWithName([out]ExplicitAccess, [in]TrusteeName, [in]Mask, )  // Build the new Explicit Access
SetEntriesInAcl([in]ExplicitAccess, [in]OldAcl, [out]NewAcl)                    // Add the new entry to the ACL
SetNameSecurityInfo([in]object, [in]NewACL...)                                  // write the ACL back onto the file

NT 5.0 EXAMPLE:
GetNamedSecurityInfoEx([in]object, [in] provider, [out] pAccessList)                // Get the access list from the file
BuildExplicitAccessWithName([out]ExplicitAccess, [in]TrusteeName, [in]Mask, )      // Build the access request
SetEntriesInAccessList([in]ExplicitAccess, [in] OldAccessList, [out]NewAccessList)  // Add it to the list
SetNameSecurityInfoEx([in]object, [in[ NewAccessList)                              // Write the access list back to the file


--*/
{
#undef DEBSUB
#define DEBSUB "FrsSetDacl"
    DWORD                   WStatus;
    PACL                    OldDACL;
    PACL                    NewDACL = NULL;
    PSECURITY_DESCRIPTOR    SD = NULL;
    PSID                    SystemSid = NULL;
    PSID                    AdminsSid = NULL;
    PSID                    EverySid = NULL;
    PSID                    BackupSid = NULL;
    EXPLICIT_ACCESS         ExplicitAccess[4];
    SID_IDENTIFIER_AUTHORITY SidNtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidWorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

    //
    // No registry key to process
    //
    if (!RegName) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get existing DACL
    //
    WStatus = GetNamedSecurityInfo(RegName,
                                   SE_REGISTRY_KEY,
                                   DACL_SECURITY_INFORMATION,
                                   NULL,
                                   NULL,
                                   &OldDACL,
                                   NULL,
                                   &SD);
    CLEANUP1_WS(0, "++ ERROR - GetNamedSecurityInfo(%ws);", RegName, WStatus, CLEANUP);

    //
    // Allocate the admins sid
    //
    if (!AllocateAndInitializeSid(&SidNtAuthority,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0,
                                  &AdminsSid)) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ WARN - AllocateAndInitializeSid(ADMINS);", WStatus, CLEANUP);
    }

    //
    // Allocate the system sid
    //
    if (!AllocateAndInitializeSid(&SidNtAuthority,
                                  1,
                                  SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &SystemSid)) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ WARN - AllocateAndInitializeSid(SYSTEM);", WStatus, CLEANUP);
    }

    //
    // Allocate the backup operators sid
    //
    if (!AllocateAndInitializeSid(&SidNtAuthority,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_BACKUP_OPS,
                                  0, 0, 0, 0, 0, 0,
                                  &BackupSid)) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ WARN - AllocateAndInitializeSid(BACKUP OPS);", WStatus, CLEANUP);
    }

    //
    // Allocate the everyone sid
    //
    if (!AllocateAndInitializeSid(&SidWorldAuthority,
                                  1,
                                  SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &EverySid)) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ WARN - AllocateAndInitializeSid(EVERYONE);", WStatus, CLEANUP);
    }

    //
    // Initialize an EXPLICIT_ACCESS structure to allow access
    //
    ZeroMemory(ExplicitAccess, sizeof(ExplicitAccess));
    //
    // Admins
    //
    ExplicitAccess[0].grfAccessPermissions = GENERIC_ALL;
    ExplicitAccess[0].grfAccessMode = SET_ACCESS;
    ExplicitAccess[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ExplicitAccess[0].Trustee.pMultipleTrustee = NULL;
    ExplicitAccess[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ExplicitAccess[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitAccess[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ExplicitAccess[0].Trustee.ptstrName = AdminsSid;

    //
    // System
    //
    ExplicitAccess[1].grfAccessPermissions = GENERIC_ALL;
    ExplicitAccess[1].grfAccessMode = SET_ACCESS;
    ExplicitAccess[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ExplicitAccess[1].Trustee.pMultipleTrustee = NULL;
    ExplicitAccess[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ExplicitAccess[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitAccess[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ExplicitAccess[1].Trustee.ptstrName = SystemSid;

    //
    // Backup
    //
    ExplicitAccess[2].grfAccessPermissions = GENERIC_ALL;
    ExplicitAccess[2].grfAccessMode = SET_ACCESS;
    ExplicitAccess[2].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ExplicitAccess[2].Trustee.pMultipleTrustee = NULL;
    ExplicitAccess[2].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ExplicitAccess[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitAccess[2].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ExplicitAccess[2].Trustee.ptstrName = BackupSid;

    //
    // Everyone
    //
    ExplicitAccess[3].grfAccessPermissions = GENERIC_READ;
    ExplicitAccess[3].grfAccessMode = SET_ACCESS;
    ExplicitAccess[3].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ExplicitAccess[3].Trustee.pMultipleTrustee = NULL;
    ExplicitAccess[3].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ExplicitAccess[3].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitAccess[3].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ExplicitAccess[3].Trustee.ptstrName = EverySid;

    //
    // Create an new ACL by merging the EXPLICIT_ACCESS structure
    // with the existing DACL
    //
    WStatus = SetEntriesInAcl(4, ExplicitAccess, OldDACL, &NewDACL);
    CLEANUP1_WS(0, "++ ERROR - SetEntriesInAcl(%ws);", RegName, WStatus, CLEANUP);

    //
    // attach the new ACL as the object's DACL
    //
    WStatus = SetNamedSecurityInfo(RegName,
                                   SE_REGISTRY_KEY,
                                   DACL_SECURITY_INFORMATION,
                                   NULL,
                                   NULL,
                                   NewDACL,
                                   NULL);
    CLEANUP1_WS(0, "++ ERROR - SetNamedSecurityInfo(%ws);", RegName, WStatus, CLEANUP);

CLEANUP:
    if (SD) {
        LocalFree((HLOCAL)SD);
    }
    if(NewDACL) {
        LocalFree((HLOCAL)NewDACL);
    }
    if (AdminsSid) {
        FreeSid(AdminsSid);
    }
    if (SystemSid) {
        FreeSid(SystemSid);
    }
    if (BackupSid) {
        FreeSid(BackupSid);
    }
    if (EverySid) {
        FreeSid(EverySid);
    }

    return WStatus;
}


#define FRS_FULL_ACCESS ( STANDARD_RIGHTS_ALL        | \
                          FILE_READ_DATA             | \
                          FILE_WRITE_DATA            | \
                          FILE_APPEND_DATA           | \
                          FILE_READ_EA               | \
                          FILE_WRITE_EA              | \
                          FILE_EXECUTE               | \
                          FILE_READ_ATTRIBUTES       | \
                          FILE_WRITE_ATTRIBUTES      | \
                          FILE_CREATE_PIPE_INSTANCE  | \
                          FILE_LIST_DIRECTORY        | \
                          FILE_ADD_FILE              | \
                          FILE_ADD_SUBDIRECTORY      | \
                          FILE_DELETE_CHILD          | \
                          FILE_TRAVERSE      )

DWORD
FrsRestrictAccessToFileOrDirectory(
    PWCHAR  Name,
    HANDLE  Handle,
    BOOL    NoInherit
    )
/*++

Routine Description:

    Restrict access to administrators and local system.

Arguments:

    Name    - File or directory name for error messages
    Handle  - opened handle for name.  If handle is NULL then open 'Name'.
    NoInherit - means that we overwrite the ACL on the file or DIR and
                do not inherit any ACL state from a parent dir.
                We want to do this on the FRS working dir and the staging dir.

Return Value:

    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB "FrsRestrictAccessToFileOrDirectory"

    DWORD                   WStatus = ERROR_SUCCESS;
    HANDLE                  LocalHandle = NULL;

    SECURITY_INFORMATION    SecurityInfo;

    EXPLICIT_ACCESS         ExplicitAccess[2];
    PACL                    NewDACL = NULL;
    SID_IDENTIFIER_AUTHORITY SidNtAuthority = SECURITY_NT_AUTHORITY;
    PSID                    SystemSid = NULL;
    PSID                    AdminsSid = NULL;

    //
    // No file or directory handle?
    //
    if (!HANDLE_IS_VALID(Handle)) {
        //
        // Open the directory
        //
        if (Name == NULL) {
            return ERROR_INVALID_PARAMETER;
        }

        LocalHandle = CreateFile(
            Name,
            GENERIC_WRITE | WRITE_DAC | FILE_READ_ATTRIBUTES | FILE_TRAVERSE,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS,
            NULL);

        if (!HANDLE_IS_VALID(LocalHandle)) {
            return GetLastError();
        }

        Handle = LocalHandle;
    }

    //
    // Allocate the admins sid
    //
    if (!AllocateAndInitializeSid(&SidNtAuthority,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0,
                                  &AdminsSid)) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ WARN - AllocateAndInitializeSid(ADMINS);", WStatus, CLEANUP);
    }

    //
    // Allocate the system sid
    //
    if (!AllocateAndInitializeSid(&SidNtAuthority,
                                  1,
                                  SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &SystemSid)) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ WARN - AllocateAndInitializeSid(SYSTEM);", WStatus, CLEANUP);
    }


    ZeroMemory(ExplicitAccess, sizeof(ExplicitAccess));
    ExplicitAccess[0].grfAccessPermissions = FRS_FULL_ACCESS;
    ExplicitAccess[0].grfAccessMode = SET_ACCESS;
    ExplicitAccess[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ExplicitAccess[0].Trustee.pMultipleTrustee = NULL;
    ExplicitAccess[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ExplicitAccess[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitAccess[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ExplicitAccess[0].Trustee.ptstrName = AdminsSid;


    ExplicitAccess[1].grfAccessPermissions = FRS_FULL_ACCESS;
    ExplicitAccess[1].grfAccessMode = SET_ACCESS;
    ExplicitAccess[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ExplicitAccess[1].Trustee.pMultipleTrustee = NULL;
    ExplicitAccess[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    ExplicitAccess[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    ExplicitAccess[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ExplicitAccess[1].Trustee.ptstrName = SystemSid;


    //
    // Create new ACL.
    //
    WStatus = SetEntriesInAcl(2, ExplicitAccess, NULL, &NewDACL);
    CLEANUP1_WS(0, "++ ERROR - SetEntriesInAcl(%ws);", Name, WStatus, CLEANUP);

    //
    // attach the new ACL as the object's DACL
    //   PROTECTED_DACL_SECURITY_INFORMATION - Means don't inherit ACLs from parent
    //
    SecurityInfo = DACL_SECURITY_INFORMATION;
    if (NoInherit) {
        SecurityInfo |= PROTECTED_DACL_SECURITY_INFORMATION;
    }

    WStatus = SetSecurityInfo(Handle,
                              SE_FILE_OBJECT,
                              SecurityInfo,
                              NULL,
                              NULL,
                              NewDACL,
                              NULL);

    CLEANUP1_WS(0, "++ ERROR - SetSecurityInfo(%ws);", Name, WStatus, CLEANUP);

CLEANUP:

    if(NewDACL) {
        LocalFree((HLOCAL)NewDACL);
    }
    if (SystemSid) {
        FreeSid(SystemSid);
    }
    if (AdminsSid) {
        FreeSid(AdminsSid);
    }
    FRS_CLOSE(LocalHandle);

    return WStatus;
}



ULONG
FrsProcessBackupRestore(
    VOID
    )
/*++

Routine Description:

    Check the registry to see if a restore has transpired.
    If so, delete the database and reset the registry as needed.

Arguments:

    None.

Return Value:

    WIN32 STATUS

--*/
{
#undef DEBSUB
#define DEBSUB "FrsProcessBackupRestore:"
    ULONG   WStatus;
    DWORD   KeyIdx;
    HKEY    hKey;

    HKEY    HBurKey = 0;
    HKEY    HCumuKey = 0;

    DWORD   GblBurFlags;
    DWORD   BurSetFlags;

    WCHAR   RegBuf[MAX_PATH + 1];

    //
    // Check for backup/restore in progress
    //    FRS_CONFIG_SECTION\backup/restore\Stop NtFrs from Starting
    //
    WStatus = CfgRegOpenKey(FKC_BKUP_STOP_SECTION_KEY, NULL, 0, &hKey);
    if (WIN_SUCCESS(WStatus)) {
        DPRINT_WS(0, ":S: WARN - Backup/Restore in progress; retry later.", WStatus);
        EPRINT1(EVENT_FRS_CANNOT_START_BACKUP_RESTORE_IN_PROGRESS, ComputerName);
        RegCloseKey(hKey);
        return ERROR_BUSY;
    }

    //
    // Open FRS_CONFIG_SECTION\backup/restore
    // Create it if it doesn't exist and put an ACL on it.
    //

    WStatus = CfgRegOpenKey(FKC_BKUP_SECTION_KEY, NULL, 0, &HBurKey);
    if (!WIN_SUCCESS(WStatus)) {

        WStatus = CfgRegOpenKey(FKC_BKUP_SECTION_KEY, NULL, FRS_RKF_CREATE_KEY, &HBurKey);
        CLEANUP_WS(0, "ERROR - Failed to create backup/restore key.", WStatus, CLEANUP_OK);

        //
        // New key; Ensure backup operators have access.
        //
        WStatus = FrsSetDacl(L"MACHINE\\" FRS_BACKUP_RESTORE_SECTION);
        DPRINT_WS(0, "WARN - FrsSetDacl failed on backup/restore key.", WStatus);

        //
        // Ignore errors
        //
        WStatus = ERROR_SUCCESS;
    }



    //
    // Move the Bur cumulative replica sets to the standard location
    //
    //     Open FRS_CONFIG_SECTION\backup/restore\Process at Startup\Cumulative Replica Sets
    //     Enumerate the Replica Sets.
    //
    CfgRegOpenKey(FKC_BKUP_MV_CUMSETS_SECTION_KEY, NULL,  FRS_RKF_CREATE_KEY,  &hKey);

    KeyIdx = 0;
    HCumuKey = 0;

    while (hKey) {

        WStatus = RegEnumKey(hKey, KeyIdx, RegBuf, MAX_PATH + 1);
        if (!WIN_SUCCESS(WStatus)) {
            if (WStatus != ERROR_NO_MORE_ITEMS) {
                DPRINT_WS(0, "WARN - Backup/restore enum.", WStatus);
            }
            break;
        }

        //
        //  Create the corresponding key in the standard location.
        //
        //      FRS_CONFIG_SECTION\Cumulative Replica Sets\<RegBuf>
        //
        CfgRegOpenKey(FKC_CUMSET_N_BURFLAGS, RegBuf,  FRS_RKF_CREATE_KEY,  &HCumuKey);

        if (HCumuKey) {
            RegCloseKey(HCumuKey);
            HCumuKey = 0;
        }

        //
        // Delete key from Backup/Restore section.
        //
        //     FRS_CONFIG_SECTION\backup/restore\Process at Startup\Cumulative Replica Sets\<RegBuf>
        //
        WStatus = RegDeleteKey(hKey, RegBuf);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2_WS(0, ":S: WARN - RegDeleteKey(%ws\\%ws);",
                    FRS_BACKUP_RESTORE_MV_CUMULATIVE_SETS_SECTION, RegBuf, WStatus);
            ++KeyIdx;
        }
    }

    if (hKey) {
        RegCloseKey(hKey);
        hKey = 0;
    }

    //
    // PROCESS Global Backup/Restore BURFLAGS
    //
    //      FRS_CONFIG_SECTION\backup/restore\Process at Startup\BurFlags
    //
    WStatus = CfgRegReadDWord(FKC_BKUP_STARTUP_GLOBAL_BURFLAGS, NULL, 0, &GblBurFlags);
    CLEANUP_WS(0, "ERROR - Failed to read Global BurFlags.", WStatus, CLEANUP_OK);

    //
    // Do we need to delete the database?
    //
    if ((GblBurFlags & NTFRSAPI_BUR_FLAGS_RESTORE) &&
        (GblBurFlags & NTFRSAPI_BUR_FLAGS_ALL_DIRECTORIES_AND_VOLUMES)) {

        DPRINT(4, ":S: Deleting database after full non-auth restore\n");

        WStatus = FrsDeletePath(JetPath, ENUMERATE_DIRECTORY_FLAGS_NONE);
        CLEANUP1_WS(0, ":S: ERROR - FrsDeletePath(%ws);", JetPath, WStatus, CLEANUP);

        DPRINT(4, ":S: Recreating database after full non-auth restore\n");
        //
        // Create the database directories
        //
        if (!CreateDirectory(JetPath, NULL)) {
            WStatus = GetLastError();
            if (!WIN_ALREADY_EXISTS(WStatus)) {
                CLEANUP1_WS(0, ":S: ERROR - CreateDirecotry(%ws);", JetPath, WStatus, CLEANUP);
            }
        }
        if (!CreateDirectory(JetSys, NULL)) {
            WStatus = GetLastError();
            if (!WIN_ALREADY_EXISTS(WStatus)) {
                CLEANUP1_WS(0, ":S: ERROR - CreateDirecotry(%ws);", JetSys, WStatus, CLEANUP);
            }
        }
        if (!CreateDirectory(JetTemp, NULL)) {
            WStatus = GetLastError();
            if (!WIN_ALREADY_EXISTS(WStatus)) {
                CLEANUP1_WS(0, ":S: ERROR - CreateDirecotry(%ws);", JetTemp, WStatus, CLEANUP);
            }
        }
        if (!CreateDirectory(JetLog, NULL)) {
            WStatus = GetLastError();
            if (!WIN_ALREADY_EXISTS(WStatus)) {
                CLEANUP1_WS(0, ":S: ERROR - CreateDirecotry(%ws);", JetLog, WStatus, CLEANUP);
            }
        }

        //
        // Enumerate the sets under "Cumulative Replica Sets" and mark them as not/primary
        //      FRS_CONFIG_SECTION\Cumulative Replica Sets
        //
        CfgRegOpenKey(FKC_CUMSET_SECTION_KEY, NULL,  FRS_RKF_CREATE_KEY,  &hKey);
        CLEANUP_WS(0, "ERROR - Failed to open Cumulative Replica Sets.", WStatus, CLEANUP);

        //
        // Enumerate the Replica Sets
        //
        KeyIdx = 0;

        while (TRUE) {
            WStatus = RegEnumKey(hKey, KeyIdx, RegBuf, MAX_PATH + 1);
            if (WStatus == ERROR_NO_MORE_ITEMS) {
                break;
            }
            CLEANUP_WS(0, "WARN - Cumulative Replica Sets enum.", WStatus, CLEANUP);

            //
            // Save type of restore in BurFlags for this replica set.
            //     FRS_CONFIG_SECTION\Cumulative Replica Sets\<RegBuf>\BurFlags
            //
            WStatus = CfgRegWriteDWord(FKC_CUMSET_N_BURFLAGS, RegBuf, 0, GblBurFlags);
            DPRINT_WS(0, "WARN - Cumulative Replica Sets BurFlags Write.", WStatus);

            ++KeyIdx;
        }

        if (hKey) {
            RegCloseKey(hKey);
            hKey = 0;
        }
    }  // End of Delete Data Base

    //
    // Move individual BurFlags into Cumulative Replica Sets
    //     Open FRS_CONFIG_SECTION\backup/restore\Process at Startup\Replica Sets
    //     Enumerate the Replica Sets
    //
    CfgRegOpenKey(FKC_BKUP_MV_SETS_SECTION_KEY, NULL,  FRS_RKF_CREATE_KEY,  &hKey);

    KeyIdx = 0;

    while (hKey) {
        WStatus = RegEnumKey(hKey, KeyIdx, RegBuf, MAX_PATH + 1);
        if (!WIN_SUCCESS(WStatus)) {
            if (WStatus != ERROR_NO_MORE_ITEMS) {
                DPRINT_WS(0, "WARN - Backup/restore enum.", WStatus);
            }
            break;
        }

        //
        // Get BurFlags
        //   FRS_CONFIG_SECTION\backup/restore\Process at Startup\Replica Sets\<RegBuf>\BurFlags
        //
        WStatus = CfgRegReadDWord(FKC_BKUP_STARTUP_SET_N_BURFLAGS,
                                  RegBuf,
                                  FRS_RKF_CREATE_KEY,
                                  &BurSetFlags);

        if (WIN_SUCCESS(WStatus)) {
            //
            // Write BurFlags
            //  FRS_CONFIG_SECTION\Cumulative Replica Sets\<RegBuf>\BurFlags
            //
            CfgRegWriteDWord(FKC_CUMSET_N_BURFLAGS,
                             RegBuf,
                             FRS_RKF_CREATE_KEY,
                             BurSetFlags);
        }

        //
        // Delete source data key.
        //   FRS_CONFIG_SECTION\backup/restore\Process at Startup\Replica Sets\<RegBuf>
        //
        WStatus = RegDeleteKey(hKey, RegBuf);
        if (!WIN_SUCCESS(WStatus)) {
            DPRINT2_WS(0, ":S: WARN - RegDeleteKey(%ws\\%ws);",
                    FRS_BACKUP_RESTORE_MV_SETS_SECTION, RegBuf, WStatus);
            ++KeyIdx;
        }
    }

    if (hKey) {
        RegCloseKey(hKey);
        hKey = 0;
    }

    //
    // Set backup/restore flags to 0
    //
    //      FRS_CONFIG_SECTION\backup/restore\Process at Startup\BurFlags
    //
    GblBurFlags = NTFRSAPI_BUR_FLAGS_NONE;

    WStatus = CfgRegWriteDWord(FKC_BKUP_STARTUP_GLOBAL_BURFLAGS, NULL, 0, GblBurFlags);
    CLEANUP_WS(0, "ERROR - Failed to clear Global BurFlags.", WStatus, CLEANUP);

    goto CLEANUP;

CLEANUP_OK:
    WStatus = ERROR_SUCCESS;

CLEANUP:

    if (HBurKey) {
        RegCloseKey(HBurKey);
    }

    return WStatus;
}


#define DEFAULT_MULTI_STRING_WCHARS (4)  // at least 8
VOID
FrsCatToMultiString(
    IN     PWCHAR   CatStr,
    IN OUT DWORD    *IOSize,
    IN OUT DWORD    *IOIdx,
    IN OUT PWCHAR   *IOStr
    )
/*++

Routine Description:

    Add a string + Catenation (if present) to the multi-string value

Arguments:

    CatStr   - string to concatenate
    IOSize   - Total size in wide chars of WStr
    IOIdx    - Current index to terminating \0 following \0 of last string
    IOStr    - Current string

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsCatToMultiString:"
    DWORD   NewSize;
    DWORD   CatSize;
    PWCHAR  Str;

    //
    // NOP
    //
    if (!CatStr) {
        return;
    }

    //
    // allocate initial buffer
    //
    if (!*IOStr) {
        *IOSize = DEFAULT_MULTI_STRING_WCHARS;
        *IOStr = FrsAlloc(*IOSize * sizeof(WCHAR));
        (*IOStr)[0] = L'\0';
        (*IOStr)[1] = L'\0';
        *IOIdx = 1;
    }

    //
    // Extend buffer when needed (note that CatStr overwrites first
    // \0 in the terminating \0\0. Hence, CatSize - 1 + 2 == CatSize + 1
    //
    CatSize = wcslen(CatStr);
    while ((CatSize + 1 + *IOIdx) >= *IOSize) {
        NewSize = *IOSize << 1;
        Str = FrsAlloc(NewSize * sizeof(WCHAR));
        CopyMemory(Str, *IOStr, *IOSize * sizeof(WCHAR));
        FrsFree(*IOStr);
        *IOStr = Str;
        *IOSize = NewSize;
    }
    //
    // Concatenate CatStr
    //
    *IOIdx -= 1;
    CopyMemory(&(*IOStr)[*IOIdx], CatStr, CatSize * sizeof(WCHAR));
    *IOIdx += CatSize;

    //
    // Append \0\0 and leave the index addressing the second \0.
    //
    (*IOStr)[*IOIdx] = L'\0';
    *IOIdx += 1;
    (*IOStr)[*IOIdx] = L'\0';

    FRS_ASSERT(*IOIdx < *IOSize);
}


VOID
FrsAddToMultiString(
    IN     PWCHAR   AddStr,
    IN OUT DWORD    *IOSize,
    IN OUT DWORD    *IOIdx,
    IN OUT PWCHAR   *IOStr
    )
/*++

Routine Description:

    Add a string + Catenation (if present) to the multi-string value

Arguments:

    AddStr   - string to add
    IOSize   - Total size in wide chars of WStr
    IOIdx    - Current index to terminating \0 following \0 of last string
    IOStr    - Current string

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsAddToMultiString:"
    DWORD   NewSize;
    DWORD   StrSize;
    PWCHAR  Str;

    //
    // NOP
    //
    if (!AddStr) {
        return;
    }

    //
    // allocate initial buffer
    //
    if (!*IOStr) {
        *IOSize = DEFAULT_MULTI_STRING_WCHARS;
        *IOStr = FrsAlloc(*IOSize * sizeof(WCHAR));
        *IOIdx = 0;
    }

    //
    // Extend buffer when needed
    //
    StrSize = wcslen(AddStr);
    while ((StrSize + 2 + *IOIdx) >= *IOSize) {
        NewSize = *IOSize << 1;
        Str = FrsAlloc(NewSize * sizeof(WCHAR));
        CopyMemory(Str, *IOStr, *IOSize * sizeof(WCHAR));
        FrsFree(*IOStr);
        *IOStr = Str;
        *IOSize = NewSize;
    }
    //
    // Append AddStr
    //
    CopyMemory(&(*IOStr)[*IOIdx], AddStr, StrSize * sizeof(WCHAR));
    *IOIdx += StrSize;

    //
    // Append \0\0 and leave the index addressing the second \0.
    //
    (*IOStr)[*IOIdx] = L'\0';
    *IOIdx += 1;
    (*IOStr)[*IOIdx] = L'\0';

    FRS_ASSERT(*IOIdx < *IOSize);
}



DWORD
UtilTranslateName(
    IN  PWCHAR              FromName,
    IN EXTENDED_NAME_FORMAT FromNameFormat,
    IN EXTENDED_NAME_FORMAT ToNameFormat,
    OUT PWCHAR              *OutToName
    )
/*++

Routine Description:

    Translate one name format into another

Arguments:

    FromName - Input, or source, name
    FromNameFormat - Format of FromName
    ToNameFormat - Desired format of *OutToName,
    OutToName - converted string; free with FrsFree()

Return Value:

    WIN32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "UtilTranslateName:"
    DWORD   WStatus;
    WCHAR   ToNameBuffer[MAX_PATH + 1];
    DWORD   ToNameSize = MAX_PATH + 1;
    PWCHAR  ToName = ToNameBuffer;

    *OutToName = NULL;

    if (!FromName) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Name -> Name (using stack buffer)
    //
    if (!TranslateName(FromName, FromNameFormat, ToNameFormat, ToName, &ToNameSize)) {
        WStatus = GetLastError();
    } else {
        WStatus = ERROR_SUCCESS;
    }
    //
    // Name -> Name (using FrsAlloc'ed buffer)
    //
    while (WIN_BUF_TOO_SMALL(WStatus)) {
        ToName = FrsAlloc((ToNameSize + 1) * sizeof(WCHAR));
        if (!TranslateName(FromName, FromNameFormat, ToNameFormat, ToName, &ToNameSize)) {
            WStatus = GetLastError();
            ToName = FrsFree(ToName);
        } else {
            WStatus = ERROR_SUCCESS;
        }
    }
    if (!WIN_SUCCESS(WStatus)) {
        DPRINT1_WS(4, "++ WARN - TranslateName(%ws);", FromName, WStatus);
        goto CLEANUP;
    }

    DPRINT2(5, "++ From -> To: %ws -> %ws\n",
            FromName, ToName);

    *OutToName = FrsWcsDup(ToName);

CLEANUP:
    if (ToName != ToNameBuffer) {
        FrsFree(ToName);
    }
    return WStatus;
}


DWORD
UtilConvertDnToStringSid(
    IN  PWCHAR  Dn,
    OUT PWCHAR  *OutStringSid
    )
/*++

Routine Description:

    Retries GetTokenInformation() with larger buffers.

Arguments:

    Dn - Dn of computer or user object
    OutStringSid - String'ized sid. Free with FrsFree();


Return Value:

    WIN32 Status

--*/
{
#undef DEBSUB
#define DEBSUB "UtilConvertDnToStringSid:"
    DWORD   WStatus;
    WCHAR   SamCompatibleBuffer[MAX_PATH + 1];
    DWORD   SamCompatibleSize = MAX_PATH + 1;
    PWCHAR  SamCompatible = SamCompatibleBuffer;

    if (OutStringSid) {
        *OutStringSid = NULL;
    }

    if (!Dn) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Dn -> Account (using stack buffer)
    //
    if (!TranslateName(Dn,
                       NameFullyQualifiedDN,
                       NameSamCompatible,
                       SamCompatible,
                       &SamCompatibleSize)) {
        WStatus = GetLastError();
    } else {
        WStatus = ERROR_SUCCESS;
    }
    //
    // Dn -> Account (using FrsAlloc'ed buffer)
    //
    while (WIN_BUF_TOO_SMALL(WStatus)) {
        SamCompatible = FrsAlloc((SamCompatibleSize + 1) * sizeof(WCHAR));
        if (!TranslateName(Dn,
                           NameFullyQualifiedDN,
                           NameSamCompatible,
                           SamCompatible,
                           &SamCompatibleSize)) {
            WStatus = GetLastError();
            SamCompatible = FrsFree(SamCompatible);
        } else {
            WStatus = ERROR_SUCCESS;
        }
    }
    CLEANUP1_WS(4, "++ WARN - TranslateName(%ws);", Dn, WStatus, CLEANUP);

    DPRINT2(5, "++ Dn -> Account: %ws -> %ws\n", Dn, SamCompatible);

CLEANUP:
    if (SamCompatible != SamCompatibleBuffer) {
        FrsFree(SamCompatible);
    }
    return WStatus;
}


DWORD
UtilGetTokenInformation(
    IN HANDLE                   TokenHandle,
    IN TOKEN_INFORMATION_CLASS  TokenInformationClass,
    IN DWORD                    InitialTokenBufSize,
    OUT DWORD                   *OutTokenBufSize,
    OUT PVOID                   *OutTokenBuf
    )
/*++

Routine Description:

    Retries GetTokenInformation() with larger buffers.

Arguments:
    TokenHandle             - From OpenCurrentProcess/Thread()
    TokenInformationClass   - E.g., TokenUser
    InitialTokenBufSize     - Initial buffer size; 0 = default
    OutTokenBufSize         - Resultant returned buf size
    OutTokenBuf             - free with with FrsFree()


Return Value:

    OutTokenBufSize - Size of returned info (NOT THE BUFFER SIZE!)
    OutTokenBuf - info of type TokenInformationClass. Free with FrsFree().

--*/
{
#undef DEBSUB
#define DEBSUB "UtilGetTokenInformation:"
    DWORD               WStatus;

    *OutTokenBuf = NULL;
    *OutTokenBufSize = 0;

    //
    // Check inputs
    //
    if (!HANDLE_IS_VALID(TokenHandle)) {
        return ERROR_INVALID_PARAMETER;
    }

    if (InitialTokenBufSize == 0 ||
        InitialTokenBufSize > (1024 * 1024)) {
        InitialTokenBufSize = 1024;
    }

    //
    // Retry if buffer is too small
    //
    *OutTokenBufSize = InitialTokenBufSize;
AGAIN:
    //
    // Need to check if *OutTokenBufSize == 0 as FrsAlloc asserts if called with 0 as the first parameter (prefix fix).
    //
    *OutTokenBuf = (*OutTokenBufSize == 0)? NULL : FrsAlloc(*OutTokenBufSize);
    WStatus = ERROR_SUCCESS;
    if (!GetTokenInformation(TokenHandle,
                             TokenInformationClass,
                             *OutTokenBuf,
                             *OutTokenBufSize,
                             OutTokenBufSize)) {
        WStatus = GetLastError();
        DPRINT2_WS(4, "++ WARN -  GetTokenInformation(Info %d, Size %d);",
                   TokenInformationClass, *OutTokenBufSize, WStatus);
        *OutTokenBuf = FrsFree(*OutTokenBuf);
        if (WIN_BUF_TOO_SMALL(WStatus)) {
            goto AGAIN;
        }
    }
    return WStatus;
}


VOID
UtilPrintUser(
    IN DWORD  Severity
    )
/*++

Routine Description:

    Print info about the user (privs, user sid).

Arguments:

    Severity    - for dprint

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "UtilPrintUser:"
    DWORD               WStatus;
    DWORD               TokenBufSize;
    PVOID               TokenBuf = NULL;
    HANDLE              TokenHandle = NULL;
    PWCHAR              SidStr;
    DWORD               i;
    TOKEN_PRIVILEGES    *Tp;
    TOKEN_USER          *Tu;
    DWORD               PrivLen;
    WCHAR               PrivName[MAX_PATH + 1];

    //
    // For this process/thread
    //
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &TokenHandle)) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ WARN - OpenProcessToken();", WStatus, CLEANUP);
    }

    //
    // Get the Token privileges from the access token for this thread or process
    //
    WStatus = UtilGetTokenInformation(TokenHandle,
                                      TokenPrivileges,
                                      0,
                                      &TokenBufSize,
                                      &TokenBuf);
    CLEANUP_WS(4, "++ UtilGetTokenInformation(TokenPrivileges);", WStatus, USER);

    //
    // Print token privileges
    //
    Tp = (TOKEN_PRIVILEGES *)TokenBuf;
    for (i = 0; i < Tp->PrivilegeCount; ++i) {
        PrivLen = MAX_PATH + 1;
        if (!LookupPrivilegeName(NULL, &Tp->Privileges[i].Luid, PrivName, &PrivLen)) {
            DPRINT_WS(0, "++ WARN -  LookupPrivilegeName();", WStatus);
            continue;
        }
        DPRINT5(Severity, "++ Priv %2d is %ws :%s:%s:%s:\n",
                i,
                PrivName,
                (Tp->Privileges[i].Attributes &  SE_PRIVILEGE_ENABLED_BY_DEFAULT) ? "Enabled by default" : "",
                (Tp->Privileges[i].Attributes &  SE_PRIVILEGE_ENABLED) ? "Enabled" : "",
                (Tp->Privileges[i].Attributes &  SE_PRIVILEGE_USED_FOR_ACCESS) ? "Used" : "");
    }
    TokenBuf = FrsFree(TokenBuf);

    //
    // Get the TokenUser from the access token for this process
    //
USER:
    WStatus = UtilGetTokenInformation(TokenHandle,
                                      TokenUser,
                                      0,
                                      &TokenBufSize,
                                      &TokenBuf);
    CLEANUP_WS(4, "++ UtilGetTokenInformation(TokenUser);", WStatus, CLEANUP);

    Tu = (TOKEN_USER *)TokenBuf;
    if (!ConvertSidToStringSid(Tu->User.Sid, &SidStr)) {
        WStatus = GetLastError();
        DPRINT_WS(4, "++ WARN - ConvertSidToStringSid();", WStatus);
    } else {
        DPRINT1(Severity, "++ User Sid: %ws\n", SidStr);
        LocalFree(SidStr);
    }
    TokenBuf = FrsFree(TokenBuf);

CLEANUP:
    FRS_CLOSE(TokenHandle);
    FrsFree(TokenBuf);
}


DWORD
UtilRpcServerHandleToAuthSidString(
    IN  handle_t    ServerHandle,
    IN  PWCHAR      AuthClient,
    OUT PWCHAR      *AuthSid
    )
/*++

Routine Description:

    Extract a the string'ized user sid from the rpc server handle
    by impersonating the caller and extracting the token info.

Arguments:

    ServerHandle - from the rpc serve call
    AuthClient - From the rpc server handle; for messages
    ClientSid - stringized user sid; free with FrsFree()

Return Value:

    Win32 Status.

--*/
{
#undef DEBSUB
#define DEBSUB "UtilRpcServerHandleToAuthSidString:"
    DWORD       WStatus;
    DWORD       WStatus2;
    DWORD       TokenBufSize;
    PWCHAR      SidStr;
    TOKEN_USER  *Tu;
    PVOID       TokenBuf = NULL;
    BOOL        Impersonated = FALSE;
    HANDLE      TokenHandle = NULL;

    //
    // Initialize return value
    //
    *AuthSid = NULL;

    //
    // Impersonate the rpc caller
    //
    WStatus = RpcImpersonateClient(ServerHandle);
    CLEANUP1_WS(0, "++ ERROR - RpcImpersonateClient(%ws);", AuthClient, WStatus, CLEANUP);

    Impersonated = TRUE;

    //
    // Open the impersonated thread token
    //
    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &TokenHandle)) {
        WStatus = GetLastError();
        CLEANUP_WS(0, "++ WARN - OpenProcessToken();", WStatus, CLEANUP);
    }

    //
    // Get the user sid
    //
    WStatus = UtilGetTokenInformation(TokenHandle,
                                      TokenUser,
                                      0,
                                      &TokenBufSize,
                                      &TokenBuf);
    CLEANUP_WS(4, "++ UtilGetTokenInformation(TokenUser);", WStatus, CLEANUP);

    //
    // Convert the sid into a string
    //
    Tu = (TOKEN_USER *)TokenBuf;
    if (!ConvertSidToStringSid(Tu->User.Sid, &SidStr)) {
        WStatus = GetLastError();
        CLEANUP_WS(4, "++ WARN - ConvertSidToStringSid();", WStatus, CLEANUP);
    } else {
        DPRINT1(5, "++ Client Sid is %ws\n", SidStr);
        *AuthSid = FrsWcsDup(SidStr);
        LocalFree(SidStr);
    }

    //
    // Done
    //
    WStatus = ERROR_SUCCESS;

CLEANUP:
    TokenBuf = FrsFree(TokenBuf);
    FRS_CLOSE(TokenHandle);

    if (Impersonated) {
        WStatus2 = RpcRevertToSelf();
        DPRINT1_WS(0, "++ ERROR IGNORED - RpcRevertToSelf(%ws);", AuthClient, WStatus2);
    }
    return WStatus;
}


BOOL
FrsSetupPrivileges (
    VOID
    )
/*++

Routine Description:

    Enable the privileges we need to replicate files.

Arguments:

    None.

Return Value:

    TRUE if got all privileges.

--*/
{

#undef DEBSUB
#define DEBSUB "FrsSetupPrivileges:"

    NTSTATUS Status;

    //
    // Get the SE_SECURITY_PRIVILEGE to read/write SACLs on files.
    //
    Status = SetupOnePrivilege(SE_SECURITY_PRIVILEGE, "Security");
    if (!NT_SUCCESS(Status)) {
        DPRINT_WS(0, "ERROR - Failed to get Security privilege.",
                              FrsSetLastNTError(Status));
        return FALSE;
    }
    //
    // Get backup/restore privilege to bypass ACL checks.
    //
    Status = SetupOnePrivilege(SE_BACKUP_PRIVILEGE, "Backup");
    if (!NT_SUCCESS(Status)) {
        DPRINT_WS(0, "ERROR - Failed to get Backup privilege.",
                              FrsSetLastNTError(Status));
        return FALSE;
    }

    Status = SetupOnePrivilege(SE_RESTORE_PRIVILEGE, "Restore");
    if (!NT_SUCCESS(Status)) {
        DPRINT_WS(0, "ERROR - Failed to get Restore privilege.",
                              FrsSetLastNTError(Status));
        return FALSE;
    }

    return TRUE;

#if 0

    //
    // Set priority privilege in order to raise our base priority.
    //

    SetupOnePrivilege(SE_INC_BASE_PRIORITY_PRIVILEGE,
                      "Increase base priority");

    //
    // Set quota privilege in order to accommodate large profile buffers.
    //

    SetupOnePrivilege(SE_INCREASE_QUOTA_PRIVILEGE,
                      "Increase quotas");
#endif
}


DWORD
FrsMarkHandle(
    IN HANDLE   VolumeHandle,
    IN HANDLE   Handle
    )
/*++

Routine Description:

    Mark the handle as so that the journal record records
    a flag that indicates "replication service is altering the file; ignore".

Arguments:

    VolumeHandle    - Used to check access
    Handle          - Handle to mark

Return Value:

    Win32 Status

--*/
{

#undef DEBSUB
#define DEBSUB "FrsMarkHandle:"

    DWORD               WStatus;
    DWORD               BytesReturned;
    MARK_HANDLE_INFO    MarkHandleInfo;


    //
    // Mark the handle as one of ours so that the journal thread
    // knows to ignore the usn records.
    //
    MarkHandleInfo.UsnSourceInfo = USN_SOURCE_REPLICATION_MANAGEMENT;
    MarkHandleInfo.VolumeHandle = VolumeHandle;
    MarkHandleInfo.HandleInfo = 0;

    if (!DeviceIoControl(Handle,
                         FSCTL_MARK_HANDLE,
                         (LPVOID)&MarkHandleInfo,
                         (DWORD)sizeof(MarkHandleInfo),
                         NULL,
                         0,
                         (LPDWORD)&BytesReturned,
                         NULL)) {

        WStatus = GetLastError();
        DPRINT_WS(0, "++ WARN - DeviceIoControl(MarkHandle);", WStatus);
    } else {
        WStatus = ERROR_SUCCESS;
        //DPRINT(0, "++ TEMP - DeviceIoControl(MarkHandle) Success\n");
    }

    return WStatus;
}


VOID
FrsCreateJoinGuid(
    OUT GUID *OutGuid
    )
/*++

Routine Description:

    Generate a random session id that is sizeof(GUID) in length.
    The session id must be very random becuase it is used to
    authenticate packets from our partners after a join.
    The join was authenticated using impersonation.

Arguments:

    Guid - Address of a guid

Return Value:

    None.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsCreateJoinGuid:"
    DWORD       WStatus;
    HCRYPTPROV  hProv;

    //
    // Acquire the context.
    // Consider caching the context if this function is called often.
    //
    if (!CryptAcquireContext(&hProv,
                             NULL,
                             NULL,
                             PROV_RSA_FULL,
                             CRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {
        WStatus = GetLastError();
        DPRINT_WS(0, "++ WARN - CryptAcquireContext();", WStatus);
        //
        // Can't use CryptGenRandom(); try using a guid
        //
        FrsUuidCreate(OutGuid);
    } else {
        //
        // Generate a random number
        //
        if (!CryptGenRandom(hProv, sizeof(GUID), (PBYTE)OutGuid)) {
            WStatus = GetLastError();
            DPRINT_WS(0, "++ WARN - CryptGenRandom();", WStatus);
            //
            // Can't use CryptGenRandom(); try using a guid
            //
            FrsUuidCreate(OutGuid);
        } else {
            DPRINT(5, "++ Created join guid\n");
        }

        //
        // Release the context
        //
        if (!CryptReleaseContext(hProv, 0)) {
            WStatus = GetLastError();
            DPRINT_WS(0, "++ ERROR - CryptReleaseContext();", WStatus);
        }
    }
}




VOID
FrsFlagsToStr(
    IN DWORD            Flags,
    IN PFLAG_NAME_TABLE NameTable,
    IN ULONG            Length,
    OUT PSTR            Buffer
    )
/*++

Routine Description:

    Routine to convert a Flags word to a descriptor string using the
    supplied NameTable.

Arguments:

    Flags - flags to convert.

    NameTable - An array of FLAG_NAME_TABLE structs.

    Length - Size of buffer in bytes.

    Buffer - buffer with returned string.

Return Value:

    Buffer containing printable string.

--*/
{
#undef DEBSUB
#define DEBSUB "FrsFlagsToStr:"

    PFLAG_NAME_TABLE pNT = NameTable;
    LONG Remaining = Length-1;


    FRS_ASSERT((Length > 4) && (Buffer != NULL));

    *Buffer = '\0';
    if (Flags == 0) {
        strncpy(Buffer, "<Flags Clear>", Length);
        return;
    }


    //
    // Build a string for each bit set in the Flag name table.
    //
    while ((Flags != 0) && (pNT->Flag != 0)) {

        if ((pNT->Flag & Flags) != 0) {
            Remaining -= strlen(pNT->Name);

            if (Remaining < 0) {
                //
                // Out of string buffer.  Tack a "..." at the end.
                //
                Remaining += strlen(pNT->Name);
                if (Remaining > 3) {
                    strcat(Buffer, "..." );
                } else {
                    strcpy(&Buffer[Length-4], "...");
                }
                return;
            }

            //
            // Tack the name onto the buffer and clear the flag bit so we
            // know what is left set when we run out of table.
            //
            strcat(Buffer, pNT->Name);
            ClearFlag(Flags, pNT->Flag);
        }

        pNT += 1;
    }

    if (Flags != 0) {
        //
        // If any flags are still set give them back in hex.
        //
        sprintf( &Buffer[strlen(Buffer)], "0x%08x ", Flags );
    }

    return;
}




DWORD
FrsDeleteByHandle(
    IN PWCHAR  Name,
    IN HANDLE  Handle
    )
/*++
Routine Description:
    This routine marks a file for delete, so that when the supplied handle
    is closed, the file will actually be deleted.

Arguments:
    Name    - for error messages
    Handle  - Supplies a handle to the file that is to be marked for delete.

Return Value:
    Win Status
--*/
{
#undef DEBSUB
#define DEBSUB "FrsDeleteByHandle:"

//
// NOTE:  This function is at the end of the module because we have to
// undefine DeleteFile to set the flag in the DispositionInfo struct.
//
#undef DeleteFile

    FILE_DISPOSITION_INFORMATION    DispositionInformation;
    IO_STATUS_BLOCK                 IoStatus;
    NTSTATUS                        NtStatus;

    if (!HANDLE_IS_VALID(Handle)) {
        return ERROR_SUCCESS;
    }

    //
    // Mark the file for delete. The delete happens when the handle is closed.
    //
    DispositionInformation.DeleteFile = TRUE;
    NtStatus = NtSetInformationFile(Handle,
                                    &IoStatus,
                                    &DispositionInformation,
                                    sizeof(DispositionInformation),
                                    FileDispositionInformation);
    DPRINT1_NT(4, "++ Could not delete %ws;", Name, NtStatus);

    return FrsSetLastNTError(NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apiacct.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiAcct.c

Abstract:

    This module contains individual API handlers for the Account APIs.

    SUPPORTED - NetAccountDeltas, NetAccountSync.

    SEE ALSO - Other NetLogon service APIs - in ApiLogon.c.

Author:

    Shanku Niyogi (w-shanku) 04-Apr-1991
    Jim Waters (t-jamesw) 09-August-1991

Revision History:

--*/


// Account APIs are UNICODE only. 

#ifndef UNICODE
#define UNICODE
#endif

#include "XactSrvP.h"

#include <netlibnt.h>
#include <crypt.h>     // must be included before <logonmsv.h>
#include <ntsam.h>     // must be included before <logonmsv.h>
#include <logonmsv.h>  // must be included before <ssi.h>
#include <ssi.h>       // I_NetAccountDeltas and I_NetAccountSync prototypes


NTSTATUS
XsNetAccountDeltas (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetAccountDeltas.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{

    NET_API_STATUS status;

    PXS_I_NET_ACCOUNT_DELTAS parameters = Parameters;
    LPTSTR nativeComputerName = NULL;       // Native parameters
    NETLOGON_AUTHENTICATOR authIn;
    NETLOGON_AUTHENTICATOR authOut;
    UAS_INFO_0 infoIn;
    DWORD entriesRead;
    DWORD totalEntries;
    UAS_INFO_0 infoOut;

    LPBYTE structure = NULL;                // Conversion variables

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(ACCOUNT) {
        NetpKdPrint(( "XsNetAccountDeltas: header at %lx, params at %lx, "
                      "buf size %ld\n",
                      Header,
                      parameters,
                      SmbGetUshort( &parameters->BufferLen )));
    }

    try {
        //
        // Convert parameters to Unicode, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 0 ) {

            status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeComputerName,
            (LPSTR)XsSmbGetPointer( &parameters->ComputerName )
            );

        //
        // Set up the input structures. This is to make sure that the
        // structures we pass to the API are naturally aligned, as well
        // as properly byte-aligned.
        //

        structure = (LPBYTE)XsSmbGetPointer( &parameters->RecordID );
        RtlCopyMemory( infoIn.ComputerName, structure, sizeof( infoIn.ComputerName ) );
        structure += sizeof( infoIn.ComputerName );
        infoIn.TimeCreated = SmbGetUlong( structure );
        structure += sizeof(DWORD);
        infoIn.SerialNumber = SmbGetUlong( structure );
        structure = (LPBYTE)XsSmbGetPointer( &parameters->Authenticator );
        RtlCopyMemory(
                &authIn.Credential,
                structure,
                sizeof(NETLOGON_CREDENTIAL)
                );
        structure += sizeof(NETLOGON_CREDENTIAL);
        authIn.timestamp = SmbGetUlong( structure );

        RtlZeroMemory( &authOut, sizeof(NETLOGON_AUTHENTICATOR) );

        //
        // Make the local I_NetAccountDeltas call.
        //

        status = NetpNtStatusToApiStatus(
                     I_NetAccountDeltas(
                         NULL,
                         nativeComputerName,
                         &authIn,
                         &authOut,
                         &infoIn,
                         (DWORD)SmbGetUshort( &parameters->Count ),
                         (DWORD)SmbGetUshort( &parameters->Level ),
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         (DWORD)SmbGetUshort( &parameters->BufferLen ),
                         (LPDWORD)&entriesRead,
                         (LPDWORD)&totalEntries,
                         &infoOut
                         ));

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetAccountDeltas: I_NetAccountDeltas failed: "
                              "%X\n", status ));
            }

            //
            // !!! When protocol level is available in the header information,
            //     we can check it. Right now, we ignore this code.
            //
            // For clients older than LanMan 2.1, return a different error code.
            // LANMAN 2.1 Protocol Level is 6.
            //

#if 0
            if ( status == NERR_TimeDiffAtDC && Header->ProtocolLevel < 6 ) {
                status = NERR_SyncRequired;
            }
#endif

            goto cleanup;
        }

        //
        // Fill in 16 bit return structures.
        //

        structure = parameters->NextRecordID;
        RtlCopyMemory( structure, infoOut.ComputerName, sizeof( infoOut.ComputerName ) );
        structure += sizeof( infoOut.ComputerName );
        SmbPutUlong( (LPDWORD)structure, infoOut.TimeCreated );
        structure += sizeof(DWORD);
        SmbPutUlong( (LPDWORD)structure, infoOut.SerialNumber );

        structure = parameters->RetAuth;
        RtlCopyMemory(
                structure,
                &authOut.Credential,
                sizeof(NETLOGON_CREDENTIAL)
                );

        structure += sizeof(NETLOGON_CREDENTIAL);
        SmbPutUlong( (LPDWORD)structure, authOut.timestamp );


        //
        // Fill in 16 bit return values.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesRead );
        SmbPutUshort( &parameters->TotalEntries, (WORD)totalEntries );

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Free strings.
    //

    NetpMemoryFree( nativeComputerName );

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetAccountDeltas


NTSTATUS
XsNetAccountSync (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetAccountSync.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{

    NET_API_STATUS status;

    PXS_I_NET_ACCOUNT_SYNC parameters = Parameters;
    LPTSTR nativeComputerName = NULL;       // Native parameters
    NETLOGON_AUTHENTICATOR authIn;
    NETLOGON_AUTHENTICATOR authOut;
    DWORD entriesRead;
    DWORD totalEntries;
    DWORD nextReference;
    UAS_INFO_0 infoOut;

    LPBYTE structure;                       // Conversion variables

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(ACCOUNT) {
        NetpKdPrint(( "XsNetAccountSync: header at %lx, params at %lx, "
                      "buf size %ld\n",
                      Header,
                      parameters,
                      SmbGetUshort( &parameters->BufferLen )));
    }
    // NetpBreakPoint();

    try {
        //
        // Convert parameters to Unicode, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 0 ) {

            status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeComputerName,
            (LPSTR)XsSmbGetPointer( &parameters->ComputerName )
            );

        //
        // Set up the input structure. This is to make sure that the
        // structure we pass to the API is naturally aligned, as well
        // as properly byte-aligned.
        //

        structure = (LPBYTE)XsSmbGetPointer( &parameters->Authenticator );
        RtlCopyMemory(
                &authIn.Credential,
                structure,
                sizeof(NETLOGON_CREDENTIAL)
                );
        structure += sizeof(NETLOGON_CREDENTIAL);
        authIn.timestamp = SmbGetUlong( structure );

        RtlZeroMemory( &authOut, sizeof(NETLOGON_AUTHENTICATOR) );


        //
        // Make the local I_NetAccountSync call.
        //

        status = NetpNtStatusToApiStatus(
                     I_NetAccountSync(
                         NULL,
                         nativeComputerName,
                         &authIn,
                         &authOut,
                         (DWORD)SmbGetUlong( &parameters->Reference ),
                         (DWORD)SmbGetUshort( &parameters->Level ),
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         (DWORD)SmbGetUshort( &parameters->BufferLen ),
                         (LPDWORD)&entriesRead,
                         (LPDWORD)&totalEntries,
                         (LPDWORD)&nextReference,
                         &infoOut
                         ));

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetAccountSync: I_NetAccountSync failed: "
                              "%X\n", status ));
            }

            //
            // !!! When protocol level is available in the header information,
            //     we can check it. Right now, we ignore this code.
            //
            // For clients older than LanMan 2.1, return a different error code.
            // LANMAN 2.1 Protocol Level is 6.
            //

#if 0
            if ( status == NERR_TimeDiffAtDC && Header->ProtocolLevel < 6 ) {
                status = NERR_SyncRequired;
            }
#endif

            goto cleanup;
        }

        //
        // Fill in 16 bit return structures.
        //

        structure = parameters->LastRecordID;
        RtlCopyMemory( structure, infoOut.ComputerName, sizeof( infoOut.ComputerName ) );
        structure += sizeof( infoOut.ComputerName );
        SmbPutUlong( (LPDWORD)structure, infoOut.TimeCreated );
        structure += sizeof(DWORD);
        SmbPutUlong( (LPDWORD)structure, infoOut.SerialNumber );

        structure = parameters->RetAuth;
        RtlCopyMemory(
                structure,
                &authOut.Credential,
                sizeof(NETLOGON_CREDENTIAL)
                );
        structure += sizeof(NETLOGON_CREDENTIAL);
        SmbPutUlong( (LPDWORD)structure, authOut.timestamp );

        //
        // Fill in 16 bit return values.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesRead );
        SmbPutUshort( &parameters->TotalEntries, (WORD)totalEntries );
        SmbPutUlong( &parameters->NextReference, nextReference );

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Free strings.
    //

    NetpMemoryFree( nativeComputerName );

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetAccountSync
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apiconn.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiConn.c

Abstract:

    This module contains individual API handlers for the NetConnection APIs.

    SUPPORTED : NetConnectionEnum.

Author:

    Shanku Niyogi (w-shanku) 26-Feb-1991

Revision History:

--*/

#include "XactSrvP.h"

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_connection_info_0 = REM16_connection_info_0;
STATIC const LPDESC Desc32_connection_info_0 = REM32_connection_info_0;
STATIC const LPDESC Desc16_connection_info_1 = REM16_connection_info_1;
STATIC const LPDESC Desc32_connection_info_1 = REM32_connection_info_1;


NTSTATUS
XsNetConnectionEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetConnectionEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_CONNECTION_ENUM parameters = Parameters;
    LPTSTR nativeQualifier = NULL;          // Native parameters
    LPVOID outBuffer = NULL;
    DWORD entriesRead;
    DWORD totalEntries;
    WORD bufferLength;

    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(CONNECTION) {
        NetpKdPrint(( "XsNetConnectionEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = (WORD)ERROR_INVALID_LEVEL;
            goto cleanup;

        }

        XsConvertTextParameter(
            nativeQualifier,
            (LPSTR)XsSmbGetPointer( &parameters->Qualifier )
            );

        bufferLength = SmbGetUshort( &parameters->BufLen );

        //
        // Make the local call.
        //

        status = NetConnectionEnum(
                     NULL,
                     nativeQualifier,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( bufferLength ),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetConnectionEnum: NetConnectionEnum failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(CONNECTION) {
            NetpKdPrint(( "XsNetConnectionEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_connection_info_0;
            StructureDesc = Desc16_connection_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_connection_info_1;
            StructureDesc = Desc16_connection_info_1;
            break;

        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (DWORD)bufferLength,
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(CONNECTION) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if ( (entriesFilled < totalEntries) ||
             (bytesRequired > bufferLength) ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    bufferLength,
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeQualifier );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} //XsNetConnectionEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apiacces.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    ApiAcces.c

Abstract:

    This module contains individual API handlers for the NetAccess APIs.

    SUPPORTED : NetAccessAdd, NetAccessDel, NetAccessEnum, NetAccessGetInfo,
                NetAccessGetUserPerms, NetAccessSetInfo.

Author:

    Shanku Niyogi (w-shanku)    13-Mar-1991

Revision History:

--*/

//
// Access APIs are UNICODE only.
//

#ifndef UNICODE
#define UNICODE
#endif

#include "xactsrvp.h"

//
// We do not support NetAccess apis from downlevel
//

#define RETURN_ACCESS_NOT_SUPPORTED    \
        API_HANDLER_PARAMETERS_REFERENCE;       \
        Header->Status = ERROR_NOT_SUPPORTED;


#ifdef NET_ACCESS_SUPPORTED

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_access_info_0 = REM16_access_info_0;
STATIC const LPDESC Desc32_access_info_0 = REM32_access_info_0;
STATIC const LPDESC Desc16_access_info_1 = REM16_access_info_1;
STATIC const LPDESC Desc32_access_info_1 = REM32_access_info_1;
STATIC const LPDESC Desc16_access_list = REM16_access_list;
STATIC const LPDESC Desc32_access_list = REM32_access_list;


STATIC NET_API_STATUS
XsNetAccessEnumVerify (
    IN NET_API_STATUS ConvertStatus,
    IN PBYTE ConvertedEntry,
    IN PBYTE BaseAddress
    )

/*++

Routine Description:


    This function is called by XsFillEnumBuffer after each entry is
    converted, in order to determine whether the entry should be retained
    in the enum buffer or discarded.


    The access_info_1 entries contain a number of auxiliary structures.
    The limit in LanMan 2.0 for these is 64. This function makes sure that
    entries with more than 64 structures are not returned. Note that the
    number of entries is not truncated to 64; if this data is received and
    used for a SetInfo, 32-bit data will be irretrievably lost.

Arguments:

    ConvertStatus - The return code from RapConvertSingleEntry.

    ConvertedEntry - The converted entry created by RapConvertSingleEntry.

    BaseAddress - A pointer to the base used to calculate offsets.

Return Value:

    NET_API_STATUS - NERR_Success if the entry should be retained, or
        an error code if the entry should be discarded.

--*/

{
    PACCESS_16_INFO_1 acc = (PACCESS_16_INFO_1)ConvertedEntry;

    UNREFERENCED_PARAMETER(BaseAddress);

    //
    // If RapConvertSingleEntry failed, discard the entry.
    //

    if ( ConvertStatus != NERR_Success ) {
        return ConvertStatus;
    }

    //
    // If there are more than 64 entries, discard the entry.
    //

    if ( SmbGetUshort( &acc->acc1_count ) > 64 ) {

        IF_DEBUG(CONVERT) {
            NetpKdPrint(( "XsNetAccessEnumVerify: too many aux. entries\n" ));
        }

        return ERROR_MORE_DATA;

    } else {

        return NERR_Success;
    }
}
#endif // NET_ACCESS_SUPPORTED


NTSTATUS
XsNetAccessAdd (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetAccessAdd.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#ifdef NET_ACCESS_SUPPORTED
    NET_API_STATUS status;

    PXS_NET_ACCESS_ADD parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC longDescriptor = NULL;
    LPDESC longNativeDescriptor = NULL;
    DWORD auxDataCount;
    DWORD bufferSize;
    DWORD i;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(ACCESS) {
        NetpKdPrint(( "XsNetAccessAdd: header at %lx, params at %lx, "
                      "level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 1 ) {

            Header->Status = (WORD)ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        StructureDesc = Desc16_access_info_1;
        AuxStructureDesc = Desc16_access_list;

        //
        // Figure out if there is enough room in the buffer for the fixed
        // structure. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE    // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessAdd: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find the auxiliary data structure count, and form a long descriptor
        // string which can be used to do all the conversion in one pass.
        //

        auxDataCount = RapAuxDataCount(
                           (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                           StructureDesc,
                           Response,
                           FALSE     // not in native format
                           );

        if ( auxDataCount > 64 ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessAdd: too many access_lists.\n" ));
            }
            Header->Status = NERR_ACFTooManyLists;
            goto cleanup;
        }

        longDescriptor = NetpMemoryAllocate(
                             strlen( StructureDesc )
                             + strlen( AuxStructureDesc ) * auxDataCount + 1 );
        longNativeDescriptor = NetpMemoryAllocate(
                                   strlen( Desc32_access_info_1 )
                                   + strlen( Desc32_access_list ) * auxDataCount
                                   + 1 );

        if (( longDescriptor == NULL ) || ( longNativeDescriptor == NULL )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessAdd: failed to allocate memory" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        strcpy( longDescriptor, StructureDesc );
        strcpy( longNativeDescriptor, Desc32_access_info_1 );
        for ( i = 0; i < auxDataCount; i++ ) {
            strcat( longDescriptor, AuxStructureDesc );
            strcat( longNativeDescriptor, Desc32_access_list );
        }

        //
        // Figure out if there is enough room in the buffer for all this
        // data. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 longDescriptor,
                 FALSE   // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessAdd: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find out how big a buffer we need to allocate to hold the native
        // 32-bit version of the input data structure.
        //

        bufferSize = XsBytesForConvertedStructure(
                         (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                         longDescriptor,
                         longNativeDescriptor,
                         RapToNative,
                         TRUE
                         );

        //
        // Allocate enough memory to hold the converted native buffer.
        //

        buffer = NetpMemoryAllocate( bufferSize );

        if ( buffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessAdd: failed to create buffer" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;

        }

        IF_DEBUG(ACCESS) {
            NetpKdPrint(( "XsNetAccessAdd: buffer of %ld bytes at %lx\n",
                          bufferSize, buffer ));
        }

        //
        // Convert the buffer from 16-bit to 32-bit.
        //

        stringLocation = (LPBYTE)buffer + bufferSize;
        bytesRequired = 0;

        status = RapConvertSingleEntry(
                (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                longDescriptor,
                TRUE,
                buffer,
                buffer,
                longNativeDescriptor,
                FALSE,
                &stringLocation,
                &bytesRequired,
                Response,
                RapToNative
                );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessAdd: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetAccessAdd(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     buffer,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessAdd: NetAccessAdd failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // There is no real return information for this API.
        //

cleanup:
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( buffer );
    NetpMemoryFree( longDescriptor );
    NetpMemoryFree( longNativeDescriptor );

#else // NET_ACCESS_SUPPORTED
    RETURN_ACCESS_NOT_SUPPORTED;
#endif // NET_ACCESS_SUPPORTED
    return STATUS_SUCCESS;

} // XsNetAccessAdd


NTSTATUS
XsNetAccessDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetAccessDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if NET_ACCESS_SUPPORTED
    NET_API_STATUS status;

    PXS_NET_ACCESS_DEL parameters = Parameters;
    LPTSTR nativeResource = NULL;           // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(ACCESS) {
        NetpKdPrint(( "XsNetAccessDel: header at %lx, params at %lx, "
                      "resource %s\n",
                      Header, parameters, SmbGetUlong( &parameters->Resource )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeResource,
            (LPSTR)SmbGetUlong( &parameters->Resource )
            );

        //
        // Make the local call.
        //

        status = NetAccessDel(
                     NULL,
                     nativeResource
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessDel: NetAccessDel failed: "
                              "%X\n", status ));
            }
        }

cleanup:
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeResource );

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;


#else // NET_ACCESS_SUPPORTED
    RETURN_ACCESS_NOT_SUPPORTED;
#endif // NET_ACCESS_SUPPORTED
    return STATUS_SUCCESS;
} // XsNetAccessDel


NTSTATUS
XsNetAccessEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetAccessEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if NET_ACCESS_SUPPORTED
    NET_API_STATUS status;

    PXS_NET_ACCESS_ENUM parameters = Parameters;
    LPTSTR nativeBasePath = NULL;           // Native parameters
    LPVOID outBuffer = NULL;
    DWORD  entriesRead;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                    // Conversion variables
    DWORD invalidEntries = 0;
    DWORD bytesRequired;
    LPDESC nativeStructureDesc;
    LPDESC nativeAuxStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(ACCESS) {
        NetpKdPrint(( "XsNetAccessEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Translate parameters, and check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = (WORD)ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeBasePath,
            (LPSTR)SmbGetUlong( &parameters->BasePath )
            );

        //
        // Make the local 32-bit call.
        //

        status = NetAccessEnum(
                     NULL,
                     nativeBasePath,
                     (DWORD)SmbGetUshort( &parameters->Recursive ),
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetAccessEnum: NetAccessEnum failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(ACCESS) {
            NetpKdPrint(( "XsNetAccessEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Determine descriptors based on level.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            StructureDesc = Desc16_access_info_0;
            nativeStructureDesc = Desc32_access_info_0;
            AuxStructureDesc = NULL;
            nativeAuxStructureDesc = NULL;

        case 1:

            StructureDesc = Desc16_access_info_1;
            nativeStructureDesc = Desc32_access_info_1;
            AuxStructureDesc = Desc16_access_list;
            nativeAuxStructureDesc = Desc32_access_list;

        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures. We call XsFillAuxEnumBuffer, because there may be
        // auxiliary structures. In level 0, auxiliary descriptors are NULL,
        // and XsFillAuxEnumBuffer will automatically call XsFillEnumBuffer.
        //

        XsFillAuxEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            nativeAuxStructureDesc,
            (LPVOID)SmbGetUlong( &parameters->Buffer ),
            (LPVOID)SmbGetUlong( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            AuxStructureDesc,
            &XsNetAccessEnumVerify,
            &bytesRequired,
            &entriesFilled,
            &invalidEntries
            );

        IF_DEBUG(ACCESS) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Because of the complexity of the
        // access structures, we'll send the data back unpacked.
        //

        if (( entriesFilled + invalidEntries ) < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail,
                          (WORD)( totalEntries - invalidEntries ));

cleanup:
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );


#else // NET_ACCESS_SUPPORTED
    RETURN_ACCESS_NOT_SUPPORTED;
#endif // NET_ACCESS_SUPPORTED
    return STATUS_SUCCESS;
} // XsNetAccessEnum


NTSTATUS
XsNetAccessGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetAccessGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if NET_ACCESS_SUPPORTED
    NET_API_STATUS status;

    PXS_NET_ACCESS_GET_INFO parameters = Parameters;
    LPTSTR nativeResource = NULL;           // Native parameters
    LPVOID outBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC longDescriptor = NULL;
    LPDESC longNativeDescriptor = NULL;
    DWORD auxDataCount;
    DWORD i;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(ACCESS) {
        NetpKdPrint(( "XsNetAccessGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, and check for errors.
        //

        switch ( SmbGetUshort( &parameters->Level )) {

        case 0:

            StructureDesc = Desc16_access_info_0;
            break;

        case 1:

            StructureDesc = Desc16_access_info_1;
            break;

        default:

            Header->Status = (WORD)ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeResource,
            (LPSTR)SmbGetUlong( &parameters->Resource )
            );

        //
        // Make the local call.
        //

        status = NetAccessGetInfo(
                     NULL,
                     nativeResource,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetAccessGetInfo: NetAccessGetInfo failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the 32-bit
        // structure we got back from NetAccessGetInfo. For a level 0 call,
        // the structure is described by the native descriptor string.
        // If the level is 1, form a long descriptor string which contains
        // enough copies of the auxiliary data descriptor. The format of the
        // 16-bit structure is stored in the transaction block - it must
        // also be converted to a long descriptor for level 1 calls.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            longDescriptor = NetpMemoryAllocate(
                                 strlen( Desc16_access_info_1 ) + 1 );
            longNativeDescriptor = NetpMemoryAllocate(
                                       strlen( Desc32_access_info_0 ) + 1 );

            if (( longDescriptor == NULL ) || ( longNativeDescriptor == NULL )) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetAccessGetInfo: failed to allocate memory" ));
                }
                Header->Status = NERR_NoRoom;
                goto cleanup;
            }

            strcpy( longDescriptor, Desc16_access_info_0 );
            strcpy( longNativeDescriptor, Desc32_access_info_0 );

            break;

        case 1:

            //
            // Find the auxiliary data count.
            //

            auxDataCount = RapAuxDataCount(
                               (LPBYTE)outBuffer,
                               Desc32_access_info_1,
                               Response,
                               TRUE   // native format
                               );

            //
            // 16-bit clients can only get 64 access list structures.
            //

            auxDataCount = ( auxDataCount > 64 ) ? 64 : auxDataCount;

            longDescriptor = NetpMemoryAllocate(
                                 strlen( Desc16_access_info_1 )
                                 + strlen( Desc16_access_list ) *
                                     auxDataCount + 1 );
            longNativeDescriptor = NetpMemoryAllocate(
                                       strlen( Desc32_access_info_1 )
                                       + strlen( Desc32_access_list ) * auxDataCount
                                       + 1 );

            if (( longDescriptor == NULL ) || ( longNativeDescriptor == NULL )) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetAccessGetInfo: failed to allocate memory" ));
                }
                Header->Status = (WORD)NERR_NoRoom;
                goto cleanup;
            }

            strcpy( longDescriptor, Desc16_access_info_1 );
            strcpy( longNativeDescriptor, Desc32_access_info_1 );
            for ( i = 0; i < auxDataCount; i++ ) {
                strcat( longDescriptor, Desc16_access_list );
                strcat( longNativeDescriptor, Desc32_access_list );
            }

            break;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( SmbGetUlong( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     longNativeDescriptor,
                     FALSE,
                     (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                     (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                     longDescriptor,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessGetInfo: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(ACCESS) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE     // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "NetAccessGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)SmbGetUlong( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    longDescriptor,
                                    1
                                    );
        }


        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( longDescriptor );
    NetpMemoryFree( longNativeDescriptor );
    NetpMemoryFree( nativeResource );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        longDescriptor,
        Header->Converter,
        1,
        Header->Status
        );


#else // NET_ACCESS_SUPPORTED
    RETURN_ACCESS_NOT_SUPPORTED;
#endif // NET_ACCESS_SUPPORTED
    return STATUS_SUCCESS;
} // XsNetAccessGetInfo


NTSTATUS
XsNetAccessGetUserPerms (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetAccessGetUserPerms.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if NET_ACCESS_SUPPORTED
    NET_API_STATUS status;

    PXS_NET_ACCESS_GET_USER_PERMS parameters = Parameters;
    LPTSTR nativeUgName = NULL;             // Native parameters
    LPTSTR nativeResource = NULL;
    DWORD userPerms;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeUgName,
            (LPSTR)SmbGetUlong( &parameters->UgName )
            );

        XsConvertTextParameter(
            nativeResource,
            (LPSTR)SmbGetUlong( &parameters->Resource )
            );

        //
        // Make the local call.
        //

        status = NetAccessGetUserPerms(
                     NULL,
                     nativeUgName,
                     nativeResource,
                     &userPerms
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessGetUserPerms: "
                              "NetAccessGetUserPerms failed: %X\n",
                              status ));
            }
        }

        //
        // Put perms into return field.
        //

        SmbPutUshort( &parameters->Perms, (WORD)userPerms );

cleanup:
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeUgName );
    NetpMemoryFree( nativeResource );

    Header->Status = (WORD)status;


#else // NET_ACCESS_SUPPORTED
    RETURN_ACCESS_NOT_SUPPORTED;
#endif // NET_ACCESS_SUPPORTED
    return STATUS_SUCCESS;
} // XsNetAccessGetUserPerms


NTSTATUS
XsNetAccessSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetAccessSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if NET_ACCESS_SUPPORTED
    NET_API_STATUS status;

    PXS_NET_ACCESS_SET_INFO parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters
    LPTSTR nativeResource = NULL;
    DWORD accessAttr;

    DWORD bufferSize;                       // Conversion variables
    LPBYTE stringLocation = NULL;
    DWORD bytesRequired = 0;
    LPDESC longDescriptor = NULL;
    LPDESC longNativeDescriptor = NULL;
    DWORD auxDataCount;
    DWORD i;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(ACCESS) {
        NetpKdPrint(( "XsNetAccessSetInfo: header at %lx, params at %lx,"
                      " level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, and check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 1 ) {

            Header->Status = (WORD)ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeResource,
            (LPSTR)SmbGetUlong( &parameters->Resource )
            );

        StructureDesc = Desc16_access_info_1;
        AuxStructureDesc = Desc16_access_list;

        //
        // The ParmNum can either be to change the whole ACL or just the auditing
        // attribute. Since the latter is much simpler than the former, check
        // for that ParmNum and process it. If not, we go through the elaborate
        // process of converting the whole buffer as in NetAccessAdd.
        //

        switch ( SmbGetUshort( &parameters->ParmNum )) {

        case ACCESS_ATTR_PARMNUM:

            if ( SmbGetUshort( &parameters->BufLen ) < sizeof(WORD)) {

                Header->Status= NERR_BufTooSmall;
                goto cleanup;
            }

            accessAttr = (DWORD)SmbGetUshort(
                                   (LPWORD)SmbGetUlong( &parameters->Buffer )
                                   );

            buffer = &accessAttr;

            break;

        case PARMNUM_ALL:

            //
            // Figure out if there is enough room in the buffer for the fixed
            // structure. If not, return NERR_BufTooSmall.
            //

            if ( !XsCheckBufferSize(
                     SmbGetUshort( &parameters->BufLen ),
                     StructureDesc,
                     FALSE    // not in native format
                    )) {

                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetAccessSetInfo: Buffer too small.\n" ));
                }
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            //
            // Find the auxiliary data structure count, and form a long descriptor
            // string which can be used to do all the conversion in one pass.
            //

            auxDataCount = RapAuxDataCount(
                               (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                               StructureDesc,
                               Response,
                               FALSE   // not in native format
                               );

            if ( auxDataCount > 64 ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetAccessSetInfo: too many access_lists.\n" ));
                }
                Header->Status = NERR_ACFTooManyLists;
                goto cleanup;
            }

            longDescriptor = NetpMemoryAllocate(
                                 strlen( StructureDesc )
                                 + strlen( AuxStructureDesc ) * auxDataCount
                                 + 1 );
            longNativeDescriptor = NetpMemoryAllocate(
                                       strlen( Desc32_access_info_1 )
                                       + strlen( Desc32_access_list ) * auxDataCount
                                       + 1 );

            if (( longDescriptor == NULL ) || ( longNativeDescriptor == NULL )) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetAccessSetInfo: failed to allocate memory" ));
                }
                Header->Status = NERR_NoRoom;
                goto cleanup;
            }

            strcpy( longDescriptor, StructureDesc );
            strcpy( longNativeDescriptor, Desc32_access_info_1 );
            for ( i = 0; i < auxDataCount; i++ ) {
                strcat( longDescriptor, AuxStructureDesc );
                strcat( longNativeDescriptor, Desc32_access_list );
            }

            //
            // Figure out if there is enough room in the buffer for all this
            // data. If not, return NERR_BufTooSmall.
            //

            if ( !XsCheckBufferSize(
                     SmbGetUshort( &parameters->BufLen ),
                     longDescriptor,
                     FALSE   // not in native format
                    )) {

                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetAccessSetInfo: Buffer too small.\n" ));
                }
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            //
            // Find out how big a buffer we need to allocate to hold the native
            // 32-bit version of the input data structure.
            //

            bufferSize = XsBytesForConvertedStructure(
                             (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                             longDescriptor,
                             longNativeDescriptor,
                             RapToNative,
                             TRUE
                             );

            //
            // Allocate enough memory to hold the converted native buffer.
            //

            buffer = NetpMemoryAllocate( bufferSize );

            if ( buffer == NULL ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetAccessSetInfo: failed to create buffer" ));
                }
                Header->Status = NERR_NoRoom;
                goto cleanup;

            }

            IF_DEBUG(ACCESS) {
                NetpKdPrint(( "XsNetAccessSetInfo: buffer of %ld bytes at %lx\n",
                              bufferSize, buffer ));
            }

            //
            // Convert the buffer from 16-bit to 32-bit.
            //

            stringLocation = (LPBYTE)buffer + bufferSize;
            bytesRequired = 0;

            status = RapConvertSingleEntry(
                         (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                         longDescriptor,
                         TRUE,
                         buffer,
                         buffer,
                         longNativeDescriptor,
                         FALSE,
                         &stringLocation,
                         &bytesRequired,
                         Response,
                         RapToNative
                         );

            if ( status != NERR_Success ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetAccessSetInfo: "
                                  "RapConvertSingleEntry failed: %X\n",
                                  status ));
                }

                Header->Status = NERR_InternalError;
                goto cleanup;
            }

            break;

        }

        //
        // Make the local call.
        //

        status = NetAccessSetInfo(
                     NULL,
                     nativeResource,
                     PARMNUM_BASE_INFOLEVEL + SmbGetUshort( &parameters->ParmNum ),
                     buffer,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetAccessSetInfo: NetAccessSetInfo failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // There is no real return information for this API.
        //

cleanup:
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeResource );

    //
    // If there is a 32-bit native buffer, free it.
    //

    if ( SmbGetUshort( &parameters->ParmNum ) == PARMNUM_ALL ) {

        NetpMemoryFree( buffer );
        NetpMemoryFree( longDescriptor );
        NetpMemoryFree( longNativeDescriptor );
    }


#else // NET_ACCESS_SUPPORTED
    RETURN_ACCESS_NOT_SUPPORTED;
#endif // NET_ACCESS_SUPPORTED
    return STATUS_SUCCESS;
} // XsNetAccessSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\util\waittime.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
    waittime.c

Abstract:
    A timeout list is managed by a thread waiting on a
    waitable timer.

    The timer can be adjusted without context switching to the
    thread that is waiting on the timer.

    An entry can be pulled off the list. The timer is adjusted
    if the entry was at the head of the queue.

    The queue is sorted by timeout value. The timeout value is
    an absolute filetime.

    The list entry is a command packet. The generic command
    packet contains a field for the wait time in milliseconds.
    This code takes the wait time and converts it into an
    absolute filetime when the command packet is put on the
    queue. The timeout triggers when the time is equal to or
    greater than the command packet's filetime.

Author:
    Billy J. Fuller 21-Feb-1998

Environment
    User mode winnt

--*/

#include <ntreppch.h>
#pragma  hdrstop

#include <frs.h>

//
// Struct for the Delayed Command Server
//      Contains info about the queues and the threads
//
//
// The wait thread exits if nothing shows up in 5 minutes.
//
#define WAIT_EXIT_TIMEOUT               (5 * 60 * 1000) // 5 minutes

//
// A command packet times out if the current time is within
// 1 second of the requested timeout value (avoids precision
// problems with the waitable timer).
//
#define WAIT_FUZZY_TIMEOUT              (1 * 1000 * 1000 * 10)

//
// When creating the wait thread, retry 10 times with a one
// second sleep in between retries
//
#define WAIT_RETRY_CREATE_THREAD_COUNT  (10)        // retry 10 times
#define WAIT_RETRY_TIMEOUT              (1 * 1000)  // 1 second

//
// The thread is running (or not). Exit after 5 minutes of idleness.
// Recreate on demand.
//
DWORD       WaitIsRunning;

//
// List of timeout commands
//
CRITICAL_SECTION    WaitLock;
CRITICAL_SECTION    WaitUnsubmitLock;
LIST_ENTRY          WaitList;

//
// Waitable timer. The thread waits on the timer and the queue's rundown event.
//
HANDLE      WaitableTimer;

//
// Current timeout trigger in WaitableTimer
//
LONGLONG    WaitFileTime;

//
// Set when the wait list is rundown
//
HANDLE      WaitRunDown;
BOOL        WaitIsRunDown;


VOID
WaitStartThread(
    VOID
    )
/*++
Routine Description:
    Start the wait thread if it isn't running. The timer has been
    set by the caller. The caller holds the WaitLock.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "WaitStartThread:"
    DWORD       Retries;
    DWORD       MainWait(PVOID Arg);

    //
    // Caller holds WaitLock
    //

    //
    // Thread is running; done
    //
    if (WaitIsRunning) {
        return;
    }
    //
    // Queue is rundown; don't start
    //
    if (WaitIsRunDown) {
        DPRINT(4, "Don't start wait thread; queue is rundown.\n");
        return;
    }
    //
    // Queue is empty; don't start
    //
    if (IsListEmpty(&WaitList)) {
        DPRINT(4, "Don't start wait thread; queue is empty.\n");
        return;
    }

    //
    // Start the wait thread. Retry several times.
    //
    if (!WaitIsRunning) {
        Retries = WAIT_RETRY_CREATE_THREAD_COUNT;
        while (!WaitIsRunning && Retries--) {
            WaitIsRunning = ThSupCreateThread(L"Wait", &WaitList, MainWait, ThSupExitWithTombstone);
            if (!WaitIsRunning) {
                DPRINT(0, "WARN: Wait thread could not be started; retry later.\n");
                Sleep(1 * 1000);
            }
        }
    }
    //
    // Can't start the wait thread. Something is very wrong. Shutdown.
    //
    if (!WaitIsRunning) {
        FrsIsShuttingDown = TRUE;
        SetEvent(ShutDownEvent);
        return;
    }
}

VOID
WaitReset(
    IN BOOL ResetTimer
    )
/*++
Routine Description:
    Complete the command packets that have timed out. Reset the timer.

    Caller holds WaitLock.

Arguments:
    ResetTimer  - reset timer always

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "WaitReset:"
    PCOMMAND_PACKET Cmd;
    PLIST_ENTRY     Entry;
    LONGLONG        Now;
    BOOL            StartThread = FALSE;

    //
    // Entries are sorted by absolute timeout
    //
    if (IsListEmpty(&WaitList)) {
        //
        // Allow the thread to exit in 5 minutes if no work shows up
        //
        if (WaitIsRunning) {
            FrsNowAsFileTime(&Now);
            WaitFileTime = Now + ((LONGLONG)WAIT_EXIT_TIMEOUT * 1000 * 10);
            ResetTimer = TRUE;
        }
    } else {
        StartThread = TRUE;
        Entry = GetListNext(&WaitList);
        Cmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        //
        // Reset timeout
        //
        if ((Cmd->WaitFileTime != WaitFileTime) || ResetTimer) {
            WaitFileTime = Cmd->WaitFileTime;
            ResetTimer = TRUE;
        }
    }
    //
    // Reset the timer
    //
    if (ResetTimer) {
        DPRINT1(4, "Resetting timer to %08x %08x.\n", PRINTQUAD(WaitFileTime));

        if (!SetWaitableTimer(WaitableTimer, (LARGE_INTEGER *)&WaitFileTime, 0, NULL, NULL, TRUE)) {
            DPRINT_WS(0, "ERROR - Resetting timer;", GetLastError());
        }
    }
    //
    // Make sure the thread is running
    //
    if (StartThread && !WaitIsRunning) {
        WaitStartThread();
    }
}


VOID
WaitUnsubmit(
    IN PCOMMAND_PACKET  Cmd
    )
/*++
Routine Description:
    Pull the command packet off of the timeout queue and adjust
    the timer. NOP if the command packet is not on the command queue.

Arguments:
    Cmd - command packet to pull off the queue

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "WaitUnsubmit:"
    BOOL    Reset = FALSE;

    //
    // Defensive
    //
    if (Cmd == NULL) {
        return;
    }

    DPRINT5(4, "UnSubmit cmd %08x (%08x) for timeout (%08x) in %d ms (%08x)\n",
            Cmd->Command, Cmd, Cmd->TimeoutCommand, Cmd->Timeout, Cmd->WaitFlags);

    EnterCriticalSection(&WaitLock);
    EnterCriticalSection(&WaitUnsubmitLock);

    //
    // Entries are sorted by absolute timeout
    //
    if (CmdWaitFlagIs(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST)) {
        RemoveEntryListB(&Cmd->ListEntry);
        ClearCmdWaitFlag(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST);
        Reset = TRUE;
    }
    LeaveCriticalSection(&WaitUnsubmitLock);
    //
    // Reset the timer if the expiration time has changed
    //
    if (Reset) {
        WaitReset(FALSE);
    }
    LeaveCriticalSection(&WaitLock);
}


VOID
WaitProcessCommand(
    IN PCOMMAND_PACKET  Cmd,
    IN DWORD            ErrorStatus
    )
/*++
Routine Description:
    Process the timed out command packet. The timeout values are
    unaffected.

Arguments:
    Cmd         - command packet that timed out or errored out
    ErrorStatus - ERROR_SUCCESS if timed out

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "WaitProcessCommand:"

    DPRINT5(4, "Process cmd %08x (%08x) for timeout (%08x) in %d ms (%08x)\n",
            Cmd->Command, Cmd, Cmd->TimeoutCommand, Cmd->Timeout, Cmd->WaitFlags);

    switch (Cmd->TimeoutCommand) {
        //
        // Submit a command
        //
        case CMD_DELAYED_SUBMIT:
            FrsSubmitCommand(Cmd, FALSE);
            break;

        //
        // Run the command packet's completion routine
        //
        case CMD_DELAYED_COMPLETE:
            FrsCompleteCommand(Cmd, ErrorStatus);
            break;

        //
        // Unknown command
        //
        default:
            DPRINT1(0, "ERROR - Wait: Unknown command 0x%x.\n", Cmd->TimeoutCommand);
            FRS_ASSERT(!"invalid comm timeout command stuck on list");
            FrsCompleteCommand(Cmd, ERROR_INVALID_FUNCTION);
            break;
    }
}


DWORD
WaitSubmit(
    IN PCOMMAND_PACKET  Cmd,
    IN DWORD            Timeout,
    IN USHORT           TimeoutCommand
    )
/*++
Routine Description:
    Insert the new command packet into the sorted, timeout list

    Restart the thread if needed.

    The Cmd may already be on the timeout list. If so, simply
    adjust its timeout.

Arguments:
    Cmd             - Command packet to timeout
    Timeout         - Timeout in milliseconds from now
    TimeoutCommand  - Disposition at timeout

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "WaitSubmit:"
    PLIST_ENTRY     Entry;
    LONGLONG        Now;
    PCOMMAND_PACKET OldCmd;
    DWORD           WStatus = ERROR_SUCCESS;

    //
    // Defensive
    //
    if (Cmd == NULL) {
        return ERROR_SUCCESS;
    }

    //
    // Setup the command packet with timeout and wait specific info
    //      We acquire the lock now just in case the command
    //      is already on the list.
    //
    EnterCriticalSection(&WaitLock);

    Cmd->Timeout = Timeout;
    Cmd->TimeoutCommand = TimeoutCommand;
    FrsNowAsFileTime(&Now);
    Cmd->WaitFileTime = Now + ((LONGLONG)Cmd->Timeout * 1000 * 10);

    DPRINT5(4, "Submit cmd %08x (%08x) for timeout (%08x) in %d ms (%08x)\n",
            Cmd->Command, Cmd,  Cmd->TimeoutCommand, Cmd->Timeout, Cmd->WaitFlags);

    //
    // Remove from list
    //
    if (CmdWaitFlagIs(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST)) {
        RemoveEntryListB(&Cmd->ListEntry);
        ClearCmdWaitFlag(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST);
    }

    //
    // Is the queue rundown?
    //
    if (WaitIsRunDown) {
        DPRINT2(4, "Can't insert cmd %08x (%08x); queue rundown\n",
                Cmd->Command, Cmd);
        WStatus = ERROR_ACCESS_DENIED;
        goto CLEANUP;
    }

    //
    // Insert into empty list
    //
    if (IsListEmpty(&WaitList)) {
        InsertHeadList(&WaitList, &Cmd->ListEntry);
        SetCmdWaitFlag(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST);
        goto CLEANUP;
    }

    //
    // Insert at tail
    //
    Entry = GetListTail(&WaitList);
    OldCmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
    if (OldCmd->WaitFileTime <= Cmd->WaitFileTime) {
        InsertTailList(&WaitList, &Cmd->ListEntry);
        SetCmdWaitFlag(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST);
        goto CLEANUP;
    }
    //
    // Insert into list
    //
    for (Entry = GetListHead(&WaitList);
         Entry != &WaitList;
         Entry = GetListNext(Entry)) {

        OldCmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        if (Cmd->WaitFileTime <= OldCmd->WaitFileTime) {
            InsertTailList(Entry, &Cmd->ListEntry);
            SetCmdWaitFlag(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST);
            goto CLEANUP;
        }
    }

CLEANUP:
    //
    // Reset the timer if the expiration time has changed
    //
    if (WIN_SUCCESS(WStatus)) {
        WaitReset(FALSE);
    }
    LeaveCriticalSection(&WaitLock);

    return WStatus;
}


VOID
WaitTimeout(
    VOID
    )
/*++
Routine Description:
    Expel the commands whose timeouts have passed.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "WaitTimeout:"
    PLIST_ENTRY     Entry;
    PCOMMAND_PACKET Cmd;
    LONGLONG        Now;

    //
    // Expel expired commands
    //
    FrsNowAsFileTime(&Now);
    EnterCriticalSection(&WaitLock);
    while (!IsListEmpty(&WaitList)) {
        Entry = GetListHead(&WaitList);
        Cmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);
        //
        // Hasn't timed out; stop
        //
        if ((Cmd->WaitFileTime - WAIT_FUZZY_TIMEOUT) > Now) {
            break;
        }

        //
        // Timed out; process it. Be careful to synchronize with
        // WaitUnsubmit.
        //
        RemoveEntryListB(Entry);
        ClearCmdWaitFlag(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST);
        EnterCriticalSection(&WaitUnsubmitLock);
        LeaveCriticalSection(&WaitLock);
        WaitProcessCommand(Cmd, ERROR_SUCCESS);
        LeaveCriticalSection(&WaitUnsubmitLock);
        EnterCriticalSection(&WaitLock);
    }
    //
    // Reset the timer (always)
    //
    WaitReset(TRUE);
    LeaveCriticalSection(&WaitLock);
}


VOID
WaitRunDownList(
    VOID
    )
/*++
Routine Description:
    Error off the commands in the timeout list

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "WaitRunDownList:"
    PLIST_ENTRY     Entry;
    PCOMMAND_PACKET Cmd;

    //
    // Rundown commands
    //
    EnterCriticalSection(&WaitLock);
    while (!IsListEmpty(&WaitList)) {
        Entry = GetListHead(&WaitList);
        Cmd = CONTAINING_RECORD(Entry, COMMAND_PACKET, ListEntry);

        RemoveEntryListB(Entry);
        ClearCmdWaitFlag(Cmd, CMD_PKT_WAIT_FLAGS_ONLIST);

        EnterCriticalSection(&WaitUnsubmitLock);
        LeaveCriticalSection(&WaitLock);

        WaitProcessCommand(Cmd, ERROR_ACCESS_DENIED);

        LeaveCriticalSection(&WaitUnsubmitLock);
        EnterCriticalSection(&WaitLock);
    }

    FrsNowAsFileTime(&WaitFileTime);
    DPRINT1(4, "Resetting rundown timer to %08x %08x.\n", PRINTQUAD(WaitFileTime));

    SetWaitableTimer(WaitableTimer, (LARGE_INTEGER *)&WaitFileTime, 0, NULL, NULL, TRUE);
    WaitIsRunDown = TRUE;
    LeaveCriticalSection(&WaitLock);
}


DWORD
MainWait(
    PFRS_THREAD FrsThread
    )
/*++
Routine Description:
    Entry point for a thread serving the wait queue.
    A timeout list is managed by a thread waiting on a
    waitable timer.

    The timer can be adjusted without context switching to the
    thread that is waiting on the timer.

    An entry can be pulled off the list. The timer is adjusted
    if the entry was at the head of the queue.

    The queue is sorted by timeout value. The timeout value is
    an absolute filetime.

    The list entry is a command packet. The generic command
    packet contains a field for the wait time in milliseconds.
    This code takes the wait time and converts it into an
    absolute filetime when the command packet is put on the
    queue. The timeout triggers when the time is equal to or
    greater than the command packet's filetime.

Arguments:
    Arg - thread

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "MainWait:"
    HANDLE      WaitArray[2];

    //
    // Thread is pointing at the correct queue
    //
    FRS_ASSERT(FrsThread->Data == &WaitList);

    DPRINT(0, "Wait thread has started.\n");

again:
    //
    // Wait for work, an exit timeout, or the queue to be rundown
    //
    DPRINT(4, "Wait thread is waiting.\n");
    WaitArray[0] = WaitRunDown;
    WaitArray[1] = WaitableTimer;

    WaitForMultipleObjectsEx(2, WaitArray, FALSE, INFINITE, TRUE);

    DPRINT(4, "Wait thread is running.\n");
    //
    // Nothing to do; exit
    //
    EnterCriticalSection(&WaitLock);
    if (IsListEmpty(&WaitList)) {
        WaitIsRunning = FALSE;
        LeaveCriticalSection(&WaitLock);

        DPRINT(0, "Wait thread is exiting.\n");
        ThSupSubmitThreadExitCleanup(FrsThread);
        ExitThread(ERROR_SUCCESS);
    }
    LeaveCriticalSection(&WaitLock);

    //
    // Check for timed out commands
    //
    WaitTimeout();

    //
    // Continue forever
    //
    goto again;
    return ERROR_SUCCESS;
}


VOID
WaitInitialize(
    VOID
    )
/*++
Routine Description:
    Initialize the wait subsystem. The thread is kicked off
    on demand.

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "WaitInitialize:"
    //
    // Timeout list
    //
    InitializeListHead(&WaitList);
    InitializeCriticalSection(&WaitLock);
    InitializeCriticalSection(&WaitUnsubmitLock);

    //
    // Rundown event for list
    //
    WaitRunDown = FrsCreateEvent(TRUE, FALSE);

    //
    // Timer
    //
    FrsNowAsFileTime(&WaitFileTime);
    WaitableTimer = FrsCreateWaitableTimer(TRUE);
    DPRINT1(4, "Setting initial timer to %08x %08x.\n", PRINTQUAD(WaitFileTime));

    if (!SetWaitableTimer(WaitableTimer, (LARGE_INTEGER *)&WaitFileTime, 0, NULL, NULL, TRUE)) {
        DPRINT_WS(0, "ERROR - Resetting timer;", GetLastError());
    }
}








VOID
ShutDownWait(
    VOID
    )
/*++
Routine Description:
    Shutdown the wait subsystem

Arguments:
    None.

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "ShutDownWait:"
    WaitRunDownList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apichdev.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    ApiChDev.c

Abstract:

    This module contains individual API handlers for the NetCharDev
    and NetCharDevQ APIs. Supported APIs are NetCharDevControl,
    NetCharDevEnum, NetCharDevGetInfo, NetCharDevQEnum, NetCharDevQGetInfo,
    NetCharDevQPurge, NetCharDevQPurgeSelf, and NetCharDevQSetInfo.

    SUPPORTED: NetCharDevControl, NetCharDevEnum, NetCharDevGetInfo,
               NetCharDevQEnum, NetCharDevQGetInfo, NetCharDevQPurge,
               NetCharDevQPurgeSelf, NetCharDevQSetInfo.

    !!! Remove handlers for unsupported APIs when done.

Author:

    Shanku Niyogi (w-shanku)    06-Mar-1991

Revision History:

--*/

#include "XactSrvP.h"

//
// Declaration of descriptor strings.
//

#if 0
STATIC const LPDESC Desc16_chardev_info_0 = REM16_chardev_info_0;
STATIC const LPDESC Desc32_chardev_info_0 = REM32_chardev_info_0;
STATIC const LPDESC Desc16_chardev_info_1 = REM16_chardev_info_1;
STATIC const LPDESC Desc32_chardev_info_1 = REM32_chardev_info_1;
STATIC const LPDESC Desc16_chardevQ_info_0 = REM16_chardevQ_info_0;
STATIC const LPDESC Desc32_chardevQ_info_0 = REM32_chardevQ_info_0;
STATIC const LPDESC Desc16_chardevQ_info_1 = REM16_chardevQ_info_1;
STATIC const LPDESC Desc32_chardevQ_info_1 = REM32_chardevQ_info_1;
STATIC const LPDESC Desc16_chardevQ_info_1_setinfo
                                           = REM16_chardevQ_info_1_setinfo;
STATIC const LPDESC Desc32_chardevQ_info_1_setinfo
                                           = REM32_chardevQ_info_1_setinfo;
#endif

#define RETURN_CHARDEV_NOT_SUPPORTED    \
        API_HANDLER_PARAMETERS_REFERENCE;       \
        Header->Status = ERROR_NOT_SUPPORTED;


NTSTATUS
XsNetCharDevControl (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetCharDevControl.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if 0
    NET_API_STATUS status;

    PXS_NET_CHAR_DEV_CONTROL parameters = Parameters;
    LPTSTR nativeDevName = NULL;            // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    //
    // Translate parameters, check for errors.
    //

    XsConvertTextParameter(
        nativeDevName,
        (LPSTR)SmbGetUlong( &parameters->DevName )
        );

    //
    // Make the local call.
    //

    status = NetCharDevControl(
                 NULL,
                 nativeDevName,
                 (DWORD)SmbGetUshort( &parameters->OpCode )
                 );

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetCharDevControl: "
                          "NetCharDevControl failed: %X\n", status ));
        }
    }

cleanup:

    NetpMemoryFree( nativeDevName );

    //
    // No return data.
    //

    Header->Status = (WORD)status;
#else
    RETURN_CHARDEV_NOT_SUPPORTED;
#endif

    return STATUS_SUCCESS;

} // XsNetCharDevControl


NTSTATUS
XsNetCharDevEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetCharDevEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{

    PXS_NET_CHAR_DEV_ENUM parameters = Parameters;
    DWORD entriesFilled = 0;
#if 0

    NET_API_STATUS status;

    LPVOID outBuffer = NULL;                // Native parameters
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD bytesRequired = 0;                // Conversion variables
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "XsNetCharDevEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    //
    // Check for errors.
    //

    if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

        Header->Status = (WORD)ERROR_INVALID_LEVEL;
        goto cleanup;
    }

    //
    // Make the local call.
    //

    status = NetCharDevEnum(
                 NULL,
                 (DWORD)SmbGetUshort( &parameters->Level ),
                 (LPBYTE *)&outBuffer,
                 XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                 &entriesRead,
                 &totalEntries,
                 NULL
                 );

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsNetCharDevEnum: NetCharDevEnum failed: %X\n",
                          status ));
        }
        Header->Status = (WORD)status;
        goto cleanup;
    }

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "XsNetCharDevEnum: received %ld entries at %lx\n",
                      entriesRead, outBuffer ));
    }

    //
    // Use the requested level to determine the format of the
    // data structure.
    //

    switch ( SmbGetUshort( &parameters->Level ) ) {

    case 0:

        nativeStructureDesc = Desc32_chardev_info_0;
        StructureDesc = Desc16_chardev_info_0;
        break;

    case 1:

        nativeStructureDesc = Desc32_chardev_info_1;
        StructureDesc = Desc16_chardev_info_1;
        break;

    }

    //
    // Do the actual conversion from the 32-bit structures to 16-bit
    // structures.
    //

    XsFillEnumBuffer(
        outBuffer,
        entriesRead,
        nativeStructureDesc,
        (LPVOID)SmbGetUlong( &parameters->Buffer ),
        (LPVOID)SmbGetUlong( &parameters->Buffer ),
        SmbGetUshort( &parameters->BufLen ),
        StructureDesc,
        NULL,  // verify function
        &bytesRequired,
        &entriesFilled,
        NULL
        );

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                      " Entries %ld of %ld\n",
                      outBuffer, SmbGetUlong( &parameters->Buffer ),
                      bytesRequired, entriesFilled, totalEntries ));
    }

    //
    // The 16-bit chardev_info structures do not contain any variable
    // data. Therefore, there is no need to pack any data - the converter
    // is already set to 0.
    //

    if ( entriesFilled < totalEntries ) {

        Header->Status = ERROR_MORE_DATA;

    }

    //
    // Set up the response parameters.
    //

    SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
    SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:

    NetApiBufferFree( outBuffer );

#else
    RETURN_CHARDEV_NOT_SUPPORTED;
#endif

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetCharDevEnum


NTSTATUS
XsNetCharDevGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetCharDevGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{

    PXS_NET_CHAR_DEV_GET_INFO parameters = Parameters;
#if 0
    NET_API_STATUS status;

    LPTSTR nativeDevName = NULL;            // Native parameters
    LPVOID outBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "XsNetCharDevGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    //
    // Translate parameters, check for errors.
    //

    if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

        Header->Status = (WORD)ERROR_INVALID_LEVEL;
        goto cleanup;
    }

    XsConvertTextParameter(
        nativeDevName,
        (LPSTR)SmbGetUlong( &parameters->DevName )
        );

    //
    //
    // Make the local call.
    //

    status = NetCharDevGetInfo(
                 NULL,
                 nativeDevName,
                 (DWORD)SmbGetUshort( &parameters->Level ),
                 (LPBYTE *)&outBuffer
                 );

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsNetCharDevGetInfo: NetCharDevGetInfo failed: "
                          "%X\n", status ));
        }
        Header->Status = (WORD)status;
        goto cleanup;

    }

    //
    // Use the requested level to determine the format of the
    // data structure.
    //

    switch ( SmbGetUshort( &parameters->Level ) ) {

    case 0:

        nativeStructureDesc = Desc32_chardev_info_0;
        StructureDesc = Desc16_chardev_info_0;
        break;

    case 1:

        nativeStructureDesc = Desc32_chardev_info_1;
        StructureDesc = Desc16_chardev_info_1;
        break;

    }

    //
    // Convert the structure returned by the 32-bit call to a 16-bit
    // structure. The last possible location for variable data is
    // calculated from buffer location and length.
    //

    stringLocation = (LPBYTE)( SmbGetUlong( &parameters->Buffer )
                                  + SmbGetUshort( &parameters->BufLen ) );

    status = RapConvertSingleEntry(
                 outBuffer,
                 nativeStructureDesc,
                 FALSE,
                 (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                 (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                 StructureDesc,
                 TRUE,
                 &stringLocation,
                 &bytesRequired,
                 Response,
                 NativeToRap
                 );


    if ( status != NERR_Success ) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetCharDevGetInfo: RapConvertSingleEntry failed: "
                      "%X\n", status ));
        }

        Header->Status = NERR_InternalError;
        goto cleanup;
    }

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                      outBuffer, SmbGetUlong( &parameters->Buffer ),
                      bytesRequired ));
    }

    //
    // Determine return code based on the size of the buffer. The 16-bit
    // chardev_info structures do not have any variable data to pack.
    //

    if ( !XsCheckBufferSize(
             SmbGetUshort( &parameters->BufLen ),
             StructureDesc,
             FALSE  // not in native format
             )) {

        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetCharDevGetInfo: Buffer too small.\n" ));
        }
        Header->Status = NERR_BufTooSmall;

    } else if ( bytesRequired > SmbGetUshort( &parameters-> BufLen )) {

        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "NetCharDevGetInfo: More data available.\n" ));
        }
        Header->Status = ERROR_MORE_DATA;

    }

    //
    // Set up the response parameters.
    //

    SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );
cleanup:

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeDevName );

#else
    RETURN_CHARDEV_NOT_SUPPORTED;
#endif

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetCharDevGetInfo


NTSTATUS
XsNetCharDevQEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetCharDevQEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    PXS_NET_CHAR_DEV_Q_ENUM parameters = Parameters;
    DWORD entriesFilled = 0;

#if 0
    NET_API_STATUS status;

    LPTSTR nativeUserName = NULL;           // Native parameters
    LPVOID outBuffer = NULL;
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "XsNetCharDevQEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    //
    // Translate parameters, check for errors.
    //

    if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

        Header->Status = (WORD)ERROR_INVALID_LEVEL;
        goto cleanup;
    }

    XsConvertTextParameter(
        nativeUserName,
        (LPSTR)SmbGetUlong( &parameters->UserName )
        );

    //
    // Make the local call.
    //

    status = NetCharDevQEnum(
                 NULL,
                 nativeUserName,
                 (DWORD)SmbGetUshort( &parameters->Level ),
                 (LPBYTE *)&outBuffer,
                 XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                 &entriesRead,
                 &totalEntries,
                 NULL
                 );

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsNetCharDevQEnum: NetCharDevQEnum failed: %X\n",
                          status ));
        }
        Header->Status = (WORD)status;
        goto cleanup;
    }

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "XsNetCharDevQEnum: received %ld entries at %lx\n",
                      entriesRead, outBuffer ));
    }

    //
    // Use the requested level to determine the format of the
    // data structure.
    //

    switch ( SmbGetUshort( &parameters->Level ) ) {

    case 0:

        nativeStructureDesc = Desc32_chardevQ_info_0;
        StructureDesc = Desc16_chardevQ_info_0;
        break;

    case 1:

        nativeStructureDesc = Desc32_chardevQ_info_1;
        StructureDesc = Desc16_chardevQ_info_1;
        break;

    }

    //
    // Do the actual conversion from the 32-bit structures to 16-bit
    // structures.
    //

    XsFillEnumBuffer(
        outBuffer,
        entriesRead,
        nativeStructureDesc,
        (LPVOID)SmbGetUlong( &parameters->Buffer ),
        (LPVOID)SmbGetUlong( &parameters->Buffer ),
        SmbGetUshort( &parameters->BufLen ),
        StructureDesc,
        NULL,  // verify function
        &bytesRequired,
        &entriesFilled,
        NULL
        );

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                      " Entries %ld of %ld\n",
                      outBuffer, SmbGetUlong( &parameters->Buffer ),
                      bytesRequired, entriesFilled, totalEntries ));
    }

    //
    // If all the data was returned, try to pack the data so that we
    // don't send empty bytes back.
    //

    if ( entriesFilled < totalEntries ) {

        Header->Status = ERROR_MORE_DATA;

    } else {

        Header->Converter = XsPackReturnData(
                                (LPVOID)SmbGetUlong( &parameters->Buffer ),
                                SmbGetUshort( &parameters->BufLen ),
                                StructureDesc,
                                entriesFilled
                                );
    }

    //
    // Set up the response parameters.
    //

    SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
    SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeUserName );
#else
    RETURN_CHARDEV_NOT_SUPPORTED;
#endif

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetCharDevQEnum


NTSTATUS
XsNetCharDevQGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetCharDevQGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    PXS_NET_CHAR_DEV_Q_GET_INFO parameters = Parameters;
#if 0
    NET_API_STATUS status;

    LPTSTR nativeQueueName = NULL;          // Native parameters
    LPTSTR nativeUserName = NULL;
    LPVOID outBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    //
    // Translate parameters, check for errors.
    //

    if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

        Header->Status = (WORD)ERROR_INVALID_LEVEL;
        goto cleanup;
    }

    XsConvertTextParameter(
        nativeQueueName,
        (LPSTR)SmbGetUlong( &parameters->QueueName )
        );

    XsConvertTextParameter(
        nativeUserName,
        (LPSTR)SmbGetUlong( &parameters->UserName )
        );

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "XsNetCharDevQGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    //
    // Make the local call.
    //

    status = NetCharDevQGetInfo(
                 NULL,
                 nativeQueueName,
                 nativeUserName,
                 (DWORD)SmbGetUshort( &parameters->Level ),
                 (LPBYTE *)&outBuffer
                 );

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsNetCharDevQGetInfo: NetCharDevQGetInfo failed: "
                          "%X\n", status ));
        }
        Header->Status = (WORD)status;
        goto cleanup;

    }

    //
    // Use the requested level to determine the format of the
    // data structure.
    //

    switch ( SmbGetUshort( &parameters->Level ) ) {

    case 0:

        nativeStructureDesc = Desc32_chardevQ_info_0;
        StructureDesc = Desc16_chardevQ_info_0;
        break;

    case 1:

        nativeStructureDesc = Desc32_chardevQ_info_1;
        StructureDesc = Desc16_chardevQ_info_1;
        break;

    }

    //
    // Convert the structure returned by the 32-bit call to a 16-bit
    // structure. The last possible location for variable data is
    // calculated from buffer location and length.
    //

    stringLocation = (LPBYTE)( SmbGetUlong( &parameters->Buffer )
                                  + SmbGetUshort( &parameters->BufLen ) );

    status = RapConvertSingleEntry(
                 outBuffer,
                 nativeStructureDesc,
                 FALSE,
                 (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                 (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                 StructureDesc,
                 TRUE,
                 &stringLocation,
                 &bytesRequired,
                 Response,
                 NativeToRap
                 );

    if ( status != NERR_Success ) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsCharDevQGetInfo: RapConvertSingleEntry failed: "
                          "%X\n", status ));
        }

        Header->Status = NERR_InternalError;
        goto cleanup;
    }

    IF_DEBUG(CHAR_DEV) {
        NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                      outBuffer, SmbGetUlong( &parameters->Buffer ),
                      bytesRequired ));
    }

    //
    // Determine return code based on the size of the buffer. If all data
    // has fit, try to pack it.
    //

    if ( !XsCheckBufferSize(
             SmbGetUshort( &parameters->BufLen ),
             StructureDesc,
             FALSE   // not in native format
             )) {

        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetCharDevQGetInfo: Buffer too small.\n" ));
        }
        Header->Status = NERR_BufTooSmall;

    } else if ( bytesRequired > SmbGetUshort( &parameters-> BufLen )) {

        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "NetCharDevQGetInfo: More data available.\n" ));
        }
        Header->Status = ERROR_MORE_DATA;

    } else {

        Header->Converter = XsPackReturnData(
                                (LPVOID)SmbGetUlong( &parameters->Buffer ),
                                SmbGetUshort( &parameters->BufLen ),
                                StructureDesc,
                                1
                                );

    }

    //
    // Set up the response parameters.
    //

    SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeQueueName );
    NetpMemoryFree( nativeUserName );

#else
    RETURN_CHARDEV_NOT_SUPPORTED;
#endif
    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetCharDevQGetInfo


NTSTATUS
XsNetCharDevQPurge (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetCharDevQPurge.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if 0
    NET_API_STATUS status;

    PXS_NET_CHAR_DEV_Q_PURGE parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    //
    // Translate parameters, check for errors.
    //

    XsConvertTextParameter(
        nativeQueueName,
        (LPSTR)SmbGetUlong( &parameters->QueueName )
        );

    //
    // Make the local call.
    //

    status = NetCharDevQPurge(
                 NULL,
                 nativeQueueName
                 );

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetCharDevQPurge: "
                          "NetCharDevQPurge failed: %X\n", status ));
        }
    }

cleanup:

    NetpMemoryFree( nativeQueueName );

    //
    // No return data.
    //

    Header->Status = (WORD)status;

#else
    RETURN_CHARDEV_NOT_SUPPORTED;
#endif
    return STATUS_SUCCESS;

} // XsNetCharDevQPurge


NTSTATUS
XsNetCharDevQPurgeSelf (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetCharDevQPurgeSelf.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if 0
    NET_API_STATUS status;

    PXS_NET_CHAR_DEV_Q_PURGE_SELF parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters
    LPTSTR nativeComputerName = NULL;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    //
    // Translate parameters, check for errors.
    //

    XsConvertTextParameter(
        nativeQueueName,
        (LPSTR)SmbGetUlong( &parameters->QueueName )
        );

    XsConvertTextParameter(
        nativeComputerName,
        (LPSTR)SmbGetUlong( &parameters->ComputerName )
        );

    //
    // Make the local call.
    //

    status = NetCharDevQPurgeSelf(
                 NULL,
                 nativeQueueName,
                 nativeComputerName
                 );

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetCharDevQPurgeSelf: "
                          "NetCharDevQPurgeSelf failed: %X\n", status ));
        }
    }

cleanup:

    NetpMemoryFree( nativeQueueName );
    NetpMemoryFree( nativeComputerName );

    //
    // No return data.
    //

    Header->Status = (WORD)status;
#else
    RETURN_CHARDEV_NOT_SUPPORTED;
#endif

    return STATUS_SUCCESS;

} // XsNetCharDevQPurgeSelf


NTSTATUS
XsNetCharDevQSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetCharDevQSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
#if 0
    NET_API_STATUS status;

    PXS_NET_CHAR_DEV_Q_SET_INFO parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters
    LPVOID buffer = NULL;
    DWORD level;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    //
    // Translate parameters, check for errors.
    //

    if ( SmbGetUshort( &parameters->Level ) != 1 ) {

        Header->Status = (WORD)ERROR_INVALID_LEVEL;
        goto cleanup;
    }

    XsConvertTextParameter(
        nativeQueueName,
        (LPSTR)SmbGetUlong( &parameters->QueueName )
        );

    StructureDesc = Desc16_chardevQ_info_1;

    status = XsConvertSetInfoBuffer(
                 (LPBYTE)SmbGetUlong( &parameters->Buffer ),
                 SmbGetUshort( &parameters->BufLen ),
                 SmbGetUshort( &parameters->ParmNum ),
                 FALSE,
                 TRUE,
                 StructureDesc,
                 Desc32_chardevQ_info_1,
                 Desc16_chardevQ_info_1_setinfo,
                 Desc32_chardevQ_info_1_setinfo,
                 (LPBYTE *)&buffer,
                 NULL
                 );

    if ( status != NERR_Success ) {

        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetCharDevQSetInfo: Problem with conversion: "
                          "%X\n", status ));
        }
        Header->Status = (WORD)status;
        goto cleanup;

    }

    //
    // Make the local call.
    //

    level = SmbGetUshort( &parameters->ParmNum );
    if ( level != 0 ) {
        level = level + PARMNUM_BASE_INFOLEVEL;
    } else {
        level = SmbGetUshort( &parameters->Level );
    }

    status = NetCharDevQSetInfo(
                 NULL,
                 nativeQueueName,
                 level,
                 buffer,
                 NULL
                 );

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetCharDevQSetInfo: NetCharDevQSetInfo failed: "
                          "%X\n", status ));
        }
        Header->Status = (WORD)status;
        goto cleanup;
    }

    //
    // No return information for this API.
    //

cleanup:

    //
    // If there is a native 32-bit buffer, free it.
    //

    NetpMemoryFree( buffer );
    NetpMemoryFree( nativeQueueName );

#else
    RETURN_CHARDEV_NOT_SUPPORTED;
#endif
    return STATUS_SUCCESS;

} // XsNetCharDevQSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apifile.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiFile.c

Abstract:

    This module contains individual API handlers for the NetFile APIs.

    SUPPORTED - NetFileClose2, NetFileEnum2, NetFileGetInfo2.

Author:

    Shanku Niyogi (w-shanku) 20-Feb-1991

Revision History:

--*/

#include "XactSrvP.h"

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_file_info_2 = REM16_file_info_2;
STATIC const LPDESC Desc32_file_info_2 = REM32_file_info_2;
STATIC const LPDESC Desc16_file_info_3 = REM16_file_info_3;
STATIC const LPDESC Desc32_file_info_3 = REM32_file_info_3;


NTSTATUS
XsNetFileClose2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetFileClose.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_FILE_CLOSE_2 parameters = Parameters;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Make the local call.
        //

        status = NetFileClose(
                     NULL,
                     SmbGetUlong( &parameters->FileId )
                     );

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( !XsApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetFileClose2: NetFileClose failed: %X\n",
                          status ));
        }
    }

    //
    // No return data.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetFileClose2


NTSTATUS
XsNetFileEnum2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetFileEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_FILE_ENUM_2 parameters = Parameters;
    LPTSTR nativeBasePath = NULL;           // Native parameters
    LPTSTR nativeUserName = NULL;
    LPVOID outBuffer = NULL;
    DWORD entriesRead;
    DWORD totalEntries;
    DWORD_PTR resumeKey = 0;

    DWORD entriesFilled = 0;                    // Conversion variables
    DWORD totalEntriesRead = 0;
    DWORD bytesRequired = 0;
    DWORD nativeBufferSize;
    LPDESC nativeStructureDesc;
    LPBYTE bufferBegin;
    DWORD bufferSize;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(FILE) {
        NetpKdPrint(( "XsNetFileEnum2: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeBasePath,
            (LPSTR)XsSmbGetPointer( &parameters->BasePath )
            );

        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        //
        // Copy input resume handle to output resume handle, and get a copy of it.
        //

        if ( SmbGetUlong( &parameters->ResumeKeyIn ) == 0 ) {

            Header->Status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

        RtlCopyMemory( parameters->ResumeKeyOut,
            (LPBYTE)XsSmbGetPointer( &parameters->ResumeKeyIn ), 8 );
        resumeKey = (DWORD)SmbGetUlong( &parameters->ResumeKeyOut[2] );

        IF_DEBUG(FILE) {
            NetpKdPrint(( "XsNetFileEnum2: resume key is %ld\n", resumeKey ));
        }

        //
        // Use the level to determine the descriptor string.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 2:

            StructureDesc = Desc16_file_info_2;
            nativeStructureDesc = Desc32_file_info_2;
            break;

        case 3:

            StructureDesc = Desc16_file_info_3;
            nativeStructureDesc = Desc32_file_info_3;
            break;

        default:

            //
            // Unsupported levels, abort before any work.
            //

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // NetFileEnum2 is a resumable API, so we cannot get more information
        // from the native call than we can send back. The most efficient way
        // to do this is in a loop...we use the 16-bit buffer size to determine
        // a safe native buffer size, make the call, fill the entries, then
        // take the amount of space remaining and determine a safe size again,
        // and so on, until NetFileEnum returns either no entries or all entries
        // read.
        //

        //
        // Initialize important variables for loop.
        //

        bufferBegin = (LPBYTE)XsSmbGetPointer( &parameters->Buffer );
        bufferSize = (DWORD)SmbGetUshort( &parameters->BufLen );
        totalEntriesRead = 0;

        for ( ; ; ) {

            //
            //  Compute a safe size for the native buffer.
            //

            switch ( SmbGetUshort( &parameters->Level ) ) {

            case 2:

                nativeBufferSize = bufferSize;
                break;

            case 3:

                nativeBufferSize = bufferSize;
                break;

            }

            //
            // Make the local call.
            //

            status = NetFileEnum(
                         NULL,
                         nativeBasePath,
                         nativeUserName,
                         (DWORD)SmbGetUshort( &parameters->Level ),
                         (LPBYTE *)&outBuffer,
                         nativeBufferSize,
                         &entriesRead,
                         &totalEntries,
                         &resumeKey
                         );

            if ( !XsApiSuccess( status )) {

                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetFileEnum2: NetFileEnum failed: %X\n",
                                  status ));
                }

                Header->Status = (WORD)status;
                goto cleanup;
            }

            IF_DEBUG(FILE) {
                NetpKdPrint(( "XsNetFileEnum2: received %ld entries at %lx\n",
                              entriesRead, outBuffer ));

                NetpKdPrint(( "XsNetFileEnum2: resume key is now %Id\n",
                              resumeKey ));
            }

            //
            // Was NetFileEnum able to read at least one complete entry?
            //

            if ( entriesRead == 0 ) {
                break;
            }

            //
            // Do the actual conversion from the 32-bit structures to 16-bit
            // structures.
            //

            XsFillEnumBuffer(
                outBuffer,
                entriesRead,
                nativeStructureDesc,
                bufferBegin,
                (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                bufferSize,
                StructureDesc,
                NULL,  // verify function
                &bytesRequired,
                &entriesFilled,
                NULL
                );

            IF_DEBUG(FILE) {
                NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                              " Entries %ld of %ld\n",
                              outBuffer, SmbGetUlong( &parameters->Buffer ),
                              bytesRequired, entriesFilled, totalEntries ));
            }

            //
            // Very key assertion!
            //

            NetpAssert( entriesRead == entriesFilled );

            //
            // Update count of entries read.
            //

            totalEntriesRead += entriesRead;

            //
            // Are there any more entries to read?
            //

            if ( entriesRead == totalEntries ) {
                break;
            }

            //
            // Calculate new buffer beginning and size.
            //

            bufferBegin += entriesRead *
                               RapStructureSize( StructureDesc, Response, FALSE );
            bufferSize -= bytesRequired;

            //
            // Free last native buffer.
            //

            NetApiBufferFree( outBuffer );
            outBuffer = NULL;

        }

        //
        // Upon exit from the loop, totalEntriesRead has the number of entries
        // read, entriesRead has the number read in the last call, totalEntries
        // has the number remaining plus entriesRead. Formulate return codes,
        // etc. from these values.
        //

        if ( totalEntries > entriesRead ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    totalEntriesRead
                                    );

        }

        IF_DEBUG(FILE) {
            NetpKdPrint(( "XsNetFileEnum2: resume key is now %ld\n", resumeKey ));
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)totalEntriesRead );
        SmbPutUshort( &parameters->EntriesRemaining,
            (WORD)( totalEntries - entriesRead ));

        //
        // Over the wire, resumeKey is a true 32-bit index, so this cast works.
        //

        SmbPutUlong( (LPDWORD)&parameters->ResumeKeyOut[2], (DWORD)resumeKey );

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeBasePath );
    NetpMemoryFree( nativeUserName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        totalEntriesRead,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetFileEnum2


NTSTATUS
XsNetFileGetInfo2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetFileGetInfo2.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_FILE_GET_INFO_2 parameters = Parameters;
    LPVOID outBuffer = NULL;                // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(FILE) {
        NetpKdPrint(( "XsNetFileGetInfo2: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Check errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 2, 3 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetFileGetInfo(
                     NULL,
                     SmbGetUlong( &parameters->FileId ),
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetFileGetInfo2: NetFileGetInfo failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 2:

            StructureDesc = Desc16_file_info_2;
            nativeStructureDesc = Desc32_file_info_2;
            break;

        case 3:

            StructureDesc = Desc16_file_info_3;
            nativeStructureDesc = Desc32_file_info_3;
            break;
        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsFileGetInfo2: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(FILE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetFileGetInfo2: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else {

            if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "NetFileGetInfo2: More data available.\n" ));
                }
                Header->Status = ERROR_MORE_DATA;

            } else {

                //
                // Pack the response data.
                //

                Header->Converter = XsPackReturnData(
                                        (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                        SmbGetUshort( &parameters->BufLen ),
                                        StructureDesc,
                                        1
                                        );
            }

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetFileGetInfo2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcimgs\ntrepl\util\vvector.c ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:
    vvector.c

Abstract:
    The version vector is a dampening mechanism that prevents replicating
    the same change to the same machine more than once.

    The version keeps track of the last change that has been received
    by a machine or the last change that was sent to a machine.

    A new change order is checked against the version vector before
    it is given to the change order accept thread. If dampened, the
    sender receives an ACK. Along with the ACK is the current
    version for the specified originator. This allows the sender
    to update its outbound cxtion version vector and dampen
    change orders before they are sent.

Author:
    Billy J. Fuller 18-Apr-1997

    David A. Orbits 15-Oct-97 :
        Revise to retire CO's in order so all COs coming from the same
        originator propagate in order.  Integrate with ChgOrdIssueCleanup()
        and restructure locking.

Environment
    User mode winnt

--*/


#include <ntreppch.h>
#pragma  hdrstop

#undef DEBSUB
#define DEBSUB  "VVECTOR:"

#include <frs.h>
#include <tablefcn.h>

ULONG
ChgOrdIssueCleanup(
    PTHREAD_CTX           ThreadCtx,
    PREPLICA              Replica,
    PCHANGE_ORDER_ENTRY   ChangeOrder,
    ULONG                 CleanUpFlags
    );



ULONG
VVReserveRetireSlot(
    IN PREPLICA             Replica,
    IN PCHANGE_ORDER_ENTRY  Coe
    )
/*++
Routine Description:
    A replica can have many outstanding change orders from any given
    originator. The change orders can complete out of sequence but
    we don't want to update the version vector with a later version
    if a earlier version is still in progress. The pending versions
    are kept on the duplicate list.

    A pending version transitions to "retired" when its change
    order is retired. After the database is updated, the version
    is committed.

    The incore version vector is then updated with the youngest
    version (largest VSN) in the list that has been committed.

    Change orders always issue in order by orginator VSN (except for retries)
    so the version vector update and propagation to the outbound log also
    occur in order.


    PERF - We should be using the existing table lock.

Arguments:

    Replica -- ptr to the replica struct for the version vector.

    Coe -- ptr to the change order entry.

Return Value:
    FrsError status.

--*/
{
#undef DEBSUB
#define DEBSUB  "VVReserveRetireSlot:"
    PVV_RETIRE_SLOT         RetireSlot;
    PVV_ENTRY               MasterVVEntry;
    PGEN_TABLE              VV = Replica->VVector;
    PCHANGE_ORDER_COMMAND   Coc = &Coe->Cmd;

    //
    // If this CO has already done the VV update or had it executed then done.
    //
    if (CO_IFLAG_ON(Coe, CO_IFLAG_VVRETIRE_EXEC) ||
        CO_FLAG_ON(Coe, CO_FLAG_VV_ACTIVATED)) {
            return FrsErrorSuccess;
    }

    //
    // A call to reserve must be matched with a call to retire before
    // another call to reserve can be made for the same change order.
    // The only exception is that once a slot is activated it can stay on the
    // list after the CO has retired or has been marked for retry.  In this case
    // a duplicate remote CO could arrive and be issued.
    //
    LOCK_GEN_TABLE(VV);

    MasterVVEntry = GTabLookupNoLock(VV, &Coc->OriginatorGuid, NULL);

    if (MasterVVEntry) {

        if (MasterVVEntry->GVsn.Vsn >= Coc->FrsVsn) {
            SET_CO_FLAG(Coe, CO_FLAG_OUT_OF_ORDER);
            UNLOCK_GEN_TABLE(VV);
            return FrsErrorSuccess;
        }

        ForEachListEntryLock( MasterVVEntry, VV_RETIRE_SLOT, Link,
            // The iterator pE is of type PVV_RETIRE_SLOT.

            if (pE->Vsn > Coc->FrsVsn) {
                SET_CO_FLAG(Coe, CO_FLAG_OUT_OF_ORDER);
                UNLOCK_GEN_TABLE(VV);
                return FrsErrorSuccess;
            }

            if (pE->Vsn == Coc->FrsVsn) {
                //
                // It must be activated.
                //
                FRS_ASSERT(pE->ChangeOrder != NULL);
                UNLOCK_GEN_TABLE(VV);
                return FrsErrorKeyDuplicate;
            }
        );
    }

    //
    // This change order does not have a reserved slot
    //
    if (CO_FLAG_ON(Coe, CO_FLAG_OUT_OF_ORDER)) {
        CHANGE_ORDER_TRACE(3, Coe, "VVResrv Retire OofO. Ignore");
        UNLOCK_GEN_TABLE(VV);
        return FrsErrorSuccess;
    }

    //
    // If new originator; create a new version vector entry.
    //
    if (!MasterVVEntry) {
        //
        // New version vector entry.  We don't have to hold locks because the
        // only time a new version vector entry is created is when change
        // order accept is processing a change order.
        //
        MasterVVEntry = FrsAlloc(sizeof(VV_ENTRY));
        InitializeListHead(&MasterVVEntry->ListHead);
        COPY_GUID(&MasterVVEntry->GVsn.Guid, &Coc->OriginatorGuid);
        MasterVVEntry->GVsn.Vsn = QUADZERO;

        //
        // Add it to the version vector table.
        //
        GTabInsertEntryNoLock(VV, MasterVVEntry, &MasterVVEntry->GVsn.Guid, NULL);
    }

    CHANGE_ORDER_TRACE(3, Coe, "VVReserve Slot");

    //
    // Allocate a version vector retire slot.
    //
    RetireSlot = FrsAlloc(sizeof(VV_RETIRE_SLOT));
    RetireSlot->Vsn = Coc->FrsVsn;

    //
    // The retire slot is linked to the list tail to maintain Issue order.
    //
    InsertTailList(&MasterVVEntry->ListHead, &RetireSlot->Link);

    VV_PRINT(4, L"End of Reserve Retire Slot", VV);
    UNLOCK_GEN_TABLE(VV);

    return FrsErrorSuccess;
}


ULONG
VVRetireChangeOrder(
    IN PTHREAD_CTX          ThreadCtx,
    IN PREPLICA             Replica,
    IN PCHANGE_ORDER_ENTRY  ChangeOrder,
    IN ULONG                CleanUpFlags
    )
/*++
Routine Description:

    Activate or discard the retire slot reserved for this change order.
    The ChangeOrder pointer and the CleanUpFlags are saved in the slot entry.
    If the retire slot is now at the head of the list the version vector
    can be updated, the change order propagated to the outbound log and the
    slot entry is freed.  The update process continues with the new head
    entry if that slot is activated.

    The incore version vector is updated after the database is updated.
    Both are updated with the VSN of the most recent entry that is processed.

    * NOTE * -- A remote CO that is discarded still needs to Ack the inbound
    partner.  The caller must handle this since a discard request
    to an entry that is not activated just causes the entry to be removed
    from the list and freed.  The version vector should NOT be updated by
    the caller in this case since the update may be out of order.  If it
    is necessary to update the VV then you must activate the retire slot
    (not setting the ISCU_INS_OUTLOG cleanup flag).  The caller can still
    trigger the inbound partner ACK out of order since that does not affect
    the version vector.  Or you can pass in the ISCU_ACK_INBOUND cleanup flag
    when you activate the entry.

Arguments:

    ThreadCtx -- Ptr to the DB thread context to use for calls to Issue cleanup.
    Replica -- Replica set context.
    ChangeOrder -- Change order to activate or discard.
    CleanUpFlags -- Cleanup flags saved in the slot entry for use when
                    VV is updated and CO is propagated.

Return Value:

    FRS STATUS
    FrsErrorVVSlotNotFound -- Returned when no VVSlot is found for an out of order
                              change order.  This means that no Issue Cleanup
                              actions will be initiated here on behalf of the=is
                              CO.  So the caller better take care of it.

--*/
{
#undef DEBSUB
#define DEBSUB  "VVRetireChangeOrder:"
#define FlagChk(_flag_) BooleanFlagOn(CleanUpFlags, _flag_)

    ULONG                   FStatus;
    PVV_RETIRE_SLOT         RetireSlot;
    PVV_ENTRY               MasterVVEntry;
    PCHANGE_ORDER_COMMAND   Coc = &ChangeOrder->Cmd;
    PGEN_TABLE              VV = Replica->VVector;
    BOOL                    First;
    ULONG                   Flags;
    ULONGLONG               UpdateVsn;
    PLIST_ENTRY             Entry;
    PLIST_ENTRY             pNext;
    GUID                    OriginatorGuid;

    //
    // Find the originator's entry in the version vector
    //
    LOCK_GEN_TABLE(VV);
    VV_PRINT(5, L"Start of Retire Change Order", VV);

    //
    // Nathing to do if CO says we are VV Retired.
    //
    if (CO_IFLAG_ON(ChangeOrder, CO_IFLAG_VVRETIRE_EXEC)) {
        UNLOCK_GEN_TABLE(VV);
        CHANGE_ORDER_TRACE(3, ChangeOrder, "VVRetire Err SAR");
        return FrsErrorSuccess;
    }

    //
    // Make a copy of the Guid.  May need it after CO is deleted.
    //
    OriginatorGuid = Coc->OriginatorGuid;
    MasterVVEntry = GTabLookupNoLock(VV, &OriginatorGuid, NULL);

    if (MasterVVEntry == NULL) {
        //
        // This change order is not participating in the version vector protocol;
        // most likely because it is an out of order retry.  Done.
        // It may be that a VV slot was never reserved so it's also ok if
        // ISCU_ACTIVATE_VV_DISCARD is set.
        //
        if (CO_FLAG_ON(ChangeOrder, CO_FLAG_OUT_OF_ORDER) ||
            FlagChk(ISCU_ACTIVATE_VV_DISCARD)) {

            UNLOCK_GEN_TABLE(VV);
            CHANGE_ORDER_TRACE(3, ChangeOrder, "VVRetire OK (OofO)");
            return FrsErrorVVSlotNotFound;
        }
    }
    FRS_ASSERT(MasterVVEntry);

    //
    // Find the retire slot for this change order.
    //
    RetireSlot = NULL;
    First = TRUE;
    ForEachListEntryLock( MasterVVEntry, VV_RETIRE_SLOT, Link,
        // The iterator pE is of type PVV_RETIRE_SLOT.
        if (pE->Vsn == Coc->FrsVsn) {
            RetireSlot = pE;
            break;
        }
        First = FALSE;
    );

    if (RetireSlot == NULL) {
        //
        // This change order is not participating in the version vector protocol;
        // most likely because it is an out of order retry.  Done.
        // It may be that a VV slot was never reserved so it's also ok if
        // ISCU_ACTIVATE_VV_DISCARD is set.
        //
        if (CO_FLAG_ON(ChangeOrder, CO_FLAG_OUT_OF_ORDER) ||
            FlagChk(ISCU_ACTIVATE_VV_DISCARD)) {

            UNLOCK_GEN_TABLE(VV);
            CHANGE_ORDER_TRACE(3, ChangeOrder, "VVRetire OK (OofO2)");
            return FrsErrorVVSlotNotFound;
        }
    }

    FRS_ASSERT(RetireSlot != NULL);

    // if the CO is aborted and the CO is not activated then free the slot.
    // if the CO is aborted and the CO is activated AND the VSN would have
    // moved the master VSN backwards then suppress the update.
    //

    //
    // Activate or discard the affected slot
    //
    if (!FlagChk(ISCU_ACTIVATE_VV_DISCARD)) {

        //
        // The change order has passsed the point of initial retire.
        // Activate the slot by saving the pointer and bumping the ref count.
        //
        // Note: The change order can still be aborted or retried (e.g. Install
        //       fails).
        //
        FRS_ASSERT(RetireSlot->ChangeOrder == NULL);
        INCREMENT_CHANGE_ORDER_REF_COUNT(ChangeOrder);
        RetireSlot->ChangeOrder = ChangeOrder;
        RetireSlot->CleanUpFlags = CleanUpFlags;
        CHANGE_ORDER_TRACE(3, ChangeOrder, "VV Slot Activated");

    } else {

        //
        // Discard this change order retire slot.
        // Do it now if the CO is local, else do it when it gets to the list
        // head.  If remote we still have to update the VV in order
        // in the event that this CO is blocked behind other COs.
        //
        if (CO_FLAG_ON(ChangeOrder, CO_FLAG_LOCALCO)) {
            FrsRemoveEntryList(&RetireSlot->Link);
            UNLOCK_GEN_TABLE(VV);

            //
            // If the slot was activated -
            // Drop our reference, do not propagate the CO to the outbound log
            // and clear ISCU_ACTIVATE_VV so we don't come back here recursively.
            // The dropped ref could free the CO so don't try to deref it.
            //
            if (RetireSlot->ChangeOrder != NULL) {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "VV ActSlot Discard");
                Flags = RetireSlot->CleanUpFlags |
                        CleanUpFlags             |
                        ISCU_FREEMEM_CLEANUP;

                ClearFlag(Flags, (ISCU_ACTIVATE_VV |
                                  ISCU_INS_OUTLOG |
                                  ISCU_INS_OUTLOG_NEW_GUID));

                FStatus = ChgOrdIssueCleanup(ThreadCtx, Replica, ChangeOrder, Flags);
                DPRINT_FS(0,"ERROR - ChgOrdIssueCleanup failed on local CO discard.", FStatus);
                FRS_ASSERT(FRS_SUCCESS(FStatus) || !"ChgOrdIssueCleanup failed on local CO");
            } else {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "VV InActSlot Discard");
            }

            FrsFree(RetireSlot);
            //
            // If this change order was not next in line to propagate then
            // we are done for now.  Otherwise get the lock back and do lookup
            // on VV entry again, in case it went away when the lock was dropped.
            //
            if (!First) {
                return FrsErrorSuccess;
            }
            LOCK_GEN_TABLE(VV);
            MasterVVEntry = GTabLookupNoLock(VV, &OriginatorGuid, NULL);
            FRS_ASSERT(MasterVVEntry);

        } else {

            //
            // The discarded CO is remote.  If activated, don't free the slot
            // until it gets to the head of the list.  Add any caller flags and
            // clear the ISCU_INS_OUTLOG flag so code below will just update
            // the VV and not propagate the CO to the outbound log.
            //
            if (RetireSlot->ChangeOrder != NULL) {
                CHANGE_ORDER_TRACE(3, ChangeOrder, "VV ActSlot Discard");
                RetireSlot->CleanUpFlags |= CleanUpFlags;
                ClearFlag(RetireSlot->CleanUpFlags, (ISCU_INS_OUTLOG |
                                                     ISCU_INS_OUTLOG_NEW_GUID));
            } else {
                FrsRemoveEntryList(&RetireSlot->Link);
                FrsFree(RetireSlot);
                CHANGE_ORDER_TRACE(3, ChangeOrder, "VV InActSlot Discard");
            }
        }
    }

    //
    // If this change order is not or was not next in line to propagate then
    // it waits for the prior change orders to finish before updating
    // the version vector with this VSN.
    //
    if (!First) {
        UNLOCK_GEN_TABLE(VV);
        return FrsErrorSuccess;
    }


    //
    // If we are already doing retires on this originator then the thread doing
    // it will pick up our entry next.  Otherwise we do it.
    // This Flag is used by the VV code to serialize database updates with
    // respect to a given originator. It avoids holding the GEN_TABLE lock
    // across database disk operations but keeps another thread from racing
    // with us to do a VV update on the same originator record.
    //
    if (BooleanFlagOn(MasterVVEntry->CleanUpFlags, VV_ENTRY_RETIRE_ACTIVE)) {
        UNLOCK_GEN_TABLE(VV);
        return FrsErrorSuccess;
    }

    SetFlag(MasterVVEntry->CleanUpFlags, VV_ENTRY_RETIRE_ACTIVE);

    //
    // Propagate Change Orders for all activated retire slots at front of list.
    //
    while (!IsListEmpty(&MasterVVEntry->ListHead)) {

        Entry = GetListHead(&MasterVVEntry->ListHead);
        RetireSlot = CONTAINING_RECORD(Entry, VV_RETIRE_SLOT, Link);

        //
        // If not retired then done.
        //
        if (RetireSlot->ChangeOrder == NULL) {
            break;
        }

        CHANGE_ORDER_TRACE(3, RetireSlot->ChangeOrder, "VV RetireSlot & Update");
        //
        // If this is the last entry to retire, update the VV table in database.
        // If we crash during processing of a series of retiring VV slots the
        // worst that can happen is that our VV entry for this originator is
        // a little old.  When we join we will request files based on this
        // Version Vector entry that we already have.  These COs will be
        // rejected so the actual files are not fetched.
        //
        Flags = 0;
        pNext = GetListNext(&RetireSlot->Link);
        if ((pNext == &MasterVVEntry->ListHead) ||
            (CONTAINING_RECORD(pNext, VV_RETIRE_SLOT, Link)->ChangeOrder == NULL)){
            Flags = ISCU_UPDATEVV_DB;
        }

        FrsRemoveEntryList(&RetireSlot->Link);

        //
        // Complete the propagation of the postponed change order, drop our
        // reference and clear ISCU_ACTIVATE_VV so we don't come back here
        // recursively.  The dropped ref could free the CO so don't try to
        // deref it.
        //
        Flags |= RetireSlot->CleanUpFlags | ISCU_FREEMEM_CLEANUP;
        ClearFlag(Flags, ISCU_ACTIVATE_VV);

        //
        // If this CO has been aborted then don't insert it into the Outbound
        // log.  Partner ack (if remote) and other cleanup is still needed.
        //
        if (CO_IFLAG_ON(RetireSlot->ChangeOrder, CO_IFLAG_CO_ABORT)) {
            ClearFlag(Flags, (ISCU_INS_OUTLOG |
                              ISCU_INS_OUTLOG_NEW_GUID));
        }

        //
        // This is to deal with the case of a crash after a remote CO has
        // installed or after a local CO has gened the staging file but the
        // VV prop is blocked by another CO.  In the latter case the CO would
        // be marked activated but not executed.  Or the remote CO could still be in
        // retry because of rename deferred, etc, but the vvretire is already done.
        // Code at startup uses this to sort things out.
        //
        SET_CO_IFLAG(RetireSlot->ChangeOrder, CO_IFLAG_VVRETIRE_EXEC);

        //
        // Update the master version vector before we drop the lock so reserve
        // can filter out of order remote COs from a different inbound partner
        // correctly.  These could come straight in or be retry COs.
        //
        UpdateVsn = RetireSlot->Vsn;
        DPRINT2(5, "Updating MasterVVEntry from %08x %08x  to  %08x %08x\n",
                PRINTQUAD(MasterVVEntry->GVsn.Vsn), PRINTQUAD(UpdateVsn));
        FRS_ASSERT(UpdateVsn >= MasterVVEntry->GVsn.Vsn);
        MasterVVEntry->GVsn.Vsn = UpdateVsn;

        //
        // Drop the table lock so others can do lookups, reserve slots or do
        // retires while we are doing database operations.
        // We still have the Dbs VV lock so another thread can't
        // get into this loop and cause a race to update the database VV table.
        // And since the RetireSlot is already off the list the retry thread
        // can't get a reference to it.
        //
        UNLOCK_GEN_TABLE(VV);

        FStatus = ChgOrdIssueCleanup(ThreadCtx,
                                     Replica,
                                     RetireSlot->ChangeOrder,
                                     Flags);
        DPRINT_FS(0,"ERROR - ChgOrdIssueCleanup failed.", FStatus);
        FRS_ASSERT(FStatus == FrsErrorSuccess);

        //
        // Free up the memory of the retire slot.
        //
        FrsFree(RetireSlot);
        LOCK_GEN_TABLE(VV);
    }


    //
    // Clear the retire active flag so the next thread that activates the
    // first entry on the list can enter the retire loop.
    //
    ClearFlag(MasterVVEntry->CleanUpFlags, VV_ENTRY_RETIRE_ACTIVE);

    VV_PRINT(4, L"End of Retire Change Order", VV);
    UNLOCK_GEN_TABLE(VV);

    return FrsErrorSuccess;
}



PCHANGE_ORDER_ENTRY
VVReferenceRetireSlot(
    IN PREPLICA  Replica,
    IN PCHANGE_ORDER_COMMAND CoCmd
    )
/*++
Routine Description:
    Look for an activated retire slot for this Guid/Vsn pair.
    If found and the connection guid in the change order matches then
    increment the reference count and return the Change order pointer.

Arguments:

    Replica -- ptr to the replica struct for the version vector.

    CoCmd -- ptr to change order command that we are trying to match.

Return Value:
    A ptr to the change order if found or NULL.

--*/
{
#undef DEBSUB
#define DEBSUB  "VVReferenceRetireSlot:"

    ULONGLONG            FrsVsn;
    PVV_ENTRY            MasterVVEntry;
    PGEN_TABLE           VV = Replica->VVector;
    PCHANGE_ORDER_ENTRY  ChangeOrder = NULL;
    GUID                *OriginatorGuid;
    GUID                *CxtionGuid;
    GUID                *CoGuid;


    FrsVsn = CoCmd->FrsVsn;
    OriginatorGuid = &CoCmd->OriginatorGuid;
    CxtionGuid = &CoCmd->CxtionGuid;

    LOCK_GEN_TABLE(VV);

    MasterVVEntry = GTabLookupNoLock(VV, OriginatorGuid, NULL);

    if (MasterVVEntry) {
        ForEachListEntryLock( MasterVVEntry, VV_RETIRE_SLOT, Link,
            // The iterator pE is of type PVV_RETIRE_SLOT.
            if (pE->Vsn == FrsVsn) {

                if ((pE->ChangeOrder != NULL) &&
                     GUIDS_EQUAL(&pE->ChangeOrder->Cmd.CxtionGuid, CxtionGuid)) {

                    //
                    // Found a match.  But need to also check for a CO Guid match.
                    //
                    CoGuid = &CoCmd->ChangeOrderGuid;
                    if (!GUIDS_EQUAL(CoGuid, &pE->ChangeOrder->Cmd.ChangeOrderGuid)) {
                        //
                        // The CO Guid's do not match.  The CO on the VV Retire
                        // chain has a matching OriginatorGuid, a matching VSN
                        // and a matching CxtionGuid so it is the same CO but
                        // we got a duplicate with a new CO Guid.  One way this
                        // can happen is if M1 was doing a VVJOIN from M2 and
                        // M2 had a CO for file X in the retry install state.
                        // When the CO on M2 finally finishes it must re-insert
                        // the CO into the outbound log, assigning the CO a new
                        // CO Guid.  The CO that was sent as part of the VVJoin
                        // operation could have the same OriginatorGuid, FrsVsn
                        // and Cxtion Guid, causing a match above.  In addition
                        // since M2 proped the incomming CO into the outlog
                        // after it fetched the staging file from its upstream
                        // partner it will have to re-insert the CO a second
                        // time if it was forced to go thru the retry install
                        // loop.  This is because it can't know how the propped
                        // CO was ordered relative to the VVJoin generated CO.
                        // This bites.  (313427)
                        //
                        DPRINT(0, "WARN - COGuid Mismatch on VVretireSlot hit\n");

                        CHANGE_ORDER_TRACE(0, pE->ChangeOrder, "No VVRef COGuid Mismatch-1");
                        CHANGE_ORDER_COMMAND_TRACE(0, CoCmd, "No VVRef COGuid Mismatch-2");
                    } else {

                        //
                        // Match is OK.
                        //
                        ChangeOrder = pE->ChangeOrder;
                        INCREMENT_CHANGE_ORDER_REF_COUNT(ChangeOrder);
                        CHANGE_ORDER_TRACE(3, ChangeOrder, "VV Ref CO");
                    }
                }
                break;
            }
        );
    }


    UNLOCK_GEN_TABLE(VV);

    return ChangeOrder;
}


VOID
VVUpdate(
    IN PGEN_TABLE   VV,
    IN ULONGLONG    Vsn,
    IN GUID         *Guid
    )
/*++
Routine Description:
    Update the version vector if the new vsn is greater than
    the current version. Or if the entry does not yet exist in VV.

Arguments:
    VV
    Vsn
    Guid

Return Value:
    None.

--*/
{
#undef DEBSUB
#define DEBSUB  "VVUpdate:"
    PVV_ENTRY VVEntry;

    //
    // Locate the originator's entry in the version vector
    //
    LOCK_GEN_TABLE(VV);

    VVEntry = GTabLookupNoLock(VV, Guid, NULL);
    if (VVEntry) {
        if (Vsn > VVEntry->GVsn.Vsn) {

            //
            // Update the existing entry's vsn
            //
            VVEntry->GVsn.Vsn = Vsn;
        }
    } else {

        //
        // Insert the new entry
        //
        VVEntry = FrsAlloc(sizeof(VV_ENTRY));
        VVEntry->GVsn.Vsn = Vsn;
        COPY_GUID(&VVEntry->GVsn.Guid, Guid);
        InitializeListHead(&VVEntry->ListHead);
        GTabInsertEntryNoLock(VV, VVEntry, &VVEntry->GVsn.Guid, NULL);
    }

    UNLOCK_GEN_TABLE(VV);
}


VOID
VVInsertOutbound(
    IN PGEN_TABLE   VV,
    IN PGVSN        GVsn
    )
/*++
Routine Description:
    Insert the given gvsn (guid, vsn) into the version vector.
    The GVsn is addressed by the gen table, don't delete it or
    change its guid!

    WARN - This function should only be used when creating
    the outbound version vector.

Arguments:
    VV   - version vector to update
    GVsn - record to insert

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "VVInsertOutbound:"
    GTabInsertEntry(VV, GVsn, &GVsn->Guid, NULL);
}


VOID
VVUpdateOutbound(
    IN PGEN_TABLE   VV,
    IN PGVSN        GVsn
    )
/*++
Routine Description:
    Update the version vector if the new vsn is greater than
    the current version. Or if the entry does not yet exist in VV.

    This function is intended for use only with the version vector
    associated with an outbound cxtion because that version vector
    uses GVSN's as the version vector entry. This saves memory.

Arguments:
    VV
    GVsn

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "VVUpdateOutbound:"
    PGVSN       OldGVsn;

    //
    // Probably a command packet without a RsGVsn()
    //
    if (!GVsn) {
        return;
    }
    //
    // Find the originator's entry in the version vector
    //
    LOCK_GEN_TABLE(VV);
    OldGVsn = GTabLookupNoLock(VV, &GVsn->Guid, NULL);
    if (OldGVsn) {
        //
        // Update the version if it is greater
        //
        if (GVsn->Vsn > OldGVsn->Vsn) {
            OldGVsn->Vsn = GVsn->Vsn;
        }
        FrsFree(GVsn);
    }
    UNLOCK_GEN_TABLE(VV);
    if (!OldGVsn) {
        //
        // Create a new entry
        //
        VVInsertOutbound(VV, GVsn);
    }
}


BOOL
VVHasVsnNoLock(
    IN PGEN_TABLE   VV,
    IN GUID         *OriginatorGuid,
    IN ULONGLONG    Vsn
    )
/*++
Routine Description:
    Check if the change order's Vsn is "in" the VV

Arguments:
    VV
    OriginatorGuid
    Vsn

Return Value:
    TRUE    - Vsn is in version vector
    FALSE   - Not
--*/
{
#undef DEBSUB
#define DEBSUB  "VVHasVsnNoLock:"
    BOOL        Ret = FALSE;
    PGVSN       GVsn;
    PGEN_ENTRY  Entry;

    //
    // Locate the originator's entry in the version vector
    //      The caller holds the table lock across the compare because
    //      the 64-bit vsn is not updated atomically. Don't
    //      hold the VV lock because that lock is held
    //      across db updates.
    //
    Entry = GTabLookupEntryNoLock(VV, OriginatorGuid, NULL);
    if (Entry) {
        FRS_ASSERT(!Entry->Dups);
        GVsn = Entry->Data;
        Ret = (Vsn <= (ULONGLONG)GVsn->Vsn);
    }
    return Ret;
}





BOOL
VVHasOriginatorNoLock(
    IN PGEN_TABLE   VV,
    IN GUID         *OriginatorGuid
    )
/*++
Routine Description:
    Check if the supplied originator guid is present in the version vector.

Arguments:
    VV
    OriginatorGuid

Return Value:
    TRUE    - Originator guid is present in version vector

--*/
{
#undef DEBSUB
#define DEBSUB  "VVHasOriginatorNoLock:"

    //
    // Locate the originator's entry in the version vector
    //      The caller holds the table lock across the compare because
    //      the 64-bit vsn is not updated atomically. Don't
    //      hold the VV lock because that lock is held
    //      across db updates.
    //

    return (GTabLookupEntryNoLock(VV, OriginatorGuid, NULL) != NULL);

}


BOOL
VVHasVsn(
    IN PGEN_TABLE            VV,
    IN PCHANGE_ORDER_COMMAND Coc
    )
/*++
Routine Description:
    Check if the change order's Vsn is "in" the VV

Arguments:
    VV
    Coc

Return Value:
    TRUE    - Vsn is in version vector
    FALSE   - Not
--*/
{
#undef DEBSUB
#define DEBSUB  "VVHasVsn:"
    BOOL        Ret = FALSE;

    //
    // This change order is out of order and hence its vsn
    // cannot be compared with the vsn in the version vector.
    //
    if (BooleanFlagOn(Coc->Flags, CO_FLAG_OUT_OF_ORDER)) {
        return FALSE;
    }

    //
    // Locate the originator's entry in the version vector
    //      Hold the table lock across the compare because
    //      the 64-bit vsn is not updated atomically. Don't
    //      hold the VV lock because that lock is held
    //      across db updates.
    //
    LOCK_GEN_TABLE(VV);
    Ret = VVHasVsnNoLock(VV, &Coc->OriginatorGuid, Coc->FrsVsn);
    UNLOCK_GEN_TABLE(VV);

    return Ret;
}


PGVSN
VVGetGVsn(
    IN PGEN_TABLE VV,
    IN GUID       *Guid
    )
/*++
Routine Description:
    Lookup the Vsn for Guid in VV.

Arguments:
    VV
    Guid

Return Value:
    Copy of the GVsn or NULL
--*/
{
#undef DEBSUB
#define DEBSUB  "VVGetGVsn:"
    PGVSN       GVsn = NULL;
    PGEN_ENTRY  Entry;

    //
    // Locate the originator's entry in the version vector
    //      Hold the table lock across the compare because
    //      the 64-bit vsn is not updated atomically. Don't
    //      hold the VV lock because that lock is held
    //      across db updates.
    //
    LOCK_GEN_TABLE(VV);

    Entry = GTabLookupEntryNoLock(VV, Guid, NULL);
    if (Entry) {
        FRS_ASSERT(!Entry->Dups);
        GVsn = Entry->Data;
        GVsn = FrsBuildGVsn(&GVsn->Guid, GVsn->Vsn);
    }

    UNLOCK_GEN_TABLE(VV);
    return (GVsn);
}


PGEN_TABLE
VVDupOutbound(
    IN PGEN_TABLE   VV
    )
/*++
Routine Description:
    Duplicate the version vector as an outbound version vector.
    An outbound version vector is composed of GVSNs instead of
    VV_ENTRYs to save space. BUT, since the first entry in a
    VV_ENTRY is a GVSN, this routin can duplicate any version
    vector.

Arguments:
    Outbound    - version vector to duplicate as an outbound version vector

Return Value:
    Outbound version vector
--*/
{
#undef DEBSUB
#define DEBSUB  "VVDupOutbound:"
    PVOID       Key;
    PGVSN       GVsn;
    PGEN_TABLE  NewVV;

    //
    // No vv, nothing to do
    //
    if (!VV) {
        return NULL;
    }

    //
    // Allocate duplicate version vector
    //
    NewVV = GTabAllocTable();

    //
    // Fill it up
    //
    LOCK_GEN_TABLE(VV);
    Key = NULL;
    while (GVsn = GTabNextDatumNoLock(VV, &Key)) {
        GVsn = FrsBuildGVsn(&GVsn->Guid, GVsn->Vsn);
        GTabInsertEntryNoLock(NewVV, GVsn, &GVsn->Guid, NULL);
    }
    UNLOCK_GEN_TABLE(VV);

    //
    // Done
    //
    return NewVV;
}


PVOID
VVFreeOutbound(
    IN PGEN_TABLE VV
    )
/*++
Routine Description:
    Delete the version vector for an outbound cxtion

Arguments:
    VV      - version vector to update

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "VVFreeOutbound:"
    return GTabFreeTable(VV, FrsFree);
}


VOID
VVFree(
    IN PGEN_TABLE VV
    )
/*++
Routine Description:
    Delete the version vector for the replica

Arguments:
    VV      - version vector to update

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "VVFree:"
    PVOID       Key;
    PVV_ENTRY   MasterVVEntry;

    Key = NULL;
    if (VV) while (MasterVVEntry = GTabNextDatum(VV, &Key)) {
        ForEachListEntryLock( MasterVVEntry, VV_RETIRE_SLOT, Link,
            // The iterator pE is of type PVV_RETIRE_SLOT.
            FrsFree(pE);
        );
    }

    GTabFreeTable(VV, FrsFree);
}


#if DBG
VOID
VVPrint(
    IN ULONG        Severity,
    IN PWCHAR       Header,
    IN PGEN_TABLE   VV,
    IN BOOL         IsOutbound
    )
/*++
Routine Description:
    Print a version vector

    Caller must have acquired the VV table lock so se can safely enumerate
    the list. i.e.  LOCK_GEN_TABLE(VV).

Arguments:
    Severity
    Header
    VV
    IsOutbound

Return Value:
    None.
--*/
{
#undef DEBSUB
#define DEBSUB  "VVPrint:"
    PVOID       Key;
    PVV_ENTRY   MasterVVEntry;
    CHAR        Guid[GUID_CHAR_LEN + 1];

    DPRINT2(Severity, "VV for %ws: %08x\n", Header, VV);
    Key = NULL;
    if (VV) while (MasterVVEntry = GTabNextDatumNoLock(VV, &Key)) {
        GuidToStr(&MasterVVEntry->GVsn.Guid, Guid);
        DPRINT2(Severity, "\t%s = %08x %08x\n", Guid, PRINTQUAD(MasterVVEntry->GVsn.Vsn));

        if (!IsOutbound) {
            ForEachListEntryLock( MasterVVEntry, VV_RETIRE_SLOT, Link,
                // The iterator pE is of type PVV_RETIRE_SLOT.
                DPRINT2(Severity, "\t\t%08x %08x  CO: %08x\n",
                        PRINTQUAD(pE->Vsn), pE->ChangeOrder);
            );

        } else {
            DPRINT1(Severity, "\t\t%08x %08x\n", PRINTQUAD(MasterVVEntry->GVsn.Vsn));
        }
    }
}
#endif DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apimsg.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    ApiMsg.c

Abstract:

    This module contains individual API handlers for the NetMessage APIs.

    SUPPORTED - NetMessageBufferSend, NetMessageNameAdd, NetMessageNameDel,
                NetMessageNameEnum, NetMessageNameGetInfo.

Author:

    Shanku Niyogi (w-shanku)    8-Mar-1991

Revision History:

--*/

#include "XactSrvP.h"

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_msg_info_0 = REM16_msg_info_0;
STATIC const LPDESC Desc32_msg_info_0 = REM32_msg_info_0;
STATIC const LPDESC Desc16_msg_info_1 = REM16_msg_info_1;
STATIC const LPDESC Desc32_msg_info_1 = REM32_msg_info_1;


NTSTATUS
XsNetMessageBufferSend (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetMessageBufferSend.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_MESSAGE_BUFFER_SEND parameters = Parameters;
    LPTSTR nativeRecipient = NULL;          // Native parameters
    LPBYTE nativeBuffer = NULL;
    DWORD nativeBufLen;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(MESSAGE) {
        NetpKdPrint(( "XsNetMessageBufferSend: header at %lx, params at %lx, "
                      "recipient %s\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->Recipient )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeRecipient,
            (LPSTR)XsSmbGetPointer( &parameters->Recipient )
            );

        //
        // NetMessageBufferSend has an ASCII data buffer. Convert this to
        // Unicode if necessary. 
        //

#ifdef UNICODE

        nativeBufLen = SmbGetUshort( &parameters->BufLen ) * sizeof(WCHAR);

        if (( nativeBuffer = NetpMemoryAllocate( nativeBufLen )) == NULL ) {

            status = NERR_NoRoom;
            goto cleanup;

        } else {

            XsCopyBufToTBuf(
                (LPBYTE)nativeBuffer,
                (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                (DWORD)SmbGetUshort( &parameters->BufLen )
                );

        }
#else

        nativeBuffer = (LPBYTE)SmbGetUlong( &parameters->Buffer );
        nativeBufLen = (DWORD)SmbGetUshort( &parameters->BufLen );

#endif // def UNICODE

        status = NetMessageBufferSend(
                     NULL,
                     nativeRecipient,
                     NULL,
                     nativeBuffer,
                     nativeBufLen
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetMessageBufferSend: NetMessageBufferSend "
                              "failed: %X\n", status ));
            }
        }

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeRecipient );

#ifdef UNICODE
    NetpMemoryFree( nativeBuffer );
#endif // def UNICODE

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetMessageBufferSend


NTSTATUS
XsNetMessageNameAdd (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetMessageNameAdd.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_MESSAGE_NAME_ADD parameters = Parameters;
    LPTSTR nativeMessageName = NULL;        // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(MESSAGE) {
        NetpKdPrint(( "XsNetMessageNameDel: header at %lx, params at %lx, "
                      "name %s\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->MessageName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeMessageName,
            (LPSTR)XsSmbGetPointer( &parameters->MessageName )
            );

        //
        // NetMessageNameAdd has one useful parameter, MessageName, a string.
        // The other parameter, FwdAction, is ignored in NT, because forwarding
        // messages is not supported.
        //
        // Make the local call.
        //

        status = NetMessageNameAdd(
                     NULL,
                     nativeMessageName
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetMessageNameAdd: NetMessageNameAdd "
                              "failed: %X\n", status ));
            }
        }

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeMessageName );

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetMessageNameAdd


NTSTATUS
XsNetMessageNameDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetMessageNameDel.

Arguments:

    Transaction - a pointer to a transaction block containing information
        about the API to process.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_MESSAGE_NAME_DEL parameters = Parameters;
    LPTSTR nativeMessageName = NULL;        // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(MESSAGE) {
        NetpKdPrint(( "XsNetMessageNameDel: header at %lx, params at %lx, "
                      "name %s\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->MessageName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeMessageName,
            (LPSTR)XsSmbGetPointer( &parameters->MessageName )
            );

        //
        // NetMessageNameDel has only one useful parameter, MessageName, which is
        // a string. The other parameter, FwdAction, is ignored, because NT does
        // not support message forwarding.
        //
        // Make the local call.
        //

        status = NetMessageNameDel(
                     NULL,
                     nativeMessageName
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetMessageNameDel: NetMessageNameDel failed: "
                              "%X\n", status ));
            }
        }

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeMessageName );

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetMessageNameDel


NTSTATUS
XsNetMessageNameEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetMessageNameEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_MESSAGE_NAME_ENUM parameters = Parameters;
    LPVOID outBuffer = NULL;                // Native parameters
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(MESSAGE) {
        NetpKdPrint(( "XsNetMessageNameEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Get the actual information from the local 32-bit call.
        //

        status = NetMessageNameEnum(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetMessageNameEnum: NetMessageNameEnum failed:"
                              " %X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(MESSAGE) {
            NetpKdPrint(( "XsNetMessageNameEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_msg_info_0;
            StructureDesc = Desc16_msg_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_msg_info_1;
            StructureDesc = Desc16_msg_info_1;
            break;
        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(MESSAGE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. MSG_INFO_x structures have no
        // data to pack.
        //

        if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetMessageNameEnum


NTSTATUS
XsNetMessageNameGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetMessageNameGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_MESSAGE_NAME_GET_INFO parameters = Parameters;
    LPTSTR nativeMessageName = NULL;        // Native parameters
    LPVOID outBuffer = NULL;

    DWORD bytesRequired = 0;                // Conversion variables
    LPBYTE stringLocation = NULL;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(MESSAGE) {
        NetpKdPrint(( "XsNetMessageNameGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeMessageName,
            (LPSTR)XsSmbGetPointer( &parameters->MessageName )
            );

        //
        // Do the actual local call.
        //

        status = NetMessageNameGetInfo(
                     NULL,
                     nativeMessageName,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetMessageNameGetInfo: "
                              "NetMessageNameGetInfo failed: %X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_msg_info_0;
            StructureDesc = Desc16_msg_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_msg_info_1;
            StructureDesc = Desc16_msg_info_1;
            break;
        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "NetMessageNameGetInfo: "
                              "RapConvertSingleEntry failed: %X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(MESSAGE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer. msg_info_x
        // structures have no data to pack.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetMessageNameGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        }


        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeMessageName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetMessageNameGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apiprint.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    ApiPrint.c

Abstract:

    This module contains individual API handlers for the DosPrint APIs.

    SUPPORTED : DosPrintDestAdd, DosPrintDestControl, DosPrintDestDel,
                DosPrintDestEnum, DosPrintDestGetInfo, DosPrintDestSetInfo,
                DosPrintJobContinue, DosPrintJobDel, DosPrintJobEnum,
                DosPrintJobGetId, DosPrintJobGetInfo, DosPrintJobPause,
                DosPrintJobSetInfo, DosPrintQAdd, DosPrintQContinue,
                DosPrintQDel, DosPrintQEnum, DosPrintQGetInfo,
                DosPrintQPause, DosPrintQPurge, DosPrintQSetInfo.

Author:

    Shanku Niyogi (w-shanku) 04-Apr-1991

Revision History:

    18-Jun-1992 JohnRo
        RAID 10324: net print vs. UNICODE.
        Use FORMAT_ equates.
    01-Oct-1992 JohnRo
        RAID 3556: DosPrintQGetInfo(from downlevel) level 3, rc=124.  (4&5 too.)

--*/

#include "XactSrvP.h"
#include <dosprint.h>

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_print_dest_0 = REM16_print_dest_0;
STATIC const LPDESC Desc32_print_dest_0 = REM32_print_dest_0;
STATIC const LPDESC Desc16_print_dest_1 = REM16_print_dest_1;
STATIC const LPDESC Desc32_print_dest_1 = REM32_print_dest_1;
STATIC const LPDESC Desc16_print_dest_2 = REM16_print_dest_2;
STATIC const LPDESC Desc32_print_dest_2 = REM32_print_dest_2;
STATIC const LPDESC Desc16_print_dest_3 = REM16_print_dest_3;
STATIC const LPDESC Desc32_print_dest_3 = REM32_print_dest_3;
STATIC const LPDESC Desc16_print_dest_3_setinfo = REM16_print_dest_3_setinfo;
STATIC const LPDESC Desc32_print_dest_3_setinfo = REM32_print_dest_3_setinfo;
STATIC const LPDESC Desc16_print_job_0 = REM16_print_job_0;
STATIC const LPDESC Desc32_print_job_0 = REM32_print_job_0;
STATIC const LPDESC Desc16_print_job_1 = REM16_print_job_1;
STATIC const LPDESC Desc32_print_job_1 = REM32_print_job_1;
STATIC const LPDESC Desc16_print_job_1_setinfo = REM16_print_job_1_setinfo;
STATIC const LPDESC Desc32_print_job_1_setinfo = REM32_print_job_1_setinfo;
STATIC const LPDESC Desc16_print_job_2 = REM16_print_job_2;
STATIC const LPDESC Desc32_print_job_2 = REM32_print_job_2;
STATIC const LPDESC Desc16_print_job_3 = REM16_print_job_3;
STATIC const LPDESC Desc32_print_job_3 = REM32_print_job_3;
STATIC const LPDESC Desc16_print_job_3_setinfo = REM16_print_job_3_setinfo;
STATIC const LPDESC Desc32_print_job_3_setinfo = REM32_print_job_3_setinfo;
STATIC const LPDESC Desc16_printQ_0 = REM16_printQ_0;
STATIC const LPDESC Desc32_printQ_0 = REM32_printQ_0;
STATIC const LPDESC Desc16_printQ_1 = REM16_printQ_1;
STATIC const LPDESC Desc32_printQ_1 = REM32_printQ_1;
STATIC const LPDESC Desc16_printQ_1_setinfo = REM16_printQ_1_setinfo;
STATIC const LPDESC Desc32_printQ_1_setinfo = REM32_printQ_1_setinfo;
STATIC const LPDESC Desc16_printQ_2 = REM16_printQ_2;
STATIC const LPDESC Desc32_printQ_2 = REM32_printQ_2;
STATIC const LPDESC Desc16_printQ_3 = REM16_printQ_3;
STATIC const LPDESC Desc32_printQ_3 = REM32_printQ_3;
STATIC const LPDESC Desc16_printQ_3_setinfo = REM16_printQ_3_setinfo;
STATIC const LPDESC Desc32_printQ_3_setinfo = REM32_printQ_3_setinfo;
STATIC const LPDESC Desc16_printQ_4 = REM16_printQ_4;
STATIC const LPDESC Desc32_printQ_4 = REM32_printQ_4;
STATIC const LPDESC Desc16_printQ_5 = REM16_printQ_5;
STATIC const LPDESC Desc32_printQ_5 = REM32_printQ_5;
STATIC const LPDESC Desc16_printQ_52 = REM16_printQ_52;
STATIC const LPDESC Desc32_printQ_52 = REM32_printQ_52;

//
// DosPrint calls behave differently from Net api calls.  On Net api calls,
// the called routine supplies the buffer to us.  DosPrint apis need a
// supplied buffer and thus can return NERR_BufferTooSmall which means
// it's an error but return the bytes needed if it's a XXGetInfo call.
//

#define XsPrintApiSuccess( Status ) \
    (( (Status) == NERR_Success ) || ( (Status) == ERROR_MORE_DATA ))

//
// Now that servers can have multiple names (See SrvNetTransportAdd, and clusters),
//  it is necessary to transmit the server name part of a queue name to the spooler.
//  The following three macros aid in the translation.
//
#define  PREPARE_CONVERT_QUEUE_NAME()                                           \
    WCHAR queueNameBuf[ MAX_PATH ];                                             \
    CHAR localComputerName[ NETBIOS_NAME_LEN ];                                 \
    DWORD localComputerNameLen = sizeof( localComputerName );                   \
    PUCHAR p = &Header->ServerName[ NETBIOS_NAME_LEN-2 ];                       \
    for( ; p > Header->ServerName && *p == ' '; p-- );                          \
    p++;                                                                        \
    GetComputerNameA( localComputerName, &localComputerNameLen );

#define CONVERT_QUEUE_NAME( queue )                                             \
    if( queue && ((DWORD)(p-Header->ServerName) != localComputerNameLen ||      \
        memcmp( localComputerName, Header->ServerName, localComputerNameLen )) &&\
        mbstowcs( NULL, Header->ServerName, (size_t)(p-Header->ServerName )) <= \
        sizeof( queueNameBuf ) - wcslen(queue)*sizeof(WCHAR) - 4*sizeof(WCHAR)){\
                                                                                \
        RtlZeroMemory( queueNameBuf, sizeof( queueNameBuf ) );                  \
        queueNameBuf[0] = queueNameBuf[1] = L'\\';                              \
        mbstowcs( queueNameBuf+2, Header->ServerName,                           \
                                  (size_t)(p-Header->ServerName) );             \
        wcscat( queueNameBuf, L"\\" );                                          \
        wcscat( queueNameBuf, queue );                                          \
        NetApiBufferFree( queue );                                              \
        queue = queueNameBuf;                                                   \
    }

#define FREE_QUEUE_NAME( queue ) if( queue != queueNameBuf ) NetApiBufferFree( queue )

#define GET_LOCAL_SERVER_NAME()                                                 \
    WCHAR LocalServerName[ MAX_PATH ];                                          \
    PUCHAR p = &Header->ServerName[ NETBIOS_NAME_LEN-2 ];                       \
    for( ; p > Header->ServerName && *p == ' '; p-- );                          \
    p++;                                                                        \
    LocalServerName[0] = LocalServerName[1] = L'\\';                            \
    mbstowcs( LocalServerName+2, Header->ServerName,                            \
                                 (size_t)(p-Header->ServerName) );              \
    LocalServerName[2+p-Header->ServerName] = L'\0';



NTSTATUS
XsNetPrintDestAdd (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintDestAdd.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_DEST_ADD parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    DWORD bufferSize;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintDestAdd: header at " FORMAT_LPVOID
                      ", params at " FORMAT_LPVOID ", "
                      "level " FORMAT_DWORD "\n",
                      Header,
                      parameters,
                      SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 3 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        StructureDesc = Desc16_print_dest_3;

        //
        // Figure out if there is enough room in the buffer for all the
        // data required. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestAdd: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find out how big a buffer we need to allocate to hold the native
        // 32-bit version of the input data structure.
        //

        bufferSize = XsBytesForConvertedStructure(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         StructureDesc,
                         Desc32_print_dest_3,
                         RapToNative,
                         TRUE
                         );

        //
        // Allocate enough memory to hold the converted native buffer.
        //

        buffer = NetpMemoryAllocate( bufferSize );

        if ( buffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestAdd: failed to create buffer" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;

        }

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "XsNetPrintDestAdd: buffer of " FORMAT_DWORD " bytes at " FORMAT_LPVOID "\n",
                          bufferSize, buffer ));
        }

        //
        // Convert the buffer from 16-bit to 32-bit.
        //

        stringLocation = (LPBYTE)buffer + bufferSize;
        bytesRequired = 0;

        status = RapConvertSingleEntry(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     buffer,
                     buffer,
                     Desc32_print_dest_3,
                     FALSE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     RapToNative
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestAdd: RapConvertSingleEntry failed: "
                              FORMAT_API_STATUS "\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = DosPrintDestAdd(
                     NULL,
                     SmbGetUshort( &parameters->Level ),
                     buffer,
                     (WORD)bufferSize
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestAdd: DosPrintDestAdd failed: "
                        FORMAT_API_STATUS "\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // There is no real return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( buffer );

    return STATUS_SUCCESS;

} // XsNetPrintDestAdd


NTSTATUS
XsNetPrintDestControl (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintDestControl.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_DEST_CONTROL parameters = Parameters;
    LPTSTR nativeDestName = NULL;           // Native parameters
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintDestControl: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "name " FORMAT_LPSTR "\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->DestName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeDestName,
            (LPSTR)XsSmbGetPointer( &parameters->DestName )
            );

        CONVERT_QUEUE_NAME( nativeDestName );

        //
        // Make the local call.
        //
        status = DosPrintDestControl(
                     NULL,
                     nativeDestName,
                     SmbGetUshort( &parameters->Control )
                     );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( !XsPrintApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetPrintDestControl: DosPrintDestControl failed: "
                          FORMAT_API_STATUS "\n", status ));
        }
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    FREE_QUEUE_NAME( nativeDestName );

    return STATUS_SUCCESS;

} // XsNetPrintDestControl


NTSTATUS
XsNetPrintDestDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintDestDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_DEST_DEL parameters = Parameters;
    LPTSTR nativePrinterName = NULL;        // Native parameters
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintDestDel: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "name " FORMAT_LPSTR "\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->PrinterName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativePrinterName,
            (LPSTR)XsSmbGetPointer( &parameters->PrinterName )
            );

        CONVERT_QUEUE_NAME( nativePrinterName );

        //
        // Make the local call.
        //

        status = DosPrintDestDel(
                     NULL,
                     nativePrinterName
                     );
cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( !XsPrintApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetPrintDestDel: DosPrintDestDel failed: "
                    FORMAT_API_STATUS "\n",
                          status ));
        }
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    FREE_QUEUE_NAME( nativePrinterName );
    return STATUS_SUCCESS;

} // XsNetPrintDestDel


NTSTATUS
XsNetPrintDestEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintDestEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_DEST_ENUM parameters = Parameters;
    LPVOID outBuffer= NULL;                 // Native parameters
    DWORD outBufferSize;
    DWORD entriesRead = 0;
    DWORD totalEntries = 0;

    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintDestEnum: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "level " FORMAT_DWORD ", buf size " FORMAT_DWORD "\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 3 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // !!! Print API mapping layer presently requires a preallocated buffer.
        //

        outBufferSize = XsNativeBufferSize( SmbGetUshort( &parameters->BufLen ));
        if ( NetapipBufferAllocate( outBufferSize, &outBuffer ) != NERR_Success
                 || outBuffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestEnum: cannot allocate memory\n" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = DosPrintDestEnum(
                     NULL,
                     SmbGetUshort( &parameters->Level ),
                     (LPBYTE)outBuffer,
                     (WORD)outBufferSize,
                     (LPWORD)&entriesRead,
                     (LPWORD)&totalEntries
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetPrintDestEnum: DosPrintDestEnum failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "XsNetPrintDestEnum: received " FORMAT_DWORD " entries at " FORMAT_LPVOID "\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_print_dest_0;
            StructureDesc = Desc16_print_dest_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_print_dest_1;
            StructureDesc = Desc16_print_dest_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_print_dest_2;
            StructureDesc = Desc16_print_dest_2;
            break;

        case 3:

            nativeStructureDesc = Desc32_print_dest_3;
            StructureDesc = Desc16_print_dest_3;
            break;

        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "32-bit data at " FORMAT_LPVOID ", 16-bit data at " FORMAT_LPVOID ", " FORMAT_DWORD " BR,"
                          " Entries " FORMAT_DWORD " of " FORMAT_DWORD "\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->Returned, (WORD)entriesFilled );
        SmbPutUshort( &parameters->Total, (WORD)totalEntries );

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetPrintDestEnum


NTSTATUS
XsNetPrintDestGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintDestGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_DEST_GET_INFO parameters = Parameters;
    LPTSTR nativeName = NULL;               // Native parameters
    LPVOID outBuffer = NULL;
    DWORD outBufferSize;
    WORD bytesNeeded = 0;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintDestGetInfo: header at " FORMAT_LPVOID ", "
                      "params at " FORMAT_LPVOID ", level " FORMAT_DWORD "\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 3 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeName,
            (LPSTR)XsSmbGetPointer( &parameters->Name )
            );

        CONVERT_QUEUE_NAME( nativeName );

        //
        // !!! Print API mapping layer presently requires a preallocated buffer.
        //

        outBufferSize = XsNativeBufferSize( SmbGetUshort( &parameters->BufLen ));
        if ( NetapipBufferAllocate( outBufferSize, &outBuffer ) != NERR_Success
                 || outBuffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestGetInfo: cannot allocate memory\n" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = DosPrintDestGetInfo(
                     NULL,
                     nativeName,
                     SmbGetUshort( &parameters->Level ),
                     (LPBYTE)outBuffer,
                     (WORD)outBufferSize,
                     &bytesNeeded
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetPrintDestGetInfo: DosPrintDestGetInfo failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_print_dest_0;
            StructureDesc = Desc16_print_dest_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_print_dest_1;
            StructureDesc = Desc16_print_dest_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_print_dest_2;
            StructureDesc = Desc16_print_dest_2;
            break;

        case 3:

            nativeStructureDesc = Desc32_print_dest_3;
            StructureDesc = Desc16_print_dest_3;
            break;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsDosPrintDestGetInfo: RapConvertSingleEntry failed: "
                              FORMAT_API_STATUS "\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "32-bit data at " FORMAT_LPVOID ", 16-bit data at " FORMAT_LPVOID ", " FORMAT_DWORD " BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );
        }

        bytesNeeded = (WORD)bytesRequired;

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Set up the response parameters.
    //

    SmbPutUshort( &parameters->Needed, bytesNeeded );

    NetApiBufferFree( outBuffer );
    FREE_QUEUE_NAME( nativeName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetPrintDestGetInfo


NTSTATUS
XsNetPrintDestSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintDestSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_DEST_SET_INFO parameters = Parameters;
    LPTSTR nativeName = NULL;               // Native parameters
    LPVOID buffer = NULL;
    DWORD bytesRequired;
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 3 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        StructureDesc = Desc16_print_dest_3;

        XsConvertTextParameter(
            nativeName,
            (LPSTR)XsSmbGetPointer( &parameters->Name )
            );

        status = XsConvertSetInfoBuffer(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     SmbGetUshort( &parameters->BufLen ),
                     SmbGetUshort( &parameters->ParmNum ),
                     FALSE,
                     TRUE,
                     StructureDesc,
                     Desc32_print_dest_3,
                     Desc16_print_dest_3_setinfo,
                     Desc32_print_dest_3_setinfo,
                     (LPBYTE *)&buffer,
                     &bytesRequired
                     );

        if ( status != NERR_Success ) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestSetInfo: Problem with conversion: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        CONVERT_QUEUE_NAME( nativeName );

        //
        // Do the actual local call.
        //

        status = DosPrintDestSetInfo(
                     NULL,
                     nativeName,
                     SmbGetUshort( &parameters->Level ),
                     (LPBYTE)buffer,
                     (WORD)bytesRequired,
                     SmbGetUshort( &parameters->ParmNum )
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintDestSetInfo: DosPrintDestSetInfo failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // No return information for this API.
        //

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // If there is a native 32-bit buffer, free it.
    //

    NetpMemoryFree( buffer );
    FREE_QUEUE_NAME( nativeName );

    return STATUS_SUCCESS;

} // XsNetPrintDestSetInfo


NTSTATUS
XsNetPrintJobContinue (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintJobContinue.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_JOB_CONTINUE parameters = Parameters;

    GET_LOCAL_SERVER_NAME();
    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintJobContinue: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "job " FORMAT_WORD_ONLY "\n",
                      Header, parameters, SmbGetUshort( &parameters->JobId )));
    }

    try {
        //
        // Make the local call.
        //

        status = DosPrintJobContinue(
                     LocalServerName,
                     FALSE,
                     SmbGetUshort( &parameters->JobId )
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintJobContinue: DosPrintJobContinue failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetPrintJobContinue


NTSTATUS
XsNetPrintJobDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintJobDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_JOB_DEL parameters = Parameters;

    GET_LOCAL_SERVER_NAME();
    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintJobDel: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "job " FORMAT_WORD_ONLY "\n",
                      Header, parameters, SmbGetUshort( &parameters->JobId )));
    }

    try {
        //
        // Make the local call.
        //

        status = DosPrintJobDel(
                     LocalServerName,
                     FALSE,
                     SmbGetUshort( &parameters->JobId )
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintJobDel: DosPrintJobDel failed: "
                        FORMAT_API_STATUS "\n",
                              status ));
            }
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetPrintJobDel


NTSTATUS
XsNetPrintJobEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintJobEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_JOB_ENUM parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters
    LPVOID outBuffer= NULL;
    DWORD outBufferSize;
    DWORD entriesRead = 0;
    DWORD totalEntries = 0;

    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;
    WORD bufferLength;
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintJobEnum: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "level " FORMAT_DWORD ", buf size " FORMAT_DWORD "\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 2 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeQueueName,
            (LPSTR)XsSmbGetPointer( &parameters->QueueName )
            );

        bufferLength = SmbGetUshort( &parameters->BufLen );

        CONVERT_QUEUE_NAME( nativeQueueName );

        //
        // !!! Print API mapping layer presently requires a preallocated buffer.
        //

        outBufferSize = XsNativeBufferSize( bufferLength );
        if ( NetapipBufferAllocate( outBufferSize, &outBuffer ) != NERR_Success
                 || outBuffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintJobEnum: cannot allocate memory\n" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = DosPrintJobEnum(
                     NULL,
                     nativeQueueName,
                     SmbGetUshort( &parameters->Level ),
                     (LPBYTE)outBuffer,
                     (WORD)outBufferSize,
                     (LPWORD)&entriesRead,
                     (LPWORD)&totalEntries
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetPrintJobEnum: DosPrintJobEnum failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "XsNetPrintJobEnum: received " FORMAT_DWORD " entries at " FORMAT_LPVOID "\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_print_job_0;
            StructureDesc = Desc16_print_job_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_print_job_1;
            StructureDesc = Desc16_print_job_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_print_job_2;
            StructureDesc = Desc16_print_job_2;
            break;

        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (DWORD)bufferLength,
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "32-bit data at " FORMAT_LPVOID ", 16-bit data at " FORMAT_LPVOID ", " FORMAT_DWORD " BR,"
                          " Entries " FORMAT_DWORD " of " FORMAT_DWORD "\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if ( (entriesFilled < totalEntries) ||
             (bytesRequired > bufferLength) ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    bufferLength,
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->Returned, (WORD)entriesFilled );
        SmbPutUshort( &parameters->Total, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    FREE_QUEUE_NAME( nativeQueueName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetPrintJobEnum


NTSTATUS
XsNetPrintJobGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintJobGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_JOB_GET_INFO parameters = Parameters;
    LPVOID outBuffer = NULL;                // Native parameters
    DWORD outBufferSize;
    WORD bytesNeeded = 0;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    GET_LOCAL_SERVER_NAME();
    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintJobGetInfo: header at " FORMAT_LPVOID ", "
                      "params at " FORMAT_LPVOID ", level " FORMAT_DWORD "\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 3 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // !!! Print API mapping layer presently requires a preallocated buffer.
        //

        outBufferSize = XsNativeBufferSize( SmbGetUshort( &parameters->BufLen ));
        if ( NetapipBufferAllocate( outBufferSize, &outBuffer ) != NERR_Success
                 || outBuffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintJobGetInfo: cannot allocate memory\n" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        //
        // Make the local call.
        //
        status = DosPrintJobGetInfo(
                     LocalServerName,
                     FALSE,
                     SmbGetUshort( &parameters->JobId ),
                     SmbGetUshort( &parameters->Level ),
                     (LPBYTE)outBuffer,
                     (WORD)outBufferSize,
                     &bytesNeeded
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetPrintJobGetInfo: DosPrintJobGetInfo failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_print_job_0;
            StructureDesc = Desc16_print_job_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_print_job_1;
            StructureDesc = Desc16_print_job_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_print_job_2;
            StructureDesc = Desc16_print_job_2;
            break;

        case 3:

            nativeStructureDesc = Desc32_print_job_3;
            StructureDesc = Desc16_print_job_3;
            break;
        }


        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsDosPrintJobGetInfo: RapConvertSingleEntry failed: "
                              FORMAT_API_STATUS "\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "32-bit data at " FORMAT_LPVOID ", 16-bit data at " FORMAT_LPVOID ", " FORMAT_DWORD " BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintJobGetInfo: Buffer too small.\n" ));
            }

            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintJobGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );
        }

        bytesNeeded = (WORD)bytesRequired;

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Set up the response parameters.
    //

    SmbPutUshort( &parameters->Needed, bytesNeeded );

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetPrintJobGetInfo


NTSTATUS
XsNetPrintJobPause (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintJobPause.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_JOB_PAUSE parameters = Parameters;

    GET_LOCAL_SERVER_NAME();
    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintJobPause: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "job " FORMAT_WORD_ONLY "\n",
                      Header, parameters, SmbGetUshort( &parameters->JobId )));
    }

    try {
        //
        // Make the local call.
        //

        status = DosPrintJobPause(
                     LocalServerName,
                     FALSE,
                     SmbGetUshort( &parameters->JobId )
                     );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( !XsPrintApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetPrintJobPause: DosPrintJobPause failed: "
                    FORMAT_API_STATUS "\n",
                          status ));
        }
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetPrintJobPause


NTSTATUS
XsNetPrintJobSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintJobSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_JOB_SET_INFO parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters
    DWORD bytesRequired;
    WORD level;

    DWORD fieldIndex;
    LPDESC setInfoDesc;                     // Conversion variables
    LPDESC nativeSetInfoDesc;
    LPDESC nativeStructureDesc;

    GET_LOCAL_SERVER_NAME();
    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Check for errors.
        //

        level = SmbGetUshort( &parameters->Level );

        if ( level != 1 && level != 3 ) {
            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Determine descriptor strings based on level. Also translate the
        // parmnum value to a field index.
        // !!! - Right now, we don't check for parameters settable in downlevel
        //       that are meaningless in the NT mapping layer. Fix this,
        //       if necessary, in the descriptor string file (with
        //       REM_IGNORE fields).
        //

        fieldIndex = (DWORD)SmbGetUshort( &parameters->ParmNum );

        switch ( level ) {

        case 1:

            StructureDesc = Desc16_print_job_1;
            nativeStructureDesc = Desc32_print_job_1;
            setInfoDesc = Desc16_print_job_1_setinfo;
            nativeSetInfoDesc = Desc32_print_job_1_setinfo;
            if ( fieldIndex > 2 ) {             // Account for pad field
                fieldIndex++;
            }

            break;

        case 3:

            StructureDesc = Desc16_print_job_3;
            nativeStructureDesc = Desc32_print_job_3;
            setInfoDesc = Desc16_print_job_3_setinfo;
            nativeSetInfoDesc = Desc32_print_job_3_setinfo;
            if ( fieldIndex != PARMNUM_ALL && fieldIndex < 15 ) {
                switch ( fieldIndex ) {
                case PRJ_NOTIFYNAME_PARMNUM:
                case PRJ_DATATYPE_PARMNUM:
                case PRJ_PARMS_PARMNUM:
                    fieldIndex += 7; break;
                case PRJ_POSITION_PARMNUM:
                    fieldIndex = 4; break;
                case PRJ_COMMENT_PARMNUM:
                case PRJ_DOCUMENT_PARMNUM:
                    fieldIndex -= 3; break;
                case PRJ_PRIORITY_PARMNUM:
                    fieldIndex = 2; break;
                default:
                    fieldIndex = 0xFFFFFFFF;    // Some invalid field
                }
            }

            break;

        }

        status = XsConvertSetInfoBuffer(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     SmbGetUshort( &parameters->BufLen ),
                     (WORD)fieldIndex,
                     FALSE,
                     TRUE,
                     StructureDesc,
                     nativeStructureDesc,
                     setInfoDesc,
                     nativeSetInfoDesc,
                     (LPBYTE *)&buffer,
                     &bytesRequired
                     );

        if ( status != NERR_Success ) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintJobSetInfo: Problem with conversion: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Do the actual local call.
        //

        status = DosPrintJobSetInfo(
                     LocalServerName,
                     FALSE,
                     SmbGetUshort( &parameters->JobId ),
                     level,
                     (LPBYTE)buffer,
                     (WORD)bytesRequired,
                     SmbGetUshort( &parameters->ParmNum )
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintJobSetInfo: DosPrintJobSetInfo failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // No return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // If there is a native 32-bit buffer, free it.
    //

    NetpMemoryFree( buffer );

    return STATUS_SUCCESS;

} // XsNetPrintJobSetInfo


NTSTATUS
XsNetPrintQAdd (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintQAdd.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_Q_ADD parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPTSTR nativeStructureDesc;
    DWORD bufferSize;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintQAdd: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "level " FORMAT_DWORD "\n",
                      Header,
                      parameters,
                      SmbGetUshort( &parameters->Level ) ));
    }

    try {

        //
        // Determine native structure descriptor based on level.
        //

        switch ( SmbGetUshort( &parameters->Level )) {

        case 1:
            StructureDesc = Desc16_printQ_1;
            nativeStructureDesc = (LPTSTR)Desc32_printQ_1;
            break;

        case 3:
            StructureDesc = Desc16_printQ_3;
            nativeStructureDesc = (LPTSTR)Desc32_printQ_3;
            break;

        default:
            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Figure out if there is enough room in the buffer for all the
        // data required. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQAdd: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find out how big a buffer we need to allocate to hold the native
        // 32-bit version of the input data structure.
        //

        bufferSize = XsBytesForConvertedStructure(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         StructureDesc,
                         (LPDESC)nativeStructureDesc,
                         RapToNative,
                         TRUE
                         );

        //
        // Allocate enough memory to hold the converted native buffer.
        //

        buffer = NetpMemoryAllocate( bufferSize );

        if ( buffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQAdd: failed to create buffer" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;

        }

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "XsNetPrintQAdd: buffer of " FORMAT_DWORD " bytes at " FORMAT_LPVOID "\n",
                          bufferSize, buffer ));
        }

        //
        // Convert the buffer from 16-bit to 32-bit.
        //

        stringLocation = (LPBYTE)buffer + bufferSize;
        bytesRequired = 0;

        status = RapConvertSingleEntry(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     buffer,
                     buffer,
                     (LPDESC)nativeStructureDesc,
                     FALSE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     RapToNative
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQAdd: RapConvertSingleEntry failed: "
                              FORMAT_API_STATUS "\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = DosPrintQAdd(
                     NULL,
                     SmbGetUshort( &parameters->Level ),
                     buffer,
                     (WORD)bufferSize
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQAdd: DosPrintQAdd failed: "
                        FORMAT_API_STATUS "\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // There is no real return information for this API.
        //

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( buffer );

    return STATUS_SUCCESS;

} // XsNetPrintQAdd


NTSTATUS
XsNetPrintQContinue (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintQContinue.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_Q_CONTINUE parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters

    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintQContinue: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "name " FORMAT_LPSTR "\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->QueueName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeQueueName,
            (LPSTR)XsSmbGetPointer( &parameters->QueueName )
            );

        CONVERT_QUEUE_NAME( nativeQueueName );

        //
        // Make the local call.
        //

        status = DosPrintQContinue(
                     NULL,
                     nativeQueueName
                     );
cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( !XsPrintApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetPrintQContinue: DosPrintQContinue failed: "
                          FORMAT_API_STATUS "\n", status ));
        }
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    FREE_QUEUE_NAME( nativeQueueName );
    return STATUS_SUCCESS;

} // XsNetPrintQContinue


NTSTATUS
XsNetPrintQDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintQDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_Q_DEL parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintQDel: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", name " FORMAT_LPSTR "\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->QueueName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeQueueName,
            (LPSTR)XsSmbGetPointer( &parameters->QueueName )
            );

        CONVERT_QUEUE_NAME( nativeQueueName );

        //
        // Make the local call.
        //

        status = DosPrintQDel(
                     NULL,
                     nativeQueueName
                     );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( !XsPrintApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetPrintQDel: DosPrintQDel failed: "
                    FORMAT_API_STATUS "\n",
                          status ));
        }
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    FREE_QUEUE_NAME( nativeQueueName );
    return STATUS_SUCCESS;

} // XsNetPrintQDel


NTSTATUS
XsNetPrintQEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintQEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_Q_ENUM parameters = Parameters;
    LPVOID outBuffer= NULL;                 // Native parameters
    DWORD outBufferSize;
    DWORD entriesRead = 0;
    DWORD totalEntries = 0;
    WORD bufferLength;

    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;
    LPDESC nativeAuxStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintQEnum: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "level " FORMAT_DWORD ", buf size " FORMAT_DWORD "\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 5 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // !!! Print API mapping layer presently requires a preallocated buffer.
        //

        bufferLength = SmbGetUshort( &parameters->BufLen );
        outBufferSize = XsNativeBufferSize( bufferLength );
        if ( NetapipBufferAllocate( outBufferSize, &outBuffer ) != NERR_Success
                 ||  outBuffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQEnum: cannot allocate memory\n" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = DosPrintQEnum(
                     NULL,
                     SmbGetUshort( &parameters->Level ),
                     (LPBYTE)outBuffer,
                     (WORD)outBufferSize,
                     (LPWORD)&entriesRead,
                     (LPWORD)&totalEntries
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetPrintQEnum: DosPrintQEnum failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "XsNetPrintQEnum: received " FORMAT_DWORD " entries at " FORMAT_LPVOID "\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        nativeAuxStructureDesc = NULL;
        AuxStructureDesc = NULL;

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_printQ_0;
            StructureDesc = Desc16_printQ_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_printQ_1;
            StructureDesc = Desc16_printQ_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_printQ_2;
            nativeAuxStructureDesc = Desc32_print_job_1;
            StructureDesc = Desc16_printQ_2;
            AuxStructureDesc = Desc16_print_job_1;
            break;

        case 3:

            nativeStructureDesc = Desc32_printQ_3;
            StructureDesc = Desc16_printQ_3;
            break;

        case 4:

            nativeStructureDesc = Desc32_printQ_4;
            nativeAuxStructureDesc = Desc32_print_job_2;
            StructureDesc = Desc16_printQ_4;
            AuxStructureDesc = Desc16_print_job_2;
            break;

        case 5:

            nativeStructureDesc = Desc32_printQ_5;
            StructureDesc = Desc16_printQ_5;
            break;
        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures. Levels 2 and 4 have auxiliary data, other levels call
        // with NULL auxiliary descriptors, so that the normal XsFillEnumBuffer
        // is called.
        //

        XsFillAuxEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            nativeAuxStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (DWORD)bufferLength,
            StructureDesc,
            AuxStructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(PRINT) {
            NetpKdPrint(( "32-bit data at " FORMAT_LPVOID ", 16-bit data at " FORMAT_LPVOID ", " FORMAT_DWORD " BR,"
                          " Entries " FORMAT_DWORD " of " FORMAT_DWORD "\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data. We won't
        // try to pack the ones with the auxiliary structures.
        //

        if ( (entriesFilled < totalEntries) ||
             (bytesRequired > bufferLength) ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            switch ( SmbGetUshort( &parameters->Level )) {

            case 2:
            case 4:

                break;

            default:

                Header->Converter = XsPackReturnData(
                                        (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                        bufferLength,
                                        StructureDesc,
                                        entriesFilled
                                        );
            }
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->Returned, (WORD)entriesFilled );
        SmbPutUshort( &parameters->Total, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetPrintQEnum


NTSTATUS
XsNetPrintQGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintQGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_Q_GET_INFO parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters
    LPVOID outBuffer = NULL;
    DWORD outBufferSize;
    WORD bytesNeeded = 0;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc = NULL;
    LPDESC nativeAuxStructureDesc = NULL;
    LPDESC longDescriptor = NULL;
    LPDESC longNativeDescriptor = NULL;
    DWORD auxDataCount;
    DWORD i;
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintQGetInfo: header at " FORMAT_LPVOID ", "
                      "params at " FORMAT_LPVOID ", level " FORMAT_DWORD "\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        //
        // Level 52 supported for Win95 clients
        //
        if ( XsWordParamOutOfRange( parameters->Level, 0, 5 ) &&
             (DWORD) SmbGetUshort(&parameters->Level) != 52 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeQueueName,
            (LPSTR)XsSmbGetPointer( &parameters->QueueName )
            );

        CONVERT_QUEUE_NAME( nativeQueueName );

        //
        // !!! Print API mapping layer presently requires a preallocated buffer.
        //

        outBufferSize = XsNativeBufferSize( SmbGetUshort( &parameters->BufLen ));
        if ( NetapipBufferAllocate( outBufferSize, &outBuffer ) != NERR_Success
                 || outBuffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQGetInfo: cannot allocate memory\n" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = DosPrintQGetInfo(
                     NULL,
                     nativeQueueName,
                     SmbGetUshort( &parameters->Level ),
                     (LPBYTE)outBuffer,
                     SmbGetUshort( &parameters->BufLen ),
                     &bytesNeeded
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetPrintQGetInfo: DosPrintQGetInfo failed: "
                              FORMAT_API_STATUS "\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_printQ_0;
            StructureDesc = Desc16_printQ_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_printQ_1;
            StructureDesc = Desc16_printQ_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_printQ_2;
            nativeAuxStructureDesc = Desc32_print_job_1;
            StructureDesc = Desc16_printQ_2;
            AuxStructureDesc = Desc16_print_job_1;
            break;

        case 3:

            nativeStructureDesc = Desc32_printQ_3;
            StructureDesc = Desc16_printQ_3;
            break;

        case 4:

            nativeStructureDesc = Desc32_printQ_4;
            nativeAuxStructureDesc = Desc32_print_job_2;
            StructureDesc = Desc16_printQ_4;
            AuxStructureDesc = Desc16_print_job_2;
            break;

        case 5:

            nativeStructureDesc = Desc32_printQ_5;
            StructureDesc = Desc16_printQ_5;
            break;

        case 52:

            nativeStructureDesc = Desc32_printQ_52;
            StructureDesc = Desc16_printQ_52;
            break;

        }

        //
        // Common code between cases 2 and 4 - form long descriptors.
        //

        switch ( SmbGetUshort( &parameters->Level )) {

        case 2:
        case 4:

            //
            // Find the auxiliary data count.
            //

            auxDataCount = RapAuxDataCount(
                               (LPBYTE)outBuffer,
                               nativeStructureDesc,
                               Response,
                               TRUE   // native format
                               );

            longDescriptor = NetpMemoryAllocate(
                                 strlen( StructureDesc )
                                 + strlen( AuxStructureDesc ) *
                                     auxDataCount + 1 );
            longNativeDescriptor = NetpMemoryAllocate(
                                       strlen( nativeStructureDesc )
                                       + strlen( nativeAuxStructureDesc )
                                             * auxDataCount
                                       + 1 );

            if (( longDescriptor == NULL ) || ( longNativeDescriptor == NULL )) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetPrintQGetInfo: failed to allocate memory" ));
                }
                Header->Status = (WORD)NERR_NoRoom;
                goto cleanup;
            }

            strcpy( longDescriptor, StructureDesc );
            strcpy( longNativeDescriptor, nativeStructureDesc );
            for ( i = 0; i < auxDataCount; i++ ) {
                strcat( longDescriptor, AuxStructureDesc );
                strcat( longNativeDescriptor, nativeAuxStructureDesc );
            }

            StructureDesc = longDescriptor;
            nativeStructureDesc = longNativeDescriptor;

            break;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsDosPrintQGetInfo: RapConvertSingleEntry failed: "
                              FORMAT_API_STATUS "\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );
        }

        bytesNeeded = (WORD)bytesRequired;

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Set up the response parameters.
    //

    SmbPutUshort( &parameters->Needed, bytesNeeded );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,            // desc (may be one we created on heap)
        Header->Converter,
        1,
        Header->Status
        );

    (VOID) NetApiBufferFree( outBuffer );
    FREE_QUEUE_NAME( nativeQueueName );
    NetpMemoryFree( longDescriptor );
    NetpMemoryFree( longNativeDescriptor );

    return STATUS_SUCCESS;

} // XsNetPrintQGetInfo


NTSTATUS
XsNetPrintQPause (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintQPause.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_Q_PAUSE parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintQPause: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "name " FORMAT_LPSTR "\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->QueueName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeQueueName,
            (LPSTR)XsSmbGetPointer( &parameters->QueueName )
            );

        CONVERT_QUEUE_NAME( nativeQueueName );

        //
        // Make the local call.
        //

        status = DosPrintQPause(
                     NULL,
                     nativeQueueName
                     );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( !XsPrintApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetPrintQPause: DosPrintQPause failed: "
                    FORMAT_API_STATUS "\n",
                          status ));
        }
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    FREE_QUEUE_NAME( nativeQueueName );
    return STATUS_SUCCESS;

} // XsNetPrintQPause


NTSTATUS
XsNetPrintQPurge (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to DosPrintQPurge.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_Q_PURGE parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PRINT) {
        NetpKdPrint(( "XsNetPrintQPurge: header at " FORMAT_LPVOID ", params at " FORMAT_LPVOID ", "
                      "name " FORMAT_LPSTR "\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->QueueName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeQueueName,
            (LPSTR)XsSmbGetPointer( &parameters->QueueName )
            );

        CONVERT_QUEUE_NAME( nativeQueueName );

        //
        // Make the local call.
        //

        status = DosPrintQPurge(
                     NULL,
                     nativeQueueName
                     );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( !XsPrintApiSuccess( status )) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsNetPrintQPurge: DosPrintQPurge failed: "
                    FORMAT_API_STATUS "\n",
                          status ));
        }
    }

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;


    FREE_QUEUE_NAME( nativeQueueName );
    return STATUS_SUCCESS;

} // XsNetPrintQPurge


NTSTATUS
XsNetPrintQSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetPrintQSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    SPLERR status;

    PXS_DOS_PRINT_Q_SET_INFO parameters = Parameters;
    LPTSTR nativeQueueName = NULL;          // Native parameters
    LPVOID buffer = NULL;
    DWORD bytesRequired;

    DWORD fieldIndex;
    LPDESC setInfoDesc;                     // Conversion variables
    LPDESC nativeSetInfoDesc;
    LPDESC nativeStructureDesc;
    PREPARE_CONVERT_QUEUE_NAME();

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 1
                 && SmbGetUshort( &parameters->Level ) != 3 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeQueueName,
            (LPSTR)XsSmbGetPointer( &parameters->QueueName )
            );

        CONVERT_QUEUE_NAME( nativeQueueName );

        //
        // Determine descriptor strings based on level. Also translate the
        // parmnum value to a field index.
        // !!! - Right now, we don't check for parameters settable in downlevel
        //       that are meaningless in the NT mapping layer.
        //

        fieldIndex = (DWORD)SmbGetUshort( &parameters->ParmNum );

        switch ( SmbGetUshort( &parameters->Level )) {

        case 1:

            StructureDesc = Desc16_printQ_1;
            nativeStructureDesc = Desc32_printQ_1;
            setInfoDesc = Desc16_printQ_1_setinfo;
            nativeSetInfoDesc = Desc32_printQ_1_setinfo;

            if ( fieldIndex > 1 ) {             // Account for pad field
                fieldIndex++;
            }

            break;

        case 3:

            StructureDesc = Desc16_printQ_3;
            nativeStructureDesc = Desc32_printQ_3;
            setInfoDesc = Desc16_printQ_3_setinfo;
            nativeSetInfoDesc = Desc32_printQ_3_setinfo;
            if ( fieldIndex == PRQ_DESTINATIONS_PARMNUM ) {
                fieldIndex = (DWORD)-1;         // No corresponding field
            } else if ( fieldIndex == PRQ_SEPARATOR_PARMNUM
                        || fieldIndex == PRQ_PROCESSOR_PARMNUM ) {
                fieldIndex++;
            }
            break;

        }

        status = XsConvertSetInfoBuffer(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     SmbGetUshort( &parameters->BufLen ),
                     (WORD)fieldIndex,
                     FALSE,
                     TRUE,
                     StructureDesc,
                     nativeStructureDesc,
                     setInfoDesc,
                     nativeSetInfoDesc,
                     (LPBYTE *)&buffer,
                     &bytesRequired
                     );

        if ( status != NERR_Success ) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQSetInfo: Problem with conversion: "
                        FORMAT_API_STATUS "\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Do the actual local call.
        //

        status = DosPrintQSetInfo(
                     NULL,
                     nativeQueueName,
                     SmbGetUshort( &parameters->Level ),
                     (LPBYTE)buffer,
                     (WORD)bytesRequired,
                     SmbGetUshort( &parameters->ParmNum )
                     );

        if ( !XsPrintApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetPrintQSetInfo: DosPrintQSetInfo failed: "
                        FORMAT_API_STATUS "\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // No return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // If there is a native 32-bit buffer, free it.
    //

    NetpMemoryFree( buffer );
    FREE_QUEUE_NAME( nativeQueueName );

    return STATUS_SUCCESS;

} // XsNetPrintQSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apisess.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiSess.c

Abstract:

    This module contains individual API handlers for the NetSession APIs.

    SUPPORTED : NetSessionDel, NetSessionEnum, NetSessionGetInfo.

Author:

    Shanku Niyogi (w-shanku) 5-Feb-1991

Revision History:

--*/

#include "XactSrvP.h"

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_session_info_0 = REM16_session_info_0;
STATIC const LPDESC Desc32_session_info_0 = REM32_session_info_0;
STATIC const LPDESC Desc16_session_info_1 = REM16_session_info_1;
STATIC const LPDESC Desc32_session_info_1 = REM32_session_info_1;
STATIC const LPDESC Desc16_session_info_2 = REM16_session_info_2;
STATIC const LPDESC Desc32_session_info_2 = REM32_session_info_2;
STATIC const LPDESC Desc16_session_info_10 = REM16_session_info_10;
STATIC const LPDESC Desc32_session_info_10 = REM32_session_info_10;


NTSTATUS
XsNetSessionDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetSessionDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SESSION_DEL parameters = Parameters;
    LPTSTR nativeClientName = NULL;          // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;        // Avoid warnings

    IF_DEBUG(SESSION) {
        NetpKdPrint(( "XsNetSessionDel: header at %lx, params at %lx, "
                      "device %s\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->ClientName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeClientName,
            (LPSTR)XsSmbGetPointer( &parameters->ClientName )
            );

        //
        // Make the local call.
        //

        status = NetSessionDel(
                     NULL,
                     nativeClientName,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetSessionDel: NetSessionDel failed: %X\n",
                              status ));
            }
        }

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeClientName );

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;


} // NetSessionDel


NTSTATUS
XsNetSessionEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetSessionEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SESSION_ENUM parameters = Parameters;
    LPVOID outBuffer = NULL;                // Native parameters
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;
    PSESSION_16_INFO_1 struct1;
    PSESSION_16_INFO_2 struct2;
    DWORD i;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SESSION) {
        NetpKdPrint(( "XsNetSessionEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 2 ) &&
             ( SmbGetUshort( &parameters->Level ) != 10 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetSessionEnum(
                     NULL,
                     NULL,
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetSessionEnum: NetSessionEnum failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(SESSION) {
            NetpKdPrint(( "XsNetSessionEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_session_info_0;
            StructureDesc = Desc16_session_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_session_info_1;
            StructureDesc = Desc16_session_info_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_session_info_2;
            StructureDesc = Desc16_session_info_2;
            break;

        case 10:

            nativeStructureDesc = Desc32_session_info_10;
            StructureDesc = Desc16_session_info_10;
            break;

        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            NULL, // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(SESSION) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // Go through all the structures, and fill in the default data.
        //

        struct1 = (PSESSION_16_INFO_1)XsSmbGetPointer( &parameters->Buffer );
        struct2 = (PSESSION_16_INFO_2)struct1;

        switch ( SmbGetUshort( &parameters->Level )) {

        case 1:

            for ( i = 0; i < entriesFilled; i++, struct1++ ) {

                SmbPutUshort( &struct1->sesi1_num_conns, DEF16_ses_num_conns );
                SmbPutUshort( &struct1->sesi1_num_users, DEF16_ses_num_users );
            }

            break;

        case 2:

            for ( i = 0; i < entriesFilled; i++, struct2++ ) {

                SmbPutUshort( &struct2->sesi2_num_conns, DEF16_ses_num_conns );
                SmbPutUshort( &struct2->sesi2_num_users, DEF16_ses_num_users );
            }

            break;

        default:

            break;

        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // NetSessionEnum


NTSTATUS
XsNetSessionGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetSessionGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SESSION_GET_INFO parameters = Parameters;
    LPTSTR nativeClientName = NULL;         // Native parameters
    LPVOID outBuffer = NULL;
    DWORD entriesRead;
    DWORD totalEntries;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;
    PSESSION_16_INFO_2 struct2;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SESSION) {
        NetpKdPrint(( "XsNetSessionGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 2 ) &&
             ( SmbGetUshort( &parameters->Level ) != 10 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeClientName,
            (LPSTR)XsSmbGetPointer( &parameters->ClientName )
            );

        //
        // If this is a null client name, send the appropriate response.
        //

        if ( ( nativeClientName == NULL ) ||
              STRLEN( nativeClientName ) == 0 ) {

            Header->Status = NERR_ClientNameNotFound;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetSessionEnum(
                     NULL,
                     nativeClientName,
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetSessionGetInfo: NetSessionEnum failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        IF_DEBUG(SESSION) {
            NetpKdPrint(( "XsNetSessionGetInfo: Received %ld entries\n",
                          entriesRead ));
        }

        //
        // Use the requested level to determine the format of the 32-bit
        // structure we got back from NetSessionGetInfo.  The format of the
        // 16-bit structure is stored in the transaction block, and we
        // got a pointer to it as a parameter.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_session_info_0;
            StructureDesc = Desc16_session_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_session_info_1;
            StructureDesc = Desc16_session_info_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_session_info_2;
            StructureDesc = Desc16_session_info_2;
            break;

        case 10:

            nativeStructureDesc = Desc32_session_info_10;
            StructureDesc = Desc16_session_info_10;
            break;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "NetSessionGetInfo: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(SESSION) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetSessionGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else {

            //
            // Fill in default data in the structure.
            //

            if (( SmbGetUshort( &parameters->Level ) == 1 ) ||
                    SmbGetUshort( &parameters->Level ) == 2 ) {

                struct2 = (PSESSION_16_INFO_2)XsSmbGetPointer( &parameters->Buffer );

                SmbPutUshort( &struct2->sesi2_num_conns, DEF16_ses_num_conns );
                SmbPutUshort( &struct2->sesi2_num_users, (WORD)entriesRead );

            }

            if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "NetSessionGetInfo: More data available.\n" ));
                }
                Header->Status = ERROR_MORE_DATA;

            } else {

                //
                // Pack the response data.
                //

                Header->Converter = XsPackReturnData(
                                        (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                        SmbGetUshort( &parameters->BufLen ),
                                        StructureDesc,
                                        1
                                        );
            }
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeClientName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // NetSessionGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apipath.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiPath.c

Abstract:

    This module contains individual API handlers for the NetName and
    NetPath APIs.

    SUPPORTED : I_NetNameCanonicalize, I_NetNameCompare, I_NetNameValidate,
                I_NetPathCanonicalize, I_NetPathCompare, I_NetPathType.

Author:

    Shanku Niyogi (w-shanku) 04-Apr-1991
    Jim Waters (t-jamesw) 6-Aug-1991

Revision History:

--*/

#include "XactSrvP.h"

//
// Needed for canonicalization routine prototypes.
//

#include <icanon.h>


NTSTATUS
XsI_NetNameCanonicalize (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetI_NetNameCanonicalize.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_I_NET_NAME_CANONICALIZE parameters = Parameters;
    LPTSTR nativeName = NULL;               // Native parameters
    LPTSTR outBuffer = NULL;
    DWORD outBufLen;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PATH) {
        NetpKdPrint(( "XsI_NetNameCanonicalize: header at %lx, params at %lx\n",
                      Header, parameters ));
    }


    //
    // Translate parameters, check for errors.
    //

    XsConvertTextParameter(
        nativeName,
        (LPSTR)XsSmbGetPointer( &parameters->Name )
        );

    //
    // Allocate local buffer, accounting for possible differences in
    // character size.
    //

    outBufLen = (DWORD)STRING_SPACE_REQD(
                           SmbGetUshort( &parameters->OutbufLen ));

    if (( outBuffer = NetpMemoryAllocate( outBufLen )) == NULL ) {
        status = NERR_NoRoom;
        goto cleanup;
    }

    //
    // Make the local call.
    //

    status = I_NetNameCanonicalize(
        NULL,
        nativeName,
        outBuffer,
        outBufLen,
        (DWORD)SmbGetUshort( &parameters->NameType ),
        (DWORD)SmbGetUlong( &parameters->Flags )
        );

    if ( !XsApiSuccess(status) ) {

        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsI_NetNameCanonicalize: "
                          "NetNameCanonicalize failed: %X\n", status ));
        }
        goto cleanup;
    }

    //
    // Copy return buffer, possibly translating from Unicode.
    //

    NetpCopyTStrToStr( (LPSTR)XsSmbGetPointer( &parameters->Outbuf ), outBuffer );

cleanup:

    NetpMemoryFree( nativeName );
    NetpMemoryFree( outBuffer );

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsI_NetNameCanonicalize


NTSTATUS
XsI_NetNameCompare (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to I_NetNameCompare.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_I_NET_NAME_COMPARE parameters = Parameters;
    LPTSTR nativeName1 = NULL;              // Native parameters
    LPTSTR nativeName2 = NULL;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PATH) {
        NetpKdPrint(( "XsI_NetNameCompare: header at %lx, params at %lx\n",
                      Header, parameters ));
    }

    //
    // Translate parameters, check for errors.
    //

    XsConvertTextParameter(
        nativeName1,
        (LPSTR)XsSmbGetPointer( &parameters->Name1 )
        );

    XsConvertTextParameter(
        nativeName2,
        (LPSTR)XsSmbGetPointer( &parameters->Name2 )
        );

    //
    // Make the local call.
    //

    status = I_NetNameCompare(
        NULL,
        nativeName1,
        nativeName2,
        (DWORD)SmbGetUshort( &parameters->NameType ),
        (DWORD)SmbGetUlong( &parameters->Flags )
        );

    if ( !XsApiSuccess(status) ) {

        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsI_NetNameCompare: NetNameCompare failed: "
                          "%X\n", status));
        }
    }

cleanup:

    NetpMemoryFree( nativeName1 );
    NetpMemoryFree( nativeName2 );

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsI_NetNameCompare


NTSTATUS
XsI_NetNameValidate (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to I_NetNameValidate.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_I_NET_NAME_VALIDATE parameters = Parameters;
    LPTSTR nativeName = NULL;               // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PATH) {
        NetpKdPrint(( "XsI_NetNameValidate: header at %lx, params at %lx\n",
                      Header, parameters ));
    }

    try {

        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeName,
            (LPSTR)XsSmbGetPointer( &parameters->Name )
            );

        //
        // Make the local call.
        //

        status = I_NetNameValidate(
            NULL,
            nativeName,
            (DWORD)SmbGetUshort( &parameters->NameType ),
            (DWORD)SmbGetUlong( &parameters->Flags )
            );

        if ( !XsApiSuccess(status) ) {

            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsI_NetPathType: NetPathType failed: %X\n", status));
            }
        }

    cleanup:
        Header->Status = (WORD)status;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if (nativeName != NULL) {
        NetpMemoryFree( nativeName );
    }

    return STATUS_SUCCESS;

} // XsI_NetNameValidate


NTSTATUS
XsI_NetPathCanonicalize (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to I_NetPathCanonicalize.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_I_NET_PATH_CANONICALIZE parameters = Parameters;
    LPTSTR nativePathName = NULL;           // Native parameters
    LPTSTR outBuffer = NULL;
    DWORD outBufLen;
    LPTSTR nativePrefix = NULL;
    DWORD pathType = 0;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PATH) {
        NetpKdPrint(( "XsI_NetPathCanonicalize: header at %lx, params at %lx\n",
                      Header, parameters ));
    }

    //
    // Translate parameters, check for errors.
    //

    XsConvertTextParameter(
        nativePathName,
        (LPSTR)XsSmbGetPointer( &parameters->PathName )
        );

    XsConvertTextParameter(
        nativePrefix,
        (LPSTR)XsSmbGetPointer( &parameters->Prefix )
        );

    //
    // Get a copy of the input path type.
    //

    pathType = SmbGetUlong( &parameters->PathType );

    //
    // Allocate local buffer, accounting for possible differences in
    // character size.
    //

    outBufLen = (DWORD)STRING_SPACE_REQD(
                           SmbGetUshort( &parameters->OutbufLen ));

    if (( outBuffer = (LPTSTR)NetpMemoryAllocate( outBufLen )) == NULL ) {
        status = NERR_NoRoom;
        goto cleanup;
    }

    //
    // Make the local call.
    //

    status = I_NetPathCanonicalize(
        NULL,
        nativePathName,
        outBuffer,
        outBufLen,
        nativePrefix,
        &pathType,
        (DWORD)SmbGetUlong( &parameters->Flags )
        );

    if ( !XsApiSuccess(status) ) {

        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsI_NetPathCanonicalize: "
                          "NetPathCanonicalize failed: %X\n", status));
        }
        goto cleanup;
    }

    //
    // Copy return buffer, possibly translating from Unicode.
    //

    NetpCopyTStrToStr( (LPSTR)XsSmbGetPointer( &parameters->Outbuf ), outBuffer );

cleanup:

    //
    // Fill return parameter.
    //

    SmbPutUlong( &parameters->PathTypeOut, pathType );

    Header->Status = (WORD)status;

    NetpMemoryFree( nativePathName );
    NetpMemoryFree( nativePrefix );
    NetpMemoryFree( outBuffer );

    return STATUS_SUCCESS;

} // XsI_NetPathCanonicalize


NTSTATUS
XsI_NetPathCompare (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to I_NetPathCompare.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_I_NET_PATH_COMPARE parameters = Parameters;
    LPTSTR nativePathName1 = NULL;          // Native parameters
    LPTSTR nativePathName2 = NULL;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PATH) {
        NetpKdPrint(( "XsI_NetPathCompare: header at %lx, params at %lx\n",
                      Header, parameters ));
    }

    //
    // Translate parameters, check for errors.
    //

    XsConvertTextParameter(
        nativePathName1,
        (LPSTR)XsSmbGetPointer( &parameters->PathName1 )
        );

    XsConvertTextParameter(
        nativePathName2,
        (LPSTR)XsSmbGetPointer( &parameters->PathName2 )
        );

    //
    // Make the local call.
    //

    status = I_NetPathCompare(
        NULL,
        nativePathName1,
        nativePathName2,
        (DWORD)SmbGetUlong( &parameters->PathType ),
        (DWORD)SmbGetUlong( &parameters->Flags )
        );

    if ( !XsApiSuccess(status) ) {

        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsI_NetPathCompare: NetPathCompare failed: "
                          "%X\n", status));
        }
    }

cleanup:

    NetpMemoryFree( nativePathName1 );
    NetpMemoryFree( nativePathName2 );

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsI_NetPathCompare


NTSTATUS
XsI_NetPathType (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to I_NetPathType.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_I_NET_PATH_TYPE parameters = Parameters;
    LPTSTR nativePathName = NULL;           // Native parameters
    DWORD pathType;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(PATH) {
        NetpKdPrint(( "XsI_NetPathType: header at %lx, params at %lx\n",
                      Header, parameters ));
    }

    //
    // Translate parameters, check for errors.
    //

    XsConvertTextParameter(
        nativePathName,
        (LPSTR)XsSmbGetPointer( &parameters->PathName )
        );

    //
    // Make the local call.
    //

    status = I_NetPathType(
        NULL,
        nativePathName,
        &pathType,
        (DWORD)SmbGetUlong( &parameters->Flags )
        );

    if ( !XsApiSuccess(status) ) {

        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsI_NetPathType: NetPathType failed: %X\n", status));
        }
    }

    //
    // Fill in return values.
    //

    SmbPutUlong( &parameters->PathType, pathType );
    Header->Status = (WORD)status;

cleanup:

    NetpMemoryFree( nativePathName );

    return STATUS_SUCCESS;

} // XsI_NetPathType


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apigroup.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    ApiGroup.c

Abstract:

    This module contains individual API handlers for the NetGroup APIs.

    SUPPORTED : NetGroupAdd, NetGroupAddUser, NetGroupDel, NetGroupDelUser,
                NetGroupEnum, NetGroupGetInfo, NetGroupGetUsers,
                NetGroupSetInfo, NetGroupSetUsers.

Author:

    Shanku Niyogi (w-shanku)    13-Mar-1991

Revision History:

--*/

//
// Group APIs are UNICODE only.
//

#ifndef UNICODE
#define UNICODE
#endif

#include "xactsrvp.h"

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_group_info_0 = REM16_group_info_0;
STATIC const LPDESC Desc32_group_info_0 = REM32_group_info_0;
STATIC const LPDESC Desc16_group_info_1 = REM16_group_info_1;
STATIC const LPDESC Desc32_group_info_1 = REM32_group_info_1;
STATIC const LPDESC Desc16_group_info_1_setinfo = REM16_group_info_1_setinfo;
STATIC const LPDESC Desc32_group_info_1_setinfo = REM32_group_info_1_setinfo;
STATIC const LPDESC Desc16_group_users_info_0 = REM16_group_users_info_0;
STATIC const LPDESC Desc32_group_users_info_0 = REM32_group_users_info_0;
STATIC const LPDESC Desc16_group_users_info_0_set
                        = REM16_group_users_info_0_set;
STATIC const LPDESC Desc32_group_users_info_0_set
                        = REM32_group_users_info_0_set;


NTSTATUS
XsNetGroupAdd (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupAdd.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GROUP_ADD parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    DWORD bufferSize;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(GROUP) {
        NetpKdPrint(( "XsNetGroupAdd: header at %lx, params at %lx, "
                      "level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Use the requested level to determine the format of the destination
        // 32-bit structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:
            StructureDesc = Desc16_group_info_0;
            nativeStructureDesc = Desc32_group_info_0;
            break;

        case 1:
            StructureDesc = Desc16_group_info_1;
            nativeStructureDesc = Desc32_group_info_1;
            break;

        default:
            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;

        }

        //
        // Figure out if there is enough room in the buffer for all the
        // data required. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupAdd: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find out how big a buffer we need to allocate to hold the native
        // 32-bit version of the input data structure.
        //

        bufferSize = XsBytesForConvertedStructure(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         StructureDesc,
                         nativeStructureDesc,
                         RapToNative,
                         TRUE
                         );

        //
        // Allocate enough memory to hold the converted native buffer.
        //

        buffer = NetpMemoryAllocate( bufferSize );

        if ( buffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupAdd: failed to create buffer" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;

        }

        IF_DEBUG(GROUP) {
            NetpKdPrint(( "XsNetGroupAdd: buffer of %ld bytes at %lx\n",
                          bufferSize, buffer ));
        }

        //
        // Convert the buffer from 16-bit to 32-bit.
        //

        stringLocation = (LPBYTE)buffer + bufferSize;
        bytesRequired = 0;

        status = RapConvertSingleEntry(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     buffer,
                     buffer,
                     nativeStructureDesc,
                     FALSE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     RapToNative
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupAdd: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetGroupAdd(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     buffer,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupAdd: NetGroupAdd failed: %X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // There is no real return information for this API.
        //

cleanup:
        ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( buffer );

    return STATUS_SUCCESS;

} // XsNetGroupAdd


NTSTATUS
XsNetGroupAddUser (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupAddUser.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GROUP_ADD_USER parameters = Parameters;
    LPTSTR nativeGroupName = NULL;          // Native parameters
    LPTSTR nativeUserName = NULL;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeGroupName,
            (LPSTR)XsSmbGetPointer( &parameters->GroupName )
            );
        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        //
        // Make the local call.
        //

        status = NetGroupAddUser(
                     NULL,
                     nativeGroupName,
                     nativeUserName
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupAddUser: NetGroupAddUser failed: %X\n",
                              status ));
            }
        }

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeGroupName );
    NetpMemoryFree( nativeUserName );

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetGroupAddUser


NTSTATUS
XsNetGroupDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GROUP_DEL parameters = Parameters;
    LPTSTR nativeGroupName = NULL;          // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(GROUP) {
        NetpKdPrint(( "XsNetGroupDel: header at %lx, params at %lx, name %s\n",
                      Header, parameters,
                      SmbGetUlong( &parameters->GroupName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeGroupName,
            (LPSTR)XsSmbGetPointer( &parameters->GroupName )
            );

        //
        // Make the local call.
        //

        status = NetGroupDel(
                     NULL,
                     nativeGroupName
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupDel: NetGroupDel failed: %X\n", status ));
            }
        }

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeGroupName );

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetGroupDel


NTSTATUS
XsNetGroupDelUser (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupDelUser.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GROUP_DEL_USER parameters = Parameters;
    LPTSTR nativeGroupName = NULL;          // Native parameters
    LPTSTR nativeUserName = NULL;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeGroupName,
            (LPSTR)XsSmbGetPointer( &parameters->GroupName )
            );
        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        //
        // Make the local call.
        //

        status = NetGroupDelUser(
                     NULL,
                     nativeGroupName,
                     nativeUserName
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupDelUser: NetGroupDelUser failed: %X\n",
                              status ));
            }
        }

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeGroupName );
    NetpMemoryFree( nativeUserName );

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetGroupDelUser


NTSTATUS
XsNetGroupEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GROUP_ENUM parameters = Parameters;
    LPVOID outBuffer= NULL;                 // Native parameters
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                    // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(GROUP) {
        NetpKdPrint(( "XsNetGroupEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetGroupEnum(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetGroupEnum: NetGroupEnum failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(GROUP) {
            NetpKdPrint(( "XsNetGroupEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_group_info_0;
            StructureDesc = Desc16_group_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_group_info_1;
            StructureDesc = Desc16_group_info_1;
            break;

        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(GROUP) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetGroupEnum


NTSTATUS
XsNetGroupGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GROUP_GET_INFO parameters = Parameters;
    LPTSTR nativeGroupName = NULL;          // Native parameters
    LPVOID outBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(GROUP) {
        NetpKdPrint(( "XsNetGroupGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeGroupName,
            (LPSTR)XsSmbGetPointer( &parameters->GroupName )
            );

        //
        // Make the local call.
        //

        status = NetGroupGetInfo(
                     NULL,
                     nativeGroupName,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetGroupGetInfo: NetGroupGetInfo failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_group_info_0;
            StructureDesc = Desc16_group_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_group_info_1;
            StructureDesc = Desc16_group_info_1;
            break;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupGetInfo: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(GROUP) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupGetInfo: Buffer too small %ld s.b. %ld.\n",
                    SmbGetUshort( &parameters->BufLen ),
                    RapStructureSize(
                        StructureDesc,
                        Response,
                        FALSE ) ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "NetGroupGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );
        }


        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeGroupName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetGroupGetInfo


NTSTATUS
XsNetGroupGetUsers (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupGetUsers.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;
    PXS_NET_GROUP_GET_USERS parameters = Parameters;
    LPTSTR nativeGroupName = NULL;          // Native parameters
    LPVOID outBuffer= NULL;
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bytesRequired = 0;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(GROUP) {
        NetpKdPrint(( "XsNetGroupGetUsers: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 0 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeGroupName,
            (LPSTR)XsSmbGetPointer( &parameters->GroupName )
            );

        //
        // Make the local call.
        //

        status = NetGroupGetUsers(
                     NULL,
                     nativeGroupName,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetGroupGetUsers: NetGroupGetUsers failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(GROUP) {
            NetpKdPrint(( "XsNetGroupGetUsers: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Do the conversion from 32- to 16-bit data.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            Desc32_group_users_info_0,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            Desc16_group_users_info_0,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(GROUP) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If there is no room for one fixed structure, return NERR_BufTooSmall.
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. GROUP_USERS_INFO_0 structures don't
        // need to be packed, because they have no variable data.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 Desc16_group_users_info_0,
                 FALSE  // not in native format
                 )) {

            Header->Status = NERR_BufTooSmall;

        } else if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeGroupName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        Desc16_group_users_info_0,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetGroupGetUsers


NTSTATUS
XsNetGroupSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GROUP_SET_INFO parameters = Parameters;
    LPTSTR nativeGroupName = NULL;          // Native parameters
    LPVOID buffer = NULL;

    WORD fieldIndex;                        // Conversion variables
    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 1 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeGroupName,
            (LPSTR)XsSmbGetPointer( &parameters->GroupName )
            );

        //
        // Translate parmnum to a field number.
        //

        fieldIndex = SmbGetUshort( &parameters->ParmNum );
        fieldIndex = ( fieldIndex == PARMNUM_ALL ) ?
                         PARMNUM_ALL : fieldIndex + 1;

        status = XsConvertSetInfoBuffer(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     SmbGetUshort( &parameters->BufLen ),
                     fieldIndex,
                     TRUE,
                     TRUE,
                     Desc16_group_info_1,
                     Desc32_group_info_1,
                     Desc16_group_info_1_setinfo,
                     Desc32_group_info_1_setinfo,
                     (LPBYTE *)&buffer,
                     NULL
                     );

        if ( status != NERR_Success ) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupSetInfo: Problem with conversion: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Do the actual local call.
        //

        status = NetGroupSetInfo(
                     NULL,
                     nativeGroupName,
                     XsLevelFromParmNum( SmbGetUshort( &parameters->Level ),
                                             SmbGetUshort( &parameters->ParmNum )),
                     buffer,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupSetInfo: NetGroupSetInfo failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // No return information for this API.
        //

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // If there is a native 32-bit buffer, free it.
    //

    NetpMemoryFree( buffer );
    NetpMemoryFree( nativeGroupName );

    return STATUS_SUCCESS;

} // XsNetGroupSetInfo


NTSTATUS
XsNetGroupSetUsers (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGroupSetUsers.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GROUP_SET_USERS parameters = Parameters;
    LPTSTR nativeGroupName = NULL;          // Native parameters
    LPBYTE actualBuffer = NULL;
    DWORD userCount;

    LPBYTE stringLocation = NULL;           // Conversion variables
    LPVOID buffer = NULL;
    DWORD bytesRequired = 0;
    LPDESC longDescriptor = NULL;
    LPDESC longNativeDescriptor = NULL;
    DWORD bufferSize;
    DWORD i;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(GROUP) {
        NetpKdPrint(( "XsNetGroupSetUsers: header at %lx, params at %lx,"
                      "level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 0 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        StructureDesc = Desc16_group_users_info_0_set;
        AuxStructureDesc = Desc16_group_users_info_0;

        XsConvertTextParameter(
            nativeGroupName,
            (LPSTR)XsSmbGetPointer( &parameters->GroupName )
            );

        //
        // Use the count of group_users_info_0 structures to form a long
        // descriptor string which can be used to do all the conversion
        // in one pass.
        //

        userCount = (DWORD)SmbGetUshort( &parameters->Entries );

        longDescriptor = NetpMemoryAllocate(
                             strlen( StructureDesc )
                             + strlen( AuxStructureDesc ) * userCount
                             + 1 );
        longNativeDescriptor = NetpMemoryAllocate(
                                   strlen( Desc32_group_users_info_0_set )
                                   + strlen( Desc32_group_users_info_0 ) * userCount
                                   + 1 );

        if (( longDescriptor == NULL ) || ( longNativeDescriptor == NULL )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupSetUsers: failed to allocate memory" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        strcpy( longDescriptor, StructureDesc );
        strcpy( longNativeDescriptor, Desc32_group_users_info_0_set );
        for ( i = 0; i < userCount; i++ ) {
            strcat( longDescriptor, AuxStructureDesc );
            strcat( longNativeDescriptor, Desc32_group_users_info_0 );
        }

        //
        // Figure out if there is enough room in the buffer for all this
        // data. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 longDescriptor,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupSetUsers: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find out how big a buffer we need to allocate to hold the native
        // 32-bit version of the input data structure.
        //

        bufferSize = XsBytesForConvertedStructure(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         longDescriptor,
                         longNativeDescriptor,
                         RapToNative,
                         TRUE
                         );

        //
        // Allocate enough memory to hold the converted native buffer.
        //

        buffer = NetpMemoryAllocate( bufferSize );

        if ( buffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupSetUsers: failed to create buffer" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        IF_DEBUG(GROUP) {
            NetpKdPrint(( "XsNetGroupSetUsers: buffer of %ld bytes at %lx\n",
                          bufferSize, buffer ));
        }

        //
        // Convert the buffer from 16-bit to 32-bit.
        //

        stringLocation = (LPBYTE)buffer + bufferSize;
        bytesRequired = 0;

        status = RapConvertSingleEntry(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     longDescriptor,
                     TRUE,
                     buffer,
                     buffer,
                     longNativeDescriptor,
                     FALSE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     RapToNative
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupSetUsers: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Check if we got all the entries. If not, we'll quit.
        //

        if ( RapAuxDataCount( buffer, Desc32_group_users_info_0_set, Both, TRUE )
                 != userCount ) {

             Header->Status = NERR_BufTooSmall;
             goto cleanup;
        }

        //
        // If there are no entries, there's no data. Otherwise, the data comes
        // after an initial header structure.
        //

        if ( userCount > 0 ) {

            actualBuffer = (LPBYTE)buffer + RapStructureSize(
                                                Desc32_group_users_info_0_set,
                                                Both,
                                                TRUE
                                                );

        } else {

            actualBuffer = NULL;
        }

        //
        // Make the local call.
        //

        status = NetGroupSetUsers(
                     NULL,
                     nativeGroupName,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     actualBuffer,
                     userCount
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGroupSetUsers: NetGroupSetUsers failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // There is no real return information for this API.
        //

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeGroupName );
    NetpMemoryFree( buffer );
    NetpMemoryFree( longDescriptor );
    NetpMemoryFree( longNativeDescriptor );

    return STATUS_SUCCESS;

} // XsNetGroupSetUsers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apisrv.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    ApiSrv.c

Abstract:

    This module contains individual API handlers for the NetServer APIs.

    SUPPORTED : NetServerDiskEnum, NetServerEnum2, NetServerGetInfo,
                NetServerSetInfo.

    SEE ALSO : NetServerAuthenticate, NetServerPasswordSet,
               NetServerReqChallenge - in ApiLogon.c.

Author:

    Shanku Niyogi (w-shanku) 25-Feb-1991

Revision History:

--*/

#include "XactSrvP.h"
#include <lmbrowsr.h>       // Definition of I_BrowserServerEnum


//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_server_info_0 = REM16_server_info_0;
STATIC const LPDESC Desc32_server_info_0 = REM32_server_info_0;
STATIC const LPDESC Desc16_server_info_1 = REM16_server_info_1;
STATIC const LPDESC Desc32_server_info_1 = REM32_server_info_1;
STATIC const LPDESC Desc16_server_info_2 = REM16_server_info_2;
STATIC const LPDESC Desc32_server_info_2 = REM32_server_info_2;
STATIC const LPDESC Desc16_server_info_3 = REM16_server_info_3;
STATIC const LPDESC Desc32_server_info_3 = REM32_server_info_3;


NTSTATUS
XsNetServerDiskEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServerDiskEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SERVER_DISK_ENUM parameters = Parameters;
    LPBYTE outBuffer = NULL;                // Native parameters
    DWORD entriesRead;
    DWORD totalEntries = 0;
    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bufferLength;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 0 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;

        }

        //
        // Make the local call.
        //

        bufferLength = (DWORD)SmbGetUshort( &parameters->BufLen );

        status = NetServerDiskEnum(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( bufferLength ),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServer: NetServerDiskEnum failed: "
                              "%X\n", status ));
            }

            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // Calculate how many entries will fit in 16-bit buffer;
        //

        if ( bufferLength > 0 ) {
            DWORD elementSize;

            elementSize = RapStructureSize( StructureDesc, Response, FALSE );

            if (elementSize != 0) {
                entriesFilled = ( bufferLength - 1 ) / elementSize;
            }
        }

        if ( entriesFilled < entriesRead ) {

            status = ERROR_MORE_DATA;
        } else {

            entriesFilled = entriesRead;
            status = NERR_Success;
        }

        //
        // Copy native buffer to 16-bit buffer, converting Unicode to Ansi
        // if necessary.
        //

        if ( bufferLength > 0 ) {

            DWORD i;
            LPTSTR entryIn = (LPTSTR)outBuffer;
            LPSTR entryOut = (LPSTR)XsSmbGetPointer( &parameters->Buffer );

            for ( i = 0; i < entriesFilled; i++ ) {

                NetpCopyWStrToStrDBCS( entryOut, entryIn );
                entryOut += ( strlen( entryOut ) + 1 );
                entryIn += ( STRLEN( entryIn ) + 1 );

            }
            strcpy( entryOut, "" );
        }

        Header->Status = (WORD)status;

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Put return data into fields.
    //

    SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
    SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

    return STATUS_SUCCESS;

} // XsNetServerDiskEnum


NTSTATUS
XsNetServerEnum2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServerEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

    Transport - The name of the transport provided to the API.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status = NERR_Success;

    PXS_NET_SERVER_ENUM_2 parameters = Parameters;
    LPTSTR nativeDomain = NULL;             // Native parameters
    LPVOID outBuffer= NULL;
    DWORD entriesRead;
    DWORD totalEntries;
    LPTSTR clientTransportName = NULL;
    LPTSTR clientName = NULL;

    DWORD entriesFilled = 0;                    // Conversion variables

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SERVER) {
        NetpKdPrint(( "XsNetServerEnum2: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeDomain,
            (LPSTR)XsSmbGetPointer( &parameters->Domain )
            );

        clientTransportName = Header->ClientTransportName;

        clientName = Header->ClientMachineName;

        //
        // Get the actual server information from the local 32-bit call. The
        // native level is 100 or 101.
        //

        if (clientTransportName == NULL) {
            status = NetServerEnum(
                            NULL,
                            100 + (DWORD)SmbGetUshort( &parameters->Level ),
                            (LPBYTE *)&outBuffer,
                            XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                            &entriesRead,
                            &totalEntries,
                            SmbGetUlong( &parameters->ServerType ),
                            nativeDomain,
                            NULL
                            );

            if ( !XsApiSuccess( status ) ) {
                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetServerEnum2: NetServerEnum failed: %X\n",
                                  status ));
                }
                Header->Status = (WORD)status;
                goto cleanup;
            }

            Header->Status = XsConvertServerEnumBuffer(
                                  outBuffer,
                                  entriesRead,
                                  &totalEntries,
                                  SmbGetUshort( &parameters->Level ),
                                  (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                  SmbGetUshort( &parameters->BufLen ),
                                  &entriesFilled,
                                  &Header->Converter);

        } else {

            Header->Status = I_BrowserServerEnumForXactsrv(
                     clientTransportName,
                     clientName,

                     100 + SmbGetUshort( &parameters->Level ),
                     SmbGetUshort( &parameters->Level ),

                     (PVOID)XsSmbGetPointer( &parameters->Buffer ),
                     SmbGetUshort( &parameters->BufLen ),
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen ) ),

                     &entriesFilled,
                     &totalEntries,

                     SmbGetUlong( &parameters->ServerType ),
                     nativeDomain,
                     NULL,

                     &Header->Converter

                     );


            if (!XsApiSuccess( Header->Status )) {
                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetServerEnum2: I_BrowserServerEnum failed: %d\n", Header->Status));
                }
                goto cleanup;
            }
        }

        if ( entriesFilled == 0 ) {
            SmbPutUshort( &parameters->BufLen, 0 );
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( outBuffer != NULL ) {
        NetApiBufferFree( outBuffer );
    }
    NetpMemoryFree( nativeDomain );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        SmbGetUshort( &parameters->Level ) == 0 ?
                    Desc16_server_info_0 :
                    Desc16_server_info_1,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetServerEnum2


NTSTATUS
XsNetServerEnum3 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServerEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

    Transport - The name of the transport provided to the API.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status = NERR_Success;

    PXS_NET_SERVER_ENUM_3 parameters = Parameters;
    LPTSTR nativeDomain = NULL;             // Native parameters
    LPTSTR nativeFirstNameToReturn = NULL;  // Native parameters
    LPVOID outBuffer= NULL;
    DWORD entriesRead;
    DWORD totalEntries;
    LPTSTR clientTransportName = NULL;
    LPTSTR clientName = NULL;

    DWORD entriesFilled = 0;                    // Conversion variables

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SERVER) {
        NetpKdPrint(( "XsNetServerEnum3: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeDomain,
            (LPSTR)XsSmbGetPointer( &parameters->Domain )
            );

        XsConvertTextParameter(
            nativeFirstNameToReturn,
            (LPSTR)XsSmbGetPointer( &parameters->FirstNameToReturn )
            );

        clientTransportName = Header->ClientTransportName;

        clientName = Header->ClientMachineName;

        //
        // Get the actual server information from the local 32-bit call. The
        // native level is 100 or 101.
        //

        if (clientTransportName == NULL) {
            status = NetServerEnumEx(
                            NULL,
                            100 + (DWORD)SmbGetUshort( &parameters->Level ),
                            (LPBYTE *)&outBuffer,
                            XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                            &entriesRead,
                            &totalEntries,
                            SmbGetUlong( &parameters->ServerType ),
                            nativeDomain,
                            nativeFirstNameToReturn
                            );

            if ( !XsApiSuccess( status ) ) {
                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetServerEnum3: NetServerEnum failed: %X\n",
                                  status ));
                }
                Header->Status = (WORD)status;
                goto cleanup;
            }

            Header->Status = XsConvertServerEnumBuffer(
                                  outBuffer,
                                  entriesRead,
                                  &totalEntries,
                                  SmbGetUshort( &parameters->Level ),
                                  (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                  SmbGetUshort( &parameters->BufLen ),
                                  &entriesFilled,
                                  &Header->Converter);

        } else {

            Header->Status = I_BrowserServerEnumForXactsrv(
                     clientTransportName,
                     clientName,

                     100 + SmbGetUshort( &parameters->Level ),
                     SmbGetUshort( &parameters->Level ),

                     (PVOID)XsSmbGetPointer( &parameters->Buffer ),
                     SmbGetUshort( &parameters->BufLen ),
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen ) ),

                     &entriesFilled,
                     &totalEntries,

                     SmbGetUlong( &parameters->ServerType ),
                     nativeDomain,
                     nativeFirstNameToReturn,

                     &Header->Converter

                     );


            if (!XsApiSuccess( Header->Status )) {
                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetServerEnum3: I_BrowserServerEnum failed: %d\n", Header->Status));
                }
                goto cleanup;
            }
        }

        if ( entriesFilled == 0 ) {
            SmbPutUshort( &parameters->BufLen, 0 );
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( outBuffer != NULL ) {
        NetApiBufferFree( outBuffer );
    }
    NetpMemoryFree( nativeDomain );
    NetpMemoryFree( nativeFirstNameToReturn );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        SmbGetUshort( &parameters->Level ) == 0 ?
                    Desc16_server_info_0 :
                    Desc16_server_info_1,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetServerEnum3


USHORT
XsConvertServerEnumBuffer(
    IN LPVOID ServerEnumBuffer,
    IN DWORD EntriesRead,
    IN OUT PDWORD TotalEntries,
    IN USHORT Level,
    IN LPBYTE ClientBuffer,
    IN USHORT BufferLength,
    OUT PDWORD EntriesFilled,
    OUT PUSHORT Converter
    )
/*++

Routine Description:

    This routine converts an NT server info array into a down level RAP
    server info buffer.

Arguments:

    IN LPVOID ServerEnumBuffer - Buffer with NT server info.
    IN DWORD EntriesRead -       Number of entries in buffer.
    IN OUT PDWORD TotalEntries - Total Number of entries.
    IN USHORT Level - Downlevel information Level (0 or 1).
    IN LPBYTE ClientBuffer - Pointer to 16 bit client side buffer.
    IN USHORT BufferLength - Size of client buffer.
    OUT PDWORD EntriesFilled - Number of entries converted into client buffer.
    OUT PUSHORT Converter - Converter used by client side to convert back.

Return Value:

    USHORT - NERR_Success or reason for failure (16 bit DOS error).

--*/

{
    USHORT status = NERR_Success;
    DWORD invalidEntries;
    LPDESC nativeStructureDesc;
    DWORD bytesRequired = 0;
    PCHAR StructureDesc;

    IF_DEBUG(SERVER) {
        NetpKdPrint(( "XsConvertServerEnumBuffer: received %ld entries at %lx\n",
                      EntriesRead, ServerEnumBuffer ));
    }

    //
    // Use the requested level to determine the format of the
    // data structure.
    //

    switch ( Level ) {

    case 0:

        StructureDesc = Desc16_server_info_0;
        nativeStructureDesc = Desc32_server_info_0;
        break;

    case 1:

        StructureDesc = Desc16_server_info_1;
        nativeStructureDesc = Desc32_server_info_1;
        break;

    }

    //
    // Do the actual conversion from the 32-bit structures to 16-bit
    // structures.
    //

    XsFillEnumBuffer(
        ServerEnumBuffer,
        EntriesRead,
        nativeStructureDesc,
        ClientBuffer,
        ClientBuffer,
        BufferLength,
        StructureDesc,
        NULL,  // verify function
        &bytesRequired,
        EntriesFilled,
        &invalidEntries
        );

    IF_DEBUG(SERVER) {
        NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                      " Entries %ld of %ld\n",
                      ServerEnumBuffer, ClientBuffer ,
                      bytesRequired, *EntriesFilled, *TotalEntries ));
    }

    //
    // If there are any invalid entries, subtract this from the
    // number of total entries to avoid the case where the client
    // keeps bugging us for more data.
    //

    if ( invalidEntries > 0) {
        (*TotalEntries) -= invalidEntries;
#if DBG
        IF_DEBUG(API_ERRORS) {
            NetpKdPrint(( "XsNetServerEnum: %d invalid entries removed."
                          " Total entries now %d, entries filled %d.\n",
                          invalidEntries, *TotalEntries, *EntriesFilled ));
        }
#endif
    }

    //
    // If all the entries could not be filled, return ERROR_MORE_DATA,
    // The data needs to be packed so that we don't send too much
    // useless data.
    //

    if ( (*EntriesFilled < *TotalEntries) ||
         (bytesRequired > BufferLength) ) {

        status = ERROR_MORE_DATA;
    }

    *Converter = XsPackReturnData(
                            ClientBuffer,
                            BufferLength,
                            StructureDesc,
                            *EntriesFilled
                            );


    return status;
}   //  XsConvertServerEnumBuffer



NTSTATUS
XsNetServerGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServerGetInfo. Since NT only provides
    levels 100-102, this routine manually fills in default values for other
    fields. Because of this, the handling in this procedure is different
    from other Xs...GetInfo handlers.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SERVER_GET_INFO parameters = Parameters;
    DWORD localLevel;                       // Native parameters
    PSERVER_INFO_102 nativeStruct = NULL;
    PSERVER_INFO_502 secondaryNativeStruct = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    DWORD sizeOfFixedStructure;
    LPDESC nativeStructureDesc;
    PSERVER_16_INFO_3 returnStruct;
    BOOLEAN bufferTooSmall = FALSE;
    LPWSTR ServerName = NULL;
    UCHAR serverNameBuf[ 2 + NETBIOS_NAME_LEN + 1 ];
    PUCHAR p;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SERVER) {
        NetpKdPrint(( "XsNetServerGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 3 ) ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Use the 16-bit level number to determine the NT level number and the
        // native descriptor string.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_server_info_0;
            StructureDesc = Desc16_server_info_0;
            localLevel = 100;
            break;

        case 1:

            nativeStructureDesc = Desc32_server_info_1;
            StructureDesc = Desc16_server_info_1;
            localLevel = 101;
            break;

        case 2:

            nativeStructureDesc = Desc32_server_info_2;
            StructureDesc = Desc16_server_info_2;
            localLevel = 102;
            break;

        case 3:

            nativeStructureDesc = Desc32_server_info_3;
            StructureDesc = Desc16_server_info_3;
            localLevel = 102;
            break;

        }

        //
        // If the buffer is not big enough, we have to continue doing the
        // Rap Conversion so that we can return the right buffer size to
        // the caller.
        //

        sizeOfFixedStructure = RapStructureSize( StructureDesc,
                                                  Response,
                                                  FALSE );

        if ( SmbGetUshort( &parameters->BufLen ) < sizeOfFixedStructure ) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServerGetInfo: Buffer too small.\n" ));
            }

            bufferTooSmall = TRUE;
        }

        serverNameBuf[0] = serverNameBuf[1] = '\\';
        memcpy( &serverNameBuf[2], Header->ServerName, NETBIOS_NAME_LEN );
        for( p = &serverNameBuf[ NETBIOS_NAME_LEN + 1 ]; p > serverNameBuf && *p == ' '; p-- )
            ;
        *(p+1) = '\0';

        ServerName = XsDupStrToWStr( serverNameBuf );

        if( ServerName == NULL ) {
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        //
        // Do the actual local call.
        //
        status = NetServerGetInfo(
                     ServerName,
                     localLevel,
                     (LPBYTE *)&nativeStruct
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetServerGetInfo: NetServerGetInfo failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // For levels 2 and 3 (native level 102), additional data is
        // required from native level 502. Do this call.
        //

        if ( localLevel == 102 ) {

            status = NetServerGetInfo(
                         ServerName,
                         502,
                         (LPBYTE *)&secondaryNativeStruct
                         );

            if ( !XsApiSuccess( status )) {
                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetServerGetInfo: NetServerGetInfo failed: "
                                  "%X\n", status ));
                }
                Header->Status = (WORD)status;
                goto cleanup;

            }
        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. For levels 0 and 1, there is no additional work
        // involved after this step, so ConvertSingleEntry can store the
        // variable data in the structure. This is indicated by passing
        // the end of the entire buffer in stringLocation. For levels 2 and 3,
        // the manual filling scheme requires that variable data not be entered
        // at this stage, so stringLocation is set to the end of the fixed
        // structure.
        //

        stringLocation = (LPBYTE)XsSmbGetPointer( &parameters->Buffer );

        if ( !bufferTooSmall ) {
            stringLocation += ( localLevel == 102 ) ?
                                        sizeOfFixedStructure:
                                        SmbGetUshort( &parameters->BufLen );
        }

        status = RapConvertSingleEntry(
                     (LPBYTE)nativeStruct,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServerGetInfo: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // For levels 2 and 3, the number of bytes required is, in fact, more than
        // that returned by ConvertSingleEntry. We also need space for the
        // string defaults.
        //

        if ( localLevel == 102 ) {

            //
            // The number we get from rap includes some string lengths.
            // We only need the fixed length since we are manually adding
            // those ourselves.
            //

            bytesRequired = sizeOfFixedStructure;
        }

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 3:

            bytesRequired += NetpUnicodeToDBCSLen( DEF16_sv_autopath ) + 1;

        case 2:

            bytesRequired += ( NetpUnicodeToDBCSLen( DEF16_sv_alerts )
                                   + NetpUnicodeToDBCSLen( DEF16_sv_srvheuristics )
                                   + NetpUnicodeToDBCSLen( nativeStruct->sv102_comment )
                                   + NetpUnicodeToDBCSLen( nativeStruct->sv102_userpath )
                                   + 4 );
        }

        //
        // We don't have room even for the fixed data, abort.
        //

        if ( bufferTooSmall ) {

            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // For levels 2 and 3, fill in the default values in the fixed structure
        // manually.
        //

        returnStruct = (PSERVER_16_INFO_3)XsSmbGetPointer( &parameters->Buffer );

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 3:

            SmbPutUlong( &returnStruct->sv3_auditedevents, DEF16_sv_auditedevents );
            SmbPutUshort( &returnStruct->sv3_autoprofile, DEF16_sv_autoprofile );

        case 2:

            SmbPutUlong( &returnStruct->sv3_ulist_mtime, DEF16_sv_ulist_mtime );
            SmbPutUlong( &returnStruct->sv3_alist_mtime, DEF16_sv_alist_mtime );
            SmbPutUlong( &returnStruct->sv3_glist_mtime, DEF16_sv_glist_mtime );
            SmbPutUshort( &returnStruct->sv3_security, DEF16_sv_security );
            SmbPutUshort( &returnStruct->sv3_auditing, DEF16_sv_auditing );
            SmbPutUshort( &returnStruct->sv3_numadmin, (USHORT)DEF16_sv_numadmin );
            SmbPutUshort( &returnStruct->sv3_lanmask, DEF16_sv_lanmask );
            NetpCopyTStrToStr( returnStruct->sv3_guestacct, DEF16_sv_guestacct );
            SmbPutUshort( &returnStruct->sv3_chdevs, DEF16_sv_chdevs );
            SmbPutUshort( &returnStruct->sv3_chdevq, DEF16_sv_chdevq );
            SmbPutUshort( &returnStruct->sv3_chdevjobs, DEF16_sv_chdevjobs );
            SmbPutUshort( &returnStruct->sv3_connections, DEF16_sv_connections );
            SmbPutUshort( &returnStruct->sv3_shares, DEF16_sv_shares );
            SmbPutUshort( &returnStruct->sv3_openfiles, DEF16_sv_openfiles );
            SmbPutUshort( &returnStruct->sv3_sessopens,
                (WORD)secondaryNativeStruct->sv502_sessopens );
            SmbPutUshort( &returnStruct->sv3_sessvcs,
                (WORD)secondaryNativeStruct->sv502_sessvcs );
            SmbPutUshort( &returnStruct->sv3_sessreqs, DEF16_sv_sessreqs );
            SmbPutUshort( &returnStruct->sv3_opensearch,
                (WORD)secondaryNativeStruct->sv502_opensearch );
            SmbPutUshort( &returnStruct->sv3_activelocks, DEF16_sv_activelocks );
            SmbPutUshort( &returnStruct->sv3_numreqbuf, DEF16_sv_numreqbuf );
            SmbPutUshort( &returnStruct->sv3_sizreqbuf,
                (WORD)secondaryNativeStruct->sv502_sizreqbuf );
            SmbPutUshort( &returnStruct->sv3_numbigbuf, DEF16_sv_numbigbuf );
            SmbPutUshort( &returnStruct->sv3_numfiletasks, DEF16_sv_numfiletasks );
            SmbPutUshort( &returnStruct->sv3_alertsched, DEF16_sv_alertsched );
            SmbPutUshort( &returnStruct->sv3_erroralert, DEF16_sv_erroralert );
            SmbPutUshort( &returnStruct->sv3_logonalert, DEF16_sv_logonalert );
            SmbPutUshort( &returnStruct->sv3_accessalert, DEF16_sv_accessalert );
            SmbPutUshort( &returnStruct->sv3_diskalert, DEF16_sv_diskalert );
            SmbPutUshort( &returnStruct->sv3_netioalert, DEF16_sv_netioalert );
            SmbPutUshort( &returnStruct->sv3_maxauditsz, DEF16_sv_maxauditsz );
        }

        //
        // Now check if there is room for the variable data. If there isn't,
        // set return status and quit. This is done here to prevent code
        // below from overwriting the buffer.
        //

        if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "NetServerGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;
            goto cleanup;
        }

        //
        // For levels 2 and 3, fill in the variable data manually. The variable
        // data is filled in immediately following the fixed structures. For
        // other levels, pack the response data as normal.

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                             + sizeOfFixedStructure );

        switch ( SmbGetUshort( &parameters->Level )) {

        case 3:

            XsAddVarString(
                stringLocation,
                DEF16_sv_autopath,
                &returnStruct->sv3_autopath,
                returnStruct
                );

        case 2:

            XsAddVarString(
                stringLocation,
                DEF16_sv_srvheuristics,
                &returnStruct->sv3_srvheuristics,
                returnStruct
                );

            XsAddVarString(
                stringLocation,
                nativeStruct->sv102_userpath,
                &returnStruct->sv3_userpath,
                returnStruct
                );

            XsAddVarString(
                stringLocation,
                DEF16_sv_alerts,
                &returnStruct->sv3_alerts,
                returnStruct
                );

            XsAddVarString(
                stringLocation,
                nativeStruct->sv102_comment,
                &returnStruct->sv3_comment,
                returnStruct
                );

            break;

        default:

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );

            break;

        }

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if( ServerName != NULL ) {
        NetpMemoryFree( ServerName );
    }

    //
    // Set up the response parameters.
    //

    SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

    NetApiBufferFree( nativeStruct );
    NetApiBufferFree( secondaryNativeStruct );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetServerGetInfo


NTSTATUS
XsNetServerSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServerSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{

    NET_API_STATUS status;

    PXS_NET_SERVER_SET_INFO parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;
    DWORD data;
    DWORD bufferSize;
    DWORD level;
    LPTSTR comment = NULL;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 1, 3 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Processing of this API depends on the value of the ParmNum
        // parameter.
        //

        switch ( SmbGetUshort( &parameters->ParmNum )) {

        case PARMNUM_ALL:

            //
            // PARMNUM_ALL.
            //
            // The structure descriptor given is OK; determine native descriptor
            // (and expected minimum buffer length) from level. The buffer then
            // needs to be converted into a native 32-bit buffer.
            //

            switch( SmbGetUshort( &parameters->Level )) {

            case 1:

                StructureDesc = Desc16_server_info_1;
                nativeStructureDesc = Desc32_server_info_1;
                break;

            case 2:

                StructureDesc = Desc16_server_info_2;
                nativeStructureDesc = Desc32_server_info_2;
                break;

            case 3:

                StructureDesc = Desc16_server_info_3;
                nativeStructureDesc = Desc32_server_info_3;
                break;

            }

            if ( !XsCheckBufferSize(
                      SmbGetUshort( &parameters->BufLen ),
                      StructureDesc,
                      FALSE // native format
                      )) {

                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            //
            // Find out how big a 32-bit data buffer we need.
            //

            bufferSize = XsBytesForConvertedStructure(
                             (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                             StructureDesc,
                             nativeStructureDesc,
                             RapToNative,
                             TRUE
                             );

            //
            // Allocate enough memory to hold the converted native buffer.
            //

            buffer = NetpMemoryAllocate( bufferSize );

            if ( buffer == NULL ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetServerSetInfo: failed to create buffer" ));
                }
                Header->Status = NERR_NoRoom;
                goto cleanup;

            }

            IF_DEBUG(SERVER) {
                NetpKdPrint(( "XsNetServerSetInfo: buffer of %ld bytes at %lx\n",
                              bufferSize, buffer ));
            }

            //
            // Convert 16-bit data into 32-bit data and store it in the native
            // buffer.
            //

            stringLocation = (LPBYTE)buffer + bufferSize;
            bytesRequired = 0;

            status = RapConvertSingleEntry(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         StructureDesc,
                         TRUE,
                         buffer,
                         buffer,
                         nativeStructureDesc,
                         FALSE,
                         &stringLocation,
                         &bytesRequired,
                         Response,
                         RapToNative
                         );

            if ( status != NERR_Success ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetServerSetInfo: RapConvertSingleEntry "
                                  "failed: %X\n", status ));
                }

                Header->Status = NERR_InternalError;
                goto cleanup;
            }

            break;

        case SV_COMMENT_PARMNUM:

            //
            // SV_COMMENT_PARMNUM.
            //
            // The structure descriptor given is meaningless. The data is actually
            // a null terminated string, and can be passed to the native routine
            // immediately. Being a string, it must be at least one character long.
            //

            if ( !XsCheckBufferSize(
                      SmbGetUshort( &parameters->BufLen ),
                      "B",
                      FALSE  // not in native format
                      )) {

                Header->Status= NERR_BufTooSmall;
                goto cleanup;
            }

            XsConvertUnicodeTextParameter(
                                    comment,
                                    (LPSTR)XsSmbGetPointer( &parameters->Buffer )
                                    );

            if ( comment == NULL ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetServerSetInfo: failed to create buffer" ));
                }
                Header->Status = NERR_NoRoom;
                goto cleanup;
            }

            buffer = &comment;

            break;

        case SV_ALERTS_PARMNUM:
        case SV_ALERTSCHED_PARMNUM:
        case SV_ERRORALERT_PARMNUM:
        case SV_LOGONALERT_PARMNUM:

            goto cleanup;

        case SV_ACCESSALERT_PARMNUM:
        case SV_DISKALERT_PARMNUM:
        case SV_NETIOALERT_PARMNUM:
        case SV_MAXAUDITSZ_PARMNUM:

            //
            // SV_ALERTS_PARMNUM, SV_ALERTSCHED_PARMNUM, SV_ERRORALERT_PARMNUM,
            // SV_LOGONALERT_PARMNUM, SV_ACCESSALERT_PARMNUM, SV_DISKALERT_PARMNUM,
            // SV_NETIOALERT_PARMNUM, or SV_MAXAUDITSZ_PARMNUM.
            //
            // These parameters are not supported in NT, so just return an OK.
            //

            goto cleanup;

        case SV_DISC_PARMNUM:
        case SV_HIDDEN_PARMNUM:
        case SV_ANNOUNCE_PARMNUM:
        case SV_ANNDELTA_PARMNUM:

            //
            // SV_DISC_PARMNUM, SV_HIDDEN_PARMNUM, SV_ANNOUNCE_PARMNUM, or
            // SV_ANNDELTA_PARMNUM.
            //
            // The structure descriptor given is meaningless; the data is a word
            // to be converted into a 32-bit DWORD. The length of data must be 2.
            //

            if ( !XsCheckBufferSize(
                      SmbGetUshort( &parameters->BufLen ),
                      "W",
                      FALSE   // not in native format
                      )) {

                Header->Status= NERR_BufTooSmall;
                goto cleanup;
            }

            data = (DWORD)SmbGetUshort(
                                  (LPWORD)XsSmbGetPointer( &parameters->Buffer )
                                  );
            buffer = &data;

            break;

        default:

            Header->Status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

        //
        // Do the actual local call.
        //

        level = SmbGetUshort( &parameters->ParmNum );
        if ( level != 0 ) {
            level = level + PARMNUM_BASE_INFOLEVEL;
        } else {
            level = 100 + SmbGetUshort( &parameters->Level );
            if ( level == 103 ) {
                level = 102;
            }
        }

        status = NetServerSetInfo(
                     NULL,
                     level,
                     buffer,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServerSetInfo: NetServerSetInfo failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // No return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // If there is a native 32-bit buffer, free it.
    //

    if ( SmbGetUshort( &parameters->ParmNum ) == PARMNUM_ALL ) {
        NetpMemoryFree( buffer );
    } else if ( SmbGetUshort( &parameters->ParmNum ) == SV_COMMENT_PARMNUM ) {
        NetpMemoryFree( comment );
    }

    return STATUS_SUCCESS;

} // XsNetServerSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apishare.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    ApiShare.c

Abstract:

    This module contains individual API handlers for the NetShare APIs.

    SUPPORTED : NetShareAdd, NetShareCheck, NetShareDel, NetShareEnum,
                NetShareGetInfo, NetShareSetInfo.

Author:

    David Treadwell (davidtr)    07-Jan-1991
    Shanku Niyogi (w-shanku)

Revision History:

--*/

#include "XactSrvP.h"

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_share_info_0 = REM16_share_info_0;
STATIC const LPDESC Desc32_share_info_0 = REM32_share_info_0;
STATIC const LPDESC Desc16_share_info_1 = REM16_share_info_1;
STATIC const LPDESC Desc32_share_info_1 = REM32_share_info_1;
STATIC const LPDESC Desc16_share_info_1_setinfo = REM16_share_info_1_setinfo;
STATIC const LPDESC Desc32_share_info_1_setinfo = REM32_share_info_1_setinfo;
STATIC const LPDESC Desc16_share_info_2 = REM16_share_info_2;
STATIC const LPDESC Desc32_share_info_2 = REM32_share_info_2;
STATIC const LPDESC Desc16_share_info_2_setinfo = REM16_share_info_2_setinfo;
STATIC const LPDESC Desc32_share_info_2_setinfo = REM32_share_info_2_setinfo;


NTSTATUS
XsNetShareAdd (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetShareAdd.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SHARE_ADD parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    DWORD bufferSize;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SHARE) {
        NetpKdPrint(( "XsNetShareAdd: header at %lx, params at %lx, "
                      "level %ld\n",
                      Header,
                      parameters,
                      SmbGetUshort( &parameters->Level ) ));
    }

    try {
            //
            // Check for errors.
            //

            if ( SmbGetUshort( &parameters->Level ) != 2 ) {

                Header->Status = ERROR_INVALID_LEVEL;
                goto cleanup;
            }

            StructureDesc = Desc16_share_info_2;

            //
            // Figure out if there is enough room in the buffer for all the
            // data required. If not, return NERR_BufTooSmall.
            //

            if ( !XsCheckBufferSize(
                     SmbGetUshort( &parameters->BufLen ),
                     StructureDesc,
                     FALSE  // not in native format
                     )) {

                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetShareAdd: Buffer too small.\n" ));
                }
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            //
            // Find out how big a buffer we need to allocate to hold the native
            // 32-bit version of the input data structure.
            //

            bufferSize = XsBytesForConvertedStructure(
                             (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                             StructureDesc,
                             Desc32_share_info_2,
                             RapToNative,
                             TRUE
                             );

            //
            // Allocate enough memory to hold the converted native buffer.
            //

            buffer = NetpMemoryAllocate( bufferSize );

            if ( buffer == NULL ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetShareAdd: failed to create buffer" ));
                }
                Header->Status = NERR_NoRoom;
                goto cleanup;

            }

            IF_DEBUG(SHARE) {
                NetpKdPrint(( "XsNetShareAdd: buffer of %ld bytes at %lx\n",
                              bufferSize, buffer ));
            }

            //
            // Convert the buffer from 16-bit to 32-bit.
            //

            stringLocation = (LPBYTE)buffer + bufferSize;
            bytesRequired = 0;

            status = RapConvertSingleEntry(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         StructureDesc,
                         TRUE,
                         buffer,
                         buffer,
                         Desc32_share_info_2,
                         FALSE,
                         &stringLocation,
                         &bytesRequired,
                         Response,
                         RapToNative
                         );


            if ( status != NERR_Success ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetShareAdd: RapConvertSingleEntry failed: "
                                  "%X\n", status ));
                }

                Header->Status = NERR_InternalError;
                goto cleanup;
            }

            //
            // Make the local call.
            //

            status = NetShareAdd(
                         NULL,
                         (DWORD)SmbGetUshort( &parameters->Level ),
                         buffer,
                         NULL
                         );

            if ( !XsApiSuccess( status )) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetShareAdd: NetShareAdd failed: %X\n", status ));
                }

                if ( status == ERROR_DIRECTORY ) {
                    Header->Status = NERR_UnknownDevDir;
                } else {
                    Header->Status = (WORD)status;
                }
                goto cleanup;
            }

            //
            // There is no real return information for this API.
            //

cleanup:
        ;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
        }

        NetpMemoryFree( buffer );

        return STATUS_SUCCESS;

} // XsNetShareAdd


NTSTATUS
XsNetShareCheck (
        API_HANDLER_PARAMETERS
        )

/*++

Routine Description:

        This routine handles a call to NetShareCheck.

Arguments:

        API_HANDLER_PARAMETERS - information about the API call. See
            XsTypes.h for details.

Return Value:

        NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
        NET_API_STATUS status;

        PXS_NET_SHARE_CHECK parameters = Parameters;
        LPTSTR nativeDeviceName = NULL;         // Native parameters
        DWORD shareType;

        API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

        try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeDeviceName,
            (LPSTR)XsSmbGetPointer( &parameters->DeviceName )
            );

        //
        // Do the local call.
        //

        status = NetShareCheck(
                     NULL,
                     nativeDeviceName,
                     &shareType
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetShareCheck: NetShareCheck failed: "
                              "%X\n", status ));
            }
        }

        //
        // Put type into return field.
        //

        SmbPutUshort( &parameters->Type, (WORD)shareType );

        Header->Status = (WORD)status;

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeDeviceName );
    return STATUS_SUCCESS;

} // XsNetShareCheck


NTSTATUS
XsNetShareDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetShareDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SHARE_DEL parameters = Parameters;
    LPTSTR nativeNetName = NULL;            // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SHARE) {
        NetpKdPrint(( "XsNetShareDel: header at %lx, params at %lx, name %s\n",
                      Header, parameters, SmbGetUlong( &parameters->NetName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeNetName,
            (LPSTR)XsSmbGetPointer( &parameters->NetName )
            );

        //
        // Make the local call.
        //

        status = NetShareDel(
                     NULL,
                     nativeNetName,
                     (DWORD)SmbGetUshort( &parameters->Reserved )
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetShareDel: NetShareDel failed: %X\n", status ));
            }
        }

        //
        // Nothing to return.
        //

        Header->Status = (WORD)status;

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeNetName );
    return STATUS_SUCCESS;

} // XsNetShareDel


NTSTATUS
XsNetShareEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetShareEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SHARE_ENUM parameters = Parameters;
    LPVOID outBuffer= NULL;                 // Native parameters
    DWORD entriesRead = 0;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                // Conversion variables
    DWORD bytesRequired = 0;
    DWORD invalidEntries = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SHARE) {
        NetpKdPrint(( "XsNetShareEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 2 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetShareEnum(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetShareEnum: NetShareEnum failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(SHARE) {
            NetpKdPrint(( "XsNetShareEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_share_info_0;
            StructureDesc = Desc16_share_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_share_info_1;
            StructureDesc = Desc16_share_info_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_share_info_2;
            StructureDesc = Desc16_share_info_2;
            break;
        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            &invalidEntries
            );

        IF_DEBUG(SHARE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if ( entriesFilled + invalidEntries < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetShareEnum


NTSTATUS
XsNetShareGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetShareGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SHARE_GET_INFO parameters = Parameters;
    LPTSTR nativeNetName = NULL;            // Native parameters
    LPVOID outBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SHARE) {
        NetpKdPrint(( "XsNetShareGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 2 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeNetName,
            (LPSTR)XsSmbGetPointer( &parameters->NetName )
            );

        //
        // Make the local call.
        //

        status = NetShareGetInfo(
                     NULL,
                     nativeNetName,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetShareGetInfo: NetShareGetInfo failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_share_info_0;
            StructureDesc = Desc16_share_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_share_info_1;
            StructureDesc = Desc16_share_info_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_share_info_2;
            StructureDesc = Desc16_share_info_2;
            break;
        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetShareGetInfo: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(SHARE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetShareGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetShareGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );
        }


        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeNetName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetShareGetInfo


NTSTATUS
XsNetShareSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetShareSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SHARE_SET_INFO parameters = Parameters;
    LPTSTR nativeNetName = NULL;            // Native parameters
    LPVOID buffer = NULL;
    DWORD level;

    LPDESC setInfoDesc;                     // Conversion variables
    LPDESC nativeSetInfoDesc;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeNetName,
            (LPSTR)XsSmbGetPointer( &parameters->NetName )
            );

        //
        // Determine descriptor strings based on level.
        //

        switch ( SmbGetUshort( &parameters->Level )) {

        case 1:

            StructureDesc = Desc16_share_info_1;
            nativeStructureDesc = Desc32_share_info_1;
            setInfoDesc = Desc16_share_info_1_setinfo;
            nativeSetInfoDesc = Desc32_share_info_1_setinfo;

            break;

        case 2:

            StructureDesc = Desc16_share_info_2;
            nativeStructureDesc = Desc32_share_info_2;
            setInfoDesc = Desc16_share_info_2_setinfo;
            nativeSetInfoDesc = Desc32_share_info_2_setinfo;

            break;

        default:

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        status = XsConvertSetInfoBuffer(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     SmbGetUshort( &parameters->BufLen ),
                     SmbGetUshort( &parameters->ParmNum ),
                     FALSE,
                     TRUE,
                     StructureDesc,
                     nativeStructureDesc,
                     setInfoDesc,
                     nativeSetInfoDesc,
                     (LPBYTE *)&buffer,
                     NULL
                     );

        if ( status != NERR_Success ) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetShareSetInfo: Problem with conversion: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Do the actual local call.
        //

        level = SmbGetUshort( &parameters->ParmNum );
        if ( level != 0 ) {
            level = level + PARMNUM_BASE_INFOLEVEL;
        } else {
            level = SmbGetUshort( &parameters->Level );
        }

        status = NetShareSetInfo(
                     NULL,
                     nativeNetName,
                     level,
                     (LPBYTE)buffer,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetShareSetInfo: NetShareSetInfo failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // No return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // If there is a native 32-bit buffer, free it.
    //

    NetpMemoryFree( buffer );
    NetpMemoryFree( nativeNetName );

    return STATUS_SUCCESS;

} // XsNetShareSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apilogon.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiLogon.c

Abstract:

    This module contains individual API handlers for the NetLogon APIs.

    SUPPORTED : NetGetDCName, NetLogonEnum, NetServerAuthenticate,
                NetServerPasswordSet, NetServerReqChallenge,
                NetWkstaUserLogoff, NetWkstaUserLogon.

    SEE ALSO : NetAccountDeltas, NetAccountSync - in ApiAcct.c.

Author:

    Shanku Niyogi (w-shanku) 04-Apr-1991

Revision History:

--*/

//
// Logon APIs are Unicode only.
//

#ifndef UNICODE
#define UNICODE
#endif

#include "xactsrvp.h"
#include <netlibnt.h>

#include <crypt.h>     // must be included before <logonmsv.h>
#include <ntsam.h>     // must be included before <logonmsv.h>
#include <logonmsv.h>  // must be included before <ssi.h>
#include <ssi.h>       // I_NetAccountDeltas and I_NetAccountSync prototypes

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_user_logon_info_0 = REM16_user_logon_info_0;
STATIC const LPDESC Desc32_user_logon_info_0 = REM32_user_logon_info_0;
STATIC const LPDESC Desc16_user_logon_info_1 = REM16_user_logon_info_1;
STATIC const LPDESC Desc32_user_logon_info_1 = REM32_user_logon_info_1;
STATIC const LPDESC Desc16_user_logon_info_2 = REM16_user_logon_info_2;
STATIC const LPDESC Desc32_user_logon_info_2 = REM32_user_logon_info_2;
STATIC const LPDESC Desc16_user_logoff_info_1 = REM16_user_logoff_info_1;
STATIC const LPDESC Desc32_user_logoff_info_1 = REM32_user_logoff_info_1;


NTSTATUS
XsNetGetDCName (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGetDCName.

Arguments:

    API_HANDLER_PARAMETERS - Information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_GET_DC_NAME parameters = Parameters;
    LPTSTR nativeDomain = NULL;             // Native parameters
    LPTSTR dcName = NULL;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeDomain,
            (LPSTR)XsSmbGetPointer( &parameters->Domain )
            );

        //
        // Make the local call.
        //

        status = NetGetDCName(
                     NULL,
                     nativeDomain,
                     (LPBYTE *)&dcName
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetGetDCName: NetGetDCName failed: %X\n",
                              status ));
            }
            goto cleanup;
        }

        //
        // Put string into buffer. Convert from Unicode if necessary.
        //

        if ( (DWORD)SmbGetUshort( &parameters->BufLen ) <= NetpUnicodeToDBCSLen( dcName )) {

            status = NERR_BufTooSmall;

        } else {

            NetpCopyWStrToStrDBCS( (LPSTR)XsSmbGetPointer( &parameters->Buffer ), dcName );

        }


        IF_DEBUG(LOGON) {
            NetpKdPrint(( "Name is %ws\n", dcName ));
        }

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }


    //
    // Set return data count.
    //

    if ( status == NERR_Success ) {
        SmbPutUshort( &parameters->BufLen, (USHORT)( STRLEN( dcName ) + 1 ));
    } else {
        SmbPutUshort( &parameters->BufLen, 0 );
    }


    Header->Status = (WORD)status;
    NetpMemoryFree( nativeDomain );
    NetApiBufferFree( dcName );

    return STATUS_SUCCESS;

} // XsNetGetDCName


NTSTATUS
XsNetLogonEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetLogonEnum.

Arguments:

    API_HANDLER_PARAMETERS - Information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_LOGON_ENUM parameters = Parameters;
    LPVOID outBuffer= NULL;
    DWORD entriesRead = 0;
    DWORD totalEntries = 0;

    DWORD entriesFilled = 0;
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;

    IF_DEBUG(LOGON) {
        NetpKdPrint(( "XsNetLogonEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if (( SmbGetUshort( &parameters->Level ) != 0 )
            && ( SmbGetUshort( &parameters->Level ) != 2 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

#ifdef LOGON_ENUM_SUPPORTED
        status = NetLogonEnum(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );
#else // LOGON_ENUM_SUPPORTED
    status = NERR_InvalidAPI;
#endif // LOGON_ENUM_SUPPORTED

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetLogonEnum: NetLogonEnum failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(LOGON) {
            NetpKdPrint(( "XsNetLogonEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_user_logon_info_0;
            StructureDesc = Desc16_user_logon_info_0;
            break;

        case 2:

            nativeStructureDesc = Desc32_user_logon_info_2;
            StructureDesc = Desc16_user_logon_info_2;
            break;
        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(LOGON) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetLogonEnum


NTSTATUS
XsNetServerAuthenticate (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServerAuthenticate.

Arguments:

    API_HANDLER_PARAMETERS - Information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    PXS_NET_SERVER_AUTHENTICATE parameters = Parameters;
    NET_API_STATUS status;                  // Native parameters
    LPTSTR nativeRequestor = NULL;
    NETLOGON_CREDENTIAL inCredential = {0};
    NETLOGON_CREDENTIAL outCredential = {0};
    WCHAR AccountName[MAX_PATH+1];

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeRequestor,
            (LPSTR)XsSmbGetPointer( &parameters->Requestor )
            );

        //
        // Copy the source credential, and zero out the destination
        // credential.
        //

        RtlCopyMemory(
                &inCredential,
                (PVOID)XsSmbGetPointer( &parameters->Caller ),
                sizeof(NETLOGON_CREDENTIAL)
                );

        RtlZeroMemory(
                &outCredential,
                sizeof(NETLOGON_CREDENTIAL)
                );

        //
        // Build the account name.
        //

        NetpNCopyTStrToWStr( AccountName, nativeRequestor, MAX_PATH );

        //
        // Make the local call.
        //

        status = NetpNtStatusToApiStatus(
                     I_NetServerAuthenticate(
                         NULL,
                         AccountName,
                         UasServerSecureChannel,
                         nativeRequestor,
                         &inCredential,
                         &outCredential
                         ));

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServerAuthenticate: I_NetServerAuthenticate "
                              "failed: %X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

cleanup:

        //
        // Set the return credential.
        //

        RtlCopyMemory(
                parameters->Primary,
                &outCredential,
                sizeof(NETLOGON_CREDENTIAL)
                );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeRequestor );

    return STATUS_SUCCESS;

} // XsNetServerAuthenticate


NTSTATUS
XsNetServerPasswordSet (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGetDCName.

Arguments:

    API_HANDLER_PARAMETERS - Information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    PXS_NET_SERVER_PASSWORD_SET parameters = Parameters;
    NET_API_STATUS status;                  // Native parameters
    LPTSTR nativeRequestor = NULL;
    NETLOGON_AUTHENTICATOR authIn = {0};
    NETLOGON_AUTHENTICATOR authOut = {0};
    ENCRYPTED_LM_OWF_PASSWORD password;
    WCHAR AccountName[MAX_PATH+1];

    LPBYTE structure = NULL;                // Conversion variables

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeRequestor,
            (LPSTR)XsSmbGetPointer( &parameters->Requestor )
            );

        //
        // Copy the source authenticator and password, and zero out the
        // destination authenticator.
        //

        structure = (LPBYTE)XsSmbGetPointer( &parameters->Authenticator );
        RtlCopyMemory(
                &authIn.Credential,
                structure,
                sizeof(NETLOGON_CREDENTIAL)
                );
        structure += sizeof(NETLOGON_CREDENTIAL);
        authIn.timestamp = SmbGetUlong( structure );

        RtlCopyMemory(
                &password,
                parameters->Password,
                sizeof(ENCRYPTED_LM_OWF_PASSWORD)
                );

        RtlZeroMemory(
                &authOut,
                sizeof(NETLOGON_CREDENTIAL)
                );


        //
        // Build the account name.
        //
        if( STRLEN( nativeRequestor ) >= MAX_PATH )
        {
            Header->Status = NERR_PasswordTooShort;
            goto cleanup;
        }

        // Make sure its NULL terminated
        AccountName[MAX_PATH] = L'\0';
        NetpNCopyTStrToWStr( AccountName, nativeRequestor, MAX_PATH );

        //
        // Make the local call.
        //

        status = NetpNtStatusToApiStatus(
                     I_NetServerPasswordSet(
                         NULL,
                         AccountName,
                         UasServerSecureChannel,
                         nativeRequestor,
                         &authIn,
                         &authOut,
                         &password
                         ));

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServerPasswordSet: "
                              "I_NetServerPasswordSet failed: %X\n",
                              status ));
            }

            //
            // !!! When protocol level is available in the header information,
            //     we can check it. Right now, we ignore this code.
            //
            // For clients older than LanMan 2.1, return a different error code.
            // LANMAN 2.1 Protocol Level is 6.
            //

#if 0
            if ( status == NERR_TimeDiffAtDC && Header->ProtocolLevel < 6 ) {
                status = NERR_SyncRequired;
            }
#endif

            Header->Status = (WORD)status;
            goto cleanup;
        }

cleanup:

        //
        // Fill in 16 bit return structures.
        //

        structure = parameters->RetAuth;
        RtlCopyMemory(
                structure,
                &authOut.Credential,
                sizeof(NETLOGON_CREDENTIAL)
                );
        structure += sizeof(NETLOGON_CREDENTIAL);
        SmbPutUlong( (LPDWORD)structure, authOut.timestamp );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeRequestor );

    return STATUS_SUCCESS;

} // XsNetServerPasswordSet


NTSTATUS
XsNetServerReqChallenge (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetGetDCName.

Arguments:

    API_HANDLER_PARAMETERS - Information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    PXS_NET_SERVER_REQ_CHALLENGE parameters = Parameters;
    NET_API_STATUS status;                  // Native parameters
    LPTSTR nativeRequestor = NULL;
    NETLOGON_CREDENTIAL inChallenge = {0};
    NETLOGON_CREDENTIAL outChallenge = {0};

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeRequestor,
            (LPSTR)XsSmbGetPointer( &parameters->Requestor )
            );

        //
        // Copy the source challenge, and zero out the destination
        // challenge.
        //

        RtlCopyMemory(
                &inChallenge,
                (PVOID)XsSmbGetPointer( &parameters->Caller ),
                sizeof(NETLOGON_CREDENTIAL)
                );

        RtlZeroMemory(
                &outChallenge,
                sizeof(NETLOGON_CREDENTIAL)
                );


        //
        // Make the local call.
        //

        status = NetpNtStatusToApiStatus(
                     I_NetServerReqChallenge(
                         NULL,
                         nativeRequestor,
                         &inChallenge,
                         &outChallenge
                         ));

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServerReqChallenge: "
                              "I_NetServerReqChallenge failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

cleanup:

        //
        // Set the return credential.
        //

        RtlCopyMemory(
                parameters->Primary,
                &outChallenge,
                sizeof(NETLOGON_CREDENTIAL)
                );
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeRequestor );

    return STATUS_SUCCESS;

} // XsNetServerReqChallenge


NTSTATUS
XsNetWkstaUserLogoff (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This temporary routine just returns STATUS_NOT_IMPLEMENTED.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_WKSTA_USER_LOGOFF parameters = Parameters;
    LPWSTR machineName = NULL;              // Native parameters
    LPWSTR userName = NULL;
    NETLOGON_LOGOFF_UAS_INFORMATION buffer;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    PWKSTA_16_USER_LOGOFF_REQUEST_1 usrLogoffReq =
        (PWKSTA_16_USER_LOGOFF_REQUEST_1)parameters->InBuf;
    PUSER_16_LOGOFF_INFO_1 logoffInfo;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertUnicodeTextParameter(
            userName,
            (LPSTR)( usrLogoffReq->wlreq1_name )
            );

        XsConvertUnicodeTextParameter(
            machineName,
            (LPSTR)( usrLogoffReq->wlreq1_workstation )
            );

        if ( SmbGetUshort( &parameters->Level ) != 1 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make sure the workstation name in the logon request is the
        // name of the workstation from which the request came.
        //

        if ( wcscmp( machineName, Header->ClientMachineName ) ) {

            Header->Status = (WORD)ERROR_ACCESS_DENIED;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = I_NetLogonUasLogoff(
                     userName,
                     machineName,
                     &buffer
                     );

        if ( !XsApiSuccess(status)) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetWkstaUserLogoff: I_NetLogonUasLogoff "
                              "failed: %X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->OutBuf )
                                    + SmbGetUshort( &parameters->OutBufLen ) );

        status = RapConvertSingleEntry(
                     (LPBYTE)&buffer,
                     Desc32_user_logoff_info_1,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->OutBuf ),
                     (LPBYTE)XsSmbGetPointer( &parameters->OutBuf ),
                     Desc16_user_logoff_info_1,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetWkstaUserLogoff: RapConvertSingleEntry "
                              "failed: %X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(LOGON) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          &buffer, SmbGetUlong( &parameters->OutBuf ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        // The user_logoff_info_1 structure has no variable data to pack,
        // but we do need to fill in the code field of the return structure.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->OutBufLen ),
                 Desc16_user_logoff_info_1,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetWkstaUserLogoff: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters->OutBufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetWkstaUserLogoff: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;
        }

        if ( SmbGetUshort( &parameters->OutBufLen ) > sizeof(WORD)) {

            logoffInfo = (PUSER_16_LOGOFF_INFO_1)XsSmbGetPointer(
                                                     &parameters->OutBuf );
            SmbPutUshort( &logoffInfo->usrlogf1_code, VALID_LOGOFF );
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }


    NetpMemoryFree( userName );
    NetpMemoryFree( machineName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->OutBufLen,
        Desc16_user_logoff_info_1,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetWkstaUserLogoff


NTSTATUS
XsNetWkstaUserLogon (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetWkstaUserLogon.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;
    PXS_NET_WKSTA_USER_LOGON parameters = Parameters;
    LPWSTR machineName = NULL;              // Native parameters
    LPWSTR userName = NULL;
    PNETLOGON_VALIDATION_UAS_INFO buffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    PWKSTA_16_USER_LOGON_REQUEST_1 usrLogonReq =
        (PWKSTA_16_USER_LOGON_REQUEST_1)parameters->InBuf;
    PUSER_16_LOGON_INFO_1 logonInfo;


    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertUnicodeTextParameter(
            userName,
            (LPSTR)( usrLogonReq->wlreq1_name )
            );

        XsConvertUnicodeTextParameter(
            machineName,
            (LPSTR)( usrLogonReq->wlreq1_workstation )
            );

        if ( SmbGetUshort( &parameters->Level ) != 1 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make sure the workstation name in the logon request is the
        // name of the workstation from which the request came.
        //

        if ( wcscmp( machineName, Header->ClientMachineName ) ) {

            Header->Status = (WORD)ERROR_ACCESS_DENIED;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = I_NetLogonUasLogon(
                     userName,
                     machineName,
                     &buffer
                     );

        if ( !XsApiSuccess ( status )) {

            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetWkstaUserLogon: I_NetLogonUasLogon failed: "
                              "%X\n", status));
            }
            Header->Status = (WORD) status;
            goto cleanup;
        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->OutBuf )
                                    + SmbGetUshort( &parameters->OutBufLen ) );

        status = RapConvertSingleEntry(
                     (LPBYTE)buffer,
                     Desc32_user_logon_info_1,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->OutBuf ),
                     (LPBYTE)XsSmbGetPointer( &parameters->OutBuf ),
                     Desc16_user_logon_info_1,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetWkstaUserLogon: RapConvertSingleEntry "
                              "failed: %X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(LOGON) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          buffer, SmbGetUlong( &parameters->OutBuf ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        // The user_logoff_info_1 structure has no variable data to pack,
        // but we do need to fill in the code field of the return structure.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->OutBufLen ),
                 Desc16_user_logon_info_1,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetWkstaUserLogon: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters->OutBufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetWkstaUserLogoff: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->OutBuf ),
                                    SmbGetUshort( &parameters->OutBufLen ),
                                    Desc16_user_logon_info_1,
                                    1
                                    );
        }

        if ( SmbGetUshort( &parameters->OutBufLen ) > sizeof(WORD)) {

            logonInfo = (PUSER_16_LOGON_INFO_1)XsSmbGetPointer(
                                                     &parameters->OutBuf );
            SmbPutUshort( &logonInfo->usrlog1_code, VALIDATED_LOGON );
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
        ;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }


    NetpMemoryFree( userName );
    NetpMemoryFree( machineName );
    if ( buffer != NULL ) {
        NetApiBufferFree( buffer );
    }

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->OutBufLen,
        Desc16_user_logon_info_1,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetWkstaUserLogon
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apistubs.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiStubs.c

Abstract:

    This module contains stubs for XACTSRV API handlers, including the
    default handler for unsupported APIs.

Author:

    David Treadwell (davidtr) 07-Jan-1991

Revision History:

--*/

#include "XactSrvP.h"


NTSTATUS
XsNetUnsupportedApi (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine is for APIs which are not supported in Xactsrv. They
    return a special error message.

Arguments:

    Transaction - a pointer to a transaction block containing information
        about the API to process.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    API_HANDLER_PARAMETERS_REFERENCE;

    Header->Status = (WORD)NERR_InvalidAPI;

    return STATUS_SUCCESS;

} // XsNetUnsupportedApi


NTSTATUS
XsNetBuildGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This temporary routine just returns STATUS_NOT_IMPLEMENTED.

Arguments:

    Transaction - a pointer to a transaction block containing information
        about the API to process.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    API_HANDLER_PARAMETERS_REFERENCE;

    Header->Status = (WORD)NERR_InvalidAPI;

    return STATUS_SUCCESS;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apitime.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ApiTime.c

Abstract:

    This module contains individual API handler for the NetRemoteTOD API.

    SUPPORTED : NetRemoteTOD.

Author:

    Shanku Niyogi (w-shanku) 04-Apr-1991

Revision History:

    10-Jun-1993 JohnRo
        RAID 13081: NetRemoteTOD should return timezone info.
--*/

#include "XactSrvP.h"
#include <timelib.h>    // NetpLocalTimeZoneOffset().

//
// Forward declarations
//

NET_API_STATUS
GetLocalTOD(
    OUT LPTIME_OF_DAY_INFO TimeOfDayInfo
    );

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_time_of_day_info = REM16_time_of_day_info;
STATIC const LPDESC Desc32_time_of_day_info = REM32_time_of_day_info;


NTSTATUS
XsNetRemoteTOD (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetRemoteTOD.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_REMOTE_TOD parameters = Parameters;
    TIME_OF_DAY_INFO timeOfDay;

    DWORD bytesRequired = 0;                // Conversion variables
    LPBYTE stringLocation = NULL;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(TIME) {
        NetpKdPrint(( "XsNetRemoteTOD: header at %lx, params at %lx\n",
                      Header, parameters ));
    }

    //
    // Make the local call.
    //

    status = GetLocalTOD(
                 &timeOfDay
                 );
    try {

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetRemoteTOD: NetRemoteTOD failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     (LPBYTE)&timeOfDay,
                     Desc32_time_of_day_info,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     Desc16_time_of_day_info,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetRemoteTOD: RapConvertSingleEntry failed: "
                          "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(TIME) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          &timeOfDay, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer. There is
        // no variable data for a time_of_day_info structure, only fixed data.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 Desc16_time_of_day_info,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetRemoteTOD: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        }

        //
        // No return parameters.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        Desc16_time_of_day_info,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetRemoteTOD

NET_API_STATUS
GetLocalTOD(
    OUT LPTIME_OF_DAY_INFO TimeOfDayInfo
    )
/*++

Routine Description:

    This routine calls the Win32 and NT base timer APIs to get the
    relevant time/date information. It also calls the Rtl routine to
    convert the time elapsed since 1-1-1970.

    The routine allocates a buffer to contain the time of day information
    and returns a pointer to that buffer to the caller.

Arguments:

    bufptr - Location of where to place pointer to buffer.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/
{

    SYSTEMTIME    LocalTime;
    LONG          LocalTimeZoneOffsetSecs;  // offset (+ for West of GMT, etc).
    LARGE_INTEGER Time;

    //
    // Call the appropriate routines to collect the time information
    //

    // Number of seconds from UTC.  Positive values for west of Greenwich,
    // negative values for east of Greenwich.
    LocalTimeZoneOffsetSecs = NetpLocalTimeZoneOffset();

    GetLocalTime(&LocalTime);

    TimeOfDayInfo->tod_hours        = LocalTime.wHour;
    TimeOfDayInfo->tod_mins         = LocalTime.wMinute;
    TimeOfDayInfo->tod_secs         = LocalTime.wSecond;
    TimeOfDayInfo->tod_hunds        = LocalTime.wMilliseconds/10;

    // tod_timezone is + for west of GMT, - for east of it.
    // tod_timezone is in minutes.
    TimeOfDayInfo->tod_timezone     = LocalTimeZoneOffsetSecs / 60;

    TimeOfDayInfo->tod_tinterval    = 310;
    TimeOfDayInfo->tod_day          = LocalTime.wDay;
    TimeOfDayInfo->tod_month        = LocalTime.wMonth;
    TimeOfDayInfo->tod_year         = LocalTime.wYear;
    TimeOfDayInfo->tod_weekday      = LocalTime.wDayOfWeek;

    //
    // Get the 64-bit system time.  Convert the system time to the
    // number of seconds since 1-1-1970.  This is in GMT, Rap will
    // convert this to local time later.
    //

    NtQuerySystemTime(&Time);
    RtlTimeToSecondsSince1970(
                &Time,
                &(TimeOfDayInfo->tod_elapsedt)
                );

    //
    // Get the free running counter value
    //

    TimeOfDayInfo->tod_msecs = GetTickCount();

    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apistats.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiStats.c

Abstract:

    This module contains individual API handlers for the NetStatistics APIs.

    SUPPORTED : NetStatisticsGet2.

Author:

    Shanku Niyogi (w-shanku) 04-Apr-1991

Revision History:

--*/

#define LM20_WORKSTATION_STATISTICS

#include "XactSrvP.h"
#include <ntddnfs.h>
#include <lmstats.h>

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_stat_server_0 = REM16_stat_server_0;
STATIC const LPDESC Desc32_stat_server_0 = REM32_stat_server_0;
STATIC const LPDESC Desc16_stat_workstation_0 = REM16_stat_workstation_0;
STATIC const LPDESC Desc32_stat_workstation_0 = REM32_stat_workstation_0;


NTSTATUS
XsNetStatisticsGet2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetStatisticsGet.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_STATISTICS_GET_2 parameters = Parameters;
    LPTSTR nativeService = NULL;            // Native parameters
    LPVOID outBuffer = NULL;
    LPVOID statBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    DWORD options;
    LPDESC actualStructureDesc;
    LPDESC nativeStructureDesc;
    STAT_WORKSTATION_0 wkstaStats;
    PREDIR_STATISTICS ntRedirStats;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(STATISTICS) {
        NetpKdPrint(( "XsNetStatisticsGet2: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 0
             || SmbGetUlong( &parameters->Reserved ) != 0 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // No options currently supported by both rdr and srv
        //

        if ( SmbGetUlong( &parameters->Options ) != 0 ) {
            Header->Status = ERROR_NOT_SUPPORTED;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeService,
            (LPSTR)XsSmbGetPointer( &parameters->Service )
            );

        //
        // Make the local call.
        //

        status = NetStatisticsGet(
                     NULL,
                     XS_MAP_SERVICE_NAME( nativeService ),
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     0,                 // Options MBZ
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetStatisticsGet2: NetStatisticsGet failed: "
                            "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the name of the service to determine the format of the 32-bit
        // structure we got back from NetStatisticsGet, and the format of what
        // the resulting 16-bit structure should be. If the service name is not
        // one supported in LM2.x, return ERROR_NOT_SUPPORTED now, as required.
        //

        if ( !_stricmp( (LPSTR)XsSmbGetPointer( &parameters->Service ), "SERVER" )) {

            statBuffer = outBuffer;
            nativeStructureDesc = Desc32_stat_server_0;
            actualStructureDesc = Desc16_stat_server_0;

        } else if ( !_stricmp( (LPSTR)XsSmbGetPointer( &parameters->Service ),
                        "WORKSTATION" )) {

            //
            // The structure we got back is an nt structure.  We need to convert
            // it by hand here.
            //

            statBuffer = &wkstaStats;
            ntRedirStats = (PREDIR_STATISTICS)outBuffer;
            RtlZeroMemory(
                    &wkstaStats,
                    sizeof(STAT_WORKSTATION_0)
                    );

            (VOID)RtlTimeToSecondsSince1970(
                            &ntRedirStats->StatisticsStartTime,
                            &wkstaStats.stw0_start
                            );

            wkstaStats.stw0_sesstart = ntRedirStats->Sessions;
            wkstaStats.stw0_sessfailcon = ntRedirStats->FailedSessions;
            wkstaStats.stw0_sessbroke = ntRedirStats->ServerDisconnects +
                                        ntRedirStats->HungSessions;
            wkstaStats.stw0_uses =
                        ntRedirStats->CoreConnects +
                        ntRedirStats->Lanman20Connects +
                        ntRedirStats->Lanman21Connects +
                        ntRedirStats->LanmanNtConnects;

            wkstaStats.stw0_usefail = ntRedirStats->FailedUseCount;
            wkstaStats.stw0_autorec = ntRedirStats->Reconnects;

            wkstaStats.stw0_bytessent_r_hi =
                                ntRedirStats->BytesTransmitted.HighPart;
            wkstaStats.stw0_bytessent_r_lo =
                                ntRedirStats->BytesTransmitted.LowPart;

            wkstaStats.stw0_bytesrcvd_r_hi =
                                ntRedirStats->BytesReceived.HighPart;
            wkstaStats.stw0_bytesrcvd_r_lo =
                                ntRedirStats->BytesReceived.LowPart;

            nativeStructureDesc = Desc32_stat_workstation_0;
            actualStructureDesc = Desc16_stat_workstation_0;

        } else {

            Header->Status = ERROR_NOT_SUPPORTED;
            goto cleanup;
        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     statBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     actualStructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetStatisticsGet2: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(STATISTICS) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer. Statistics
        // structures don't have any variable data to pack.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 actualStructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetStatisticsGet2: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeService );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        actualStructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetStatisticsGet2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apisvc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiSvc.c

Abstract:

    This module contains individual API handlers for the NetService APIs.

    SUPPORTED : NetServicControl, NetServiceEnum, NetServiceGetInfo,
                NetServiceInstall.

Author:

    Shanku Niyogi (w-shanku) 26-Feb-1991

Revision History:

--*/

#include "XactSrvP.h"


#define XACTSRV_CONVERT_SVC_EXITCODE(ob)                                       \
    {                                                                          \
        PSERVICE_INFO_2 ss = (PSERVICE_INFO_2) ob;                             \
        if ((unsigned short) ss->svci2_code == ERROR_SERVICE_SPECIFIC_ERROR) { \
            ss->svci2_code = (ss->svci2_code & 0xffff0000) | (unsigned short) ss->svci2_specific_error;\
        }                                                                      \
    }


//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_service_info_0 = REM16_service_info_0;
STATIC const LPDESC Desc32_service_info_0 = REM32_service_info_0;
STATIC const LPDESC Desc16_service_info_1 = REM16_service_info_1;
STATIC const LPDESC Desc32_service_info_1 = REM32_service_info_1;
STATIC const LPDESC Desc16_service_info_2 = REM16_service_info_2;
STATIC const LPDESC Desc32_service_info_2 = REM32_service_info_2;


NTSTATUS
XsNetServiceControl (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServiceControl.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SERVICE_CONTROL parameters = Parameters;
    LPTSTR nativeService = NULL;            // Native parameters
    LPVOID outBuffer = NULL;
    LPVOID newOutBuffer = NULL;
    LPSERVICE_INFO_2 serviceInfo2;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    DWORD installState;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SERVICE) {
        NetpKdPrint(( "XsNetServiceControl: header at %lx, params at %lx\n",
                      Header, parameters ));
    }

    try {
            //
            // Translate parameters, check for errors.
            //

            XsConvertTextParameter(
                nativeService,
                (LPSTR)XsSmbGetPointer( &parameters->Service )
                );

            //
            // Make the local call.  We need to mask off the upper bytes of
            // both the opcode and the arg parameters since the client is
            // putting some garbage on the high byte.  The valid values for
            // both are 1-255.
            //

            status = NetServiceControl(
                         NULL,
                         XS_MAP_SERVICE_NAME( nativeService ),
                         (DWORD)( parameters->OpCode & 0x00FF ),
                         (DWORD)( parameters->Arg & 0x00FF ),
                         (LPBYTE *)&outBuffer
                         );

            if ( !XsApiSuccess( status )) {
                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetServiceControl: NetServiceControl failed: "
                                  "%X\n", status ));
                }

                Header->Status = (WORD)status;

                goto cleanup;

            }

            //
            // Convert nt service name to os/2 name
            //

            status = NetpTranslateNamesInServiceArray(
                                        2,                      // level 2 by def
                                        outBuffer,
                                        1,                      // 1 entry
                                        FALSE,
                                        &newOutBuffer
                                        );

            if ( !XsApiSuccess( status )) {
                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetServiceControl: NetpTranslateNamesInServiceArray failed: "
                                  "%X\n", status ));
                }

                Header->Status = NERR_InternalError;
                goto cleanup;
            }

            //
            // If the status indicates INSTALL or UNINSTALL PENDING, and if the
            // wait hint is greater than 0xFF then the wait hint sent to downlevel
            // must be set the maximum SERVICE_MAXTIME (0xFF).
            //
            serviceInfo2 = (LPSERVICE_INFO_2)newOutBuffer;
            installState = serviceInfo2->svci2_status & SERVICE_INSTALL_STATE;

            if ((installState == SERVICE_INSTALL_PENDING) ||
                (installState == SERVICE_UNINSTALL_PENDING)) {

                if (SERVICE_NT_WAIT_GET(serviceInfo2->svci2_code) > SERVICE_MAXTIME) {
                    serviceInfo2->svci2_code |= UPPER_HINT_MASK;
                    serviceInfo2->svci2_code &= SERVICE_RESRV_MASK;
                }
            }
            else {
                //
                // NT version has code and specific_error while downlevel
                // version only has code.  Convert the info from the extra
                // NT specific_error field.
                //

                XACTSRV_CONVERT_SVC_EXITCODE(newOutBuffer);
            }
            //
            // Convert the structure returned by the 32-bit call to a 16-bit
            // structure. The last possible location for variable data is
            // calculated from buffer location and length.
            //

            stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                          + SmbGetUshort( &parameters->BufLen ) );

            status = RapConvertSingleEntry(
                         newOutBuffer,
                         Desc32_service_info_2,
                         FALSE,
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         Desc16_service_info_2,
                         TRUE,
                         &stringLocation,
                         &bytesRequired,
                         Response,
                         NativeToRap
                         );


            if ( status != NERR_Success ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetServiceControl: RapConvertSingleEntry failed: "
                                  "%X\n", status ));
                }

                Header->Status = NERR_InternalError;
                goto cleanup;
            }

            IF_DEBUG(SERVICE ) {
                NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                              newOutBuffer, SmbGetUlong( &parameters->Buffer ),
                              bytesRequired ));
            }

            //
            // Determine return code based on the size of the buffer.
            // SERVICE_INFO_x structures have no variable data to pack.
            //

            if ( !XsCheckBufferSize(
                     SmbGetUshort( &parameters->BufLen ),
                     Desc16_service_info_2,
                     FALSE  // not in native format
                     )) {

                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetServiceControl: Buffer too small.\n" ));
                }
                Header->Status = NERR_BufTooSmall;

            }

cleanup:
        ;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
        }

        NetpMemoryFree( nativeService );
        NetApiBufferFree( outBuffer );
        NetApiBufferFree( newOutBuffer );

        //
        // Determine return buffer size.
        //

        XsSetDataCount(
            &parameters->BufLen,
            Desc16_service_info_2,
            Header->Converter,
            1,
            Header->Status
            );

        return STATUS_SUCCESS;

} // XsNetServiceControl


NTSTATUS
XsNetServiceEnum (
        API_HANDLER_PARAMETERS
        )

/*++

Routine Description:

        This routine handles a call to NetServiceEnum.

Arguments:

        API_HANDLER_PARAMETERS - information about the API call. See
            XsTypes.h for details.

Return Value:

        NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
        NET_API_STATUS status;

        PXS_NET_SERVICE_ENUM parameters = Parameters;
        LPVOID outBuffer = NULL;                // Native parameters
        LPVOID newOutBuffer = NULL;
        DWORD entriesRead;
        DWORD totalEntries;

        DWORD entriesFilled = 0;                    // Conversion variables
        DWORD bytesRequired = 0;
        LPDESC nativeStructureDesc;
        DWORD level;

        API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

        IF_DEBUG(SERVICE) {
            NetpKdPrint(( "XsNetServiceEnum: header at %lx, params at %lx, "
                          "level %ld, buf size %ld\n",
                          Header, parameters, SmbGetUshort( &parameters->Level ),
                          SmbGetUshort( &parameters->BufLen )));
        }

        try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 2 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        level = (DWORD)SmbGetUshort( &parameters->Level );
        status = NetServiceEnum(
                     NULL,
                     level,
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetServiceEnum: NetServiceEnum failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(SERVICE) {
            NetpKdPrint(( "XsNetServiceEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Convert nt service names to os/2 name
        //

        status = NetpTranslateNamesInServiceArray(
                                    level,
                                    outBuffer,
                                    entriesRead,
                                    FALSE,
                                    &newOutBuffer
                                    );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetServiceEnum: NetpTranslateNamesInServiceArray failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( level ) {

        case 0:

            nativeStructureDesc = Desc32_service_info_0;
            StructureDesc = Desc16_service_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_service_info_1;
            StructureDesc = Desc16_service_info_1;
            {
                DWORD i;
                DWORD installState;
                PSERVICE_INFO_1 serviceInfo1 = (PSERVICE_INFO_1) newOutBuffer;

                for (i = 0; i < entriesRead; i++, serviceInfo1++) {

                    //
                    // If the status indicates INSTALL or UNINSTALL PENDING,
                    // and if the wait hint is greater than 0xFF then the
                    // wait hint sent to downlevel must be set the
                    // maximum SERVICE_MAXTIME (0xFF).
                    //
                    installState = (serviceInfo1[i]).svci1_status & SERVICE_INSTALL_STATE;
                    if ((installState == SERVICE_INSTALL_PENDING) ||
                        (installState == SERVICE_UNINSTALL_PENDING)) {

                        if (SERVICE_NT_WAIT_GET(serviceInfo1->svci1_code) > SERVICE_MAXTIME) {
                            serviceInfo1->svci1_code |= UPPER_HINT_MASK;
                            serviceInfo1->svci1_code &= SERVICE_RESRV_MASK;
                        }
                    }
                }
            }
            break;

        case 2:

            nativeStructureDesc = Desc32_service_info_2;
            StructureDesc = Desc16_service_info_2;

            {
                DWORD i;
                DWORD installState;
                PSERVICE_INFO_2 serviceInfo2 = (PSERVICE_INFO_2) newOutBuffer;

                for (i = 0; i < entriesRead; i++, serviceInfo2++) {

                    //
                    // If the status indicates INSTALL or UNINSTALL PENDING,
                    // and if the wait hint is greater than 0xFF then the
                    // wait hint sent to downlevel must be set the
                    // maximum SERVICE_MAXTIME (0xFF).
                    //
                    installState = (serviceInfo2[i]).svci2_status & SERVICE_INSTALL_STATE;
                    if ((installState == SERVICE_INSTALL_PENDING) ||
                        (installState == SERVICE_UNINSTALL_PENDING)) {

                        if (SERVICE_NT_WAIT_GET(serviceInfo2->svci2_code) > SERVICE_MAXTIME) {
                            serviceInfo2->svci2_code |= UPPER_HINT_MASK;
                            serviceInfo2->svci2_code &= SERVICE_RESRV_MASK;
                        }
                    }
                    else {
                        //
                        // NT version has code and specific_error while downlevel
                        // version only has code.  Convert the info from the extra
                        // NT specific_error field.
                        //
                        XACTSRV_CONVERT_SVC_EXITCODE(serviceInfo2);
                    }
                }
            }

            break;
        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            newOutBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(SERVICE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          newOutBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA.
        // SERVICE_INFO_x structures have no variable data to pack.
        //

        if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetApiBufferFree( newOutBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetServiceEnum


NTSTATUS
XsNetServiceGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServiceGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SERVICE_GET_INFO parameters = Parameters;
    LPTSTR nativeService = NULL;            // Native parameters
    LPVOID outBuffer = NULL;
    LPVOID newOutBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;
    DWORD level;
    LPSERVICE_INFO_2 serviceInfo2;
    LPSERVICE_INFO_1 serviceInfo1;
    DWORD installState;


    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SERVICE) {
        NetpKdPrint(( "XsNetServiceGetInfo: header at %lx, "
                      "params at %lx, level %d\n",
                      Header, parameters, SmbGetUshort( &parameters->Level )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 2 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeService,
            (LPSTR)XsSmbGetPointer( &parameters->Service )
            );

        if (nativeService == NULL) {
            Header->Status = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        level = (DWORD)SmbGetUshort( &parameters->Level );
        status = NetServiceGetInfo(
                     NULL,
                     XS_MAP_SERVICE_NAME( nativeService ),
                     level,
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetServiceGetInfo: NetServiceGetInfo failed: "
                              "%X\n", status ));
            }

            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Convert nt service name to os/2 name
        //

        status = NetpTranslateNamesInServiceArray(
                                    level,
                                    outBuffer,
                                    1,
                                    FALSE,
                                    &newOutBuffer
                                    );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetServiceGetInfo: NetpTranslateNamesInServiceArray failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( level ) {

        case 0:

            nativeStructureDesc = Desc32_service_info_0;
            StructureDesc = Desc16_service_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_service_info_1;
            StructureDesc = Desc16_service_info_1;
            //
            // If the status indicates INSTALL or UNINSTALL PENDING, and if the
            // wait hint is greater than 0xFF then the wait hint sent to downlevel
            // must be set the maximum SERVICE_MAXTIME (0xFF).
            //
            serviceInfo1 = (LPSERVICE_INFO_1)newOutBuffer;
            installState = serviceInfo1->svci1_status & SERVICE_INSTALL_STATE;

            if ((installState == SERVICE_INSTALL_PENDING) ||
                (installState == SERVICE_UNINSTALL_PENDING)) {

                if (SERVICE_NT_WAIT_GET(serviceInfo1->svci1_code) > SERVICE_MAXTIME) {
                    serviceInfo1->svci1_code |= UPPER_HINT_MASK;
                    serviceInfo1->svci1_code &= SERVICE_RESRV_MASK;
                }
            }
            break;

        case 2:

            nativeStructureDesc = Desc32_service_info_2;
            StructureDesc = Desc16_service_info_2;

            //
            // If the status indicates INSTALL or UNINSTALL PENDING, and if the
            // wait hint is greater than 0xFF then the wait hint sent to downlevel
            // must be set the maximum SERVICE_MAXTIME (0xFF).
            //
            serviceInfo2 = (LPSERVICE_INFO_2)newOutBuffer;
            installState = serviceInfo2->svci2_status & SERVICE_INSTALL_STATE;

            if ((installState == SERVICE_INSTALL_PENDING) ||
                (installState == SERVICE_UNINSTALL_PENDING)) {

                if (SERVICE_NT_WAIT_GET(serviceInfo2->svci2_code) > SERVICE_MAXTIME) {
                    serviceInfo2->svci2_code |= UPPER_HINT_MASK;
                    serviceInfo2->svci2_code &= SERVICE_RESRV_MASK;
                }
            }
            else {
                //
                // NT version has code and specific_error while downlevel
                // version only has code.  Convert the info from the extra
                // NT specific_error field.
                //
                XACTSRV_CONVERT_SVC_EXITCODE(newOutBuffer);
            }
            break;
        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     newOutBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServiceGetInfo: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(SERVICE ) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          newOutBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        // SERVICE_INFO_x structures have no variable data to pack.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServiceGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        }


        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( newOutBuffer );
    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeService );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetServiceGetInfo

NTSTATUS
XsNetServiceInstall (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetServiceInstall.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_SERVICE_INSTALL parameters = Parameters;
    LPTSTR nativeService = NULL;            // Native parameters
    DWORD argc;
    LPTSTR * argv = NULL;
    LPVOID outBuffer = NULL;
    LPVOID newOutBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPTSTR nativeRcvBuffer = NULL;
    LPSTR srcBuffer = NULL;
    LPTSTR destBuffer = NULL;
    DWORD bufSize;
    DWORD i;
    DWORD installState;
    LPSERVICE_INFO_2 serviceInfo2;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(SERVICE) {
        NetpKdPrint(( "XsNetServiceInstall: header at %lx, "
                      "params at %lx, service %s\n",
                      Header, parameters,
                      (LPSTR)XsSmbGetPointer( &parameters->Service ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeService,
            (LPSTR)XsSmbGetPointer( &parameters->Service )
            );

        //
        // Convert buffer. First, find number of arguments and buffer size.
        //

        srcBuffer = (LPSTR)XsSmbGetPointer( &parameters->RcvBuffer );
        if ( srcBuffer ) {
            bufSize = 0;
            for ( argc = 0; strlen( srcBuffer ) > 0; argc++ ) {
                bufSize += ( strlen( srcBuffer ) + 1 );
                srcBuffer += ( strlen( srcBuffer ) + 1 );
            }
        } else {
            bufSize = 0;
            argc = 0;
        }

        if ( argc ) {

            //
            // Allocate an argument vector.
            //

            argv = NetpMemoryAllocate( argc * sizeof(LPTSTR) );
            if ( argv == NULL ) {
                Header->Status = NERR_NoRoom;
                goto cleanup;
            }

            //
            // If we are Unicode, allocate room for converted buffer.
            // Otherwise, use the receive buffer to fill argv.
            //

#ifdef UNICODE
            nativeRcvBuffer = NetpMemoryAllocate( STRING_SPACE_REQD( bufSize + 1 ));
            if ( nativeRcvBuffer == NULL ) {
                Header->Status = NERR_NoRoom;
                goto cleanup;
            }
            srcBuffer = (LPSTR)XsSmbGetPointer( &parameters->RcvBuffer );
#else
            nativeRcvBuffer = (LPTSTR)XsSmbGetPointer( &parameters->RcvBuffer );
#endif

        }

        //
        // Go through buffer, filling in argv vector, and optionally converting
        // to Unicode.
        //

        destBuffer = nativeRcvBuffer;
        for ( i = 0; i < argc; i++ ) {

#ifdef UNICODE
            NetpCopyStrToTStr( destBuffer, srcBuffer );
            srcBuffer += ( strlen( srcBuffer ) + 1 );
#endif

            argv[i] = destBuffer;
            destBuffer += ( STRLEN( destBuffer ) + 1 );
        }

        //
        // Make the local call.
        //

        status = NetServiceInstall(
                     NULL,
                     XS_MAP_SERVICE_NAME( nativeService ),
                     argc,
                     argv,
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetServiceInstall: NetServiceInstall failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Convert nt service name to os/2 name
        //

        status = NetpTranslateNamesInServiceArray(
                                    2,                  // level 2 by def
                                    outBuffer,
                                    1,                  // 1 entry
                                    FALSE,
                                    &newOutBuffer
                                    );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetServiceInstall: NetpTranslateNamesInServiceArray failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // If the status indicates INSTALL or UNINSTALL PENDING, and if the
        // wait hint is greater than 0xFF then the wait hint sent to downlevel
        // must be set the maximum SERVICE_MAXTIME (0xFF).
        //
        serviceInfo2 = (LPSERVICE_INFO_2)newOutBuffer;
        installState = serviceInfo2->svci2_status & SERVICE_INSTALL_STATE;

        if ((installState == SERVICE_INSTALL_PENDING) ||
            (installState == SERVICE_UNINSTALL_PENDING)) {

            if (SERVICE_NT_WAIT_GET(serviceInfo2->svci2_code) > SERVICE_MAXTIME) {
                serviceInfo2->svci2_code |= UPPER_HINT_MASK;
                serviceInfo2->svci2_code &= SERVICE_RESRV_MASK;
            }
        }

        else {
            //
            // NT version has code and specific_error while downlevel
            // version only has code.  Convert the info from the extra
            // NT specific_error field.
            //

            XACTSRV_CONVERT_SVC_EXITCODE(newOutBuffer);
        }
        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The "return buffer" is actually a byte array in the
        // parameter area.
        //

        stringLocation = parameters->RetBuffer + sizeof( parameters->RetBuffer );

        status = RapConvertSingleEntry(
                     newOutBuffer,
                     Desc32_service_info_2,
                     FALSE,
                     parameters->RetBuffer,
                     parameters->RetBuffer,
                     Desc16_service_info_2,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );


        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetServiceInstall: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(SERVICE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          newOutBuffer, &parameters->RetBuffer, bytesRequired ));
        }

        //
        // There should have been enough memory to make this call, because
        // buffer length is checked locally on the client, and an 88 byte
        // receive buffer is always provided.
        //

        NetpAssert( bytesRequired <= sizeof( parameters->RetBuffer ));

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetApiBufferFree( newOutBuffer );
    NetpMemoryFree( nativeService );
    NetpMemoryFree( argv );
#ifdef UNICODE
    NetpMemoryFree( nativeRcvBuffer );
#endif // def UNICODE

    return STATUS_SUCCESS;

} // XsNetServiceInstall
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apiuse.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiUse.c

Abstract:

    This module contains individual API handlers for the NetUse APIs.

    SUPPORTED : NetUseAdd, NetUseDel, NetUseEnum, NetUseGetInfo.

    NOTE : These handlers are only provided as exports by the XACTSRV
           DLL, for use by clients such as VDM. They are not supported
           for remote clients.

Author:

    Shanku Niyogi (w-shanku) 31-Jan-1991

Revision History:

--*/

#include "XactSrvP.h"

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_use_info_0 = REM16_use_info_0;
STATIC const LPDESC Desc32_use_info_0 = REM32_use_info_0;
STATIC const LPDESC Desc16_use_info_1 = REM16_use_info_1;
STATIC const LPDESC Desc32_use_info_1 = REM32_use_info_1;


STATIC NET_API_STATUS
XsNetUseEnumVerify (
    IN NET_API_STATUS ConvertStatus,
    IN PBYTE ConvertedEntry,
    IN PBYTE BaseAddress
    )

/*++

Routine Description:


    This function is called by XsFillEnumBuffer after each entry is
    converted, in order to determine whether the entry should be retained
    in the enum buffer or discarded.


    The use_info_x structures contain sharenames in a field with the format
    \\computername\sharename.  XACTSRV must not return information about
    shares or computers with names longer than are allowed under LanMan 2.0.
    RapConvertSingleEntry can only insure that the entire field does not
    exceed the specified length; it cannot verify the lengths of individual
    components of a sharename.  So this function is called by
    XsFillEnumBuffer after each call to RapConvertSingleEntry in order to
    check whether the converted entry satisfies this additional constraint.


Arguments:

    ConvertStatus - The return code from RapConvertSingleEntry.

    ConvertedEntry - The converted entry created by RapConvertSingleEntry.

    BaseAddress - A pointer to the base used to calculate offsets.

Return Value:

    NTSTATUS - STATUS_INVALID_PARAMETER if the entry should be retained, or
        an error code if the entry should be discarded.

--*/

{
    NTSTATUS status;
    DWORD remote;
    PUSE_16_INFO_0 use = (PUSE_16_INFO_0)ConvertedEntry;

    //
    // If RapConvertSingleEntry failed, discard the entry.
    //

    if ( ConvertStatus != NERR_Success ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // If the sharename is too long, discard the entry.
    //

    remote = (DWORD)SmbGetUlong( &use->ui0_remote );

    status = ( remote == 0 ) ? NERR_Success
                             : XsValidateShareName( BaseAddress + remote );

    IF_DEBUG(CONVERT) {

        if ( !NT_SUCCESS(status) ) {
            NetpKdPrint(( "XsNetUseEnumVerify: sharename too long: "
                          "discarding entry\n" ));
        }
    }

    return status;
}


NTSTATUS
XsNetUseAdd (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUseAdd.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USE_ADD parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    DWORD bufferSize;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(USE) {
        NetpKdPrint(( "XsNetUseAdd: header at %lx, params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 1 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        StructureDesc = Desc16_use_info_1;

        //
        // Figure out if there is enough room in the buffer for all the
        // data required. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format yet
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUseAdd: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find out how big a buffer we need to allocate to hold the native
        // 32-bit version of the input data structure.
        //

        bufferSize = XsBytesForConvertedStructure(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         StructureDesc,
                         Desc32_use_info_1,
                         RapToNative,
                         TRUE
                         );

        //
        // Allocate enough memory to hold the converted native buffer.
        //

        buffer = NetpMemoryAllocate( bufferSize );

        if ( buffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUseAdd: failed to create buffer" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        IF_DEBUG(USE) {
            NetpKdPrint(( "XsNetUseAdd: buffer of %ld bytes at %lx\n",
                          bufferSize, buffer ));
        }

        //
        // Convert the buffer from 16-bit to 32-bit.
        //

        stringLocation = (LPBYTE)buffer + bufferSize;
        bytesRequired = 0;

        status = RapConvertSingleEntry(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     buffer,
                     buffer,
                     Desc32_use_info_1,
                     FALSE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     RapToNative
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUseAdd: RapConvertSingleEntry failed: "
                          "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // RLF
        //
        // if use_info_1.ui1_asg_type is 0xffff meaning wildcard, we have to
        // convert it to 0xffffffff since NetUseAdd is going to compare it
        // against (DWORD)(-1) and RapConvertSingleEntry has only converted it
        // to 0x0000ffff which results in an error
        //

        if (((LPUSE_INFO_1)buffer)->ui1_asg_type == 0xffff) {
            ((LPUSE_INFO_1)buffer)->ui1_asg_type = 0xffffffff;
        }

        //
        // Do the actual local call.
        //

        status = NetUseAdd(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE)buffer,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUseAdd: NetUseAdd failed: %X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // There is no real return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( buffer );

    return STATUS_SUCCESS;

} // XsNetUseAdd


NTSTATUS
XsNetUseDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUseDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USE_DEL parameters = Parameters;
    LPTSTR nativeUseName = NULL;            // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(USE) {
        NetpKdPrint(( "XsNetUseDel: header at %lx, params at %lx, device %s\n",
                      Header, parameters, SmbGetUlong( &parameters->UseName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeUseName,
            (LPSTR)XsSmbGetPointer( &parameters->UseName )
            );

        //
        // Do local call, with converted parameter values.
        //

        status = NetUseDel(
                     NULL,
                     nativeUseName,
                     (DWORD)SmbGetUshort( &parameters->Force )
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUseDel: NetUseDel failed: %X\n", status ));
            }
        }

        //
        // Nothing to return.
        //

        Header->Status = (WORD)status;

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeUseName );

    return STATUS_SUCCESS;

} // XsNetUseDel


NTSTATUS
XsNetUseEnum (
    API_HANDLER_PARAMETERS
    )

/*+

Routine Description:

    This routine handles a call to NetUseEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.
+
--*/

{
    NET_API_STATUS status;

    PXS_NET_USE_ENUM parameters = Parameters;
    LPVOID outBuffer = NULL;                // Native parameters
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                    // Conversion variables
    DWORD invalidEntries = 0;
    DWORD bytesRequired;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(USE) {
        NetpKdPrint(( "XsNetUseEnum: header at %lx, params at %lx, level %ld, "
                      "buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetUseEnum(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetUseEnum: NetUseEnum failed: %X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(USE) {
            NetpKdPrint(( "XsNetUseEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_use_info_0;
            StructureDesc = Desc16_use_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_use_info_1;
            StructureDesc = Desc16_use_info_1;
            break;

        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            &XsNetUseEnumVerify,
            &bytesRequired,
            &entriesFilled,
            &invalidEntries
            );

        IF_DEBUG(USE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if (( entriesFilled + invalidEntries ) < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail,
                          (WORD)( totalEntries - invalidEntries ));

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // NetUseEnum


NTSTATUS
XsNetUseGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUseGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USE_GET_INFO parameters = Parameters;
    LPTSTR nativeUseName = NULL;            // Native parameters
    LPVOID outBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(USE) {
        NetpKdPrint(( "XsNetUseGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeUseName,
            (LPSTR)XsSmbGetPointer( &parameters->UseName )
            );

        //
        // Do the actual local call.
        //

        status = NetUseGetInfo(
                     NULL,
                     nativeUseName,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetUseGetInfo: NetUseGetInfo failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the 32-bit
        // structure we got back from NetUseGetInfo.  The format of the
        // 16-bit structure is stored in the transaction block, and we
        // got a pointer to it as a parameter.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_use_info_0;
            StructureDesc = Desc16_use_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_use_info_1;
            StructureDesc = Desc16_use_info_1;
            break;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUseGetInfo: RapConvertSingleEntry failed: "
                          "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(USE) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE      // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUseGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "NetUseGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // NetUseGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\changepw.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ChangePw.c

Abstract:

    This module implements password change from downlevel clients.
    XsChangePasswordSam is called by XsNetUserPasswordSet2 in
    apiuser.c.  I've put this in a seperate file because it #includes
    a private SAM header.

Author:

    Dave Hart (davehart) 31-Apr-1992

Revision History:

--*/

#include "xactsrvp.h"
#include <ntlsa.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <crypt.h>
#include <lmcons.h>
#include "changepw.h"
#include <netlibnt.h>
#include <smbgtpt.h>


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//  Internal function prototyptes.                                         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

NTSTATUS
RtlGetPrimaryDomain(
    IN  ULONG            SidLength,
    OUT PBOOLEAN         PrimaryDomainPresent,
    OUT PUNICODE_STRING  PrimaryDomainName,
    OUT PUSHORT          RequiredNameLength,
    OUT PSID             PrimaryDomainSid OPTIONAL,
    OUT PULONG           RequiredSidLength
    );


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//  Exported functions.                                                    //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

NET_API_STATUS
XsChangePasswordSam (
    IN PUNICODE_STRING UserName,
    IN PVOID OldPassword,
    IN PVOID NewPassword,
    IN BOOLEAN Encrypted
    )
/*++

Routine Description:

    This routine is called by XsNetUserPasswordSet2 to change the password
    on a Windows NT machine.  The code is based on
    lsa\msv1_0\nlmain.c MspChangePasswordSam.

Arguments:

    UserName     - Name of the user to change password for.

    OldPassword  - Old password encrypted using new password as key.

    NewPassword  - New password encrypted using old password as key.

Return Value:


--*/

{
    NTSTATUS                    Status;
    NT_PRODUCT_TYPE             NtProductType;
    UNICODE_STRING              DomainName;
    LPWSTR                      serverName = NULL;
    BOOLEAN                     DomainNameAllocated;
    BOOLEAN                     PrimaryDomainPresent;
    USHORT                      RequiredDomainNameLength;
    ULONG                       RequiredDomainSidLength;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    PSID                        DomainSid = NULL;
    PULONG                      UserId = NULL;
    PSID_NAME_USE               NameUse = NULL;
    SAM_HANDLE                  SamHandle = NULL;
    SAM_HANDLE                  DomainHandle = NULL;
    SAM_HANDLE                  UserHandle = NULL;
    HANDLE                      OpenedToken;

    //
    // We're going to _open the local account domain.  The name of this
    // domain is "Account" on a WinNT machine, or the name of the
    // primary domain on a LanManNT machine.  Figure out the product
    // type, assuming WinNT if RtlGetNtProductType fails.
    //

    DomainName.MaximumLength = 0;
    DomainName.Buffer = NULL;
    DomainNameAllocated = FALSE;

    NtProductType = NtProductWinNt;

    RtlGetNtProductType(
        &NtProductType
    );

    if (NtProductLanManNt != NtProductType) {

        NET_API_STATUS error;

        //
        // The server name is the database name.
        //

        error = NetpGetComputerName( &serverName );

        if ( error != NO_ERROR ) {
            return(error);
        }

        RtlInitUnicodeString(
            &DomainName,
            serverName
            );

    } else {

        //
        // This is a LanManNT machine, so we need to find out the
        // name of the primary domain.  First get the length of the
        // domain name, then make room for it and retrieve it.
        //

        Status = RtlGetPrimaryDomain(
                     0,
                     &PrimaryDomainPresent,
                     &DomainName,
                     &RequiredDomainNameLength,
                     NULL,
                     &RequiredDomainSidLength
                     );

        if (STATUS_BUFFER_TOO_SMALL != Status && !NT_SUCCESS(Status)) {

            KdPrint(("XsChangePasswordSam: Unable to size primary "
                         " domain name buffer, %8.8x\n", Status));

            goto Cleanup;
        }

        DomainName.Buffer = RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                DomainName.MaximumLength = RequiredDomainNameLength
                                );
        DomainNameAllocated = TRUE;

        DomainSid = RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                RequiredDomainSidLength
                                );

        if (!DomainName.Buffer || !DomainSid) {
            KdPrint(("XsChangePasswordSam: Out of memory allocating %d and %d bytes.",
                     RequiredDomainNameLength, RequiredDomainSidLength));
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        Status = RtlGetPrimaryDomain(
                     RequiredDomainSidLength,
                     &PrimaryDomainPresent,
                     &DomainName,
                     &RequiredDomainNameLength,
                     DomainSid,
                     &RequiredDomainSidLength
                     );

        RtlFreeHeap(RtlProcessHeap(), 0, DomainSid);
        DomainSid = NULL;

        if (!NT_SUCCESS(Status)) {
            KdPrint(("XsChangePasswordSam: Unable to retrieve domain "
                     "name, %8.8x\n", Status));
            goto Cleanup;
        }

        ASSERT(PrimaryDomainPresent);

    }


    //
    // Wrap an exception handler around this entire function,
    // since RPC raises exceptions to return errors.
    //

    try {

        //
        // Connect to local SAM.
        //

        InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);
        ObjectAttributes.SecurityQualityOfService = &SecurityQos;

        SecurityQos.Length = sizeof(SecurityQos);
        SecurityQos.ImpersonationLevel = SecurityIdentification;
        SecurityQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
        SecurityQos.EffectiveOnly = FALSE;

        Status = SamConnect(
                     NULL,
                     &SamHandle,
                     GENERIC_EXECUTE,
                     &ObjectAttributes
                     );

        if ( !NT_SUCCESS(Status) ) {
            KdPrint(("XsChangePasswordSam: SamConnect failed, status %8.8x\n",
                      Status));
            goto Cleanup;
        }

        //
        // Lookup the Domain SID.
        //

        Status = SamLookupDomainInSamServer(
                     SamHandle,
                     &DomainName,
                     &DomainSid
                     );

        if ( !NT_SUCCESS(Status) ) {
            KdPrint(("XsChangePasswordSam: Cannot find domain %wZ, "
                    "status %8.8x\n", &DomainName, Status));

            Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
            goto Cleanup;
        }


        //
        // Revert to Local System
        //
        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    MAXIMUM_ALLOWED,
                    TRUE,
                    &OpenedToken
                );

        if( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }

        RevertToSelf();

        //
        // Open the account domain.
        //

        Status = SamOpenDomain(
                     SamHandle,
                     GENERIC_EXECUTE,
                     DomainSid,
                     &DomainHandle
                     );

        if ( !NT_SUCCESS(Status) ) {
#if DBG
            UNICODE_STRING UnicodeSid;

            RtlConvertSidToUnicodeString(
                &UnicodeSid,
                DomainSid,
                TRUE
                );
            KdPrint(("XsChangePasswordSam: Cannot open domain %wZ, status %8.8x, SAM handle %8.8x, Domain SID %wZ\n",
                     &DomainName, Status, SamHandle, UnicodeSid));
            RtlFreeUnicodeString(&UnicodeSid);
#endif
            Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
            goto Cleanup;
        }

        //
        // Find the ID for this username.
        //

        Status = SamLookupNamesInDomain(
                     DomainHandle,
                     1,
                     UserName,
                     &UserId,
                     &NameUse
                     );

        if ( !NT_SUCCESS(Status) ) {
            KdPrint(("XsChangePasswordSam: Cannot lookup user %wZ, "
                     "status %8.8x\n", UserName, Status));
            if (STATUS_NONE_MAPPED == Status) {
                Status = STATUS_NO_SUCH_USER;
            }

            goto Cleanup;
        }

        //
        // Re-impersonate the client
        //
        Status = NtSetInformationThread(
                            NtCurrentThread(),
                            ThreadImpersonationToken,
                            &OpenedToken,
                            sizeof( OpenedToken )
                            );

        if( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }


        //
        // Open the user object.
        //

        Status = SamOpenUser(
                     DomainHandle,
                     USER_CHANGE_PASSWORD,
                     *UserId,
                     &UserHandle
                     );

        if ( !NT_SUCCESS(Status) ) {
            KdPrint(("XsChangePasswordSam: Cannot open user %wZ, "
                     "status %8.8x\n", UserName, Status));
            goto Cleanup;
        }

        if (Encrypted) {

            //
            // The client is Windows for Workgroups, OS/2, or DOS running
            // the ENCRYPT service.  Pass the cross-encrypted passwords
            // to SamiLmChangePasswordUser.
            //

            Status = SamiLmChangePasswordUser(
                         UserHandle,
                         OldPassword,
                         NewPassword
                         );
        } else {

            //
            // The client is DOS not running the ENCRYPT service, and so
            // sent plaintext.  Calculate the one-way functions and call
            // SamiChangePasswordUser.
            //

            LM_OWF_PASSWORD OldLmOwfPassword, NewLmOwfPassword;

            Status = RtlCalculateLmOwfPassword(
                         OldPassword,
                         &OldLmOwfPassword
                         );

            if (NT_SUCCESS(Status)) {

                Status = RtlCalculateLmOwfPassword(
                             NewPassword,
                             &NewLmOwfPassword
                             );
            }

            if (!NT_SUCCESS(Status)) {
                KdPrint(("XsChangePasswordSam: Unable to generate OWF "
                         "passwords, %8.8x\n", Status));
                goto Cleanup;
            }


            //
            // Ask SAM to change the LM password and not store a new
            // NT password.
            //

            Status = SamiChangePasswordUser(
                         UserHandle,
                         TRUE,
                         &OldLmOwfPassword,
                         &NewLmOwfPassword,
                         FALSE,
                         NULL,
                         NULL
                         );

        }

        if ( !NT_SUCCESS(Status) ) {
            KdPrint(("XsChangePasswordSam: Cannot change password "
                     "for %wZ, status %8.8x\n", UserName, Status));

            goto Cleanup;
        }

    } except (Status = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER) {

        KdPrint(("XsChangePasswordSam: caught exception 0x%8.8x\n", Status));

        if (RPC_S_SERVER_UNAVAILABLE == Status) {
            Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
        }

    }

Cleanup:

    NetApiBufferFree( serverName );

    if (DomainNameAllocated && DomainName.Buffer) {
        RtlFreeHeap(RtlProcessHeap(), 0, DomainName.Buffer);
    }

    if (DomainSid) {
        SamFreeMemory(DomainSid);
    }

    if (UserId) {
        SamFreeMemory(UserId);
    }

    if (NameUse) {
        SamFreeMemory(NameUse);
    }

    if (UserHandle) {
        SamCloseHandle(UserHandle);
    }

    if (DomainHandle) {
        SamCloseHandle(DomainHandle);
    }

    if (SamHandle) {
        SamCloseHandle(SamHandle);
    }

    return RtlNtStatusToDosError(Status);
}

NTSTATUS
XsSamOEMChangePasswordUser2_P (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to SamrOemChangePasswordUser2 coming in
        from Win 95 clients

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    PXS_SAMOEMCHGPASSWORDUSER2_P  parameters = Parameters;
    STRING                        UserName;
    SAMPR_ENCRYPTED_USER_PASSWORD EncryptedUserPassword;
    ENCRYPTED_LM_OWF_PASSWORD     EncryptedOwfPassword;
    NTSTATUS                      ntstatus;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        if( SmbGetUshort( &parameters->BufLen ) !=
            sizeof( EncryptedUserPassword) + sizeof( EncryptedOwfPassword ) ) {

                Header->Status = ERROR_INVALID_PARAMETER;
                return STATUS_SUCCESS;
        }

        RtlCopyMemory( &EncryptedUserPassword,
                       parameters->Buffer,
                       sizeof( EncryptedUserPassword ) );

        RtlCopyMemory( &EncryptedOwfPassword,
                       parameters->Buffer + sizeof( EncryptedUserPassword ),
                       sizeof( EncryptedOwfPassword ) );

        UserName.Buffer = parameters->UserName;
        UserName.Length = (USHORT) strlen( UserName.Buffer );
        UserName.MaximumLength = UserName.Length;

        ntstatus = SamiOemChangePasswordUser2(
                NULL,
                &UserName,
                &EncryptedUserPassword,
                &EncryptedOwfPassword );


        if( ntstatus == STATUS_NOT_SUPPORTED ) {
            Header->Status = NERR_InvalidAPI;
        } else {
            Header->Status = (WORD)NetpNtStatusToApiStatus( ntstatus );
        }

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    return STATUS_SUCCESS;

} // XsSamOEMChangePasswordUser2_P


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//  Internal function implementation.                                      //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

//
// Copied from ntos\dll\seurtl.c, where it is disabled.  Remove if
// it is enabled in ntdll.
//

NTSTATUS
RtlGetPrimaryDomain(
    IN  ULONG            SidLength,
    OUT PBOOLEAN         PrimaryDomainPresent,
    OUT PUNICODE_STRING  PrimaryDomainName,
    OUT PUSHORT          RequiredNameLength,
    OUT PSID             PrimaryDomainSid OPTIONAL,
    OUT PULONG           RequiredSidLength
    )

/*++

Routine Description:

    This procedure opens the LSA policy object and retrieves
    the primary domain information for this machine.

Arguments:

    SidLength - Specifies the length of the PrimaryDomainSid
        parameter.

    PrimaryDomainPresent - Receives a boolean value indicating
        whether this machine has a primary domain or not. TRUE
        indicates the machine does have a primary domain. FALSE
        indicates the machine does not.

    PrimaryDomainName - Points to the unicode string to receive
        the primary domain name.  This parameter will only be
        used if there is a primary domain.

    RequiredNameLength - Recevies the length of the primary
        domain name (in bytes).  This parameter will only be
        used if there is a primary domain.

    PrimaryDomainSid - This optional parameter, if present,
        points to a buffer to receive the primary domain's
        SID.  This parameter will only be used if there is a
        primary domain.

    RequiredSidLength - Recevies the length of the primary
        domain SID (in bytes).  This parameter will only be
        used if there is a primary domain.


Return Value:

    STATUS_SUCCESS - The requested information has been retrieved.

    STATUS_BUFFER_TOO_SMALL - One of the return buffers was not
        large enough to receive the corresponding information.
        The RequiredNameLength and RequiredSidLength parameter
        values have been set to indicate the needed length.

    Other status values as may be returned by:

        LsaOpenPolicy()
        LsaQueryInformationPolicy()
        RtlCopySid()


--*/
{
    NTSTATUS Status, IgnoreStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo;


    //
    // Set up the Security Quality Of Service
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes to open the Lsa policy object
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0L,
                               (HANDLE)NULL,
                               NULL);
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open the local LSA policy object
    //

    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &LsaHandle
                          );
    if (NT_SUCCESS(Status)) {

        //
        // Get the primary domain info
        //
        Status = LsaQueryInformationPolicy(LsaHandle,
                                           PolicyPrimaryDomainInformation,
                                           (PVOID *)&PrimaryDomainInfo);
        IgnoreStatus = LsaClose(LsaHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    if (NT_SUCCESS(Status)) {

        //
        // Is there a primary domain?
        //

        if (PrimaryDomainInfo->Sid != NULL) {

            //
            // Yes
            //

            (*PrimaryDomainPresent) = TRUE;
            (*RequiredNameLength) = PrimaryDomainInfo->Name.Length;
            (*RequiredSidLength)  = RtlLengthSid(PrimaryDomainInfo->Sid);



            //
            // Copy the name
            //

            if (PrimaryDomainName->MaximumLength >=
                PrimaryDomainInfo->Name.Length) {
                RtlCopyUnicodeString(
                    PrimaryDomainName,
                    &PrimaryDomainInfo->Name
                    );
            } else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }


            //
            // Copy the SID (if appropriate)
            //

            if (PrimaryDomainSid != NULL && NT_SUCCESS(Status)) {

                Status = RtlCopySid(SidLength,
                                    PrimaryDomainSid,
                                    PrimaryDomainInfo->Sid
                                    );
            }
        } else {

            (*PrimaryDomainPresent) = FALSE;
        }

        //
        // We're finished with the buffer returned by LSA
        //

        IgnoreStatus = LsaFreeMemory(PrimaryDomainInfo);
        ASSERT(NT_SUCCESS(IgnoreStatus));

    }


    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apiwksta.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ApiWksta.c

Abstract:

    This module contains individual API handlers for the NetWksta
    APIs.

    SUPPORTED : NetWkstaGetInfo, NetWkstaSetInfo.

    UNSUPPORTED : NetWkstaSetUid.

    SEE ALSO : NetWkstaUserLogon, NetWkstaUserLogoff - in ApiLogon.c.

Author:

    Shanku Niyogi (w-shanku) 25-Feb-1991

Revision History:

--*/

#include "XactSrvP.h"

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_wksta_info_0 = REM16_wksta_info_0;
STATIC const LPDESC Desc16_wksta_info_1 = REM16_wksta_info_1;
STATIC const LPDESC Desc16_wksta_info_10 = REM16_wksta_info_10;

//
// The size of the heuristics is actually 55 chars but we add one
// for padding.
//

#define  SIZE_HEURISTICS            56

NTSTATUS
XsNetWkstaGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine sets up a call to NetWkstaGetInfo. Because of the differences
    between 16- and 32-bit structures, this routine does not use the normal
    conversion process.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_WKSTA_GET_INFO parameters = Parameters;
    LPWKSTA_INFO_100 wksta_100 = NULL;      // Native parameters
    LPWKSTA_INFO_101 wksta_101 = NULL;
    LPWKSTA_INFO_502 wksta_502 = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    BOOL varWrite;
    LPWKSTA_16_INFO_1 entry1;
    LPWKSTA_16_INFO_10 entry10;
    TCHAR heuristics[SIZE_HEURISTICS];
    DWORD i;
    USHORT level;

    WCHAR lanroot[PATHLEN+1];

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(WKSTA) {
        NetpKdPrint(( "XsNetWkstaGetInfo: header at %lx, "
                      "params at %lx, level %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Check for errors.
        //

        level = SmbGetUshort( &parameters->Level );
        if ( (level != 0) && (level != 1) && (level != 10) ) {
            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // we return the system directory as the lanroot
        //

        *lanroot = 0;
        GetSystemDirectory(lanroot, sizeof(lanroot)/sizeof(*lanroot));

        //
        // Gather the requested data by making local GetInfo calls.
        //

        switch ( level ) {

        case 10:
            status = NetWkstaGetInfo(
                         NULL,
                         (DWORD)100,
                         (LPBYTE *)&wksta_100
                         );

            if ( !XsApiSuccess ( status )) {

                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsWkstaGetInfo: WkstaGetInfo (level 100) "
                                  "failed: %X\n", status));
                }

                Header->Status = (WORD) status;
                goto cleanup;
            }

            break;

        case 0:
        case 1:
            status = NetWkstaGetInfo(
                         NULL,
                         (DWORD)101,
                         (LPBYTE *)&wksta_101
                         );

            if ( !XsApiSuccess( status )) {

                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsWkstaGetInfo: WkstaGetInfo (level 101) "
                                  "failed: %X\n", status));
                }

                Header->Status = (WORD) status;
                goto cleanup;
            }

            status = NetWkstaGetInfo(
                         NULL,
                         (DWORD)502,
                         (LPBYTE *)&wksta_502
                         );

            if ( !XsApiSuccess( status )) {

                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsWkstaGetInfo: WkstaGetInfo (level 502) "
                                  "failed: %X\n", status));
                }

                Header->Status = (WORD) status;
                goto cleanup;
            }

            break;

        }

        //
        // Calculate the amount of space required to hold the fixed and
        // variable data. Since this is the only place where we get one
        // case for each valid level, we will also get the source structure
        // descriptor here.
        //

        switch ( level ) {

        case 0:

            StructureDesc = Desc16_wksta_info_0;
            bytesRequired = sizeof( WKSTA_16_INFO_0 )
                                + NetpUnicodeToDBCSLen( lanroot )
                                + NetpUnicodeToDBCSLen( wksta_101->wki101_computername )
                                + NetpUnicodeToDBCSLen( DEF16_wk_username )
                                + NetpUnicodeToDBCSLen( wksta_101->wki101_langroup )
                                + NetpUnicodeToDBCSLen( DEF16_wk_logon_server )
                                + SIZE_HEURISTICS
                                + 6;  // for terminating nulls
            break;

        case 1:

            StructureDesc = Desc16_wksta_info_1;
            bytesRequired = sizeof( WKSTA_16_INFO_1 )
                                + NetpUnicodeToDBCSLen( lanroot )
                                + NetpUnicodeToDBCSLen( wksta_101->wki101_computername )
                                + NetpUnicodeToDBCSLen( DEF16_wk_username )
                                + NetpUnicodeToDBCSLen( wksta_101->wki101_langroup )
                                + NetpUnicodeToDBCSLen( DEF16_wk_logon_server )
                                + SIZE_HEURISTICS
                                + NetpUnicodeToDBCSLen( DEF16_wk_logon_domain )
                                + NetpUnicodeToDBCSLen( DEF16_wk_oth_domains )
                                + 8;  // for terminating nulls

            break;

        case 10:

            StructureDesc = Desc16_wksta_info_10;
            bytesRequired = sizeof( WKSTA_16_INFO_10 )
                                + NetpUnicodeToDBCSLen( DEF16_wk_username )
                                + NetpUnicodeToDBCSLen( DEF16_wk_logon_domain )
                                + NetpUnicodeToDBCSLen( wksta_100->wki100_computername )
                                + NetpUnicodeToDBCSLen( wksta_100->wki100_langroup )
                                + NetpUnicodeToDBCSLen( DEF16_wk_oth_domains )
                                + 5;  // for terminating nulls
            break;
        }

        //
        // If there isn't enough room in the buffer for this, don't write any
        // variable data.
        //

        varWrite = ( (DWORD)SmbGetUshort( &parameters->BufLen )
                         >= bytesRequired ) ? TRUE : FALSE;

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                             + RapStructureSize( StructureDesc, Response, FALSE ));

        //
        // Return NERR_BufTooSmall if fixed structure will not fit.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetWkstaGetInfo: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );
            goto cleanup;

        }

        //
        // Based on the level, fill the appropriate information directly into
        // 16-bit buffer.
        //

        entry1 = (LPWKSTA_16_INFO_1) XsSmbGetPointer( &parameters->Buffer );
        entry10 = (LPWKSTA_16_INFO_10) entry1;

        switch ( level ) {

        case 1:

            if ( varWrite ) {
                XsAddVarString(
                    stringLocation,
                    DEF16_wk_logon_domain,
                    &entry1->wki1_logon_domain,
                    entry1
                    );
                XsAddVarString(
                    stringLocation,
                    DEF16_wk_oth_domains,
                    &entry1->wki1_oth_domains,
                    entry1
                    );
            }
            SmbPutUshort( &entry1->wki1_numdgrambuf,
                          DEF16_wk_numdgrambuf );

            //
            // Fill the rest of the level 1 structure just like a
            // level 0 structure.
            //

        case 0:

            //
            // Zero the reserved words.
            //

            SmbPutUshort( &entry1->wki1_reserved_1, (WORD) 0 );
            SmbPutUlong( &entry1->wki1_reserved_2, (DWORD) 0 );
            SmbPutUlong( &entry1->wki1_reserved_3, (DWORD) 0 );
            SmbPutUshort( &entry1->wki1_reserved_4, (WORD) 0 );
            SmbPutUshort( &entry1->wki1_reserved_5, (WORD) 0 );
            SmbPutUshort( &entry1->wki1_reserved_6, (WORD) 0 );

            //
            // Fill in the fields which have analogues in NT.
            //

            if ( varWrite ) {
                XsAddVarString(
                    stringLocation,
                    lanroot,
                    &entry1->wki1_root,
                    entry1
                    );
                XsAddVarString(
                    stringLocation,
                    wksta_101->wki101_computername,
                    &entry1->wki1_computername,
                    entry1
                    );
                XsAddVarString(
                    stringLocation,
                    wksta_101->wki101_langroup,
                    &entry1->wki1_langroup,
                    entry1
                    );
            }

            entry1->wki1_ver_major = (BYTE) wksta_101->wki101_ver_major;
            entry1->wki1_ver_minor = (BYTE) wksta_101->wki101_ver_minor;

            SmbPutUshort( &entry1->wki1_charwait,
                          XsDwordToWord( wksta_502->wki502_char_wait ) );
            SmbPutUlong( &entry1->wki1_chartime,
                         (DWORD) wksta_502->wki502_collection_time );
            SmbPutUshort( &entry1->wki1_charcount,
                          XsDwordToWord( wksta_502->
                                             wki502_maximum_collection_count ) );
            SmbPutUshort( &entry1->wki1_keepconn,
                          XsDwordToWord( wksta_502->wki502_keep_conn ) );
            SmbPutUshort( &entry1->wki1_maxthreads,
                          XsDwordToWord( wksta_502->wki502_max_threads ) );
            SmbPutUshort( &entry1->wki1_maxcmds,
                          XsDwordToWord( wksta_502->wki502_max_cmds ) );
            SmbPutUshort( &entry1->wki1_sesstimeout,
                          XsDwordToWord( wksta_502->wki502_sess_timeout ) );

            //
            // Construct the heuristics string.
            //

            // Request opportunistic locking of files.
            heuristics[0] = MAKE_TCHAR(XsBoolToDigit(
                                wksta_502->wki502_use_opportunistic_locking ));
            // Optimize performance for command files.
            heuristics[1] = MAKE_TCHAR('1');
            // Unlock and WriteUnlock asynchronously.
            heuristics[2] = MAKE_TCHAR('1'); // default
            // Close and WriteClose asynchronously.
            heuristics[3] = MAKE_TCHAR('1'); // default
            // Buffer named pipes and communication devices.
            heuristics[4] = MAKE_TCHAR(XsBoolToDigit(
                                wksta_502->wki502_buf_named_pipes ));
            // LockRead and WriteUnlock.
            heuristics[5] = MAKE_TCHAR(XsBoolToDigit(
                                wksta_502->wki502_use_lock_read_unlock ));
            // Use Open and Read.
            heuristics[6] = MAKE_TCHAR('0');
            // Read-ahead to sector boundary.
            heuristics[7] = MAKE_TCHAR('1');
            // Use the "chain send" NetBIOS NCB.
            heuristics[8] = MAKE_TCHAR('2');
            // Buffer small read/write requests.
            heuristics[9] = MAKE_TCHAR('1');
            // Use buffer mode.
            heuristics[10] = MAKE_TCHAR('3');
            // Use raw data transfer read/write server message block protocols.
            heuristics[11] = MAKE_TCHAR('1');
            // Use large RAW read-ahead buffer.
            heuristics[12] = MAKE_TCHAR('1');
            // Use large RAW write-behind buffer.
            heuristics[13] = MAKE_TCHAR('1');
            // Use read multiplex SMB protocols.
            heuristics[14] = MAKE_TCHAR('0');
            // Use write multiplex SMB protocols.
            heuristics[15] = MAKE_TCHAR('0');
            // Use big buffer for large core reads.
            heuristics[16] = MAKE_TCHAR('1');
            // Set the read-ahead size.
            heuristics[17] = MAKE_TCHAR('0');
            // Set the write-behind size.
            heuristics[18] = MAKE_TCHAR('0');
            // Force 512-byte maximum transfers to and from core servers.
            heuristics[19] = MAKE_TCHAR(XsBoolToDigit(
                                 wksta_502->wki502_use_512_byte_max_transfer ));
            // Flush pipes and devices on DosBufReset or DosClose.
            heuristics[20] = MAKE_TCHAR('0');
            // Use encryption if the server supports it.
            heuristics[21] = MAKE_TCHAR(XsBoolToDigit(
                                 wksta_502->wki502_use_encryption ));
            // Control log entries for multiple occurences of an error.
            heuristics[22] = MAKE_TCHAR('1');
            // Buffer all files opened with "deny write" rights.
            heuristics[23] = MAKE_TCHAR(XsBoolToDigit(
                                 wksta_502->wki502_buf_files_deny_write ));
            // Buffer all files opened with R attribute.
            heuristics[24] = MAKE_TCHAR(XsBoolToDigit(
                                 wksta_502->wki502_buf_read_only_files ));
            // Read ahead when opening a file for execution.
            heuristics[25] = MAKE_TCHAR('0');
            // Handle Ctrl-C.
            heuristics[26] = MAKE_TCHAR('2');
            // Force correct open mode when creating files on a core server.
            heuristics[27] = MAKE_TCHAR(XsBoolToDigit(
                                 wksta_502->wki502_force_core_create_mode ));
            // Use NetBIOS NoAck mode.
            heuristics[28] = MAKE_TCHAR('0');
            // Send data along with SMB write-block-RAW requests.
            heuristics[29] = MAKE_TCHAR('1');
            // Send a popup when the workstation logs an error.
            heuristics[30] = MAKE_TCHAR('1');
            // Close the print job, causing the remote spooler to print if no
            // activity occurs on the printer for the time specified.
            heuristics[31] = MAKE_TCHAR('0');
            // Controls BufReset and SMBFlush behavior for the MS-DOS
            // compatibility box.
            heuristics[32] = MAKE_TCHAR('2');
            // Controls the time-out value for performing logon validation from a
            // domain controller.
            heuristics[33] = MAKE_TCHAR('0');

            for ( i = 34; i <= 54; i++ ) {
                heuristics[i] = MAKE_TCHAR('0');
            }

            heuristics[SIZE_HEURISTICS-1] = MAKE_TCHAR('\0');

            if ( varWrite ) {
                XsAddVarString(
                    stringLocation,
                    heuristics,
                    &entry1->wki1_wrkheuristics,
                    entry1
                    );
            }

            //
            // Put default values in the fields that are meaningless in NT.
            //

            if ( varWrite ) {
                XsAddVarString(
                    stringLocation,
                    DEF16_wk_logon_server,
                    &entry1->wki1_logon_server,
                    entry1
                    );
                XsAddVarString(
                    stringLocation,
                    DEF16_wk_username,
                    &entry1->wki1_username,
                    entry1
                    );
            }

            SmbPutUshort( &entry1->wki1_keepsearch,
                          (WORD) DEF16_wk_keepsearch );
            SmbPutUshort( &entry1->wki1_numworkbuf,
                          (WORD) DEF16_wk_numworkbuf );
            SmbPutUshort( &entry1->wki1_sizworkbuf,
                          (WORD) DEF16_wk_sizeworkbuf );
            SmbPutUshort( &entry1->wki1_maxwrkcache,
                          (WORD) DEF16_wk_maxwrkcache );
            SmbPutUshort( &entry1->wki1_sizerror,
                          (WORD) DEF16_wk_sizerror );
            SmbPutUshort( &entry1->wki1_numalerts,
                          (WORD) DEF16_wk_numalerts );
            SmbPutUshort( &entry1->wki1_numservices,
                          (WORD) DEF16_wk_numservices );
            SmbPutUshort( &entry1->wki1_errlogsz,
                          (WORD) DEF16_wk_errlogsz );
            SmbPutUshort( &entry1->wki1_printbuftime,
                          (WORD) DEF16_wk_printbuftime );
            SmbPutUshort( &entry1->wki1_numcharbuf,
                          (WORD) DEF16_wk_numcharbuf );
            SmbPutUshort( &entry1->wki1_sizcharbuf,
                          (WORD) DEF16_wk_sizcharbuf );
            SmbPutUshort( &entry1->wki1_mailslots,
                          (WORD) DEF16_wk_mailslots );

            break;

        case 10:

            //
            // Fill in the fields which have analogues in NT.
            //


            if ( varWrite ) {
                XsAddVarString(
                    stringLocation,
                    wksta_100->wki100_computername,
                    &entry10->wki10_computername,
                    entry10
                    );
                XsAddVarString(
                    stringLocation,
                    wksta_100->wki100_langroup,
                    &entry10->wki10_langroup,
                    entry10
                    );
            }

            entry10->wki10_ver_major = XsDwordToByte( wksta_100->wki100_ver_major );
            entry10->wki10_ver_minor = XsDwordToByte( wksta_100->wki100_ver_minor );

            //
            // Put default values in the fields that are meaningless in NT.
            //


            if ( varWrite ) {
                XsAddVarString(
                    stringLocation,
                    DEF16_wk_username,
                    &entry10->wki10_username,
                    entry10
                    );
                XsAddVarString(
                    stringLocation,
                    DEF16_wk_logon_domain,
                    &entry10->wki10_logon_domain,
                    entry10
                    );
                XsAddVarString(
                    stringLocation,
                    DEF16_wk_oth_domains,
                    &entry10->wki10_oth_domains,
                    entry10
                    );
            }

            break;
        }

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

        if ( varWrite == 0 ) {
            Header->Status = ERROR_MORE_DATA;
        } else {
            Header->Status = NERR_Success;
            Header->Converter = 0;
        }

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    if ( wksta_100 != NULL ) {
        NetApiBufferFree( wksta_100 );
    }

    if ( wksta_101 != NULL ) {
        NetApiBufferFree( wksta_101 );
    }

    if ( wksta_502 != NULL ) {
        NetApiBufferFree( wksta_502 );
    }

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetWkstaGetInfo



NTSTATUS
XsNetWkstaSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetWkstaSetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{

    NET_API_STATUS status;

    PXS_NET_WKSTA_SET_INFO parameters = Parameters;
    DWORD data;
    BOOL flag;
    DWORD nativeParmNum;

    LPVOID buffer = NULL;                   // Conversion variables
    DWORD bufferSize;
    LPWKSTA_16_INFO_1 entry1;
    LPWKSTA_16_INFO_10 entry10;
    BOOL error;
    DWORD parmNum;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Check for errors. We will filter out wrong levels now.
        //

        parmNum = SmbGetUshort( &parameters->ParmNum );

        switch ( SmbGetUshort( &parameters->Level )) {

        case 0:
            StructureDesc = Desc16_wksta_info_0;
            if ( parmNum == WKSTA_OTH_DOMAINS_PARMNUM ) {
                Header->Status = ERROR_INVALID_LEVEL;
                goto cleanup;
            }

            break;

        case 1:
            StructureDesc = Desc16_wksta_info_1;
            break;

        case 10:
            StructureDesc = Desc16_wksta_info_10;
            if ( parmNum == WKSTA_CHARWAIT_PARMNUM
                 || parmNum == WKSTA_CHARTIME_PARMNUM
                 || parmNum == WKSTA_CHARCOUNT_PARMNUM
                 || parmNum == WKSTA_ERRLOGSZ_PARMNUM
                 || parmNum == WKSTA_PRINTBUFTIME_PARMNUM
                 || parmNum == WKSTA_WRKHEURISTICS_PARMNUM ) {

                Header->Status = ERROR_INVALID_LEVEL;
                goto cleanup;
            }

            break;

        default:

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
            break;
        }

        //
        // Check input buffer size if parmnum is PARMNUM_ALL.
        //

        if ( parmNum == PARMNUM_ALL ) {

            if ( !XsCheckBufferSize(
                      SmbGetUshort( &parameters->BufLen ),
                      StructureDesc,
                      FALSE  // not in native format
                      )) {
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }
        }

        buffer = (LPVOID)XsSmbGetPointer( &parameters->Buffer );
        bufferSize = (DWORD)SmbGetUshort( &parameters->BufLen );
        entry1 = (LPWKSTA_16_INFO_1)buffer;
        entry10 = (LPWKSTA_16_INFO_10)buffer;

        //
        // Processing of this API depends on the value of the ParmNum
        // parameter. Because of all the discrepancies between NT and downlevel
        // info structures, we will handle each instance by hand.
        //

        error = TRUE;

        //
        // charwait - source data is in a WORD - convert to DWORD
        //

        if ( parmNum == PARMNUM_ALL || parmNum == WKSTA_CHARWAIT_PARMNUM ) {

            if ( bufferSize < sizeof(WORD) ) {
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            data = ( parmNum == PARMNUM_ALL )
                       ? (DWORD)SmbGetUshort( &entry1->wki1_charwait )
                       : (DWORD)SmbGetUshort( (LPWORD)buffer );

            status = NetWkstaSetInfo(
                         NULL,
                         PARMNUM_BASE_INFOLEVEL + WKSTA_CHARWAIT_PARMNUM,
                         (LPBYTE)&data,
                         NULL
                         );

            if ( status != NERR_Success ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetWkstaSetInfo : SetInfo of charwait failed"
                                  "%X\n", status ));
                }
                Header->Status = (WORD)status;
                goto cleanup;
            }

            error = FALSE;
        }

        //
        // chartime - source data is in a DWORD - convert to DWORD
        //

        if ( parmNum == PARMNUM_ALL || parmNum == WKSTA_CHARTIME_PARMNUM ) {

            if ( bufferSize < sizeof(DWORD) ) {
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            data = ( parmNum == PARMNUM_ALL )
                       ? SmbGetUlong( &entry1->wki1_chartime )
                       : SmbGetUlong( (LPDWORD)buffer );

            status = NetWkstaSetInfo(
                         NULL,
                         PARMNUM_BASE_INFOLEVEL + WKSTA_CHARTIME_PARMNUM,
                         (LPBYTE)&data,
                         NULL
                         );

            if ( status != NERR_Success ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetWkstaSetInfo : SetInfo of chartime failed"
                                  "%X\n", status ));
                }
                Header->Status = (WORD)status;
                goto cleanup;
            }

            error = FALSE;
        }

        //
        // charcount - source data is in a WORD - convert to DWORD
        //

        if ( parmNum == PARMNUM_ALL || parmNum == WKSTA_CHARCOUNT_PARMNUM ) {

            if ( bufferSize < sizeof(WORD) ) {
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            data = ( parmNum == PARMNUM_ALL )
                       ? (DWORD)SmbGetUshort( &entry1->wki1_charcount )
                       : (DWORD)SmbGetUshort( (LPWORD)buffer );

            status = NetWkstaSetInfo(
                         NULL,
                         PARMNUM_BASE_INFOLEVEL + WKSTA_CHARCOUNT_PARMNUM,
                         (LPBYTE)&data,
                         NULL
                         );

            if ( status != NERR_Success ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetWkstaSetInfo : SetInfo of charcount failed"
                                  "%X\n", status ));
                }
                Header->Status = (WORD)status;
                goto cleanup;
            }

            error = FALSE;
        }

        //
        // errlogsz, printbuftime - source data is in a WORD.
        //
        // We can't set this, but downlevel can, so indicate success,
        // as long as something was sent.
        //

        if ( parmNum == PARMNUM_ALL || parmNum == WKSTA_ERRLOGSZ_PARMNUM
                                    || parmNum == WKSTA_PRINTBUFTIME_PARMNUM ) {

            if ( bufferSize < sizeof(WORD) ) {
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            error = FALSE;
        }

        //
        // othdomains - source data is a string.
        //
        // We can't set this, but downlevel can, so indicate success,
        // as long as something was sent.
        //

        if ( parmNum == PARMNUM_ALL || parmNum == WKSTA_OTH_DOMAINS_PARMNUM ) {

            if ( bufferSize == 0 ) {
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            error = FALSE;
        }

        //
        // wrkheuristics - source data is in a string.
        //
        // There are some elements of this that we can set. We go through a loop,
        // setting these.
        //

        if ( parmNum == PARMNUM_ALL || parmNum == WKSTA_WRKHEURISTICS_PARMNUM ) {

            LPBYTE heuristics;
            DWORD i;

            if ( bufferSize < 54 ) {
                Header->Status = NERR_BufTooSmall;
                goto cleanup;
            }

            heuristics = ( parmNum == PARMNUM_ALL )
                             ? (LPBYTE)XsSmbGetPointer( &entry1->wki1_wrkheuristics )
                             : (LPBYTE)buffer;

            //
            // Nothing to be changed
            //

            if ( heuristics == NULL ) {
                goto cleanup;
            }

            //
            // Make sure we have the right size of string.
            //

            if ( strlen( heuristics ) != 54 ) {

                Header->Status = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

            for ( i = 0; i < 54; i++ ) {

                //
                // Make sure heuristics string is valid.
                //

                if ( !isdigit( heuristics[i] )) {

                    Header->Status = ERROR_INVALID_PARAMETER;
                    goto cleanup;
                }

                //
                // Check if we can set this field.
                //

                switch ( i ) {

                case 0:
                    nativeParmNum = WKSTA_USEOPPORTUNISTICLOCKING_PARMNUM;
                    break;
                case 4:
                    nativeParmNum = WKSTA_BUFFERNAMEDPIPES_PARMNUM;
                    break;
                case 5:
                    nativeParmNum = WKSTA_USELOCKANDREADANDUNLOCK_PARMNUM;
                    break;
                case 19:
                    nativeParmNum = WKSTA_USE512BYTESMAXTRANSFER_PARMNUM;
                    break;
                case 21:
                    nativeParmNum = WKSTA_USEENCRYPTION_PARMNUM;
                    break;
                case 23:
                    nativeParmNum = WKSTA_BUFFILESWITHDENYWRITE_PARMNUM;
                    break;
                case 24:
                    nativeParmNum = WKSTA_BUFFERREADONLYFILES_PARMNUM;
                    break;
                case 27:
                    nativeParmNum = WKSTA_FORCECORECREATEMODE_PARMNUM;
                    break;
                default:
                    nativeParmNum = 0;
                    break;

                }

                //
                // If we can set the field, set it.
                //

                if ( nativeParmNum != 0 ) {

                    if ( heuristics[i] != '0' && heuristics[i] != '1' ) {

                        Header->Status = ERROR_INVALID_PARAMETER;
                        goto cleanup;
                    }

                    flag = XsDigitToBool( heuristics[i] );

                    status = NetWkstaSetInfo(
                                 NULL,
                                 PARMNUM_BASE_INFOLEVEL + nativeParmNum,
                                 (LPBYTE)&flag,
                                 NULL
                                 );

                    if ( status != NERR_Success ) {
                        IF_DEBUG(ERRORS) {
                            NetpKdPrint(( "XsNetWkstaSetInfo : SetInfo of a "
                                          "heuristic failed: %X\n", status ));
                        }
                        Header->Status = (WORD)status;
                        goto cleanup;
                    }
                }
            }

            error = FALSE;
        }

        //
        // Tried all possible parmnums. If error is still set, we have an
        // invalid parmnum on our hands.
        //

        if ( error ) {

            Header->Status = ERROR_INVALID_PARAMETER;

        }

        //
        // No return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    return STATUS_SUCCESS;

} // XsNetWkstaSetInfo


NTSTATUS
XsNetWkstaSetUID (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This temporary routine just returns STATUS_NOT_IMPLEMENTED.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    Header->Status = (WORD)NERR_InvalidAPI;

    return STATUS_SUCCESS;

} // XsNetWkstaSetUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\changepw.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ChangePw.h

Abstract:

    This module implements password change from downlevel clients.
    XsChangePasswordSam is called by XsNetUserPasswordSet2 in
    apiuser.c.  I've put this in a seperate file because it #includes
    a private SAM header.

Author:

    Dave Hart (davehart) 31-Apr-1992

Revision History:

--*/

NET_API_STATUS
XsChangePasswordSam (
    IN PUNICODE_STRING UserName,
    IN PVOID OldPassword,
    IN PVOID NewPassword,
    IN BOOLEAN Encrypted
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\apiuser.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ApiUser.c

Abstract:

    This module contains individual API handlers for the NetUser APIs.

    SUPPORTED : NetUserAdd2, NetUserDel, NetUserEnum, NetUserEnum2,
                NetUserGetGroups, NetUserGetInfo, NetUserModalsGet,
                NetUserModalsSet, NetUserSetGroups, NetUserSetInfo2,
                NetUserSetInfo, NetUserPasswordSet2

    UNSUPPORTED :  NetUserValidate2.

Author:

    Shanku Niyogi (w-shanku) 11-Feb-1991

Revision History:

--*/

//
// NetUser APIs are UNICODE only.
//

#ifndef UNICODE
#define UNICODE
#endif

#include "xactsrvp.h"
#include <crypt.h>
#include "changepw.h"
#include <loghours.h>
#include <netlibnt.h>
#include <names.h>
#include <prefix.h>     // PREFIX_ equates.

//
// Declaration of descriptor strings.
//

STATIC const LPDESC Desc16_user_info_0 = REM16_user_info_0;
STATIC const LPDESC Desc32_user_info_0 = REM32_user_info_0;

STATIC const LPDESC Desc16_user_info_1 = REM16_user_info_1;
STATIC const LPDESC Desc32_user_info_1 = REM32_user_info_1;
STATIC const LPDESC Desc32_user_info_1_NC = REM32_user_info_1_NOCRYPT;
STATIC const LPDESC Desc32_user_info_1_OWF = REM32_user_info_1_OWF;
STATIC const LPDESC Desc16_user_info_1_setinfo = REM16_user_info_1_setinfo;
STATIC const LPDESC Desc32_user_info_1_setinfo = REM32_user_info_1_setinfo;
STATIC const LPDESC Desc32_user_info_1_setinfo_NC = REM32_user_info_1_setinfo_NOCRYPT;

STATIC const LPDESC Desc16_user_info_2 = REM16_user_info_2;
STATIC const LPDESC Desc32_user_info_2 = REM32_user_info_2;
STATIC const LPDESC Desc32_user_info_2_NC = REM32_user_info_2_NOCRYPT;
STATIC const LPDESC Desc16_user_info_2_setinfo = REM16_user_info_2_setinfo;
STATIC const LPDESC Desc32_user_info_2_setinfo = REM32_user_info_2_setinfo;
STATIC const LPDESC Desc32_user_info_2_setinfo_NC = REM32_user_info_2_setinfo_NOCRYPT;

STATIC const LPDESC Desc16_user_info_10 = REM16_user_info_10;
STATIC const LPDESC Desc32_user_info_10 = REM32_user_info_10;
STATIC const LPDESC Desc16_user_info_11 = REM16_user_info_11;
STATIC const LPDESC Desc32_user_info_11 = REM32_user_info_11;
STATIC const LPDESC Desc32_user_info_22 = REM32_user_info_22;

STATIC const LPDESC Desc16_user_group_info_0 = REM16_group_info_0;
STATIC const LPDESC Desc32_user_group_info_0 = REM32_group_info_0;
STATIC const LPDESC Desc16_user_group_info_0_set
                        = REM16_group_users_info_0_set;
STATIC const LPDESC Desc32_user_group_info_0_set
                        = REM32_group_users_info_0_set;

STATIC const LPDESC Desc16_user_modals_info_0 = REM16_user_modals_info_0;
STATIC const LPDESC Desc32_user_modals_info_0 = REM32_user_modals_info_0;
STATIC const LPDESC Desc16_user_modals_info_0_setinfo
                        = REM16_user_modals_info_0_setinfo;
STATIC const LPDESC Desc32_user_modals_info_0_setinfo
                        = REM32_user_modals_info_0_setinfo;
STATIC const LPDESC Desc16_user_modals_info_1 = REM16_user_modals_info_1;
STATIC const LPDESC Desc32_user_modals_info_1 = REM32_user_modals_info_1;
STATIC const LPDESC Desc16_user_modals_info_1_setinfo
                        = REM16_user_modals_info_1_setinfo;
STATIC const LPDESC Desc32_user_modals_info_1_setinfo
                        = REM32_user_modals_info_1_setinfo;


STATIC NET_API_STATUS
XsGetMinPasswordLength(
    LPDWORD minPasswordLength
    )
{
    NET_API_STATUS apiStatus;
    LPUSER_MODALS_INFO_0 modals = NULL;
    HANDLE                      OpenedToken;

    NetpAssert( minPasswordLength != NULL );

    //
    // Revert to Local System
    //
    (VOID)NtOpenThreadToken(
                NtCurrentThread(),
                MAXIMUM_ALLOWED,
                TRUE,
                &OpenedToken
            );

    RevertToSelf();

    //
    // Find out how long the password has to be.
    //

    apiStatus = NetUserModalsGet(
            NULL,                       // local (no server name)
            0,                          // level
            (LPBYTE *)&modals );        // alloc and set ptr

    //
    // Re-impersonate the client
    //
    (VOID)NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadImpersonationToken,
                        &OpenedToken,
                        sizeof( OpenedToken )
                        );

    if ( apiStatus != NO_ERROR ) {
        NetpKdPrint(( PREFIX_XACTSRV
                "XsGetMinPasswordLength: Problems getting modals: "
                FORMAT_API_STATUS ".\n", apiStatus ));
        return (apiStatus);
    }
    NetpAssert( modals != NULL );

    *minPasswordLength = modals->usrmod0_min_passwd_len;
    (VOID) NetApiBufferFree( (LPVOID)modals );
    return (NO_ERROR);

} // XsGetMinPasswordLength


STATIC NET_API_STATUS
XsCheckAndReplacePassword (
    IN DWORD Length
    )

/*++

Routine Description

    This routine checks the current password's real length to make sure
    it is valid, and then generates a reasonably random replacement password
    long enough to satisfy the system's modal for minimum password length.
    This routine is used by Add and SetInfo handlers below.

Arguments:

    Length - Real length of the current password.

    Seed - A seed number.

    TempPassword - Receives a pointer to a new temporary password. If
        this is not specified, the new password is not generated.

Return Value:

    NET_API_STATUS - NERR_Success on successful completion, or some other
        error status.

--*/

{
    NET_API_STATUS status;
    DWORD minPasswordLength;

    //
    // Find out how long the password has to be.
    //

    status = XsGetMinPasswordLength( &minPasswordLength );


    if ( status != NERR_Success ) {
        NetpKdPrint(( PREFIX_XACTSRV
                "XsCheckAndReplacePassword: Problems getting min PW len: "
                FORMAT_API_STATUS ".\n", status ));
        return status;
    }

    //
    // Check length of current password.
    //

    if ( Length < minPasswordLength ) {

        return NERR_PasswordTooShort;
    }


    return NERR_Success;

}


NET_API_STATUS
XsNameToRid(
    IN LPCTSTR Name,      // may be user or group name.
    IN SID_NAME_USE ExpectedType,
    OUT PULONG UserRid
    )
{
    NET_API_STATUS status;
    PSID_NAME_USE nameUse;
    NTSTATUS ntstatus;
    UNICODE_STRING unicodeName;
    PULONG tempRid;
    PSID accountsDomainId;
    SAM_HANDLE samConnectHandle;
    SAM_HANDLE samAccountsDomainHandle;

    if( ARGUMENT_PRESENT( UserRid ) ) {
        *UserRid = 0;
    }

    //
    // Get a connection to SAM.
    //

    ntstatus = SamConnect(
                    NULL,                       // no server name (local)
                    &samConnectHandle,          // resulting SAM handle
                    SAM_SERVER_LOOKUP_DOMAIN,   // desired access
                    NULL                        // no object attributes
                    );
    if ( !NT_SUCCESS( ntstatus ) ) {
        status = NetpNtStatusToApiStatus( ntstatus );
        return status;
    }

    //
    // To open the accounts domain, we'll need the domain ID.
    //

    status = NetpGetLocalDomainId (
                LOCAL_DOMAIN_TYPE_ACCOUNTS, // type we want.
                &accountsDomainId
                );
    if ( status != NO_ERROR ) {
        SamCloseHandle( samConnectHandle );
        return status;
    }

    //
    // Open the accounts domain.
    //

    ntstatus = SamOpenDomain(
                    samConnectHandle,
                    DOMAIN_LOOKUP,
                    accountsDomainId,
                    &samAccountsDomainHandle
                    );
    if ( !NT_SUCCESS( ntstatus ) ) {
        LocalFree( accountsDomainId );
        SamCloseHandle( samConnectHandle );
        status = NetpNtStatusToApiStatus( ntstatus );
        return status;
    }

    //
    // Get a RID for this user name.
    //

    RtlInitUnicodeString(
            &unicodeName,       // dest (NT struct)
            Name );             // src (null-terminated)

    ntstatus = SamLookupNamesInDomain(
                    samAccountsDomainHandle,    // users live in accounts domain
                    (ULONG)1,                   // only want one name.
                    &unicodeName,               // name (in NT struct)
                    &tempRid,                   // alloc and set RIDs.
                    &nameUse                    // alloc and set name types.
                    );

    if ( !NT_SUCCESS( ntstatus ) ) {
        status = NetpNtStatusToApiStatus( ntstatus );
        goto cleanup;
    }

    *UserRid = *tempRid;

    //
    // Did type user wanted match the actual one?
    //

    if ( ExpectedType != *nameUse ) {
        status = ERROR_INVALID_PARAMETER;   
    } else {
        status = NO_ERROR;
    }

    //
    // Free memory which SAM allocated for us.
    //

    ntstatus = SamFreeMemory( nameUse );
    if ( !NT_SUCCESS( ntstatus ) ) {
        status = NetpNtStatusToApiStatus( ntstatus );
    }

    ntstatus = SamFreeMemory( tempRid );
    if ( !NT_SUCCESS( ntstatus ) ) {
        status = NetpNtStatusToApiStatus( ntstatus );
    }

cleanup:

    LocalFree( accountsDomainId );
    SamCloseHandle( samAccountsDomainHandle );
    SamCloseHandle( samConnectHandle );

    return status;

} // XsNameToRid


NET_API_STATUS
XsSetMacPrimaryGroup(
    IN LPCTSTR UserName,
    IN LPCTSTR MacPrimaryField   // field in "mGroup:junk" format.
    )
{
    NET_API_STATUS status;
    LPTSTR groupName = NULL;
    ULONG groupRid;
    USER_INFO_1051 userInfo;

    //
    // Extract the primary group name from the Mac field.
    //

    status = NetpGetPrimaryGroupFromMacField(
                MacPrimaryField,              // name in "mGroup:" format.
                &groupName                    // alloc and set ptr.
                );
    if ( status != NO_ERROR ) {
        goto cleanup;
    }

    //
    // Make sure this user is a member of the group (add to group if needed).
    // This will also check if the group and user exist.
    //

    status = NetGroupAddUser(
                NULL,                       // local (no server name)
                groupName,                  // group to update
                (LPTSTR)UserName            // user name to add to group
                );
    if ( (status != NO_ERROR) && (status != NERR_UserInGroup) ) {
        goto cleanup;
    }

    //
    // Convert the group name to a RID.
    //

    status = XsNameToRid(
                (LPCWSTR)groupName,
                SidTypeGroup,       // expected type
                &groupRid
                );
    if ( status != NO_ERROR ) {
        goto cleanup;
    }

    //
    // Call NetUserSetInfo to set the primary group ID using the RID.
    //

    userInfo.usri1051_primary_group_id = (DWORD)groupRid;

    status = NetUserSetInfo (
                NULL,                       // local (no server name)
                (LPTSTR)UserName,
                PARMNUM_BASE_INFOLEVEL + USER_PRIMARY_GROUP_PARMNUM,
                (LPVOID)&userInfo,
                NULL                        // don't care about parmnum
                );

cleanup:

    if ( groupName != NULL ) {
        NetpMemoryFree( groupName );
    }

    return status;

} // XsSetMacPrimaryGroup


NTSTATUS
XsNetUserAdd2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserAdd. A remote NetUserAdd call
    from a 16-bit machine will translate to a NetUserAdd2 call, with
    a doubly encrypted password. We will call a special level of
    NetUserSetInfo to set this later, after the user has been added.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_ADD_2 parameters = Parameters;
    LPVOID buffer = NULL;                   // Native parameters
    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    DWORD bufferSize;
    LPBYTE nativeStructureDesc;
    LPUSER_INFO_1 user = NULL;
    DWORD parmError;
    DWORD level;
    BOOLEAN encryptionSupported = TRUE;
    PUSER_INFO_22 usri22;
    BYTE tempPwdBuffer[ENCRYPTED_PWLEN];

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(USER) {
        NetpKdPrint(( "XsNetUserAdd2: header at %lx, params at %lx, "
                      "level %ld\n",
                      Header, parameters,
                      SmbGetUshort( &parameters->Level ) ));
    }

    try {
        //
        // Check if password is encrypted.  We know for a fact that dos redirs
        // don't support encryption
        //

        encryptionSupported = (BOOLEAN)
                ( SmbGetUshort( &parameters->DataEncryption ) == TRUE );
        level = SmbGetUshort( &parameters->Level );

        //
        // Check for password length
        //

        status = XsCheckAndReplacePassword( (DWORD)( SmbGetUshort( &parameters->PasswordLength )) );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserAdd2: XsCheckAndReplacePassword failed: "
                              "%X\n", status ));
            }
            goto cleanup;
        }

        //
        // Use the requested level to determine the format of the 32-bit
        // we need to pass to NetUserAdd. The format of the
        // 16-bit structure is stored in the transaction block, and we
        // got a pointer to it as a parameter.
        //

        switch ( level ) {

        case 1:
            StructureDesc = Desc16_user_info_1;
            nativeStructureDesc = Desc32_user_info_1_OWF;
            break;

        case 2:
            StructureDesc = Desc16_user_info_2;
            nativeStructureDesc = Desc32_user_info_22;
            break;

        default:
            status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }


        //
        // Figure out if there is enough room in the buffer for all the
        // data required. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserAdd2: Buffer too small.\n" ));
            }
            status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find out how big a buffer we need to allocate to hold the native
        // 32-bit version of the input data structure.  Always allocate
        // a level 22 buffer since we will always be making a level 22
        // call to netuseradd.
        //

        bufferSize = XsBytesForConvertedStructure(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         StructureDesc,
                         Desc32_user_info_22,
                         RapToNative,
                         TRUE
                         );

        //
        // Allocate enough memory to hold the converted native buffer.
        //

        buffer = NetpMemoryAllocate( bufferSize );

        if ( buffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserAdd2: failed to create buffer" ));
            }
            status = NERR_NoRoom;
            goto cleanup;

        }

        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserAdd2: buffer of %ld bytes at %lx\n",
                          bufferSize, buffer ));
        }

        //
        // Convert the buffer from 16-bit to 32-bit.
        //

        stringLocation = (LPBYTE)buffer + bufferSize;
        bytesRequired = 0;

        status = RapConvertSingleEntry(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     buffer,
                     buffer,
                     nativeStructureDesc,
                     FALSE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     RapToNative
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserAdd: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            status = NERR_InternalError;
            goto cleanup;
        }

        usri22 = buffer;

        //
        // If this is a level 1 call, then we did not fill up all the
        // entries required for a level 22 call.  Put the default values
        // here.
        //

        if ( level == 1 ) {

            //
            // These are not used in a NetUserAdd.
            //
            // usri22->usri22_last_logon
            // usri22->usri22_last_logoff
            // usri22->usri22_units_per_week
            // usri22->usri22_bad_pw_count
            // usri22->usri22_num_logons
            //

            usri22->usri22_auth_flags = 0;
            usri22->usri22_full_name = NULL;
            usri22->usri22_usr_comment = NULL;
            usri22->usri22_parms = NULL;
            usri22->usri22_workstations = NULL;
            usri22->usri22_acct_expires = TIMEQ_FOREVER;
            usri22->usri22_max_storage = USER_MAXSTORAGE_UNLIMITED;
            usri22->usri22_logon_hours = NULL;
            usri22->usri22_logon_server = NULL;
            usri22->usri22_country_code = 0;
            usri22->usri22_code_page = 0;

        } else if ( usri22->usri22_logon_hours != NULL ) {

            //
            // Call NetpRotateLogonHours to make sure we behave properly
            // during DST.
            //

            if ( !NetpRotateLogonHours(
                        usri22->usri22_logon_hours,
                        usri22->usri22_units_per_week,
                        TRUE
                        ) ) {

                status = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

        }

        //
        // If the password is clear text, we need to convert it to an OWF
        // password.  This is to fix a LMUNIX bug which forgets to upper
        // case the password it sends across.  Converting it to OWF
        // tells sam not to do upcasing.
        //
        // If the password is encrypted, then we get the owf by decrypting
        // it with the session key.
        //

        RtlCopyMemory(
                tempPwdBuffer,
                usri22->usri22_password,
                ENCRYPTED_PWLEN
                );

        if ( !encryptionSupported ) {

            (VOID) RtlCalculateLmOwfPassword(
                                (PLM_PASSWORD) tempPwdBuffer,
                                (PLM_OWF_PASSWORD) usri22->usri22_password
                                );


        } else {

            (VOID) RtlDecryptLmOwfPwdWithLmSesKey(
                                    (PENCRYPTED_LM_OWF_PASSWORD) tempPwdBuffer,
                                    (PLM_SESSION_KEY) Header->EncryptionKey,
                                    (PLM_OWF_PASSWORD) usri22->usri22_password
                                    );

        }

        //
        // Make the local call.
        //

        status = NetUserAdd(
                         NULL,
                         22,
                         (LPBYTE) usri22,
                         &parmError
                         );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserAdd2: NetUserAdd failed: %X\n", status ));
                if ( status == ERROR_INVALID_PARAMETER ) {
                    NetpKdPrint(( "XsNetUserAdd2: ParmError: %ld\n",
                                  parmError ));

                }
            }
            goto cleanup;
        }

        //
        // If there was a Macintosh primary group field for this user, then
        // set the primary group.
        //

        if ( NetpIsMacPrimaryGroupFieldValid( (LPCTSTR)usri22->usri22_parms ) ) {
            NET_API_STATUS status1;
            status1 = XsSetMacPrimaryGroup(
                        (LPCTSTR)usri22->usri22_name,
                        (LPCTSTR)usri22->usri22_parms
                        );
            if ( !XsApiSuccess( status1 )) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetUserAdd2: SetMacPrimaryGroup failed: %X\n",
                                    status1 ));
                }
            }
        }

        //
        // There is no real return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    Header->Status = (WORD)status;

    NetpMemoryFree( buffer );

    return STATUS_SUCCESS;

} // XsNetUserAdd2


NTSTATUS
XsNetUserDel (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserDel.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_DEL parameters = Parameters;
    LPTSTR nativeUserName = NULL;           // Native parameters

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    IF_DEBUG(USER) {
        NetpKdPrint(( "XsNetUserDel: header at %lx, params at %lx, name %s\n",
                      Header, parameters, SmbGetUlong( &parameters->UserName )));
    }

    try {
        //
        // Translate parameters, check for errors.
        //

        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        //
        // Make the local call.
        //

        status = NetUserDel(
                     NULL,
                     nativeUserName
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserDel: NetUserDel failed: %X\n", status ));
            }
        }

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeUserName );

    //
    // Nothing to return.
    //

    Header->Status = (WORD)status;

    return STATUS_SUCCESS;
}


NTSTATUS
XsNetUserEnum (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description

    This routine handles a call to NetUserEnum.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_ENUM parameters = Parameters;
    LPVOID outBuffer = NULL;                // Native parameters
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                    // Conversion variables
    DWORD bytesRequired = 0;
    LPBYTE nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid parameters

    IF_DEBUG(USER) {
        NetpKdPrint(( "XsNetUserEnum: header at %lx, params at %lx, "
                      "level %ld, buf size %ld\n",
                      Header, parameters, SmbGetUshort( &parameters->Level ),
                      SmbGetUshort( &parameters->BufLen )));
    }

    try {
        //
        // Check for errors.
        //

        if (( XsWordParamOutOfRange( parameters->Level, 0, 2 ))
             && SmbGetUshort( &parameters->Level ) != 10 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetUserEnum(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     FILTER_NORMAL_ACCOUNT,
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetUserEnum: NetUserEnum failed: %X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserEnum: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_user_info_0;
            StructureDesc = Desc16_user_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_user_info_1;
            StructureDesc = Desc16_user_info_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_user_info_2;
            StructureDesc = Desc16_user_info_2;
            break;

        case 10:

            nativeStructureDesc = Desc32_user_info_10;
            StructureDesc = Desc16_user_info_10;
            break;

        }

        //
        // Do the actual conversion from the 32-bit structures to 16-bit
        // structures.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            nativeStructureDesc,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            StructureDesc,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(USER) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. Otherwise, the data needs to be
        // packed so that we don't send too much useless data.
        //

        if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    entriesFilled
                                    );

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetUserEnum


NTSTATUS
XsNetUserEnum2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserEnum. This version supports a
    resumable handle.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_ENUM_2 parameters = Parameters;
    LPVOID outBuffer = NULL;                // Native parameters
    DWORD TotalEntriesToReturn = 0;
    LPDESC nativeStructureDesc;
    DWORD nativeBufferSize = 0xFFFFFFFF;

    DWORD entriesRead = 0;
    DWORD PreviousEntriesRead;
    DWORD totalEntries;
    DWORD entriesFilled = 0;                    // Conversion variables
    DWORD bytesRequired;

    LPBYTE bufferBegin;
    DWORD bufferSize;
    DWORD totalEntriesRead= 0;
    DWORD resumeKey;

    LPBYTE SavedBufferBegin;
    DWORD SavedBufferSize;
    DWORD SavedTotalEntriesRead;
    DWORD SavedResumeKey;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserEnum2: header at %lx, params at %lx, "
                          "level %ld, buf size %ld\n",
                          Header, parameters, SmbGetUshort( &parameters->Level ),
                          SmbGetUshort( &parameters->BufLen )));
        }

        //
        // Copy input resume handle to output resume handle, and get a copy of it.
        //

        resumeKey = SmbGetUlong( &parameters->ResumeIn );
        SmbPutUlong( &parameters->ResumeOut, resumeKey );

        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserEnum2: resume key is %ld\n", resumeKey ));
        }

        //
        // Use the level to determine the descriptor string.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_user_info_0;
            StructureDesc = Desc16_user_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_user_info_1;
            StructureDesc = Desc16_user_info_1;
            break;

        case 2:

            nativeStructureDesc = Desc32_user_info_2;
            StructureDesc = Desc16_user_info_2;
            break;

        case 10:

            nativeStructureDesc = Desc32_user_info_10;
            StructureDesc = Desc16_user_info_10;
            break;

        default:

            //
            // Unsupported levels, abort before any work.
            //

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // NetUserEnum2 is a resumable API, so we cannot get more information
        // from the native call than we can send back. The most efficient way
        // to do this is in a loop...we use the 16-bit buffer size to determine
        // a safe native buffer size, make the call, fill the entries, then
        // take the amount of space remaining and determine a safe size again,
        // and so on, until NetUserEnum returns either no entries or all entries
        // read.
        //

        //
        // Initialize important variables for loop.
        //

        bufferBegin = (LPBYTE)XsSmbGetPointer( &parameters->Buffer );
        bufferSize = (DWORD)SmbGetUshort( &parameters->BufLen );
        totalEntriesRead = 0;

        for ( ; ; ) {


            //
            // Compute a safe size for the native buffer.
            //
            // It is better to underguess than overguess.  NetUserEnum is relatively
            // efficient (especially in the local case) at resuming an enumeration.
            // It is relatively inefficient at returning detailed information about
            // the enumerated users.
            //
            // If nativeBufferSize reaches 1 (or 0),
            //  NetUserEnum will typically enumerate a single user.
            //

            if ( nativeBufferSize > bufferSize/2 ) {
                nativeBufferSize = bufferSize/2;
            }

            //
            // Remember how many we read last time to ensure we make progress.
            //

            PreviousEntriesRead = entriesRead;

            //
            // Save away a copy of all the important variables.
            //
            // The NetUserEnum API can actually overshoot its PrefMaxLen.  The
            // values being saved are values known to not already have been overshot.
            // We can restore these values later if needed.
            //

            SavedBufferBegin = bufferBegin;
            SavedBufferSize = bufferSize;
            SavedTotalEntriesRead = totalEntriesRead;
            SavedResumeKey = resumeKey;


            //
            // Make the local call.
            //

            status = NetUserEnum(
                         NULL,
                         (DWORD)SmbGetUshort( &parameters->Level ),
                         FILTER_NORMAL_ACCOUNT,
                         (LPBYTE *)&outBuffer,
                         nativeBufferSize,
                         &entriesRead,
                         &totalEntries,
                         &resumeKey
                         );

            if ( !XsApiSuccess( status )) {

                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetUserEnum2: NetUserEnum failed: %X\n",
                                  status ));
                }

                Header->Status = (WORD)status;
                goto cleanup;
            }

            IF_DEBUG(USER) {
                NetpKdPrint(( "XsNetUserEnum2: received %ld entries out of %ld at %lx asking for %ld bytes.\n",
                              entriesRead, totalEntries, outBuffer, nativeBufferSize ));

                NetpKdPrint(( "XsNetUserEnum2: resume key is now %ld\n",
                              resumeKey ));
            }

            //
            // Keep track of the total entries available.
            //

            if ( totalEntries > TotalEntriesToReturn ) {
                TotalEntriesToReturn = totalEntries;
            }

            //
            // Was NetUserEnum able to read at least one complete entry?
            //

            if ( entriesRead == 0 ) {
                break;
            }

            //
            // Do the actual conversion from the 32-bit structures to 16-bit
            // structures.
            //

            XsFillEnumBuffer(
                outBuffer,
                entriesRead,
                nativeStructureDesc,
                bufferBegin,
                (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                bufferSize,
                StructureDesc,
                NULL,  // verify function
                &bytesRequired,
                &entriesFilled,
                NULL
                );

            IF_DEBUG(USER) {
                NetpKdPrint(( "XsNetUserEnum2: 32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                              " Entries %ld of %ld\n",
                              outBuffer, SmbGetUlong( &parameters->Buffer ),
                              bytesRequired, entriesFilled, entriesRead ));
            }

            //
            // If NetUserEnum overshot PrefMaxLen,
            //  we can't simply return the collected data since we wouldn't
            //  know what to use as a ResumeHandle.
            //

            if ( entriesRead != entriesFilled ) {

                //
                // Restore the saved values.
                //

                bufferBegin = SavedBufferBegin;
                bufferSize = SavedBufferSize;
                totalEntriesRead = SavedTotalEntriesRead;
                resumeKey = SavedResumeKey;

                //
                // If we have ANY data to return to the caller,
                //  return the short list now rather than trying to outguess NetUserEnum
                //

                if ( totalEntriesRead != 0 ) {
                    IF_DEBUG(USER) {
                        NetpKdPrint(( "XsNetUserEnum2: couldn't pack data: return previous data\n" ));
                    }
                    break;
                }

                //
                // If we've already asked NetUserEnum for the smallest amount,
                //  just give up.
                //

                if ( nativeBufferSize == 1 || entriesRead == 1 ) {

                    status = NERR_BufTooSmall;
                    IF_DEBUG(API_ERRORS) {
                        NetpKdPrint(( "XsNetUserEnum2: NetUserEnum buffer too small: %X\n",
                                      status ));
                    }

                    Header->Status = (WORD)status;
                    goto cleanup;
                }

                //
                // Otherwise, trim it down and try again.
                //  If we've tried twice and gotten the same result,
                //      be really agressive.
                //

                if ( entriesRead == PreviousEntriesRead || entriesRead < 10 ) {
                    nativeBufferSize = 1;
                } else {
                    nativeBufferSize /= 2;
                }

            //
            // If NetUserEnum returned useful data,
            //  account for it.
            //

            } else {
                //
                // Update count of entries read.
                //

                totalEntriesRead += entriesRead;

                //
                // Are there any more entries to read?
                //

                if ( entriesRead == totalEntries ) {
                    break;
                }

                //
                // If we've made the nativeBufferSize so small we're barely making
                //  progress,
                //  just return what we have to the caller.
                //

                if ( entriesRead == 1 ) {
                    break;
                }

                //
                // Calculate new buffer beginning and size.
                //

                bufferBegin += entriesRead *
                                   RapStructureSize( StructureDesc, Response, FALSE );
                bufferSize -= bytesRequired;

                //
                // Don't hassle the last few bytes,
                //  we'll just overshoot anyway.
                //

                if ( bufferSize < 50 ) {
                    break;
                }
            }


            //
            // Free last native buffer.
            //

            NetApiBufferFree( outBuffer );
            outBuffer = NULL;

        }

        //
        // Upon exit from the loop, totalEntriesRead has the number of entries
        // read, TotalEntriesToReturn has the number available from NetUserEnum.
        // Formulate return codes, etc. from these values.
        //

        if ( totalEntriesRead < TotalEntriesToReturn ) {

            Header->Status = ERROR_MORE_DATA;

        } else {

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    totalEntriesRead
                                    );

        }

        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserEnum2: returning %ld entries of %ld. Resume key is now %ld\n",
                          totalEntriesRead,
                          TotalEntriesToReturn,
                          resumeKey ));
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)totalEntriesRead );
        SmbPutUshort( &parameters->TotalAvail,
            (WORD)( TotalEntriesToReturn ));
        SmbPutUlong( &parameters->ResumeOut, resumeKey );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        totalEntriesRead,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetUserEnum2


NTSTATUS
XsNetUserGetGroups (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserGetGroups.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_GET_GROUPS parameters = Parameters;
    LPTSTR nativeUserName = NULL;           // Native parameters
    LPVOID outBuffer= NULL;
    DWORD entriesRead;
    DWORD totalEntries;

    DWORD entriesFilled = 0;                    // Conversion variables
    DWORD bytesRequired = 0;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserGetGroups: header at %lx, params at %lx, "
                          "level %ld, buf size %ld\n",
                          Header, parameters, SmbGetUshort( &parameters->Level ),
                          SmbGetUshort( &parameters->BufLen )));
        }

        //
        // Translate parameters, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 0 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        //
        // Get the actual information from the local 32-bit call.
        //

        status = NetUserGetGroups(
                     NULL,
                     nativeUserName,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer,
                     XsNativeBufferSize( SmbGetUshort( &parameters->BufLen )),
                     &entriesRead,
                     &totalEntries
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetUserGetGroups: NetUserGetGroups failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserGetGroups: received %ld entries at %lx\n",
                          entriesRead, outBuffer ));
        }

        //
        // Do the conversion from 32- to 16-bit data.
        //

        XsFillEnumBuffer(
            outBuffer,
            entriesRead,
            Desc32_user_group_info_0,
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
            SmbGetUshort( &parameters->BufLen ),
            Desc16_user_group_info_0,
            NULL,  // verify function
            &bytesRequired,
            &entriesFilled,
            NULL
            );

        IF_DEBUG(USER) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR,"
                          " Entries %ld of %ld\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired, entriesFilled, totalEntries ));
        }

        //
        // If there is no room for one fixed structure, return NERR_BufTooSmall.
        // If all the entries could not be filled, return ERROR_MORE_DATA,
        // and return the buffer as is. GROUP_INFO_0 structures don't
        // need to be packed, because they have no variable data.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 Desc16_user_group_info_0,
                 FALSE   // not in native format
                 )) {

            Header->Status = NERR_BufTooSmall;

        } else if ( entriesFilled < totalEntries ) {

            Header->Status = ERROR_MORE_DATA;

        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->EntriesRead, (WORD)entriesFilled );
        SmbPutUshort( &parameters->TotalAvail, (WORD)totalEntries );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeUserName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        Desc16_user_group_info_0,
        Header->Converter,
        entriesFilled,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetUserGetGroups


NTSTATUS
XsNetUserGetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserGetInfo.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_GET_INFO parameters = Parameters;
    LPTSTR nativeUserName = NULL;           // Native parameters
    LPVOID outBuffer = NULL;

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPBYTE nativeStructureDesc;
    DWORD level;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserGetInfo: header at %lx, "
                          "params at %lx, level %ld\n",
                          Header, parameters, SmbGetUshort( &parameters->Level ) ));
        }

        //
        // Translate parameters, check for errors.
        //

        level = SmbGetUshort( &parameters->Level );

        if ( XsWordParamOutOfRange( level, 0, 2 )
             && XsWordParamOutOfRange( level, 10, 11 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        //
        // Make the local call.
        //

        status = NetUserGetInfo(
                     NULL,
                     nativeUserName,
                     level,
                     (LPBYTE *)&outBuffer
                     );


        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetUserGetInfo: NetUserGetInfo failed: "
                            "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( level ) {

        case 0:

            nativeStructureDesc = Desc32_user_info_0;
            StructureDesc = Desc16_user_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_user_info_1;
            StructureDesc = Desc16_user_info_1;
            break;

        case 2:

            {
                PUSER_INFO_2 usri2 = outBuffer;

                //
                // Call NetpRotateLogonHours to make sure we behave properly
                // during DST.
                //

                if ( usri2->usri2_logon_hours != NULL ) {

                    if ( !NetpRotateLogonHours(
                                usri2->usri2_logon_hours,
                                usri2->usri2_units_per_week,
                                FALSE
                                ) ) {

                        Header->Status = NERR_InternalError;
                        goto cleanup;
                    }
                }

                //
                // Truncate UserParms to 48 bytes
                //

                if (( usri2->usri2_parms != NULL ) &&
                    (wcslen(usri2->usri2_parms) > LM20_MAXCOMMENTSZ))
                {
                    *(usri2->usri2_parms + LM20_MAXCOMMENTSZ) = UNICODE_NULL;
                }
                
                nativeStructureDesc = Desc32_user_info_2;
                StructureDesc = Desc16_user_info_2;
            }
            break;

        case 10:

            nativeStructureDesc = Desc32_user_info_10;
            StructureDesc = Desc16_user_info_10;
            break;

        case 11:

            {
                PUSER_INFO_11 usri11 = outBuffer;

                //
                // Call NetpRotateLogonHours to make sure we behave properly
                // during DST.
                //

                if ( usri11->usri11_logon_hours != NULL ) {
                    if ( !NetpRotateLogonHours(
                                usri11->usri11_logon_hours,
                                usri11->usri11_units_per_week,
                                FALSE
                                ) ) {

                        Header->Status = NERR_InternalError;
                        goto cleanup;
                    }
                }

                //
                // Truncate UserParms to 48 bytes
                //

                if (( usri11->usri11_parms != NULL ) &&
                    (wcslen(usri11->usri11_parms) > LM20_MAXCOMMENTSZ))
                {
                    *(usri11->usri11_parms + LM20_MAXCOMMENTSZ) = UNICODE_NULL;
                }
                
                nativeStructureDesc = Desc32_user_info_11;
                StructureDesc = Desc16_user_info_11;
            }
            break;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserGetInfo: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(USER) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserGetInfo: Buffer too small %ld s.b. %ld.\n",
                    SmbGetUshort( &parameters->BufLen ),
                    RapStructureSize(
                        StructureDesc,
                        Response,
                        FALSE ) ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "NetUserGetInfo: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );
    NetpMemoryFree( nativeUserName );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetUserGetInfo


NTSTATUS
XsNetUserModalsGet (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserModalsGet.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_MODALS_GET parameters = Parameters;
    LPVOID outBuffer = NULL;                // Native parameters

    LPBYTE stringLocation = NULL;           // Conversion variables
    DWORD bytesRequired = 0;
    LPBYTE nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserModalsGet: header at %lx, "
                          "params at %lx, level %ld\n",
                          Header, parameters, SmbGetUshort( &parameters->Level ) ));
        }

        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // Make the local call.
        //

        status = NetUserModalsGet(
                     NULL,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     (LPBYTE *)&outBuffer
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(API_ERRORS) {
                NetpKdPrint(( "XsNetUserModalsGet: NetUserModalsGet failed: "
                              "%X\n", status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Use the requested level to determine the format of the
        // data structure.
        //

        switch ( SmbGetUshort( &parameters->Level ) ) {

        case 0:

            nativeStructureDesc = Desc32_user_modals_info_0;
            StructureDesc = Desc16_user_modals_info_0;
            break;

        case 1:

            nativeStructureDesc = Desc32_user_modals_info_1;
            StructureDesc = Desc16_user_modals_info_1;
            break;

        }

        //
        // Convert the structure returned by the 32-bit call to a 16-bit
        // structure. The last possible location for variable data is
        // calculated from buffer location and length.
        //

        stringLocation = (LPBYTE)( XsSmbGetPointer( &parameters->Buffer )
                                      + SmbGetUshort( &parameters->BufLen ) );

        status = RapConvertSingleEntry(
                     outBuffer,
                     nativeStructureDesc,
                     FALSE,
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     StructureDesc,
                     TRUE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     NativeToRap
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserModalsGet: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        IF_DEBUG(USER) {
            NetpKdPrint(( "32-bit data at %lx, 16-bit data at %lx, %ld BR\n",
                          outBuffer, SmbGetUlong( &parameters->Buffer ),
                          bytesRequired ));
        }

        //
        // Determine return code based on the size of the buffer.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 StructureDesc,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserModalsGet: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;

        } else if ( bytesRequired > (DWORD)SmbGetUshort( &parameters-> BufLen )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "NetUserModalsGet: More data available.\n" ));
            }
            Header->Status = ERROR_MORE_DATA;

        } else {

            //
            // Pack the response data.
            //

            Header->Converter = XsPackReturnData(
                                    (LPVOID)XsSmbGetPointer( &parameters->Buffer ),
                                    SmbGetUshort( &parameters->BufLen ),
                                    StructureDesc,
                                    1
                                    );
        }

        //
        // Set up the response parameters.
        //

        SmbPutUshort( &parameters->TotalAvail, (WORD)bytesRequired );

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetApiBufferFree( outBuffer );

    //
    // Determine return buffer size.
    //

    XsSetDataCount(
        &parameters->BufLen,
        StructureDesc,
        Header->Converter,
        1,
        Header->Status
        );

    return STATUS_SUCCESS;

} // XsNetUserModalsGet


NTSTATUS
XsNetUserModalsSet (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserModalsSet.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_MODALS_SET parameters = Parameters;
    DWORD nativeLevel;                      // Native parameters
    LPVOID buffer = NULL;

    LPDESC setInfoDesc;                     // Conversion variables
    LPDESC nativeSetInfoDesc;
    LPDESC nativeStructureDesc;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Check for errors.
        //

        if ( XsWordParamOutOfRange( parameters->Level, 0, 1 )) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        //
        // First of all, the 32-bit parmnum is a bit messed up. If the level
        // is 2, the new parmnum is 5 plus the old parmnum.
        //

        nativeLevel = XsLevelFromParmNum( SmbGetUshort( &parameters->Level ),
                          SmbGetUshort( &parameters->ParmNum ));

        switch ( SmbGetUshort( &parameters->Level )) {

        case 0:

            StructureDesc = Desc16_user_modals_info_0;
            nativeStructureDesc = Desc32_user_modals_info_0;
            setInfoDesc = Desc16_user_modals_info_0_setinfo;
            nativeSetInfoDesc = Desc32_user_modals_info_0_setinfo;

            break;

        case 1:

            StructureDesc = Desc16_user_modals_info_1;
            nativeStructureDesc = Desc32_user_modals_info_1;
            setInfoDesc = Desc16_user_modals_info_1_setinfo;
            nativeSetInfoDesc = Desc32_user_modals_info_1_setinfo;
            if ( nativeLevel != (DWORD)SmbGetUshort( &parameters->Level )) {
                nativeLevel += 5;
            }

            break;

        }

        status = XsConvertSetInfoBuffer(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     SmbGetUshort( &parameters->BufLen ),
                     SmbGetUshort( &parameters->ParmNum ),
                     TRUE,
                     TRUE,
                     StructureDesc,
                     nativeStructureDesc,
                     setInfoDesc,
                     nativeSetInfoDesc,
                     (LPBYTE *)&buffer,
                     NULL
                     );

        if ( status != NERR_Success ) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserModalsSet: Problem with conversion: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;

        }

        //
        // Make the local call.
        //

        status = NetUserModalsSet(
                     NULL,
                     nativeLevel,
                     buffer,
                     NULL
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserModalsSet: NetUserModalsSet failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // No return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // If there is a native 32-bit buffer, free it.
    //

    NetpMemoryFree( buffer );

    return STATUS_SUCCESS;

} // XsNetUserModalsSet


NTSTATUS
XsNetUserPasswordSet2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserPasswordSet. This call is
    translated to NetUserPasswordSet2 when remotely called from a
    16-bit machine.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_PASSWORD_SET_2 parameters = Parameters;
    LPTSTR nativeUserName = NULL;           // Native parameters
    UNICODE_STRING UserName;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        //
        // Convert the username.
        //

        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        RtlInitUnicodeString(
            &UserName,
            nativeUserName
            );

        //
        // Check the password length.
        //
        status = XsCheckAndReplacePassword( (DWORD)( SmbGetUshort( &parameters->PasswordLength )) );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserPasswordSet2: XsCheckAndReplacePassword "
                              "failed: %X\n", status ));
            }
            goto cleanup;
        }

        status = XsChangePasswordSam(
                     &UserName,
                     parameters->OldPassword,
                     parameters->NewPassword,
                     (BOOLEAN)SmbGetUshort( &parameters->DataEncryption )
                     );


        //
        // No return data.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( nativeUserName );
    Header->Status = (WORD)status;

    return STATUS_SUCCESS;

} // XsNetUserPasswordSet2


NTSTATUS
XsNetUserSetGroups (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserSetGroups.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status;

    PXS_NET_USER_SET_GROUPS parameters = Parameters;
    LPTSTR nativeUserName = NULL;           // Native parameters
    LPBYTE actualBuffer = NULL;
    DWORD groupCount;

    LPBYTE stringLocation = NULL;           // Conversion variables
    LPVOID buffer = NULL;
    DWORD bytesRequired = 0;
    LPDESC longDescriptor = NULL;
    LPDESC longNativeDescriptor = NULL;
    DWORD bufferSize;
    DWORD i;

    API_HANDLER_PARAMETERS_REFERENCE;       // Avoid warnings

    try {
        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserSetGroups: header at %lx, params at %lx,"
                          "level %ld\n",
                          Header, parameters, SmbGetUshort( &parameters->Level ) ));
        }

        //
        // Translate parameters, check for errors.
        //

        if ( SmbGetUshort( &parameters->Level ) != 0 ) {

            Header->Status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        StructureDesc = Desc16_user_group_info_0_set;
        AuxStructureDesc = Desc16_user_group_info_0;

        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        //
        // Use the count of group_info_0 structures to form a long
        // descriptor string which can be used to do all the conversion
        // in one pass.
        //

        groupCount = (DWORD)SmbGetUshort( &parameters->Entries );

        longDescriptor = NetpMemoryAllocate(
                             strlen( StructureDesc )
                             + strlen( AuxStructureDesc ) * groupCount
                             + 1 );
        longNativeDescriptor = NetpMemoryAllocate(
                                   strlen( Desc32_user_group_info_0_set )
                                   + strlen( Desc32_user_group_info_0 )
                                         * groupCount
                                   + 1 );

        if (( longDescriptor == NULL ) || ( longNativeDescriptor == NULL )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserSetGroups: failed to allocate memory" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        strcpy( longDescriptor, StructureDesc );
        strcpy( longNativeDescriptor, Desc32_user_group_info_0_set );
        for ( i = 0; i < groupCount; i++ ) {
            strcat( longDescriptor, AuxStructureDesc );
            strcat( longNativeDescriptor, Desc32_user_group_info_0 );
        }

        //
        // Figure out if there is enough room in the buffer for all this
        // data. If not, return NERR_BufTooSmall.
        //

        if ( !XsCheckBufferSize(
                 SmbGetUshort( &parameters->BufLen ),
                 longDescriptor,
                 FALSE  // not in native format
                 )) {

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserSetGroups: Buffer too small.\n" ));
            }
            Header->Status = NERR_BufTooSmall;
            goto cleanup;
        }

        //
        // Find out how big a buffer we need to allocate to hold the native
        // 32-bit version of the input data structure.
        //

        bufferSize = XsBytesForConvertedStructure(
                         (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                         longDescriptor,
                         longNativeDescriptor,
                         RapToNative,
                         TRUE
                         );

        //
        // Allocate enough memory to hold the converted native buffer.
        //

        buffer = NetpMemoryAllocate( bufferSize );

        if ( buffer == NULL ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserSetGroups: failed to create buffer" ));
            }
            Header->Status = NERR_NoRoom;
            goto cleanup;
        }

        IF_DEBUG(USER) {
            NetpKdPrint(( "XsNetUserSetGroups: buffer of %ld bytes at %lx\n",
                          bufferSize, buffer ));
        }

        //
        // Convert the buffer from 16-bit to 32-bit.
        //

        stringLocation = (LPBYTE)buffer + bufferSize;
        bytesRequired = 0;

        status = RapConvertSingleEntry(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     longDescriptor,
                     TRUE,
                     buffer,
                     buffer,
                     longNativeDescriptor,
                     FALSE,
                     &stringLocation,
                     &bytesRequired,
                     Response,
                     RapToNative
                     );

        if ( status != NERR_Success ) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserSetGroups: RapConvertSingleEntry failed: "
                              "%X\n", status ));
            }

            Header->Status = NERR_InternalError;
            goto cleanup;
        }

        //
        // Check if we got all the entries. If not, we'll quit.
        //

        if ( RapAuxDataCount( buffer, Desc32_user_group_info_0_set, Both, TRUE )
                 != groupCount ) {

             Header->Status = NERR_BufTooSmall;
             goto cleanup;
        }

        //
        // If there are no entries, there's no data. Otherwise, the data comes
        // after an initial header structure.
        //

        if ( groupCount > 0 ) {

            actualBuffer = (LPBYTE)buffer + RapStructureSize(
                                                Desc32_user_group_info_0_set,
                                                Both,
                                                TRUE
                                                );

        } else {

            actualBuffer = NULL;
        }

        //
        // Make the local call.
        //

        status = NetUserSetGroups(
                     NULL,
                     nativeUserName,
                     (DWORD)SmbGetUshort( &parameters->Level ),
                     actualBuffer,
                     (DWORD)groupCount
                     );

        if ( !XsApiSuccess( status )) {
            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsNetUserSetGroups: NetUserSetGroups failed: %X\n",
                              status ));
            }
            Header->Status = (WORD)status;
            goto cleanup;
        }

        //
        // There is no real return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Header->Status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    NetpMemoryFree( buffer );
    NetpMemoryFree( longDescriptor );
    NetpMemoryFree( longNativeDescriptor );
    NetpMemoryFree( nativeUserName );

    return STATUS_SUCCESS;

} // XsNetUserSetGroups


NTSTATUS
XsNetUserSetInfo2 (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserSetInfo2. A remote NetUserGetInfo2
    call from a 16-bit machine is translated to NetUserGetInfo2, with
    an encrypted password. This routine has to check for a password set
    and handle it properly, by using level 21 to set the password.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    NET_API_STATUS status = NO_ERROR;

    PXS_NET_USER_SET_INFO_2 parameters = Parameters;
    LPTSTR nativeUserName = NULL;           // Native parameters
    LPVOID buffer = NULL;
    WORD   bufLen;
    DWORD level;
    BYTE newPassword[ENCRYPTED_PWLEN];

    LPDESC setInfoDesc;                     // Conversion variables
    LPVOID nativePasswordArea = NULL;       // Points to Unicode or encrypted.
    LPDESC nativeSetInfoDesc;
    LPDESC nativeStructureDesc;
    LPUSER_INFO_2 user = NULL;
    PUSER_16_INFO_1 user16 = NULL;
    USER_INFO_1020 usri1020;
    BOOLEAN changePassword = FALSE;
    BOOLEAN changeUserInfo = FALSE;
    BOOLEAN encryptionSupported = TRUE;
    WORD parmNum;
    PUSER_INFO_2 Susri2 = NULL;

    //
    // avoid warnings;
    //

    API_HANDLER_PARAMETERS_REFERENCE;

    try {
        bufLen  = SmbGetUshort( &parameters->BufLen );
        level   = SmbGetUshort( &parameters->Level );
        parmNum = SmbGetUshort( &parameters->ParmNum );

        IF_DEBUG(USER) {
            NetpKdPrint((
                    "XsNetUserSetInfo2: header at " FORMAT_LPVOID ", "
                    "params at " FORMAT_LPVOID ",\n  "
                    "level " FORMAT_DWORD ", parmnum " FORMAT_DWORD ", "
                    "buflen " FORMAT_WORD_ONLY "\n",
                    Header, parameters,
                    level, parmNum, bufLen ));
        }

        //
        // Translate parameters
        //

        XsConvertTextParameter(
            nativeUserName,
            (LPSTR)XsSmbGetPointer( &parameters->UserName )
            );

        //
        // Check if password is encrypted.  We know for a fact that dos redirs
        // don't support encryption
        //

        encryptionSupported = (BOOLEAN)
                ( SmbGetUshort( &parameters->DataEncryption ) == TRUE );

        //
        // Determine descriptor strings based on level.
        //

        switch ( level ) {

        case 1:

            StructureDesc = Desc16_user_info_1;
            setInfoDesc = Desc16_user_info_1_setinfo;

            if ( encryptionSupported ) {
                nativeStructureDesc = Desc32_user_info_1;
                nativeSetInfoDesc = Desc32_user_info_1_setinfo;
            } else {
                nativeStructureDesc = Desc32_user_info_1_NC;
                nativeSetInfoDesc = Desc32_user_info_1_setinfo_NC;
            }

            break;

        case 2:

            StructureDesc = Desc16_user_info_2;
            setInfoDesc = Desc16_user_info_2_setinfo;

            if ( encryptionSupported ) {
                nativeStructureDesc = Desc32_user_info_2;
                nativeSetInfoDesc = Desc32_user_info_2_setinfo;
            } else {
                nativeStructureDesc = Desc32_user_info_2_NC;
                nativeSetInfoDesc = Desc32_user_info_2_setinfo_NC;
            }
            break;

        default:
            status = ERROR_INVALID_LEVEL;
            goto cleanup;
        }

        if (parmNum != USER_PASSWORD_PARMNUM) {
            status = XsConvertSetInfoBuffer(
                     (LPBYTE)XsSmbGetPointer( &parameters->Buffer ),
                     bufLen,
                     parmNum,
                     TRUE,                  // yes, convert strings
                     TRUE,                  // yes, meaningless input pointers
                     StructureDesc,
                     nativeStructureDesc,
                     setInfoDesc,
                     nativeSetInfoDesc,
                     (LPBYTE *)&buffer,
                     NULL                   // don't need output buffer size
                     );

            if ( status != NERR_Success ) {

                IF_DEBUG(ERRORS) {
                    NetpKdPrint((
                            "XsNetUserSetInfo2: Problem with conversion: "
                            FORMAT_API_STATUS "\n",
                            status ));
                }
                goto cleanup;

            }

        } else {
            XsConvertTextParameter(
                    buffer,
                    (LPSTR)XsSmbGetPointer( &parameters->Buffer ) );
        }
        NetpAssert( buffer != NULL );


        //
        // Check the password length.  A value of -1 means caller wants us
        // to compute the length; see XsNetUserSetInfo below.
        //

        if ( parmNum == PARMNUM_ALL || parmNum == USER_PASSWORD_PARMNUM) {
            WORD   passwordLength = SmbGetUshort( &parameters->PasswordLength );

            if (parmNum == PARMNUM_ALL) {
                LPUSER_INFO_2 userInfo = (LPVOID) buffer;  // Native structure.
                nativePasswordArea = userInfo->usri2_password;   // May be NULL.
            } else {
                nativePasswordArea = buffer;        // Entire native buffer.
                if (nativePasswordArea == NULL) {
                    status = ERROR_INVALID_PARAMETER;
                    goto cleanup;
                }
            }

            if (passwordLength == (WORD)(-1)) {
                if (parameters->DataEncryption) {
                    parameters->PasswordLength = ENCRYPTED_PWLEN;
                } else if (nativePasswordArea != NULL) {
                    // Unencrypted, count is number of chars, w/o null char.
                    parameters->PasswordLength = (USHORT)wcslen( nativePasswordArea );
                } else {
                    parameters->PasswordLength = 0;
                }
            }

            status = XsCheckAndReplacePassword( (DWORD)( SmbGetUshort( &parameters->PasswordLength )) );

            if ( status != NERR_Success ) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetUserSetInfo2: XsCheckAndReplacePassword "
                                  "failed: " FORMAT_API_STATUS "\n", status ));
                }
                goto cleanup;
            }

        }

        //
        // If necessary, do work with passwords. Also, translate the parmnum to
        // an info level.
        //

        switch( parmNum ) {

        case PARMNUM_ALL:

            //
            // Get the encrypted password.
            //

            user16 = (PUSER_16_INFO_1)XsSmbGetPointer( &parameters->Buffer );

            RtlCopyMemory(
                newPassword,
                user16->usri1_password,
                ENCRYPTED_PWLEN
                );

            user = (LPUSER_INFO_2)buffer;
            user->usri2_password = NULL;

            if ( level == 2 && user->usri2_logon_hours != NULL ) {

                //
                // Call NetpRotateLogonHours to make sure we behave properly
                // during DST.
                //

                if ( !NetpRotateLogonHours(
                            user->usri2_logon_hours,
                            user->usri2_units_per_week,
                            TRUE
                            ) ) {

                    status = ERROR_INVALID_PARAMETER;
                    goto cleanup;
                }
            }

            changePassword = TRUE;
            changeUserInfo = TRUE;
            break;

        case USER_PASSWORD_PARMNUM:

            //
            // We will use level 21 for changing passwords.
            //

            //
            // Get the encrypted password.
            //

            RtlCopyMemory(
                    newPassword,
                    (PVOID)XsSmbGetPointer( &parameters->Buffer ),
                    ENCRYPTED_PWLEN
                    );

            changePassword = TRUE;
            break;

        case USER_LOGON_HOURS_PARMNUM:

            usri1020.usri1020_units_per_week = UNITS_PER_WEEK;
            usri1020.usri1020_logon_hours =
                                (LPBYTE)XsSmbGetPointer( &parameters->Buffer );

            //
            // Call NetpRotateLogonHours to make sure we behave properly
            // during DST.
            //

            if ( !NetpRotateLogonHours(
                        usri1020.usri1020_logon_hours,
                        usri1020.usri1020_units_per_week,
                        TRUE
                        ) ) {

                status = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

            //
            // Lack of break is intentional
            //

        default:

            changeUserInfo = TRUE;
            level = PARMNUM_BASE_INFOLEVEL + parmNum;

            break;
        }

        //
        // Bug 114883
        // Downlevel clients cannot set more than 48 wchars and if the server
        // did have more than 48 wchars, we were truncating it! We merge the
        // data that the client sent with what exists on the server
        //

        if ((buffer != NULL) &&
            (changeUserInfo) &&
            ((level == 2) || (parmNum == USER_PARMS_PARMNUM)))
        {
            PUSER_INFO_2 Cusri2 = NULL;
            PUSER_INFO_1013 Cusri1013 = NULL;
            LPWSTR UserParms = NULL;

            // Get the pointer to the client's userparms

            if (level == 2)
            {
                Cusri2 = buffer;
                UserParms = Cusri2->usri2_parms;
            }
            else
            {
                Cusri1013 = buffer;
                UserParms = Cusri1013->usri1013_parms;
            }
            
            //
            // Make the local call.
            //

            status = NetUserGetInfo(
                         NULL,
                         nativeUserName,
                         level,
                         (LPBYTE *)&Susri2
                         );

            if ( !XsApiSuccess( status )) {
                IF_DEBUG(API_ERRORS) {
                    NetpKdPrint(( "XsNetUserGetInfo: NetUserGetInfo failed: "
                            "%X\n", status ));
                }
                goto cleanup;
            }

            // If the server userparms field is > 48, we want to do something special

            if (( Susri2->usri2_parms != NULL )  &&
                (wcslen(Susri2->usri2_parms) > LM20_MAXCOMMENTSZ))
            {
                //
                // We need to merge the returned bytes with the local ones
                //

                UINT Length = 0;

                if ( UserParms != NULL )
                {
                    //
                    // Just to be safe, we never over-write more than 48 wchars.
                    //

                    Length = wcslen(UserParms);

                    if (Length > LM20_MAXCOMMENTSZ)
                    {
                        Length = LM20_MAXCOMMENTSZ;
                    }
                }

                // we copy the bytes that the client sent, but only upto
                // 48 wchars.

                RtlCopyMemory( Susri2->usri2_parms,
                               UserParms,
                               Length * sizeof(WCHAR));

                // From Length to LM20_MAXCOMMENTSZ, we pad with blanks

                while (Length < LM20_MAXCOMMENTSZ)
                {
                    Susri2->usri2_parms[Length++] = L' ';
                }

                // Save the merged user parms

                if (level == 2 )
                {
                    Cusri2->usri2_parms = Susri2->usri2_parms;
                }
                else
                {
                    Cusri1013->usri1013_parms = Susri2->usri2_parms;
                }
            }
        }

        //
        // Change user infos other than the password
        //

        if ( changeUserInfo ) {

            status = NetUserSetInfo(
                         NULL,
                         nativeUserName,
                         level,
                         buffer,
                         NULL
                         );

            if ( !XsApiSuccess( status )) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetUserSetInfo2: NetUserSetInfo failed: %X\n",
                                  status ));
                }
                goto cleanup;
            }

            //
            // If there was a Macintosh primary group field for this user, then
            // set the primary group.
            //

            if ( (level == 2) &&
                 NetpIsMacPrimaryGroupFieldValid( (LPCTSTR)user->usri2_parms ) ) {
                NET_API_STATUS status1;
                status1 = XsSetMacPrimaryGroup(
                            (LPCTSTR)nativeUserName,
                            (LPCTSTR)user->usri2_parms
                            );
                if ( !XsApiSuccess( status1 )) {
                    IF_DEBUG(ERRORS) {
                        NetpKdPrint(( "XsNetUserSetInfo2: SetMacPrimaryGroup "
                                        "failed: %X\n", status1 ));
                    }
                }
            } else if ( (level == USER_PARMS_INFOLEVEL) &&
                        NetpIsMacPrimaryGroupFieldValid(
                          (LPCTSTR)((LPUSER_INFO_1013)buffer)->usri1013_parms ) ) {
                NET_API_STATUS status1;
                status1 = XsSetMacPrimaryGroup(
                            (LPCTSTR)nativeUserName,
                            (LPCTSTR)((LPUSER_INFO_1013)buffer)->usri1013_parms
                            );
                if ( !XsApiSuccess( status1 )) {
                    IF_DEBUG(ERRORS) {
                        NetpKdPrint(( "XsNetUserSetInfo2: SetMacPrimaryGroup "
                                        "failed: %X\n", status1 ));
                    }
                }
            }

        }

        //
        // If there is a pending password change, do it now.
        //

        if ( changePassword ) {

            USER_INFO_21 user21;

            if ( !encryptionSupported ) {

                //
                // Do not change password if user sent all blanks.  Clear text
                // passwords are only 14 bytes (LM20_PWLEN) long.
                //

                if ( RtlCompareMemory(
                            newPassword,
                            NULL_USERSETINFO_PASSWD,
                            LM20_PWLEN
                            ) == LM20_PWLEN ) {

                    status = NERR_Success;
                    goto cleanup;
                }

                //
                // Change clear text password to OWF
                //

                (VOID) RtlCalculateLmOwfPassword(
                                    (PLM_PASSWORD) newPassword,
                                    (PLM_OWF_PASSWORD) user21.usri21_password
                                    );


            } else {

                BYTE NullOwfPassword[ENCRYPTED_PWLEN];

                //
                // Decrypt doubly encrypted password with the encryption key
                // provided creating an OWF encrypted password.
                //

                (VOID) RtlDecryptLmOwfPwdWithLmSesKey(
                                    (PENCRYPTED_LM_OWF_PASSWORD) newPassword,
                                    (PLM_SESSION_KEY) Header->EncryptionKey,
                                    (PLM_OWF_PASSWORD) user21.usri21_password
                                    );

                //
                // Generate the NULL Owf Password.
                //

                (VOID) RtlCalculateLmOwfPassword(
                                    (PLM_PASSWORD) NULL_USERSETINFO_PASSWD,
                                    (PLM_OWF_PASSWORD) NullOwfPassword
                                    );

                //
                // Compare the Owf password the client sent and the Owf password
                // for the NULL password.  Do not change the password if this is
                // the case.
                //

                if ( RtlCompareMemory(
                            user21.usri21_password,
                            NullOwfPassword,
                            ENCRYPTED_PWLEN
                            ) == ENCRYPTED_PWLEN ) {

                    status = NERR_Success;
                    goto cleanup;

                }
            }

            status = NetUserSetInfo(
                         NULL,
                         nativeUserName,
                         21,
                         (LPBYTE)&user21,
                         NULL
                         );

            if ( !XsApiSuccess( status )) {
                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsNetUserSetInfo2: NetUserSetInfo failed: "
                                  "%X\n", status ));
                }
                goto cleanup;
            }

        }

        //
        // No return information for this API.
        //

cleanup:
    ;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        status = (WORD)RtlNtStatusToDosError( GetExceptionCode() );
    }

    //
    // If there is a native 32-bit buffer, free it.
    //

    if (Susri2)
        NetApiBufferFree( Susri2);
    Header->Status = (WORD)status;
    NetpMemoryFree( buffer );
    NetpMemoryFree( nativeUserName );

    return STATUS_SUCCESS;

} // XsNetUserSetInfo2


NTSTATUS
XsNetUserSetInfo (
    API_HANDLER_PARAMETERS
    )

/*++

Routine Description:

    This routine handles a call to NetUserSetInfo.  Since this is a subset
    of the newer NetUserSetInfo2, we just convert into a call to that.

Arguments:

    API_HANDLER_PARAMETERS - information about the API call. See
        XsTypes.h for details.

Return Value:

    NTSTATUS - STATUS_SUCCESS or reason for failure.

--*/

{
    WORD                   dataEncryption;
    WORD                   bufLen;
    WORD                   level;
    NTSTATUS               ntStatus;
    WORD                   parmNum;
    PXS_NET_USER_SET_INFO  subsetParameters = Parameters;
    XS_NET_USER_SET_INFO_2 supersetParameters;

    bufLen         = SmbGetUshort( &subsetParameters->BufLen );
    dataEncryption = SmbGetUshort( &subsetParameters->DataEncryption );
    level          = SmbGetUshort( &subsetParameters->Level );
    parmNum        = SmbGetUshort( &subsetParameters->ParmNum );

    try {
        IF_DEBUG(USER) {
            NetpKdPrint((
                    "XsNetUserSetInfo: header at " FORMAT_LPVOID ", "
                    "params at " FORMAT_LPVOID ",\n  level " FORMAT_DWORD ", "
                    "parmnum " FORMAT_DWORD ", buflen " FORMAT_LONG "\n",
                    Header, subsetParameters,
                    (DWORD) level, (DWORD) parmNum, (LONG) bufLen ));
        }

        //
        // Create parms for XsNetUserSetInfo2()...
        //

        supersetParameters.Buffer   = subsetParameters->Buffer;
        supersetParameters.UserName = subsetParameters->UserName;

        SmbPutUshort( &supersetParameters.Level,          level );
        SmbPutUshort( &supersetParameters.BufLen,         bufLen );
        SmbPutUshort( &supersetParameters.ParmNum,        parmNum );
        SmbPutUshort( &supersetParameters.DataEncryption, dataEncryption );

        //
        // Set info 2 will calc password length for us if we give it -1.
        //
        SmbPutUshort( &supersetParameters.PasswordLength, (WORD)(-1) );


        //
        // Invoke new version of API.
        //

        ntStatus = XsNetUserSetInfo2(
                Header,
                &supersetParameters,
                StructureDesc,
                AuxStructureDesc );

    } except( EXCEPTION_EXECUTE_HANDLER ) {
        ntStatus = GetExceptionCode();
    }

    return (ntStatus);

} // XsNetUserSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\xactsrvp.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    xactsrvp.h

Abstract:

    Private header file for XACTSRV.

Author:

    David Treadwell (davidtr) 05-Jan-1991

Revision History:

    02-Jun-1992 JohnRo
        RAID 9829: Avoid SERVICE_ equate conflicts.

--*/

#ifndef _XACTSRVP_
#define _XACTSRVP_

//
// To make netlib declare NetpDbgPrint.
//

#if DBG
#ifndef CDEBUG
#define CDEBUG
#endif
#endif

//
// "System" include files
//

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <ctype.h>
#include <stdlib.h>
#include <windef.h>
#include <winbase.h>
#include <string.h>
//!!UNICODE!! - Include tstring.h TSTR type-independent functions
#include <tstring.h>

//
// Network include files.
//

#include <nettypes.h>

#include <smbtypes.h>
#include <smbmacro.h>
#include <smbgtpt.h>
#include <smb.h>
#include <smbtrans.h>

#include <status.h>
#include <srvfsctl.h>
#include <lm.h>         // LM20_SERVICE_ equates, etc.
#include <ntmsv1_0.h>

#include <winsvc.h>     // SERVICE_ equates, etc.

#include <apiparam.h>
#include <remdef.h>
#include <remtypes.h>
#include <netlib.h>
#include <netdebug.h>
#include <rap.h>

//
// Xactsrv's own include files
//

#include <XsDebug.h>
#include <XsTypes.h>
#include <XactSrv2.h>             // XsTypes.h must precede XactSrv.h
#include <XsConst.h>              // XactSrv.h must precede XsConst.h
#include <XsUnicod.h>
#include <XsProcs.h>              // XsTypes.h must precede XsProcs.h.
#include <XsProcsP.h>             // XsTypes.h, XsConst.h and XsUnicod.h
                                  // must precede XsProcsP.h.
#include <XsDef16.h>
#include <XsParm16.h>

//
// !!! Temporary definitions for stubs.
//

#include <WkstaDef.h>

#endif // ndef _XACTSRVP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\wkstadef.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    WkstaDef.h

Abstract:

    This is a temporary file of definitions for the local NT
    workstation/server. It contains information returned by the
    stubs for NetServer/NetWksta code. Change these values locally
    to adapt to your machine. All caps is probably wise, as this only
    deals with 2.0 servers

Author:

    Shanku Niyogi (w-shanku) 25-Feb-1991

Revision History:

--*/

//!!UNICODE!! - Added TEXT prefix for these strings.

//
// Server name. This should be the same name as entered in NET SERVE command.
//

#define XS_SERVER_NAME TEXT("SERVER")

//
// Workstation name. Same as in NET START REDIR command.
//

#define XS_WKSTA_NAME TEXT("WKSTA")

//
// Workstation user name.
//

#define XS_WKSTA_USERNAME TEXT("USER")

//
// List of drives on NT server. Each character should be a drive letter.
//

#define XS_ENUM_DRIVES TEXT("ABC")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\xsconst.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    XsConst.h

Abstract:

    Constant manifests for XACTSRV.

Author:

    David Treadwell (davidtr) 09-Jan-1991
    Shanku Niyogi (w-shanku)

Revision History:

--*/

#ifndef _XSCONST_
#define _XSCONST_

//
// The server device name.  XACTSRV will open this name to send the
// "connect to XACTSRV" FSCTL to the server.
//

#define XS_SERVER_DEVICE_NAME_W  L"\\Device\\LanmanServer"

//
// The name of the LPC port XACTSRV creates and uses for communication
// with the server.  This name is included in the connect FSCTL sent to
// the server so that the server knows what port to connect to.
//

#define XS_PORT_NAME_W  L"\\XactSrvLpcPort"
#define XS_PORT_NAME_A   "\\XactSrvLpcPort"

//
// The maximum size of a message that can be sent over the port.
//

#define XS_PORT_MAX_MESSAGE_LENGTH                                         \
    ( sizeof(XACTSRV_REQUEST_MESSAGE) > sizeof(XACTSRV_REPLY_MESSAGE) ?    \
         sizeof(XACTSRV_REQUEST_MESSAGE) : sizeof(XACTSRV_REPLY_MESSAGE) )

#define XS_PORT_TIMEOUT_MILLISECS 5000

//
// The minimum gap before variable-length data is moved up in a response
// data buffer.  If the variable-length data is moved, the converted word
// is set appropriately.
//

#define MAXIMUM_ALLOWABLE_DATA_GAP 100

//
// A scaling function for approximating the maximum required buffer size
// for native Enumeration calls. This value should preferably be 3, because
// at least a factor of 2 is required to convert all 16-bit client words to
// 32-bit native dwords, while character arrays require a factor of more
// than two, to account for Unicode conversion plus a four-byte pointer
// to the converted string.
//
// To specify a minimum value for the buffer size, specify the scaling
// function in form min + s, where min is the minimum and s is the scale.
// DO NOT USE PARENTHESES IN THIS EXPRESSION.
//

#define XS_BUFFER_SCALE 1024 + 3

//
// Parameter descriptor for unsupported APIs.
//

#define REMSmb_NetUnsupportedApi_P NULL

#endif // ndef _XSCONST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\xsdata.c ===
/*+

Copyright (c) 1991  Microsoft Corporation

Module Name:

    XsData.c

Abstract:

    Global data declarations for XACTSRV.

Author:

    David Treadwell (davidtr) 05-Jan-1991
    Shanku Niyogi (w-shanku)

Revision History:

--*/

#include <XactSrvP.h>

//
// Conditional debug print variable.  See XsDebug.h.
// !!! If you change this, also change XsDebug in ..\SvcDlls\XsSvc\XsData.c
//

#if DBG
DWORD XsDebug = 0; // DEBUG_API_ERRORS | DEBUG_ERRORS;
#endif

//DWORD XsDebug = 0xFFFFFFFF;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\xsdebug.h ===
#ifndef _XSDEBUG_
#define _XSDEBUG_

//
// Debugging macros
//

#ifndef DBG
#define DBG 0
#endif

#if !DBG

#undef XSDBG
#define XSDBG 0

#else

#ifndef XSDBG
#define XSDBG 1
#endif

#endif

#undef IF_DEBUG

#if !XSDBG

#define STATIC static

#define DEBUG if (FALSE)
#define IF_DEBUG(flag) if (FALSE)

#else

extern DWORD XsDebug;

#define STATIC

#define DEBUG if (TRUE)
#define IF_DEBUG(flag) if (XsDebug & (DEBUG_ ## flag))

#define DEBUG_INIT                0x00000001
#define DEBUG_TRACE               0x00000002
#define DEBUG_LPC                 0x00000004
#define DEBUG_CONVERT             0x00000008

#define DEBUG_THREADS             0x00000010
#define DEBUG_SHARE               0x00000020
#define DEBUG_SESSION             0x00000040
#define DEBUG_USE                 0x00000080

#define DEBUG_USER                0x00000100
#define DEBUG_FILE                0x00000200
#define DEBUG_SERVER              0x00000400
#define DEBUG_WKSTA               0x00000800

#define DEBUG_SERVICE             0x00001000
#define DEBUG_CONNECTION          0x00002000
#define DEBUG_CHAR_DEV            0x00004000
#define DEBUG_MESSAGE             0x00008000

#define DEBUG_ACCESS              0x00010000
#define DEBUG_GROUP               0x00020000
#define DEBUG_AUDIT               0x00040000
#define DEBUG_ERROR               0x00080000

#define DEBUG_PRINT               0x00100000
#define DEBUG_STATISTICS          0x00200000
#define DEBUG_TIME                0x00400000
#define DEBUG_NETBIOS             0x00800000

#define DEBUG_CONFIG              0x01000000
#define DEBUG_LOGON               0x02000000
#define DEBUG_PATH                0x04000000
#define DEBUG_ACCOUNT             0x08000000

#define DEBUG_BOGUS_APIS          0x10000000
#define DEBUG_DESC_STRINGS        0x20000000
#define DEBUG_API_ERRORS          0x40000000
#define DEBUG_ERRORS              0x80000000

#endif // else !XSDBG

#endif // ndef _XSDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\xsdef16.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    XsDef16.h

Abstract:

    Type declarations and constants for default values returned to 16-bit
    clients. Data expected by downlevel clients but not available to NT
    is defined here.

Author:

    David Treadwell (davidtr) 09-Jan-1991

Revision History:

--*/

#ifndef _XSDEF16_

#define _XSDEF16_

//
// The string definitions in this file are put into 16-bit
// structures with a macro that converts Unicode->Ansi.
// Therefore, these definitions should be Unicode.
// All other definitions are Ascii, and should be left alone.
//
// 16-bit info structures for manual filling of defaults.
//

#include <packon.h>

// Pointers are actually Dword offsets (64-bit compat)
#define LPSTR_16_REMOTE DWORD

typedef struct _ACCESS_16_INFO_1 {
    LPSTR_16_REMOTE acc1_resource_name;
    WORD acc1_attr;
    WORD acc1_count;
} ACCESS_16_INFO_1, *PACCESS_16_INFO_1;

typedef struct _PRQINFO_16 {
    LPSTR_16_REMOTE pszName;
    WORD uPriority;
    WORD uStartTime;
    WORD uUntilTime;
    WORD pad1;
    LPSTR_16_REMOTE pszSepFile;
    LPSTR_16_REMOTE pszPrProc;
    LPSTR_16_REMOTE pszParms;
    LPSTR_16_REMOTE pszComment;
    WORD fsStatus;
    WORD cJobs;
    LPSTR_16_REMOTE pszPrinters;
    LPSTR_16_REMOTE pszDriverName;
    PBYTE pDriverData;
} PRQINFO3_16, *PPRQINFO3_16;

typedef struct _PRJINFO_16 {
    WORD uJobId;
    WORD uPriority;
    LPSTR_16_REMOTE pszUserName;
    WORD uPosition;
    WORD fsStatus;
    DWORD ulSubmitted;
    DWORD ulSize;
    LPSTR_16_REMOTE pszComment;
    LPSTR_16_REMOTE pszDocument;
} PRJINFO2_16, *PPRJINFO2_16;

typedef struct _PRINTQ_16_INFO_5 {
    LPSTR_16_REMOTE pszName;
} PRQ_16_INFO_5, *PPRQ_16_INFO_5;

typedef struct _SERVER_16_INFO_2 {
    BYTE sv2_name[LM20_CNLEN + 1];
    BYTE sv2_version_major;
    BYTE sv2_version_minor;
    DWORD sv2_type;
    LPSTR_16_REMOTE sv2_comment;
    DWORD sv2_ulist_mtime;
    DWORD sv2_glist_mtime;
    DWORD sv2_alist_mtime;
    WORD sv2_users;
    WORD sv2_disc;
    LPSTR_16_REMOTE sv2_alerts;
    WORD sv2_security;
    WORD sv2_auditing;
    WORD sv2_numadmin;
    WORD sv2_lanmask;
    WORD sv2_hidden;
    WORD sv2_announce;
    WORD sv2_anndelta;
    BYTE sv2_guestacct[LM20_UNLEN + 1];
    BYTE sv2_pad1;
    LPSTR_16_REMOTE sv2_userpath;
    WORD sv2_chdevs;
    WORD sv2_chdevq;
    WORD sv2_chdevjobs;
    WORD sv2_connections;
    WORD sv2_shares;
    WORD sv2_openfiles;
    WORD sv2_sessopens;
    WORD sv2_sessvcs;
    WORD sv2_sessreqs;
    WORD sv2_opensearch;
    WORD sv2_activelocks;
    WORD sv2_numreqbuf;
    WORD sv2_sizreqbuf;
    WORD sv2_numbigbuf;
    WORD sv2_numfiletasks;
    WORD sv2_alertsched;
    WORD sv2_erroralert;
    WORD sv2_logonalert;
    WORD sv2_accessalert;
    WORD sv2_diskalert;
    WORD sv2_netioalert;
    WORD sv2_maxauditsz;
    LPSTR_16_REMOTE sv2_srvheuristics;
} SERVER_16_INFO_2, *PSERVER_16_INFO_2;

typedef struct _SERVER_16_INFO_3 {
    BYTE sv3_name[LM20_CNLEN + 1];
    BYTE sv3_version_major;
    BYTE sv3_version_minor;
    DWORD sv3_type;
    LPSTR_16_REMOTE sv3_comment;
    DWORD sv3_ulist_mtime;
    DWORD sv3_glist_mtime;
    DWORD sv3_alist_mtime;
    WORD sv3_users;
    WORD sv3_disc;
    LPSTR_16_REMOTE sv3_alerts;
    WORD sv3_security;
    WORD sv3_auditing;
    WORD sv3_numadmin;
    WORD sv3_lanmask;
    WORD sv3_hidden;
    WORD sv3_announce;
    WORD sv3_anndelta;
    BYTE sv3_guestacct[LM20_UNLEN + 1];
    BYTE sv3_pad1;
    LPSTR_16_REMOTE sv3_userpath;
    WORD sv3_chdevs;
    WORD sv3_chdevq;
    WORD sv3_chdevjobs;
    WORD sv3_connections;
    WORD sv3_shares;
    WORD sv3_openfiles;
    WORD sv3_sessopens;
    WORD sv3_sessvcs;
    WORD sv3_sessreqs;
    WORD sv3_opensearch;
    WORD sv3_activelocks;
    WORD sv3_numreqbuf;
    WORD sv3_sizreqbuf;
    WORD sv3_numbigbuf;
    WORD sv3_numfiletasks;
    WORD sv3_alertsched;
    WORD sv3_erroralert;
    WORD sv3_logonalert;
    WORD sv3_accessalert;
    WORD sv3_diskalert;
    WORD sv3_netioalert;
    WORD sv3_maxauditsz;
    LPSTR_16_REMOTE sv3_srvheuristics;
    DWORD sv3_auditedevents;
    WORD sv3_autoprofile;
    LPSTR_16_REMOTE sv3_autopath;
} SERVER_16_INFO_3, *PSERVER_16_INFO_3;

#define DEF16_sv_ulist_mtime 0
#define DEF16_sv_glist_mtime 0
#define DEF16_sv_alist_mtime 0
#define DEF16_sv_alerts TEXT("")
#define DEF16_sv_security SV_USERSECURITY
#define DEF16_sv_auditing 0
#define DEF16_sv_numadmin -1
#define DEF16_sv_lanmask 0x0F
#define DEF16_sv_guestacct TEXT("")
#define DEF16_sv_chdevs 65535
#define DEF16_sv_chdevq 65535
#define DEF16_sv_chdevjobs 65535
#define DEF16_sv_connections 2000
#define DEF16_sv_shares 65535
#define DEF16_sv_openfiles 8000
#define DEF16_sv_sessreqs 65535
#define DEF16_sv_activelocks 64
#define DEF16_sv_numreqbuf 300
#define DEF16_sv_numbigbuf 80
#define DEF16_sv_numfiletasks 8
#define DEF16_sv_alertsched 5
#define DEF16_sv_erroralert 5
#define DEF16_sv_logonalert 5
#define DEF16_sv_accessalert 5
#define DEF16_sv_diskalert 300
#define DEF16_sv_netioalert 5
#define DEF16_sv_maxauditsz 100
#define DEF16_sv_srvheuristics TEXT("0110151110111001331")
#define DEF16_sv_auditedevents 0xFFFFFFFF
#define DEF16_sv_autoprofile 0
#define DEF16_sv_autopath TEXT("")

typedef struct _SESSION_16_INFO_1 {
    LPSTR_16_REMOTE sesi1_cname;
    LPSTR_16_REMOTE sesi1_username;
    WORD sesi1_num_conns;
    WORD sesi1_num_opens;
    WORD sesi1_num_users;
    DWORD sesi1_time;
    DWORD sesi1_idle_time;
    DWORD sesi1_user_flags;
} SESSION_16_INFO_1, *PSESSION_16_INFO_1;

typedef struct _SESSION_16_INFO_2 {
    LPSTR_16_REMOTE sesi2_cname;
    LPSTR_16_REMOTE sesi2_username;
    WORD sesi2_num_conns;
    WORD sesi2_num_opens;
    WORD sesi2_num_users;
    DWORD sesi2_time;
    DWORD sesi2_idle_time;
    DWORD sesi2_user_flags;
    LPSTR_16_REMOTE sesi2_cltype_name;
} SESSION_16_INFO_2, *PSESSION_16_INFO_2;

typedef struct _SESSION_16_INFO_10 {
    LPSTR_16_REMOTE sesi10_cname;
    LPSTR_16_REMOTE sesi10_username;
    DWORD sesi10_time;
    DWORD sesi10_idle_time;
} SESSION_16_INFO_10, *PSESSION_16_INFO_10;

#define DEF16_ses_num_conns 1
#define DEF16_ses_num_users 1

typedef struct _USE_16_INFO_0 {
    BYTE ui0_local[LM20_DEVLEN + 1];
    BYTE ui0_pad1;
    LPSTR_16_REMOTE ui0_remote;
} USE_16_INFO_0, *PUSE_16_INFO_0;

typedef struct _USER_16_INFO_1 {
    BYTE usri1_name[LM20_UNLEN+1];
    BYTE usri1_pad_1;
    BYTE usri1_password[ENCRYPTED_PWLEN];
    DWORD usri1_password_age;
    WORD usri1_priv;
    LPSTR_16_REMOTE usri1_home_dir;
    LPSTR_16_REMOTE usri1_comment;
    WORD usri1_flags;
    LPSTR_16_REMOTE usri1_script_path;
} USER_16_INFO_1, *PUSER_16_INFO_1;

typedef struct _USER_16_LOGOFF_INFO_1 {
    WORD usrlogf1_code;
    DWORD usrlogf1_duration;
    WORD usrlogf1_num_logons;
} USER_16_LOGOFF_INFO_1, *PUSER_16_LOGOFF_INFO_1;

typedef struct _USER_16_LOGON_INFO_1 {
    WORD usrlog1_code;
    BYTE usrlog1_eff_name[UNLEN+1];
    BYTE usrlog1_pad_1;
    WORD usrlog1_priv;
    DWORD usrlog1_auth_flags;
    WORD usrlog1_num_logons;
    WORD usrlog1_bad_pw_count;
    DWORD usrlog1_last_logon;
    DWORD usrlog1_last_logoff;
    DWORD usrlog1_logoff_time;
    DWORD usrlog1_kickoff_time;
    DWORD usrlog1_password_age;
    DWORD usrlog1_pw_can_change;
    DWORD usrlog1_pw_must_change;
    LPSTR_16_REMOTE usrlog1_computer;
    LPSTR_16_REMOTE usrlog1_domain;
    LPSTR_16_REMOTE usrlog1_script_path;
    DWORD usrlog1_reserved1;
} USER_16_LOGON_INFO_1, *PUSER_16_LOGON_INFO_1;

typedef struct _WKSTA_16_INFO_0 {
    WORD  wki0_reserved_1;
    DWORD wki0_reserved_2;
    LPSTR_16_REMOTE wki0_root;
    LPSTR_16_REMOTE wki0_computername;
    LPSTR_16_REMOTE wki0_username;
    LPSTR_16_REMOTE wki0_langroup;
    BYTE  wki0_ver_major;
    BYTE  wki0_ver_minor;
    DWORD wki0_reserved_3;
    WORD  wki0_charwait;
    DWORD wki0_chartime;
    WORD  wki0_charcount;
    WORD  wki0_reserved_4;
    WORD  wki0_reserved_5;
    WORD  wki0_keepconn;
    WORD  wki0_keepsearch;
    WORD  wki0_maxthreads;
    WORD  wki0_maxcmds;
    WORD  wki0_reserved_6;
    WORD  wki0_numworkbuf;
    WORD  wki0_sizworkbuf;
    WORD  wki0_maxwrkcache;
    WORD  wki0_sesstimeout;
    WORD  wki0_sizerror;
    WORD  wki0_numalerts;
    WORD  wki0_numservices;
    WORD  wki0_errlogsz;
    WORD  wki0_printbuftime;
    WORD  wki0_numcharbuf;
    WORD  wki0_sizcharbuf;
    LPSTR_16_REMOTE wki0_logon_server;
    LPSTR_16_REMOTE wki0_wrkheuristics;
    WORD  wki0_mailslots;
} WKSTA_16_INFO_0, *PWKSTA_16_INFO_0, *LPWKSTA_16_INFO_0;

typedef struct _WKSTA_16_INFO_1 {
    WORD  wki1_reserved_1;
    DWORD wki1_reserved_2;
    LPSTR_16_REMOTE wki1_root;
    LPSTR_16_REMOTE wki1_computername;
    LPSTR_16_REMOTE wki1_username;
    LPSTR_16_REMOTE wki1_langroup;
    BYTE  wki1_ver_major;
    BYTE  wki1_ver_minor;
    DWORD wki1_reserved_3;
    WORD  wki1_charwait;
    DWORD wki1_chartime;
    WORD  wki1_charcount;
    WORD  wki1_reserved_4;
    WORD  wki1_reserved_5;
    WORD  wki1_keepconn;
    WORD  wki1_keepsearch;
    WORD  wki1_maxthreads;
    WORD  wki1_maxcmds;
    WORD  wki1_reserved_6;
    WORD  wki1_numworkbuf;
    WORD  wki1_sizworkbuf;
    WORD  wki1_maxwrkcache;
    WORD  wki1_sesstimeout;
    WORD  wki1_sizerror;
    WORD  wki1_numalerts;
    WORD  wki1_numservices;
    WORD  wki1_errlogsz;
    WORD  wki1_printbuftime;
    WORD  wki1_numcharbuf;
    WORD  wki1_sizcharbuf;
    LPSTR_16_REMOTE wki1_logon_server;
    LPSTR_16_REMOTE wki1_wrkheuristics;
    WORD  wki1_mailslots;
    LPSTR_16_REMOTE wki1_logon_domain;
    LPSTR_16_REMOTE wki1_oth_domains;
    WORD  wki1_numdgrambuf;
} WKSTA_16_INFO_1, *PWKSTA_16_INFO_1, *LPWKSTA_16_INFO_1;

typedef struct _WKSTA_16_INFO_10 {
    LPSTR_16_REMOTE wki10_computername;
    LPSTR_16_REMOTE wki10_username;
    LPSTR_16_REMOTE wki10_langroup;
    BYTE  wki10_ver_major;
    BYTE  wki10_ver_minor;
    LPSTR_16_REMOTE wki10_logon_domain;
    LPSTR_16_REMOTE wki10_oth_domains;
} WKSTA_16_INFO_10, *PWKSTA_16_INFO_10, *LPWKSTA_16_INFO_10;

typedef struct _WKSTA_16_USER_LOGON_REQUEST_1 {
    BYTE wlreq1_name[LM20_UNLEN + 1];
    BYTE wlreq1_pad1;
    BYTE wlreq1_password[LM20_PWLEN + 1];
    BYTE wlreq1_pad2;
    BYTE wlreq1_workstation[LM20_CNLEN + 1];
} WKSTA_16_USER_LOGON_REQUEST_1, *PWKSTA_16_USER_LOGON_REQUEST_1,
      *LPWKSTA_16_USER_LOGON_REQUEST_1;

typedef struct _WKSTA_16_USER_LOGOFF_REQUEST_1 {
    BYTE wlreq1_name[LM20_UNLEN + 1];
    BYTE wlreq1_pad_1;
    BYTE wlreq1_workstation[LM20_CNLEN + 1];
} WKSTA_16_USER_LOGOFF_REQUEST_1, *PWKSTA_16_USER_LOGOFF_REQUEST_1,
      *LPWKSTA_16_USER_LOGOFF_REQUEST_1;

#define DEF16_ses_num_conns 1
#define DEF16_ses_num_users 1

#define DEF16_wk_username TEXT("")
#define DEF16_wk_keepsearch 600
#define DEF16_wk_numworkbuf 15
#define DEF16_wk_sizeworkbuf 4096
#define DEF16_wk_maxwrkcache 64
#define DEF16_wk_sizerror 512
#define DEF16_wk_numalerts 12
#define DEF16_wk_numservices 8
#define DEF16_wk_errlogsz 100
#define DEF16_wk_printbuftime 60
#define DEF16_wk_numcharbuf 5
#define DEF16_wk_sizcharbuf 512
#define DEF16_wk_logon_server TEXT("")
#define DEF16_wk_wrk_heuristics TEXT("")
#define DEF16_wk_mailslots 1
#define DEF16_wk_logon_domain TEXT("")
#define DEF16_wk_oth_domains TEXT("")
#define DEF16_wk_numdgrambuf 14

#include <packoff.h>

#endif // ndef _XSDEF16_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\xsparm16.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    XsParm16.h

Abstract:

    Constants for PARMNUM values for 16-bit info structures. 16-bit
    clients use these values for parmnum parameters, while NT uses
    its own values.

    ??UNICODE?? - Once the SetInfo calls are converted to the new
                  format (see NetShareSetInfo), this file is no longer
                  required.

Author:

    Shanku Niyogi (w-shanku) 03-Apr-1991

Revision History:

--*/

#ifndef _XSPARM16_

#define _XSPARM16_

//
// Standard PARMNUM_ALL value.
//

#define PARMNUM_16_ALL 0

//
// access_info_x parmnums.
//

#define PARMNUM_16_ACCESS_ATTR 2

//
// chardevQ_info_x parmnums.
//

#define PARMNUM_16_CHARDEVQ_PRIORITY 2
#define PARMNUM_16_CHARDEVQ_DEVS 3

//
// group_info_x parmnums.
//

#define PARMNUM_16_GRP1_COMMENT 2

//
// share_info_x parmnums.
//

#define PARMNUM_16_SHI_REMARK 4
#define PARMNUM_16_SHI_PERMISSIONS 5
#define PARMNUM_16_SHI_MAX_USES 6
#define PARMNUM_16_SHI_PASSWD 9

//
// server_info_x parmnums.
//

#define PARMNUM_16_SV_COMMENT 5
#define PARMNUM_16_SV_DISC 10
#define PARMNUM_16_SV_ALERTS 11
#define PARMNUM_16_SV_HIDDEN 16
#define PARMNUM_16_SV_ANNOUNCE 17
#define PARMNUM_16_SV_ANNDELTA 18
#define PARMNUM_16_SV_ALERTSCHED 37
#define PARMNUM_16_SV_ERRORALERT 38
#define PARMNUM_16_SV_LOGONALERT 39
#define PARMNUM_16_SV_ACCESSALERT 40
#define PARMNUM_16_SV_DISKALERT 41
#define PARMNUM_16_SV_NETIOALERT 42
#define PARMNUM_16_SV_MAXAUDITSZ 43

//
// user_info_x parmnums.
//

#define PARMNUM_16_USER_PASSWD 3
#define PARMNUM_16_USER_PRIV 5
#define PARMNUM_16_USER_DIR 6
#define PARMNUM_16_USER_COMMENT 7
#define PARMNUM_16_USER_USER_FLAGS 8
#define PARMNUM_16_USER_SCRIPT_PATH 9
#define PARMNUM_16_USER_AUTH_FLAGS 10
#define PARMNUM_16_USER_FULL_NAME 11
#define PARMNUM_16_USER_USR_COMMENT 12
#define PARMNUM_16_USER_PARMS 13
#define PARMNUM_16_USER_WORKSTATIONS 14
#define PARMNUM_16_USER_ACCT_EXPIRES 17
#define PARMNUM_16_USER_MAX_STORAGE 18
#define PARMNUM_16_USER_LOGON_HOURS 20
#define PARMNUM_16_USER_LOGON_SERVER 23
#define PARMNUM_16_USER_COUNTRY_CODE 24
#define PARMNUM_16_USER_CODE_PAGE 25

//
// user_modals_info_x parmnums
//

#define PARMNUM_16_MODAL0_MIN_LEN 1     // These two must be the same!
#define PARMNUM_16_MODAL1_ROLE 1
#define PARMNUM_16_MODAL0_MAX_AGE 2     // These two must be the same!
#define PARMNUM_16_MODAL1_PRIMARY 2
#define PARMNUM_16_MODAL0_MIN_AGE 3
#define PARMNUM_16_MODAL0_FORCEOFF 4
#define PARMNUM_16_MODAL0_HISTLEN 5

//
// wksta_info_x parmnums
//

#define PARMNUM_16_WKSTA_CHARWAIT 10
#define PARMNUM_16_WKSTA_CHARTIME 11
#define PARMNUM_16_WKSTA_CHARCOUNT 12
#define PARMNUM_16_WKSTA_ERRLOGSZ 27
#define PARMNUM_16_WKSTA_PRINTBUFTIME 28
#define PARMNUM_16_WKSTA_WRKHEURISTICS 32
#define PARMNUM_16_WKSTA_OTHDOMAINS 35

#endif // ndef _XSPARM16_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\xsprocsp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    XsProcsP.h

Abstract:

    This header file contains private procedure prototypes for XACTSRV.

Author:

    David Treadwell (davidtr) 05-Jan-1991
    Shanku Niyogi (w-shanku)

Revision History:

--*/

#ifndef _XSPROCSP_
#define _XSPROCSP_

//
// This header file is full of expressions that are always false. These
// expressions manifest themselves in macros that take unsigned values
// and make tests, for example, of greater than or equal to zero.
//
// Turn off these warnings until the authors fix this code.
//

#pragma warning(disable:4296)

//
// Helper subroutines.
//

//
// XsAddVarString(
//     IN OUT LPSTR StringLocation,
//     IN LPTSTR String,
//     IN OUT LPBYTE *Pointer,
//     IN LPBYTE OffsetBegin
// )
//
// Copy string to location, put the offset of location from OffsetBegin
// in Pointer, and update location to point past string.
//
// !!UNICODE!! - Changed strcpy to NetpCopyTStrToStr. Fix WKSTA.H to use this!

#define XsAddVarString( StringLocation, String, Pointer, OffsetBegin ) \
    NetpCopyWStrToStrDBCS((StringLocation), (String));                 \
    SmbPutUlong((LPDWORD)(Pointer),                                    \
        (ULONG)((LPBYTE)(StringLocation)-(LPBYTE)(OffsetBegin)));      \
    StringLocation += (strlen((LPSTR)StringLocation) + 1)

//
// XsAuxiliaryDescriptor - return second argument if 'N' character is present
//     in first argument (an LPDESC), or NULL otherwise.
//
// !!UNICODE!! - Descriptor strings are always Ascii. No conversion.

#define XsAuxiliaryDescriptor( DataDescriptor, EndOfParameters ) \
    (( strchr(( DataDescriptor ), REM_AUX_NUM ) != NULL ) \
        ? (EndOfParameters) : NULL )

//
// BOOL
// XsApiSuccess(
//     IN NET_API_STATUS Status
// )
//
// XsApiSuccess - check if status is one of three allowable ones.
//

#define XsApiSuccess( Status ) \
    (( (Status) == NERR_Success ) || ( (Status) == ERROR_MORE_DATA ) || \
        ( (Status) == NERR_BufTooSmall ))

//
// WORD
// XsDwordToWord(
//     IN DWORD d
// )
//
// Returns the WORD which is closest in value to the supplied DWORD.
//

#define XsDwordToWord(d) \
    ( (WORD) ( (DWORD) (d) > 0xffff ? 0xffff : (d) ) )

//
// BYTE
// XsDwordToByte(
//     IN DWORD d
// )
//
// Returns the BYTE which is closest in value to the supplied DWORD.
//

#define XsDwordToByte(d) \
    ( (BYTE) ( (DWORD) (d) > 0xff ? 0xff : (d) ) )

//
// BYTE
// XsBoolToDigit(
//     IN BOOL b
// )
//
// Returns '1' if the supplied boolean is true, or '0' if it is false.
//

#define XsBoolToDigit(b) \
    ( (BYTE) ( (BOOL)(b) ? '0' : '1' ) )

DWORD
XsBytesForConvertedStructure (
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN LPDESC OutStructureDesc,
    IN RAP_CONVERSION_MODE Mode,
    IN BOOL MeaninglessInputPointers
    );

BOOL
XsCheckBufferSize (
    IN WORD BufferLength,
    IN LPDESC Descriptor,
    IN BOOL NativeFormat
    );

//
// XsDwordParamOutOfRange(
//     IN DWORD Field,
//     IN DWORD Min,
//     IN DWORD Max
//     )
//
// Check if parameter is out of range.
//


#define XsDwordParamOutOfRange( Field, Min, Max )   \
    (((DWORD)SmbGetUlong( &( Field )) < ( Min )) || \
     ((DWORD)SmbGetUlong( &( Field )) > ( Max )))

// !!UNICODE!! - Validation on ASCII string - leave as LPSTR
NET_API_STATUS
XsValidateShareName(
    IN LPSTR ShareName
);

NET_API_STATUS
XsConvertSetInfoBuffer(
    IN LPBYTE InBuffer,
    IN WORD BufferLength,
    IN WORD ParmNum,
    IN BOOL ConvertStrings,
    IN BOOL MeaninglessInputPointers,
    IN LPDESC InStructureDesc,
    IN LPDESC OutStructureDesc,
    IN LPDESC InSetInfoDesc,
    IN LPDESC OutSetInfoDesc,
    OUT LPBYTE * OutBuffer,
    OUT LPDWORD OutBufferLength OPTIONAL
    );

//
// BOOL
// XsDigitToBool(
//     IN BYTE b
// )
//
// Returns false if the supplied digit is '0', true otherwise.
//

#define XsDigitToBool(b) \
    (BOOL)((( b ) == '0' ) ? FALSE : TRUE )

VOID
XsFillAuxEnumBuffer (
    IN LPBYTE InBuffer,
    IN DWORD NumberOfEntries,
    IN LPDESC InStructureDesc,
    IN LPDESC InAuxStructureDesc,
    IN OUT LPBYTE OutBuffer,
    IN LPBYTE OutBufferStart,
    IN DWORD OutBufferLength,
    IN LPDESC OutStructureDesc,
    IN LPDESC OutAuxStructureDesc,
    IN PXACTSRV_ENUM_VERIFY_FUNCTION VerifyFunction OPTIONAL,
    OUT LPDWORD BytesRequired,
    OUT LPDWORD EntriesFilled,
    OUT LPDWORD InvalidEntries OPTIONAL
    );

VOID
XsFillEnumBuffer (
    IN LPBYTE InBuffer,
    IN DWORD NumberOfEntries,
    IN LPDESC InStructureDesc,
    IN OUT LPBYTE OutBuffer,
    IN LPBYTE OutBufferStart,
    IN DWORD OutBufferLength,
    IN LPDESC OutStructureDesc,
    IN PXACTSRV_ENUM_VERIFY_FUNCTION VerifyFunction OPTIONAL,
    OUT LPDWORD BytesRequired,
    OUT LPDWORD EntriesFilled,
    OUT LPDWORD InvalidEntries OPTIONAL
    );

LPBYTE
XsFindParameters (
    IN LPTRANSACTION Transaction
    );

//
// DWORD
// XsLevelFromParmNum(
//     WORD Level,
//     WORD ParmNum
//     )
//
// Translate an old parmnum to an info level. If parmnum is PARMNUM_ALL,
// this is just the old level, otherwise it is the old parmnum plus
// PARMNUM_BASE_INFOLEVEL.
//

#define XsLevelFromParmNum( Level, ParmNum )                      \
    ((( ParmNum ) == PARMNUM_ALL ) ? (DWORD)( Level )             \
                                   : (DWORD)( ParmNum )           \
                                         + PARMNUM_BASE_INFOLEVEL )

//
// Maps downlevel service names to nt service names
//

#define XS_MAP_SERVICE_NAME( ServiceName ) \
        (!STRICMP( ServiceName, SERVICE_LM20_SERVER ) ? SERVICE_SERVER :    \
         !STRICMP( ServiceName, SERVICE_LM20_WORKSTATION ) ? SERVICE_WORKSTATION : \
         ServiceName )


//
// DWORD
// XsNativeBufferSize(
//     IN WORD Size
//     )
//
// Uses XS_BUFFER_SCALE constant to calculate a reasonable maximum for the host
// buffer, and rounds it to an even number for alignment.
//

#define XsNativeBufferSize( Size ) \
    ( (( XS_BUFFER_SCALE * (DWORD)( Size )) + 1) & (~1) )

WORD
XsPackReturnData (
    IN LPVOID Buffer,
    IN WORD BufferLength,
    IN LPDESC Descriptor,
    IN DWORD EntriesRead
    );

VOID
XsSetDataCount(
    IN OUT LPWORD DataCount,
    IN LPDESC Descriptor,
    IN WORD Converter,
    IN DWORD EntriesRead,
    IN WORD ReturnStatus
    );

//
// XsWordParamOutOfRange(
//     IN WORD Field,
//     IN WORD Min,
//     IN WORD Max
//     )
//
// Check if parameter is out of range.
//
// N.B. If Min is zero, then the first part of the following expression is
//      always FALSE.
//

#define XsWordParamOutOfRange( Field, Min, Max )            \
    (((DWORD)SmbGetUshort( &( Field )) < ( (DWORD)Min )) || \
     ((DWORD)SmbGetUshort( &( Field )) > ( (DWORD)Max )))

VOID
XsAnnounceServiceStatus( VOID );

//
// API bogus stub.
//

NTSTATUS
XsNetUnsupportedApi (
    API_HANDLER_PARAMETERS
    );

//
//  Convert an NT style server info array into a packed
//  RAP server info array
//

typedef
USHORT
(XS_CONVERT_SERVER_ENUM_BUFFER_FUNCTION)(
    IN LPVOID ServerEnumBuffer,
    IN DWORD EntriesRead,
    IN OUT PDWORD TotalEntries,
    IN USHORT Level,
    OUT LPBYTE ClientBuffer,
    IN USHORT BufferLength,
    OUT PDWORD EntriesFilled,
    OUT PUSHORT Converter
    );

extern XS_CONVERT_SERVER_ENUM_BUFFER_FUNCTION XsConvertServerEnumBuffer;


//++
//
// ULONG
// XsSmbGetPointer (
//     IN PSMB_ULONG SrcAddress
//     )
//
// Routine Description:
//
//     This macro retrieves a ULONG value from the possibly misaligned
//     source address, avoiding alignment faults.
//     This also takes into account the fact that pointers are 8-bytes on 64-bit.
//
// Arguments:
//
//     SrcAddress - where to retrieve ULONG value from
//
// Return Value:
//
//     ULONG - the value retrieved.  The target must be aligned.
//
//--
#if defined (_WIN64)
#define XsSmbGetPointer(SrcAddress) ((LPBYTE)(  ((__int64)SmbGetUlong((LPVOID)SrcAddress)) + (((__int64)SmbGetUlong( ( ((LPBYTE)SrcAddress) + 4 ) ) ) << 32) ))
#else
#define XsSmbGetPointer SmbGetUlong
#endif


//++
//
// VOID
// XsSmbPutPointer (
//     OUT PSMB_ULONG DestAddress,
//     IN LPVOID Value
//     )
//
// Routine Description:
//
//     This macro stores a POINTER value at the possibly misaligned
//     destination address, avoiding alignment faults.
//     This also takes into account the fact that 64-bit pointers are 8-bytes
//
// Arguments:
//
//     DestAddress - where to store ULONG value
//
//     Value - ULONG to store.  Value must be a constant or an aligned
//         field.
//
// Return Value:
//
//     None.
//
//--
#if defined (_WIN64)
#define XsSmbPutPointer(DestAddress64,Value)                 \
              {                                              \
                    LPDWORD Source = (LPDWORD)(&Value);      \
                    LPDWORD Dest = (LPDWORD)DestAddress64;   \
                    SmbPutUlong( Dest, SmbGetUlong(Source) );             \
                    SmbPutUlong( Dest+1, SmbGetUlong(Source+1) );         \
              }

#else
#define XsSmbPutPointer(DEST,VAL) SmbPutUlong(DEST, (ULONG)VAL)
#endif

#endif // ndef _XSPROCSP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\xsunicod.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    XsUnicod.h

Abstract:

    This module contains declarations for Unicode work done by XACTSRV.

Author:

    Shanku Niyogi(w-shankn)      27-Sep-1991

Revision History:

--*/

#ifndef _XSUNICOD_
#define _XSUNICOD_

//
// Unicode macro/procedure definitions.
//
// !!UNICODE!! - Added these type-independent conversion routines.
// These will probably last only as long as NetpDup isn't written.

//
// XsDupStrToTstr, XsDupTstrToStr - allocate memory and do a
//                          NetpCopy. This memory is XACTSRV memory,
//                          and can be freed with NetpMemoryFree.
//

LPWSTR
XsDupStrToWStr(
    IN LPSTR Src
    );

LPSTR
XsDupWStrToStr(
    IN LPWSTR Src
    );

#ifdef UNICODE

#define XsDupStrToTStr( src ) ((LPTSTR)XsDupStrToWStr(( src )))
#define XsDupTStrToStr( src ) (XsDupWStrToStr((LPWSTR)( src )))

VOID
XsCopyTBufToBuf(
    OUT LPBYTE Dest,
    IN LPBYTE Src,
    IN DWORD DestSize
    );

VOID
XsCopyBufToTBuf(
    OUT LPBYTE Dest,
    IN LPBYTE Src,
    IN DWORD SrcSize
    );

#else

//
// XsDupStrToStr - used instead of strdup so that XsDupStrToTStr macros
//                 end up allocating memory from the same place, which
//                 can be freed with NetpMemoryFree.
//

LPSTR
XsDupStrToStr(
    IN LPSTR Src
    );

#define XsDupStrToTStr( src ) (LPTSTR)XsDupStrToStr( src )
#define XsDupTStrToStr( src ) XsDupStrToStr( (LPSTR)src )
#define XsCopyTBufToBuf( dest, src, size ) RtlCopyMemory( dest, src, size )
#define XsCopyBufToTBuf( dest, src, size ) RtlCopyMemory( dest, src, size )

#endif // def UNICODE

//
// VOID
// XsConvertTextParameter(
//     OUT LPTSTR OutParam,
//     IN LPSTR InParam
// )
//
// Convert InParam parameter to Unicode, allocating memory, and return the
// address in OutParam. Free with NetpMemoryFree.
//

#define XsConvertTextParameter( OutParam, InParam )     \
    if (( InParam ) == NULL ) {                         \
        OutParam = NULL;                                \
    } else {                                            \
        OutParam = XsDupStrToTStr( InParam );           \
        if (( OutParam ) == NULL ) {                    \
            Header->Status = (WORD)NERR_NoRoom;         \
            status = NERR_NoRoom;                       \
            goto cleanup;                               \
        }                                               \
    }

//
// VOID
// XsConvertUnicodeTextParameter(
//     OUT LPWSTR OutParam,
//     IN LPSTR InParam
// )
//
// Convert InParam parameter to Unicode, allocating memory, and return the
// address in OutParam. Free with NetpMemoryFree.
//

#define XsConvertUnicodeTextParameter( OutParam, InParam ) \
    if (( InParam ) == NULL ) {                            \
        OutParam = NULL;                                   \
    } else {                                               \
        OutParam = XsDupStrToWStr( InParam );              \
        if (( OutParam ) == NULL ) {                       \
            Header->Status = (WORD)NERR_NoRoom;            \
            status = NERR_NoRoom;                          \
            goto cleanup;                                  \
        }                                                  \
    }

#endif // ndef _XSUNICOD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\xsunicod.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    XsUnicod.c

Abstract:

    This module contains Unicode routines for XACTSRV.

Author:

    Shanku Niyogi (w-shankn)   27-Sep-1990

Revision History:

--*/

#include "xactsrvp.h"
#include <prefix.h>     // PREFIX_ equates.



LPWSTR
XsDupStrToWStr(
    IN LPSTR Src
    )

/*++

Routine Description:

    This routine is an ANSI->Unicode equivalent of the run-time strdup
    function.

Arguments:

    Src - A pointer to the source string.

Return Value:

    LPWSTR - Pointer to the destination string if successful, NULL otherwise.
        Memory must be freed with NetpMemoryFree.

--*/

{

    LPWSTR dest = NULL;

    if (( dest = NetpMemoryAllocate(sizeof(WCHAR) * ( strlen( Src ) + 1 )))
           == NULL ) {

        return NULL;

    }

    NetpCopyStrToWStr( dest, Src );
    return dest;

} // XsDupStrToWStr


LPSTR
XsDupWStrToStr(
    IN LPWSTR Src
    )

/*++

Routine Description:

    This routine is a Unicode->ANSI equivalent of the run-time strdup
    function.

Arguments:

    Src - A pointer to the source string.

Return Value:

    LPSTR - Pointer to the destination string if successful, NULL otherwise.
        Memory must be freed with NetpMemoryFree.

--*/

{

    LPSTR dest = NULL;

    if (( dest = NetpMemoryAllocate( NetpUnicodeToDBCSLen( Src ) + 1 )) == NULL ) {
        return NULL;

    }

    NetpCopyWStrToStrDBCS( dest, Src );
    return dest;

} // XsDupWStrToStr


LPSTR
XsDupStrToStr(
    IN LPSTR Src
    )

/*++

Routine Description:

    This routine is equivalent to the run-time strdup function, but allocates
    memory using NetpMemory functions.

Arguments:

    Src - A pointer to the source string.

Return Value:

    LPSTR - Pointer to the destination string if successful, NULL otherwise.
        Memory must be freed with NetpMemoryFree.

--*/

{

    LPSTR dest = NULL;

    if (( dest = NetpMemoryAllocate( strlen( Src ) + 1 )) == NULL ) {

        return NULL;

    }

    strcpy( dest, Src );
    return dest;

} // XsDupStrToStr

#ifdef UNICODE


VOID
XsCopyTBufToBuf(
    OUT LPBYTE Dest,
    IN LPBYTE Src,
    IN DWORD DestSize
    )

/*++

Routine Description:

    This routine is a Unicode->ANSI equivalent of the run-time memcpy
    function.

Arguments:

    Dest - A pointer to the destination buffer.

    Src - A pointer to the source buffer.

    DestSize - The size, in bytes, of the destination buffer.

Return Value:

    none.

--*/

{
    DWORD finalDestSize;
    NTSTATUS ntStatus;
    DWORD srcSize;

    if ( (Dest == NULL) || (Src == NULL) || (DestSize == 0) ) {

        return;
    }

    srcSize = WCSSIZE( (LPWSTR) Src );
    NetpAssert( srcSize > 0 );

    ntStatus = RtlUnicodeToOemN(
            (PCHAR) Dest,               // OEM string
            (ULONG) DestSize,           // max bytes in OEM string
            (PULONG) & finalDestSize,   // bytes in OEM string
            (PWSTR) Src,                // UNICODE string
            (ULONG) srcSize             // bytes in UNICODE string
            );

    if ( !NT_SUCCESS( ntStatus ) ) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( PREFIX_XACTSRV
                "XsCopyTBufToBuf: unexpected return code from "
                "RtlUnicodeToOemN: " FORMAT_NTSTATUS ".\n",
                ntStatus ));
        }
    }

    return;

} // XsCopyTBufToBuf




VOID
XsCopyBufToTBuf(
    OUT LPBYTE Dest,
    IN LPBYTE Src,
    IN DWORD SrcSize
    )

/*++

Routine Description:

    This routine is a ANSI->Unicode equivalent of the run-time memcpy
    function.

Arguments:

    Dest - A pointer to the destination buffer.

    Src - A pointer to the source buffer.

    SrcSize - The size, in bytes, of the source buffer.

Return Value:

    none.

--*/

{
    DWORD finalDestSize;
    DWORD destSize = SrcSize * sizeof(WCHAR);   // max byte count for dest.
    NTSTATUS ntStatus;

    if ( (Dest == NULL) || (Src == NULL) || (SrcSize == 0) ) {

        return;
    }
    NetpAssert( destSize > 0 );

    ntStatus = RtlOemToUnicodeN(
            (PWSTR) Dest,               // UNICODE string
            (ULONG) destSize,           // max bytes in UNICODE buffer
            (PULONG) & finalDestSize,   // final bytes in UNICODE buffer
            (PCHAR) Src,                // OEM string
            (ULONG) SrcSize             // bytes in OEM string
            );

    if ( !NT_SUCCESS( ntStatus ) ) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( PREFIX_XACTSRV
                "XsCopyBufToTBuf: unexpected return code from "
                "RtlOemToUnicodeN: " FORMAT_NTSTATUS ".\n",
                ntStatus ));
        }
    }

} // XsCopyBufToTBuf

#endif // def UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\xactsrv\xssubs.c ===
/*++

Copyright (c) 1991-92 Microsoft Corporation

Module Name:

    XsSubs.c

Abstract:

    This module contains various subroutines for XACTSRV.

Author:

    David Treadwell (davidtr)    07-Jan-1991

Revision History:

    05-Oct-1992 JohnRo
        RAID 3556: DosPrintQGetInfo(from downlevel) level 3, rc=124.  (4&5 too.)
    (Fixed XsFillAuxEnumBuffer.)

--*/

#include "XactSrvP.h"
#include <WinBase.h>          // GetCurrentProcessId prototype
#include <align.h>

VOID
SmbCapturePtr(
    LPBYTE  PointerDestination,
    LPBYTE  PointerSource
    );


DWORD
XsBytesForConvertedStructure (
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN LPDESC OutStructureDesc,
    IN RAP_CONVERSION_MODE Mode,
    IN BOOL MeaninglessInputPointers
    )

/*++

Routine Description:

    This routine determines the number of bytes that would be required
    to hold the input structure when converted to the structure
    described by OutStructureDesc.

Arguments:

    InStructure - a pointer to the actual input structure.

    InStructureDesc - a pointer to an ASCIIZ describing the format of the
        input structure.

    OutStructureDesc - a pointer to an ASCIIZ describing the format of the
        output structure.

    Mode - indicates mode of conversion (native to RAP or vice versa).

Return Value:

    DWORD - The number of bytes required to hold the converted structure.

--*/

{
    NET_API_STATUS status;
    DWORD bytesRequired = 0;

    //
    // Use RapConvertSingleEntry to get the size that the input structure
    // will take when converted to the format specified in the output
    // structure description.  That routine should not actually write
    // anything--it should simply appear that there is no room to
    // write more data into, just as if an Enum buffer is full.
    //

    //
    // Should handle errors from RapConvertSingleEntry.
    // But the way this is used, existing code probably
    // won't break if we just ignore them.
    //

    status = RapConvertSingleEntry(
                 InStructure,
                 InStructureDesc,
                 MeaninglessInputPointers,
                 NULL,
                 NULL,
                 OutStructureDesc,
                 FALSE,
                 NULL,
                 &bytesRequired,
                 Response,
                 Mode
                 );

    //
    // For native structures, we should make sure the buffer is an even amount,
    // to allow an even boundary for strings, as in Unicode.
    //

    if ( Mode == RapToNative ) {

        bytesRequired = ROUND_UP_COUNT( bytesRequired, ALIGN_DWORD );
    }

    return bytesRequired;

} // XsBytesForConvertedStructure


LPVOID
XsCaptureParameters (
    IN LPTRANSACTION Transaction,
    OUT LPDESC *AuxDescriptor
    )

/*++

Routine Description:

    This routine captures all input parameters from the transaction block
    and puts them into a consistent structure that API handlers can access.
    It allocates memory to hold this structure.  This memory should be
    freed by XsSetParameters after the API handler has done its work.

Arguments:

    Transaction - a pointer to the transaction block describing the
        request.

    AuxDescriptor - a pointer to a LPDESC which will hold a pointer to
        the auxiliary descriptor string if there is one, or NULL if there
        is not.

Return Value:

    LPVOID - a pointer to a buffer containing the captured parameters.

--*/

{
    LPDESC descriptorString;
    LPDESC descriptor;
    LPBYTE inParams;
    DWORD outParamsLength;
    LPBYTE outParams;
    LPBYTE outParamsPtr;
    WORD rcvBufferLength;

    //
    // The first two bytes of the parameter section are the API number,
    // then comes the descriptor string.
    //

    descriptorString = Transaction->InParameters + 2;

    //
    // Find the actual parameter data in the input.
    //

    inParams = XsFindParameters( Transaction );

    //
    // Find out how much space to allocate to hold the parameters.
    //

    outParamsLength = RapStructureSize( descriptorString, Response, FALSE );

    //
    // Allocate space to hold the output parameters.
    // In addition when the request fails the current APIs set the buflen field
    // In order to account for this additional buffer space is allocated. Since
    // this field is not located at the same offset we need to compute the
    // additional space reqd. to be the maximum of all the offsets. Currently
    // the 16 byte offset seems to suffice. When modifying apiparam.h ensure
    // that this is the case.
    //

    outParams = NetpMemoryAllocate( sizeof(XS_PARAMETER_HEADER)
                                        + outParamsLength +
                                        sizeof(DWORD) * 4);

    if ( outParams == NULL ) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsCaptureParameters: unable to allocate %ld bytes\n",
                          outParamsLength ));
        }
        return NULL;
    }

    //
    // Zero out the parameters and set outParamsPtr to the start of the
    // actual parameters.
    //

    RtlZeroMemory( outParams, sizeof(XS_PARAMETER_HEADER) + outParamsLength );
    outParamsPtr = outParams + sizeof(XS_PARAMETER_HEADER);

    //
    // For each character in the descriptor string, fill in the output
    // parameters as appropriate.
    //

    for ( descriptor = descriptorString; *descriptor != '\0'; ) {

        switch ( *descriptor++ ) {

        case REM_ASCIZ:

            //
            // The parameter is a pointer to a string. The actual string
            // is in the parameter data, so put a pointer to it in the
            // output structure.
            //
            // String parameters just get passed as is. It
            // is up to the API handler to convert the actual data.
            //

            //
            // !!! Parameter string descriptors may not have maximum length
            //     counts.
            //

            if( isdigit( *descriptor ) ) {
                NetpMemoryFree( outParams );
                return NULL;
            }

            SmbCapturePtr( outParamsPtr, inParams );

            //
            // Update pointers -- move inParams past end of string.
            //

            inParams += ( strlen( inParams ) + 1 );
            outParamsPtr += sizeof(LPSTR);

            break;

        case REM_BYTE_PTR:
        case REM_FILL_BYTES:

            //
            // The parameter is a pointer to a byte or array of bytes.
            //

            SmbCapturePtr( outParamsPtr, inParams );

            inParams += sizeof(BYTE) * RapDescArrayLength( descriptor );
            outParamsPtr += sizeof(LPBYTE);

            break;

        case REM_DWORD:

            //
            // The parameter is a dword or array of dwords.
            //
            // !!! This assumes that an array of words will never be passed
            //     as a parameter.

            if( isdigit( *descriptor ) ) {
                NetpMemoryFree( outParams );
                return NULL;
            }

            //
            // Copy over the double word and update pointers.
            //

            SmbPutUlong(
                (LPDWORD)outParamsPtr,
                SmbGetUlong( (LPDWORD)inParams )
                );

            inParams += sizeof(DWORD);
            outParamsPtr += sizeof(DWORD);

            break;

        case REM_ENTRIES_READ:
        case REM_RCV_WORD_PTR:

            //
            // Count of entries read (e) or receive word pointer (h).
            // This is an output parameter, so just zero it and
            // increment the output parameter pointer.
            //

            SmbPutUshort( (LPWORD)outParamsPtr, 0 );

            outParamsPtr += sizeof(WORD);

            break;

        case REM_RCV_DWORD_PTR:

            //
            // Count of receive dword pointer (i).
            // This is an output parameter, so just zero it and
            // increment the output parameter pointer.
            //

            SmbPutUlong( (LPDWORD)outParamsPtr, 0 );

            outParamsPtr += sizeof(DWORD);

            break;

        case REM_NULL_PTR:

            //
            // Null pointer. Set output parameter to NULL, and increment
            // pointers.
            //

            SmbCapturePtr( outParamsPtr, NULL );
            outParamsPtr += sizeof(LPSTR);

            break;

        case REM_RCV_BUF_LEN:

            //
            // The length of the receive buffer (r).
            //

            rcvBufferLength = SmbGetUshort( (LPWORD)inParams );

            //
            // If the indicated buffer length is greater than the max
            // data count on the transaction, somebody messed up. Set
            // the length to MaxDataCount.
            //

            if ( rcvBufferLength > (WORD)Transaction->MaxDataCount ) {

                IF_DEBUG(ERRORS) {
                    NetpKdPrint(( "XsCaptureParameters: OutBufLen %lx greater than MaxDataCount %lx.\n",
                    rcvBufferLength, Transaction->MaxDataCount ));
                }

                rcvBufferLength = (WORD)Transaction->MaxDataCount;
            }

            //
            // Put the max output data length in the output parameters.
            //

            SmbPutUshort( (LPWORD)outParamsPtr, rcvBufferLength );

            //
            // Fill in the receive buffer with zeroes for security.
            //

            RtlZeroMemory( Transaction->OutData, (DWORD)rcvBufferLength );

            inParams += sizeof(WORD);
            outParamsPtr += sizeof(WORD);

            break;

        case REM_RCV_BUF_PTR:

            //
            // A pointer to a receive data buffer.  There is nothing in
            // the transaction corresponding to this, but set a longword
            // in the output parameters to point to the data output
            // section of the transaction.
            //

            SmbCapturePtr(
                outParamsPtr,
                Transaction->OutData
                );

            outParamsPtr += sizeof(LPBYTE);

            break;

        case REM_RCV_BYTE_PTR:

            //
            // Return bytes, so just increment output parameter pointer.
            //

            outParamsPtr += sizeof(BYTE) * RapDescArrayLength( descriptor );

            break;

        case REM_SEND_BUF_LEN:

            //
            // The size of an input data buffer.  Put the size of the
            // received data in the output structure.
            //

            SmbPutUshort(
                (LPWORD)outParamsPtr,
                (WORD)Transaction->DataCount
                );

            outParamsPtr += sizeof(WORD);

            break;

        case REM_SEND_BUF_PTR:

            //
            // A pointer to a send data buffer.  There is nothing in the
            // transaction corresponding to this, but set a longword in
            // the output parameters to point to the data input section
            // of the transaction.
            //

            SmbCapturePtr( outParamsPtr, Transaction->InData );

            outParamsPtr += sizeof(LPBYTE);

            break;

        case REM_WORD:
        case REM_PARMNUM:

            //
            // The parameter is a word.
            //
            // !!! This assumes that an array of words will never be passed
            //     as a parameter.

            if( isdigit( *descriptor ) ) {
                NetpMemoryFree( outParams );
                return NULL;
            }

            //
            // Copy over the word and update pointers.
            //

            SmbPutUshort(
                (LPWORD)outParamsPtr,
                SmbGetUshort( (LPWORD)inParams )
                );

            inParams += sizeof(WORD);
            outParamsPtr += sizeof(WORD);

            break;

        default:

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsCaptureParameters: unsupported character at %lx: "
                                "%c\n", descriptor - 1, *( descriptor - 1 ) ));
                NetpBreakPoint( );
            }
        }
    }

    //
    // Examine the data descriptor string to see if an auxiliary descriptor
    // string exists. If it does, the string starts right after the end
    // of the parameters.
    //

    *AuxDescriptor = XsAuxiliaryDescriptor( ++descriptor, inParams );

    return outParams;

} // XsCaptureParameters


BOOL
XsCheckBufferSize (
    IN WORD BufferLength,
    IN LPDESC Descriptor,
    IN BOOL NativeFormat
    )

/*++

Routine Description:

    This routine determines if there is enough room in the buffer for the
    fixed component of at least one entry of the described structure.

Arguments:

    BufferLength - the length of the buffer to test.

    Descriptor - the format of the structure in the buffer.

    NativeFormat - TRUE iff the buffer is in native (as opposed to RAP) format.

Return Value:

    BOOL - True if there is enough room, false if there isn't.

--*/

{
    if ( (DWORD)BufferLength
            >= RapStructureSize( Descriptor, Response, NativeFormat )) {

        return TRUE;

    } else {

        return FALSE;

    }

} // XsCheckBufferSize


BOOL
XsCheckSmbDescriptor(
    IN LPDESC SmbDescriptor,
    IN LPDESC ActualDescriptor
)

/*++

Routine Description:

    This routine checks whether a descriptor passed in the SMB matches
    the actual descriptor expected, taking into account that the actual
    descriptor may have ignore fields which have no corresponding field in
    the SMB descriptor, and that the SMB descriptor may have null pointer
    fields instead of normal pointer fields. However, array-type fields
    have to be of the same length in both descriptors.

Arguments:

    SmbDescriptor - the descriptor to be validated.

    ActualDescriptor - the descriptor expected. Does not have to be an
        exact match - see the description above.

Return Value:

    BOOL - TRUE if the descriptor is valid,
           FALSE otherwise.

--*/

{
    DESC_CHAR smbField;
    DESC_CHAR expField;
    DWORD smbFieldSize;
    DWORD expFieldSize;

    while (( smbField = *SmbDescriptor++ ) != '\0' ) {

        smbFieldSize = RapDescArrayLength( SmbDescriptor );

        //
        // Skip over ignore fields.
        //

        while ( *ActualDescriptor == REM_IGNORE ) {
            ActualDescriptor++;
        }

        //
        // There should be a corresponding field expected.
        //

        if (( expField = *ActualDescriptor++ ) == '\0' ) {
            return FALSE;
        }

        expFieldSize = RapDescArrayLength( ActualDescriptor );

        //
        // If both are actual data fields, they must be the same type and of
        // same length.
        //

        if (( !RapIsPointer( expField ) || smbField != REM_NULL_PTR ) &&
                 ( smbField != expField || smbFieldSize != expFieldSize )) {
            return FALSE;
        }

        //
        // SMB provides a null pointer field, we are expecting any pointer.
        // This is OK, as long as there is no input array length.
        //

        if ( smbField == REM_NULL_PTR &&
                 ( !RapIsPointer( expField ) || smbFieldSize != 1 )) {
            return FALSE;
        }
    }

    return TRUE;

} // XsCheckSmbDescriptor


NET_API_STATUS
XsConvertSetInfoBuffer(
    IN LPBYTE InBuffer,
    IN WORD BufferLength,
    IN WORD ParmNum,
    IN BOOL ConvertStrings,
    IN BOOL MeaninglessInputPointers,
    IN LPDESC InStructureDesc,
    IN LPDESC OutStructureDesc,
    IN LPDESC InSetInfoDesc,
    IN LPDESC OutSetInfoDesc,
    OUT LPBYTE * OutBuffer,
    OUT LPDWORD OutBufferLength OPTIONAL
    )

/*++

Routine Description:

    This routine converts data for a SetInfo call based on the parameter
    number (ParmNum) value. The ParmNum indicates the field in the whole
    structure which has to be changed, and may be 0.

Arguments:

    InBuffer - a pointer to the input buffer in 16-bit format.

    BufferLength - the length of the input buffer.

    ParmNum - the parameter number.

    ConvertStrings - a boolean indicating whether string parameter data
        should be converted to a pointer form. If TRUE, the return data
        buffer will have a pointer to another place in the buffer where
        the string will be. If FALSE, the data buffer will have only the
        physical string.

    InStructureDesc - the exact descriptor of the input buffer.

    OutStructureDesc - the descriptor of the 32-bit output data, as found
        in RemDef.h.

    InSetInfoDesc - the setinfo-specific descriptor of the input structure
        format, as found in RemDef.h.

    OutSetInfoDesc - the setinfo-specific descriptor of the output structure
        format, as found in RemDef.h.

    OutBuffer - a pointer to an LPBYTE which will get a pointer to the
        resulting output buffer.

    OutBufferLength - an optional pointer to a DWORD which will get the
        length of the resulting output buffer.

Return Value:

    NET_API_STATUS - NERR_Success if conversion was successful; otherwise
        the appropriate status to return to the user. The only exception is
        ERROR_NOT_SUPPORTED, which indicates that the particular parameter
        number is valid, but not on NT.

--*/

{

    LPDESC fieldDesc = NULL;
    DWORD stringLength;
    LPDESC subDesc = NULL;
    LPDESC subDesc2 = NULL;
    DWORD bufferSize;
    LPBYTE stringLocation;
    DWORD bytesRequired = 0;
    LPDESC OutDescCopy = OutStructureDesc;
    NET_API_STATUS status = NERR_Success;

    //
    // The buffer length should be greater than 0.
    //

    if ( BufferLength == 0 ) {

        return NERR_BufTooSmall;

    }

    if ( ParmNum != PARMNUM_ALL ) {

        //
        // Check 16-bit parameter to see if it could be changed in OS/2.
        //

        fieldDesc = RapParmNumDescriptor( InSetInfoDesc, (DWORD)ParmNum,
                        Both, FALSE );

        if ( fieldDesc == NULL ) {

            return NERR_NoRoom;
        }

        if ( fieldDesc[0] == REM_UNSUPPORTED_FIELD ) {

            status = ERROR_INVALID_PARAMETER;
            goto cleanup;

        } else {

            InStructureDesc = RapParmNumDescriptor( InStructureDesc,
                                  (DWORD)ParmNum, Both, FALSE );
        }

        NetpMemoryFree( fieldDesc );

        //
        // Check 32-bit parameter to see if it is valid in NT.
        //

        fieldDesc = RapParmNumDescriptor( OutSetInfoDesc, (DWORD)ParmNum,
                        Both, TRUE );

        if ( fieldDesc == NULL ) {

            return NERR_NoRoom;
        }

        if ( fieldDesc[0] == REM_IGNORE ) {

            status = ERROR_NOT_SUPPORTED;
            goto cleanup;

        } else {

            OutStructureDesc = RapParmNumDescriptor( OutStructureDesc,
                                   (DWORD)ParmNum, Both, TRUE );
        }

        //
        // Filter out strings that are too long for LM2.x.
        //

        if ( InStructureDesc[0] == REM_ASCIZ
             || InStructureDesc[0] == REM_ASCIZ_TRUNCATABLE ) {

            subDesc = InStructureDesc + 1;
            stringLength = RapDescStringLength( subDesc );
            subDesc = NULL;
            if ( stringLength && strlen( InBuffer ) >= stringLength ) {
                switch( InStructureDesc[0] ) {
                case REM_ASCIZ:
                    status = ERROR_INVALID_PARAMETER;
                    goto cleanup;
                case REM_ASCIZ_TRUNCATABLE:
                    InBuffer[stringLength - 1] = '\0';
                }
            }
        }

        //
        // If a descriptor is a string pointer, the data is the actual
        // string, rather than a pointer. Find the length of the string,
        // and create a descriptor.
        //
        // Assuming all these arrays are string data, we
        // use available macros to generate an array big
        // enough to hold the converted string.

        if ( InStructureDesc[0] == REM_ASCIZ
             || InStructureDesc[0] == REM_ASCIZ_TRUNCATABLE ) {

            if (( subDesc = NetpMemoryAllocate( MAX_DESC_SUBSTRING + 1 ))
                      == NULL ) {
                status = NERR_NoRoom;
                goto cleanup;
            }
            stringLength = strlen( InBuffer ) + 1;
            subDesc[0] = REM_BYTE;
            _ltoa( stringLength, &subDesc[1], 10 );
            InStructureDesc = subDesc;

        }

        //
        // If output descriptor is a string pointer, and we are asked to keep
        // strings inline, make the target data an array of bytes. We find out
        // the length required by "walking" the input descriptor, and then
        // allocate memory to hold a similar descriptor.
        //
        // Assuming all these arrays are string data, we
        // use available macros to generate an array big
        // enough to hold the converted string. Because of the way
        // RAP works, if the destination string is Unicode, the destination
        // array will be exactly twice as long, and RAP will automatically
        // do the Unicode conversion.
        //

        if (( OutStructureDesc[0] == REM_ASCIZ
             || OutStructureDesc[0] == REM_ASCIZ_TRUNCATABLE )
             && !ConvertStrings ) {

            OutDescCopy = OutStructureDesc;
            subDesc2 = InStructureDesc + 1;
            stringLength = RapDescArrayLength( subDesc2 );
            if (( subDesc2 = NetpMemoryAllocate( MAX_DESC_SUBSTRING + 1 ))
                      == NULL ) {
                status = NERR_NoRoom;
                goto cleanup;
            }
            subDesc2[0] = REM_BYTE;
            _ltoa( STRING_SPACE_REQD( stringLength ), &subDesc2[1], 10 ) ;
            OutStructureDesc = subDesc2;
        }

    }

    if ( !XsCheckBufferSize( BufferLength, InStructureDesc, FALSE )) {

        status = NERR_BufTooSmall;
        goto cleanup;
    }

    //
    // Find out how big a 32-bit data buffer we need.
    //

    bufferSize = XsBytesForConvertedStructure(
                     InBuffer,
                     InStructureDesc,
                     OutStructureDesc,
                     RapToNative,
                     MeaninglessInputPointers
                     );

    //
    // Allocate enough memory to hold the converted native buffer.
    //

    *OutBuffer = NetpMemoryAllocate( bufferSize );

    if ( *OutBuffer == NULL ) {

        status = NERR_NoRoom;
        goto cleanup;
    }


    //
    // Convert 16-bit data into 32-bit data and store it in the native
    // buffer.
    //

    stringLocation = *OutBuffer + bufferSize;
    bytesRequired = 0;

    status = RapConvertSingleEntry(
                 InBuffer,
                 InStructureDesc,
                 MeaninglessInputPointers,
                 *OutBuffer,
                 *OutBuffer,
                 OutStructureDesc,
                 FALSE,
                 &stringLocation,
                 &bytesRequired,
                 Response,
                 RapToNative
                 );

    if ( status != NERR_Success ) {
        IF_DEBUG(ERRORS) {
            NetpKdPrint(( "XsConvertSetInfoBuffer: RapConvertSingleEntry "
                          "failed %X\n", status ));
        }

        status = NERR_InternalError;
        goto cleanup;
    }

cleanup:

    //
    // Free buffers.
    //

    NetpMemoryFree( subDesc );
    NetpMemoryFree( subDesc2 );
    NetpMemoryFree( fieldDesc );

    if ( OutBufferLength != NULL ) {

        *OutBufferLength = bytesRequired;
    }

    return status;

} // XsConvertSetInfoBuffer


NET_API_STATUS
XsDefaultEnumVerifyFunction (
    NET_API_STATUS ConvertStatus,
    PBYTE ConvertedEntry,
    PBYTE BaseAddress
    )

/*++

Routine Description:

    This is the default routine called by XsFillEnumBuffer to determine
    whether each converted entry should be retained or discarded.  This
    routine directs XsFillEnumBuffer to discard any entry which
    RapConvertSingleEntry encountered an error trying to convert.

Parameters:

    ConvertStatus - the status which RapConvertSingleEntry encountered
        trying to convert this entry.

    ConvertedEntry - a pointer to the buffer containing the converted entry.

    BaseAddress - A pointer to the base used to calculate offsets.

Return Value:

    NET_API_STATUS - NERR_Success if the entry should be retained,
               or an error code if the entry should be discarded.

--*/

{
    UNREFERENCED_PARAMETER(ConvertedEntry);
    UNREFERENCED_PARAMETER(BaseAddress);

    return ConvertStatus;
}


VOID
XsFillAuxEnumBuffer (
    IN LPBYTE InBuffer,
    IN DWORD NumberOfEntries,
    IN LPDESC InStructureDesc,
    IN LPDESC InAuxStructureDesc,
    IN OUT LPBYTE OutBuffer,
    IN LPBYTE OutBufferStart,
    IN DWORD OutBufferLength,
    IN LPDESC OutStructureDesc,
    IN LPDESC OutAuxStructureDesc,
    IN PXACTSRV_ENUM_VERIFY_FUNCTION VerifyFunction OPTIONAL,
    OUT LPDWORD BytesRequired,
    OUT LPDWORD EntriesFilled,
    OUT LPDWORD InvalidEntries OPTIONAL
    )

/*++

Routine Description:

    This routine copies all Enum structures which have auxiliary data
    from 32-bit format to 16-bit format. As many complete entries as
    possible are copied, then possibly some incomplete entries.
    All pointer fields are converted to offsets so that this buffer
    may be returned directly to the requesting client.

    Enum buffers with auxiliary data have one or more auxiliary
    structures, with possible variable data, after each entry.

Arguments:

    InBuffer - a pointer to the input information in 32-bit format.

    NumberOfEntries - the count of fixed structures in the input buffer.

    InStructureDesc - description of the input fixed structure.

    InAuxStructureDesc - description of the input auxiliary structure.

    OutBuffer - a pointer to where to write the 16-bit buffer.

    OutBufferStart - a pointer to the actual start of the 16-bit buffer.
        Used to calculate offsets for all pointers in structures.

    OutBufferLength - length of the output buffer.

    OutStructureDesc - description of the output fixed structure.

    OutAuxStructureDesc - description of the output fixed structure.

    VerifyFunction - a pointer to a function which is be called after
        each enum record is converted in order to determine whether
        the record should be retained or discarded.  The function
        is passed the return code from RapConvertSingleEntry and
        a pointer to the converted entry.  It must return NERR_SUCCESS
        if the entry is to be retained, or any error code if the entry
        is to be discarded.  If no function is supplied, a default function
        is used, which discards an entry only if RapConvertSingleEntry
        returned an error trying to convert it.

    BytesRequired - a pointer to a DWORD to receive the total number of
        bytes that would be required to hold the entire output buffer.

    EntriesFilled - a pointer to a DWORD to receive the total number of
        entries that could be put in the buffer given.

    InvalidEntries - an optional pointer to a DWORD to receive the total
        number of entries discarded by the verify function. If NULL, this
        value will be not be available to the caller.

Return Value:

    None.

--*/

{

    NET_API_STATUS status;
    DWORD currentEntry;
    LPBYTE currentInEntryPtr;
    LPBYTE currentOutEntryPtr;
    LPBYTE outputStringLocation;
    LPBYTE oldStringLocation;
    DWORD inputStructureSize;
    DWORD inputAuxStructureSize;
    DWORD outputStructureSize;
    DWORD outputAuxStructureSize;
    DWORD inputAuxCount;
    DWORD currentAux;
    DWORD outputAuxOffset;
    DWORD newBytesRequired;
    DWORD auxBytesRequired;
    DWORD remainingSize;
    DWORD invalidEntries = 0;

    //
    // In degenerate case, just call FillEnumBuffer.
    //

    if ( InAuxStructureDesc == NULL || OutAuxStructureDesc == NULL ) {

        XsFillEnumBuffer (
            InBuffer,
            NumberOfEntries,
            InStructureDesc,
            OutBuffer,
            OutBufferStart,
            OutBufferLength,
            OutStructureDesc,
            VerifyFunction,
            BytesRequired,
            EntriesFilled,
            InvalidEntries
            );

        return;
    }

    if ( VerifyFunction == NULL ) {
        VerifyFunction = &XsDefaultEnumVerifyFunction;
    }

    //
    // Set up sizes of input and output structures.
    //

    inputStructureSize = RapStructureSize( InStructureDesc, Response, TRUE );
    inputAuxStructureSize
        = RapStructureSize( InAuxStructureDesc, Response, TRUE );
    outputStructureSize = RapStructureSize( OutStructureDesc, Response, FALSE );
    outputAuxStructureSize
        = RapStructureSize( OutAuxStructureDesc, Response, FALSE );
    outputAuxOffset = RapAuxDataCountOffset( InStructureDesc, Response, TRUE );

    outputStringLocation = (LPBYTE)OutBuffer + OutBufferLength;
    *BytesRequired = 0;

    //
    // Check if one fixed entry will fit.
    //

    if ( inputStructureSize > OutBufferLength ) {

        *EntriesFilled = 0;
        goto cleanup;
    }

    //
    // Loop through the entries, converting along the way.
    //

    currentInEntryPtr = InBuffer;
    currentOutEntryPtr = OutBuffer;
    *EntriesFilled = 0;

    for ( currentEntry = 0; currentEntry < NumberOfEntries; currentEntry++ ) {

        //
        // If there wasn't enough room for the conversion, we can quit now.
        //

        if ( currentOutEntryPtr + outputStructureSize > outputStringLocation ) {

            break;
        }

        newBytesRequired = *BytesRequired;
        oldStringLocation = outputStringLocation;

        //
        // Get the auxiliary number count.
        //

        inputAuxCount = RapAuxDataCount(
                            currentInEntryPtr,
                            InStructureDesc,
                            Response,
                            TRUE
                            );

        NetpAssert( inputAuxCount != NO_AUX_DATA );

        //
        // Convert the fixed entry.
        //

        status = RapConvertSingleEntry(
                     currentInEntryPtr,
                     InStructureDesc,
                     FALSE,
                     OutBufferStart,
                     currentOutEntryPtr,
                     OutStructureDesc,
                     TRUE,
                     &outputStringLocation,
                     &newBytesRequired,
                     Response,
                     NativeToRap
                     );

        //
        // Check if the entry is valid. If it is not, fix up pointers,
        // and start with the next entry in the list.
        // If there are more than 65536 auxiliary structures (which
        // probably never happens anyway), this entry is automatically
        // invalid.
        //


        status = (*VerifyFunction)(
                     status,
                     currentOutEntryPtr,
                     OutBufferStart
                     );

        if ( status != NERR_Success || inputAuxCount > 0xFFFF ) {

            invalidEntries++;
            currentInEntryPtr += inputStructureSize
                                     + inputAuxCount * inputAuxStructureSize;
            outputStringLocation = oldStringLocation;
            continue;

        }

        //
        // Prepare pointers for converting the auxiliary structures.
        //

        currentInEntryPtr += inputStructureSize;
        currentOutEntryPtr += outputStructureSize;

        //
        // Try to add the auxiliary structures.
        //

        for ( currentAux = 0; currentAux < inputAuxCount; currentAux++ ) {

            remainingSize = (DWORD)(outputStringLocation - currentOutEntryPtr);
            auxBytesRequired = 0;

            status = RapConvertSingleEntry(
                         currentInEntryPtr,
                         InAuxStructureDesc,
                         FALSE,
                         OutBufferStart,
                         currentOutEntryPtr,
                         OutAuxStructureDesc,
                         TRUE,
                         &outputStringLocation,
                         &auxBytesRequired,
                         Response,
                         NativeToRap
                         );

            //
            // Did this aux. entry fit? If all the aux. entries do not fit,
            // we are going to play it safe and say the main entry did not
            // fit.
            //

            if ( status != NERR_Success || auxBytesRequired > remainingSize ) {
                goto cleanup;
            }

            currentInEntryPtr += inputAuxStructureSize;
            currentOutEntryPtr += outputAuxStructureSize;
            newBytesRequired += auxBytesRequired;
        }

        *BytesRequired = newBytesRequired;
        *EntriesFilled += 1;
    }

cleanup:

    if ( InvalidEntries != NULL ) {

        *InvalidEntries = invalidEntries;

    }

    return;

} // XsFillAuxEnumBuffer


VOID
XsFillEnumBuffer (
    IN LPBYTE InBuffer,
    IN DWORD NumberOfEntries,
    IN LPDESC InStructureDesc,
    IN OUT LPBYTE OutBuffer,
    IN LPBYTE OutBufferStart,
    IN DWORD OutBufferLength,
    IN LPDESC OutStructureDesc,
    IN PXACTSRV_ENUM_VERIFY_FUNCTION VerifyFunction OPTIONAL,
    OUT LPDWORD BytesRequired,
    OUT LPDWORD EntriesFilled,
    OUT LPDWORD InvalidEntries OPTIONAL
    )

/*++

Routine Description:

    This routine copies all Enum structures from 32-bit format to
    16-bit format.  As many complete entries as possible are copied,
    then possibly some incomplete entries.  All pointer fields
    are converted to offsets so that this buffer may be returned
    directly to the requesting client.

Arguments:

    InBuffer - a pointer to the input information in 32-bit format.

    NumberOfEntries - the count of fixed structures in the input buffer.

    InStructureDesc - description of the input fixed structure.

    OutBuffer - a pointer to where to write the 16-bit buffer.

    OutBufferStart - a pointer to the actual start of the 16-bit buffer.
        Used to calculate offsets for all pointers in structures.

    OutBufferLength - length of the output buffer.

    OutStructureDesc - description of the output fixed structure.

    VerifyFunction - a pointer to a function which is be called after
        each enum record is converted in order to determine whether
        the record should be retained or discarded.  The function
        is passed the return code from RapConvertSingleEntry and
        a pointer to the converted entry.  It must return NERR_SUCCESS
        if the entry is to be retained, or any error code if the entry
        is to be discarded.  If no function is supplied, a default function
        is used, which discards an entry only if RapConvertSingleEntry
        returned an error trying to convert it.

    BytesRequired - a pointer to a DWORD to receive the total number of
        bytes that would be required to hold the entire output buffer.

    EntriesFilled - a pointer to a DWORD to receive the total number of
        entries that could be put in the buffer given.

    InvalidEntries - an optional pointer to a DWORD to receive the total
        number of entries discarded by the verify function. If NULL, this
        value will be not be available to the caller.

Return Value:

    None.

--*/

{
    NET_API_STATUS status;
    DWORD currentEntry;
    LPBYTE currentInEntryPtr;
    LPBYTE currentOutEntryPtr;
    LPBYTE outputStringLocation;
    LPBYTE oldStringLocation;
    DWORD inputStructureSize;
    DWORD outputStructureSize;
    DWORD newBytesRequired;
    DWORD invalidEntries = 0;

    if ( VerifyFunction == NULL ) {
        VerifyFunction = &XsDefaultEnumVerifyFunction;
    }

    //
    // Set up sizes of input and output structures.
    //

    inputStructureSize = RapStructureSize( InStructureDesc, Response, TRUE );
    outputStructureSize = RapStructureSize( OutStructureDesc, Response, FALSE );

    outputStringLocation = (LPBYTE)OutBuffer + OutBufferLength;
    *BytesRequired = 0;

    //
    // Check if one fixed entry will fit.
    //

    if ( inputStructureSize > OutBufferLength ) {

        *EntriesFilled = 0;
        goto cleanup;
    }

    //
    // Loop through the entries, converting along the way.
    //

    currentInEntryPtr = InBuffer;
    currentOutEntryPtr = OutBuffer;
    *EntriesFilled = 0;

    for ( currentEntry = 0; currentEntry < NumberOfEntries; currentEntry++ ) {

        //
        // If there wasn't enough room for the conversion, we can quit now.
        //

        if ( currentOutEntryPtr + outputStructureSize > outputStringLocation ) {

            break;
        }

        newBytesRequired = *BytesRequired;
        oldStringLocation = outputStringLocation;

        status = RapConvertSingleEntry(
                     currentInEntryPtr,
                     InStructureDesc,
                     FALSE,
                     OutBufferStart,
                     currentOutEntryPtr,
                     OutStructureDesc,
                     TRUE,
                     &outputStringLocation,
                     &newBytesRequired,
                     Response,
                     NativeToRap
                     );

        //
        // If the conversion was successful, increment the buffer pointers,
        // the count of bytes required, and the number of converted entries.
        //

        status = (*VerifyFunction)(
                     status,
                     currentOutEntryPtr,
                     OutBufferStart
                     );

        if ( status == NERR_Success ) {

            currentInEntryPtr += inputStructureSize;
            currentOutEntryPtr += outputStructureSize;
            *BytesRequired = newBytesRequired;
            *EntriesFilled += 1;

        } else {

            invalidEntries++;
            currentInEntryPtr += inputStructureSize;
            outputStringLocation = oldStringLocation;

        }

    }

cleanup:

    if ( InvalidEntries != NULL ) {

        *InvalidEntries = invalidEntries;

    }

    return;

} // XsFillEnumBuffer


LPBYTE
XsFindParameters (
    IN LPTRANSACTION Transaction
    )

/*++

Routine Description:

    This routine finds the start of the parameters section in the
    transaction block of a remote down-level API request.

Arguments:

    Transaction - a pointer to a transaction block containing information
        about the API to process.

Return Value:

    None.

--*/

{
    LPBYTE s;

    //
    // Skip over the API number and parameters description string.
    //

    for ( s = Transaction->InParameters + 2; *s != '\0'; s++ );

    //
    // Skip over the zero terminator and the data description string.
    //

    for ( s++; *s != '\0'; s++ );

    //
    // Return a pointer to the location after the zero terminator.
    //

    return s + 1;

} // XsFindParameters


WORD
XsPackReturnData (
    IN LPVOID Buffer,
    IN WORD BufferLength,
    IN LPDESC Descriptor,
    IN DWORD EntriesRead
    )

/*++

Routine Description:

    This routine, called by get info and enum API handlers, packs the
    output data so that no unused data is returned to the client.  This
    is necessary because buffers are filled with variable-length data
    starting at the end, thereby leaving potentially large gaps of
    unused space between the end of fixed structures and the beginning
    of variable-length data.

Arguments:

    Buffer - a pointer to the buffer to pack.

    BufferLength - the length of this buffer.

    Descriptor - a pointer to a string which describes the fixed structures
        in the buffer.

    EntriesRead - the count of fixed structures in the buffer.

Return Value:

    WORD - the "converter word" which informs the client how much
        to adjust pointers in the fixed structures so that they are
        meaningful.

--*/

{
    DWORD structureSize;
    LPBYTE lastFixedStructure;
    LPBYTE endOfFixedStructures;
    DWORD lastPointerOffset;
    DWORD beginningOfVariableData;

    //
    // If there is no data, return immediately.
    //

    if ( EntriesRead == 0 ) {

        return 0;
    }

    //
    // Find the size of a single fixed-length structure.
    //

    structureSize = RapStructureSize( Descriptor, Response, FALSE );

    //
    // Use this and the number of entries to find the location of the
    // last fixed structure and where the fixed structures end.
    //

    endOfFixedStructures = (LPBYTE)Buffer + EntriesRead * structureSize;
    lastFixedStructure = endOfFixedStructures - structureSize;

    //
    // Find the offset into the fixed structure of the last pointer
    // to variable data.  The value stored at this offset in the last
    // structure is the offset to the first variable data.
    //

    lastPointerOffset = RapLastPointerOffset( Descriptor, Response, FALSE );

    //
    // If there are no pointers, there is obviously no data to pack.
    //

    if ( lastPointerOffset == NO_POINTER_IN_STRUCTURE ) {

        return 0;
    }

    beginningOfVariableData =
        SmbGetUlong( (LPDWORD)(lastFixedStructure + lastPointerOffset) );

    //
    // If this offset is NULL, then the data overflowed, hence the buffer
    // is nearly full.  Don't do any packing.
    //
    // Also, if the gap is less than MAXIMUM_ALLOWABLE_DATA_GAP then it
    // isn't worth doing the packing because of the time involved in
    // the data copy.
    //

    if ( beginningOfVariableData == (DWORD)0 ||
         (DWORD_PTR)Buffer + beginningOfVariableData -
             (DWORD_PTR)endOfFixedStructures <= MAXIMUM_ALLOWABLE_DATA_GAP ) {

        return 0;
    }

    //
    // Move the variable data up to follow the fixed structures.
    //

    RtlMoveMemory(
        endOfFixedStructures,
        (LPBYTE)Buffer + beginningOfVariableData,
        BufferLength - beginningOfVariableData
        );

    //
    // Return the distance we moved the variable data.
    //

    return (WORD)( (DWORD_PTR)Buffer + beginningOfVariableData -
                         (DWORD_PTR)endOfFixedStructures );

} // XsPackReturnData


VOID
XsSetDataCount(
    IN OUT LPWORD DataCount,
    IN LPDESC Descriptor,
    IN WORD Converter,
    IN DWORD EntriesRead,
    IN WORD ReturnStatus
    )

/*++

Routine Description:

    This routine calculates the return data count based on a number
    of characteristics of the return data. This routine will examine
    the buffer size, the number of entries placed in the buffer,
    whether the data was packed, and what the return code was to
    determine the return data size. The following assumptions are made
    about the data: only calls with ReturnCode = NERR_Success or
    ERROR_MORE_DATA return any data to the client; and if there is
    no pointer in the fixed entries, then there is no variable data.
    Handlers which cannot assure these two assumptions must determine
    the data count manually.

Arguments:

    DataCount - a pointer to a short word indicating the maximum
        return data count (usually the BufLen parameter). On return,
        this word will hold the actual return data count.

    Descriptor - a string describing the structure of the fixed
        entries in the buffer.

    Converter - The adjustment value for pointers in data. A non-zero
        value indicates data in the buffer is packed.

    EntriesRead - Number of entries placed in the buffer. Used to
        determine data count for buffers with no variable data.

    ReturnStatus - Return status of the API call, as it will be returned
        to the client (in other words, converted to a WORD).

Return Value:

    None.

--*/

{

    if (( ReturnStatus != NERR_Success )
              && ( ReturnStatus != ERROR_MORE_DATA)) {

        //
        // If the return status is not NERR_Success or ERROR_MORE_DATA, then
        // the return data count is 0.

        SmbPutUshort( DataCount, 0 );
        return;

    }

    if ( RapLastPointerOffset( Descriptor, Response, FALSE )
             == NO_POINTER_IN_STRUCTURE ) {

        //
        // If there is no variable data, the return data count is the size
        // of the fixed structures.

        SmbPutUshort( DataCount,
                      (WORD)(RapStructureSize( Descriptor, Response, FALSE )
                                   * EntriesRead ));
        return;

    }

    SmbPutUshort( DataCount, SmbGetUshort( DataCount ) - Converter );

    return;

} // XsSetDataCount


VOID
XsSetParameters (
    IN LPTRANSACTION Transaction,
    IN LPXS_PARAMETER_HEADER Header,
    IN LPVOID Parameters
    )

/*++

Routine Description:

    This routine takes parameters from the structure allocated by
    XsCaptureParameters and uses the descriptor string to place them in
    the correct format in the transaction block.  It also frees the
    buffer holding the parameter structure.

Arguments:

    Transaction - a pointer to the transaction block describing the
        request.

    Header - a pointer to the parameter header, which contains information
        from the API handler such as the converter word and return status.

    Parameters - a pointer to the parameter structure.


Return Value:

    None.

--*/

{
    LPBYTE inParams = Parameters;
    LPBYTE outParams = Transaction->OutParameters;
    LPDESC descriptorString;
    LPDESC descriptor;
    LPBYTE outParamsMax = outParams + Transaction->MaxParameterCount;

    //
    // The first two bytes of the parameter section are the API number,
    // then comes the descriptor string.
    //

    descriptorString = Transaction->InParameters + 2;

    //
    // Set up the first part of the output parameters from the parameter
    // header.
    //

    if( outParams + sizeof(WORD) > outParamsMax ) goto insuff_buffer;
    SmbPutUshort( (LPWORD)outParams, Header->Status );
    outParams += sizeof(WORD);

    if( outParams + sizeof(WORD) > outParamsMax ) goto insuff_buffer;
    SmbPutUshort( (LPWORD)outParams, Header->Converter );
    outParams += sizeof(WORD);

    //
    // Initially set the size of the return data to 0. If there is a
    // receive buffer for this call, the API handler has changed the
    // buffer length parameter to the count of data returned, which
    // will be transferred to the DataCount variable later.
    //

    Transaction->DataCount = 0;

    //
    // Walk through the descriptor string, converting from the total
    // parameter set to the smaller set passed back to the client.  In
    // general, only information the client does not already know is
    // passed back as parameters.
    //

    for ( descriptor = descriptorString; *descriptor != '\0'; ) {

        switch ( *descriptor++ ) {

        case REM_ASCIZ:
        case REM_NULL_PTR:

            //
            // !!! Parameter string descriptors may not have maximum length
            //     counts.
            //

            NetpAssert( !isdigit( *descriptor ));

            //
            // The parameter is a pointer to a string, which is
            // not returned to the client.
            //

            inParams += sizeof(LPSTR);

            break;

        case REM_BYTE_PTR:
        case REM_FILL_BYTES:

            //
            // Array of bytes, doesn't get sent back.
            //

            //
            // Skip over any numeric characters in descriptor.
            //

            RapAsciiToDecimal( &descriptor );

            inParams += sizeof(LPBYTE);

            break;

        case REM_DWORD:

            //
            // The parameter is a input word not returned to the client.
            //
            // !!! This assumes that an array of dwords will never be passed
            //     as a parameter.

            NetpAssert( !isdigit( *descriptor ));

            inParams += sizeof(DWORD);

            break;

        case REM_ENTRIES_READ:
        case REM_RCV_WORD_PTR:

            //
            // Count of entries read (e) or receive word pointer (h).
            // This is an output parameter, so copy over the word.
            //

            if( outParams + sizeof(WORD) > outParamsMax ) goto insuff_buffer;

            SmbPutUshort(
                (LPWORD)outParams,
                SmbGetUshort( (LPWORD)inParams )
                );

            inParams += sizeof(WORD);
            outParams += sizeof(WORD);

            break;

        case REM_RCV_DWORD_PTR:

            //
            // Count of receive dword pointer (h).
            // This is an output parameter, so copy over the word.
            //

            if( outParams + sizeof(DWORD) > outParamsMax ) goto insuff_buffer;

            SmbPutUlong(
                (LPDWORD)outParams,
                SmbGetUlong( (LPDWORD)inParams )
                );

            inParams += sizeof(DWORD);
            outParams += sizeof(DWORD);

            break;

        case REM_RCV_BUF_LEN:

            //
            // The length of the receive buffer (r).  The parameter is not
            // returned to the client, but it is used to set the return
            // data count.
            //

            Transaction->DataCount = (DWORD)SmbGetUshort( (LPWORD)inParams );
            inParams += sizeof(WORD);

            break;

        case REM_RCV_BUF_PTR:
        case REM_SEND_BUF_PTR:

            //
            // A pointer to a data buffer.  This is not returned to the
            // client.
            //

            inParams += sizeof(LPBYTE);

            break;

        case REM_RCV_BYTE_PTR: {

            //
            // The parameter indicates return bytes.
            //

            DWORD arraySize;

            arraySize = sizeof(BYTE) * RapDescArrayLength( descriptor );

            if( outParams + arraySize > outParamsMax ) goto insuff_buffer;

            RtlCopyMemory( outParams, inParams, arraySize );

            outParams += arraySize;
            inParams += arraySize;

            break;

        }

        case REM_SEND_BUF_LEN:
        case REM_WORD:
        case REM_PARMNUM:

            //
            // The parameter is a input word not returned to the client.
            //
            // !!! This assumes that an array of words will never be passed
            //     as a parameter.

            NetpAssert( !isdigit( *descriptor ));

            inParams += sizeof(WORD);

            break;

        default:

            IF_DEBUG(ERRORS) {
                NetpKdPrint(( "XsSetParameters: unsupported character at %lx: %c\n",
                                descriptor - 1, *( descriptor - 1 )));
                NetpBreakPoint( );
            }
        }
    }

    //
    // Indicate the number of response parameter bytes.
    //

    Transaction->ParameterCount =
        (DWORD)((DWORD_PTR)outParams - (DWORD_PTR)(Transaction->OutParameters) );

    //
    // Free the parameter buffer allocated by XsCaptureParameters.
    //

    NetpMemoryFree( Header );

    return;

insuff_buffer:
    Header->Status = NERR_BufTooSmall;
    return;

} // XsSetParameters


NET_API_STATUS
XsValidateShareName(
    IN LPSTR ShareName
)

/*++

Routine Description:

    This routine determines whether the supplied string is a valid share
    name of the format \\computer\share, with both computer name and
    share name no longer than permitted by LanMan 2.0.  It does not
    attempt to determine whether the share actually exists.

Arguments:

    ShareName - The share name to be validated (an ASCII string)

Return Value:

    NET_API_STATUS - NERR_Success if the share name is valid,
                     ERROR_INVALID_PARAMETER otherwise.

--*/

{
    DWORD componentLength;
    NET_API_STATUS status = NERR_Success;

    if ( ShareName == NULL ) {           // NULL is OK
        return NERR_Success;
    }

    componentLength = 0;
    while ( *ShareName == '\\' ) {
        componentLength++;
        ShareName++;
    }

    if ( componentLength != 2 ) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    componentLength = 0;
    while (( *ShareName != '\\' ) && ( *ShareName != '\0' )) {
        componentLength++;
        ShareName++;
    }

    if (( *ShareName == '\0' ) ||
            ( componentLength < 1 ) || ( componentLength > MAX_PATH )) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    componentLength = 0;
    while ( *ShareName == '\\' ) {
        componentLength++;
        ShareName++;
    }

    if ( componentLength != 1 ) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    componentLength = 0;
    while (( *ShareName != '\\' ) && ( *ShareName != '\0' )) {
        componentLength++;
        ShareName++;
    }

    if (( *ShareName == '\\' ) ||
            ( componentLength < 1 ) || ( componentLength > MAX_PATH )) {
        status = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

cleanup:

    return status;
}

VOID
SmbCapturePtr(
    LPBYTE  PointerDestination,
    LPBYTE  PointerValue
    )

/*++

Routine Description:

    This routine captures a pointer from the supplied buffer and places it
    into the destination buffer.

Arguments:

    PointerDestination - A pointer to the pointer value destination.

    PointerSource - A pointer to the pointer value source.

Return Value:

    None.

--*/

{
    XsSmbPutPointer( PointerDestination, PointerValue );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\logview\fvfile.c ===
/*
  +-------------------------------------------------------------------------+
  |                MDI Text File Viewer - File IO Routines                  |
  +-------------------------------------------------------------------------+
  |                        (c) Copyright 1994                               |
  |                          Microsoft Corp.                                |
  |                        All rights reserved                              |
  |                                                                         |
  | Program               : [mpfile.c]                                      |
  | Programmer            : Arthur Hanson                                   |
  | Original Program Date : [Jul 27, 1993                                   |
  | Last Update           : [Jul 30, 1993]  Time : 18:30                    |
  |                                                                         |
  | Version:  0.10                                                          |
  |                                                                         |
  | Description:                                                            |
  |                                                                         |
  | History:                                                                |
  |   arth  Jul 27, 1993    0.10    Original Version.                       |
  |                                                                         |
  +-------------------------------------------------------------------------+
*/

#include "LogView.h"
#include <fcntl.h>
#include <SYS\types.h>
#include <SYS\stat.h>
#include <io.h>
#include <string.h>

VOID APIENTRY GetFileName(HWND hwnd, PSTR);

OFSTRUCT        of;


/*+-------------------------------------------------------------------------+
  | AlreadyOpen()                                                           |
  |                                                                         |
  |   Checks to see if a file is already opened.  Returns a handle to       |
  |   the file's window if it is opened, otherwise NULL.                    |
  |                                                                         |
  +-------------------------------------------------------------------------+*/
HWND AlreadyOpen(CHAR *szFile) {
    INT     iDiff;
    HWND    hwndCheck;
    CHAR    szChild[64];
    LPSTR   lpChild, lpFile;
    HFILE     wFileTemp;

    // Open the file with the OF_PARSE flag to obtain the fully qualified
    // pathname in the OFSTRUCT structure.
    wFileTemp = OpenFile((LPSTR)szFile, (LPOFSTRUCT)&of, OF_PARSE);
    if (! wFileTemp)
        return(NULL);
    _lclose(wFileTemp);

    // Check each MDI child window in LogView
    for (   hwndCheck = GetWindow(hwndMDIClient, GW_CHILD);
            hwndCheck;
            hwndCheck = GetWindow(hwndCheck, GW_HWNDNEXT)   ) {
        // Initialization  for comparison
        lpChild = szChild;
        lpFile = (LPSTR)AnsiUpper((LPSTR) of.szPathName);
        iDiff = 0;

        // Skip icon title windows
        if (GetWindow(hwndCheck, GW_OWNER))
            continue;

        // Get current child window's name
        GetWindowText(hwndCheck, lpChild, 64);

        // Compare window name with given name
        while ((*lpChild) && (*lpFile) && (!iDiff)) {
            if (*lpChild++ != *lpFile++)
                iDiff = 1;
        }

        // If the two names matched, the file is already open - return handle to matching
        // child window.
        if (!iDiff)
            return(hwndCheck);
    }
    
    // No match found -- file is not open -- return NULL handle
    return(NULL);
    
} // AlreadyOpen


/*+-------------------------------------------------------------------------+
  | AddFile()                                                               |
  |                                                                         |
  |   Create a new MDI Window, and loads specified file into Window.        |
  |                                                                         |
  +-------------------------------------------------------------------------+*/
HWND APIENTRY AddFile(CHAR * pName) {
    HWND hwnd;

    CHAR            sz[160];
    MDICREATESTRUCT mcs;

    if (!pName) {
        // The pName parameter is NULL -- load the "Untitled" string from STRINGTABLE
        // and set the title field of the MDI CreateStruct.
        LoadString (hInst, IDS_UNTITLED, sz, sizeof(sz));
        mcs.szTitle = (LPSTR)sz;
    }
    else
        // Title the window with the fully qualified pathname obtained by calling
        // OpenFile() with the OF_PARSE flag (in function AlreadyOpen(), which is called
        // before AddFile().
        mcs.szTitle = pName;

    mcs.szClass = szChild;
    mcs.hOwner  = hInst;

    // Use the default size for the window
    mcs.x = mcs.cx = CW_USEDEFAULT;
    mcs.y = mcs.cy = CW_USEDEFAULT;

    // Set the style DWORD of the window to default
    mcs.style = 0L;

    // tell the MDI Client to create the child
    hwnd = (HWND)SendMessage (hwndMDIClient,
                              WM_MDICREATE,
                              0,
                              (LONG_PTR)(LPMDICREATESTRUCT)&mcs);

    // Did we get a file? Read it into the window
    if (pName){
        if (!LoadFile(hwnd, pName)){
            // File couldn't be loaded -- close window
            SendMessage(hwndMDIClient, WM_MDIDESTROY, (DWORD_PTR) hwnd, 0L);
        }
    }

    return hwnd;
    
} // AddFile


/*+-------------------------------------------------------------------------+
  | LoadFile()                                                              |
  |                                                                         |
  |    Loads file into specified MDI window's edit control.                 |
  |                                                                         |
  +-------------------------------------------------------------------------+*/
INT APIENTRY LoadFile ( HWND hwnd, CHAR * pName) {
    LONG   wLength;
    HANDLE hT;
    LPSTR  lpB;
    HWND   hwndEdit;
    HFILE  fh;
    OFSTRUCT  of;
    
    hwndEdit = (HWND)GetWindowLong (hwnd, GWL_HWNDEDIT);

    // The file has a title, so reset the UNTITLED flag.
    SetWindowWord(hwnd, GWW_UNTITLED, FALSE);

    fh = OpenFile(pName, &of, OF_READ);  // JAP was 0, which is OF_READ)

    // Make sure file has been opened correctly
    if ( fh < 0 )
        goto error;

    // Find the length of the file
    wLength = (DWORD)_llseek(fh, 0L, 2);
    _llseek(fh, 0L, 0);

    // Attempt to reallocate the edit control's buffer to the file size
    hT = (HANDLE)SendMessage (hwndEdit, EM_GETHANDLE, 0, 0L);
    if (LocalReAlloc(hT, wLength+1, LHND) == NULL) {
        // Couldn't reallocate to new size -- error
        _lclose(fh);
        goto error;
    }

    // read the file into the buffer
    if (wLength != (LONG)_lread(fh, (lpB = (LPSTR)LocalLock (hT)), (UINT)wLength))
        MPError (hwnd, MB_OK|MB_ICONHAND, IDS_CANTREAD, (LPSTR)pName);

    // Zero terminate the edit buffer
    lpB[wLength] = 0;
    LocalUnlock (hT);

    SendMessage (hwndEdit, EM_SETHANDLE, (UINT_PTR)hT, 0L);
    _lclose(fh);

    return TRUE;

error:
    // Report the error and quit
    MPError(hwnd, MB_OK | MB_ICONHAND, IDS_CANTOPEN, (LPSTR)pName);
    return FALSE;
    
} // LoadFile


/*+-------------------------------------------------------------------------+
  | MyReadFile()                                                            |
  |                                                                         |
  |   Asks user for a filename.                                             |
  |                                                                         |
  +-------------------------------------------------------------------------+*/
VOID APIENTRY MyReadFile(HWND hwnd) {
    CHAR    szFile[128];
    HWND    hwndFile;

    GetFileName (hwnd, szFile);

    // If the result is not the empty string -- take appropriate action
    if (*szFile) {
            // Is file already open??
            if (hwndFile = AlreadyOpen(szFile)) {
                // Yes -- bring the file's window to the top
                BringWindowToTop(hwndFile);
            }
            else {
                // No -- make a new window and load file into it
                AddFile(szFile);
            }
    }
        UNREFERENCED_PARAMETER(hwnd);
        
} // MyReadFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\logview\fvinit.c ===
/*
  +-------------------------------------------------------------------------+
  |                        Initialization Code                              |
  +-------------------------------------------------------------------------+
  |                        (c) Copyright 1993                               |
  |                          Microsoft Corp.                                |
  |                        All rights reserved                              |
  |                                                                         |
  | Program               : [mpinit.c]                                      |
  | Programmer            : Arthur Hanson                                   |
  | Original Program Date : [Jul 27, 1993                                   |
  | Last Update           : [Jul 30, 1993]  Time : 18:30                    |
  |                                                                         |
  | Version:  0.10                                                          |
  |                                                                         |
  | Description:                                                            |
  |                                                                         |
  | History:                                                                |
  |   arth  Jul 27, 1993    0.10    Original Version.                       |
  |                                                                         |
  +-------------------------------------------------------------------------+
*/
#include "LogView.h"

CHAR szFrame[] = "mpframe";   // Class name for "frame" window
CHAR szChild[] = "mpchild";   // Class name for MDI window

/*+-------------------------------------------------------------------------+
  | InitializeApplication()                                                 |
  |                                                                         |
  +-------------------------------------------------------------------------+*/
BOOL APIENTRY InitializeApplication() {
    WNDCLASS    wc;

    // Register the frame class
    wc.style         = 0;
    wc.lpfnWndProc   = (WNDPROC) MPFrameWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance    = hInst;
    wc.hIcon         = LoadIcon(hInst,IDLOGVIEW);
    wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
    wc.hbrBackground = (HBRUSH) (COLOR_APPWORKSPACE+1);
    wc.lpszMenuName  = IDLOGVIEW;
    wc.lpszClassName = szFrame;

    if (!RegisterClass (&wc) )
        return FALSE;

    // Register the MDI child class
    wc.lpfnWndProc   = (WNDPROC) MPMDIChildWndProc;
    wc.hIcon         = LoadIcon(hInst,IDNOTE);
    wc.lpszMenuName  = NULL;
    wc.cbWndExtra    = CBWNDEXTRA;
    wc.lpszClassName = szChild;

    if (!RegisterClass(&wc))
        return FALSE;

    return TRUE;

} // InitializeApplication


/*+-------------------------------------------------------------------------+
  | InitializeInstance()                                                    |
  |                                                                         |
  +-------------------------------------------------------------------------+*/
BOOL APIENTRY InitializeInstance(LPSTR lpCmdLine, INT nCmdShow) {
   extern HWND  hwndMDIClient;
   CHAR         sz[80], *pCmdLine, *pFileName, *pChar;
   HDC          hdc;
   HMENU        hmenu;

   // Get the base window title
   LoadString (hInst, IDS_APPNAME, sz, sizeof(sz));

    hStdCursor= LoadCursor( NULL,IDC_ARROW );
    hWaitCursor= LoadCursor( NULL, IDC_WAIT );

    // Create the frame
    hwndFrame = CreateWindow (szFrame, sz,  WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                              CW_USEDEFAULT, 0, CW_USEDEFAULT,  0,  NULL,
                              NULL,  hInst, NULL);

    if ((!hwndFrame) || (!hwndMDIClient))
        return FALSE;

    // Load main menu accelerators
    if (!(hAccel = LoadAccelerators (hInst, IDLOGVIEW)))
        return FALSE;

    // init.fields of the FINDREPLACE struct used by FindText()
    FR.lStructSize = sizeof(FINDREPLACE);
    FR.hwndOwner = hwndFrame;
    FR.Flags = FR_DOWN | FR_HIDEWHOLEWORD;
    FR.lpstrReplaceWith   = (LPTSTR)NULL;
    FR.wReplaceWithLen = 0;
    FR.lpfnHook = NULL;

    /* determine the message number to be used for communication with
     * Find dialog
     */
    if (!(wFRMsg = RegisterWindowMessage ((LPTSTR)FINDMSGSTRING)))
         return FALSE;
    if (!(wHlpMsg = RegisterWindowMessage ((LPTSTR)HELPMSGSTRING)))
         return FALSE;

    // Display the frame window
    ShowWindow (hwndFrame, nCmdShow);
    UpdateWindow (hwndFrame);

    // If the command line string is empty, nullify the pointer to it else copy
    // command line into our data segment 
   if ( lpCmdLine && !(*lpCmdLine)) {
      pCmdLine = NULL;
             
      // Add the first MDI window 
      AddFile (pCmdLine);

   } else {
      pCmdLine = (CHAR *) LocalAlloc(LPTR, lstrlen(lpCmdLine) + 1);
      
      if (pCmdLine) {
         lstrcpy(pCmdLine, lpCmdLine);
           
         pFileName = pChar = pCmdLine;
         
         while (*pChar) {
            if (*pChar == ' ') {
               *pChar = '\0';
               AddFile(pFileName);
               *pChar = ' ';
               pChar++;
               pFileName = pChar;
            } else
               pChar++;
         }
            AddFile(pFileName);
            
      } else
         
      // Add the first MDI window
      AddFile (pCmdLine);
   }

   // if we allocated a buffer then free it
   if (pCmdLine)
      LocalFree((LOCALHANDLE) pCmdLine);

   return TRUE;
   UNREFERENCED_PARAMETER(hmenu);
   UNREFERENCED_PARAMETER(hdc);

} // InitializeInstance
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\logview\fvfind.c ===
/*
  +-------------------------------------------------------------------------+
  |             MDI Text File Viewer - Text Search Routines                 |
  +-------------------------------------------------------------------------+
  |                        (c) Copyright 1994                               |
  |                          Microsoft Corp.                                |
  |                        All rights reserved                              |
  |                                                                         |
  | Program               : [FVFind.c]                                      |
  | Programmer            : Arthur Hanson                                   |
  | Original Program Date : [Jul 27, 1993                                   |
  | Last Update           : [Jul 30, 1993]  Time : 18:30                    |
  |                                                                         |
  | Version:  0.10                                                          |
  |                                                                         |
  | Description:                                                            |
  |                                                                         |
  | History:                                                                |
  |   arth  Jul 27, 1993    0.10    Original Version.                       |
  |                                                                         |
  +-------------------------------------------------------------------------+
*/

#include "LogView.h"
#include <string.h>
#include <stdlib.h>

#undef HIWORD
#undef LOWORD

#define HIWORD(l) (((WORD*)&(l))[1])
#define LOWORD(l) (((WORD*)&(l))[0])

BOOL fCase = FALSE;        // Turn case sensitivity off
CHAR szSearch[160] = "";   // Initialize search string


extern HWND hDlgFind;       /* handle to modeless FindText window */

LPTSTR ReverseScan(
    LPTSTR lpSource,
    LPTSTR lpLast,
    LPTSTR lpSearch,
    BOOL fCaseSensitive ) {
   int iLen = lstrlen(lpSearch);

   if (!lpLast)
      lpLast = lpSource + lstrlen(lpSource);

   do {
      if (lpLast == lpSource)
         return NULL;

      --lpLast;

      if (fCaseSensitive) {
         if (*lpLast != *lpSearch)
            continue;
      } else {
         if (CharUpper ((LPTSTR)MAKELONG((WORD)*lpLast, 0)) != CharUpper ((LPTSTR)MAKELONG((WORD)*lpSearch, 0)))
            continue;
      }

      if (fCaseSensitive) {
         if (!strncmp( lpLast, lpSearch, iLen))
            break;
      } else {
         if (!_strnicmp (lpLast, lpSearch, iLen))
            break;
      }
   } while (TRUE);

   return lpLast;
} // ReverseScan


LPTSTR ForwardScan(LPTSTR lpSource, LPTSTR lpSearch, BOOL fCaseSensitive ) {
   int iLen = lstrlen(lpSearch);

   while (*lpSource) {
      if (fCaseSensitive) {
         if (*lpSource != *lpSearch) {
            lpSource++;
            continue;
         }
      } else {
         if (CharUpper ((LPTSTR)MAKELONG((WORD)*lpSource, 0)) != CharUpper ((LPTSTR)MAKELONG((WORD)*lpSearch, 0))) {
            lpSource++;
            continue;
         }
      }

      if (fCaseSensitive) {
         if (!strncmp( lpSource, lpSearch, iLen))
            break;
      } else {
         if (!_strnicmp( lpSource, lpSearch, iLen))
            break;
      }

      lpSource++;
   }

   return *lpSource ? lpSource : NULL;
} // ForwardScan


// search forward or backward in the edit control text for the given pattern
void FAR Search (TCHAR * szKey) {
    HANDLE    hText;
    TCHAR   * pStart, *pMatch;
    DWORD_PTR StartIndex, EndIndex;
    DWORD     SelStart, SelEnd, i;
    LRESULT     dwSel;
    INT_PTR cbText, LineNum;

    if (!*szKey)
        return;

    SetCursor(hWaitCursor);
    dwSel= SendMessage(hwndActiveEdit, EM_GETSEL, (WPARAM)&SelStart, (LPARAM)&SelEnd);

    /*
     * Allocate hText and read edit control text into it.
     * Lock hText and fall through to existing code.
     */

    cbText= SendMessage(hwndActiveEdit, WM_GETTEXTLENGTH, 0, 0L) + 1;
    hText= LocalAlloc( LPTR, cbText );
    if( !hText )  // quiet exit if not enough memory
        return;
    if( !(pStart= LocalLock(hText)) ) {
        LocalFree(hText);
        return;
    }

    SendMessage(hwndActiveEdit, WM_GETTEXT, cbText, (LPARAM)pStart);

    if (fReverse) {
        // Get current line number
        LineNum= SendMessage(hwndActiveEdit, EM_LINEFROMCHAR, SelStart, 0);
        // Get index to start of the line
        StartIndex= SendMessage(hwndActiveEdit, EM_LINEINDEX, LineNum, 0);
        // Set upper limit for search text
        EndIndex= SelStart;
        pMatch= NULL;

        // Search line by line, from LineNum to 0
        i = (DWORD) LineNum;
        while (TRUE) {
            pMatch= ReverseScan(pStart+StartIndex,pStart+EndIndex,szKey,fCase);
            if (pMatch)
               break;
            // current StartIndex is the upper limit for the next search
            EndIndex= StartIndex;

            if (i) {
                // Get start of the next line
                i-- ;
                StartIndex= SendMessage(hwndActiveEdit, EM_LINEINDEX, i, 0);
            } else
               break ;
        }
    } else {
            pMatch= ForwardScan(pStart + SelEnd, szKey, fCase);
    }
    LocalUnlock(hText);
    LocalFree( hText );
    SetCursor(hStdCursor);

    if (pMatch == NULL) {
        TCHAR Message[256], AppName[256] ;

        if (!LoadString(hInst, IDS_CANTFINDSTR, Message,
                        sizeof(Message)/sizeof(Message[0]))) {
            Message[0] = 0 ;
        }
        
        if (!LoadString(hInst, IDS_APPNAME, AppName,
                        sizeof(AppName)/sizeof(AppName[0]))) {
            AppName[0] = 0 ;
        }
        
        MessageBox(hwndFrame, Message, AppName,
                   MB_APPLMODAL | MB_OK | MB_ICONASTERISK);
    } else {
        SelStart = (DWORD) (pMatch - pStart);
        SendMessage(hwndActiveEdit, EM_SETSEL, SelStart, SelStart+lstrlen(szKey));
        SendMessage(hwndActiveEdit, EM_SCROLLCARET, 0, 0);
    }

} // Search
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nlrepl\nlrepl.c ===
/*++

Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    nlrepl.c

Abstract:

    The database replication functions called either from LSA OR SAM.
    The actual code resides in netlogon.dll.

Author:

    Madan Appiah (Madana)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    14-Apr-1992 (madana)
        Created.

--*/

#include <nt.h>         // needed for NTSTATUS
#include <ntrtl.h>      // needed for nturtl.h
#include <nturtl.h>     // needed for windows.h
#include <windows.h>    // win32 typedefs

#include <crypt.h>      // samsrv.h will need this
#include <ntlsa.h>      // needed for POLICY_LSA_SERVER_ROLE
#include <samrpc.h>
#include <samisrv.h>    // needed for SECURITY_DB_TYPE etc.
#include <winsock2.h>   // needed for SOCKET defn's
#include <nlrepl.h>     // proto types

typedef NTSTATUS
            (*PI_NetNotifyDelta) (
                IN SECURITY_DB_TYPE DbType,
                IN LARGE_INTEGER ModificationCount,
                IN SECURITY_DB_DELTA_TYPE DeltaType,
                IN SECURITY_DB_OBJECT_TYPE ObjectType,
                IN ULONG ObjectRid,
                IN PSID ObjectSid,
                IN PUNICODE_STRING ObjectName,
                IN DWORD ReplicationImmediately,
                IN PSAM_DELTA_DATA MemberId
            );


typedef NTSTATUS
            (*PI_NetNotifyRole) (
                IN POLICY_LSA_SERVER_ROLE Role
            );

typedef NTSTATUS
            (*PI_NetNotifyMachineAccount) (
                IN ULONG ObjectRid,
                IN PSID DomainSid,
                IN ULONG OldUserAccountControl,
                IN ULONG NewUserAccountControl,
                IN PUNICODE_STRING ObjectName
            );

typedef NTSTATUS
            (*PI_NetNotifyTrustedDomain) (
                IN PSID HostedDomainSid,
                IN PSID TrustedDomainSid,
                IN BOOLEAN IsDeletion
            );

typedef NTSTATUS
            (*PI_NetNotifyNetlogonDllHandle) (
                IN PHANDLE Role
            );

typedef NTSTATUS
    (*PI_NetLogonSetServiceBits)(
        IN DWORD ServiceBitsOfInterest,
        IN DWORD ServiceBits
    );

typedef NTSTATUS
    (*PI_NetLogonGetSerialNumber) (
    IN SECURITY_DB_TYPE DbType,
    IN PSID DomainSid,
    OUT PLARGE_INTEGER SerialNumber
    );

typedef NTSTATUS
    (*PI_NetLogonLdapLookup)(
    IN PVOID Filter,
    OUT PVOID *Response,
    OUT PULONG ResponseSize
    );

typedef NTSTATUS
    (*PI_NetLogonLdapLookupEx)(
    IN PVOID Filter,
    IN PVOID SockAddr,
    OUT PVOID *Response,
    OUT PULONG ResponseSize
    );

typedef VOID
    (*PI_NetLogonFree)(
    IN PVOID Buffer
    );

typedef NET_API_STATUS
    (*PI_DsGetDcCache)(
    IN LPCWSTR NetbiosDomainName OPTIONAL,
    IN LPCWSTR DnsDomainName OPTIONAL,
    OUT PBOOLEAN InNt4Domain,
    OUT LPDWORD InNt4DomainTime
    );

typedef NET_API_STATUS
    (*PDsrGetDcName)(
        IN LPWSTR ComputerName OPTIONAL,
        IN LPWSTR DomainName OPTIONAL,
        IN GUID *DomainGuid OPTIONAL,
        IN GUID *SiteGuid OPTIONAL,
        IN ULONG Flags,
        OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
        );

typedef NET_API_STATUS
    (*PDsrGetDcNameEx2)(
        IN LPWSTR ComputerName OPTIONAL,
        IN LPCWSTR AccountName OPTIONAL,
        IN ULONG AllowableAccountControlBits,
        IN LPWSTR DomainName OPTIONAL,
        IN GUID *DomainGuid OPTIONAL,
        IN LPWSTR SiteName OPTIONAL,
        IN ULONG Flags,
        OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
        );

typedef NTSTATUS
(*PI_NetNotifyDsChange)(
    IN NL_DS_CHANGE_TYPE DsChangeType
    );

typedef NTSTATUS
(*PI_NetLogonReadChangeLog)(
    IN PVOID InContext,
    IN ULONG InContextSize,
    IN ULONG ChangeBufferSize,
    OUT PVOID *ChangeBuffer,
    OUT PULONG BytesRead,
    OUT PVOID *OutContext,
    OUT PULONG OutContextSize
    );

typedef NTSTATUS
(*PI_NetLogonNewChangeLog)(
    OUT HANDLE *ChangeLogHandle
    );

typedef NTSTATUS
(*PI_NetLogonAppendChangeLog)(
    IN HANDLE ChangeLogHandle,
    IN PVOID ChangeBuffer,
    IN ULONG ChangeBufferSize
    );

typedef NTSTATUS
(*PI_NetLogonCloseChangeLog)(
    IN HANDLE ChangeLogHandle,
    IN BOOLEAN Commit
    );

typedef NTSTATUS
(*PI_NetLogonSendToSamOnPdc)(
    IN LPWSTR DomainName,
    IN LPBYTE OpaqueBuffer,
    IN ULONG OpaqueBufferSize
    );

typedef NET_API_STATUS
(*PI_NetLogonGetIpAddresses)(
    OUT PULONG IpAddressCount,
    OUT LPBYTE *IpAddresses
    );

typedef NTSTATUS
(*PI_NetLogonGetAuthDataEx)(
    IN LPWSTR HostedDomainName,
    IN LPWSTR TrustedDomainName,
    IN BOOLEAN ResetChannel,
    IN ULONG Flags,
    OUT LPWSTR *ServerName,
    OUT PNL_OS_VERSION ServerOsVersion,
    OUT LPWSTR *ServerPrincipleName,
    OUT PVOID *ClientContext,
    OUT PULONG AuthnLevel
    );

typedef NTSTATUS
(*PI_NetLogonGetDirectDomain)(
    IN LPWSTR HostedDomainName,
    IN LPWSTR TrustedDomainName,
    OUT LPWSTR *DirectDomainName
    );

typedef NTSTATUS
(*PI_NetNotifyNtdsDsaDeletion) (
    IN LPWSTR DnsDomainName,
    IN GUID *DomainGuid,
    IN GUID *DsaGuid,
    IN LPWSTR DnsHostName
    );

typedef NET_API_STATUS
(*PI_NetLogonAddressToSiteName)(
    IN PSOCKET_ADDRESS SocketAddress,
    OUT LPWSTR *SiteName
    );

//
// Global status
//

HANDLE NetlogonDllHandle = NULL;
PI_NetNotifyDelta pI_NetNotifyDelta = NULL;
PI_NetNotifyRole pI_NetNotifyRole = NULL;
PI_NetNotifyMachineAccount pI_NetNotifyMachineAccount = NULL;
PI_NetNotifyTrustedDomain pI_NetNotifyTrustedDomain = NULL;
PI_NetLogonSetServiceBits pI_NetLogonSetServiceBits = NULL;
PI_NetLogonGetSerialNumber pI_NetLogonGetSerialNumber = NULL;
PI_NetLogonLdapLookup pI_NetLogonLdapLookup = NULL;
PI_NetLogonLdapLookupEx pI_NetLogonLdapLookupEx = NULL;
PI_NetLogonFree pI_NetLogonFree = NULL;
PI_DsGetDcCache pI_DsGetDcCache = NULL;
PDsrGetDcName pDsrGetDcName = NULL;
PDsrGetDcNameEx2 pDsrGetDcNameEx2 = NULL;
PI_NetNotifyDsChange pI_NetNotifyDsChange = NULL;
PI_NetLogonReadChangeLog pI_NetLogonReadChangeLog = NULL;
PI_NetLogonNewChangeLog pI_NetLogonNewChangeLog = NULL;
PI_NetLogonAppendChangeLog pI_NetLogonAppendChangeLog = NULL;
PI_NetLogonCloseChangeLog pI_NetLogonCloseChangeLog = NULL;
PI_NetLogonSendToSamOnPdc pI_NetLogonSendToSamOnPdc = NULL;
PI_NetLogonGetIpAddresses pI_NetLogonGetIpAddresses = NULL;
PI_NetLogonGetAuthDataEx pI_NetLogonGetAuthDataEx = NULL;
PI_NetLogonGetDirectDomain pI_NetLogonGetDirectDomain = NULL;
PI_NetNotifyNtdsDsaDeletion pI_NetNotifyNtdsDsaDeletion = NULL;
PI_NetLogonAddressToSiteName pI_NetLogonAddressToSiteName = NULL;


NTSTATUS
NlLoadNetlogonDll(
    VOID
    )
/*++

Routine Description:

    This function loads the netlogon.dll module if it is not loaded
    already. If the network is not installed then netlogon.dll will not
    present in the system and the LoadLibrary will fail.

Arguments:

    None

Return Value:

    NT Status code.

--*/
{
    static NTSTATUS DllLoadStatus = STATUS_SUCCESS;
    PI_NetNotifyNetlogonDllHandle pI_NetNotifyNetlogonDllHandle = NULL;
    HANDLE DllHandle = NULL;


    //
    // If we've tried to load the DLL before and it failed,
    //  return the same error code again.
    //

    if( DllLoadStatus != STATUS_SUCCESS ) {
        goto Cleanup;
    }


    //
    // Load netlogon.dll
    //

    DllHandle = LoadLibraryA( "Netlogon" );

    if ( DllHandle == NULL ) {

#if DBG
        DWORD DbgError;

        DbgError = GetLastError();

        DbgPrint("[Security Process] can't load netlogon.dll %d \n",
            DbgError);
#endif // DBG

        DllLoadStatus = STATUS_DLL_NOT_FOUND;

        goto Cleanup;
    }

//
// Macro to grab the address of the named procedure from netlogon.dll
//

#if DBG
#define GRAB_ADDRESS( _X ) \
    p##_X = (P##_X) GetProcAddress( DllHandle, #_X ); \
    \
    if ( p##_X == NULL ) { \
        DbgPrint("[security process] can't load " #_X " procedure. %ld\n", GetLastError()); \
        DllLoadStatus = STATUS_PROCEDURE_NOT_FOUND;\
        goto Cleanup; \
    }

#else // DBG
#define GRAB_ADDRESS( _X ) \
    p##_X = (P##_X) GetProcAddress( DllHandle, #_X ); \
    \
    if ( p##_X == NULL ) { \
        DllLoadStatus = STATUS_PROCEDURE_NOT_FOUND;\
        goto Cleanup; \
    }

#endif // DBG


    //
    // Get the addresses of the required procedures.
    //

    GRAB_ADDRESS( I_NetNotifyDelta );
    GRAB_ADDRESS( I_NetNotifyRole );
    GRAB_ADDRESS( I_NetNotifyMachineAccount );
    GRAB_ADDRESS( I_NetNotifyTrustedDomain );
    GRAB_ADDRESS( I_NetLogonSetServiceBits );
    GRAB_ADDRESS( I_NetLogonGetSerialNumber );
    GRAB_ADDRESS( I_NetLogonLdapLookup );
    GRAB_ADDRESS( I_NetLogonLdapLookupEx );
    GRAB_ADDRESS( I_NetLogonFree );
    GRAB_ADDRESS( I_DsGetDcCache );
    GRAB_ADDRESS( DsrGetDcName );
    GRAB_ADDRESS( DsrGetDcNameEx2 );
    GRAB_ADDRESS( I_NetNotifyDsChange );
    GRAB_ADDRESS( I_NetLogonReadChangeLog );
    GRAB_ADDRESS( I_NetLogonNewChangeLog );
    GRAB_ADDRESS( I_NetLogonAppendChangeLog );
    GRAB_ADDRESS( I_NetLogonCloseChangeLog );
    GRAB_ADDRESS( I_NetLogonSendToSamOnPdc );
    GRAB_ADDRESS( I_NetLogonGetIpAddresses );
    GRAB_ADDRESS( I_NetLogonGetAuthDataEx );
    GRAB_ADDRESS( I_NetLogonGetDirectDomain );
    GRAB_ADDRESS( I_NetNotifyNtdsDsaDeletion );
    GRAB_ADDRESS( I_NetLogonAddressToSiteName );

    //
    // Find the address of the I_NetNotifyNetlogonDllHandle procedure.
    //  This is an optional procedure so don't complain if it isn't there.
    //

    pI_NetNotifyNetlogonDllHandle = (PI_NetNotifyNetlogonDllHandle)
        GetProcAddress( DllHandle, "I_NetNotifyNetlogonDllHandle" );



    DllLoadStatus = STATUS_SUCCESS;

Cleanup:
    if (DllLoadStatus == STATUS_SUCCESS) {
        NetlogonDllHandle = DllHandle;

        //
        // Notify Netlogon that we've loaded it.
        //

        if( pI_NetNotifyNetlogonDllHandle != NULL ) {
            (VOID) (*pI_NetNotifyNetlogonDllHandle)( &NetlogonDllHandle );
        }

    } else {
        if ( DllHandle != NULL ) {
            FreeLibrary( DllHandle );
        }
    }
    return( DllLoadStatus );
}


NTSTATUS
I_NetNotifyDelta (
    IN SECURITY_DB_TYPE DbType,
    IN LARGE_INTEGER ModificationCount,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PSID ObjectSid,
    IN PUNICODE_STRING ObjectName,
    IN DWORD ReplicationImmediately,
    IN PSAM_DELTA_DATA MemberId
    )
/*++

Routine Description:

    This function is called by the SAM and LSA services after each
    change is made to the SAM and LSA databases.  The services describe
    the type of object that is modified, the type of modification made
    on the object, the serial number of this modification etc.  This
    information is stored for later retrieval when a BDC or member
    server wants a copy of this change.  See the description of
    I_NetSamDeltas for a description of how the change log is used.

    Add a change log entry to circular change log maintained in cache as
    well as on the disk and update the head and tail pointers

    It is assumed that Tail points to a block where this new change log
    entry may be stored.

    NOTE: The actual code is in netlogon.dll. This wrapper function
    will determine whether the network is installed, if so, it calls the
    actual worker function after loading the netlogon.dll module. If the
    network is not installed then this will function will return with
    appropriate error code.

Arguments:

    DbType - Type of the database that has been modified.

    ModificationCount - The value of the DomainModifiedCount field for the
        domain following the modification.

    DeltaType - The type of modification that has been made on the object.

    ObjectType - The type of object that has been modified.

    ObjectRid - The relative ID of the object that has been modified.
        This parameter is valid only when the object type specified is
        either SecurityDbObjectSamUser, SecurityDbObjectSamGroup or
        SecurityDbObjectSamAlias otherwise this parameter is set to zero.

    ObjectSid - The SID of the object that has been modified.  If the object
        modified is in a SAM database, ObjectSid is the DomainId of the Domain
        containing the object.

    ObjectName - The name of the secret object when the object type
        specified is SecurityDbObjectLsaSecret or the old name of the object
        when the object type specified is either SecurityDbObjectSamUser,
        SecurityDbObjectSamGroup or SecurityDbObjectSamAlias and the delta
        type is SecurityDbRename otherwise this parameter is set to NULL.

    ReplicateImmediately - TRUE if the change should be immediately
        replicated to all BDCs.  A password change should set the flag
        TRUE.

    MemberId - This parameter is specified when group/alias membership
        is modified. This structure will then point to the member's ID that
        has been updated.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

--*/
{

    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetNotifyDelta)(
                    DbType,
                    ModificationCount,
                    DeltaType,
                    ObjectType,
                    ObjectRid,
                    ObjectSid,
                    ObjectName,
                    ReplicationImmediately,
                    MemberId
                );

    return( STATUS_SUCCESS );

}


NTSTATUS
I_NetNotifyRole(
    IN POLICY_LSA_SERVER_ROLE Role
    )
/*++

Routine Description:

    This function is called by the LSA service upon LSA initialization
    and when LSA changes domain role.  This routine will initialize the
    change log cache if the role specified is PDC or delete the change
    log cache if the role specified is other than PDC.

    When this function initializing the change log if the change log
    currently exists on disk, the cache will be initialized from disk.
    LSA should treat errors from this routine as non-fatal.  LSA should
    log the errors so they may be corrected then continue
    initialization.  However, LSA should treat the system databases as
    read-only in this case.

    NOTE: The actual code is in netlogon.dll. This wrapper function
    will determine whether the network is installed, if so, it calls the
    actual worker function after loading the netlogon.dll module. If the
    network is not installed then this will function will return with
    appropriate error code.

Arguments:

    Role - Current role of the server.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

--*/
{


    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetNotifyRole)(
                    Role
                );

#if DBG

    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetNotifyRole returns 0x%lx \n",
                    NtStatus);
    }

#endif // DBG

    return( STATUS_SUCCESS );

}


NTSTATUS
I_NetNotifyMachineAccount (
    IN ULONG ObjectRid,
    IN PSID DomainSid,
    IN ULONG OldUserAccountControl,
    IN ULONG NewUserAccountControl,
    IN PUNICODE_STRING ObjectName
    )
/*++

Routine Description:

    This function is called by the SAM to indicate that the account type
    of a machine account has changed.  Specifically, if
    USER_INTERDOMAIN_TRUST_ACCOUNT, USER_WORKSTATION_TRUST_ACCOUNT, or
    USER_SERVER_TRUST_ACCOUNT change for a particular account, this
    routine is called to let Netlogon know of the account change.

    NOTE: The actual code is in netlogon.dll. This wrapper function
    will determine whether the network is installed, if so, it calls the
    actual worker function after loading the netlogon.dll module. If the
    network is not installed then this will function will return with
    appropriate error code.

Arguments:

    ObjectRid - The relative ID of the object that has been modified.

    DomainSid - Specifies the SID of the Domain containing the object.

    OldUserAccountControl - Specifies the previous value of the
        UserAccountControl field of the user.

    NewUserAccountControl - Specifies the new (current) value of the
        UserAccountControl field of the user.

    ObjectName - The name of the account being changed.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetNotifyMachineAccount)(
                    ObjectRid,
                    DomainSid,
                    OldUserAccountControl,
                    NewUserAccountControl,
                    ObjectName );

#if DBG
    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetNotifyMachineAccount returns 0x%lx\n",
                    NtStatus);
    }
#endif // DBG

    return( NtStatus );
}


NTSTATUS
I_NetNotifyTrustedDomain (
    IN PSID HostedDomainSid,
    IN PSID TrustedDomainSid,
    IN BOOLEAN IsDeletion
    )
/*++

Routine Description:

    This function is called by the LSA to indicate that a trusted domain
    object has changed.

    This function is called for both PDC and BDC.

Arguments:

    HostedDomainSid - Domain SID of the domain the trust is from.

    TrustedDomainSid - Domain SID of the domain the trust is to.

    IsDeletion - TRUE if the trusted domain object was deleted.
        FALSE if the trusted domain object was created or modified.


Return Value:

    Status of the operation.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetNotifyTrustedDomain)(
                    HostedDomainSid,
                    TrustedDomainSid,
                    IsDeletion );

#if DBG
    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetNotifyTrustedDomain returns 0x%lx\n",
                    NtStatus);
    }
#endif // DBG

    return( NtStatus );
}



NTSTATUS
I_NetLogonSetServiceBits(
    IN DWORD ServiceBitsOfInterest,
    IN DWORD ServiceBits
    )

/*++

Routine Description:

    Inidcates whether this DC is currently running the specified service.

    For instance,

        I_NetLogonSetServiceBits( DS_KDC_FLAG, DS_KDC_FLAG );

    tells Netlogon the KDC is running.  And

        I_NetLogonSetServiceBits( DS_KDC_FLAG, 0 );

    tells Netlogon the KDC is not running.

Arguments:

    ServiceBitsOfInterest - A mask of the service bits being changed, set,
        or reset by this call.  Only the following flags are valid:

            DS_KDC_FLAG
            DS_DS_FLAG
            DS_TIMESERV_FLAG

    ServiceBits - A mask indicating what the bits specified by ServiceBitsOfInterest
        should be set to.


Return Value:

    STATUS_SUCCESS - Success.

    STATUS_INVALID_PARAMETER - The parameters have extaneous bits set.

    STATUS_DLL_NOT_FOUND - Netlogon.dll could not be loaded.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonSetServiceBits)(
                    ServiceBitsOfInterest,
                    ServiceBits );

#if DBG
    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonSetServiceBits returns 0x%lx\n",
                    NtStatus);
    }
#endif // DBG

    return( NtStatus );
}


NTSTATUS
I_NetLogonGetSerialNumber (
    IN SECURITY_DB_TYPE DbType,
    IN PSID DomainSid,
    OUT PLARGE_INTEGER SerialNumber
    )
/*++

Routine Description:

    This function is called by the SAM and LSA services when they startup
    to get the current serial number written to the changelog.

Arguments:

    DbType - Type of the database that has been modified.

    DomainSid - For the SAM and builtin database, this specifies the DomainId of
        the domain whose serial number is to be returned.

    SerialNumber - Returns the latest set value of the DomainModifiedCount
        field for the domain.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_INVALID_DOMAIN_ROLE - This machine is not the PDC.

    STATUS_DLL_NOT_FOUND - Netlogon.dll could not be loaded.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonGetSerialNumber)(
                    DbType,
                    DomainSid,
                    SerialNumber );

#if DBG
    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonGetSerialNumber returns 0x%lx\n",
                    NtStatus);
    }
#endif // DBG

    return( NtStatus );
}

NTSTATUS
I_NetLogonLdapLookup(
    IN PVOID Filter,
    OUT PVOID *Response,
    OUT PULONG ResponseSize
    )

/*++

Routine Description:

    This routine builds a response to an LDAP ping of a DC.  DsGetDcName does
    such a ping to ensure the DC is functional and still meets the requirements
    of the DsGetDcName.  DsGetDcName does an LDAP lookup of the NULL DN asking
    for attribute "Netlogon".  The DS turns that into a call to this routine
    passing in the filter parameter.

Arguments:

    Filter - Filter describing the query.  The filter is built by the DsGetDcName
        client, so we can limit the flexibility significantly.  The filter is:

    Response - Returns a pointer to an allocated buffer containing
        the response to return to the caller.  This response is a binary blob
        which should be returned to the caller bit-for-bit intact.
        The buffer should be freed be calling I_NetLogonFree.

    ResponseSize - Size (in bytes) of the returned message.

Return Value:

    STATUS_SUCCESS -- The response was returned in the supplied buffer.

    STATUS_INVALID_PARAMETER -- The filter was invalid.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonLdapLookup)(
                    Filter,
                    Response,
                    ResponseSize );

#if DBG
    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonLdapLookup returns 0x%lx\n",
                    NtStatus);
    }
#endif // DBG

    return( NtStatus );

}

NTSTATUS
I_NetLogonLdapLookupEx(
    IN PVOID Filter,
    IN PVOID SockAddr,
    OUT PVOID *Response,
    OUT PULONG ResponseSize
    )

/*++

Routine Description:

    This routine builds a response to an LDAP ping of a DC.  DsGetDcName does
    such a ping to ensure the DC is functional and still meets the requirements
    of the DsGetDcName.  DsGetDcName does an LDAP lookup of the NULL DN asking
    for attribute "Netlogon".  The DS turns that into a call to this routine
    passing in the filter parameter.

Arguments:

    Filter - Filter describing the query.  The filter is built by the DsGetDcName
        client, so we can limit the flexibility significantly.  The filter is:

    SockAddr - Address of the client that sent the ping.

    Response - Returns a pointer to an allocated buffer containing
        the response to return to the caller.  This response is a binary blob
        which should be returned to the caller bit-for-bit intact.
        The buffer should be freed be calling I_NetLogonFree.

    ResponseSize - Size (in bytes) of the returned message.

Return Value:

    STATUS_SUCCESS -- The response was returned in the supplied buffer.

    STATUS_INVALID_PARAMETER -- The filter was invalid.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonLdapLookupEx)(
                    Filter,
                    SockAddr,
                    Response,
                    ResponseSize );

#ifdef notdef // Failures occur frequently in nature
#if DBG
    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonLdapLookupEx returns 0x%lx\n",
                    NtStatus);
    }
#endif // DBG
#endif // notdef

    return( NtStatus );

}

VOID
I_NetLogonFree(
    IN PVOID Buffer
    )

/*++

Routine Description:

    Free any buffer allocated by Netlogon and returned to an in-process caller.

Arguments:

    Buffer - Buffer to deallocate.

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return;
        }
    }

    (*pI_NetLogonFree)( Buffer );
}


NET_API_STATUS
I_DsGetDcCache(
    IN LPCWSTR NetbiosDomainName OPTIONAL,
    IN LPCWSTR DnsDomainName OPTIONAL,
    OUT PBOOLEAN InNt4Domain,
    OUT LPDWORD InNt4DomainTime
    )
/*++

Routine Description:

    This routine finds a domain entry that matches the caller's query.

Arguments:

    NetbiosDomainName - Specifies the Netbios name of the domain to find.

    DnsDomainName - Specifies the Dns name of the domain to find.

        At least one of the above parameters should be non-NULL.

    InNt4Domain - Returns true if the domain is an NT 4.0 domain.

    InNt4DomainTime - Returns the GetTickCount time of when the domain was
        detected to be an NT 4.0 domain.

Return Value:

    NO_ERROR: Information is returned about the domain.

    ERROR_NO_SUCH_DOMAIN: cached information is not available for this domain.

--*/
{
    NTSTATUS NtStatus;
    NET_API_STATUS NetStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NetStatus = (*pI_DsGetDcCache)(
                    NetbiosDomainName,
                    DnsDomainName,
                    InNt4Domain,
                    InNt4DomainTime );

    return( NetStatus );
}

NET_API_STATUS
DsrGetDcName(
        IN LPWSTR ComputerName OPTIONAL,
        IN LPWSTR DomainName OPTIONAL,
        IN GUID *DomainGuid OPTIONAL,
        IN GUID *SiteGuid OPTIONAL,
        IN ULONG Flags,
        OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
)
/*++

Routine Description:

    Same as DsGetDcNameW except:

    * This is the RPC server side implementation.

Arguments:

    Same as DsGetDcNameW except as above.

Return Value:

    Same as DsGetDcNameW except as above.


--*/
{
    NTSTATUS NtStatus;
    NET_API_STATUS NetStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NetStatus = (*pDsrGetDcName)(
                    ComputerName,
                    DomainName,
                    DomainGuid,
                    SiteGuid,
                    Flags,
                    DomainControllerInfo );

    return( NetStatus );
}

NET_API_STATUS
DsrGetDcNameEx2(
        IN LPWSTR ComputerName OPTIONAL,
        IN LPWSTR AccountName OPTIONAL,
        IN ULONG AllowableAccountControlBits,
        IN LPWSTR DomainName OPTIONAL,
        IN GUID *DomainGuid OPTIONAL,
        IN LPWSTR SiteName OPTIONAL,
        IN ULONG Flags,
        OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
)
/*++

Routine Description:

    Same as DsGetDcNameW except:

    AccountName - Account name to pass on the ping request.
        If NULL, no account name will be sent.

    AllowableAccountControlBits - Mask of allowable account types for AccountName.

    * This is the RPC server side implementation.

Arguments:

    Same as DsGetDcNameW except as above.

Return Value:

    Same as DsGetDcNameW except as above.


--*/
{
    NTSTATUS NtStatus;
    NET_API_STATUS NetStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NetStatus = (*pDsrGetDcNameEx2)(
                    ComputerName,
                    AccountName,
                    AllowableAccountControlBits,
                    DomainName,
                    DomainGuid,
                    SiteName,
                    Flags,
                    DomainControllerInfo );

    return( NetStatus );
}


NTSTATUS
I_NetNotifyDsChange(
    IN NL_DS_CHANGE_TYPE DsChangeType
    )
/*++

Routine Description:

    This function is called by the LSA to indicate that configuration information
    in the DS has changed.

    This function is called for both PDC and BDC.

Arguments:

    DsChangeType - Indicates the type of information that has changed.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetNotifyDsChange)(
                    DsChangeType
                );

#if DBG

    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetNotifyDsChange &ld returns 0x%lx \n",
                    DsChangeType,
                    NtStatus);
    }

#endif // DBG

    return( NtStatus );

}



NTSTATUS
I_NetLogonReadChangeLog(
    IN PVOID InContext,
    IN ULONG InContextSize,
    IN ULONG ChangeBufferSize,
    OUT PVOID *ChangeBuffer,
    OUT PULONG BytesRead,
    OUT PVOID *OutContext,
    OUT PULONG OutContextSize
    )
/*++

Routine Description:

    This function returns a portion of the change log to the caller.

    The caller asks for the first portion of the change log by passing zero as
    the InContext/InContextSize.  Each call passes out an OutContext that
    identifies the last change returned to the caller.  That context can
    be passed in on a subsequent call to I_NetlogonReadChangeLog.

Arguments:

    InContext - Opaque context describing the last entry to have been previously
        returned.  Specify NULL to request the first entry.

    InContextSize - Size (in bytes) of InContext.  Specify 0 to request the
        first entry.

    ChangeBufferSize - Specifies the size (in bytes) of the passed in ChangeBuffer.

    ChangeBuffer - Returns the next several entries from the change log.
        Buffer must be DWORD aligned.

    BytesRead - Returns the size (in bytes) of the entries returned in ChangeBuffer.

    OutContext - Returns an opaque context describing the last entry returned
        in ChangeBuffer.  NULL is returned if no entries were returned.
        The buffer must be freed using I_NetLogonFree

    OutContextSize - Returns the size (in bytes) of OutContext.


Return Value:

    STATUS_MORE_ENTRIES - More entries are available.  This function should
        be called again to retrieve the remaining entries.

    STATUS_SUCCESS - No more entries are currently available.  Some entries may
        have been returned on this call.  This function need not be called again.
        However, the caller can determine if new change log entries were
        added to the log, by calling this function again passing in the returned
        context.

    STATUS_INVALID_PARAMETER - InContext is invalid.
        Either it is too short or the change log entry described no longer
        exists in the change log.

    STATUS_INVALID_DOMAIN_ROLE - Change log not initialized

    STATUS_NO_MEMORY - There is not enough memory to allocate OutContext.


--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonReadChangeLog)(
                    InContext,
                    InContextSize,
                    ChangeBufferSize,
                    ChangeBuffer,
                    BytesRead,
                    OutContext,
                    OutContextSize
                );

#if DBG

    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonReadChangeLog returns 0x%lx \n",
                    NtStatus);
    }

#endif // DBG

    return( NtStatus );
}




NTSTATUS
I_NetLogonNewChangeLog(
    OUT HANDLE *ChangeLogHandle
    )
/*++

Routine Description:

    This function opens a new changelog file for writing.  The new changelog
    is a temporary file.  The real change log will not be modified until
    I_NetLogonCloseChangeLog is called asking to Commit the changes.

    The caller should follow this call by Zero more calls to
    I_NetLogonAppendChangeLog followed by a call to I_NetLogonCloseChangeLog.

    Only one temporary change log can be active at once.

Arguments:

    ChangeLogHandle - Returns a handle identifying the temporary change log.

Return Value:

    STATUS_SUCCESS - The temporary change log has been successfully opened.

    STATUS_INVALID_DOMAIN_ROLE - DC is neither PDC nor BDC.

    STATUS_NO_MEMORY - Not enough memory to create the change log buffer.

    Sundry file creation errors.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonNewChangeLog)(
                    ChangeLogHandle
                );

#if DBG

    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonNewChangeLog returns 0x%lx \n",
                    NtStatus);
    }

#endif // DBG

    return( NtStatus );
}




NTSTATUS
I_NetLogonAppendChangeLog(
    IN HANDLE ChangeLogHandle,
    IN PVOID ChangeBuffer,
    IN ULONG ChangeBufferSize
    )
/*++

Routine Description:

    This function appends change log information to new changelog file.

    The ChangeBuffer must be a change buffer returned from I_NetLogonReadChangeLog.
    Care should be taken to ensure each call to I_NetLogonReadChangeLog is
    exactly matched by one call to I_NetLogonAppendChangeLog.

Arguments:

    ChangeLogHandle - A handle identifying the temporary change log.

    ChangeBuffer - A buffer describing a set of changes returned from
    I_NetLogonReadChangeLog.

    ChangeBufferSize - Size (in bytes) of ChangeBuffer.

Return Value:

    STATUS_SUCCESS - The temporary change log has been successfully opened.

    STATUS_INVALID_DOMAIN_ROLE - DC is neither PDC nor BDC.

    STATUS_INVALID_HANDLE - ChangeLogHandle is not valid.

    STATUS_INVALID_PARAMETER - ChangeBuffer contains invalid data.

    Sundry disk write errors.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonAppendChangeLog)(
                    ChangeLogHandle,
                    ChangeBuffer,
                    ChangeBufferSize
                );

#if DBG

    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonAppendChangeLog returns 0x%lx \n",
                    NtStatus);
    }

#endif // DBG

    return( NtStatus );
}


NTSTATUS
I_NetLogonCloseChangeLog(
    IN HANDLE ChangeLogHandle,
    IN BOOLEAN Commit
    )
/*++

Routine Description:

    This function closes a new changelog file.

Arguments:

    ChangeLogHandle - A handle identifying the temporary change log.

    Commit - If true, the specified changes are written to the primary change log.
        If false, the specified change are deleted.

Return Value:

    STATUS_SUCCESS - The temporary change log has been successfully opened.

    STATUS_INVALID_DOMAIN_ROLE - DC is neither PDC nor BDC.

    STATUS_INVALID_HANDLE - ChangeLogHandle is not valid.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonCloseChangeLog)(
                    ChangeLogHandle,
                    Commit
                );

#if DBG

    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonCloseChangeLog returns 0x%lx \n",
                    NtStatus);
    }

#endif // DBG

    return( NtStatus );
}




NTSTATUS
I_NetLogonSendToSamOnPdc(
    IN LPWSTR DomainName,
    IN LPBYTE OpaqueBuffer,
    IN ULONG OpaqueBufferSize
    )
/*++

Routine Description:

    This function sends an opaque buffer from SAM on a BDC to SAM on the PDC of
    the specified domain.

    The original use of this routine will be to allow the BDC to forward user
    account password changes to the PDC.


Arguments:

    DomainName - Identifies the hosted domain that this request applies to.
        DomainName may be the Netbios domain name or the DNS domain name.
        NULL implies the primary domain hosted by this DC.

    OpaqueBuffer - Buffer to be passed to the SAM service on the PDC.
        The buffer will be encrypted on the wire.

    OpaqueBufferSize - Size (in bytes) of OpaqueBuffer.

Return Value:

    STATUS_SUCCESS: Message successfully sent to PDC

    STATUS_NO_MEMORY: There is not enough memory to complete the operation

    STATUS_NO_SUCH_DOMAIN: DomainName does not correspond to a hosted domain

    STATUS_NO_LOGON_SERVERS: PDC is not currently available

    STATUS_NOT_SUPPORTED: PDC does not support this operation

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonSendToSamOnPdc)(
                    DomainName,
                    OpaqueBuffer,
                    OpaqueBufferSize );

#if DBG

    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonSendToSamOnPdc returns 0x%lx \n",
                    NtStatus);
    }

#endif // DBG

    return( NtStatus );
}

NET_API_STATUS
I_NetLogonGetIpAddresses(
    OUT PULONG IpAddressCount,
    OUT LPBYTE *IpAddresses
    )
/*++

Routine Description:

    Returns all of the IP Addresses assigned to this machine.

Arguments:


    IpAddressCount - Returns the number of IP addresses assigned to this machine.

    IpAddresses - Returns a buffer containing an array of SOCKET_ADDRESS
        structures.
        This buffer should be freed using I_NetLogonFree().

Return Value:

    NO_ERROR - Success

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the operation.

    ERROR_NETLOGON_NOT_STARTED - Netlogon is not started.

--*/
{
    NTSTATUS NtStatus;
    NET_API_STATUS NetStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NetStatus = (*pI_NetLogonGetIpAddresses)(
                    IpAddressCount,
                    IpAddresses );

    return( NetStatus );
}


NTSTATUS
I_NetLogonGetAuthDataEx(
    IN LPWSTR HostedDomainName,
    IN LPWSTR TrustedDomainName,
    IN BOOLEAN ResetChannel,
    IN ULONG Flags,
    OUT LPWSTR *ServerName,
    OUT PNL_OS_VERSION ServerOsVersion,
    OUT LPWSTR *ServerPrincipleName,
    OUT PVOID *ClientContext,
    OUT PULONG AuthnLevel
    )
/*++

Routine Description:

    This function returns the data that a caller could passed to
    RpcBindingSetAuthInfoW to do an RPC call using the Netlogon security package.

    The returned data is valid for the life of Netlogon's secure channel to
    the current DC.  There is no way for the caller to determine that lifetime.
    So, the caller should be prepared for access to be denied and respond to that
    by calling I_NetLogonGetAuthData again.

    Once the returned data is passed to RpcBindingSetAuthInfoW, the data should
    not be deallocated until after the binding handle is closed.

Arguments:

    HostedDomainName - Identifies the hosted domain that this request applies to.
        DomainName may be the Netbios domain name or the DNS domain name.
        NULL implies the primary domain hosted by this machine.

    TrustedDomainName - Identifies the domain the trust relationship is to.
        DomainName may be the Netbios domain name or the DNS domain name.

    ResetChannel - If true, specifies that the netlogon secure channel
        is to be reset.

    Flags - Flags defining which ClientContext to return:

        NL_DIRECT_TRUST_REQUIRED: Indicates that STATUS_NO_SUCH_DOMAIN should be returned
            if TrustedDomainName is not directly trusted.

        NL_RETURN_CLOSEST_HOP: Indicates that for indirect trust, the "closest hop"
            session should be returned rather than the actual session

        NL_ROLE_PRIMARY_OK: Indicates that if this is a PDC, it's OK to return
            the client session to the primary domain.

        NL_REQUIRE_DOMAIN_IN_FOREST - Indicates that STATUS_NO_SUCH_DOMAIN should be returned
            if TrustedDomainName is not a domain in the forest.

    ServerName - UNC name of a DC in the trusted domain.
        The caller should RPC to the named DC.  This DC is the only DC
        that has the server side context associated with the ClientContext
        given below.
        The buffer must be freed using I_NetLogonFree.

    ServerOsVersion - Returns the operating system version of the machine named ServerName

    ServerPrincipleName - ServerPrincipleName to pass to RpcBindingSetAutInfo.
        (See note above about when this data can be deallocated.)
        The buffer must be freed using I_NetLogonFree.

    ClientContext - Authentication data to pass as AuthIdentity to RpcBindingSetAutInfo.
        (See note above about when this data can be deallocated.)
        The buffer must be freed using I_NetLogonFree.


    AuthnLevel - Authentication level Netlogon will use for its secure
        channel.  This value will be one of:

            RPC_C_AUTHN_LEVEL_PKT_PRIVACY: Sign and seal
            RPC_C_AUTHN_LEVEL_PKT_INTEGRITY: Sign only

        The caller can ignore this value and independently choose an authentication
        level.

Return Value:

    STATUS_SUCCESS: The auth data was successfully returned.

    STATUS_NO_MEMORY: There is not enough memory to complete the operation

    STATUS_NETLOGON_NOT_STARTED: Netlogon is not running

    STATUS_NO_SUCH_DOMAIN: HostedDomainName does not correspond to a hosted domain, OR
        TrustedDomainName is not a trusted domain.

    STATUS_NO_LOGON_SERVERS: No DCs are not currently available

    STATUS_NOT_SUPPORTED: DC does not support this operation
        Probably because the DC in the trusted domain is running NT 4.0,
        or Netlogon on this machine is configured to neither sign nor seal.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonGetAuthDataEx)(
                    HostedDomainName,
                    TrustedDomainName,
                    ResetChannel,
                    Flags,
                    ServerName,
                    ServerOsVersion,
                    ServerPrincipleName,
                    ClientContext,
                    AuthnLevel );

    return( NtStatus );
}


NTSTATUS
I_NetLogonGetDirectDomain(
    IN LPWSTR HostedDomainName,
    IN LPWSTR TrustedDomainName,
    OUT LPWSTR *DirectDomainName
    )
/*++

Routine Description:

    This function returns the name of a domain in the enterprise and returns
    the name of a domain that is one hop closer.

Arguments:

    HostedDomainName - Identifies the hosted domain that this request applies to.
        DomainName may be the Netbios domain name or the DNS domain name.
        NULL implies the primary domain hosted by this machine.

    TrustedDomainName - Identifies the domain the trust relationship is to.
        DomainName may be the Netbios domain name or the DNS domain name.

    DirectDomainName - Returns the DNS domain name of the domain that is
        one hop closer to TrustedDomainName.  If there is a direct trust to
        TrustedDomainName, NULL is returned.
        The buffer must be freed using I_NetLogonFree.


Return Value:

    STATUS_SUCCESS: The auth data was successfully returned.

    STATUS_NO_MEMORY: There is not enough memory to complete the operation

    STATUS_NETLOGON_NOT_STARTED: Netlogon is not running

    STATUS_NO_SUCH_DOMAIN: HostedDomainName does not correspond to a hosted domain, OR
        TrustedDomainName is not a trusted domain.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetLogonGetDirectDomain)(
                                HostedDomainName,
                                TrustedDomainName,
                                DirectDomainName );

#if DBG

    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetLogonGetDirectDomain returns 0x%lx \n",
                    NtStatus);
    }

#endif // DBG

    return( NtStatus );
}


NTSTATUS
I_NetNotifyNtdsDsaDeletion (
    IN LPWSTR DnsDomainName,
    IN GUID *DomainGuid,
    IN GUID *DsaGuid,
    IN LPWSTR DnsHostName
    )
/*++

Routine Description:

    This function is called by the DS to indicate that a NTDS-DSA object
    is being deleted.

    This function is called on the DC that the object is originally deleted on.
    It is not called when the deletion is replicated to other DCs.

Arguments:

    DnsDomainName - DNS domain name of the domain the DC was in.
        This need not be a domain hosted by this DC.

    DomainGuid - Domain Guid of the domain specified by DnsDomainName

    DsaGuid - GUID of the NtdsDsa object that is being deleted.

    DnsHostName - DNS host name of the DC whose NTDS-DSA object is being deleted.

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS NtStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NtStatus = (*pI_NetNotifyNtdsDsaDeletion)(
                                DnsDomainName,
                                DomainGuid,
                                DsaGuid,
                                DnsHostName );

#if DBG

    if( !NT_SUCCESS(NtStatus) ) {
        DbgPrint("[Security Process] I_NetNotifyNtdsDsaDeletion returns 0x%lx \n",
                    NtStatus);
    }

#endif // DBG

    return( NtStatus );
}

NET_API_STATUS
I_NetLogonAddressToSiteName(
    IN PSOCKET_ADDRESS SocketAddress,
    OUT LPWSTR *SiteName
    )
/*++

Routine Description:

    This function translates a socket addresses to site name.

Arguments:

    SocketAddress -- the requested socket address
    
    SiteName -- the corresponding site name                                                        

Return Value:

    Status of the operation.

--*/
{
    NTSTATUS NtStatus;
    NET_API_STATUS NetStatus;

    //
    // Load netlogon.dll if it hasn't already been loaded.
    //

    if( NetlogonDllHandle == NULL ) {
        if( (NtStatus = NlLoadNetlogonDll()) != STATUS_SUCCESS ) {
            return( NtStatus );
        }
    }

    NetStatus = (*pI_NetLogonAddressToSiteName)(SocketAddress,
                                                SiteName );

    return( NetStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\logview\fvopen.c ===
/*
  +-------------------------------------------------------------------------+
  |               MDI Text File View - File open Functions                  |
  +-------------------------------------------------------------------------+
  |                        (c) Copyright 1994                               |
  |                          Microsoft Corp.                                |
  |                        All rights reserved                              |
  |                                                                         |
  | Program               : [FVOpen.c]                                      |
  | Programmer            : Arthur Hanson                                   |
  | Original Program Date : [Feb 11, 1994]                                  |
  | Last Update           : [Feb 11, 1994]                                  |
  |                                                                         |
  | Version:  0.10                                                          |
  |                                                                         |
  | Description:                                                            |
  |                                                                         |
  | History:                                                                |
  |   arth  Jul 27, 1993    0.10    Original Version.                       |
  |                                                                         |
  +-------------------------------------------------------------------------+
*/

#include "LogView.h"
#include <fcntl.h>
#include <io.h>
#include <string.h>

#define MAXFILENAME 256


CHAR szPropertyName [] = "FILENAME";  // Name of the File name property list item


/////////////////////////////////////////////////////////////////////////
BOOL 
FileExists(
   PSTR pch
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
        int fh;

        if ((fh = _open(pch, O_RDONLY)) < 0)
             return(FALSE);

        _lclose(fh);
        return(TRUE);
} // FileExists


/////////////////////////////////////////////////////////////////////////
VOID APIENTRY 
GetFileName(
   HWND hwnd, 
   PSTR pstr
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    CHAR szFmt[128];
    OPENFILENAME ofn;
    CHAR szFilterSpec[128];
    CHAR szDefExt[10];
    CHAR szFileName[MAXFILENAME];
    CHAR szFileTitle[MAXFILENAME];

    strcpy(szFileName, "");   // these need be NULL
    strcpy(szFileTitle, "");
    memset(&ofn,0,sizeof(ofn)) ;
    memset(szFilterSpec,0,sizeof(szFilterSpec)) ;

    LoadString (hInst, (WORD)IDS_OPENTEXT, 
                (LPSTR)szFmt, sizeof (szFmt));
    LoadString (hInst, (WORD)IDS_OPENFILTER,
                (LPSTR)szFilterSpec, sizeof (szFilterSpec));


    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hwnd;
    ofn.lpstrFilter       = szFilterSpec;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = szFileName;
    ofn.nMaxFile          = MAXFILENAME;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrFileTitle    = szFileTitle;
    ofn.nMaxFileTitle     = MAXFILENAME;
    ofn.lpstrTitle        = szFmt;

    LoadString (hInst, (WORD)IDS_DEFEXT, (LPSTR)szDefExt, sizeof (szDefExt));
    ofn.lpstrDefExt       = szDefExt;
    ofn.Flags             = OFN_FILEMUSTEXIST;
    
    // Use standard open dialog
    if (!GetOpenFileName ((LPOPENFILENAME)&ofn)) {
        *pstr = 0;
    }
    else {
        strcpy(pstr, ofn.lpstrFile);
    }
 
   return;

} // GetFileName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\logview\logview.h ===
#include "windows.h"

#ifndef WIN16
#ifndef WIN32
    #define WIN32   1       // placed because RC can't pass in C_DEFINES
#endif
    #include <commdlg.h>
#endif

#define CCHKEYMAX             32    // max characters in search string

#define GET_EM_SETSEL_MPS(iStart, iEnd) (UINT)(iStart), (LONG)(iEnd)
#define GET_WM_COMMAND_CMD(wp, lp)      HIWORD(wp)
#define GET_WM_COMMAND_HWND(wp, lp)     (HWND)(lp)
#define GET_WM_COMMAND_MPS(id, hwnd, cmd) (UINT)MAKELONG(id, cmd), (LONG)(hwnd)
#define GET_EM_SETSEL_MPS(iStart, iEnd) (UINT)(iStart), (LONG)(iEnd)
#define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (lp == (LONG_PTR)hwnd)

#define WINDOWMENU  2   // position of window menu
#define SHORTMENU   2   // position of short version window menu

#define DEFFILESEARCH   (LPSTR) "*.LOG"

#ifdef RC_INVOKED
#define ID(id) id
#else
#define ID(id) MAKEINTRESOURCE(id)
#endif

// edit control identifier
#define ID_EDIT 0xCAC

// resource ID's
#define IDLOGVIEW  ID(1)
#define IDLOGVIEW2 ID(3)
#define IDNOTE      ID(2)

// Window word values for child windows
#define GWL_HWNDEDIT    0
#define GWW_CHANGED     4
#define GWL_WORDWRAP    6
#define GWW_UNTITLED    10
#define CBWNDEXTRA      12

// menu ID's
#define IDM_FILENEW     1001
#define IDM_FILEOPEN    1002
#define ID_HELP_INDEX   1003
#define ID_HELP_USING   1004
#define ID_HELP_CONT    1005
#define IDM_FILEPRINT   1006
#define IDM_FILEEXIT    1007
#define IDM_FILEABOUT   1008
#define IDM_FILESETUP   1009
#define IDM_FILEMENU    1010

#define IDM_EDITUNDO    2001
#define IDM_EDITCUT     2002
#define IDM_EDITCOPY    2003
#define IDM_EDITPASTE   2004
#define IDM_EDITCLEAR   2005
#define IDM_EDITSELECT  2006
#define IDM_EDITTIME    2007
#define IDM_EDITWRAP    2008
#define IDM_EDITFONT    2009
#define IDM_EDITFIRST   IDM_EDITUNDO
#define IDM_EDITLAST    IDM_EDITFONT

#define IDM_SEARCHFIND  3001
#define IDM_SEARCHNEXT  3002
#define IDM_SEARCHPREV  3003
#define IDM_SEARCHFIRST IDM_SEARCHFIND
#define IDM_SEARCHLAST  IDM_SEARCHPREV

#define IDM_WINDOWTILE  4001
#define IDM_WINDOWCASCADE 4002
#define IDM_WINDOWCLOSEALL  4003
#define IDM_WINDOWICONS 4004

#define IDM_WINDOWCHILD 4100

#define IDM_HELPHELP    5001
#define IDM_HELPABOUT   5002
#define IDM_HELPSPOT    5003

#define IDD_FILEOPEN    ID(200)
#define IDD_FILENAME    201
#define IDD_FILES       202
#define IDD_PATH        203
#define IDD_DIRS        204

// dialog ids
#define IDD_ABOUT       ID(300)

#define IDD_FIND        ID(400)
#define IDD_SEARCH      401
#define IDD_PREV        402
#define IDD_NEXT        IDOK
#define IDD_CASE        403

#define IDD_SAVEAS      ID(500)
#define IDD_SAVEFROM    501
#define IDD_SAVETO      502

#define IDD_PRINT       ID(600)
#define IDD_PRINTDEVICE 601
#define IDD_PRINTPORT   602
#define IDD_PRINTTITLE  603

#define IDD_FONT        ID(700)
#define IDD_FACES       701
#define IDD_SIZES       702
#define IDD_BOLD        703
#define IDD_ITALIC      704
#define IDD_FONTTITLE   705

// +------------------------------------------------------------------------+
// About Box
// +------------------------------------------------------------------------+
#define IDC_AVAIL_MEM                   101
#define IDC_PHYSICAL_MEM                101
#define IDC_LICENSEE_COMPANY            104
#define IDC_LICENSEE_NAME               105
#define IDD_SPLASH                      105
#define IDC_MATH_COPR                   106
#define IDC_DISK_SPACE                  107
#define IDC_BIGICON                     1001

// strings
#define IDS_CANTOPEN    1
#define IDS_CANTREAD    2
#define IDS_CANTCREATE  3
#define IDS_CANTWRITE   4
#define IDS_ILLFNM      5
#define IDS_ADDEXT      6
#define IDS_CLOSESAVE   7
#define IDS_CANTFIND    8
#define IDS_HELPNOTAVAIL 9
#define IDS_CANTFINDSTR  10

#define IDS_CLIENTTITLE 16
#define IDS_UNTITLED    17
#define IDS_APPNAME     18

#define IDS_PRINTJOB    24
#define IDS_PRINTERROR  25

#define IDS_DISK_SPACE_UNAVAIL 26
#define IDS_DISK_SPACE         27
#define IDS_MATH_COPR_NOTPRESENT 28
#define IDS_MATH_COPR_PRESENT    29
#define IDS_AVAIL_MEM            30
#define IDS_PHYSICAL_MEM         31

#define IDS_OPENTEXT    32
#define IDS_OPENFILTER  33
#define IDS_DEFEXT      34

#define IDC_STATIC                      -1


// attribute flags for DlgDirList
#define ATTR_DIRS       0xC010          // find drives and directories
#define ATTR_FILES      0x0000          // find ordinary files
#define PROP_FILENAME   szPropertyName  // name of property for dialog


//  External variable declarations
extern HANDLE hInst;            // application instance handle
extern HANDLE hAccel;           // resource handle of accelerators
extern HWND hwndFrame;          // main window handle
extern HWND hwndMDIClient;      // handle of MDI Client window
extern HWND hwndActive;         // handle of current active MDI child
extern HWND hwndActiveEdit;     // handle of edit control in active child
extern LONG styleDefault;       // default child creation state
extern CHAR szChild[];          // class of child
extern CHAR szSearch[];         // search string
extern CHAR *szDriver;          // name of printer driver
extern CHAR szPropertyName[];   // filename property for dialog box
extern INT iPrinter;            // level of printing capability
extern BOOL fCase;              // searches case sensitive
extern WORD cFonts;             // number of fonts enumerated

extern FINDREPLACE FR;
extern UINT wHlpMsg;
extern UINT wFRMsg;
extern BOOL fReverse;

extern HANDLE   hStdCursor, hWaitCursor;

//  externally declared functions
extern BOOL APIENTRY InitializeApplication(VOID);
extern BOOL APIENTRY InitializeInstance(LPSTR,INT);
extern BOOL APIENTRY AboutDlgProc(HWND,UINT,UINT,LONG);
extern HWND APIENTRY AddFile(CHAR *);
extern VOID APIENTRY MyReadFile(HWND);
extern INT APIENTRY LoadFile(HWND, CHAR *);
extern VOID APIENTRY PrintFile(HWND);
extern BOOL APIENTRY GetInitializationData(HWND);
extern SHORT MPError(HWND,WORD,WORD, char *);
extern VOID APIENTRY Find(VOID);
extern VOID APIENTRY FindNext(VOID);
extern VOID APIENTRY FindPrev(VOID);
extern LRESULT APIENTRY MPFrameWndProc(HWND,UINT,UINT,LONG);
extern LRESULT APIENTRY MPMDIChildWndProc(HWND,UINT,UINT,LONG);
extern HDC APIENTRY GetPrinterDC(BOOL);
extern VOID NEAR PASCAL SetSaveFrom (HWND, PSTR);
extern BOOL NEAR PASCAL RealSlowCompare (PSTR, PSTR);
extern VOID APIENTRY FindPrev (VOID);
extern VOID APIENTRY FindNext (VOID);
extern BOOL NEAR PASCAL IsWild (PSTR);
extern VOID NEAR PASCAL SelectFile (HWND);
extern VOID NEAR PASCAL Local_FindText ( INT );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\logview\fvprint.c ===
/*
  +-------------------------------------------------------------------------+
  |                MDI Text File Viewer - Printing Routines                 |
  +-------------------------------------------------------------------------+
  |                        (c) Copyright 1994                               |
  |                          Microsoft Corp.                                |
  |                        All rights reserved                              |
  |                                                                         |
  | Program               : [FVPrint.c]                                     |
  | Programmer            : Arthur Hanson                                   |
  | Original Program Date : [Feb 11, 1994]                                  |
  | Last Update           : [Feb 11, 1994]                                  |
  |                                                                         |
  | Version:  0.10                                                          |
  |                                                                         |
  | Description:                                                            |
  |                                                                         |
  | History:                                                                |
  |   arth  Jul 27, 1993    0.10    Original Version.                       |
  |                                                                         |
  +-------------------------------------------------------------------------+
*/

#include "LogView.h"

BOOL fAbort;
HWND hwndPDlg;
CHAR szDevice[160];
PSTR szDriver;
PSTR szPort;
PSTR szTitle;
INT iPrinter = 0;       // level of available printer support.
                        // 0 - no printer available
                        // 1 - printer available
                        // 2 - driver supports 3.0 device initialization
HANDLE hInitData=NULL;

CHAR szExtDeviceMode[] = "EXTDEVICEMODE";


/*+-------------------------------------------------------------------------+
  | GetPrinterDC()                                                          |
  |                                                                         |
  |   Creates a printer display context for the default device.  As a side  |
  |   effect, it sets the szDevice and szPort variables.  It also sets      |
  |   iPrinter to the supported level of printing.                          |
  |                                                                         |
  +-------------------------------------------------------------------------+*/
HDC APIENTRY GetPrinterDC(BOOL bInformation) {
    HDC hdc;
    LPDEVMODE lpdevmode = NULL;

    iPrinter = 0;

    // Get the printer information from win.ini into a buffer and null terminate it.
    GetProfileString ( TEXT("windows"), TEXT("device"), TEXT(""), szDevice, sizeof(szDevice));
    for (szDriver = szDevice; *szDriver && *szDriver != TEXT(','); szDriver++)
        ;
    if (*szDriver)
        *szDriver++ = 0;

    // From the current position in the buffer, null teminate the list of ports
    for (szPort = szDriver; *szPort && *szPort != TEXT(','); szPort++)
        ;
    if (*szPort)
        *szPort++ = 0;

    // if the device, driver and port buffers all contain meaningful data, proceed.
    if (!*szDevice || !*szDriver || !*szPort){
        *szDevice = 0;
        return NULL;
    }

    // Create the printer display context
    if (hInitData){
        // Get a pointer to the initialization data
        lpdevmode = (LPDEVMODE) LocalLock (hInitData);

        if (lstrcmp (szDevice, (LPSTR)lpdevmode)) {
            // User has changed the device... cancel this setup, as it is invalid
            // (although if we worked harder we could retain some of it).
            lpdevmode = NULL;
            LocalUnlock (hInitData);
            LocalFree (hInitData);
            hInitData = NULL;
        }
    }

    if (bInformation)
      hdc = CreateIC (szDriver, szDevice, szPort, lpdevmode);
   else
      hdc = CreateDC (szDriver, szDevice, szPort, lpdevmode);

    // Unlock initialization data
    if (hInitData)
        LocalUnlock (hInitData);

    if (!hdc)
        return NULL;


    iPrinter = 1;

    // Find out if ExtDeviceMode() is supported and set flag appropriately
    if (GetProcAddress (LoadLibrary(szDriver), szExtDeviceMode))
        iPrinter = 2;

    return hdc;

} // GetPrinterDC


/*+-------------------------------------------------------------------------+
  | AbortProc()                                                             |
  |                                                                         |
  |   Checks for user abort.                                                |
  |                                                                         |
  +-------------------------------------------------------------------------+*/
INT APIENTRY AbortProc ( HDC hdc, WORD reserved) {
    MSG msg;

    // Allow other apps to run, or get abort messages
    while (!fAbort && PeekMessage (&msg, NULL, 0, 0, TRUE))
        if (!hwndPDlg || !IsDialogMessage (hwndPDlg, &msg)) {
            TranslateMessage (&msg);
            DispatchMessage  (&msg);
        }

    return !fAbort;

    UNREFERENCED_PARAMETER(hdc);
    UNREFERENCED_PARAMETER(reserved);

} // AbortProc


/*+-------------------------------------------------------------------------+
  | PrintDlgProc()                                                          |
  |                                                                         |
  |    Print/Cancel dialog box.                                             |
  |                                                                         |
  +-------------------------------------------------------------------------+*/
BOOL APIENTRY PrintDlgProc(HWND hwnd, UINT msg, WORD wParam, LONG lParam) {
    switch (msg) {
        case WM_INITDIALOG:
            // Set up information in dialog box
            SetDlgItemText (hwnd, IDD_PRINTTITLE, (LPSTR)szTitle);
            break;

        case WM_COMMAND:
            // abort printing if the only button gets hit
            fAbort = TRUE;
            break;

        default:
            return FALSE;
    }

    return TRUE;

    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
} // PrintDlgProc


/*+-------------------------------------------------------------------------+
  | PrintFile()                                                             |
  |                                                                         |
  |    Prints the contents of the edit control.                             |
  |                                                                         |
  +-------------------------------------------------------------------------+*/
VOID APIENTRY PrintFile(HWND hwnd) {
    HDC     hdc;
    INT     yExtPage;
    CHAR    sz[32];
    int     cch;
    WORD    ich;
    PSTR    pch;
    WORD    iLine;
    WORD    nLinesEc;
    WORD    i;
    HANDLE  hT;
    HWND    hwndPDlg;
    DWORD   dy;
    INT     yExtSoFar;
    WORD    fError = TRUE;
    HWND    hwndEdit;
    HFONT   hFont, hOldFont;

    hwndEdit = (HWND)GetWindowLong(hwnd,GWL_HWNDEDIT);

    // Create the job title by loading the title string from STRINGTABLE
    cch = LoadString (hInst, IDS_PRINTJOB, sz, sizeof(sz));
    szTitle = sz + cch;
    cch += GetWindowText (hwnd, sz + cch, 32 - cch);
    sz[31] = 0;

    // Initialize the printer
    hdc = GetPrinterDC(FALSE);
    if (!hdc)
        goto getout5;

    SetMapMode(hdc, MM_TEXT);
    SelectObject(hdc, GetStockObject(ANSI_FIXED_FONT));

    // Disable the main application window and create the Cancel dialog
    EnableWindow (hwndFrame, FALSE);

    hwndPDlg = CreateDialog (hInst, IDD_PRINT, hwnd, (DLGPROC) PrintDlgProc);

    if (!hwndPDlg)
        goto getout3;

    ShowWindow (hwndPDlg, SW_SHOW);
    UpdateWindow (hwndPDlg);

    // Allow the app. to inform GDI of the escape function to call
    if (Escape(hdc, SETABORTPROC, 0, (LPSTR)AbortProc, NULL) < 0)
        goto getout1;

    // Initialize the document
    if (Escape(hdc, STARTDOC, cch, (LPSTR)sz, NULL) < 0)
        goto getout1;

    // Get the height of one line and the height of a page
    {
    SIZE tmp;
    GetTextExtentPoint(hdc, "CC", 2, &tmp );
    dy = tmp.cy;
    }

    yExtPage = GetDeviceCaps(hdc, VERTRES);

    // Get the lines in document and and a handle to the text buffer
    iLine     = 0;
    yExtSoFar = 0;
    nLinesEc  = (WORD)SendMessage (hwndEdit, EM_GETLINECOUNT, 0, 0L);
    hT        = (HANDLE)SendMessage (hwndEdit, EM_GETHANDLE, 0, 0L);

    // While more lines print out the text
    while (iLine < nLinesEc) {
        if (yExtSoFar + (int) dy > yExtPage) {
            // Reached the end of a page. Tell the device driver to eject a page
            if (Escape(hdc, NEWFRAME, 0, NULL, NULL) < 0 || fAbort)
                goto getout2;
            yExtSoFar = 0;
        }

        // Get the length and position of the line in the buffer and lock from that
        // offset into the buffer.
        ich = (WORD)SendMessage (hwndEdit, EM_LINEINDEX, iLine, 0L);
        cch = (WORD)SendMessage (hwndEdit, EM_LINELENGTH, ich, 0L);
        pch = (PSTR)LocalLock(hT) + ich;

        // Print the line and unlock the text handle
        TextOut (hdc, 0, yExtSoFar, (LPSTR)pch, cch);
        LocalUnlock (hT);

        // Test and see if the Abort flag has been set. If yes, exit.
        if (fAbort)
            goto getout2;

        // Move down the page
        yExtSoFar += dy;
        iLine++;
    }

    // Eject the last page.
    if (Escape(hdc, NEWFRAME, 0, NULL, NULL) < 0)
        goto getout2;

    // Complete the document.
    if (Escape(hdc, ENDDOC, 0, NULL, NULL) < 0) {
getout2:
        // Ran into a problem before NEWFRAME? Abort the document
        Escape( hdc, ABORTDOC, 0, NULL, NULL);
    } else
        fError=FALSE;

getout3:
    // Close the cancel dialog and re-enable main app. window
    EnableWindow (hwndFrame, TRUE);
    DestroyWindow (hwndPDlg);

getout1:
    DeleteDC(hdc);

getout5:
#ifdef WIN16
    // Get rid of dialog procedure instances
    FreeProcInstance (lpfnPDlg);
#endif

#ifdef WIN16
getout4:
    FreeProcInstance (lpfnAbort);
getout:
#endif

    // Error? make sure the user knows...
    if (fError)
        MPError (hwnd, MB_OK | MB_ICONEXCLAMATION, IDS_PRINTERROR, (LPSTR)szTitle);

    return;
        UNREFERENCED_PARAMETER(i);

} // PrintFile


/*+-------------------------------------------------------------------------+
  | GetInitializationData()                                                 |
  |                                                                         |
  |   Gets DC initialization data from a printer driver supporting          |
  |   ExtDeviceMode(). Called in response to the File/Printer setup menu    |
  |   selection.                                                            |
  |                                                                         |
  |   This function allows the user to change the printer settings FOR      |
  |   LOGVIEW ONLY.  This allows LogView to print in a variety of settings  |
  |   without messing up any othe applications.                             |
  |                                                                         |
  +-------------------------------------------------------------------------+*/
BOOL APIENTRY GetInitializationData( HWND hwnd ) {
    LPSTR lpOld;
    LPSTR lpNew;
    FARPROC lpfn;
    HANDLE hT,hDrv;
    CHAR sz[32];
    int cb;
    INT flag;

    // Pop up dialog for user and retain data in app buffer
    flag = DM_PROMPT | DM_COPY;

    // Load the device driver and find the ExtDeviceMode() function
    wsprintf (sz, "%s.drv", (LPSTR)szDriver);
    if (!(hDrv = LoadLibrary (sz)))
        return FALSE;
    if (!(lpfn = (FARPROC) GetProcAddress (hDrv, szExtDeviceMode)))
        return FALSE;

    if (hInitData) {
        // We have some old data... we want to modify the previously specified
        // setup rather than starting with the default setup.
        lpOld = (LPSTR)LocalLock(hInitData);
        flag |= DM_MODIFY;
    }
    else
        lpOld = NULL;

    // Get the number of bytes needed for the init data
    cb = (int) (*lpfn) (hwnd, hDrv, (LPDEVMODE)NULL, (LPSTR)szDevice, (LPSTR)szPort, (LPDEVMODE)NULL, (LPSTR)NULL, 0);

    // Grab some memory for the new data and lock it.
    hT    = LocalAlloc (LHND,cb);
    if(!hT) {
        MessageBox(hwnd, TEXT("<GetInitializationData> Not enough memory."), NULL, MB_OK | MB_ICONHAND);
        LocalUnlock(hInitData);
        LocalFree(hInitData);
        FreeLibrary(hDrv);
        return(FALSE);
    }

    lpNew = (LPSTR)LocalLock (hT);

    // Post the device mode dialog. 0 flag iff user hits OK button
    if ((*lpfn) (hwnd, hDrv, (LPDEVMODE)lpNew, (LPSTR)szDevice, (LPSTR)szPort, (LPDEVMODE)lpOld, (LPSTR)NULL, flag) == IDOK)
        flag = 0;

    // Unlock the input structures
    LocalUnlock (hT);

    if (hInitData)
        LocalUnlock (hInitData);

    // If the user hit OK and everything worked, free the original init.  data and
    // retain the new one.  Otherwise, toss the new buffer.
    if (flag)
        LocalFree (hT);
    else {
        if (hInitData)
            LocalFree (hInitData);

        hInitData = hT;
    }

    FreeLibrary(hDrv);
    return (!flag);

} // GetInitializationData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\logview\logview.c ===
/*++

Copyright (c) 1993-1995  Microsoft Corporation

Module Name:

   LogView.C

Abstract:


Author:

    Arthur Hanson (arth) 27-Jul-1993

Revision History:

--*/

#include "LogView.h"
#include <string.h>
#include <stdio.h>
//#include <dos.h>
//#include <direct.h>
#include <shellapi.h>

// global variables used in this module or among more than one module
HANDLE hInst;
HANDLE hAccel;
HWND hwndFrame = NULL;
HWND hwndMDIClient = NULL;
HWND hwndActive = NULL;
HWND hwndActiveEdit = NULL;
HWND hDlgFind = NULL;
LPSTR lpMenu = IDLOGVIEW;
TCHAR szAppName[] = "LogView";

FINDREPLACE FR;
PRINTDLG PD;
UINT wFRMsg;
UINT wHlpMsg;
BOOL fReverse = FALSE;      // Flag for direction of search
TCHAR szSearch[CCHKEYMAX];       // Search String

HANDLE   hStdCursor;                 // handle to arrow or beam cursor
HANDLE   hWaitCursor;                // handle to hour glass cursor

void FAR Search (TCHAR * szKey);


// Forward declarations of helper functions in this module 
VOID NEAR PASCAL InitializeMenu (HANDLE);
VOID NEAR PASCAL CommandHandler (HWND, UINT, LONG);
LPSTR GetCmdLine( VOID );
BOOL CenterWindow( HWND hwndChild, HWND hwndParent );

#define HELP_FILE TEXT("logview.hlp")

/////////////////////////////////////////////////////////////////////////
int PASCAL 
WinMain(
   HINSTANCE hInstance, 
   HINSTANCE hPrevInstance, 
   LPSTR lpCmdLine, 
   int nCmdShow
   )

/*++

Routine Description:

    Creates the "frame" window, does some initialization and enters the
    message loop.

Arguments:


Return Value:


--*/

{
    MSG msg;

    hInst = hInstance;

    // If this is the first instance of the app. register window classes
    if (!hPrevInstance){
        if (!InitializeApplication ())
            return 0;
    }

    lpCmdLine = GetCmdLine();

    // Create the frame and do other initialization
    if (!InitializeInstance (lpCmdLine, nCmdShow))
        return 0;

    while (GetMessage (&msg, NULL, 0, 0)){
        // If a keyboard message is for the MDI , let the MDI client take care of it.
        // Otherwise, check to see if it's a normal accelerator key (like F3 = find next).
        // Otherwise, just handle the message as usual.
        if (!hDlgFind || !IsDialogMessage(hDlgFind, &msg)) {
           if ( !TranslateMDISysAccel (hwndMDIClient, &msg) &&
                !TranslateAccelerator (hwndFrame, hAccel, &msg)) {
               TranslateMessage (&msg);
               DispatchMessage (&msg);
           }
        }
    }
    
    return 0;
    
} // WinMain


/////////////////////////////////////////////////////////////////////////
LRESULT APIENTRY 
MPFrameWndProc ( 
   HWND hwnd, 
   UINT msg, 
   UINT wParam, 
   LONG lParam
   )

/*++

Routine Description:

   The window function for the "frame" window, which controls the menu
   and encompasses all the MDI child windows.

Arguments:


Return Value:


--*/

{
   LPFINDREPLACE lpfr;
   DWORD dwFlags;

   switch (msg) {
      case WM_CREATE: {

         CLIENTCREATESTRUCT ccs;
         HDC hdc;

         // Find window menu where children will be listed
         ccs.hWindowMenu = GetSubMenu (GetMenu(hwnd), WINDOWMENU);
         ccs.idFirstChild = IDM_WINDOWCHILD;

         // Create the MDI client filling the client area
         hwndMDIClient = CreateWindow ("mdiclient", NULL,
                                       WS_CHILD | WS_CLIPCHILDREN | WS_VSCROLL | WS_HSCROLL,
                                       0, 0, 0, 0, hwnd, (HMENU) 0xCAC, hInst, (LPSTR) &ccs);

         ShowWindow (hwndMDIClient,SW_SHOW);

         // Check if printer can be initialized
         if (hdc = GetPrinterDC (TRUE)) {
            DeleteDC (hdc);
         }

         break;
      }

      case WM_INITMENU:
         // Set up the menu state
         InitializeMenu ((HMENU)wParam);
         break;

      case WM_WININICHANGE:
      case WM_DEVMODECHANGE:{

         //  If control panel changes default printer characteristics, reinitialize our
         //  printer information...
         HDC hdc;

         if (hdc = GetPrinterDC (TRUE))
            DeleteDC (hdc);
         
         break;
      }

      case WM_COMMAND:
         // Direct all menu selection or accelerator commands to another function
         CommandHandler(hwnd, wParam, lParam);
         break;

      case WM_CLOSE:
         DestroyWindow (hwnd);
         break;

      case WM_DESTROY:
         PostQuitMessage (0);
         break;

      default:
         if (msg == wFRMsg)
          {
             lpfr = (LPFINDREPLACE)lParam;
             dwFlags = lpfr->Flags;

             fReverse = (dwFlags & FR_DOWN      ? FALSE : TRUE);
             fCase    = (dwFlags & FR_MATCHCASE ? TRUE  : FALSE);

             if (dwFlags & FR_FINDNEXT)
                 Search (szSearch);
             else if (dwFlags & FR_DIALOGTERM)
                 hDlgFind = NULL;   /* invalidate modeless window handle */
             break;
         }

         //  use DefFrameProc() instead of DefWindowProc() since there are things
         //  that have to be handled differently because of MDI
         return DefFrameProc (hwnd,hwndMDIClient,msg,wParam,lParam);
   }
    
   return 0;
    
} // MPFrameWndProc


/////////////////////////////////////////////////////////////////////////
LRESULT APIENTRY 
MPMDIChildWndProc ( 
   HWND hwnd, 
   UINT msg, 
   UINT wParam, 
   LONG lParam
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   HWND hwndEdit;
   HFONT hFont;
   LRESULT ret;
    
   switch (msg) {
      case WM_CREATE:
         hwndEdit = CreateWindow ("edit", NULL,
                                    WS_CHILD | WS_HSCROLL | WS_MAXIMIZE | WS_VISIBLE | 
                                    WS_VSCROLL | ES_AUTOHSCROLL | ES_AUTOVSCROLL | 
                                    ES_MULTILINE | ES_READONLY | ES_NOHIDESEL,
                                    0, 0, 0, 0,
                                    hwnd, (HMENU) ID_EDIT, hInst, NULL);

         // Remember the window handle and initialize some window attributes
         SetWindowLongPtr (hwnd, GWL_HWNDEDIT, (LONG_PTR) hwndEdit);
         SetWindowWord (hwnd, GWW_CHANGED, FALSE);
         SetWindowWord (hwnd, GWL_WORDWRAP, FALSE);
         SetWindowWord (hwnd, GWW_UNTITLED, TRUE);
            
         hFont = GetStockObject(SYSTEM_FIXED_FONT);
         ret = SendMessage(hwndEdit, WM_SETFONT, (WPARAM) hFont, (LPARAM) MAKELONG((WORD) TRUE, 0));
            
         SetFocus (hwndEdit);
         break;

      case WM_MDIACTIVATE:
            // If we're activating this child, remember it
            if (GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wParam, lParam)) {
                hwndActive     = hwnd;
                hwndActiveEdit = (HWND)GetWindowLong (hwnd, GWL_HWNDEDIT);
            }
            else {
                hwndActive     = NULL;
                hwndActiveEdit = NULL;
            }
            break;

        case WM_CLOSE:
            goto CallDCP;

        case WM_SIZE:{
            RECT rc;

            // On creation or resize, size the edit control.
            hwndEdit = (HWND)GetWindowLong (hwnd, GWL_HWNDEDIT);
            GetClientRect (hwnd, &rc);
            MoveWindow (hwndEdit,
                        rc.left,
                        rc.top,
                        rc.right-rc.left,
                        rc.bottom-rc.top,
                        TRUE);
            goto CallDCP;
        }

        case WM_SETFOCUS:
            SetFocus ((HWND)GetWindowLong (hwnd, GWL_HWNDEDIT));
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)){
                case ID_EDIT:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam)) {
                    
                        case EN_ERRSPACE:
                            // If the control is out of space, beep
                            MessageBeep (0);
                            break;

                        default:
                            goto CallDCP;
                    }
                    break;

                default:
                  goto CallDCP;
            }
            break;

        default:
CallDCP:
            return DefMDIChildProc (hwnd, msg, wParam, lParam);
    }
    return FALSE;
    
} // MPMDIChildWndProc


/////////////////////////////////////////////////////////////////////////
VOID NEAR PASCAL 
InitializeMenu (
   register HANDLE hmenu
   )

/*++

Routine Description:

   Sets up greying, enabling and checking of main menu items.

Arguments:


Return Value:


--*/

{
   WORD status;
   WORD i;
   INT j;

   // Is there any active child to talk to?
   if (hwndActiveEdit) {
   
        // Set the word wrap state for the window
        if ((WORD) SendMessage(hwndActive, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_EDITWRAP, 0, 0)))
            status = MF_CHECKED;
        else
            status = MF_UNCHECKED;
            
        CheckMenuItem (hmenu, IDM_EDITWRAP, status);

        // Enable search menu items only if there is a search string
        if (*szSearch)
            status = MF_ENABLED;
        else
            status = MF_GRAYED;
            
        EnableMenuItem (hmenu, IDM_SEARCHNEXT, status);
        EnableMenuItem (hmenu, IDM_SEARCHPREV, status);

        // Enable File/Print only if a printer is available
        status = (WORD) (iPrinter ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem (hmenu, IDM_FILEPRINT, status);

        // select all and wrap toggle always enabled
        status = MF_ENABLED;
        EnableMenuItem(hmenu, IDM_EDITSELECT, status);
        EnableMenuItem(hmenu, IDM_EDITWRAP, status);
        EnableMenuItem(hmenu, IDM_SEARCHFIND, status);
    } else {
        // There are no active child windows
        status = MF_GRAYED;

        // No active window, so disable everything
        for (i = IDM_EDITFIRST; i <= IDM_EDITLAST; i++)
            EnableMenuItem (hmenu, i, status);

        CheckMenuItem (hmenu, IDM_EDITWRAP, MF_UNCHECKED);

        for (i = IDM_SEARCHFIRST; i <= IDM_SEARCHLAST; i++)
            EnableMenuItem (hmenu, i, status);

        EnableMenuItem (hmenu, IDM_FILEPRINT, status);

    }

    // The following menu items are enabled if there is an active window
    EnableMenuItem (hmenu, IDM_WINDOWTILE, status);
    EnableMenuItem (hmenu, IDM_WINDOWCASCADE, status);
    EnableMenuItem (hmenu, IDM_WINDOWICONS, status);
    EnableMenuItem (hmenu, IDM_WINDOWCLOSEALL, status);

    // Allow printer setup only if printer driver supports device initialization
    if (iPrinter < 2)
        status = MF_GRAYED;
        
   EnableMenuItem ( hmenu, IDM_FILESETUP, status);
   UNREFERENCED_PARAMETER(j);

} // InitializeMenu


/////////////////////////////////////////////////////////////////////////
VOID NEAR PASCAL 
CloseAllChildren ()

/*++

Routine Description:

    Destroys all MDI child windows.

Arguments:


Return Value:


--*/

{
    register HWND hwndT;

    // hide the MDI client window to avoid multiple repaints
    ShowWindow(hwndMDIClient,SW_HIDE);

    // As long as the MDI client has a child, destroy it
    while ( hwndT = GetWindow (hwndMDIClient, GW_CHILD)){

        // Skip the icon title windows
        while (hwndT && GetWindow (hwndT, GW_OWNER))
            hwndT = GetWindow (hwndT, GW_HWNDNEXT);

        if (!hwndT)
            break;

        SendMessage (hwndMDIClient, WM_MDIDESTROY, (UINT_PTR)hwndT, 0L);
    }
    
} // CloseAllChildren


/////////////////////////////////////////////////////////////////////////
VOID NEAR PASCAL 
CommandHandler ( 
   HWND hwnd, 
   UINT wParam, 
   LONG lParam
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   DLGPROC lpfnDlg;
   
    switch (LOWORD(wParam)){
        case IDM_FILENEW:
            // Add a new, empty MDI child
            AddFile (NULL);
            break;

        case IDM_FILEOPEN:
            MyReadFile (hwnd);
            break;

        case IDM_FILEPRINT:
            // Print the active child MDI
            PrintFile (hwndActive);
            break;

        case IDM_FILESETUP:
            // Set up the printer environment for this app
            GetInitializationData (hwnd);
            break;

        case IDM_FILEMENU: {
              // lengthen / shorten the size of the MDI menu
              HMENU hMenu;
              HMENU hWindowMenu;
              INT i;

              if (lpMenu == IDLOGVIEW) {
                  lpMenu = IDLOGVIEW2;
                  i      = SHORTMENU;
              }
              else {
                  lpMenu = IDLOGVIEW;
                  i      = WINDOWMENU;
              }

              hMenu = LoadMenu (hInst, lpMenu);
              hWindowMenu = GetSubMenu (hMenu, i);

              // Set the new menu
              hMenu = (HMENU)SendMessage (hwndMDIClient,
                                          WM_MDISETMENU,
                                          (UINT_PTR)hMenu,
                                          (LONG_PTR)hWindowMenu);

              DestroyMenu (hMenu);
              DrawMenuBar (hwndFrame);
              break;
        }

        case IDM_FILEEXIT:
            // Close LogView
            SendMessage (hwnd, WM_CLOSE, 0, 0L);
            break;

        case IDM_HELPABOUT:
            // Just let the shell display the about box...
            ShellAbout(hwnd, szAppName, szAppName, LoadIcon(hInst, IDLOGVIEW));
            break;

        // The following are edit commands. Pass these off to the active child'd edit
        // control window.
        case IDM_EDITWRAP:
            SendMessage(hwndActive, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_EDITWRAP, 1, 0));
            break;

        case IDM_SEARCHPREV:
            if (szSearch[0]) {
               fReverse = TRUE;
               Search(szSearch);
               break;
            }
            // else fall through and bring up find dialog

        case IDM_SEARCHNEXT:
            if (szSearch[0]) {
               fReverse = FALSE;
               Search(szSearch);
               break;
            }
            // else fall through and bring up find dialog

        case IDM_SEARCHFIND:
            if (hDlgFind)
               SetFocus(hDlgFind);
            else {
               FR.lpstrFindWhat = szSearch;
               FR.wFindWhatLen  = CCHKEYMAX;
               hDlgFind = FindText((LPFINDREPLACE)&FR);
            }

            break;

        // The following are window commands - these are handled by the MDI Client.
        case IDM_WINDOWTILE:
            // Tile MDI windows
            SendMessage (hwndMDIClient, WM_MDITILE, 0, 0L);
            break;

        case IDM_WINDOWCASCADE:
            // Cascade MDI windows
            SendMessage (hwndMDIClient, WM_MDICASCADE, 0, 0L);
            break;

        case IDM_WINDOWICONS:
            // Auto - arrange MDI icons
            SendMessage (hwndMDIClient, WM_MDIICONARRANGE, 0, 0L);
            break;

        case IDM_WINDOWCLOSEALL:
            CloseAllChildren();

            // Show the window since CloseAllChilren() hides the window for fewer repaints
            ShowWindow( hwndMDIClient, SW_SHOW);
            break;

         case ID_HELP_CONT:
            WinHelp(hwnd, HELP_FILE, HELP_CONTENTS, 0L);
            break;

         case ID_HELP_INDEX:
            WinHelp(hwnd, HELP_FILE, HELP_PARTIALKEY, 0L);
            break;

         case ID_HELP_USING:
            WinHelp(hwnd, HELP_FILE, HELP_HELPONHELP, 0L);
            break;

        default:
           // This is essential, since there are frame WM_COMMANDS generated by the MDI
           // system for activating child windows via the window menu.
           DefFrameProc(hwnd, hwndMDIClient, WM_COMMAND, wParam, lParam);
    }
    
} // CommandHandler


/////////////////////////////////////////////////////////////////////////
SHORT 
MPError( 
   HWND hwnd, 
   WORD bFlags, 
   WORD id, 
   char *psz 
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    CHAR sz[160];
    CHAR szFmt[128];

    LoadString (hInst, id, szFmt, sizeof (szFmt));
    sprintf (sz, szFmt, psz );
    LoadString (hInst, (WORD)IDS_APPNAME, (LPSTR)szFmt, sizeof (szFmt));
    return( (SHORT)MessageBox (hwndFrame, sz, szFmt, bFlags));

    UNREFERENCED_PARAMETER(hwnd);
} // MPError


/////////////////////////////////////////////////////////////////////////
LPSTR 
GetCmdLine( 
   VOID
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    LPSTR lpCmdLine, lpT;

    lpCmdLine = GetCommandLine();
        
    // on Win32, lpCmdLine's first string includes its own name, remove this
    if (*lpCmdLine) {
        lpT = strchr(lpCmdLine, ' ');     // skip self name
        
        if (lpT) {
            lpCmdLine = lpT;
            
            while (*lpCmdLine == ' ') {
                lpCmdLine++;              // skip spaces to end or first cmd
            }
            
        } else {
            lpCmdLine += strlen(lpCmdLine);  // point to NULL
        }
    }
    return(lpCmdLine);
    
} // GetCmdLine


#define CY_SHADOW   4
#define CX_SHADOW   4

/////////////////////////////////////////////////////////////////////////
BOOL 
CenterWindow( 
   HWND hwndChild, 
   HWND hwndParent
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   RECT    rChild, rParent;
   int     wChild, hChild, wParent, hParent;
   int     wScreen, hScreen, xNew, yNew;
   HDC     hdc;

   // Get the Height and Width of the child window
   GetWindowRect (hwndChild, &rChild);
   wChild = rChild.right - rChild.left;
   hChild = rChild.bottom - rChild.top;

   // Get the Height and Width of the parent window
   GetWindowRect (hwndParent, &rParent);
   wParent = rParent.right - rParent.left;
   hParent = rParent.bottom - rParent.top;

   // Get the display limits
   hdc = GetDC (hwndChild);
   wScreen = GetDeviceCaps (hdc, HORZRES);
   hScreen = GetDeviceCaps (hdc, VERTRES);
   ReleaseDC (hwndChild, hdc);

   // Calculate new X position, then adjust for screen
   xNew = rParent.left + ((wParent - wChild) /2);
   if (xNew < 0)
      xNew = 0;
   else if ((xNew+wChild) > wScreen)
      xNew = wScreen - wChild;

   // Calculate new Y position, then adjust for screen
   yNew = rParent.top  + ((hParent - hChild) /2);
   if (yNew < 0)
      yNew = 0;
   else if ((yNew+hChild) > hScreen)
      yNew = hScreen - hChild;

   // Set it, and return
   return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);

} // CenterWindow
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\columnlb.h ===
// ==================================================================
//      Copyright 1990-1993 Microsoft corporation
//          all rights reservered
// ==================================================================
//
//  MODULE: COLUMNLB.H
//  PURPOSE: Definitions of all external procedure prototypes for custom
// window class ColumnLB
//
//  ------ TABSTOP = 4 -------------------
//
// HISTORY
// -------
// Tom Laird-McConnell    5/1/93      Created
// ==================================================================

#ifndef _COLUMNLB_
#define _COLUMNLB_

#ifdef __cplusplus
extern "C"{
#endif

//
// CONTROL STYLES
//
#define CLBS_NOTIFYLMOUSE   0x0200L         // pass on WM_LMOUSE messages to perent
#define CLBS_NOTIFYRMOUSE   0x0800L         // pass on WM_RMOUSE messages to parent

//
// CONTROL MESSAGES
//

#define CLB_BASE            (WM_USER+4000)

#define CLB_MSGMIN          (CLB_BASE)

#define CLB_GETNUMBERCOLS   (CLB_BASE+0)    // get the number of columns (ret=NumCols)
#define CLB_SETNUMBERCOLS   (CLB_BASE+1)    // set the number of columns (wparam=NumCols)

#define CLB_GETCOLWIDTH     (CLB_BASE+2)    // get a column width   (wParm=Column ret=ColWidth in DU's)
#define CLB_SETCOLWIDTH     (CLB_BASE+3)    // set a column width   (wParm=Column lParam=Width)

#define CLB_GETCOLTITLE     (CLB_BASE+4)    // get a column's title (wParm=Column, ret=Title)
#define CLB_SETCOLTITLE     (CLB_BASE+5)    // set a column's title (wParm=Col, lParm=Title)

#define CLB_GETSORTCOL      (CLB_BASE+6)    // get the sort column (ret=Col)
#define CLB_SETSORTCOL      (CLB_BASE+7)    // set the sort column (wParm=Col)

#define CLB_AUTOWIDTH       (CLB_BASE+8)    // auto-matically set column widths using titles...

#define CLB_GETCOLOFFSETS   (CLB_BASE+9)    // gets the incremental col offsets (ret=LPINT array)
#define CLB_SETCOLOFFSETS   (CLB_BASE+10)

#define CLB_GETCOLORDER     (CLB_BASE+11)    // get the order that columns should be displayed(ret=LPBYTE table)
#define CLB_SETCOLORDER     (CLB_BASE+12)    // set the order that columns should be displayed(LParm=LPBYTE TABLE)

#define CLB_HSCROLL         (CLB_BASE+13)    // a hscroll event (INTERNAL)

#define CLB_GETFOCUS        (CLB_BASE+14)    // get the primary key focus window of CLB

#define CLB_GETROWCOLTEXT   (CLB_BASE+15)    // given a row AND a column, give me the text for the physical column.

#define CLB_GETTEXTPTRS     (CLB_BASE+16)    // just like gettext, but it give the array of pointers to the strings.

#define CLB_CHECKFOCUS      (CLB_BASE+17)    // Does this listbox have the focus?

/*
 * Listbox messages (Defined as CLB_BASE+0+LB_ADDSTRING...to get original LB_ message, just take msg-CLB_BASE to get LB_
 */

#define CLB_LISTBOX_MSGMIN       (CLB_MSGMIN+LB_ADDSTRING         )

#define CLB_ADDSTRING            (CLB_MSGMIN+LB_ADDSTRING         ) 
#define CLB_INSERTSTRING         (CLB_MSGMIN+LB_INSERTSTRING      ) 
#define CLB_DELETESTRING         (CLB_MSGMIN+LB_DELETESTRING      ) 
#define CLB_SELITEMRANGEEX       (CLB_MSGMIN+LB_SELITEMRANGEEX    ) 
#define CLB_RESETCONTENT         (CLB_MSGMIN+LB_RESETCONTENT      ) 
#define CLB_SETSEL               (CLB_MSGMIN+LB_SETSEL            ) 
#define CLB_SETCURSEL            (CLB_MSGMIN+LB_SETCURSEL         ) 
#define CLB_GETSEL               (CLB_MSGMIN+LB_GETSEL            ) 
#define CLB_GETCURSEL            (CLB_MSGMIN+LB_GETCURSEL         ) 
#define CLB_GETTEXT              (CLB_MSGMIN+LB_GETTEXT           ) 
#define CLB_GETTEXTLEN           (CLB_MSGMIN+LB_GETTEXTLEN        ) 
#define CLB_GETCOUNT             (CLB_MSGMIN+LB_GETCOUNT          ) 
#define CLB_SELECTSTRING         (CLB_MSGMIN+LB_SELECTSTRING      ) 
#define CLB_DIR                  (CLB_MSGMIN+LB_DIR               ) 
#define CLB_GETTOPINDEX          (CLB_MSGMIN+LB_GETTOPINDEX       ) 
#define CLB_FINDSTRING           (CLB_MSGMIN+LB_FINDSTRING        ) 
#define CLB_GETSELCOUNT          (CLB_MSGMIN+LB_GETSELCOUNT       ) 
#define CLB_GETSELITEMS          (CLB_MSGMIN+LB_GETSELITEMS       ) 
#define CLB_SETTABSTOPS          (CLB_MSGMIN+LB_SETTABSTOPS       ) 
#define CLB_GETHORIZONTALEXTENT  (CLB_MSGMIN+LB_GETHORIZONTALEXTENT)
#define CLB_SETHORIZONTALEXTENT  (CLB_MSGMIN+LB_SETHORIZONTALEXTENT)
#define CLB_SETCOLUMNWIDTH       (CLB_MSGMIN+LB_SETCOLUMNWIDTH    ) 
#define CLB_ADDFILE              (CLB_MSGMIN+LB_ADDFILE           ) 
#define CLB_SETTOPINDEX          (CLB_MSGMIN+LB_SETTOPINDEX       ) 
#define CLB_GETITEMRECT          (CLB_MSGMIN+LB_GETITEMRECT       ) 
#define CLB_GETITEMDATA          (CLB_MSGMIN+LB_GETITEMDATA       ) 
#define CLB_SETITEMDATA          (CLB_MSGMIN+LB_SETITEMDATA       ) 
#define CLB_SELITEMRANGE         (CLB_MSGMIN+LB_SELITEMRANGE      ) 
#define CLB_SETANCHORINDEX       (CLB_MSGMIN+LB_SETANCHORINDEX    ) 
#define CLB_GETANCHORINDEX       (CLB_MSGMIN+LB_GETANCHORINDEX    ) 
#define CLB_SETCARETINDEX        (CLB_MSGMIN+LB_SETCARETINDEX     ) 
#define CLB_GETCARETINDEX        (CLB_MSGMIN+LB_GETCARETINDEX     ) 
#define CLB_SETITEMHEIGHT        (CLB_MSGMIN+LB_SETITEMHEIGHT     ) 
#define CLB_GETITEMHEIGHT        (CLB_MSGMIN+LB_GETITEMHEIGHT     ) 
#define CLB_FINDSTRINGEXACT      (CLB_MSGMIN+LB_FINDSTRINGEXACT   ) 
#define CLB_SETLOCALE            (CLB_MSGMIN+LB_SETLOCALE         ) 
#define CLB_GETLOCALE            (CLB_MSGMIN+LB_GETLOCALE         ) 
#define CLB_SETCOUNT             (CLB_MSGMIN+LB_SETCOUNT          ) 
                                                                  
#define CLB_LISTBOX_MSGMAX       CLB_SETCOUNT

#define CLB_MSGMAX               CLB_LISTBOX_MSGMAX


//
// NOTIFICATION MESSAGES
//
#define CLBN_MSGMIN         (CLB_MSGMAX + 1)

#define CLBN_DRAWITEM       CLBN_MSGMIN       // ask the parent to do a XXXXitem lParam = LPDRAWITEMSTRUCT)
//#define CLBN_COMPAREITEM    CLBN_MSGMIN+2)   // ask the parent to do a XXXXitem (wParam=PhysCol, lParam = LPCOMPAREITEMSTRUCT)
#define CLBN_CHARTOITEM     (CLBN_MSGMIN+3)     // ask the parent to do a XXXXitem (wParam=PhysCol,                          )

#define CLBN_TITLESINGLECLK (CLBN_MSGMIN+4)     // notify the parent that a user clicked on a title (wParam = CTLID, lParam=Col)
#define CLBN_TITLEDBLCLK    (CLBN_MSGMIN+5)     // notify the parent that a user double-clicked on a title (wParam = CTLID, lParam=Col)

#define CLBN_COLREORDER     (CLBN_MSGMIN+6)     // notify the parent that someone changed the column order (LPARAM=LPINT order)
#define CLBN_COLSIZE        (CLBN_MSGMIN+7)     // notify the parent that someone changed the column size (lParam=LPINT widths)
#define CLBN_RBUTTONDOWN    (CLBN_MSGMIN+8)     // notify the parent on rbutton which row and column
#define CLBN_RBUTTONUP      (CLBN_MSGMIN+9)     // notify the parent on rbutton which row and column

#define CLBN_MSGMAX         CLBN_RBUTTONUP  


#define MAX_COLUMNS 32


//
// structure used to keep track of column info
//
typedef struct _ColumnInfo
{
    int     Width;      // width in LU's of column
    LPTSTR  lpTitle;    // pointer to title string
    BOOL    fDepressed; // flag for whether this columns header button is depressed or not
} COLUMNINFO;
typedef COLUMNINFO *LPCOLUMNINFO;


//
// structure used for doing a Column DrawItem
//
typedef struct _CLBDrawItemStruct
{
    DRAWITEMSTRUCT  DrawItemStruct;
    LPBYTE          lpColOrder;
    DWORD           nColumns;
    RECT            rect[MAX_COLUMNS];
} CLBDRAWITEMSTRUCT;
typedef CLBDRAWITEMSTRUCT *LPCLBDRAWITEMSTRUCT;

#define MOUSE_COLUMNDRAG     1
#define MOUSE_COLUMNRESIZE   2
#define MOUSE_COLUMNCLICK    3

//
// internal datastructure used to keep track of everything internal to the
// ColumnLB class...
//
typedef struct _ColumnLBstruct
{
    DWORD       Style;                          // style of columnlb
    
    HWND        hwndList;                       // handle to the internal listbox
    HWND        hwndTitleList;                  // handle to title listbox
    
    HFONT       hFont;                          // font in use...
    
    HINSTANCE   hInstance;                      // hInstance of the app which created this

    BYTE        nColumns;                       // number of columns in the column listbox
    COLUMNINFO  ColumnInfoTable[MAX_COLUMNS];   // table of ColumnInfoStructures
    int         ColumnOffsetTable[MAX_COLUMNS]; // table of offsets from front of listbox (in lu's)
    BYTE        ColumnOrderTable[MAX_COLUMNS];  // indexes of columns in order of display
    BYTE        SortColumn;                     // index of current sort column

    int         xPos;                           // current x position in scroll-box
    int         yTitle;                         // height of title portion...

    FARPROC     OldListboxProc;                 // old listbox proc
    FARPROC     NewListboxProc;                 // New listbox proc

    FARPROC     OldTitleListboxProc;            // old listbox proc
    FARPROC     NewTitleListboxProc;            // New listbox proc

    BYTE        fUseVlist:1;                    // flag for whether to use VLIST class or not...
    BYTE        fMouseState:3;                  // state for moving
    BYTE        fSorting:1;                     // flag to signifiy that we are sorting so ignore DELETEITEM's
    BYTE        fHasFocus:1;                    // does the listbox have the focus?
    
    int         xPrevPos   ;                    // previous x mouse position
    BYTE        ColClickStart;                  // column of click start
    RECT        ColClickRect;                   // rect of click column
} COLUMNLBSTRUCT;
typedef COLUMNLBSTRUCT FAR *LPCOLUMNLBSTRUCT;

#define COLUMNLBCLASS_CLASSNAME TEXT("ColumnListBox")        // normal Column listbox
#define COLUMNVLBCLASS_CLASSNAME TEXT("ColumnVListBox")      // Vlist Column box

//
// structure used for RBUTTONDOWN messages.  The Column list box tells the parent
// which column and index.
//
typedef struct _CLBRButtonStruct
{
    HWND    hwndChild;
    BYTE    PhysColumn;
    DWORD_PTR   Index;
    int     x;
    int     y;
} CLBRBUTTONSTRUCT;

typedef CLBRBUTTONSTRUCT *LPCLBRBUTTONSTRUCT;


//
// function prototypes
//
BOOL ColumnLBClass_Register(HINSTANCE hInstance);
BOOL ColumnVLBClass_Register(HINSTANCE hInstance);
BOOL ColumnLBClass_Unregister(HINSTANCE hInstance);
BOOL ColumnVLBClass_Unregister(HINSTANCE hInstance);

void ColumnLB_DrawColumnBorder(HDC hdc, RECT *rect, int Bottom, HBRUSH hBrush);

// -----------------------------------------------------------------------------------
//
// ColumnListBox_ Macros (uses CLB_ messages) New definitions
//
#define ColumnLB_GetNumberCols(hwndCtl)             ((int)(DWORD)SendMessage((hwndCtl), CLB_GETNUMBERCOLS, 0L, (LPARAM)0))
#define ColumnLB_SetNumberCols(hwndCtl,Number)      ((int)(DWORD)SendMessage((hwndCtl), CLB_SETNUMBERCOLS, (WPARAM)Number, (LPARAM)0))
#define ColumnLB_GetColWidth(hwndCtl,Column)        ((int)(DWORD)SendMessage((hwndCtl), CLB_GETCOLWIDTH, (WPARAM)Column, (LPARAM)0))
#define ColumnLB_SetColWidth(hwndCtl,Column, Width) ((int)(DWORD)SendMessage((hwndCtl), CLB_SETCOLWIDTH, (WPARAM)Column, (LPARAM)Width))
#define ColumnLB_GetColTitle(hwndCtl,Column)        ((LPTSTR)(DWORD)SendMessage((hwndCtl), CLB_GETCOLTITLE, (WPARAM)Column, (LPARAM)0))
#define ColumnLB_SetColTitle(hwndCtl,Column, Title) ((LPTSTR)(DWORD)SendMessage((hwndCtl), CLB_SETCOLTITLE, (WPARAM)Column, (LPARAM)Title))
#define ColumnLB_GetSortCol(hwndCtl)                ((DWORD)SendMessage((hwndCtl), CLB_GETSORTCOL, (WPARAM)0, (LPARAM)0))
#define ColumnLB_SetSortCol(hwndCtl,Column)         ((int)(DWORD)SendMessage((hwndCtl), CLB_SETSORTCOL, (WPARAM)Column, (LPARAM)0))
#define ColumnLB_AutoWidth(hwndCtl, Width)          ((int)(DWORD)SendMessage((hwndCtl), CLB_AUTOWIDTH, (WPARAM)Width, (LPARAM)0))
#define ColumnLB_GetColOffsets(hwndCtl)             ((LPINT)(DWORD)SendMessage((hwndCtl), CLB_GETCOLOFFSETS, (WPARAM)0, (LPARAM)0))
#define ColumnLB_SetColOffsets(hwndCtl,Offsets)     ((int)(DWORD)SendMessage((hwndCtl), CLB_SETCOLOFFSETS, (WPARAM)Offsets, (LPARAM)0))
#define ColumnLB_GetColOrder(hwndCtl)               ((LPBYTE)(DWORD)SendMessage((hwndCtl), CLB_GETCOLORDER, (WPARAM)0, (LPARAM)0))
#define ColumnLB_SetColOrder(hwndCtl, Order)        ((LPBYTE)(DWORD)SendMessage((hwndCtl), CLB_SETCOLORDER, (WPARAM)0, (LPARAM)Order))
#define ColumnLB_CheckFocus(hwndCtl)                ((BOOL)(DWORD)SendMessage((hwndCtl), CLB_CHECKFOCUS, (WPARAM)0, (LPARAM)0))

// -----------------------------------------------------------------------------------              
//
// ColumnListBox_ Macros (uses CLB_ messages) Listbox definitions
//
#define ColumnLB_Enable(hwndCtl, fEnable)            EnableWindow((hwndCtl), (fEnable))

#define ColumnLB_GetCount(hwndCtl)                   ((int)(DWORD)SendMessage((hwndCtl), CLB_GETCOUNT, 0L, 0L))
#define ColumnLB_ResetContent(hwndCtl)               ((BOOL)(DWORD)SendMessage((hwndCtl), CLB_RESETCONTENT, 0L, 0L))

#define ColumnLB_AddString(hwndCtl, lpsz)            ((int)(DWORD)SendMessage((hwndCtl), CLB_ADDSTRING, 0L, (LPARAM)(LPCTSTR)(lpsz)))
#define ColumnLB_InsertString(hwndCtl, index, lpsz)  ((int)(DWORD)SendMessage((hwndCtl), CLB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(LPCTSTR)(lpsz)))

#define ColumnLB_AddItemData(hwndCtl, data)          ((int)(DWORD)SendMessage((hwndCtl), CLB_ADDSTRING, 0L, (LPARAM)(data)))
#define ColumnLB_InsertItemData(hwndCtl, index, data) ((int)(DWORD)SendMessage((hwndCtl), CLB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(data)))

#define ColumnLB_DeleteString(hwndCtl, index)        ((int)(DWORD)SendMessage((hwndCtl), CLB_DELETESTRING, (WPARAM)(int)(index), 0L))

#define ColumnLB_GetTextLen(hwndCtl, index)          ((int)(DWORD)SendMessage((hwndCtl), CLB_GETTEXTLEN, (WPARAM)(int)(index), 0L))
#define ColumnLB_GetText(hwndCtl, index, lpszBuffer)  ((int)(DWORD)SendMessage((hwndCtl), CLB_GETTEXT, (WPARAM)(int)(index), (LPARAM)(LPCTSTR)(lpszBuffer)))
#define ColumnLB_GetTextPtrs(hwndCtl, index)        ((LPTSTR *)(DWORD)SendMessage((hwndCtl), CLB_GETTEXTPTRS, (WPARAM)(int)(index), (LPARAM)0))
#define ColumnLB_GetRowColText(hwndCtl, index, col)  (LPBYTE)(DWORD)SendMessage((hwndCtl), CLB_GETROWCOLTEXT, (WPARAM)(int) (col), (LPARAM)(int)(index))

#define ColumnLB_GetItemData(hwndCtl, index)         ((LRESULT)(DWORD)SendMessage((hwndCtl), CLB_GETITEMDATA, (WPARAM)(int)(index), 0L))
#define ColumnLB_SetItemData(hwndCtl, index, data)   ((int)(DWORD)SendMessage((hwndCtl), CLB_SETITEMDATA, (WPARAM)(int)(index), (LPARAM)(data)))

#if (WINVER >= 0x030a)
#define ColumnLB_FindString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), CLB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCTSTR)(lpszFind)))
#define ColumnLB_FindItemData(hwndCtl, indexStart, data) ((int)(DWORD)SendMessage((hwndCtl), CLB_FINDSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ColumnLB_SetSel(hwndCtl, fSelect, index)     ((int)(DWORD)SendMessage((hwndCtl), CLB_SETSEL, (WPARAM)(BOOL)(fSelect), (LPARAM)(index)))
#define ColumnLB_SelItemRange(hwndCtl, fSelect, first, last)    ((int)(DWORD)SendMessage((hwndCtl), CLB_SELITEMRANGE, (WPARAM)(BOOL)(fSelect), MAKELPARAM((first), (last))))

#define ColumnLB_GetCurSel(hwndCtl)                  ((int)(DWORD)SendMessage((hwndCtl), CLB_GETCURSEL, 0L, 0L))
#define ColumnLB_SetCurSel(hwndCtl, index)           ((int)(DWORD)SendMessage((hwndCtl), CLB_SETCURSEL, (WPARAM)(int)(index), 0L))

#define ColumnLB_SelectString(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), CLB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(LPCTSTR)(lpszFind)))
#define ColumnLB_SelectItemData(hwndCtl, indexStart, data)   ((int)(DWORD)SendMessage((hwndCtl), CLB_SELECTSTRING, (WPARAM)(int)(indexStart), (LPARAM)(data)))

#define ColumnLB_GetSel(hwndCtl, index)              ((int)(DWORD)SendMessage((hwndCtl), CLB_GETSEL, (WPARAM)(int)(index), 0L))
#define ColumnLB_GetSelCount(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), CLB_GETSELCOUNT, 0L, 0L))
#define ColumnLB_GetTopIndex(hwndCtl)                ((int)(DWORD)SendMessage((hwndCtl), CLB_GETTOPINDEX, 0L, 0L))
#define ColumnLB_GetSelItems(hwndCtl, cItems, lpItems) ((int)(DWORD)SendMessage((hwndCtl), CLB_GETSELITEMS, (WPARAM)(int)(cItems), (LPARAM)(int *)(lpItems)))

#define ColumnLB_SetTopIndex(hwndCtl, indexTop)      ((int)(DWORD)SendMessage((hwndCtl), CLB_SETTOPINDEX, (WPARAM)(int)(indexTop), 0L))

#define ColumnLB_SetColumnWidth(hwndCtl, cxColumn)   ((void)SendMessage((hwndCtl), CLB_SETCOLUMNWIDTH, (WPARAM)(int)(cxColumn), 0L))
#define ColumnLB_GetHorizontalExtent(hwndCtl)        ((int)(DWORD)SendMessage((hwndCtl), CLB_GETHORIZONTALEXTENT, 0L, 0L))
#define ColumnLB_SetHorizontalExtent(hwndCtl, cxExtent)     ((void)SendMessage((hwndCtl), CLB_SETHORIZONTALEXTENT, (WPARAM)(int)(cxExtent), 0L))

#define ColumnLB_SetTabStops(hwndCtl, cTabs, lpTabs) ((BOOL)(DWORD)SendMessage((hwndCtl), CLB_SETTABSTOPS, (WPARAM)(int)(cTabs), (LPARAM)(int *)(lpTabs)))

#define ColumnLB_GetItemRect(hwndCtl, index, lprc)   ((int)(DWORD)SendMessage((hwndCtl), CLB_GETITEMRECT, (WPARAM)(int)(index), (LPARAM)(RECT *)(lprc)))

#define ColumnLB_SetCaretIndex(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), CLB_SETCARETINDEX, (WPARAM)(int)(index), 0L))
#define ColumnLB_GetCaretIndex(hwndCtl)              ((int)(DWORD)SendMessage((hwndCtl), CLB_GETCARETINDEX, 0L, 0L))

#define ColumnLB_FindStringExact(hwndCtl, indexStart, lpszFind) ((int)(DWORD)SendMessage((hwndCtl), CLB_FINDSTRINGEXACT, (WPARAM)(int)(indexStart), (LPARAM)(LPCTSTR)(lpszFind)))

#define ColumnLB_SetItemHeight(hwndCtl, index, cy)   ((int)(DWORD)SendMessage((hwndCtl), CLB_SETITEMHEIGHT, (WPARAM)(int)(index), MAKELPARAM((cy), 0)))
#define ColumnLB_GetItemHeight(hwndCtl, index)       ((int)(DWORD)SendMessage((hwndCtl), CLB_GETITEMHEIGHT, (WPARAM)(int)(index), 0L))
#endif  /* WINVER >= 0x030a */

#define ColumnLB_Dir(hwndCtl, attrs, lpszFileSpec)   ((int)(DWORD)SendMessage((hwndCtl), CLB_DIR, (WPARAM)(UINT)(attrs), (LPARAM)(LPCTSTR)(lpszFileSpec)))

#define ColumnLB_GetFocus(hwndCtl)   ((HWND)(DWORD)SendMessage((hwndCtl), CLB_GETFOCUS, 0L, 0L))


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\constant.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _CONSTANT_
#define _CONSTANT_

#ifdef __cplusplus
extern "C"{
#endif

#define MAX_NW_OBJECT_NAME_LEN 48
#define MAX_NT_SERVER_NAME_LEN 15

// These constants are just a safe max of the NT and NW constants
#define MAX_SERVER_NAME_LEN 48
#define MAX_USER_NAME_LEN   256 // must add room for nw4 names...
#define MAX_NT_USER_NAME_LEN 20
#define MAX_SHARE_NAME_LEN  16
#define MAX_GROUP_NAME_LEN  50
#define MAX_NT_GROUP_NAME_LEN 20
#define MAX_DOMAIN_NAME_LEN 15
#define MAX_UNC_PATH MAX_PATH + MAX_SERVER_NAME_LEN + MAX_SHARE_NAME_LEN + 265

#define MAX_PW_LEN 14
#define MAX_UCONST_LEN 10
#define MAX_DOMAIN_LEN 15

#define TMP_STR_LEN_256 256
#define TMP_STR_LEN_80 80

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\logview\version.h ===
/*
** Template for version resources.  Place this in your .rc file,
** editing the values for VER_FILETYPE, VER_FILESUBTYPE,
** VER_FILEDESCRIPTION_STR and VER_INTERNALNAME_STR as needed.
** See winver.h for possible values.
**
** Ntverp.h defines several global values that don't need to be
** changed except for official releases such as betas, sdk updates, etc.
**
** Common.ver has the actual version resource structure that all these
** #defines eventually initialize.
*/

/* #include <windows.h> needed if this will be the .rc file */

#include <ntverp.h>

/*-----------------------------------------------*/
/* the following lines are specific to this file */
/*-----------------------------------------------*/

/* VER_FILETYPE, VER_FILESUBTYPE, VER_FILEDESCRIPTION_STR
 * and VER_INTERNALNAME_STR must be defined before including COMMON.VER
 * The strings don't need a '\0', since common.ver has them.
 */
#define	VER_FILETYPE	VFT_APP
/* possible values:		VFT_UNKNOWN
				VFT_APP
				VFT_DLL
				VFT_DRV
				VFT_FONT
				VFT_VXD
				VFT_STATIC_LIB
*/
#define	VER_FILESUBTYPE	VFT2_UNKNOWN
/* possible values		VFT2_UNKNOWN
				VFT2_DRV_PRINTER
				VFT2_DRV_KEYBOARD
				VFT2_DRV_LANGUAGE
				VFT2_DRV_DISPLAY
				VFT2_DRV_MOUSE
				VFT2_DRV_NETWORK
				VFT2_DRV_SYSTEM
				VFT2_DRV_INSTALLABLE
				VFT2_DRV_SOUND
				VFT2_DRV_COMM
*/
#define VER_FILEDESCRIPTION_STR     "Migration Tool for NetWare Log File Viewer"
#define VER_INTERNALNAME_STR        "LogView"
#define VER_ORIGINALFILENAME_STR    "LOGVIEW.EXE"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\aboutbox.c ===
/*
  +-------------------------------------------------------------------------+
  |                        About Box Routine                                |
  +-------------------------------------------------------------------------+
  |                     (c) Copyright 1993-1994                             |
  |                          Microsoft Corp.                                |
  |                        All rights reserved                              |
  |                                                                         |
  | Program               : [AboutBox.c]                                    |
  | Programmer            : Arthur Hanson                                   |
  | Original Program Date : [Jul 27, 1993]                                  |
  | Last Update           : [Jun 18, 1994]                                  |
  |                                                                         |
  | Version:  1.00                                                          |
  |                                                                         |
  | Description:                                                            |
  |   About box code, nuff said.                                            |
  |                                                                         |
  |                                                                         |
  | History:                                                                |
  |   arth  Jun 18, 1994    1.00    Original Version.                       |
  |                                                                         |
  +-------------------------------------------------------------------------+
*/

#include "globals.h"
#include <shellapi.h>

extern TCHAR szAppName[];

/*+-------------------------------------------------------------------------+
  | AboutBox_Do()
  |
  +-------------------------------------------------------------------------+*/
void AboutBox_Do(HWND hDlg) {

    ShellAbout(hDlg, szAppName, szAppName, LoadIcon(hInst, szAppName));

} // AboutBox_Do
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\columnlb.c ===
// ==================================================================================================
//  COPYRIGHT 1992,1993 MICROSOFT CORP ALL RIGHTS RESERVED
// ==================================================================================================
//
//  - Custom control to display Columns/Titles above a list box
//
// TERMINOLOGY:
// PHYSICAL COLUMNS: The index of the original columns in their original order
// VIRtUAL COLUMNS: The index of the column as the display is currently showing it based on
//                  the current order.
//
//  History:
//  -------
//  RickD                   04/10/92    created TitleListBox
//  Tom Laird-McConnell     12/30/92    Ported to Win32, added to BH project
//  Tom Laird-McConnell     05/01/93    gutted titlelist and used as base for complete rewrite as ColumnLB
//  Tom Laird-McConnell     08/18/93    Added tabbed-delimited string support
//  Arth                    03/24/94    Added Unicode support
// ==================================================================================================
#define STRICT  1
#include "switches.h"

#include <windows.h>
#include <windowsx.h>

#include <string.h>
#include <stdlib.h>

// #include <dprintf.h>

#include "columnlb.h"
#include "vlist.h"

#include "utils.h"
#include "debug.h"
#include "mem.h"


//#define DEBUG_HSCROLL 1

#define WHITESPACE        8

#define IDL_COLUMNLISTBOX       (CLB_BASE + 1)
#define IDL_COLUMNTITLELISTBOX  (CLB_BASE + 2)

#define LB16_ADDSTRING      (WM_USER+1)
#define LB16_INSERTSTRING   (WM_USER+2)

typedef struct _COLRECORD
{
    DWORD_PTR   itemData;
    LPTSTR   pString[];
} COLRECORD;
typedef COLRECORD *LPCOLRECORD;

// -------------------------------------------------------------------------------------
//
// window procs
//
LRESULT CALLBACK ColumnLBClass_ListBoxWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK ColumnLBClass_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

//
//  system message handlers
//
BOOL    ColumnLBClass_OnNCCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct);
void    ColumnLBClass_OnNCDestroy(HWND hwnd);
void    ColumnLBClass_OnDestroy(HWND hwnd);
void    ColumnLBClass_OnPaint(HWND hwnd);
void    ColumnLBClass_OnSize(HWND hwnd, UINT state, int cx, int cy);
void    ColumnLBClass_OnSetFont(HWND hwnd, HFONT hfont, BOOL fRedraw);
LRESULT ColumnLBClass_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos);
void    ColumnLBClass_OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpDrawItem);
void    ColumnLBClass_OnMeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT lpMeasureItem);
void    ColumnLBClass_OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT *lpDeleteItem);
int     ColumnLBClass_OnCharToItem(HWND hwnd, UINT ch, HWND hwndListbox, int iCaret);

//
// WM_USER message handlers
//
BYTE    ColumnLBClass_OnNumberCols(HWND hwnd, BYTE NewNumberCols, BOOL fSetColumns);
int     ColumnLBClass_OnColWidth(HWND hwnd, BYTE Column, int NewWidth, BOOL fSetWidth);
LPTSTR   ColumnLBClass_OnColTitle(HWND hwnd, BYTE Column, LPTSTR lpTitle, BOOL fSetTitle);
BYTE    ColumnLBClass_OnSortCol(HWND hwnd, BYTE NewSortCol, BOOL fSetSortCol);
LPBYTE  ColumnLBClass_OnColOrder(HWND hwnd, LPBYTE NewColOrder, BOOL fSetOrder);
LPINT   ColumnLBClass_OnColOffsets(HWND hwnd, LPINT NewOffsetTable, BOOL fSetOffsets);
LRESULT ColumnLBClass_OnAutoWidth(HWND hwnd, BYTE ColumnToCompute);


//
// mouse movement messages
//
void    ColumnLBClass_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags);
void    ColumnLBClass_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);
void    ColumnLBClass_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags);
void    ColumnLBClass_OnRButtonDown (HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags);

// helper functions
int     ColumnLBClass_ComputeOffsets(HWND hwnd);

// -------------------------------------------------------------------------------------
//
//  Locals
//
BOOL        fWIN32s;            // flag for whether win32s (instead of win32/NT)


// -----------------------------------------------------------------
//
//  ColumnLBClass_Register()
//
//  This function is used to register the Column LB class with the system
//
// HISTORY:
//  Tom Laird-McConnell 4/17/93     Created
//
// -----------------------------------------------------------------
BOOL ColumnLBClass_Register(HINSTANCE hInstance)
{
    WNDCLASS   WndClass;

    fWIN32s = ((DWORD)GetVersion() & 0x80000000) ? TRUE : FALSE;

    //
    // Create the COLUMNLISTBOX class
    //
    WndClass.style         = CS_PARENTDC | CS_DBLCLKS; //  CS_GLOBALCLASS;
    WndClass.lpfnWndProc   = ColumnLBClass_WndProc;
    WndClass.cbClsExtra    = 0;
    WndClass.cbWndExtra    = sizeof(LPCOLUMNLBSTRUCT);  // we store a pointer as instance data
    WndClass.hInstance     = hInstance;
    WndClass.hIcon         = 0;
    WndClass.hCursor       = LoadCursor(0, IDC_ARROW);
    WndClass.hbrBackground = 0;
    WndClass.lpszMenuName  = 0;
    WndClass.lpszClassName = COLUMNLBCLASS_CLASSNAME;

    /* Register the normal title list box control */
    return RegisterClass((LPWNDCLASS)&WndClass);
}


// -----------------------------------------------------------------
//
//  ColumnVLBClass_Register()
//
//  This function is used to register the Column VLIST LB class with the system
//
// HISTORY:
//  Tom Laird-McConnell 4/17/93     Created
//
// -----------------------------------------------------------------
BOOL ColumnVLBClass_Register(HINSTANCE hInstance)
{
    WNDCLASS   WndClass;

    fWIN32s = ((DWORD)GetVersion() & 0x80000000) ? TRUE : FALSE;

    //
    // Create the COLUMNVLISTBOX class
    //
    WndClass.style         = CS_PARENTDC | CS_DBLCLKS; //  CS_GLOBALCLASS;
    WndClass.lpfnWndProc   = ColumnLBClass_WndProc;
    WndClass.cbClsExtra    = 0;
    WndClass.cbWndExtra    = sizeof(LPCOLUMNLBSTRUCT);  // we store a pointer as instance data
    WndClass.hInstance     = hInstance;
    WndClass.hIcon         = 0;
    WndClass.hCursor       = LoadCursor(0, IDC_ARROW);
    WndClass.hbrBackground = 0;
    WndClass.lpszMenuName  = 0;
    WndClass.lpszClassName = COLUMNVLBCLASS_CLASSNAME; // NOTE: this is a different name

    /* Register the new control */
    return(RegisterClass((LPWNDCLASS)&WndClass));
}



// -----------------------------------------------------------------
//
//  ColumnLBClass_Unregister()
//
//  This function is used to deregister the Column  LB class with the system
//
// HISTORY:
//  Tom Laird-McConnell 4/17/93     Created
//
// -----------------------------------------------------------------
BOOL ColumnLBClass_Unregister(HINSTANCE hInstance)
{
    return(UnregisterClass(COLUMNLBCLASS_CLASSNAME, hInstance));
}

// -----------------------------------------------------------------
//
//  ColumnVLBClass_Unregister()
//
//  This function is used to deregister the Column VLIST LB class with the system
//
// HISTORY:
//  Tom Laird-McConnell 4/17/93     Created
//
// -----------------------------------------------------------------
BOOL ColumnVLBClass_Unregister(HINSTANCE hInstance)
{
    return(UnregisterClass(COLUMNVLBCLASS_CLASSNAME, hInstance));
}

// -----------------------------------------------------------------
// ColumnLBClass_ListBoxWndProc
//
//  Window proc used in sub-classing the internal listbox to catch
// internal scroll events to keep title in sync with it...
//
// HISTORY:
//  Tom Laird-McConnell 4/17/93     Created
//
// -----------------------------------------------------------------
LRESULT CALLBACK ColumnLBClass_ListBoxWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT                   result;
    LPCOLUMNLBSTRUCT        lpColumnLB;

    // Everthing goes to normal listbox for processing
    lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(GetParent(hwnd), (DWORD)0);

    // preprocessing
    switch (msg)
    {

        case WM_HSCROLL:
            // do title hscroll first..
            result = SendMessage(lpColumnLB->hwndTitleList, WM_HSCROLL, wParam, lParam);
            break;

        case WM_SETFOCUS:
            lpColumnLB->fHasFocus = TRUE;
            //dprintf ("SetFocus to ColumnLB\n");
            break;

        case WM_KILLFOCUS:
            lpColumnLB->fHasFocus = FALSE;
            //dprintf ("KillFocus to ColumnLB\n");
            break;


    }

    //
    // call the original listbox window proc
    //
    result = CallWindowProc((WNDPROC)(lpColumnLB->OldListboxProc), hwnd, msg, (WPARAM) wParam, (LPARAM)lParam);


    //
    // or if our parent has CLBS_NOTIFYLMOUSE style, then foward LMOUSE buttons
    // or if our parent has CLBS_NOTIFYRMOUSE style, then foward RMOUSE buttons
    //
    switch (msg)
    {
        case WM_HSCROLL:
            //
            // if it is a Horizontal scrolls, then we foward to our parent so title can be moved
            // in sync with listbox....
            //
            SendMessage(GetParent(hwnd), CLB_HSCROLL, wParam, lParam );
            break;

        case VLB_RESETCONTENT:
        case LB_RESETCONTENT:
            //
            // if it is a LB_RESETCONTENT, or VLB_RESETCONTENT, then reset x position
            //
            SendMessage(GetParent(hwnd), CLB_HSCROLL, (WPARAM)SB_TOP, (LPARAM)NULL);
            break;

        case WM_LBUTTONDOWN   :
        case WM_LBUTTONUP     :
        case WM_LBUTTONDBLCLK :
            //
            // forward message to parent
            //
            if (GetWindowLong(GetParent(hwnd), GWL_EXSTYLE) & CLBS_NOTIFYLMOUSE)
                SendMessage(GetParent(hwnd), msg, wParam, lParam);
            break;

        case WM_RBUTTONDOWN   :
//      case WM_RBUTTONUP     :
        case WM_RBUTTONDBLCLK :

            //
            // forward message to parent
            //

            //  if (GetWindowLong(GetParent(hwnd), GWL_EXSTYLE) & CLBS_NOTIFYRMOUSE)
                SendMessage(GetParent(hwnd), msg, wParam, lParam);
            break;


        default:
            break;
    }

    return(result);
}

// -----------------------------------------------------------------
// ColumnLBClass_TitleListBoxWndProc
//
//  Window proc used in sub-classing the internal Title listbox to catch
// internal mouse click events...
//
// HISTORY:
//  Tom Laird-McConnell 4/17/93     Created
//
// -----------------------------------------------------------------
LRESULT CALLBACK ColumnLBClass_TitleListBoxWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT             result;
    LPCOLUMNLBSTRUCT    lpColumnLB;

    // Everthing goes to normal listbox for processing
    lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(GetParent(hwnd), (DWORD)0);

    //
    // call the original listbox window proc
    //
    result = CallWindowProc((WNDPROC)(lpColumnLB->OldTitleListboxProc) , hwnd, msg, (WPARAM) wParam, (LPARAM)lParam);

    //
    // foward LMOUSE buttons, foward RMOUSE buttons
    //
    switch (msg)
    {
#ifdef DEBUG_HSCROLL
        case WM_HSCROLL:
            dprintf(TEXT("ColumnLBClass_TitleListBoxProc: CallWindowProc(OldListboxProc) returned %ld to hwnd=%lx, wParam=%u, lParam=%u\n"), hwnd, wParam, lParam);
            break;
#endif
        case WM_MOUSEMOVE:
        case WM_LBUTTONDOWN   :
        case WM_LBUTTONUP     :
        case WM_LBUTTONDBLCLK :
        case WM_RBUTTONDOWN   :
        case WM_RBUTTONUP     :
        case WM_RBUTTONDBLCLK :
                SendMessage(GetParent(hwnd), msg, wParam, lParam);
                break;

        case WM_SETFOCUS:
            // we don't ever want the focus, so give it back to the parent...
            SendMessage(GetParent(hwnd), msg, wParam, lParam);
            break;

        case WM_SIZE:
            // we need to reset our idea of what our current scroll position is...
            break;
    }

    return(result);
}



// -----------------------------------------------------------------
//  ColumnLBClass_WndProc
//
// Main window proc for handling messages for both the ColumnLB and
// ColumnVLB classes...
//
// HISTORY:
//  Tom Laird-McConnell 4/17/93     Created
//
// -----------------------------------------------------------------
LRESULT CALLBACK ColumnLBClass_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPCOLUMNLBSTRUCT    lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0);
    LPCOLRECORD lpRecord;
    LRESULT result;

    //
    // check for ListBox message coming from application
    // and forward them onto the listbox itself...
    //
    if ( ((fWIN32s == TRUE) && (msg >= WM_USER && msg < (WM_USER + LB_MSGMAX - LB_ADDSTRING + 1)) ) || // WIN32s version   BUGBUG
         ((fWIN32s == FALSE) && (msg >= LB_ADDSTRING && msg < LB_MSGMAX)) ||    // NT version       BUGBUG
         ((msg >= VLB_TOVLIST_MSGMIN) && (msg <= VLB_TOVLIST_MSGMAX))           // vlb sepcific APP->VLIST messages should be fowarded...
       )
    {
        //
        // OWNERDRAW parent, so just send it to the hwnd list child
        //
        return(SendMessage(lpColumnLB->hwndList, msg, wParam, lParam));
    }

    //
    // check to see if message is a TO APPLCATION message from the child listbox
    // which should be forwarded to application parent window
    //
    if ((msg >= VLB_TOAPP_MSGMIN) && (msg <= VLB_TOAPP_MSGMAX))
        return(SendMessage(GetParent(hwnd), msg, wParam, lParam));   // forward to parent...

    //
    // since it's not a message passing through, then process this message
    // as our own...
    //
    switch (msg)
    {
        HANDLE_MSG(hwnd, WM_NCCREATE,       ColumnLBClass_OnNCCreate);
        HANDLE_MSG(hwnd, WM_NCDESTROY,      ColumnLBClass_OnNCDestroy);
        HANDLE_MSG(hwnd, WM_DESTROY,        ColumnLBClass_OnDestroy);
        HANDLE_MSG(hwnd, WM_PAINT,          ColumnLBClass_OnPaint);
        HANDLE_MSG(hwnd, WM_SIZE,           ColumnLBClass_OnSize);
        HANDLE_MSG(hwnd, WM_DRAWITEM,       ColumnLBClass_OnDrawItem);
        HANDLE_MSG(hwnd, WM_MEASUREITEM,    ColumnLBClass_OnMeasureItem);
        HANDLE_MSG(hwnd, WM_DELETEITEM,     ColumnLBClass_OnDeleteItem);

        HANDLE_MSG(hwnd, WM_LBUTTONDOWN,    ColumnLBClass_OnLButtonDown);
        HANDLE_MSG(hwnd, WM_LBUTTONDBLCLK,  ColumnLBClass_OnLButtonDown);
        HANDLE_MSG(hwnd, WM_LBUTTONUP,      ColumnLBClass_OnLButtonUp);
        HANDLE_MSG(hwnd, WM_MOUSEMOVE,      ColumnLBClass_OnMouseMove);

        case WM_RBUTTONDOWN:
            // figure out what item we are on and tell our parent.
            HANDLE_WM_RBUTTONDOWN ( hwnd, wParam, lParam, ColumnLBClass_OnRButtonDown );
            break;

        case WM_CREATE:
            {
                LPCREATESTRUCT lpCreate = (LPCREATESTRUCT) lParam;

                ColumnLBClass_OnSize(hwnd, SIZE_RESTORED, lpCreate->cx, lpCreate->cy);
            }
            break;


        // -------------------------------------------------------------------
        // put System messages here which explicitly need to be passed to LISTBOX
        //
        case WM_SETFONT:
            HANDLE_WM_SETFONT(hwnd, wParam, lParam,   ColumnLBClass_OnSetFont);
            break;

        // put the focus on the list box if we get it
        case WM_SETFOCUS:
            lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0);
            SetFocus(lpColumnLB->hwndList);
            break;

        case SBM_SETPOS         :
        case SBM_SETRANGE       :
        case SBM_SETRANGEREDRAW :
            //
            // need to foward SBM messages to both listboxes...
            //
            SendMessage(lpColumnLB->hwndTitleList, msg, wParam, lParam);
            return(SendMessage(lpColumnLB->hwndList, msg, wParam, lParam));

        case SBM_GETPOS         :
        case SBM_GETRANGE       :
        case SBM_ENABLE_ARROWS  :
            return(SendMessage(lpColumnLB->hwndList, msg, wParam, lParam));

        // ------------------------------------------------------------------------------
        //
        //   LB_XXXXXXX Messages (disguised as CLB_XXXXXX messages)
        //          to pass on to child listbox, if the parent didn't want us to
        //          be owner draw, then we implement ownerddraw default behavior ourself
        //
        // ------------------------------------------------------------------------------
        case CLB_ADDSTRING:
        case CLB_INSERTSTRING:
            //
            // if the parent is NOT handling OWNERDRAW, then we need to handle
            //
            if ( ! (lpColumnLB->Style & (LBS_OWNERDRAWFIXED | VLBS_OWNERDRAWFIXED)) )
            {
                LPTSTR lpColStart,lpTab;
                LPTSTR lpStringBuffer;
                int i;

                lpRecord = (LPCOLRECORD)GlobalAllocPtr(GPTR, sizeof(COLRECORD) + sizeof(LPTSTR) * lpColumnLB->nColumns);
                lpStringBuffer = (LPTSTR) GlobalAllocPtr(GPTR, (lstrlen((LPTSTR)lParam) * sizeof(TCHAR)) + sizeof(TCHAR));

                if ((lpRecord) && (lpStringBuffer))
                {
                    // now parse the tab-deliminated string and put into each pointer
                    lstrcpy(lpStringBuffer, (LPTSTR)lParam);
                    lpColStart =  lpStringBuffer;
                    lpTab  = lstrchr(lpStringBuffer, TEXT('\t'));

                    // fill in pointer table
                    for (i=0; i < lpColumnLB->nColumns; i++)
                    {
                        if (lpTab)
                            *lpTab = '\0';
                        else
                        {
                            // there was an error, not enough tabs!
                            GlobalFreePtr(lpRecord);
                            GlobalFreePtr(lpStringBuffer);
                            return(LB_ERR);
                        }
                        // store this pointer.
                        lpRecord->pString[i] = lpColStart;
                        // advance to next column text
                        lpColStart = lpTab + 1;
                        lpTab = lstrchr(lpColStart, TEXT('\t'));
                    }
                    lpRecord->itemData = 0;

                    // and now pass on our new lpRecord as the item being added to the listbox
                    return(SendMessage(lpColumnLB->hwndList, msg - CLB_BASE, wParam, (LPARAM)lpRecord));
                }
                else // an error has occured, free up any memory and return failure
                {
                    if (lpStringBuffer)
                        GlobalFreePtr(lpStringBuffer);
                    if (lpRecord)
                        GlobalFreePtr(lpRecord);
                    return(LB_ERR);
                }
            }
            else
                //
                // Parent is owner draw, so send it to the hwnd list child,
                // but translate the message first to real LB_ message
                //
                return(SendMessage(lpColumnLB->hwndList, msg - CLB_BASE, wParam, lParam));

        // and we also need to check for LB_GETTEXT to make it look like a string
        case CLB_GETTEXT:
            //
            // if the parent is NOT handling OWNERDRAW, then we need to handle
            //
            if ( ! (lpColumnLB->Style & (LBS_OWNERDRAWFIXED | VLBS_OWNERDRAWFIXED)) )
            {
                LPTSTR p = (LPTSTR)lParam;
                DWORD Length = 0;
                DWORD x;
                int i;

                *p = '\0';

                // and now pass on to get the text...
                lpRecord = (LPCOLRECORD)SendMessage(lpColumnLB->hwndList, LB_GETITEMDATA, wParam, 0);

                if (lpRecord == (LPCOLRECORD)LB_ERR)
                    return(LB_ERR);

                for (i=0; i < lpColumnLB->nColumns ; i++ )
                {
                    lstrcpy(p, lpRecord->pString[lpColumnLB->ColumnOrderTable[i]]);
                    lstrcat(p, TEXT("\t"));
                    x = lstrlen(p);
                    Length += x + sizeof(TCHAR);
                    p += x;
                }
                return(Length);
            }
            else
                //
                // Parent is owner draw, so send it to the hwnd list child,
                // but translate the message first to real LB_ message
                //
                return(SendMessage(lpColumnLB->hwndList, msg - CLB_BASE, wParam, lParam));

        case CLB_GETTEXTPTRS:

            if ( ! (lpColumnLB->Style & (LBS_OWNERDRAWFIXED | VLBS_OWNERDRAWFIXED)) )
            {
                lpRecord = (LPCOLRECORD)SendMessage(lpColumnLB->hwndList, LB_GETITEMDATA, wParam, 0);

                if (lpRecord == (LPCOLRECORD)LB_ERR)
                    return(LB_ERR);

                return (LRESULT)lpRecord->pString;
            }
            else
                return (LRESULT)NULL;


            // we need to handle LB_GETTEXTLEN to return full tabbed length...
        case CLB_GETTEXTLEN:
            //
            // if the parent is NOT handling OWNERDRAW, then we need to handle
            //
            if ( ! (lpColumnLB->Style & (LBS_OWNERDRAWFIXED | VLBS_OWNERDRAWFIXED)) )
            {
                LPTSTR p = (LPTSTR)lParam;
                DWORD Length = 0;
                int i;

                // and now pass on to get the text...
                lpRecord = (LPCOLRECORD)SendMessage(lpColumnLB->hwndList, LB_GETITEMDATA, wParam, 0);

                if (lpRecord == (LPCOLRECORD)LB_ERR)
                    return(LB_ERR);

                for (i=0; i < lpColumnLB->nColumns ; i++ )
                {
                    Length += lstrlen(lpRecord->pString[lpColumnLB->ColumnOrderTable[i]]) + sizeof(TCHAR);
                }
                return(Length);
            }
            else
                //
                // Parent is owner draw, so send it to the hwnd list child,
                // but translate the message first to real LB_ message
                //
                return(SendMessage(lpColumnLB->hwndList, msg - CLB_BASE, wParam, lParam));

        case CLB_GETITEMDATA:
            //
            // if the parent is NOT handling OWNERDRAW, then we need to handle
            //
            if ( ! (lpColumnLB->Style & (LBS_OWNERDRAWFIXED | VLBS_OWNERDRAWFIXED)) )
            {
                lpRecord = (LPCOLRECORD)SendMessage(lpColumnLB->hwndList, LB_GETITEMDATA, wParam, 0);
                if (lpRecord != (LPCOLRECORD)LB_ERR)
                    return(lpRecord->itemData);
                else
                    return(LB_ERR);
            }
            else
                //
                // Parent is owner draw, so send it to the hwnd list child,
                // but translate the message first to real LB_ message
                //
                return(SendMessage(lpColumnLB->hwndList, msg - CLB_BASE, wParam, lParam));


        case CLB_SETITEMDATA:
            //
            // if the parent is NOT handling OWNERDRAW, then we need to handle
            //
            if ( ! (lpColumnLB->Style & (LBS_OWNERDRAWFIXED | VLBS_OWNERDRAWFIXED)) )
            {
                lpRecord = (LPCOLRECORD)SendMessage(lpColumnLB->hwndList, LB_GETITEMDATA, wParam, 0);

                if (lpRecord != (LPCOLRECORD)LB_ERR)
                    return (LRESULT)(lpRecord->itemData = lParam);
                else
                    return(LB_ERR);
            }
            else
                //
                // Parent is owner draw, so send it to the hwnd list child,
                // but translate the message first to real LB_ message
                //
                return(SendMessage(lpColumnLB->hwndList, msg - CLB_BASE, wParam, lParam));

        //
        // if it is a HORIZONTAL exntent message, then we need to massage...
        //
        case CLB_SETHORIZONTALEXTENT :
            //
            // send the message to the title listbox as well
            //
            SendMessage(lpColumnLB->hwndTitleList, LB_SETHORIZONTALEXTENT, wParam, lParam);

            //
            // pass it on to the child listbox, using VLB_SETHOR if appropriate...
            //
            return(SendMessage(lpColumnLB->hwndList,
                                (lpColumnLB->fUseVlist) ? VLB_SETHORIZONTALEXTENT : LB_SETHORIZONTALEXTENT,
                                wParam, lParam));

        //
        // we need to massage the GETITEMRECT to handle the incorrect rect returned due to titlelistbox.
        //
        case CLB_GETITEMRECT:
            {
                LRESULT retcode;
                int height;
                LPRECT lpRect = (LPRECT)lParam;

                //
                // send it to the hwnd list child, but translate the message first to real LB_ message
                //
                retcode = SendMessage(lpColumnLB->hwndList, msg - CLB_BASE, wParam, lParam);
                height = lpRect->bottom-lpRect->top;
                lpRect->top = lpRect->bottom + 1;
                lpRect->bottom = lpRect->top + height;
                return(retcode);
            }
            break;

        case CLB_DELETESTRING         :
        case CLB_SELITEMRANGEEX       :
        case CLB_RESETCONTENT         :
        case CLB_SETSEL               :
        case CLB_SETCURSEL            :
        case CLB_GETSEL               :
        case CLB_GETCURSEL            :
        case CLB_GETCOUNT             :
        case CLB_SELECTSTRING         :
        case CLB_DIR                  :
        case CLB_GETTOPINDEX          :
        case CLB_FINDSTRING           :
        case CLB_GETSELCOUNT          :
        case CLB_GETSELITEMS          :
        case CLB_SETTABSTOPS          :
        case CLB_GETHORIZONTALEXTENT  :
        case CLB_SETCOLUMNWIDTH       :
        case CLB_ADDFILE              :
        case CLB_SETTOPINDEX          :
        case CLB_SELITEMRANGE         :
        case CLB_SETANCHORINDEX       :
        case CLB_GETANCHORINDEX       :
        case CLB_SETCARETINDEX        :
        case CLB_GETCARETINDEX        :
        case CLB_SETITEMHEIGHT        :
        case CLB_GETITEMHEIGHT        :
        case CLB_FINDSTRINGEXACT      :
        case CLB_SETLOCALE            :
        case CLB_GETLOCALE            :
        case CLB_SETCOUNT             :
            //
            // Simply send it to the hwnd list child, but translate the message first to real LB_ message
            //
            return(SendMessage(lpColumnLB->hwndList, msg - CLB_BASE, wParam, lParam));

        // -------------------------------------------------------------------
        // put messages here which explicitly need to be passed to our PARENT
        //
        case WM_COMMAND:
            /* if this is a notification message from our child translate */
            /* it to look like it is from us and pass on to our parent    */

            if (LOWORD(wParam) == IDL_COLUMNLISTBOX)
              return(SendMessage(   GetParent(hwnd),
                                    msg,
                                    MAKELONG(  GetDlgCtrlID(hwnd) ,HIWORD(wParam)),
                                    (LPARAM)hwnd )); // make it look like we were the ones sending the message...
            else
              return(SendMessage(GetParent(hwnd), msg, wParam, (LPARAM)hwnd));

        case WM_VKEYTOITEM:
            // pass on to our parent but using our hwnd...
            if (lpColumnLB->Style & (LBS_WANTKEYBOARDINPUT | VLBS_WANTKEYBOARDINPUT) )
                return(SendMessage(GetParent(hwnd), msg, wParam, (LPARAM)hwnd));
            else
                return(-1); // perform default action...

        case WM_CHARTOITEM:
            if (lpColumnLB->Style & (LBS_WANTKEYBOARDINPUT | VLBS_WANTKEYBOARDINPUT) )
                if ((result = SendMessage(GetParent(hwnd), msg, wParam, (LPARAM)hwnd)) != -1)
                    return(result);

            return HANDLE_WM_CHARTOITEM(hwnd, wParam, lParam, ColumnLBClass_OnCharToItem);

        case WM_COMPAREITEM:
            {
                LPCOMPAREITEMSTRUCT lpCompareItem = (LPCOMPAREITEMSTRUCT)lParam;
                LRESULT result;

                if ((lpColumnLB->Style & LBS_OWNERDRAWFIXED) ||
                    (lpColumnLB->Style & VLBS_OWNERDRAWFIXED))
                {
                    //
                    // substitute our values in the COMPAREITEMSTRUCT...
                    //
                    lpCompareItem->CtlID = GetDlgCtrlID(hwnd);
                    lpCompareItem->hwndItem = hwnd;

                    //
                    // then pass to our parent as our WM_COMPAREITEM, with the current physcial sort column as wParam
                    //
                    result = (int)SendMessage(GetParent(hwnd), WM_COMPAREITEM, (WPARAM)lpColumnLB->SortColumn, (LPARAM)lpCompareItem);
                    return(result);
                }
                else
                {
                    LPTSTR lpString1;
                    LPTSTR lpString2;
                    LPCOLRECORD lpColRecord1;
                    LPCOLRECORD lpColRecord2;

                    // handle ourselves assuming item data is pointer to array of LPTSTR's
                    lpColRecord1 = (LPCOLRECORD)lpCompareItem->itemData1;
                    lpColRecord2 = (LPCOLRECORD)lpCompareItem->itemData2;
                    lpString1 = lpColRecord1->pString[lpColumnLB->SortColumn];
                    lpString2 = lpColRecord2->pString[lpColumnLB->SortColumn];
                    if (lpString1 && lpString2)
                        return(lstrcmpi(lpString1, lpString2));
                    else
                        return(0);
                }
            }
            break;

        // ---------------------------------------------------------
        //  handle our own messages
        // ---------------------------------------------------------

        //
        // NUMBER COLUMNS
        //
        case  CLB_GETNUMBERCOLS   :    // get the number of columns (ret=NumCols)
            return ColumnLBClass_OnNumberCols(hwnd, 0, FALSE);

        case  CLB_SETNUMBERCOLS   :    // set the number of columns (wparam=NumCols)
            return ColumnLBClass_OnNumberCols(hwnd, (BYTE)wParam, TRUE);

        // ----------------------------------------------------------------
        //      Following messages use physical column numbers
        // ----------------------------------------------------------------
        //
        // COLUMN WIDTH
        //
        case  CLB_GETCOLWIDTH     :    // get a column width   (wParm=Physical Column ret=ColWidth in LU's)
            return ColumnLBClass_OnColWidth(hwnd, (BYTE)wParam, (int)0, FALSE);

        case  CLB_SETCOLWIDTH     :    // set a column width   (wParm=Physical Column lParam=Width)
            return ColumnLBClass_OnColWidth(hwnd, (BYTE)wParam, (int)lParam, TRUE);

        case  CLB_AUTOWIDTH       :    // auto-matically set column widths using titles... (wParam = Physical Column to auto width)
            return ColumnLBClass_OnAutoWidth(hwnd, (BYTE)wParam);

        //
        // COLUMN TITLE
        //
        case  CLB_GETCOLTITLE     :    // get a column's title (wParm=Physical Column, ret=Title)
            return (LRESULT)ColumnLBClass_OnColTitle(hwnd, (BYTE)wParam, (LPTSTR)NULL, FALSE);

        case  CLB_SETCOLTITLE     :    // set a column's title (wParm=Physical Col, lParm=Title)
            return (LRESULT)ColumnLBClass_OnColTitle(hwnd, (BYTE)wParam, (LPTSTR)lParam, TRUE);

        case CLB_GETROWCOLTEXT:
            //
            // if the parent is NOT handling OWNERDRAW, then we need to handle
            //
            if ( ! (lpColumnLB->Style & (LBS_OWNERDRAWFIXED | VLBS_OWNERDRAWFIXED)) )
            {
                INT     WhichCol = (INT)(wParam);
                INT     WhichRow = (INT)(lParam);

                // and now pass on to get the text...
                lpRecord = (LPCOLRECORD)SendMessage(lpColumnLB->hwndList, LB_GETITEMDATA, WhichRow, 0);

                if (lpRecord == (LPCOLRECORD)LB_ERR)
                    return((LRESULT)NULL);

                return (LRESULT)lpRecord->pString[WhichCol];
            }
            return((LRESULT)NULL);   // owner draw, the owner  has to figure this out themselves


        //
        // SORT COLUMN
        //
        case  CLB_GETSORTCOL      :    // get the physical sort column (ret=Physical Col)
            return (LRESULT)ColumnLBClass_OnSortCol(hwnd, 0, FALSE);

        case  CLB_SETSORTCOL      :    // set the physical sort column (wParm=Physical Col)
            return (LRESULT)ColumnLBClass_OnSortCol(hwnd, (BYTE)wParam, TRUE);

        //
        // COLUMN ORDER
        //
        case  CLB_GETCOLORDER :    // get the virtual order of physical columns (ret = LPDWORD order table)
            return (LRESULT)ColumnLBClass_OnColOrder(hwnd, (LPBYTE)0, FALSE);

        case  CLB_SETCOLORDER :    // get the virtual order of physical columns (wParam = LPDWORD order table)
            return (LRESULT)ColumnLBClass_OnColOrder(hwnd, (LPBYTE)lParam, TRUE);



        case CLB_CHECKFOCUS:    // does the listbox have the focus?
//            if (lpColumnLB->fUseVlist)  // then we have to ask vlist the info
//                return
//            else
                return lpColumnLB->fHasFocus;


        // ----------------------------------------------------------------
        //      Following messages use virtual column numbers
        // ----------------------------------------------------------------

        //
        // COLUMN OFFSETS
        //
        case  CLB_GETCOLOFFSETS   :    // gets the incremental virtual col offsets (ret=LPDWORD)
            return (LRESULT)ColumnLBClass_OnColOffsets(hwnd, (LPINT)wParam, FALSE);

//        case  CLB_SETCOLOFFSETS   :    // gets the incremental virtual col offsets (ret=LPDWORD)
//            return (LRESULT)ColumnLBClass_OnColOffsets(hwnd, (LPDWORD)wParam, TRUE);


        // =================================================================
        //  INTERNAL
        //
        case  CLB_HSCROLL    :    // a hscroll event (INTERNAL)
           return ColumnLBClass_OnHScroll(hwnd, (HWND)(lParam), (int)LOWORD(wParam), (int)HIWORD(wParam));


        //
        // GET FOCUS
        //
        case  CLB_GETFOCUS  :    // get the handle for the window of CLB with the key focus
            if ( lpColumnLB->fUseVlist )
                // we must ask the column list box below us for the information.
                return SendMessage ( lpColumnLB->hwndList, VLB_GETFOCUSHWND, 0,0 );
            return (LRESULT) lpColumnLB->hwndList;

        default:
            return(DefWindowProc(hwnd, msg, wParam, lParam));
    }

    return(TRUE);
}


// ------------------------------------------------------------------
//  ColumnLBClass_OnNCCreate()
//
//  Handles WM_NCCCREATE message
//
// HISTORY:
//  Tom Laird-McConnell   4/18/93     Created
// ------------------------------------------------------------------
BOOL ColumnLBClass_OnNCCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct)
{
    LPCOLUMNLBSTRUCT lpColumnLB;
    HWND        hwndList;
    HWND        hwndTitleList;
    BOOL        fUseVlist;
    HDC         hdc;
    TEXTMETRIC  tm;
    RECT        rect;
    WORD ncxBorder;
    WORD ncyBorder;
    WORD yTitle;

    ncxBorder = (WORD) GetSystemMetrics(SM_CXBORDER);
    ncyBorder = (WORD) GetSystemMetrics(SM_CYBORDER);

    //
    // if the classname is for ColumnVLB class, then they want the Column Virtual list box...
    //
    if (lstrcmpi(lpCreateStruct->lpszClass, COLUMNVLBCLASS_CLASSNAME) == 0)
        fUseVlist = TRUE;
    else
        fUseVlist = FALSE;

    hdc = GetDC(hwnd);
    GetTextMetrics(hdc, &tm);
    ReleaseDC(hwnd, hdc);

    yTitle = (WORD)(tm.tmHeight + 2*ncyBorder);

    GetClientRect(hwnd, &rect);

    //
    // create the title list box window...
    //
    hwndTitleList = CreateWindow(   (LPTSTR) TEXT("LISTBOX"),
                                    (LPTSTR) TEXT(""),
                                    (lpCreateStruct->style & ~WS_BORDER) |
                                    LBS_NOINTEGRALHEIGHT          |
                                    LBS_OWNERDRAWFIXED            |
                                    WS_VISIBLE                    |
                                    WS_CHILD,
                                    ncxBorder,
                                    ncyBorder,
                                    lpCreateStruct->cx - (2*ncxBorder) - GetSystemMetrics(SM_CXVSCROLL),
                                    yTitle,
                                    hwnd,
                                    (HMENU)IDL_COLUMNTITLELISTBOX,
                                    lpCreateStruct->hInstance,
                                    NULL);

    if (fUseVlist == TRUE)
        //
        // create a Vlist window...
        //
        hwndList = CreateWindow((LPTSTR)VLIST_CLASSNAME,
                                 (LPTSTR) TEXT(""),
                                 (lpCreateStruct->style & ~(WS_BORDER | VLBS_HASSTRINGS)) | // NOTE: This can _never_ be hasstrings
                                   VLBS_NOTIFY                   |
                                   VLBS_USETABSTOPS              |
                                   VLBS_NOINTEGRALHEIGHT         |
                                   VLBS_OWNERDRAWFIXED           |  // we always force this as either we will owner draw, or our parent will
                                   WS_HSCROLL                    |
                                   WS_VSCROLL                    |
                                   VLBS_DISABLENOSCROLL          |
                                   WS_VISIBLE                    |
                                   WS_CHILD,
                                 ncxBorder,
                                 yTitle + ncyBorder,
                                 lpCreateStruct->cx - ncxBorder,    // -(2*ncxBorder)
                                 lpCreateStruct->cy - yTitle - ncyBorder,
                                 hwnd,
                                 (HMENU)IDL_COLUMNLISTBOX,
                                 lpCreateStruct->hInstance,
                                 NULL);
    else
        //
        // create a list box window...
        //
#ifdef H_SCROLL
        hwndList = CreateWindow((LPTSTR) TEXT("LISTBOX"),
                                 (LPTSTR) TEXT(""),
                                 (lpCreateStruct->style & ~(WS_BORDER | LBS_HASSTRINGS)) |  // NOTE: This can _never_ be hasstrings
                                   LBS_NOTIFY                    |
                                   LBS_USETABSTOPS               |
                                   LBS_NOINTEGRALHEIGHT          |
                                   LBS_OWNERDRAWFIXED            |  // we always force this as either we will owner draw, or our parent will
                                   WS_HSCROLL                    |
                                   WS_VSCROLL                    |
                                   LBS_DISABLENOSCROLL           |
                                   WS_VISIBLE                    |
                                   WS_CHILD,
                                 ncxBorder,
                                 yTitle + ncyBorder,
                                 lpCreateStruct->cx - ncxBorder, // -(2*ncxBorder)
                                 lpCreateStruct->cy - yTitle - ncyBorder,
                                 hwnd,
                                 (HMENU)IDL_COLUMNLISTBOX,
                                 lpCreateStruct->hInstance,
                                 NULL);
#else
        hwndList = CreateWindow((LPTSTR) TEXT("LISTBOX"),
                                 (LPTSTR) TEXT(""),
                                 (lpCreateStruct->style & ~(WS_BORDER | LBS_HASSTRINGS)) |  // NOTE: This can _never_ be hasstrings
                                   LBS_NOTIFY                    |
                                   LBS_USETABSTOPS               |
                                   LBS_NOINTEGRALHEIGHT          |
                                   LBS_OWNERDRAWFIXED            |  // we always force this as either we will owner draw, or our parent will
                                   WS_VSCROLL                    |
                                   LBS_DISABLENOSCROLL           |
                                   WS_VISIBLE                    |
                                   WS_CHILD,
                                 ncxBorder,
                                 yTitle + ncyBorder,
                                 lpCreateStruct->cx - ncxBorder, // -(2*ncxBorder)
                                 lpCreateStruct->cy - yTitle - ncyBorder,
                                 hwnd,
                                 (HMENU)IDL_COLUMNLISTBOX,
                                 lpCreateStruct->hInstance,
                                 NULL);
#endif

    //
    // if we succeeded...
    //
    if (hwndList)
    {
        //
        // create a ColumnLB struct to keep track of all of the pertinent instance
        // info for this instance of a ColumnLB window
        //
        lpColumnLB = (LPCOLUMNLBSTRUCT)GlobalAllocPtr(GPTR, sizeof(COLUMNLBSTRUCT));

        if (lpColumnLB)
        {
            BYTE i;

            //
            // store it in the window data for this window
            //
            SetWindowLongPtr(hwnd, 0, (LONG_PTR) lpColumnLB);

            memset(lpColumnLB, '\0', sizeof(COLUMNLBSTRUCT));

            //
            // fill in pertinent info
            //
            lpColumnLB->Style = lpCreateStruct->style;

            lpColumnLB->hInstance = (HINSTANCE)GetWindowLong(hwnd, GWLP_HINSTANCE);

            lpColumnLB->fUseVlist = (UCHAR) fUseVlist;
            lpColumnLB->fSorting = FALSE;
            lpColumnLB->fMouseState = 0;

            lpColumnLB->hwndList = hwndList;
            lpColumnLB->OldListboxProc = (FARPROC)GetWindowLong(hwndList, GWLP_WNDPROC);
            lpColumnLB->NewListboxProc = MakeProcInstance((FARPROC)ColumnLBClass_ListBoxWndProc, hInst);

            lpColumnLB->hwndTitleList = hwndTitleList;
            lpColumnLB->OldTitleListboxProc = (FARPROC)GetWindowLong(hwndTitleList, GWLP_WNDPROC);
            lpColumnLB->NewTitleListboxProc = MakeProcInstance((FARPROC)ColumnLBClass_TitleListBoxWndProc, hInst);

            lpColumnLB->nColumns=1;

            lpColumnLB->yTitle = yTitle;

            //
            // init sort order
            //
            for (i=0; i < MAX_COLUMNS ; i++ )
                lpColumnLB->ColumnOrderTable[i] = i;

            //
            // sub-class the listbox window by substituting our window proc for the
            // normal one...
            //
            SetWindowLongPtr(hwndList, GWLP_WNDPROC,(DWORD_PTR)lpColumnLB->NewListboxProc);

            //
            // sub-class the title listbox window by substituting our window proc for the
            // normal one...
            //
            SetWindowLongPtr(hwndTitleList, GWLP_WNDPROC,(DWORD_PTR)lpColumnLB->NewTitleListboxProc);

            //
            // add the lpColumnLB struct as the only item in the title listbox
            //
            ListBox_AddString(lpColumnLB->hwndTitleList, (DWORD_PTR)lpColumnLB);

            //
            // pass this on to the default window proc
            //
            return(FORWARD_WM_NCCREATE(hwnd, lpCreateStruct, DefWindowProc));
        }
        else
        {
            return(FALSE);
        }
    }
    else
        return(FALSE);
}


// ------------------------------------------------------------------
//  ColumnLBClass_OnDestroy()
//
//  Handles WM_DESTROY message
//
// HISTORY:
//  Tom Laird-McConnell   7/18/93     Created
// ------------------------------------------------------------------
void ColumnLBClass_OnDestroy(HWND hwnd)
{
    LPCOLUMNLBSTRUCT lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0);

    DestroyWindow(lpColumnLB->hwndTitleList);
    DestroyWindow(lpColumnLB->hwndList);
}

// ------------------------------------------------------------------
//  ColumnLBClass_OnNCDestroy()
//
//  Handles WM_NCDESTROY
//
// HISTORY:
//  Tom Laird-McConnell   4/18/93     Created
// ------------------------------------------------------------------
void ColumnLBClass_OnNCDestroy(HWND hwnd)
{
    LPCOLUMNLBSTRUCT lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0);
    FreeProcInstance(lpColumnLB->NewListboxProc);

    GlobalFreePtr(lpColumnLB);
}

// ------------------------------------------------------------------
//  ColumnLBClass_OnPaint()
//
//  Handles WM_PAINT message, draws column titles as appropriate...
//
// HISTORY:
//  Tom Laird-McConnell   4/18/93     Created
// ------------------------------------------------------------------
void ColumnLBClass_OnPaint(HWND hwnd)
{
    LPCOLUMNLBSTRUCT lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0);
    PAINTSTRUCT ps;
    HBRUSH  hFrameBrush, hGreyBrush;
    RECT    rect;
    HDC     hdc;
    int     ncxBorder = GetSystemMetrics(SM_CXBORDER);
    int     ncyBorder = GetSystemMetrics(SM_CYBORDER);

    BeginPaint(hwnd, (LPPAINTSTRUCT)&ps);

    // Draw border around title and listbox
    GetClientRect(hwnd, (LPRECT)&rect);

    hdc = ps.hdc;

    hFrameBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME));
    FrameRect(hdc, (LPRECT)&rect, hFrameBrush);

    // make bottom the height of a HSCROLL bar
    // make left side the width of a VSCROLL bar
    rect.top += ncyBorder;
    rect.right -= ncxBorder;
    rect.left = rect.right - GetSystemMetrics(SM_CXVSCROLL);
    rect.bottom = lpColumnLB->yTitle+ncyBorder;

    hGreyBrush = CreateSolidBrush(GetSysColor(COLOR_SCROLLBAR));
    FillRect(hdc, &rect, hGreyBrush);

    rect.right = rect.left+1;
    FillRect(hdc, &rect, hFrameBrush);

    // destroy brushes...
    DeleteBrush(hFrameBrush);
    DeleteBrush(hGreyBrush);

    EndPaint(hwnd, (LPPAINTSTRUCT)&ps);
}



// ------------------------------------------------------------------
//  ColumnLBClass_OnSize()
//
//  Handles WM_SIZE message
//
// HISTORY:
//  Tom Laird-McConnell   4/18/93     Created
// ------------------------------------------------------------------
void ColumnLBClass_OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    WORD ncxBorder;
    WORD ncyBorder;
    RECT rect;
    DWORD cxExtent;

    LPCOLUMNLBSTRUCT lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0);

    if (lpColumnLB->hwndList != (HWND)NULL)
    {
        ncxBorder = (WORD)GetSystemMetrics(SM_CXBORDER);
        ncyBorder = (WORD)GetSystemMetrics(SM_CYBORDER);

        // position title listbox at top
        MoveWindow(lpColumnLB->hwndTitleList,
                 ncxBorder,
                 ncyBorder,
                 cx-(2*ncxBorder) - GetSystemMetrics(SM_CXVSCROLL),
                 lpColumnLB->yTitle,
                 TRUE);

       // position list box below title listbox
       MoveWindow(lpColumnLB->hwndList,
                 ncxBorder,
                 lpColumnLB->yTitle + ncyBorder,
                 cx - ncxBorder,    // -(2*ncxBorder)
                 cy-lpColumnLB->yTitle - ncyBorder,
                 TRUE);

        cxExtent = ColumnLBClass_ComputeOffsets(hwnd);

        GetClientRect(hwnd, &rect);

        //
        // if the new extent is smaller then the space available, move the position
        //
        if ((DWORD)rect.right > cxExtent)
        {
// #ifdef DEBUG
//            dprintf(TEXT("Reset HSCROLL pos to far left\n"));
// #endif
            // move position to far left
            SendMessage(lpColumnLB->hwndList,
                        (lpColumnLB->fUseVlist) ? VLB_HSCROLL : WM_HSCROLL,
                        MAKEWPARAM(SB_TOP, 0), 0);

            // do the same for the title list
            SendMessage(lpColumnLB->hwndTitleList,
                        WM_HSCROLL, MAKEWPARAM(SB_TOP, 0), 0);
        }

        InvalidateRect(lpColumnLB->hwndList, NULL, TRUE);
        InvalidateRect(lpColumnLB->hwndTitleList, NULL, TRUE);
    }
    InvalidateRect(lpColumnLB->hwndTitleList, 0, TRUE);
    InvalidateRect(lpColumnLB->hwndList, 0, TRUE);
}

// ------------------------------------------------------------------
//  ColumnLBClass_OnSetFont()
//
//  Handles WM_SETFONT message
//
// HISTORY:
//  Tom Laird-McConnell   4/18/93     Created
// ------------------------------------------------------------------
void ColumnLBClass_OnSetFont(HWND hwnd, HFONT hFont, BOOL fRedraw)
{
    LPCOLUMNLBSTRUCT    lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0);
    HDC                 hdc;
    TEXTMETRIC          tm;
    RECT                rect;

    lpColumnLB->hFont = hFont;

    hdc = GetDC(hwnd);
    SelectFont(hdc, (HFONT)hFont);
    GetTextMetrics(hdc, &tm);

    //
    // forward on to listbox window
    //
    if (lpColumnLB->hwndList != (HWND)NULL)
        FORWARD_WM_SETFONT(lpColumnLB->hwndList, hFont, fRedraw, SendMessage);

    if (lpColumnLB->hwndTitleList != (HWND)NULL)
        FORWARD_WM_SETFONT(lpColumnLB->hwndTitleList, hFont, fRedraw, SendMessage);

    //
    // store text height...
    //
    lpColumnLB->yTitle = tm.tmHeight + 2*GetSystemMetrics(SM_CYBORDER);

    //
    // change height appropriately
    //
    ListBox_SetItemHeight(lpColumnLB->hwndTitleList, 0, lpColumnLB->yTitle);

    SendMessage(lpColumnLB->hwndList,
                (lpColumnLB->fUseVlist) ? VLB_SETITEMHEIGHT : LB_SETITEMHEIGHT,
                0,
                tm.tmHeight);

    //
    // since we changed the font size, forze a WM_SIZE to recalc the size of the window
    //
    GetClientRect(hwnd, &rect);
    ColumnLBClass_OnSize(hwnd, SIZE_RESTORED, rect.right-rect.left, rect.bottom-rect.top);

    ReleaseDC(hwnd, hdc);
}


// ------------------------------------------------------------------
//  ColumnLBClass_OnHScroll()
//
//
//  Handles OnHScroll messages to keep title bar in ssync with listbox...
//
// HISTORY:
//  Tom Laird-McConnell   5/1/93      Created
// ------------------------------------------------------------------
LRESULT ColumnLBClass_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos)
{
    LPCOLUMNLBSTRUCT lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0);

    long    lPos;
    WORD    nPos;
    RECT    rect;
    int     cxExtent;

    switch (code)
    {
        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            nPos = (WORD) pos;
            break;

        case SB_LINEUP:
        case SB_LINEDOWN:
        case SB_PAGEUP:
        case SB_PAGEDOWN:
        case SB_TOP:
        case SB_BOTTOM:
        case SB_ENDSCROLL:
            if (lpColumnLB->fUseVlist)
                nPos = (WORD)SendMessage(lpColumnLB->hwndList, VLB_GETSCROLLPOS, 0, 0);
            else
                nPos = (WORD) GetScrollPos((hwndCtl) ? hwndCtl : lpColumnLB->hwndList, SB_HORZ);
//              nPos = GetScrollPos(lpColumnLB->hwndList, SB_HORZ);
            break;

        default:
            return(TRUE);
    }

    GetClientRect(lpColumnLB->hwndList, (LPRECT)&rect);

    //... if it is a VLIST, then there is an error in the client calculation when it has VSCROLL bars, so
    // we need to adjust ourselves by width of VSCROLL bar...
    if (lpColumnLB->fUseVlist)
        rect.right -= GetSystemMetrics(SM_CXVSCROLL);

    cxExtent = (DWORD)SendMessage(lpColumnLB->hwndList,
                                 (lpColumnLB->fUseVlist) ? VLB_GETHORIZONTALEXTENT : LB_GETHORIZONTALEXTENT, 0, 0L);
    if (cxExtent >= rect.right)
    {
        // then the listbox size is > then client's display size
        // so we need to calculate how much is not on the client display
        cxExtent -= rect.right;
    }
    else
        // else set the amount left over to 0 to nullify (technical term) the
        // effects of this calculation...
        cxExtent = 0;

    lPos = -(((LONG)nPos*(LONG)cxExtent)/100);
    if (lPos > 0)
        lpColumnLB->xPos = 0;
    else
    if (lPos < -cxExtent)
        lpColumnLB->xPos = -cxExtent;
    else
        lpColumnLB->xPos = (int)lPos;

    return(TRUE);

}



// ------------------------------------------------------------------
//  ColumnLBClass_OnMeasureItem()
//
//
//  Handles telling the parent how to draw each column accordingly...
//
//
// HISTORY:
//  Tom Laird-McConnell   4/18/93     Created
// ------------------------------------------------------------------
void ColumnLBClass_OnMeasureItem(HWND hwnd, LPMEASUREITEMSTRUCT lpMeasureItem)
{
    LPCOLUMNLBSTRUCT    lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0L);
    TEXTMETRIC          tm;
    HDC                 hdc;

    if (lpMeasureItem->CtlID == IDL_COLUMNTITLELISTBOX)
    {
        if (lpColumnLB)
            lpMeasureItem->itemHeight = lpColumnLB->yTitle;
        else
        {
            hdc = GetDC(hwnd);
            GetTextMetrics(hdc, &tm);
            ReleaseDC(hwnd, hdc);

            lpMeasureItem->itemHeight = tm.tmHeight;
        }
    }
    else
        //
        // it should be passed to parent
        //
        FORWARD_WM_MEASUREITEM(GetParent(hwnd), lpMeasureItem, SendMessage);
}

// ------------------------------------------------------------------
//  ColumnLBClass_OnDeleteItem()
//
//
//  Handles deleting items if necessary...
//
//
// HISTORY:
//  Tom Laird-McConnell   08/18/93   Created
// ------------------------------------------------------------------
void ColumnLBClass_OnDeleteItem(HWND hwnd, const DELETEITEMSTRUCT *lpDeleteItem)
{
    LPCOLUMNLBSTRUCT    lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0L);
    LPCOLRECORD lpRecord;

    // don't actually do the delete if we are sorting...
    if (lpColumnLB->fSorting == TRUE)
        return;

    if (lpDeleteItem->CtlID == IDL_COLUMNLISTBOX)
    {
        // if the style is that the owner is handling the owner draw stuff
        // then we need to pass to the parent ELSE free our memory...
        if ((lpColumnLB) && (lpColumnLB->Style & LBS_OWNERDRAWFIXED))
            //
            // it should be passed to parent
            //
            FORWARD_WM_DELETEITEM(GetParent(hwnd), lpDeleteItem, SendMessage);
        else
            // this is our item data, so we need to free it
            if (lpDeleteItem->itemData)
            {
                lpRecord = (LPCOLRECORD)lpDeleteItem->itemData;
                // NOTE that the first pointer is actually the string buffer...
                if (lpRecord->pString[0])
                    GlobalFreePtr(lpRecord->pString[0]);
                GlobalFreePtr(lpRecord);
            }
    }
}

// ------------------------------------------------------------------
//  ColumnLBClass_OnDrawItem()
//
//
//  Handles telling the parent to draw each column accordingly...
//
//
// HISTORY:
//  Tom Laird-McConnell   4/18/93     Created
// ------------------------------------------------------------------
void ColumnLBClass_OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpDrawItem)
{
    LPCOLUMNLBSTRUCT    lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0L);
    HWND                hwndParent = GetParent(hwnd);
    BYTE                i;
    BYTE                PhysCol;
    CLBDRAWITEMSTRUCT   CLBDrawItemStruct;
    RECT                rect;
    int                 ncxBorder = GetSystemMetrics(SM_CXBORDER);
    int                 ncyBorder = GetSystemMetrics(SM_CYBORDER);
    HPEN                hFramePen;
    HPEN                hShadowPen;
    HPEN                hHighlightPen;
    HPEN                hOldPen;
    HBRUSH              hBackgroundBrush;
    DWORD               Col;
    DWORD               cyChar;
    TEXTMETRIC          tm;
    BYTE                PhysColumn;
    RECT                ClientRect;

    GetClientRect(lpDrawItem->hwndItem, &ClientRect);

    //
    // figure out which window sent us the DrawItem
    //
    switch (lpDrawItem->CtlID)
    {
        //
        // handle drawing the title listbox
        //
        case IDL_COLUMNTITLELISTBOX:
            {

                LPCOLUMNLBSTRUCT lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0);

                if (lpDrawItem->itemAction == ODA_DRAWENTIRE)
                {
                    GetTextMetrics(lpDrawItem->hDC, &tm);

                    cyChar    = tm.tmHeight;

                    //
                    // create all of our pens for our drawing
                    //
                    hHighlightPen   = CreatePen(PS_SOLID, ncyBorder, GetSysColor(COLOR_BTNHIGHLIGHT));
                    hShadowPen      = CreatePen(PS_SOLID, ncyBorder, GetSysColor(COLOR_BTNSHADOW));
                    hFramePen       = CreatePen(PS_SOLID, ncyBorder, GetSysColor(COLOR_WINDOWFRAME));

                    hBackgroundBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));

                    //
                    // get the window rect we are going to work with
                    //
                    CopyRect(&rect, &lpDrawItem->rcItem);
                    FillRect(lpDrawItem->hDC, &rect, hBackgroundBrush);

                    //
                    // Draw frame color line below title section of property window
                    //
                    hOldPen = SelectObject(lpDrawItem->hDC, hFramePen);
                    MoveToEx(lpDrawItem->hDC, rect.left, rect.bottom, NULL);
                    LineTo(lpDrawItem->hDC, rect.right, rect.bottom);

                    //
                    // we start at the current left
                    //
                    rect.top += 2*ncyBorder;

                    SetTextColor(lpDrawItem->hDC, GetSysColor(COLOR_BTNTEXT));
                    SetBkColor(lpDrawItem->hDC, GetSysColor(COLOR_BTNFACE));

                    SetBkMode(lpDrawItem->hDC, TRANSPARENT);

                    for (Col=0; Col < lpColumnLB->nColumns; Col++)
                    {
                        //
                        // get the index number of the current column
                        //
                        PhysColumn = lpColumnLB->ColumnOrderTable[Col];

                        //
                        // adjust right side to be left side plus width of current column
                        //
                        rect.right = rect.left + lpColumnLB->ColumnInfoTable[PhysColumn].Width;

                        //
                        // if the button is dpressed, then draw it that way
                        //
                        if (lpColumnLB->ColumnInfoTable[PhysColumn].fDepressed)
                        {
                            //
                            // pick the shadow pen and draw the top-left depressed
                            //
                            SelectObject(lpDrawItem->hDC, hShadowPen);
                            MoveToEx(lpDrawItem->hDC, rect.left,  rect.bottom, NULL);
                            LineTo(lpDrawItem->hDC, rect.left,  rect.top-2*ncyBorder);  // bottom-left --> top-left
                            LineTo(lpDrawItem->hDC, rect.right, rect.top-2*ncyBorder);  // top-left --> top-right

                            //
                            // pick the Frame pen and draw the Column seperater
                            //
                            SelectObject(lpDrawItem->hDC, hFramePen);
                            MoveToEx(lpDrawItem->hDC, rect.right+ncxBorder,  rect.top-2*ncyBorder, NULL);
                            LineTo(lpDrawItem->hDC, rect.right+ncxBorder,  rect.bottom);  // bottom-left --> top-left

                            //
                            // move the cursor for whitespace to draw text
                            //
                            rect.left += WHITESPACE/2;

                            // draw the title of the column in the current slot
                            DrawText(lpDrawItem->hDC,
                                    lpColumnLB->ColumnInfoTable[PhysColumn].lpTitle,
                                    -1,
                                    (LPRECT)&rect,
                                    DT_SINGLELINE | DT_LEFT | DT_TOP);
                            rect.left -= WHITESPACE/2; // restore the left position...
                        }
                        else
                        {
                            // it is not depressed, draw it normal

                            //
                            // pick the white pen and draw the top-left highlight
                            //
                            SelectObject(lpDrawItem->hDC, hHighlightPen);
                            MoveToEx(lpDrawItem->hDC, rect.left,  rect.bottom-ncyBorder, NULL);
                            LineTo(lpDrawItem->hDC, rect.left,  rect.top-2*ncyBorder);  // bottom-left --> top-left
                            LineTo(lpDrawItem->hDC, rect.right, rect.top-2*ncyBorder);  // top-left --> top-right

                            //
                            // pick the shadow pen and draw the bottom-right dark shadow
                            //
                            SelectObject(lpDrawItem->hDC, hShadowPen);
                            LineTo(lpDrawItem->hDC, rect.right, rect.bottom-ncyBorder);   // top-right --> bottom-right
                            LineTo(lpDrawItem->hDC, rect.left,  rect.bottom-ncyBorder);   // bottom-right --> bottom-left

                            //
                            // pick the Frame pen and draw the Column seperater
                            //
                            SelectObject(lpDrawItem->hDC, hFramePen);
                            MoveToEx(lpDrawItem->hDC, rect.right+ncxBorder,  rect.top-2*ncyBorder, NULL);
                            LineTo(lpDrawItem->hDC, rect.right+ncxBorder,  rect.bottom);  // bottom-left --> top-left

                            //
                            // move the cursor for whitespace to draw text
                            //
                            rect.left += WHITESPACE/4;

                            rect.top -= ncyBorder;

                            // draw the title of the column in the current slot
                            DrawText(lpDrawItem->hDC,
                                    lpColumnLB->ColumnInfoTable[PhysColumn].lpTitle,
                                    -1,
                                    (LPRECT)&rect,
                                    DT_SINGLELINE | DT_LEFT | DT_TOP);

                            rect.top += ncyBorder;
                        }

                        //
                        // adjust the left side of the rect for the width of this column
                        //
                        rect.left = rect.right+2*ncxBorder;
                    }

                    // select the original brush
                    SelectObject(lpDrawItem->hDC, hOldPen);

                    // delete my pens
                    DeletePen(hFramePen);
                    DeletePen(hHighlightPen);
                    DeletePen(hShadowPen);

                    DeleteBrush(hBackgroundBrush);
                }
            }
            break;

        //
        // handle sending CLB_DRAWITEM MESSAGES to parent
        //
        case IDL_COLUMNLISTBOX:
            {
                //
                // make a copy of the drawitem portion of the struct
                //
                memcpy(&CLBDrawItemStruct.DrawItemStruct, lpDrawItem, sizeof(DRAWITEMSTRUCT));

                //
                // fake parent window into thinking our id is the listbox
                //
                CLBDrawItemStruct.DrawItemStruct.CtlID = GetDlgCtrlID(hwnd);
                CLBDrawItemStruct.lpColOrder = lpColumnLB->ColumnOrderTable;
                CLBDrawItemStruct.nColumns = lpColumnLB->nColumns;

                CopyRect(&rect, &lpDrawItem->rcItem);

                //
                // move the cursor for whitespace to draw text
                //
                rect.left += WHITESPACE/4;

                //
                // tell the parent to draw each physical column in the appropriate rectangle
                //
                for (i=0; i < lpColumnLB->nColumns ;i++ )
                {
                    //
                    // get physical column number
                    //
                    PhysCol = lpColumnLB->ColumnOrderTable[i];

                    //
                    // massage the rect's right to be the left plus the width of the column
                    //
                    rect.right = rect.left + lpColumnLB->ColumnInfoTable[PhysCol].Width - WHITESPACE/4;

                    //
                    // copy it
                    //
                    CopyRect(&CLBDrawItemStruct.rect[i], &rect);

                    //
                    // massage the rect's left to be the right + 1
                    //
                    rect.left = rect.right + WHITESPACE/4 + 2*ncxBorder ;
                }

                if ((lpColumnLB->Style & LBS_OWNERDRAWFIXED) ||
                    (lpColumnLB->Style & VLBS_OWNERDRAWFIXED) )
                    //
                    // send a draw message with the physical column order list
                    // to the parent as they want to draw it
                    //
                    SendMessage(hwndParent, CLBN_DRAWITEM, (WPARAM)0, (WPARAM)&CLBDrawItemStruct);
                else
                {
                    //
                    // we want to draw it ourselves...
                    // NOTE: This assumes that we are LBS_HASSTRINGS and NOT LBS_OWNERDRAWFIXED
                    //
                    switch(lpDrawItem->itemAction)
                    {
                        case ODA_FOCUS:
                            DrawFocusRect(lpDrawItem->hDC,(LPRECT)&(lpDrawItem->rcItem));
                            break;

                        case ODA_DRAWENTIRE:
                        case ODA_SELECT:
                            // only if we have data...
                            if (lpDrawItem->itemData)
                            {
                                LPCOLRECORD lpColRecord = (LPCOLRECORD)lpDrawItem->itemData;

                                if ((lpColRecord == NULL) ||
                                    (lpColRecord == (LPCOLRECORD)LB_ERR))
                                    break;  // bogus data


                                // Are we highlighted? (highlit?)
                                if (lpDrawItem->itemState & ODS_SELECTED)
                                {
                                    hBackgroundBrush = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
                                    SetBkColor(lpDrawItem->hDC, GetSysColor(COLOR_HIGHLIGHT));
                                    SetTextColor(lpDrawItem->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
                                }
                                else
                                {
                                    hBackgroundBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
                                    SetBkColor(lpDrawItem->hDC, GetSysColor(COLOR_WINDOW));
                                    SetTextColor(lpDrawItem->hDC, GetSysColor(COLOR_WINDOWTEXT));
                                }
                                // FillRect(lpDrawItem->hDC,(LPRECT)&(lpDrawItem->rcItem), hBackgroundBrush);

                                //
                                // either way, draw column borders now...
                                //
                                hFramePen       = CreatePen(PS_SOLID, ncyBorder, GetSysColor(COLOR_WINDOWFRAME));

                                hOldPen = SelectObject(lpDrawItem->hDC, hFramePen);

                                //
                                // now draw each column in the approved order...
                                //
                                for (i=0; i < CLBDrawItemStruct.nColumns ; i++)
                                {
                                    //
                                    // draw line of text...
                                    //
                                    ExtTextOut(  lpDrawItem->hDC,
                                                 CLBDrawItemStruct.rect[i].left,
                                                 CLBDrawItemStruct.rect[i].top,
                                                 ETO_CLIPPED | ETO_OPAQUE,
                                                 &CLBDrawItemStruct.rect[i],
                                                 lpColRecord->pString[CLBDrawItemStruct.lpColOrder[i]],           // pointer to string
                                                 lstrlen(lpColRecord->pString[CLBDrawItemStruct.lpColOrder[i]]),   // length
                                                 (LPINT)NULL);

                                    // draw column seperator
                                    ColumnLB_DrawColumnBorder( lpDrawItem->hDC, &CLBDrawItemStruct.rect[i], ClientRect.bottom, hBackgroundBrush);
                                }

                                // restore old pen
                                SelectObject(lpDrawItem->hDC, hOldPen);

                                // destroy pen
                                DeletePen(hFramePen);

                                DeleteBrush(hBackgroundBrush);
                            }
                            break;
                    }   // end of switch on drawitem action
                }

            }
            break;
    }
}

// ------------------------------------------------------------------
//  ColumnLBClass_OnCharToItem()
//
//  Handles converting keystrokes to items
//
// HISTORY:
//  Tom Laird-McConnell   10/18/93   Created
// ------------------------------------------------------------------
int ColumnLBClass_OnCharToItem(HWND hwnd, UINT ch, HWND hwndListbox, int iCaret)
{
    LPCOLUMNLBSTRUCT lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0);
    LPCOLRECORD    lpColRecord;
    int     nCount;
    int     nCurSel;
    int     nNewSel;
    TCHAR    cKey;
    TCHAR    cLBText;

    if (hwndListbox != lpColumnLB->hwndTitleList)
    {
        RECT ClientRect;
        GetClientRect(hwnd, &ClientRect);

        //
        // if the parent is NOT ownerdraw, then we are doing it ourselves, and
        // so need to translate the WM_CHAR --> the correct item based on the
        // current sort column...
        //
        if (! (lpColumnLB->Style & (LBS_OWNERDRAWFIXED | VLBS_OWNERDRAWFIXED)) )
        {
            nCurSel  = ListBox_GetCurSel(lpColumnLB->hwndList);
            if (IsCharAlphaNumeric((TCHAR)ch))
            {
                nNewSel = nCurSel + 1;
                nCount = ListBox_GetCount(lpColumnLB->hwndList);
                cKey = (TCHAR) toupper( (TCHAR)ch );

                // loop thru items starting with the one just after
                // the current selection, until we are too far along,
                // then wrap around to the beginning and
                // keep going until we hit our original selection.
                for (; nNewSel != nCurSel ; nNewSel++ )
                {
                    // make sure that we do't try to compare at location -1
                    if( nNewSel == -1)
                        continue;

                    lpColRecord = (LPCOLRECORD)ListBox_GetItemData(lpColumnLB->hwndList, nNewSel);

                    // if this comes back as LB_ERR then we are off the end of the list
                    if( lpColRecord ==  (LPCOLRECORD)LB_ERR )
                    {
                        nNewSel = -1;   // increment will move to 0
                        continue;
                    }

                    cLBText = (TCHAR) toupper( *lpColRecord->pString[
                                           lpColumnLB->ColumnOrderTable[
                                               lpColumnLB->SortColumn ]] );

                    if ( cLBText == cKey )
                    {
                        // we found it ...
                        // change the current selection
                        if( lpColumnLB->Style & LBS_MULTIPLESEL )
                        {
                            // multiple selection LB, just move fuzzy rect
                            ListBox_SetCaretIndex(lpColumnLB->hwndList, nNewSel);

                            // BUGBUG change of caret does not have a notification?
                        }
                        else
                        {
                            // single sel LB, change the sel
                            ListBox_SetCurSel(lpColumnLB->hwndList, nNewSel);

                            // notify our parent if we need to
                            if( lpColumnLB->Style & LBS_NOTIFY )
                            {
                                SendMessage( GetParent( hwnd ),
                                   WM_COMMAND,
                                   MAKEWPARAM(  GetDlgCtrlID( hwnd), LBN_SELCHANGE),
                                   (LPARAM)hwnd);  // NOTE: substitute ourselves
                                                   // as the source of the message
                            }
                        }

                        return(-1); // we handled it...
                    }
                    else if (nNewSel == nCount-1)
                    {
                        // we have gone beyond it
                        // or are at the end of the list...

                        // we need to wrap to the beginning
                        // (this will get incremented above prior to use)
                        nNewSel = -1;
                        continue;
                    }
                }

                // we did not find our target
                return(nCurSel);
            }
            else
                // not an alphanumeric, just return the current selection
                return(nCurSel);
        }
        else
            //
            // pass on to parent as a WM_CHARTOITEM, but with the HIWORD(wParam) == SORT COLUMN
            //
            return((int)SendMessage( GetParent(hwnd),
                                CLBN_CHARTOITEM,
                                MAKEWPARAM(ch, lpColumnLB->SortColumn),
                                (LPARAM)hwnd));
    } else {

        return 0;
    }
}


// ------------------------------------------------------------------
//  ColumnLBClass_OnNumberCols()
//
//        case  CLB_GETNUMBERCOLS   :    // get the number of columns (ret=NumCols)
//        case  CLB_SETNUMBERCOLS   :    // set the number of columns (wparam=NumCols)
//
// HISTORY:
//  Tom Laird-McConnell   4/18/93     Created
// ------------------------------------------------------------------
BYTE ColumnLBClass_OnNumberCols(HWND hwnd, BYTE NewNumberCols, BOOL fSetColumns)
{
    LPCOLUMNLBSTRUCT lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0L);

    //
    // if we are modifying it
    //
    if (fSetColumns)
    {
        //
        // if the value is a new value
        //
        if (lpColumnLB->nColumns != NewNumberCols)
        {
            lpColumnLB->nColumns = NewNumberCols;

            // force a redraw of the entire columnlb...
            InvalidateRect(hwnd, NULL, TRUE);
        }
    }
    return lpColumnLB->nColumns;
}

// ------------------------------------------------------------------
//  ColumnLBClass_OnColWidth()
//
//        case  CLB_GETCOLWIDTH     :    // get a column width   (wParm=Physical Column ret=ColWidth in DU's)
//        case  CLB_SETCOLWIDTH     :    // set a column width   (wParm=Physical Column lParam=Width)
//
// HISTORY:
//  Tom Laird-McConnell   4/18/93     Created
// ------------------------------------------------------------------
int ColumnLBClass_OnColWidth(HWND hwnd, BYTE Column, int NewWidth, BOOL fSetWidth)
{
    LPCOLUMNLBSTRUCT lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0L);
    int cxExtent;
    RECT rect;

    //
    // if we are modifying it
    //
    if (fSetWidth)
    {
        //
        // if the value is a new value
        //
        if (lpColumnLB->ColumnInfoTable[Column].Width != NewWidth)
        {
            lpColumnLB->ColumnInfoTable[Column].Width = NewWidth;

            cxExtent = ColumnLBClass_ComputeOffsets(hwnd);

            GetClientRect(hwnd, &rect);

            //
            // send the message to the title listbox as well
            //
            SendMessage(lpColumnLB->hwndTitleList, LB_SETHORIZONTALEXTENT, cxExtent, 0L);

            //
            // pass it on to the child listbox, using VLB_SETHOR if appropriate...
            //
            SendMessage(lpColumnLB->hwndList,
                                 (lpColumnLB->fUseVlist) ? VLB_SETHORIZONTALEXTENT : LB_SETHORIZONTALEXTENT, cxExtent, 0L);

            //
            // if the new extent is smaller then the space available, move the position
            //
            if (rect.right > cxExtent)
            {
// #ifdef DEBUG
//                dprintf(TEXT("Reset HSCROLL pos to far left\n"));
// #endif
                // move position to far left
                SendMessage(lpColumnLB->hwndList,
                            (lpColumnLB->fUseVlist) ? VLB_HSCROLL : WM_HSCROLL,
                            MAKEWPARAM(SB_TOP, 0), 0);

                // do the same for the title list
                SendMessage(lpColumnLB->hwndTitleList,
                            WM_HSCROLL, MAKEWPARAM(SB_TOP, 0), 0);
            }

            InvalidateRect(lpColumnLB->hwndList, NULL, TRUE);
            InvalidateRect(lpColumnLB->hwndTitleList, NULL, TRUE);
        }
    }
    return (DWORD)lpColumnLB->ColumnInfoTable[Column].Width;
}

// ------------------------------------------------------------------
//  ColumnLBClass_OnColTitle()
//
//        case  CLB_GETCOLTITLE     :    // get a column's title (wParm=Physical Column, ret=Title)
//        case  CLB_SETCOLTITLE     :    // set a column's title (wParm=Physical Col, lParm=Title)
//
// HISTORY:
//  Tom Laird-McConnell   4/18/93     Created
// ------------------------------------------------------------------
LPTSTR ColumnLBClass_OnColTitle(HWND hwnd, BYTE Column, LPTSTR lpTitle, BOOL fSetTitle)
{
    LPCOLUMNLBSTRUCT lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0L);

    //
    // if we are modifying it
    //
    if (fSetTitle)
    {
        //
        // if the value is a new value
        //
        if (lpColumnLB->ColumnInfoTable[Column].lpTitle != lpTitle)
        {
            //
            // BUGBUG, is there more to do here?
            //
            lpColumnLB->ColumnInfoTable[Column].lpTitle = lpTitle;

            //
            // invalidate the title
            //
            InvalidateRect(lpColumnLB->hwndTitleList, NULL, TRUE);
        }
    }
    return (LPTSTR)lpColumnLB->ColumnInfoTable[Column].lpTitle;
}




// ------------------------------------------------------------------
//  ColumnLBClass_OnSortCol()
//
//        case  CLB_GETSORTCOL      :    // get the sort column (ret=Physical Col)
//        case  CLB_SETSORTCOL      :    // set the sort column (wParm=Physical Col)
//
// HISTORY:
//  Tom Laird-McConnell   4/18/93     Created
// ------------------------------------------------------------------
BYTE ColumnLBClass_OnSortCol(HWND hwnd, BYTE NewSortCol, BOOL fSetSortCol)
{
    LPCOLUMNLBSTRUCT lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0L);
    DWORD   nCount;
    PDWORD_PTR lpListboxContents;
    DWORD   i;
    int nCurSel;
    DWORD_PTR ItemData;
    HCURSOR hCursor;

    //
    // if we are modifying it
    //
    if (fSetSortCol)
    {
        hCursor = SetCursor(LoadCursor(0, IDC_WAIT));

        // set new sort value
        lpColumnLB->SortColumn = NewSortCol;

        // need to resort listbox
        nCount = ListBox_GetCount(lpColumnLB->hwndList);

        // need to get current select
        nCurSel = ListBox_GetCurSel(lpColumnLB->hwndList);

        // and it's item data
        ItemData = ListBox_GetItemData(lpColumnLB->hwndList, nCurSel);

        SetWindowRedraw(lpColumnLB->hwndList, FALSE);

        //
        // allocate space for the listbox contents
        //
        lpListboxContents = (PDWORD_PTR) GlobalAllocPtr(GPTR, sizeof(DWORD_PTR) * nCount);

        //
        // retrieve all of the data values
        //
        for (i=0; i<nCount; i++)
            lpListboxContents[i] = ListBox_GetItemData(lpColumnLB->hwndList, i);

        //
        // reset the listbox contents
        //
        lpColumnLB->fSorting = TRUE;    // disable deleting while sorting...
        SendMessage(lpColumnLB->hwndList, LB_RESETCONTENT, 0, 0);
        lpColumnLB->fSorting = FALSE;   // reenable it...

        //
        // now re-add all of the items, with the new sort column
        //
        for (i=0; i<nCount ; i++ )
        {
            nCurSel = ListBox_AddString(lpColumnLB->hwndList, lpListboxContents[i]);
        }

        // reselect selected item...
        for (i=0; i < nCount ; i++)
        {
            if (ItemData == (DWORD)ListBox_GetItemData(lpColumnLB->hwndList, i))
                // then select it
                ListBox_SetCurSel(lpColumnLB->hwndList, i);
        }

        GlobalFreePtr(lpListboxContents);

        SetWindowRedraw(lpColumnLB->hwndList, TRUE);

        InvalidateRect(lpColumnLB->hwndList, NULL, TRUE);

        SetCursor(hCursor);
    }
    return lpColumnLB->SortColumn;
}

// ------------------------------------------------------------------
//  ColumnLBClass_OnColOrder()
//
//        case  CLB_GETCOLORDER     :    // get the virtual order of the physical columns (ret=LPDWORD order table)
//        case  CLB_SETCOLORDER     :    // set the virtual order of the physical columns (ret=LPDWORD order table, wParamn=LPDWORD new order)
//
// HISTORY:
//  Tom Laird-McConnell   4/18/93     Created
// ------------------------------------------------------------------
LPBYTE ColumnLBClass_OnColOrder(HWND hwnd, LPBYTE NewColOrder, BOOL fSetOrder)
{
    LPCOLUMNLBSTRUCT lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0L);

    //
    // if we are modifying it
    //
    if (fSetOrder)
    {
        //
        // copy the new order over the old order
        //
        memcpy(lpColumnLB->ColumnOrderTable, NewColOrder, lpColumnLB->nColumns);

        ColumnLBClass_ComputeOffsets(hwnd);

        //
        // cause listbox to be redrawn
        //
        InvalidateRect(lpColumnLB->hwndTitleList, NULL, TRUE);
        InvalidateRect(lpColumnLB->hwndList, NULL, TRUE);
    }

    return lpColumnLB->ColumnOrderTable;
}


// ------------------------------------------------------------------
//  ColumnLBClass_OnColOffsets()
//
//        case  CLB_GETCOLOFFSETS   :    // gets the incremental col offsets (ret=LPDWORD)
//        case  CLB_SETCOLOFFSETS   :    // sets the incremental col offsets (wParam = LPDWORD)
//
// HISTORY:
//  Tom Laird-McConnell   4/18/93     Created
// ------------------------------------------------------------------
LPINT  ColumnLBClass_OnColOffsets(HWND hwnd, LPINT NewOffsetTable, BOOL fSetOffsets)
{
    LPCOLUMNLBSTRUCT lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0L);

    //
    // if we are modifying it
    //
//    if (fSetOffsets)
//    {
//        for (i=0; i < lpColumnLB->nColumns ; i++ )
//        {
//            lpColumnLB->ColumnOffsetTable[i] = NewOffsetTable[i];
//        }
//    }
    return (lpColumnLB->ColumnOffsetTable);
}

// ------------------------------------------------------------------
//  ColumnLBClass_OnAutoWidths()
//
//
//  Handles CLB_AUTOWIDTHS messages to calculate the width of each field, and
// to calculate the offsets automatically... (if column is -1 , then all columns)
// ColumnToCompute is in Physical Columns
//
// returns: The horiztonal extent of all of the columns...
//
// HISTORY:
//  Tom Laird-McConnell   5/1/93      Created
// ------------------------------------------------------------------
LRESULT ColumnLBClass_OnAutoWidth(HWND hwnd, BYTE ColumnToCompute)
{
    HDC                 hdc;
    BYTE                nColumn;
    LONG                cxExtent;
    SIZE                Size;
    TEXTMETRIC          tm;
    LPCOLUMNINFO        lpColumnInfo, lpPrevColumnInfo;

    LPCOLUMNLBSTRUCT    lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0);
    HFONT   hOldFont;
    DWORD_PTR OldStyle, NewStyle;

    hdc = GetDC(hwnd);
    GetTextMetrics(hdc, &tm);
    hOldFont = SelectFont(hdc, lpColumnLB->hFont);
    lpPrevColumnInfo = NULL;

    //
    // based on column order, compute the widths and offsets of each column
    // NOTE: nColumn is the physical column
    //
    lpColumnInfo = lpColumnLB->ColumnInfoTable;
    cxExtent = 0;
    for (nColumn=0; nColumn < lpColumnLB->nColumns; nColumn++, lpColumnInfo++)
    {
        // bail out if column title is not there...
        if ((lpColumnInfo->lpTitle == NULL) ||
            (lpColumnInfo->lpTitle[0] == '\0'))
            continue;   // try next column

        //
        // only if it is a column we are supposed to change
        //
        if ((ColumnToCompute == (BYTE)-1) ||
            (nColumn == ColumnToCompute))
        {
             GetTextExtentPoint( hdc,
                                 (LPTSTR)lpColumnInfo->lpTitle,
                                 lstrlen(lpColumnInfo->lpTitle),
                                 &Size);

             //
             // the width is the text extent of the string plus some whitespace
             //
             lpColumnInfo->Width = (WHITESPACE/2) + Size.cx;
        }
    }

    SelectFont(hdc, hOldFont);
    ReleaseDC(hwnd, hdc);

    //
    // now adjust the offsets to show new values
    //
    cxExtent = ColumnLBClass_ComputeOffsets(hwnd);

    if (lpColumnLB->fUseVlist)
        OldStyle = SendMessage(lpColumnLB->hwndList, VLB_GETLISTBOXSTYLE, 0L, 0L);
    else
        OldStyle = GetWindowLongPtr(lpColumnLB->hwndList, GWL_STYLE);

    //
    // send the message to the title listbox as well
    //
    SendMessage(lpColumnLB->hwndTitleList, LB_SETHORIZONTALEXTENT, cxExtent, 0L);

    SendMessage(lpColumnLB->hwndList,
                  (lpColumnLB->fUseVlist) ? VLB_SETHORIZONTALEXTENT : LB_SETHORIZONTALEXTENT, cxExtent, 0L);

    if (lpColumnLB->fUseVlist)
        NewStyle = SendMessage(lpColumnLB->hwndList, VLB_GETLISTBOXSTYLE, 0L, 0L);
    else
        NewStyle = GetWindowLongPtr(lpColumnLB->hwndList, GWL_STYLE);

    //
    // if the horizontal scroll bar is gone, then reset hscroll position
    //
    if ((NewStyle & WS_HSCROLL) !=
        (OldStyle & WS_HSCROLL))
    {
        // move position to far left
        SendMessage(lpColumnLB->hwndList,
                    (lpColumnLB->fUseVlist) ? VLB_HSCROLL : WM_HSCROLL,
                    MAKEWPARAM(SB_TOP, 0), 0);
    }

    InvalidateRect(lpColumnLB->hwndList, NULL, TRUE);
    InvalidateRect(lpColumnLB->hwndTitleList, NULL, TRUE);

    return(cxExtent);
}


// ------------------------------------------------------------------
//  ColumnLBClass_ComputeOffsets()
//
// returns text extent...
//
// HISTORY:
//  Tom Laird-McConnell   5/3/93     Created
// ------------------------------------------------------------------
int ColumnLBClass_ComputeOffsets(HWND hwnd)
{
    BYTE                i;
    LPCOLUMNLBSTRUCT    lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0L);
    LPINT               lpOffset;
    LPBYTE              lpOrder;
    LPCOLUMNINFO        lpColumnInfo;
    BYTE                PhysColumn;
    int                 ncxBorder = GetSystemMetrics(SM_CXBORDER);

    //
    // recalc the offsets table using the current virtual order
    //
    lpOffset = lpColumnLB->ColumnOffsetTable;
    lpOrder =  lpColumnLB->ColumnOrderTable;
    lpColumnInfo = lpColumnLB->ColumnInfoTable;
    //
    // first offset is always 0
    //
    lpOffset[0] = 0;
    for (i=1; i < lpColumnLB->nColumns + 1 ; i++ )
    {
        PhysColumn = lpOrder[i-1];

        //
        // this offset is the previous offset plus the previous width
        //
        lpOffset[i] = lpOffset[i-1] + lpColumnInfo[PhysColumn].Width + 2 * ncxBorder;
    }
    //
    // last offset is also new text extent...
    return(lpOffset[lpColumnLB->nColumns]);
}

// ------------------------------------------------------------------
//  ColumnLBClass_OnLButtonDown()
//
//  Handles WM_LBUTTONDOWN and WM_LBUTTONDBLCLK messages from the client
// area above the listbox
//
//
// HISTORY:
//  Tom Laird-McConnell   5/3/93     Created
// ------------------------------------------------------------------
void ColumnLBClass_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
    LPCOLUMNLBSTRUCT    lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0L);
    BYTE                i;
    int                 AdjustedX = x - lpColumnLB->xPos;
    HCURSOR             hCursor;
    BYTE                PhysColumn;
    BYTE                VirtColumn;
    RECT                rect;
    POINT               point;

    point.x = x;
    point.y = y;
    GetClientRect(lpColumnLB->hwndTitleList, &rect);

    // only if this is a right mouse button from
    if (PtInRect(&rect, point))
    {
        //
        // if this is a down-click, and it is on a column border, then go into resize mode
        //
        for(i=1; i < lpColumnLB->nColumns+1; i++)
        {
            //
            // check to see if this is a column offset
            //
            if ((AdjustedX > lpColumnLB->ColumnOffsetTable[i]-4) &&
                (AdjustedX < lpColumnLB->ColumnOffsetTable[i]+4))
            {
                VirtColumn = i-1;
                PhysColumn = lpColumnLB->ColumnOrderTable[VirtColumn];

                //
                // x is the right-side of the column i-1
                //
                lpColumnLB->fMouseState = MOUSE_COLUMNRESIZE;
                lpColumnLB->xPrevPos     = 0;
                lpColumnLB->ColClickStart = VirtColumn;    // virtual column
                SetCapture(hwnd);

                hCursor = LoadCursor(lpColumnLB->hInstance, TEXT("SizebarHCursor"));
                SetCursor(hCursor);
                return;
            }
#ifdef DRAG
            else
            //
            // if this is a down-click, and it is on a column title,
            //
            if ((AdjustedX > lpColumnLB->ColumnOffsetTable[i-1]) &&
                (AdjustedX < lpColumnLB->ColumnOffsetTable[i]))
            {
                //
                // whether it is a double-or single click, we need to draw down button state
                //
                VirtColumn = i-1;
                PhysColumn = lpColumnLB->ColumnOrderTable[VirtColumn];

                lpColumnLB->ColumnInfoTable[PhysColumn].fDepressed = TRUE;

                GetClientRect(lpColumnLB->hwndTitleList, &rect);
                rect.left = lpColumnLB->ColumnOffsetTable[VirtColumn] + lpColumnLB->xPos;
                rect.right = lpColumnLB->ColumnOffsetTable[VirtColumn+1] + lpColumnLB->xPos;

                //
                // if this is a double-click, AND we are in sort mode then handle this as a sort request on the
                // column double-clicked on
                //
                if (fDoubleClick)
                {
                    if (GetWindowLong(hwnd, GWL_STYLE) & LBS_SORT)
                    {
                        //
                        // then default to doing a sort
                        //
                        SendMessage(hwnd, CLB_SETSORTCOL, (WPARAM)PhysColumn, (LPARAM)0);
                    }
                    else
                    {
                        //
                        // tell parent that the user double-clicked on PhysColumn
                        //
                        SendMessage(GetParent(hwnd), CLBN_TITLEDBLCLK, (WPARAM)GetDlgCtrlID(hwnd), (LPARAM) PhysColumn);
                    }
                    //
                    // we are done with double-click, so redraw window
                    //
                    lpColumnLB->ColumnInfoTable[PhysColumn].fDepressed = FALSE;

                    InvalidateRect(lpColumnLB->hwndTitleList, &rect, FALSE);

                    return;
                }
                else
                {
                    // then go into single click mode/or column drag mode

                    //
                    // then x, y is in column i-1
                    //
                    lpColumnLB->fMouseState = MOUSE_COLUMNCLICK;
                    lpColumnLB->ColClickStart = VirtColumn;

                    CopyRect(&lpColumnLB->ColClickRect, &rect);

    //                lpColumnLB->ColClickRect.left += (lpColumnLB->ColClickRect.right - lpColumnLB->ColClickRect.left)/3;
    //                lpColumnLB->ColClickRect.right -= (lpColumnLB->ColClickRect.right - lpColumnLB->ColClickRect.left)/3;

                    SetCapture(hwnd);
                    InvalidateRect(lpColumnLB->hwndTitleList, &rect, FALSE);

                    GetWindowRect(lpColumnLB->hwndTitleList, &rect);
                    ClipCursor(&rect);
                    return;
                }
            }
#endif
        }
    }
}

// ------------------------------------------------------------------
//  ColumnLBClass_OnMouseMove()
//
//  Handles Mouse movement messages from the client
// area above the listbox
//
//
// HISTORY:
//  Tom Laird-McConnell   5/3/93     Created
// ------------------------------------------------------------------
void ColumnLBClass_OnMouseMove(HWND hwnd, int x, int y, UINT keyFlags)
{
    LPCOLUMNLBSTRUCT lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0L);
    RECT        rect;
    HDC         hdc;
    BYTE        i;
    int         AdjustedX = x - lpColumnLB->xPos;
    POINT       Point;
    HCURSOR     hCursor;

    switch (lpColumnLB->fMouseState)
    {
        case 0 :    // not in mouse mode at all, so just track changing cursor when over column border
            for(i=1; i < lpColumnLB->nColumns + 1; i++)
            {
                //
                // check to see if this is a column offset
                //
                if ((AdjustedX > lpColumnLB->ColumnOffsetTable[i]-4) &&
                    (AdjustedX < lpColumnLB->ColumnOffsetTable[i]+4))
                {
                    //
                    // it is, so set the cursor and return
                    //
                    hCursor = LoadCursor(lpColumnLB->hInstance, TEXT("SizebarHCursor"));
                    SetCursor(hCursor);
                    return;
                }
            }
            SetCursor(LoadCursor(0,IDC_ARROW));
            break;

        case MOUSE_COLUMNRESIZE:
            GetClientRect(hwnd, &rect);

            //
            // as long as we haven't moved past the previous column, and we haven't moved out of the rect
            //
            if (AdjustedX < lpColumnLB->ColumnOffsetTable[lpColumnLB->ColClickStart]+8)
            {
                x += (lpColumnLB->ColumnOffsetTable[lpColumnLB->ColClickStart]+8)-AdjustedX;
                AdjustedX = lpColumnLB->ColumnOffsetTable[lpColumnLB->ColClickStart]+8;
            }

            if (x < rect.right)
            {
                hdc = GetDC(hwnd);

                // un invert previous postion
                if (lpColumnLB->xPrevPos)
                {
                    rect.left = lpColumnLB->xPrevPos;
                    rect.right = rect.left+1;
                    InvertRect(hdc, &rect);
                }

                lpColumnLB->xPrevPos     = x;

                // invert new position
                rect.left = x;
                rect.right = rect.left+1;
                InvertRect(hdc, &rect);

                ReleaseDC(hwnd, hdc);
            }
            break;

        case MOUSE_COLUMNDRAG:
            //
            // if this is a column drag, we track the messages until the mouse has moved
            // back INTO the original column rectangle, if it does this, then we switchback to
            // COLUMNCLICK mode, until they let go, or move back out
            //
            Point.x = x;
            Point.y = y;

            GetClientRect(lpColumnLB->hwndTitleList, &rect);

            // if it is on far RIGHT generate WM_HSCROLL right message
            if (x >= rect.right-2)
            {
                SendMessage(lpColumnLB->hwndList, (lpColumnLB->fUseVlist) ? VLB_HSCROLL : WM_HSCROLL, MAKEWPARAM(SB_LINEDOWN, 0), (LPARAM)NULL);
                return;
            }

            // if it is on far RIGHT generate WM_HSCROLL left message
            if (x <= rect.left+2)
            {
                SendMessage(lpColumnLB->hwndList, (lpColumnLB->fUseVlist) ? VLB_HSCROLL : WM_HSCROLL, MAKEWPARAM(SB_LINEUP, 0), (LPARAM)NULL);
                return;
            }

//            rect.right -= lpColumnLB->xPos;
//
//            //
//            // it if is out of the title area, or if it is in the original column
//            //
//            if ((PtInRect(&lpColumnLB->ColClickRect, Point) == TRUE) ||     // original column
//                (PtInRect(&rect, Point) == FALSE) )                         // title area
//            {
//                //
//                // then it has moved back into the original column, switch to
//                //COLUMNCLICK mode
//                //
//                lpColumnLB->fMouseState = MOUSE_COLUMNCLICK;
//
//                SetCursor(LoadCursor(0, IDC_ARROW));
//                return;
//            }
            break;

        case MOUSE_COLUMNCLICK:
            //
            // if this is a column click, we track the messages until the mouse has moved
            // outside of the original column rectangle, if it does this, then we switch to
            // COLUMNDRAG mode, until they let go, or until they move back to the original
            // column.
            //
            Point.x = x;
            Point.y = y;

            GetClientRect(lpColumnLB->hwndTitleList, &rect);
            rect.right -= lpColumnLB->xPos;

            //
            // if it is outside of the original column, and inside title area, then swtich to
            // DRAG mode
            //
            if ((PtInRect(&lpColumnLB->ColClickRect, Point) == FALSE) &&    //
                (PtInRect(&rect, Point) == TRUE) )                          // title area
            {

                //
                // then it has moved outside of the column, switch to
                //COLUMNDRAG mode
                //
                lpColumnLB->fMouseState = MOUSE_COLUMNDRAG;

                hCursor = LoadCursor(lpColumnLB->hInstance, TEXT("ColDragCursor"));
                SetCursor(hCursor);
            }
            break;
    }
}


// ------------------------------------------------------------------
//  ColumnLBClass_OnLButtonUp()
//
//  Handles WM_LBUTTONUp messages from the client
// area above the listbox
//
//
// HISTORY:
//  Tom Laird-McConnell   5/3/93     Created
// ------------------------------------------------------------------
void ColumnLBClass_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags)
{
    LPCOLUMNLBSTRUCT    lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0L);

    BYTE                PhysColumn = lpColumnLB->ColumnOrderTable[lpColumnLB->ColClickStart];
    BYTE                PhysSourceColumn;

    int                 AdjustedX = x - lpColumnLB->xPos;

    POINT               Point;

    BYTE                NewOrderTable[MAX_COLUMNS];

    LPBYTE              lpNewOrderTable = NewOrderTable;
    LPBYTE              lpOrderTable = lpColumnLB->ColumnOrderTable;


    BYTE                CurrentCol;
    BYTE                DestCol;
    BYTE                SourceCol;
    TCHAR               Direction;

    BYTE                i;
    HDC                 hdc;
    RECT                rect;


    SetCursor(LoadCursor(0, IDC_ARROW)); // go back to arrow

    switch (lpColumnLB->fMouseState)
    {
        case MOUSE_COLUMNRESIZE:
            //
            // if we were in resize column mode, then resize the column to the left of the border
            //
            ReleaseCapture();
            ClipCursor(NULL);

            lpColumnLB->fMouseState = 0;

            // clean up line
            GetClientRect(hwnd, &rect);
            hdc = GetDC(hwnd);

            // massage the value to make sure it's in the right range...
            if (AdjustedX < lpColumnLB->ColumnOffsetTable[lpColumnLB->ColClickStart]+8)
                AdjustedX = lpColumnLB->ColumnOffsetTable[lpColumnLB->ColClickStart]+8;

            // un invert previous postion
            if (lpColumnLB->xPrevPos)
            {
                rect.left = lpColumnLB->xPrevPos;
                rect.right = rect.left+1;
                InvertRect(hdc, &rect);
            }

            ReleaseDC(hwnd, hdc);

            //
            // set the physical column width to be the current x position - the current virtual column offset
            //
            SendMessage(hwnd,
                        CLB_SETCOLWIDTH,
                        (WPARAM)PhysColumn,
                        (LPARAM)AdjustedX - lpColumnLB->ColumnOffsetTable[lpColumnLB->ColClickStart]);
            break;

        case MOUSE_COLUMNDRAG:

            lpColumnLB->fMouseState = 0;

            ReleaseCapture();
            ClipCursor(NULL);

            lpColumnLB->ColumnInfoTable[PhysColumn].fDepressed = FALSE;

            //
            // we need to figure out what column we ended up on
            //
            for(i=1; i < lpColumnLB->nColumns+1; i++)
            {
                //
                // if it fits in this columns area, then this is the destination column
                //
                if ((AdjustedX > lpColumnLB->ColumnOffsetTable[i-1]) &&
                    (AdjustedX < lpColumnLB->ColumnOffsetTable[i]))
                {
                    //
                    // make duplicate of the table
                    //
                    memcpy(NewOrderTable, lpOrderTable, sizeof(BYTE)*lpColumnLB->nColumns);

                    //
                    // i-1 is the destination column! (virtual)
                    //
                    SourceCol = lpColumnLB->ColClickStart;  // virtual
                    DestCol = i-1;                          // virtual
                    PhysSourceColumn = lpColumnLB->ColumnOrderTable[SourceCol];  // physical

                    Direction = (SourceCol > DestCol) ? -1 : 1;

                    CurrentCol = SourceCol;
                    while (CurrentCol != DestCol)
                    {
                        NewOrderTable[CurrentCol] = NewOrderTable[CurrentCol + Direction];
                        CurrentCol += Direction;
                    }

                    //
                    // ok, it's equal to destination, so let's put the source Physical value into the destination
                    //
                    NewOrderTable[CurrentCol] = PhysSourceColumn;

                    //
                    // ok, so now set the order to the new order
                    //
                    SendMessage(hwnd, CLB_SETCOLORDER, (WPARAM)0, (LPARAM)NewOrderTable);
                }
            }

            GetClientRect(lpColumnLB->hwndTitleList, &rect);
            rect.left = lpColumnLB->ColumnOffsetTable[lpColumnLB->ColClickStart] + lpColumnLB->xPos;
            rect.right = lpColumnLB->ColumnOffsetTable[lpColumnLB->ColClickStart+1] + lpColumnLB->xPos;
            InvalidateRect(lpColumnLB->hwndTitleList, &rect, FALSE);

            break;

        case MOUSE_COLUMNCLICK:
            //
            // if this is a column click, we track the messages until the mouse has moved
            //
            lpColumnLB->fMouseState = 0;

            ReleaseCapture();
            ClipCursor(NULL);

            lpColumnLB->ColumnInfoTable[PhysColumn].fDepressed = FALSE;

            GetClientRect(lpColumnLB->hwndTitleList, &rect);
            rect.left = lpColumnLB->ColumnOffsetTable[lpColumnLB->ColClickStart] + lpColumnLB->xPos;
            rect.right = lpColumnLB->ColumnOffsetTable[lpColumnLB->ColClickStart+1] + lpColumnLB->xPos;
            InvalidateRect(lpColumnLB->hwndTitleList, &rect, FALSE);

            //
            // now send a CLBN_SINGLECLICK message to the parent, only if the mousebutton was let up in the original
            // column
            //
            Point.x = AdjustedX;
            Point.y = y;
            if (PtInRect(&lpColumnLB->ColClickRect, Point) == TRUE)
                SendMessage(GetParent(hwnd), CLBN_TITLESINGLECLK, (WPARAM)GetDlgCtrlID(hwnd), (LPARAM)PhysColumn);
            return;
    }
}

// ------------------------------------------------------------------
//  ColumnLBClass_OnRButtonDown()
//
//  Handles WM_RBUTTON_DOWN messages
//  alg:
//
//  figure out where we are
//      determine listbox item
//          find height of rows
//          translate mouse Y into a row number
//          are we VLIST?
//          Yes,   Get TopIndex
//              are we Owner Draw?
//              Yes
//                  Send message to VLIST to get the data for row number
//              No
//                  item number + TopIndex is the info the parent needs.
//          No
//              item number is the info the parent needs
//      determine column
//          calc which column taking into account scrolling
//  send message to parent with info
//      The parent will receive the column in wParam and the item in lParam.  lParam
//      needs to be the item because it might be the owner draw data.
//
//
//
// HISTORY:
//  Steve Hiskey        10/19/93        Created
// ------------------------------------------------------------------
void ColumnLBClass_OnRButtonDown (HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags)
{
    LPCOLUMNLBSTRUCT    lpColumnLB = (LPCOLUMNLBSTRUCT)GetWindowLong(hwnd, 0L);
                        // get the item height here and not when the OnFont message is
                        //  processed.  ?? we get different/wrong results otherwise.
    int                 ItemHeight = (int)ListBox_GetItemHeight(hwnd,1);
    int                 Item = y / ItemHeight;
    BYTE                i;
    int                 AdjustedX = x - lpColumnLB->xPos;
    BYTE                VirtColumn;
    DWORD               TopIndex;
    CLBRBUTTONSTRUCT    RButtonStruct;
    BOOL                GotOne = FALSE;
    BOOL                fTemp;


    RButtonStruct.x = x;
    RButtonStruct.y = y + lpColumnLB->yTitle;
    RButtonStruct.hwndChild = hwnd;

    //
    // we already have the item (non VList), figure out which column
    //
    for(i=1; i < lpColumnLB->nColumns+1; i++)
    {
        if ((AdjustedX > lpColumnLB->ColumnOffsetTable[i-1]) &&
            (AdjustedX < lpColumnLB->ColumnOffsetTable[i]))
        {
            //
            // we have our column.  Get the Physical Column.  The parent of this column
            // list box know what columns are interesting... and how the physical columns
            // map to the virtual columns.
            //
            VirtColumn = i-1;
            RButtonStruct.PhysColumn = lpColumnLB->ColumnOrderTable[VirtColumn];
            GotOne = TRUE;
            break;
        }
    }
    if ( !GotOne)
        return;

    // are we VLIST?

    if ( lpColumnLB->fUseVlist )
    {
        DWORD Style;

        // are we owner draw?  If so, then we don't care about TopIndex, we just want
        // the instance data
        Style = (DWORD)SendMessage(lpColumnLB->hwndList, VLB_GETVLISTSTYLE, 0, 0L);
        if ( Style && VLBS_USEDATAVALUES )
        {
            // we are use data values.  This means that we must ask the VList for the
            // data and this is the data is the identifier of the row.  ie, the data the
            // VList stores is the structure needed to identify and display the line.

            RButtonStruct.Index = ListBox_GetItemData(lpColumnLB->hwndList, Item );

        }
        else
        {
            // we are a normal vlist box.  Get the top index and add our offset
            // from top of listbox to it.

            TopIndex = (DWORD)SendMessage(lpColumnLB->hwndList, LB_GETTOPINDEX, 0, 0L);
            RButtonStruct.Index = TopIndex + Item;
        }

    }
    else
    {
        // we are a normal list box.  We need to know what item we are looking at.
        // ask the listbox for the top index.
        TopIndex = (DWORD)SendMessage(lpColumnLB->hwndList, LB_GETTOPINDEX, 0, 0L);
        RButtonStruct.Index = TopIndex + Item;
    }

    // if they have hit rButton, we should set the focus to this item (lButton)... since
    // WE are providing the CLB_SETCURSEL, we must tell the parent... some weird rule about
    // if the user does a set cur sel, then the parent is notified, but if the parent does
    // the set cur sel, the parent is not notified... since we are neither the parent or the
    // user, we have to do both.


    // if VLIST, we need to send just the item, top TopIndex + Item...

    if ( lpColumnLB->fUseVlist )
        fTemp = ListBox_SetCurSel(lpColumnLB->hwndList, Item);
    else
        fTemp = ListBox_SetCurSel(lpColumnLB->hwndList, RButtonStruct.Index);

    if ( fTemp )
        SendMessage(GetParent(hwnd), WM_COMMAND,
                          GetDlgCtrlID( lpColumnLB->hwndList),
                          MAKELPARAM(lpColumnLB->hwndList, LBN_SELCHANGE));

    // we are ready to send which column and which row to the parent.

    SendMessage ( GetParent (hwnd), CLBN_RBUTTONDOWN, (WORD)0, (LPARAM) &RButtonStruct );

}



// ------------------------------------------------------------------
//  ColumnLBClass_DrawColumnBorder()
//
//
// HISTORY:
//  Tom Laird-McConnell 3/15/94     created
// ------------------------------------------------------------------
void ColumnLB_DrawColumnBorder(HDC hDC, RECT *lpRect, int Bottom, HBRUSH hBackgroundBrush)
{
    int ncxBorder = GetSystemMetrics(SM_CXBORDER);
    RECT rect;

    CopyRect(&rect, lpRect);

    // fill in left side of rect
    rect.right = rect.left;
    rect.left -= (WHITESPACE/4);
    FillRect(hDC, &rect, hBackgroundBrush);

    // fill in right side of rect
    rect.left = lpRect->right;
    rect.right = lpRect->right + ncxBorder;
    FillRect(hDC, &rect, hBackgroundBrush);

    // draw the line itself
    MoveToEx( hDC, rect.right, rect.top, NULL);
    LineTo( hDC, rect.right, Bottom);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\convapi.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _HCONVAPI_
#define _HCONVAPI_

#ifdef __cplusplus
extern "C"{
#endif

#include "netutil.h"
#include "filesel.h"
#include "servlist.h"
void TreeRecurseCurrentShareSet(SHARE_BUFFER *CShare);
void TreeRootInit(SHARE_BUFFER *CShare, LPTSTR NewPath);
void TreeFillRecurse(UINT Level, LPTSTR Path, DIR_BUFFER *Dir);
ULONG TotalFileSizeGet();
void FileSelect_Do(HWND hDlg, SOURCE_SERVER_BUFFER *SourceServ, SHARE_BUFFER *CShare);
#include "sbrowse.h"
#include "statbox.h"

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\error.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _HERROR_
#define _HERROR_

#ifdef __cplusplus
extern "C"{
#endif

void CriticalErrorExit(LPTSTR ErrorString);
void WarningError(LPTSTR ErrorString, ...);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\error.c ===
/*
  +-------------------------------------------------------------------------+
  |                      Error Handling Routines                            |
  +-------------------------------------------------------------------------+
  |                     (c) Copyright 1993-1994                             |
  |                          Microsoft Corp.                                |
  |                        All rights reserved                              |
  |                                                                         |
  | Program               : [Error.c]                                       |
  | Programmer            : Arthur Hanson                                   |
  | Original Program Date : [Jul 27, 1993]                                  |
  | Last Update           : [Jun 18, 1994]                                  |
  |                                                                         |
  | Version:  1.00                                                          |
  |                                                                         |
  | Description:                                                            |
  |                                                                         |
  | History:                                                                |
  |   arth  Jun 18, 1994    1.00    Original Version.                       |
  |                                                                         |
  +-------------------------------------------------------------------------+
*/

#include "globals.h"


/*+-------------------------------------------------------------------------+
  | CriticalErrorExit()
  |
  |    This should only be called when there is an unrecoverable error and
  |    the program must abort (such as running out of disk space on main
  |    system or out of memory).
  |
  |    Can't dynamically load the error string (must do this at program
  |    init), because at time or error we might not be able to load it!
  |
  +-------------------------------------------------------------------------+*/
void CriticalErrorExit(LPTSTR ErrorString) {
   MessageBox(NULL, ErrorString, Lids(IDS_E_1), MB_ICONHAND | MB_SYSTEMMODAL | MB_OK);
   exit(0);

}  // CriticalErrorExit



/*+-------------------------------------------------------------------------+
  | WarningError()
  |
  |    Pops up a warning message to the user - this should only be used
  |    when the user must be notified of something (the program stops until
  |    the user responds), but it is not so critical the the program has to
  |    abort.
  |
  |    An example of this is if a config file is corrupt and the program
  |    will ignore it.
  |
  +-------------------------------------------------------------------------+*/
void WarningError(LPTSTR ErrorString, ...) {
   static TCHAR tmpStr[TMP_STR_LEN_256];
   va_list marker;

   va_start(marker, ErrorString);
   wvsprintf(tmpStr, ErrorString, marker);
   MessageBox(NULL, tmpStr, Lids(IDS_E_2), MB_ICONHAND | MB_OK);
   va_end(marker);

} // WarningError
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\debug.h ===
#ifndef _DEBUG_
#define _DEBUG_

#ifdef __cplusplus
extern "C"{
#endif

void __cdecl dprintf(LPTSTR szFormat, ...);

#ifdef DUMP

#include "netutil.h"
#include "filesel.h"
#include "servlist.h"

void DumpConvertList(CONVERT_LIST *pConvertList);
void DumpDestServerBuffer(DEST_SERVER_BUFFER *pDestServerBuffer);
void DumpSourceServerBuffer(SOURCE_SERVER_BUFFER *pSourceServerBuffer);
void DumpDomainBuffer(DOMAIN_BUFFER *pDomainBuffer);
void DumpVirtualShareBuffer(VIRTUAL_SHARE_BUFFER *pVirtualShareBuffer);
void DumpShareList(SHARE_LIST *pShareList);
void DumpShareBuffer(SHARE_BUFFER *pShareBuffer);
void DumpDriveList(DRIVE_LIST *pDriveList);
void DumpDriveBuffer(DRIVE_BUFFER *pDriveBuffer);
void DumpDirBuffer(DIR_BUFFER *pDirBuffer);

#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\encrypt.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    encrypt.c

Abstract:

    This module implements the routines for the NetWare
    redirector to mangle an objectid, challenge key and
    password such that a NetWare server will accept the
    password as valid.

    This program uses information published in Byte Magazine.

Author:

    Colin Watson    [ColinW]    15-Mar-1993

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
// #include <nwsutil.h>
#include <usrprop.h>
#include <crypt.h>
// #include <ncpcomm.h>

#define SWAPWORD(w)         ((WORD)((w & 0xFF) << 8)|(WORD)(w >> 8))
#define SWAPLONG(l)         MAKELONG(SWAPWORD(HIWORD(l)),SWAPWORD(LOWORD(l)))

#define NCP_WELL_KNOWN_SUPERVISOR_ID            (ULONG) 0x00000001
#define NCP_WELL_KNOWN_SUPERVISOR_ID_SWAPPED    (ULONG) 0x01000000
#define NCP_WELL_KNOWN_SUPERVISOR_ID_CHICAGO    (ULONG) 0x00010000
#define NCP_WELL_KNOWN_PSERVER_ID               (ULONG) 0x00000002

#define NCP_PSERVER_SIGNATURE   L"PS_"

#define SWAP_OBJECT_ID(id) (id == NCP_WELL_KNOWN_SUPERVISOR_ID) ?           \
                                NCP_WELL_KNOWN_SUPERVISOR_ID_SWAPPED :      \
                                MAKELONG(LOWORD(id),SWAPWORD(HIWORD(id)))


UCHAR Table[] =
{0x7,0x8,0x0,0x8,0x6,0x4,0xE,0x4,0x5,0xC,0x1,0x7,0xB,0xF,0xA,0x8,
 0xF,0x8,0xC,0xC,0x9,0x4,0x1,0xE,0x4,0x6,0x2,0x4,0x0,0xA,0xB,0x9,
 0x2,0xF,0xB,0x1,0xD,0x2,0x1,0x9,0x5,0xE,0x7,0x0,0x0,0x2,0x6,0x6,
 0x0,0x7,0x3,0x8,0x2,0x9,0x3,0xF,0x7,0xF,0xC,0xF,0x6,0x4,0xA,0x0,
 0x2,0x3,0xA,0xB,0xD,0x8,0x3,0xA,0x1,0x7,0xC,0xF,0x1,0x8,0x9,0xD,
 0x9,0x1,0x9,0x4,0xE,0x4,0xC,0x5,0x5,0xC,0x8,0xB,0x2,0x3,0x9,0xE,
 0x7,0x7,0x6,0x9,0xE,0xF,0xC,0x8,0xD,0x1,0xA,0x6,0xE,0xD,0x0,0x7,
 0x7,0xA,0x0,0x1,0xF,0x5,0x4,0xB,0x7,0xB,0xE,0xC,0x9,0x5,0xD,0x1,
 0xB,0xD,0x1,0x3,0x5,0xD,0xE,0x6,0x3,0x0,0xB,0xB,0xF,0x3,0x6,0x4,
 0x9,0xD,0xA,0x3,0x1,0x4,0x9,0x4,0x8,0x3,0xB,0xE,0x5,0x0,0x5,0x2,
 0xC,0xB,0xD,0x5,0xD,0x5,0xD,0x2,0xD,0x9,0xA,0xC,0xA,0x0,0xB,0x3,
 0x5,0x3,0x6,0x9,0x5,0x1,0xE,0xE,0x0,0xE,0x8,0x2,0xD,0x2,0x2,0x0,
 0x4,0xF,0x8,0x5,0x9,0x6,0x8,0x6,0xB,0xA,0xB,0xF,0x0,0x7,0x2,0x8,
 0xC,0x7,0x3,0xA,0x1,0x4,0x2,0x5,0xF,0x7,0xA,0xC,0xE,0x5,0x9,0x3,
 0xE,0x7,0x1,0x2,0xE,0x1,0xF,0x4,0xA,0x6,0xC,0x6,0xF,0x4,0x3,0x0,
 0xC,0x0,0x3,0x6,0xF,0x8,0x7,0xB,0x2,0xD,0xC,0x6,0xA,0xA,0x8,0xD};

UCHAR Keys[32] =
{0x48,0x93,0x46,0x67,0x98,0x3D,0xE6,0x8D,
 0xB7,0x10,0x7A,0x26,0x5A,0xB9,0xB1,0x35,
 0x6B,0x0F,0xD5,0x70,0xAE,0xFB,0xAD,0x11,
 0xF4,0x47,0xDC,0xA7,0xEC,0xCF,0x50,0xC0};

#define XorArray( DEST, SRC ) {                             \
    PULONG D = (PULONG)DEST;                                \
    PULONG S = (PULONG)SRC;                                 \
    int i;                                                  \
    for ( i = 0; i <= 7 ; i++ ) {                           \
        D[i] ^= S[i];                                       \
    }                                                       \
}

int
Scramble(
    int   iSeed,
    UCHAR achBuffer[32]
    );

VOID
Shuffle(
    UCHAR *achObjectId,
    UCHAR *szUpperPassword,
    int   iPasswordLen,
    UCHAR *achOutputBuffer
    )

/*++

Routine Description:

    This routine shuffles around the object ID with the password

Arguments:

    IN achObjectId - Supplies the 4 byte user's bindery object id

    IN szUpperPassword - Supplies the user's uppercased password on the
        first call to process the password. On the second and third calls
        this parameter contains the OutputBuffer from the first call

    IN iPasswordLen - length of uppercased password

    OUT achOutputBuffer - Returns the 8 byte sub-calculation

Return Value:

    none.

--*/

{
    int     iTempIndex;
    int     iOutputIndex;
    UCHAR   achTemp[32];

    //
    //  Truncate all trailing zeros from the password.
    //

    while (iPasswordLen > 0 && szUpperPassword[iPasswordLen-1] == 0 ) {
        iPasswordLen--;
    }

    //
    //  Initialize the achTemp buffer. Initialization consists of taking
    //  the password and dividing it up into chunks of 32. Any bytes left
    //  over are the remainder and do not go into the initialization.
    //
    //  achTemp[0] = szUpperPassword[0] ^ szUpperPassword[32] ^ szUpper...
    //  achTemp[1] = szUpperPassword[1] ^ szUpperPassword[33] ^ szUpper...
    //  etc.
    //

    if ( iPasswordLen > 32) {

        //  At least one chunk of 32. Set the buffer to the first chunk.

        RtlCopyMemory( achTemp, szUpperPassword, 32 );

        szUpperPassword +=32;   //  Remove the first chunk
        iPasswordLen -=32;

        while ( iPasswordLen >= 32 ) {
            //
            //  Xor this chunk with the characters already loaded into
            //  achTemp.
            //

            XorArray( achTemp, szUpperPassword);

            szUpperPassword +=32;   //  Remove this chunk
            iPasswordLen -=32;
        }

    } else {

        //  No chunks of 32 so set the buffer to zero's

        RtlZeroMemory( achTemp, sizeof(achTemp));

    }

    //
    //  achTemp is now initialized. Load the remainder into achTemp.
    //  The remainder is repeated to fill achTemp.
    //
    //  The corresponding character from Keys is taken to seperate
    //  each repitition.
    //
    //  As an example, take the remainder "ABCDEFG". The remainder is expanded
    //  to "ABCDEFGwABCDEFGxABCDEFGyABCDEFGz" where w is Keys[7],
    //  x is Keys[15], y is Keys[23] and z is Keys[31].
    //
    //

    if (iPasswordLen > 0) {
        int iPasswordOffset = 0;
        for (iTempIndex = 0; iTempIndex < 32; iTempIndex++) {

            if (iPasswordLen == iPasswordOffset) {
                iPasswordOffset = 0;
                achTemp[iTempIndex] ^= Keys[iTempIndex];
            } else {
                achTemp[iTempIndex] ^= szUpperPassword[iPasswordOffset++];
            }
        }
    }

    //
    //  achTemp has been loaded with the users password packed into 32
    //  bytes. Now take the objectid that came from the server and use
    //  that to munge every byte in achTemp.
    //

    for (iTempIndex = 0; iTempIndex < 32; iTempIndex++)
        achTemp[iTempIndex] ^= achObjectId[ iTempIndex & 3];

    Scramble( Scramble( 0, achTemp ), achTemp );

    //
    //  Finally take pairs of bytes in achTemp and return the two
    //  nibbles obtained from Table. The pairs of bytes used
    //  are achTemp[n] and achTemp[n+16].
    //

    for (iOutputIndex = 0; iOutputIndex < 16; iOutputIndex++) {

        achOutputBuffer[iOutputIndex] =
            Table[achTemp[iOutputIndex << 1]] |
            (Table[achTemp[(iOutputIndex << 1) + 1]] << 4);
    }

    return;
}

int
Scramble(
    int   iSeed,
    UCHAR   achBuffer[32]
    )

/*++

Routine Description:

    This routine scrambles around the contents of the buffer. Each buffer
    position is updated to include the contents of at least two character
    positions plus an EncryptKey value. The buffer is processed left to right
    and so if a character position chooses to merge with a buffer position
    to its left then this buffer position will include bits derived from at
    least 3 bytes of the original buffer contents.

Arguments:

    IN iSeed
    IN OUT achBuffer[32]

Return Value:

    none.

--*/

{
    int iBufferIndex;

    for (iBufferIndex = 0; iBufferIndex < 32; iBufferIndex++) {
        achBuffer[iBufferIndex] =
            (UCHAR)(
                ((UCHAR)(achBuffer[iBufferIndex] + iSeed)) ^
                ((UCHAR)(   achBuffer[(iBufferIndex+iSeed) & 31] -
                    Keys[iBufferIndex] )));

        iSeed += achBuffer[iBufferIndex];
    }
    return iSeed;
}

NTSTATUS
ReturnNetwareForm(
    const char * pszSecretValue,
    DWORD dwUserId,
    const WCHAR * pchNWPassword,
    UCHAR * pchEncryptedNWPassword
    )

/*++

Routine Description:

    This routine takes the ObjectId and encrypts it with the user
    supplied password to develop a credential for the intermediate form.

Arguments:
    DWORD dwUserId - Supplies the 4 byte user's object id
    const WCHAR * pchNWPassword - Supplies the user's password

    UCHAR * pchEncryptedNWPassword - 16 characters where the result goes.

Return Value:

    none.

--*/

{
    DWORD          dwStatus;
    DWORD          chObjectId = SWAP_OBJECT_ID (dwUserId);
    UNICODE_STRING uniNWPassword;
    OEM_STRING     oemNWPassword;

    //
    //  shuffle actually uses 32 bytes, not just 16.  It only returns 16 though.
    //

    UCHAR          pszShuffledNWPassword[NT_OWF_PASSWORD_LENGTH * 2];

    uniNWPassword.Buffer = (WCHAR *) pchNWPassword;
    uniNWPassword.Length = (USHORT)(lstrlenW (pchNWPassword)*sizeof(WCHAR));
    uniNWPassword.MaximumLength = uniNWPassword.Length;

    if ((dwStatus = RtlUpcaseUnicodeStringToOemString (&oemNWPassword,
                                           &uniNWPassword,
                                           TRUE)) == STATUS_SUCCESS)
    {
        Shuffle((UCHAR *) &chObjectId, oemNWPassword.Buffer, oemNWPassword.Length, pszShuffledNWPassword);

        // Encrypt with LSA secret.
        dwStatus = RtlEncryptNtOwfPwdWithUserKey(
                       (PNT_OWF_PASSWORD) pszShuffledNWPassword,
                       (PUSER_SESSION_KEY) pszSecretValue,
                       (PENCRYPTED_NT_OWF_PASSWORD) pchEncryptedNWPassword);
    }

    return (dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\ctlspriv.h ===
#define STRICT

/* disable "non-standard extension" warnings in our code
#ifndef RC_INVOKED
#pragma warning(disable:4001)
#endif
 */

#include <windows.h>
#include <windowsx.h>
//#include <port1632.h>

#define OFFSETOF(x) x
#define Static

#define UNICODE_FONT_NAME   TEXT("Lucida Sans Unicode")
#define COUNTOF(x) (sizeof(x)/sizeof(*x))
#define ByteCountOf(x) ((x) * sizeof(TCHAR))
#define LONG2POINT(l, pt)   ((pt).x = (SHORT)LOWORD(l), (pt).y = (SHORT)HIWORD(l))

#include <commctrl.h>

extern HINSTANCE hInst;

BOOL FAR PASCAL InitToolbarClass(HINSTANCE hInstance);

BOOL FAR PASCAL InitStatusClass(HINSTANCE hInstance);

BOOL FAR PASCAL InitHeaderClass(HINSTANCE hInstance);

BOOL FAR PASCAL InitButtonListBoxClass(HINSTANCE hInstance);

BOOL FAR PASCAL InitTrackBar(HINSTANCE hInstance);

BOOL FAR PASCAL InitUpDownClass(HINSTANCE hInstance);

void FAR PASCAL NewSize(HWND hWnd, int nClientHeight, LONG style,
                        int left, int top, int width, int height);

#define IDS_SPACE 0x0400

/* System MenuHelp
 */
#define MH_SYSMENU      (0x8000 - MINSYSCOMMAND)
#define IDS_SYSMENU     (MH_SYSMENU-16)
#define IDS_HEADER      (MH_SYSMENU-15)
#define IDS_HEADERADJ   (MH_SYSMENU-14)
#define IDS_TOOLBARADJ  (MH_SYSMENU-13)

/* Cursor ID's
 */
#define IDC_SPLIT       100
#define IDC_MOVEBUTTON  102

#define IDC_STOP        103
#define IDC_COPY        104
#define IDC_MOVE        105

/* Icon ID's
 */
#define IDI_INSERT      150

/* AdjustDlgProc stuff
 */
#define ADJUSTDLG       200
#define IDC_BUTTONLIST  201
#define IDC_RESET       202
#define IDC_CURRENT     203
#define IDC_REMOVE      204
#define IDC_MOVEUP      205
#define IDC_MOVEDOWN    206

/* bitmap IDs
 */

#define IDB_THUMB       300

/* These are the internal structures used for a status bar.  The header
 * bar code needs this also
 */
typedef struct tagSTRINGINFO
{
    LPTSTR  pString;
    UINT    uType;
    int     right;
} STRINGINFO, *PSTRINGINFO;

typedef struct tagSTATUSINFO
{
    HFONT      hStatFont;
    BOOL       bDefFont;

    int        nFontHeight;
    int        nMinHeight;
    int        nBorderX, nBorderY, nBorderPart;

    STRINGINFO sSimple;

    int        nParts;
    STRINGINFO sInfo[1];

} STATUSINFO, *PSTATUSINFO;

#define GWL_PSTATUSINFO    0        /* Window word index for status info */
#define SBT_NOSIMPLE       0x00ff   /* Flags to indicate normal status bar */

/* This is the default status bar face name
 */
extern TCHAR szSansSerif[];

/* Note that window procedures in protect mode only DLL's may be called
 * directly.
 */
void FAR PASCAL PaintStatusWnd(HWND hWnd, PSTATUSINFO pStatusInfo,
      PSTRINGINFO pStringInfo, int nParts, int nBorderX, BOOL bHeader);
LRESULT CALLBACK StatusWndProc(HWND hWnd, UINT uMessage, WPARAM wParam,
      LPARAM lParam);

/* toolbar.c */
#define GWL_PTBSTATE 0

typedef struct tagTBBMINFO     /* info for recreating the bitmaps */
{
    int        nButtons;
    HINSTANCE  hInst;
    WORD       wID;
    HBITMAP    hbm;

} TBBMINFO, NEAR *PTBBMINFO;

typedef struct tagTBSTATE      /* instance data for toolbar window */
{
    PTBBUTTON pCaptureButton;
    HWND      hdlgCust;
    HWND      hwndCommand;
    int       nBitmaps;
    PTBBMINFO pBitmaps;
    int       iNumButtons;
    int       nSysColorChanges;
    TBBUTTON  Buttons[1];

} TBSTATE, NEAR *PTBSTATE;

extern HBITMAP FAR PASCAL SelectBM(HDC hDC, PTBSTATE pTBState, int nButton);
extern void FAR PASCAL DrawButton(HDC hdc, int x, int y, int dx, int dy,
      PTBSTATE pTBState, PTBBUTTON ptButton);
extern int FAR PASCAL TBHitTest(PTBSTATE pTBState, int xPos, int yPos);
extern int FAR PASCAL PositionFromID(PTBSTATE pTBState, int id);

/* tbcust.c */
extern BOOL FAR PASCAL SaveRestore(HWND hWnd, PTBSTATE pTBState, BOOL bWrite,
      LPTSTR FAR *lpNames);
extern void FAR PASCAL CustomizeTB(HWND hWnd, PTBSTATE pTBState, int iPos);
extern void FAR PASCAL MoveButton(HWND hwndToolbar, PTBSTATE pTBState,
      int nSource);


/* cutils.c */
void FAR PASCAL NewSize(HWND hWnd, int nHeight, LONG style, int left, int top, int width, int height);
BOOL FAR PASCAL CreateDitherBrush(BOOL bIgnoreCount);   /* creates hbrDither */
BOOL FAR PASCAL FreeDitherBrush(void);
void FAR PASCAL CreateThumb(BOOL bIgnoreCount);
void FAR PASCAL DestroyThumb(void);
void FAR PASCAL CheckSysColors(void);

extern HBRUSH hbrDither;
extern HBITMAP hbmThumb;
extern int nSysColorChanges;
extern DWORD rgbFace;         // globals used a lot
extern DWORD rgbShadow;
extern DWORD rgbHilight;
extern DWORD rgbFrame;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\debug.c ===
#define DUMP // leave enabled...

#include "globals.h"
#include "switches.h"
#include <windows.h>
#include <windowsx.h>
#include <io.h>
#include <malloc.h>
#include <string.h>

#if DBG
void __cdecl dprintf(LPTSTR szFormat, ...) {
   static TCHAR tmpStr[1024];
   va_list marker;

   va_start(marker, szFormat);
   wvsprintf(tmpStr, szFormat, marker);
   OutputDebugString(tmpStr);
   va_end(marker);

} // dprintf

BOOL fDoEntireList = FALSE;

void DumpConvertList(CONVERT_LIST *pConvertList)
{
    if (pConvertList)
    {
        dprintf(
            TEXT("+++CONVERT_LIST(0x%08lx)"),
            pConvertList
            );
 
        dprintf(
            TEXT("\r\n\tnext           = 0x%08lx")
            TEXT("\r\n\tprev           = 0x%08lx")
            TEXT("\r\n\tSourceServ     = 0x%08lx")
            TEXT("\r\n\tFileServ       = 0x%08lx")
            TEXT("\r\n\tConvertOptions = 0x%08lx")
            TEXT("\r\n\tFileOptions    = 0x%08lx\r\n"),
            pConvertList->next,          
            pConvertList->prev,          
            pConvertList->SourceServ,    
            pConvertList->FileServ,      
            pConvertList->ConvertOptions,
            pConvertList->FileOptions   
            );

        if (pConvertList->SourceServ)
            DumpSourceServerBuffer(pConvertList->SourceServ);

        if (pConvertList->FileServ)
            DumpDestServerBuffer(pConvertList->FileServ);

        if (fDoEntireList && pConvertList->next)
            DumpConvertList(pConvertList->next);

        dprintf(
            TEXT("---CONVERT_LIST(0x%08lx)\r\n"),
            pConvertList
            );
    }
    else
        dprintf(TEXT("Null pConvertList\r\n"));

} // DumpConvertList


void DumpDestServerBuffer(DEST_SERVER_BUFFER *pDestServerBuffer)
{
    if (pDestServerBuffer)
    {
        dprintf(
            TEXT("+++DEST_SERVER_BUFFER(0x%08lx)"),
            pDestServerBuffer
            );

        dprintf(
            TEXT("\r\n\tnext        = 0x%08lx")
            TEXT("\r\n\tprev        = 0x%08lx")
            TEXT("\r\n\tIndex       = 0x%08lx")
            TEXT("\r\n\tType        = 0x%08lx")
            TEXT("\r\n\tVerMaj      = 0x%08lx")
            TEXT("\r\n\tVerMin      = 0x%08lx")
            TEXT("\r\n\tLName       = %s")
            TEXT("\r\n\tName        = %s")
            TEXT("\r\n\tShareList   = 0x%08lx")
            TEXT("\r\n\tNumVShares  = 0x%08lx")
            TEXT("\r\n\tVShareStart = 0x%08lx")
            TEXT("\r\n\tVShareEnd   = 0x%08lx")
            TEXT("\r\n\tUseCount    = 0x%08lx")
            TEXT("\r\n\tIsNTAS      = 0x%08lx")
            TEXT("\r\n\tIsFPNW      = 0x%08lx")
            TEXT("\r\n\tInDomain    = 0x%08lx")
            TEXT("\r\n\tDomain      = 0x%08lx")
            TEXT("\r\n\tDriveList   = 0x%08lx\r\n"),
            pDestServerBuffer->next,       
            pDestServerBuffer->prev,       
            pDestServerBuffer->Index,      
            pDestServerBuffer->Type,       
            pDestServerBuffer->VerMaj,     
            pDestServerBuffer->VerMin,     
            pDestServerBuffer->LName,      
            pDestServerBuffer->Name,       
            pDestServerBuffer->ShareList,  
            pDestServerBuffer->NumVShares, 
            pDestServerBuffer->VShareStart,
            pDestServerBuffer->VShareEnd,  
            pDestServerBuffer->UseCount,  
            pDestServerBuffer->IsNTAS,     
            pDestServerBuffer->IsFPNW,     
            pDestServerBuffer->InDomain,   
            pDestServerBuffer->Domain,     
            pDestServerBuffer->DriveList  
            );

        if (pDestServerBuffer->DriveList)
            DumpDriveList(pDestServerBuffer->DriveList);

        if (pDestServerBuffer->ShareList)
            DumpShareList(pDestServerBuffer->ShareList);

        if (pDestServerBuffer->VShareStart)
            DumpVirtualShareBuffer(pDestServerBuffer->VShareStart);

        if (pDestServerBuffer->Domain)
            DumpDomainBuffer(pDestServerBuffer->Domain);

        if (fDoEntireList && pDestServerBuffer->next)
            DumpDestServerBuffer(pDestServerBuffer->next);

        dprintf(
            TEXT("---DEST_SERVER_BUFFER(0x%08lx)\r\n"),
            pDestServerBuffer
            );
    }
    else 
        dprintf(TEXT("Null pDestServerBuffer\r\n"));

} // DumpDestServerBuffer


void DumpSourceServerBuffer(SOURCE_SERVER_BUFFER *pSourceServerBuffer)
{
    if (pSourceServerBuffer)
    {
        dprintf(
            TEXT("+++SOURCE_SERVER_BUFFER(0x%08lx)"),
            pSourceServerBuffer
            );

        dprintf(
            TEXT("\r\n\tnext      = 0x%08lx")
            TEXT("\r\n\tprev      = 0x%08lx")
            TEXT("\r\n\tIndex     = 0x%08lx")
            TEXT("\r\n\tType      = 0x%08lx")
            TEXT("\r\n\tVerMaj    = 0x%08lx")
            TEXT("\r\n\tVerMin    = 0x%08lx")
            TEXT("\r\n\tLName     = %s")
            TEXT("\r\n\tName      = %s")
            TEXT("\r\n\tShareList = 0x%08lx\r\n"),
            pSourceServerBuffer->next,     
            pSourceServerBuffer->prev,     
            pSourceServerBuffer->Index,    
            pSourceServerBuffer->Type,     
            pSourceServerBuffer->VerMaj,   
            pSourceServerBuffer->VerMin,   
            pSourceServerBuffer->LName,    
            pSourceServerBuffer->Name,     
            pSourceServerBuffer->ShareList
            );   

        if (pSourceServerBuffer->ShareList)
            DumpShareList(pSourceServerBuffer->ShareList);

        if (fDoEntireList && pSourceServerBuffer->next)
            DumpSourceServerBuffer(pSourceServerBuffer->next);

        dprintf(
            TEXT("---SOURCE_SERVER_BUFFER(0x%08lx)\r\n"),
            pSourceServerBuffer
            );
    }
    else 
        dprintf(TEXT("Null pSourceServerBuffer\r\n"));

} // DumpSourceServerBuffer


void DumpDomainBuffer(DOMAIN_BUFFER *pDomainBuffer)
{   
    if (pDomainBuffer)
    {
        dprintf(
            TEXT("+++DOMAIN_BUFFER(0x%08lx)"),
            pDomainBuffer
            );

        dprintf(
            TEXT("\r\n\tnext     = 0x%08lx")
            TEXT("\r\n\tprev     = 0x%08lx")
            TEXT("\r\n\tIndex    = 0x%08lx")
            TEXT("\r\n\tName     = %s")
            TEXT("\r\n\tPDCName  = %s")
            TEXT("\r\n\tType     = 0x%08lx")
            TEXT("\r\n\tVerMaj   = 0x%08lx")
            TEXT("\r\n\tVerMin   = 0x%08lx")
            TEXT("\r\n\tUseCount = 0x%08lx\r\n"),
            pDomainBuffer->next,    
            pDomainBuffer->prev,    
            pDomainBuffer->Index,   
            pDomainBuffer->Name,    
            pDomainBuffer->PDCName, 
            pDomainBuffer->Type,    
            pDomainBuffer->VerMaj,  
            pDomainBuffer->VerMin,  
            pDomainBuffer->UseCount
            );

        if (fDoEntireList && pDomainBuffer->next)
            DumpDomainBuffer(pDomainBuffer->next);

        dprintf(
            TEXT("---DOMAIN_BUFFER(0x%08lx)\r\n"),
            pDomainBuffer
            );
    }
    else
        dprintf(TEXT("Null pDomainBuffer\r\n"));

} // DumpDomainBuffer


void DumpVirtualShareBuffer(VIRTUAL_SHARE_BUFFER *pVirtualShareBuffer)
{
    if (pVirtualShareBuffer)
    {
        dprintf(
            TEXT("+++VIRTUAL_SHARE_BUFFER(0x%08lx)"),
            pVirtualShareBuffer
            );

        dprintf(
            TEXT("\r\n\tVFlag    = 0x%08lx")
            TEXT("\r\n\tnext     = 0x%08lx")
            TEXT("\r\n\tprev     = 0x%08lx")
            TEXT("\r\n\tIndex    = 0x%08lx")
            TEXT("\r\n\tName     = %s")
            TEXT("\r\n\tUseCount = 0x%08lx")
            TEXT("\r\n\tPath     = %s")
            TEXT("\r\n\tDrive    = 0x%08lx\r\n"),
            pVirtualShareBuffer->VFlag,  
            pVirtualShareBuffer->next,    
            pVirtualShareBuffer->prev,    
            pVirtualShareBuffer->Index,   
            pVirtualShareBuffer->Name,    
            pVirtualShareBuffer->UseCount,
            pVirtualShareBuffer->Path,    
            pVirtualShareBuffer->Drive
            );   

        if (pVirtualShareBuffer->Drive)
            DumpDriveBuffer(pVirtualShareBuffer->Drive);

        if (fDoEntireList && pVirtualShareBuffer->next)
            DumpVirtualShareBuffer(pVirtualShareBuffer->next);        

        dprintf(
            TEXT("---VIRTUAL_SHARE_BUFFER(0x%08lx)\r\n"),
            pVirtualShareBuffer
            );
    }
    else
        dprintf(TEXT("Null pVirtualShareBuffer\r\n"));

} // DumpVirtualShareBuffer


void DumpShareList(SHARE_LIST *pShareList)
{
    ULONG index;
    if (pShareList)
    {
        dprintf(
            TEXT(">>>SHARE_LIST(0x%08lx)(%d entries, %d converting, %s)\r\n"), 
            pShareList, 
            pShareList->Count, 
            pShareList->ConvertCount, 
            pShareList->Fixup ? TEXT("FIXUP") : TEXT("NO FIXUP")
            );
        for (index = 0; index < pShareList->Count; index++ )
            DumpShareBuffer(&pShareList->SList[index]);
    }
    else
        dprintf(TEXT("Null pShareList\r\n"));

} // DumpShareList


void DumpShareBuffer(SHARE_BUFFER *pShareBuffer)
{
    if (pShareBuffer)
    {
        dprintf(
            TEXT("+++SHARE_BUFFER(0x%08lx)"),
            pShareBuffer
            );

        dprintf(
            TEXT("\r\n\tVFlag       = 0x%08lx")
            TEXT("\r\n\tIndex       = 0x%08lx")
            TEXT("\r\n\tName        = %s")
            TEXT("\r\n\tConvert     = 0x%08lx")
            TEXT("\r\n\tHiddenFiles = 0x%08lx")
            TEXT("\r\n\tSystemFiles = 0x%08lx")
            TEXT("\r\n\tToFat       = 0x%08lx")
            TEXT("\r\n\tRoot        = 0x%08lx")
            TEXT("\r\n\tDrive       = 0x%08lx")
            TEXT("\r\n\tSize        = 0x%08lx")
            TEXT("\r\n\tPath        = %s")
            TEXT("\r\n\tSubDir      = %s")
            TEXT("\r\n\tVirtual     = 0x%08lx")
            TEXT("\r\n\tDestShare   = 0x%08lx\r\n"),
            pShareBuffer->VFlag,      
            pShareBuffer->Index,      
            pShareBuffer->Name,       
            pShareBuffer->Convert,    
            pShareBuffer->HiddenFiles,
            pShareBuffer->SystemFiles,
            pShareBuffer->ToFat,      
            pShareBuffer->Root,       
            pShareBuffer->Drive,      
            pShareBuffer->Size,       
            pShareBuffer->Path,       
            pShareBuffer->SubDir,     
            pShareBuffer->Virtual,    
            pShareBuffer->DestShare
            );  

        if (pShareBuffer->Root)
            DumpDirBuffer(pShareBuffer->Root);

        if (pShareBuffer->Drive)
            DumpDriveBuffer(pShareBuffer->Drive);

        if (pShareBuffer->DestShare)
            if (!pShareBuffer->Virtual)
                DumpShareBuffer(pShareBuffer->DestShare);  
            else
                DumpVirtualShareBuffer((VIRTUAL_SHARE_BUFFER *)pShareBuffer->DestShare);

        dprintf(
            TEXT("---SHARE_BUFFER(0x%08lx)\r\n"),
            pShareBuffer
            );
    }
    else
        dprintf(TEXT("Null pShareBuffer\r\n"));

} // DumpShareBuffer


void DumpDriveList(DRIVE_LIST *pDriveList)
{
    ULONG index;
    if (pDriveList)
    {
        dprintf(TEXT(">>>DRIVE_LIST(0x%08lx)(%d entries)\r\n"), pDriveList, pDriveList->Count);
        for (index = 0; index < pDriveList->Count; index++ )
            DumpDriveBuffer(&pDriveList->DList[index]);
    }
    else
        dprintf(TEXT("Null pDriveList\r\n"));

} // DumpDriveList


void DumpDriveBuffer(DRIVE_BUFFER *pDriveBuffer)
{
    if (pDriveBuffer)
    {
        dprintf(
            TEXT("+++DRIVE_BUFFER(0x%08lx)"),
            pDriveBuffer
            );

        dprintf(
            TEXT("\r\n\tType       = 0x%08lx")
            TEXT("\r\n\tDrive      = %s")
            TEXT("\r\n\tDriveType  = %s")
            TEXT("\r\n\tName       = %s")
            TEXT("\r\n\tTotalSpace = 0x%08lx")
            TEXT("\r\n\tFreeSpace  = 0x%08lx")
            TEXT("\r\n\tAllocSpace = 0x%08lx\r\n"),
            pDriveBuffer->Type, 
            pDriveBuffer->Drive,
            pDriveBuffer->DriveType,
            pDriveBuffer->Name,
            pDriveBuffer->TotalSpace,
            pDriveBuffer->FreeSpace,
            pDriveBuffer->AllocSpace
            );

        dprintf(
            TEXT("---DRIVE_BUFFER(0x%08lx)\r\n"),
            pDriveBuffer
            );
    }
    else
        dprintf(TEXT("Null pDriveBuffer)\r\n"));    

} // DumpDriveBuffer


void DumpDirBuffer(DIR_BUFFER *pDirBuffer)
{
    if (pDirBuffer)
    {
        dprintf(
            TEXT("+++DIR_BUFFER(0x%08lx)"),
            pDirBuffer
            );

        dprintf(
            TEXT("\r\n\tName       = %s")
            TEXT("\r\n\tparent     = 0x%08lx")
            TEXT("\r\n\tLast       = 0x%08lx")
            TEXT("\r\n\tAttributes = 0x%08lx")
            TEXT("\r\n\tConvert    = 0x%08lx")
            TEXT("\r\n\tSpecial    = 0x%08lx")
            TEXT("\r\n\tDirList    = 0x%08lx")
            TEXT("\r\n\tFileList   = 0x%08lx\r\n"),
            pDirBuffer->Name,       
            pDirBuffer->parent,     
            pDirBuffer->Last,       
            pDirBuffer->Attributes, 
            pDirBuffer->Convert,    
            pDirBuffer->Special,    
            pDirBuffer->DirList,    
            pDirBuffer->FileList   
            );

//      if (pDirBuffer->DirList)
//          DumpDirList(pDirBuffer->DirList);

//      if (pDirBuffer->FileList)
//          DumpFileList(pDirBuffer->FileList);

        dprintf(
            TEXT("---DIR_BUFFER(0x%08lx)\r\n"),
            pDirBuffer
            );
    }
    else
        dprintf(TEXT("Null pDirBuffer\r\n"));

} // DumpDirBuffer
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\fastcopy.c ===
/*
  +-------------------------------------------------------------------------+
  |                      File Copying Routines                              |
  +-------------------------------------------------------------------------+
  |                     (c) Copyright 1993-1994                             |
  |                          Microsoft Corp.                                |
  |                        All rights reserved                              |
  |                                                                         |
  | Program               : [FastCopy.c]                                    |
  | Programmer            : Arthur Hanson                                   |
  | Original Program Date : [Jul 27, 1993]                                  |
  | Last Update           : [Jun 18, 1994]                                  |
  |                                                                         |
  | Version:  1.00                                                          |
  |                                                                         |
  |   Use multiple threads to whack data from one file to another           |
  |                                                                         |
  | Modifications:                                                          |
  |    18-Oct-1990 w-barry Removed 'dead' code.                             |
  |    21-Nov-1990 w-barry Updated API's to the Win32 set.                  |
  |                                                                         |
  +-------------------------------------------------------------------------+
*/

#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES

#include "globals.h"
#include <stdio.h>
#include <process.h>
#include <windows.h>
#include <malloc.h>
#include "mem.h"
#include "debug.h"
#include "utils.h"
#include "convapi.h"

#define BUFSIZE     0xFE00       //  full segment minus sector
#define STACKSIZE   256          //  stack size for child thread

typedef struct BUF BUF;

struct BUF {
    BOOL  flag;
    DWORD cbBuf;
    BUF  *fpbufNext;
    BYTE ach[BUFSIZE];
};

#define LAST    TRUE
#define NOTLAST FALSE

static HANDLE hevQNotEmpty;
static CRITICAL_SECTION  hcrtQLock;
static BUF *fpbufHead = NULL;
static BUF *fpbufTail = NULL;
static HANDLE hfSrc, hfDst;
static HANDLE hThread;
static BOOLEAN fAbort;

//  forward type definitions

LPTSTR writer( void );
DWORD reader( void );
BUF  *dequeue( void );
void  enqueue( BUF *fpbuf );
TCHAR *fastcopy( HANDLE hfSrcParm, HANDLE hfDstParm );

/*+-------------------------------------------------------------------------+
  | writer()
  |
  +-------------------------------------------------------------------------+*/
LPTSTR writer ( void ) {
    BUF *fpbuf;
    DWORD cbBytesOut;
    BOOL f = !LAST;
    LPTSTR npsz = NULL;
    ULONG BytesCopied = 0;

    TCHAR buffer[MAX_PATH];

    Status_Bytes(lToStr(BytesCopied));

    while (f != LAST && npsz == NULL) {
        fpbuf = dequeue ();

        if (fpbuf) {
           if ((f = fpbuf->flag) != LAST) {
               if (!WriteFile(hfDst, fpbuf->ach, fpbuf->cbBuf, &cbBytesOut, NULL)) {
                   npsz = Lids(IDS_L_4);
#ifdef DEBUG
dprintf(TEXT("ERROR: WriteFile\n"));
#endif
               } else {
                  BytesCopied += cbBytesOut;
                  Status_Bytes(lToStr(BytesCopied));


                  if (cbBytesOut != (DWORD)fpbuf->cbBuf) {
                     npsz = Lids(IDS_L_5);
#ifdef DEBUG
dprintf(TEXT("ERROR: WriteFile: out-of-space\n"));
#endif
                  }
               }
           }
           else
               npsz = *(LPTSTR *)fpbuf->ach;

           FreeMemory(fpbuf);

        } else {
           wsprintf (buffer, Lids(IDS_L_4), fpbuf);
#ifdef DEBUG
dprintf(TEXT("ERROR: WriteFile - FileBuffer is NULL\n"));
#endif
        }
    }

    if (f != LAST)
        fAbort = TRUE;

    WaitForSingleObject(hThread, (DWORD)-1);
    CloseHandle(hThread);
    CloseHandle(hevQNotEmpty);
    DeleteCriticalSection(&hcrtQLock);

    return (npsz);
} // writer


/*+-------------------------------------------------------------------------+
  | reader()
  |
  +-------------------------------------------------------------------------+*/
DWORD reader( void ) {
    BUF *fpbuf;
    BOOL f = !LAST;

    while (!fAbort && f != LAST) {
        if ((fpbuf = AllocMemory(sizeof(BUF))) == NULL) {
#ifdef DEBUG
dprintf(TEXT("ERROR: MemoryAlloc error %ld\n"), GetLastError());
#endif
            return(0);
        }

        f = fpbuf->flag = NOTLAST;
        if (!ReadFile(hfSrc, fpbuf->ach, BUFSIZE, &fpbuf->cbBuf, NULL) || fpbuf->cbBuf == 0) {
            f = fpbuf->flag = LAST;
            *(LPTSTR *)(fpbuf->ach) = NULL;
        }

        enqueue (fpbuf);
    }

    return(0);
} // reader


/*+-------------------------------------------------------------------------+
  | dequeue()
  |
  +-------------------------------------------------------------------------+*/
BUF *dequeue( void ) {
    BUF *fpbuf;

    while (TRUE) {
        if (fpbufHead != NULL) {
            EnterCriticalSection(&hcrtQLock);
            fpbufHead = (fpbuf = fpbufHead)->fpbufNext;

            if (fpbufTail == fpbuf)
                fpbufTail = NULL;

            LeaveCriticalSection(&hcrtQLock);
            break;
        }

        // the head pointer is null so the list is empty.  Block on eventsem 
        // until enqueue posts (ie. adds to queue)
        WaitForSingleObject(hevQNotEmpty, (DWORD)-1);
    }

    return fpbuf;
} // dequeue


/*+-------------------------------------------------------------------------+
  | enqueue()
  |
  +-------------------------------------------------------------------------+*/
void enqueue( BUF *fpbuf ) {
    fpbuf->fpbufNext = NULL;

    EnterCriticalSection(&hcrtQLock);

    if (fpbufTail == NULL)
        fpbufHead = fpbuf;
    else
        fpbufTail->fpbufNext = fpbuf;

    fpbufTail = fpbuf;
    LeaveCriticalSection(&hcrtQLock);

    SetEvent(hevQNotEmpty);
} // enqueue


/*+-------------------------------------------------------------------------+
  | fastcopy()
  |
  |  hfSrcParm       file handle to read from
  |  hfDstParm       file handle to write to
  |
  |  returns         NULL if successful
  |                  pointer to error string otherwise
  +-------------------------------------------------------------------------+*/
TCHAR *fastcopy (HANDLE hfSrcParm, HANDLE hfDstParm) {
    DWORD dwReader;

    hfSrc = hfSrcParm;
    hfDst = hfDstParm;


    hevQNotEmpty = CreateEvent(NULL, (BOOL)FALSE, (BOOL)FALSE, NULL);
    if (hevQNotEmpty == INVALID_HANDLE_VALUE)
        return NULL;

    InitializeCriticalSection(&hcrtQLock);

    fAbort = FALSE;
    hThread = CreateThread(0, STACKSIZE, (LPTHREAD_START_ROUTINE)reader, 0, 0, &dwReader);
    if (hThread == INVALID_HANDLE_VALUE) {
#ifdef DEBUG
dprintf(TEXT("ERROR: Can't create thread - FileCopy\n"));
#endif
        return Lids(IDS_L_6);
    }

    return(writer());
} // fastcopy
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\fcopy.c ===
/*++

Copyright (c) 1993-1995  Microsoft Corporation

Module Name:

   FCopy.c

Abstract:


Author:

    Arthur Hanson (arth) 16-Jun-1994

Revision History:

--*/


#include "globals.h"

#include <limits.h>

#include "nwconv.h"
#include "convapi.h"
#include "ntnetapi.h"
#include "nwnetapi.h"
#include "userdlg.h"
#include "statbox.h"
#include "filedlg.h"

//
// Defines used in CopyNode routine - used for figuring out if we are doing
// the home-directories in the MAIL sub-dir of the SYS vol.
//
#define DIR_TYPE_NORMAL 0
#define DIR_TYPE_MAIL   1
#define DIR_TYPE_LOGIN  2

static TCHAR SourcePath[MAX_UNC_PATH];
static LPTSTR spPtr;
static FILE_OPTIONS *FileOptions = NULL;
static CONVERT_OPTIONS *CurrentConvertOptions = NULL;
static ULONG Count;
static ULONG ServShareLen = 0;

static USER_LIST *Users;
static ULONG UserCount;
static GROUP_LIST *Groups;
static ULONG GroupCount;
static BOOL IsNTFSDrive;

static PSECURITY_DESCRIPTOR pSD = NULL;
static PACL pACLNew = NULL;
static PSID pSID = NULL;
static ULONG CurSizeTotal;
static ULONG CurNumFiles;
static ULONG TotalSizeTotal;
static BOOL SysRoot = FALSE;
static BOOL SysVol = FALSE;

extern UINT TotFiles;
extern TCHAR UserServerName[];

#define NWRIGHTSALL 0xFF

#define BASE_16     16

#define SWAPWORD(w)         ((WORD)((w & 0xFF) << 8)|(WORD)(w >> 8))
#define SWAPLONG(l)         MAKELONG(SWAPWORD(HIWORD(l)),SWAPWORD(LOWORD(l)))


TCHAR *fastcopy( HANDLE hfSrcParm, HANDLE hfDstParm );

USER_BUFFER *FindUserMatch(LPTSTR Name, USER_LIST *UserList, BOOL NewName);
GROUP_BUFFER *FindGroupMatch(LPTSTR Name, GROUP_LIST *GroupList, BOOL NewName);
BOOL NTFile_AccessRightsAdd(LPTSTR ServerName, LPTSTR pUserName, LPTSTR pFileName, ULONG Rights, BOOL Dir);
VOID ErrorIt(LPTSTR szFormat, ...);

TCHAR SrcPath[MAX_UNC_PATH];  // +3 for slashes
TCHAR DestPath[MAX_UNC_PATH];  // +3 for slashes


/////////////////////////////////////////////////////////////////////////
VOID 
ConvertFilesInit(
   HWND hDlg
   )

/*++

Routine Description:

   Initialization routine called before doing the file copying.  Sets up
   the information panel dialog and fills in the directory tree structures.

Arguments:


Return Value:


--*/

{
   static TCHAR NewPath[MAX_UNC_PATH];
   SOURCE_SERVER_BUFFER *SServ;
   DEST_SERVER_BUFFER *DServ;
   SHARE_LIST *ShareList;
   SHARE_BUFFER *SList;
   SHARE_BUFFER *CurrentShare;
   DRIVE_BUFFER *Drive;
   VIRTUAL_SHARE_BUFFER *VShare;
   ULONG i;

   // Just to be safe init this.
   FillDirInit();
   TotFiles = 0;
   TotalSizeTotal = 0;

   // Clear out old alloc space calculations
   DServListSpaceFree();

   CurrentConvertList = ConvertListStart;
   while (CurrentConvertList) {
      SServ = CurrentConvertList->SourceServ;
      DServ = CurrentConvertList->FileServ;
      ShareList = SServ->ShareList;

      FileOptions = (FILE_OPTIONS *) CurrentConvertList->FileOptions;
      if (FileOptions->TransferFileInfo) {
         if (ShareList) {
            SList = ShareList->SList;
            // First expand all the file trees
            for (i = 0; i < ShareList->Count; i++) {
               CurrentShare = &SList[i];
               if (CurrentShare->Convert) {
                  Panel_Line(1, Lids(IDS_D_1));
                  Panel_Line(6, TEXT("%s\\%s:"), SServ->Name, CurrentShare->Name);
                  Panel_Line(2, Lids(IDS_D_2));
                  Panel_Line(3, Lids(IDS_D_3));
                  Panel_Line(4, Lids(IDS_D_4));
                  wsprintf(NewPath, TEXT("\\\\%s\\%s\\"), SServ->Name, CurrentShare->Name);

                  if (CurrentShare->Root == NULL)
                     TreeRootInit(CurrentShare, NewPath);

                  TreeFillRecurse(1, NewPath, CurrentShare->Root);

                  // Now increment allocated space on dest drive
                  if (CurrentShare->DestShare != NULL)
                     if (CurrentShare->Virtual) {
                        VShare = (VIRTUAL_SHARE_BUFFER *) CurrentShare->DestShare;
                        Drive = VShare->Drive;

                        if (Drive != NULL)
                           Drive->AllocSpace += TotalFileSizeGet();

                     } else {
                        Drive = CurrentShare->DestShare->Drive;
                        if (Drive != NULL)
                           Drive->AllocSpace += TotalFileSizeGet();
                     }

               }
            } // expand the file trees...
         }

      } // if transfer files

      CurrentConvertList = CurrentConvertList->next;
   } // loop through servers

} // ConvertFilesInit


/////////////////////////////////////////////////////////////////////////
PSECURITY_DESCRIPTOR 
SecurityDescriptorCreate(
   LPTSTR ServerName
   )

/*++

Routine Description:

   Creates a security descriptor.

Arguments:


Return Value:


--*/

{
    DWORD cbACL = 1024;
    DWORD cbSID = 1024;
    LPTSTR lpszAccount;
    TCHAR lpszDomain[80];
    DWORD cchDomainName = 80;
    UCHAR psnuType[1024];
    ACCESS_ALLOWED_ACE *pAAAce;

    lpszAccount = Lids(IDS_S_1);

    // Initialize a new security descriptor.
    pSD = (PSECURITY_DESCRIPTOR) AllocMemory(SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (pSD == NULL)
      return NULL;

    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)) {
        FreeMemory(pSD);
        return NULL;
    }

    // Initialize a new ACL.
    pACLNew = (PACL) AllocMemory(cbACL);
    if (pACLNew == NULL) {
        goto Cleanup;
    }

    if (!InitializeAcl(pACLNew, cbACL, ACL_REVISION2)) {
        goto Cleanup;
    }

    // Retrieve the SID for UserABC.
    pSID = (PSID) AllocMemory(cbSID);
    if (pSID == NULL) {
        goto Cleanup;
    }

    if (!LookupAccountName(ServerName, lpszAccount, pSID, &cbSID,
            lpszDomain, &cchDomainName, (PSID_NAME_USE) psnuType)) {
        goto Cleanup;
    }

    // Set access permissions
    if (!AddAccessAllowedAce(pACLNew, ACL_REVISION2, GENERIC_ALL, pSID)) {
        goto Cleanup;
    }

    if (!GetAce(pACLNew, 0, (LPVOID *) &pAAAce))
        goto Cleanup;

    pAAAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
    pAAAce->Mask = GENERIC_ALL;

    // Add a new ACL to the security descriptor.
    if (!SetSecurityDescriptorDacl(pSD, TRUE, pACLNew, FALSE)) {
        goto Cleanup;
    }

    return pSD;

Cleanup:

    if (pSID != NULL)
       FreeSid(pSID);

    if(pSD != NULL)
        FreeMemory(pSD);

    if(pACLNew != NULL)
       FreeMemory(pACLNew);

    return NULL;

} // SecurityDescriptorCreate


/////////////////////////////////////////////////////////////////////////
VOID
MakeDir (
   DEST_SERVER_BUFFER *DServ, 
   VIRTUAL_SHARE_BUFFER *VShare
   )

/*++

Routine Description:

   Given a path, this will start at the root of the path and create a
   directory tree up to the ending node.

Arguments:


Return Value:


--*/

{
   static TCHAR NewPath[MAX_UNC_PATH];
   TCHAR oc;
   LPTSTR ptr;
   TCHAR ServerName[MAX_SERVER_NAME_LEN + 3];
   SECURITY_ATTRIBUTES sa;

   // First need to construct a root path in the correct form
   wsprintf(NewPath, TEXT("\\\\%s\\%s"), DServ->Name, VShare->Path);

   ptr = NewPath;
   if (*ptr == TEXT('\0'))
      return;

   // Look for ":" and change to the "$"
   while (*ptr && *ptr != TEXT(':'))
      ptr++;

   if (*ptr == TEXT(':'))
      *ptr = TEXT('$');
   else
      return;

   // Go to initial backslash (one right after drive designator)
   while (*ptr && *ptr != TEXT('\\'))
      ptr++;

   // We are pointing at the first char of the path - now loop through
   // the path - looking for each backslash and make each sub-dir
   // individually.
   while (*ptr) {
      // skip over backslash we are on
      ptr++;

      while (*ptr && *ptr != TEXT('\\'))
         ptr++;

      // sitting on next backslash - truncate path and make the dir
      oc = *ptr;
      *ptr = TEXT('\0');

      wsprintf(ServerName, TEXT("\\\\%s"), DServ->Name);
      sa.nLength = sizeof(SECURITY_ATTRIBUTES);
      sa.lpSecurityDescriptor = SecurityDescriptorCreate(ServerName);
      sa.bInheritHandle = TRUE;

      CreateDirectory(NewPath, &sa);

      // Now cleanup the allocated security stuff
      if (pSID != NULL)
         FreeSid(pSID);

      if(pSD != NULL)
         FreeMemory(pSD);

      if(pACLNew != NULL)
         FreeMemory(pACLNew);

      *ptr = oc;
   }

} // MakeDir


/////////////////////////////////////////////////////////////////////////
VOID
VSharesCreate(
   DEST_SERVER_BUFFER *DServ, 
   BOOL TConversion
   )

/*++

Routine Description:

   Given a virtual share struct, creates the share on the destination
   server, include both an NT share and FPNW share if applicable.  Will
   also create any directories to point the share at if needed.

Arguments:


Return Value:


--*/

{
   CONVERT_OPTIONS *cvo;
   VIRTUAL_SHARE_BUFFER *VShare;
   BOOL FPNWChk;

   LogWriteLog(0, Lids(IDS_L_7));
   VShare = CurrentConvertList->FileServ->VShareStart;
   cvo = (CONVERT_OPTIONS *) CurrentConvertList->ConvertOptions;

   FPNWChk = DServ->IsFPNW;

   while (VShare) {
      if (VShare->UseCount > 0) {
         LogWriteLog(1, TEXT("%s \r\n"), VShare->Name);
         LogWriteLog(2, Lids(IDS_L_8), VShare->Path);

         if (!TConversion) {
            MakeDir(DServ, VShare);
            if ((cvo->NetWareInfo) && FPNWChk)
               FPNWShareAdd(VShare->Name, VShare->Path);

            NTShareAdd(VShare->Name, VShare->Path);
         }

      }

      VShare = VShare->next;
   }

   LogWriteLog(0, Lids(IDS_CRLF));

} // VSharesCreate


/////////////////////////////////////////////////////////////////////////
VOID 
FileSecurityTransfer(
   LPTSTR SrcPath, 
   LPTSTR DestPath, 
   BOOL TConversion, 
   BOOL Dir
   )

/*++

Routine Description:

   Given a source and destination path, will take all the file permissions
   from the source and apply them to the destination.  Will automatically
   convert any user names to their new equivalence.

Arguments:


Return Value:


--*/

{
   BOOL match;
   LPTSTR fnPtr;
   USER_RIGHTS_LIST *secUsers = NULL;
   ULONG secUserCount;
   ULONG i;
   USER_BUFFER *FoundUser;
   GROUP_BUFFER *FoundGroup;
   LPTSTR NewName;
   ACCESS_MASK AccessMask;
   NTSTATUS ntstatus;
   BOOL DidEveryone = FALSE;

   fnPtr = &SrcPath[ServShareLen];
    
   lstrcat(SourcePath, fnPtr);
   ErrorItemSet(Lids(IDS_L_9), SourcePath);

#ifdef DEBUG
dprintf(TEXT("Getting Rights for: %s\n"), SourcePath);
#endif
   if (!NWFileRightsEnum(SourcePath, &secUsers, &secUserCount, (CurrentConvertList->SourceServ->VerMaj < 3))) {

      if (VerboseFileLogging() && (secUserCount > 0))
         if (Dir)
            LogWriteLog(2, Lids(IDS_L_10));
         else
            LogWriteLog(3, Lids(IDS_L_10));

      for (i = 0; i < secUserCount; i++) {
#ifdef DEBUG
         dprintf(TEXT("%s %s\n"), NWRightsLog(secUsers[i].Rights), secUsers[i].Name);
#endif

         match = FALSE;
         FoundUser = FindUserMatch(secUsers[i].Name, Users, FALSE);

         // Check if this is "EVERYONE"
         if (!lstrcmpi(secUsers[i].Name, Lids(IDS_S_31)))
            DidEveryone = TRUE;

         if (FoundUser == NULL) {
            FoundGroup = FindGroupMatch(secUsers[i].Name, Groups, FALSE);
            if (FoundGroup != NULL) {
               match = TRUE;
               NewName = FoundGroup->NewName;

            }
         } else {
            match = TRUE;
            NewName = FoundUser->NewName;
         }

         if (!match)
            NewName = NWSpecialNamesMap(secUsers[i].Name);

         // Map the NW rights to NT access mask
         AccessMask =  0x0;

         if (Dir)
            ntstatus = MapNwRightsToNTAccess(secUsers[i].Rights, &DirRightsMapping, &AccessMask);
         else
            ntstatus = MapNwRightsToNTAccess(secUsers[i].Rights, &FileRightsMapping, &AccessMask);

         if (VerboseFileLogging())
            if (Dir)
               LogWriteLog(3, TEXT("%s %-20s -> %-20s %s\r\n"), NWRightsLog(secUsers[i].Rights), secUsers[i].Name, NewName, NTAccessLog(AccessMask));
            else
               LogWriteLog(4, TEXT("%s %-20s -> %-20s %s\r\n"), NWRightsLog(secUsers[i].Rights), secUsers[i].Name, NewName, NTAccessLog(AccessMask));

         if (NT_SUCCESS(ntstatus)) {
#ifdef DEBUG
dprintf(TEXT("Server: %s\n"), UserServerName);
#endif
            if (!TConversion)
               NTFile_AccessRightsAdd(UserServerName, NewName, DestPath, AccessMask, Dir);
         }
#ifdef DEBUG
         else
            dprintf(TEXT("NwAddRight: MapNwRightsToNTAccess failed\n"));
#endif
      }

      FreeMemory(secUsers);
   }

   //
   // If this is the root of the sys vol, and the rights for Everyone weren't 
   // transferred, then Give everyone access.  NT and NetWare handle 
   // permissions a bit differently.  In NW if a user has permission
   // nested down in a sub-dir, then NW will back-port S permission down
   // to the root so the user can get access into the sub-dir.  NT does
   // access from the root up.  Giving the user RX access provides a
   // workaround.
   //
   if (SysRoot && !DidEveryone) {
      // Use "Domain Users" for the user - equiv of everyone.
      NewName = Lids(IDS_S_33);
      // Map the NW rights to NT access mask
      AccessMask =  0x0;

      ntstatus = MapNwRightsToNTAccess(NW_FILE_READ, &DirRightsMapping, &AccessMask);

      if (VerboseFileLogging())
         LogWriteLog(3, TEXT("%s %-20s -> %-20s %s\r\n"), NWRightsLog(NW_FILE_READ), Lids(IDS_S_31), NewName, NTAccessLog(AccessMask));

      if (NT_SUCCESS(ntstatus) && !TConversion)
         NTFile_AccessRightsAdd(UserServerName, NewName, DestPath, AccessMask, Dir);
   }

   // re-truncate share name
   *spPtr = TEXT('\0');

} // FileSecurityTransfer


/////////////////////////////////////////////////////////////////////////
LPTSTR 
fcopy (
   LPTSTR src, 
   LPTSTR dst
   )

/*++

Routine Description:

   fcopy (source file, destination file) copies the source to the destination
   preserving attributes and filetimes.  Returns NULL if OK or a char pointer
   to the corresponding text of the error

Arguments:


Return Value:


--*/

{
   static TCHAR fcopyErrorText[128];
   HANDLE srcfh = INVALID_HANDLE_VALUE;
   HANDLE dstfh = INVALID_HANDLE_VALUE;
   LPTSTR result = NULL;
   DWORD attribs;
   FILETIME CreationTime, LastAccessTime, LastWriteTime;

   attribs = GetFileAttributes(src);
   if (attribs == FILE_ATTRIBUTE_DIRECTORY) {
      result = Lids(IDS_L_11);
      goto done;
   }

   if( ( srcfh = CreateFile( src, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL ) ) == (HANDLE)-1 ) {
      wsprintf( fcopyErrorText, Lids(IDS_L_12), GetLastError() );
      result = fcopyErrorText;
      goto done;
   }

   if (!GetFileTime(srcfh, &CreationTime, &LastAccessTime, &LastWriteTime)) {
      result = Lids(IDS_L_13);
      goto done;
   }

   if( ( dstfh = CreateFile( dst, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, srcfh ) ) == INVALID_HANDLE_VALUE) {
      wsprintf( fcopyErrorText, Lids(IDS_L_14), GetLastError() );
      result = fcopyErrorText;
      goto done;
   }

   result = fastcopy( srcfh, dstfh );

   if( result != NULL ) {
      if (dstfh != INVALID_HANDLE_VALUE) {
          CloseHandle( dstfh );
          dstfh = INVALID_HANDLE_VALUE;
      }

      DeleteFile( dst );
      goto done;
   }

   if (!SetFileTime(dstfh, &CreationTime, &LastAccessTime, &LastWriteTime)) {
      result = Lids(IDS_L_15);
      goto done;
   }

   if (attribs != 0xFFFFFFFF)
      if (!SetFileAttributes(dst, attribs)) {
         result = Lids(IDS_L_16);
         goto done;
      }

done:
   if (srcfh != INVALID_HANDLE_VALUE)
      CloseHandle( srcfh );

   if (dstfh != INVALID_HANDLE_VALUE)
      CloseHandle( dstfh );

   return result;
} // fcopy


/////////////////////////////////////////////////////////////////////////
BOOL
LoginDirConvert(
   LPTSTR OldName,
   LPTSTR NewName
   )

/*++

Routine Description:

   We need to copy login scripts, these reside in the mail directory on
   the NetWare server.  Each user's OBJECT_ID is a sub-directory.  What
   needs to be done is scan the sub-directories and convert the 
   OBJECT_ID for each user to the corresponding new OBJECT_ID on the 
   NT Server and rename the sub-dir to this new OBJECT_ID value.  Then
   copy the files.

   The copy of the files and saving of the directory is done in 
   CopyNode, this routine converts the OBJECT-ID's.

Arguments:


Return Value:


--*/

{
   DWORD OldID, NewID;
   USER_BUFFER *FoundUser;
   char aOldName[MAX_PATH + 1];
   TCHAR OldUserName[MAX_PATH + 1];
   LPTSTR NewUserName;
   BOOL ret = TRUE;

   // 
   // Need to take several conversion steps.  We are passed in a string
   // representation of the OBJECT-ID.  This needs to be changed into
   // the new string represenation of the new OBJECT-ID as follows:
   //
   //    1.  Str-OBJECTID -> OBJECT-ID (DWORD)
   //    2.  OBJECT-ID -> Name (User Name on NW server)
   //    3.  Name -> New Name (on NT Server)
   //    4.  New Name -> OBJECT-ID (DWORD)
   //    5.  OBJECT-ID -> Str-OBJECTID
   //

   //
   // Init just in case
   //
   lstrcpy(NewName, TEXT(""));
   strcpy(aOldName, "");
   OldID = NewID = 0;

   //
   // 1.  Str-OBJECTID -> OBJECT-ID (DWORD)
   // 
   WideCharToMultiByte(CP_ACP, 0, OldName, -1, aOldName, sizeof(aOldName), NULL, NULL);
   RtlCharToInteger(aOldName, BASE_16, &OldID);
   SWAPWORDS(OldID);

   //
   // If we didn't convert it, or not an Object ID, then use original string
   //
   if (OldID == 0) {
      lstrcpy(NewName, OldName);
      ret = FALSE;
      goto LoginDirConvertExit;
   }

   //
   // 2.  OBJECT-ID -> Name (User Name on NW server)
   // 
   if (!NWObjectNameGet(OldID, OldUserName)) {
      lstrcpy(NewName, OldName);
      ret = FALSE;
      goto LoginDirConvertExit;
   }

   //
   // 3.  Name -> New Name (on NT Server)
   // 
   FoundUser = FindUserMatch(OldUserName, Users, FALSE);
   NewUserName = OldUserName;

   if (FoundUser != NULL)
      NewUserName = FoundUser->NewName;

   //
   // 4.  New Name -> OBJECT-ID (DWORD)
   // 
   NewID = NTObjectIDGet(NewUserName);

   if (NewID == 0) {
      lstrcpy(NewName, OldName);
      ret = FALSE;
      goto LoginDirConvertExit;
   }

   //
   // 5.  OBJECT-ID -> Str-OBJECTID
   // 
   wsprintf(NewName, TEXT("%lX"), MAKELONG(HIWORD(NewID),SWAPWORD(LOWORD(NewID))) );

LoginDirConvertExit:
#ifdef DEBUG
   if (ret)
      dprintf(TEXT("Converting Login Dir for [%s]: %s -> %s\n"), OldUserName, OldName, NewName);
#endif

   return ret;

}  // LoginDirConvert


/////////////////////////////////////////////////////////////////////////
VOID 
CopyNode(
   DIR_BUFFER *Dir, 
   BOOL First, 
   BOOL TConversion,
   DWORD DirType
   )

/*++

Routine Description:

   A node in this case is a sub-directory.  This is a recursive function that
   will copy all files and sub-directories under a given sub-directory.

Arguments:


Return Value:


--*/

{
   LPTSTR ErrText;
   DIR_LIST *DirList = NULL;
   FILE_LIST *FileList = NULL;
   DIR_BUFFER *DList;
   FILE_BUFFER *FList;
   LPTSTR pSrcPath, pDestPath;
   TCHAR Attributes[10];
   ULONG i;
   DWORD ChildDirType;
   DWORD attribs;

   if (Dir == NULL)
      return;

   if (!Dir->Convert)
      return;

   SysRoot = FALSE;

   // 1. Make dir if need be.
   // 2. Copy all files in this dir
   // 3. For each sub-dir recurse into this function, building up the path

   //
   // 1. Make Dir
   //
   if (!First) {
      lstrcat(SrcPath, Dir->Name);

      //
      // If a HOME directory, then we need to convert the name to the new
      // USER-ID
      //
      if (DirType == DIR_TYPE_LOGIN) {
         TCHAR NewDirName[MAX_PATH + 1];

         if (!LoginDirConvert(Dir->Name, NewDirName))
            return;

         lstrcat(DestPath, NewDirName);
      } else
         lstrcat(DestPath, Dir->Name);

      if (!TConversion) {
         attribs = GetFileAttributes(SrcPath);
         CreateDirectory(DestPath, NULL);

         if (attribs != 0xFFFFFFFF)
            SetFileAttributes(DestPath, attribs);
      }

   } else {
      lstrcat(DestPath, TEXT("\\"));

      // Check if this is the root of the sys dir (for special security transfer).
      if (SysVol)
         SysRoot = TRUE;
   }

   if (VerboseFileLogging()) {
      LogWriteLog(0, Lids(IDS_CRLF));
      LogWriteLog(2, Lids(IDS_L_17), SrcPath);
      LogWriteLog(2, Lids(IDS_L_18), DestPath);
   }

   if (IsNTFSDrive)
      FileSecurityTransfer(SrcPath, DestPath, TConversion, TRUE);

   // No need for this anymore
   SysRoot = FALSE;

   // Fixup and remember our path
   lstrcat(SrcPath, TEXT("\\"));

   if (!First)
      lstrcat(DestPath, TEXT("\\"));

   Status_ItemLabel(Lids(IDS_L_19), NicePath(50, SrcPath));

   // Remember where end of source and dest paths are - so we don't have to
   // store them on the stack all the time
   pSrcPath = SrcPath;
   while (*pSrcPath)
      pSrcPath++;

   pDestPath = DestPath;
   while (*pDestPath)
      pDestPath++;

   Status_CurNum((UINT) Count+1);

   //
   // 2. Copy All Files in this dir
   //
   FileList = Dir->FileList;
   if (FileList) {

      if (FileList->Count > 0)
         LogWriteLog(2, Lids(IDS_L_20));

      FList = FileList->FileBuffer;
      for (i = 0; i < FileList->Count; i++)
         if (FList[i].Convert) {
            ErrText = NULL;
            lstrcat(SrcPath, FList[i].Name);
            lstrcat(DestPath, FList[i].Name);
            Status_CurNum((UINT) Count+1);
#ifdef DEBUG
dprintf(TEXT("FC: %s -> %s\n"), SrcPath, DestPath);
#endif
            ErrorItemSet(Lids(IDS_L_19), SrcPath);
            Status_Item(FList[i].Name);
            TotFiles++;
            CurNumFiles++;
            Status_TotFiles(TotFiles);
            Count++;

            Status_TotBytes(lToStr(FList[i].Size));

            if (!TConversion) {
               ErrText = fcopy(SrcPath, DestPath);

               if (IsNTFSDrive)
                  FileSecurityTransfer(SrcPath, DestPath, TConversion, FALSE);
            }

            if (VerboseFileLogging()) {
               lstrcpy(Attributes, Lids(IDS_L_21));
               if (!(FList[i].Attributes & FILE_ATTRIBUTE_READONLY))
                  Attributes[1] = TEXT(' ');

               if (!(FList[i].Attributes & FILE_ATTRIBUTE_ARCHIVE))
                  Attributes[2] = TEXT(' ');

               if (!(FList[i].Attributes & FILE_ATTRIBUTE_HIDDEN))
                  Attributes[3] = TEXT(' ');

               if (!(FList[i].Attributes & FILE_ATTRIBUTE_SYSTEM))
                  Attributes[4] = TEXT(' ');

               LogWriteLog(3, TEXT("%13s %s %s\r\n"), lToStr(FList[i].Size), Attributes, FList[i].Name);
            }

            if (ErrText != NULL) {
               if (!VerboseFileLogging())
                  LogWriteLog(3, Lids(IDS_L_22), SrcPath, DestPath);

               LogWriteLog(4, TEXT("%s\r\n"), ErrText);
               ErrorIt(TEXT("%s\r\n"), ErrText);
            } else {
               CurSizeTotal += FList[i].Size;
               TotalSizeTotal += FList[i].Size;
            }

            // reset our paths to the right place
            *pSrcPath = TEXT('\0');
            *pDestPath = TEXT('\0');
         }

   }

   //
   // 3. Recurse the sub-dirs
   //
   DirList = Dir->DirList;
   if (DirList) {
      DList = DirList->DirBuffer;
      for (i = 0; i < DirList->Count; i++)
         if (DList[i].Convert) {

            //
            // Reset child dir type...
            //
            ChildDirType = DIR_TYPE_NORMAL;

            //
            // If this is the mail sub-dir, then the children are home-dirs
            //
            if (DirType == DIR_TYPE_MAIL)
               ChildDirType = DIR_TYPE_LOGIN;

            // recurse into this dir - check if this is the mail dir
            if (SysVol && First && !lstrcmpi(DList[i].Name, TEXT("MAIL")) && CurrentConvertList->FileServ->IsFPNW )
               ChildDirType = DIR_TYPE_MAIL;

            CopyNode(&DList[i], FALSE, TConversion, ChildDirType);

            // reset our paths to the right place
            *pSrcPath = TEXT('\0');
            *pDestPath = TEXT('\0');
         }
   } // Recursing Sub-dirs

} // CopyNode


/////////////////////////////////////////////////////////////////////////
VOID 
ConvertFiles(
   HWND hDlg, 
   BOOL TConversion, 
   USER_LIST *iUsers, 
   GROUP_LIST *iGroups
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   DIR_LIST *DirList = NULL;
   SOURCE_SERVER_BUFFER *SServ;
   DEST_SERVER_BUFFER *DServ;
   VIRTUAL_SHARE_BUFFER *VShare;
   SHARE_LIST *ShareList;
   SHARE_BUFFER *SList;
   SHARE_BUFFER *CurrentShare;
   ULONG i;

   Users = iUsers;
   Groups = iGroups;

   if (iUsers != NULL)
      UserCount = iUsers->Count;
   else
      UserCount = 0;

   if (iGroups != NULL)
      GroupCount = iGroups->Count;
   else
      GroupCount = 0;

   Count = 0;
   FileOptions = (FILE_OPTIONS *) CurrentConvertList->FileOptions;
   CurrentConvertOptions = (CONVERT_OPTIONS *) CurrentConvertList->ConvertOptions;
   SServ = CurrentConvertList->SourceServ;
   DServ = CurrentConvertList->FileServ;

   // Synchronize the domain
   NTDomainSynch(DServ);

   // Following steps are taken:
   //    1. Enumerate / create all virtual shares
   //    2. Enumerate volumes and destinations to convert
   //    3. Go to each volume - copy that tree

   ShareList = SServ->ShareList;

   if (VerboseFileLogging()) {
      LogWriteLog(0, Lids(IDS_LINE));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_23));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_24));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_25));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_26));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_27));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_28));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_29));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_30));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_31));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_32));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_33));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_34));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_35));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_36));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_37));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_38));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_39));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_40));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_41));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_42));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_43));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_44));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_45));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_46));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_47));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_48));
      LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_49));
      LogWriteLog(0, Lids(IDS_LINE));
   }

   LogWriteLog(0, Lids(IDS_L_20));
   Status_ConvTxt(Lids(IDS_L_50));
   Status_ItemLabel(Lids(IDS_L_51));

   if (ShareList) {
      SList = ShareList->SList;

      for (i = 0; i < ShareList->Count; i++) {
         Count = 0;
         CurrentShare = &SList[i];
         if (CurrentShare->Root)
            Status_CurTot((UINT) TreeCount(CurrentShare->Root));

         if (CurrentShare->Convert) {
            // Set root paths for this conversion
            memset(SrcPath, 0, sizeof(SrcPath));
            wsprintf(SrcPath, TEXT("\\\\%s\\%s"), SServ->Name, CurrentShare->Name);
            ServShareLen = lstrlen(SrcPath) + 1;

            // create sharename for access rights query in form of "SHARE:"
            memset(SourcePath, 0, sizeof(SourcePath));
            lstrcpy(SourcePath, CurrentShare->Name);
            lstrcat(SourcePath, TEXT(":"));

            // Check if this is the root of the sys dir (for special security transfer).
            SysVol = FALSE;
            if (!lstrcmpi(CurrentShare->Name, Lids(IDS_S_6)))
               SysVol = TRUE;

            // point spPtr to ending NULL so we can truncate it back
            spPtr = &SourcePath[lstrlen(SourcePath)];
            LogWriteSummary(0, Lids(IDS_CRLF));
            LogWriteLog(0, Lids(IDS_CRLF));
            LogWriteLog(1, Lids(IDS_L_52), CurrentShare->Name);
            LogWriteSummary(1, Lids(IDS_L_52), CurrentShare->Name);

            if (CurrentShare->Virtual) {
               VShare = (VIRTUAL_SHARE_BUFFER *) CurrentShare->DestShare;
               //
               // NOTE: The DestShare->Name may be that of the ncp server so
               // instead of formatting the destination \\server\share\<foo>,
               // which means nothing to the smb server if the share is fpnw,
               // we format the destination \\server\d$\path\<foo>.
               // 
               wsprintf(DestPath, TEXT("\\\\%s\\%s"), DServ->Name, VShare->Path);
               DestPath[2+lstrlen(DServ->Name)+1+1] = TEXT('$'); // replace ':' with '$' in unc path

               if (VShare->Drive != NULL)
                  IsNTFSDrive = (VShare->Drive->Type == DRIVE_TYPE_NTFS);
               else
                  IsNTFSDrive = FALSE;

               LogWriteLog(1, Lids(IDS_L_53), VShare->Name);
               LogWriteSummary(1, Lids(IDS_L_53), VShare->Name);
            } else {
               //
               // NOTE: The DestShare->Name may be that of the ncp server so
               // instead of formatting the destination \\server\share\<foo>,
               // which means nothing to the smb server if the share is fpnw,
               // we format the destination \\server\d$\path\<foo>.
               // 
               wsprintf(DestPath, TEXT("\\\\%s\\%s"), DServ->Name, CurrentShare->DestShare->Path);
               DestPath[2+lstrlen(DServ->Name)+1+1] = TEXT('$'); // replace ':' with '$' in unc path

               if (CurrentShare->DestShare->Drive != NULL)
                  IsNTFSDrive = (CurrentShare->DestShare->Drive->Type == DRIVE_TYPE_NTFS);
               else
                  IsNTFSDrive = FALSE;

               LogWriteLog(1, Lids(IDS_L_53), CurrentShare->DestShare->Name);
               LogWriteSummary(1, Lids(IDS_L_53), CurrentShare->DestShare->Name);
            }

            CurSizeTotal = 0;
            CurNumFiles = 0;
            CopyNode(CurrentShare->Root, TRUE, TConversion, (DWORD) DIR_TYPE_NORMAL);
            LogWriteSummary(2, Lids(IDS_L_54), lToStr(CurNumFiles));
            LogWriteSummary(2, Lids(IDS_L_55), lToStr(CurSizeTotal));

            // Whack it down to minimum size to conserve memory
            TreePrune(CurrentShare->Root);
         }
      }
   }

} // ConvertFiles
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\filedlg.c ===
/*
  +-------------------------------------------------------------------------+
  |                         File Operations                                 |
  +-------------------------------------------------------------------------+
  |                        (c) Copyright 1994                               |
  |                          Microsoft Corp.                                |
  |                        All rights reserved                              |
  |                                                                         |
  | Program               : [FileDLG.c]                                     |
  | Programmer            : Arthur Hanson                                   |
  | Original Program Date : [Feb 10, 1994]                                  |
  | Last Update           : [Jun 16, 1994]                                  |
  |                                                                         |
  | Version:  1.00                                                          |
  |                                                                         |
  | Description:                                                            |
  |                                                                         |
  | History:                                                                |
  |   arth  Feb 10, 1994    1.00    Original Version.                       |
  |                                                                         |
  +-------------------------------------------------------------------------+
*/


#include "globals.h"

#include "convapi.h"
#include "filedlg.h"
#include "ntnetapi.h"
#include "nwnetapi.h"
#include "columnlb.h"

static SOURCE_SERVER_BUFFER *SServ;
static DEST_SERVER_BUFFER *DServ;

static FILE_OPTIONS *FileOptions;
static SHARE_LIST *ShareList;
static SHARE_BUFFER *SList;
static SHARE_BUFFER *CurrentShare;
static SHARE_BUFFER *CurrentDShare;
static int SelectType;
static int NewShareType;

#define SELECT_TYPE_MODIFY 1
#define SELECT_TYPE_ADD 2

static BOOL ConvertFiles = TRUE;

void FileSelect_Do(HWND hDlg, SOURCE_SERVER_BUFFER *SourceServ, SHARE_BUFFER *CShare);
BOOL MapShare(SHARE_BUFFER *Share, DEST_SERVER_BUFFER *DServ);


/*+-------------------------------------------------------------------------+
  | FileOptionsDefaultsSet()
  |
  +-------------------------------------------------------------------------+*/
void FileOptionsDefaultsSet(void *tfo) {
   FILE_OPTIONS *fo = tfo;

   if (fo->TransferFileInfo)
      ConvertFiles = TRUE;
   else
      ConvertFiles = FALSE;

} // FileOptionsDefaultsSet


/*+-------------------------------------------------------------------------+
  | FileOptionsDefaultsReset()
  |
  +-------------------------------------------------------------------------+*/
void FileOptionsDefaultsReset() {
   ConvertFiles = TRUE;

} // FileOptionsDefaultsReset


/*+-------------------------------------------------------------------------+
  | FileOptionsInit()
  |
  +-------------------------------------------------------------------------+*/
void FileOptionsInit(void **lpfo) {
   FILE_OPTIONS *fo;

   fo = (FILE_OPTIONS *) *lpfo;

   // if we need to allocate space, do so
   if (fo == NULL)
      fo = AllocMemory(sizeof(FILE_OPTIONS));

   // make sure it was allocated
   if (fo == NULL)
      return;

   memset(fo, 0, sizeof(FILE_OPTIONS));
   fo->TransferFileInfo = ConvertFiles;
   *lpfo = (void *) fo;

} // FileOptionsInit


/*+-------------------------------------------------------------------------+
  | FileOptionsLoad()
  |
  +-------------------------------------------------------------------------+*/
void FileOptionsLoad(HANDLE hFile, void **lpfo) {
   FILE_OPTIONS *fo;
   DWORD wrote;

   fo = (FILE_OPTIONS *) *lpfo;

   // if we need to allocate space, do so
   if (fo == NULL)
      fo = AllocMemory(sizeof(FILE_OPTIONS));

   // make sure it was allocated
   if (fo == NULL)
      return;

   ReadFile(hFile, fo, sizeof(FILE_OPTIONS), &wrote, NULL);
   *lpfo = (void *) fo;

} // FileOptionsLoad


/*+-------------------------------------------------------------------------+
  | FileOptionsSave()
  |
  +-------------------------------------------------------------------------+*/
void FileOptionsSave(HANDLE hFile, void *fo) {
   DWORD wrote;

   WriteFile(hFile, fo, sizeof(FILE_OPTIONS), &wrote, NULL);

} // FileOptionsSave


/*+-------------------------------------------------------------------------+
  |                    Share Modify/Create Dialog Routines                  |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | ShareNewPathValidate()
  |
  +-------------------------------------------------------------------------+*/
BOOL ShareNewPathValidate(HWND hWnd, LPTSTR Path, DRIVE_BUFFER **pDrive) {
   VIRTUAL_SHARE_BUFFER *VShare;
   DRIVE_BUFFER *DList;
   ULONG i;
   TCHAR Drive[2];

   // must be long enough to hold drive, colon and path
   if (lstrlen(Path) < 3)
      goto ShareNewValidateFail;

   if (Path[1] != TEXT(':'))
      goto ShareNewValidateFail;

   if (Path[2] != TEXT('\\'))
      goto ShareNewValidateFail;

   if (DServ->DriveList == NULL)
      return FALSE;

   // Scan drive list looking for match to share path
   Drive[1] = TEXT('\0');
   DList = DServ->DriveList->DList;
   for (i = 0; i < DServ->DriveList->Count; i++) {
      // Get first char from path - should be drive letter
      Drive[0] = Path[0];
      if (!lstrcmpi(Drive, DList[i].Drive)) {
         // Found match
         *pDrive = &DList[i];

         if (NewShareType == SELECT_TYPE_MODIFY)
            if (CurrentDShare->VFlag) {
               VShare = (VIRTUAL_SHARE_BUFFER *) CurrentDShare;
               VShare->Drive = &DList[i];
            } else
               CurrentDShare->Drive = &DList[i];

         return TRUE;
      }
   }

ShareNewValidateFail:
   MessageBox(hWnd, Lids(IDS_E_3), Lids(IDS_E_2), MB_OK);
   return FALSE;

} // ShareNewPathValidate


/*+-------------------------------------------------------------------------+
  | ShareNewShareValidate()
  |
  +-------------------------------------------------------------------------+*/
BOOL ShareNewShareValidate(HWND hWnd, LPTSTR ShareName) {
   ULONG i;
   VIRTUAL_SHARE_BUFFER *VShare;
   SHARE_BUFFER *VList;

   // Loop through share list seeing if the share already exists (same name)
   if (DServ->ShareList != NULL) {
      VList = DServ->ShareList->SList;

      for (i = 0; i < DServ->ShareList->Count; i++)
         if (!lstrcmpi(VList[i].Name, ShareName))
            goto ShareNewShareVFail;

   }

   // Now do the same for the virtual share list
   VShare = DServ->VShareStart;
   while (VShare) {

      if (!lstrcmpi(VShare->Name, ShareName))
         goto ShareNewShareVFail;

      VShare = VShare->next;
   }

   return TRUE;

ShareNewShareVFail:
   MessageBox(hWnd, Lids(IDS_E_4), Lids(IDS_E_2), MB_OK);
   return FALSE;

} // ShareNewShareValidate


/*+-------------------------------------------------------------------------+
  | NWShareNew()
  |
  +-------------------------------------------------------------------------+*/
LRESULT CALLBACK NWShareNew(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
   HWND hCtrl;
   BOOL Enable;
   int wmId, wmEvent;
   TCHAR Path[MAX_PATH + 1];
   TCHAR NewShare[MAX_SHARE_NAME_LEN + 1];
   VIRTUAL_SHARE_BUFFER *VShare;
   DRIVE_BUFFER *Drive;
   BOOL ok;

   switch (message) {
      case WM_INITDIALOG:
         // Center the dialog over the application window
         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));

         hCtrl = GetDlgItem(hDlg, IDC_EDIT1);
         PostMessage(hCtrl, EM_LIMITTEXT, (WPARAM) MAX_SHARE_NAME_LEN, 0);
         hCtrl = GetDlgItem(hDlg, IDC_EDIT2);
         PostMessage(hCtrl, EM_LIMITTEXT, (WPARAM) MAX_PATH, 0);

         if (NewShareType == SELECT_TYPE_MODIFY) {
            SendMessage(hDlg, WM_SETTEXT, (WPARAM) 0, (LPARAM) Lids(IDS_D_5));
            hCtrl = GetDlgItem(hDlg, IDC_EDIT1);
            EnableWindow(hCtrl, FALSE);
            ShowWindow(hCtrl, SW_HIDE);

            hCtrl = GetDlgItem(hDlg, IDC_SHARENAME);
            if (CurrentDShare->VFlag) {
               VShare = (VIRTUAL_SHARE_BUFFER *) CurrentDShare;
               SendMessage(hCtrl, WM_SETTEXT, (WPARAM) 0, (LPARAM) VShare->Name);
            } else
               SendMessage(hCtrl, WM_SETTEXT, (WPARAM) 0, (LPARAM) CurrentDShare->Name);

         } else {
            hCtrl = GetDlgItem(hDlg, IDC_SHARENAME);
            EnableWindow(hCtrl, FALSE);
            ShowWindow(hCtrl, SW_HIDE);

            hCtrl = GetDlgItem(hDlg, IDOK);
            EnableWindow(hCtrl, FALSE);
         }

         PostMessage(hDlg, WM_COMMAND, ID_INIT, 0L);
         return (TRUE);

      case WM_COMMAND:
         wmId    = LOWORD(wParam);
         wmEvent = HIWORD(wParam);

         switch (wmId) {

            case IDOK:
               ok = TRUE;

               if (NewShareType == SELECT_TYPE_ADD) {
                  hCtrl = GetDlgItem(hDlg, IDC_EDIT1);
                  * (WORD *)NewShare = sizeof(NewShare);
                  SendMessage(hCtrl, EM_GETLINE, 0, (LPARAM) NewShare);

                  if (!ShareNewShareValidate(hDlg, NewShare))
                     ok = FALSE;
               }

               if (ok) {
                  hCtrl = GetDlgItem(hDlg, IDC_EDIT2);
                  * (WORD *)Path = sizeof(Path);
                  SendMessage(hCtrl, EM_GETLINE, 0, (LPARAM) Path);

                  if (!ShareNewPathValidate(hDlg, Path, &Drive))
                     ok = FALSE;
               }
               
               if (ok) {
                  if (NewShareType == SELECT_TYPE_ADD) {
                     // If we are in ADD - then we might have added a virtual
                     // share when we did the match, if so get rid of it...
                     if ((CurrentShare !=NULL) && (CurrentShare->DestShare != NULL))
                        if (CurrentShare->Virtual) {
                           VShare = (VIRTUAL_SHARE_BUFFER *) CurrentShare->DestShare;
                           VShareListDelete(DServ, VShare);
                           CurrentShare->DestShare = NULL;
                        }

                     // Got rid of old one, now need to create new one.
                     CurrentShare->Virtual = TRUE;
                     VShare = VShareListAdd(DServ, NewShare, Path);
                     VShare->Drive = Drive;
                     VShare->UseCount++;
                     CurrentShare->DestShare = (SHARE_BUFFER *) VShare;
                     CurrentDShare = (SHARE_BUFFER *) VShare;
                  } else
                     // Modify so update the values of the path/drive with
                     // the new stuff.
                     if ((CurrentShare !=NULL) && (CurrentShare->DestShare != NULL))
                        if (CurrentShare->Virtual) {
                           VShare = (VIRTUAL_SHARE_BUFFER *) CurrentShare->DestShare;
                           lstrcpy(VShare->Path, Path);
                           VShare->Drive = Drive;
                        }


                  EndDialog(hDlg, 0);
               }

               break;

            case IDCANCEL:
               EndDialog(hDlg, 0);
               break;

            case IDHELP:
               if (NewShareType == SELECT_TYPE_MODIFY)
                  WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDC_HELP_SHAREPROP);
               else
                  WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDC_HELP_SHARENEW);

               break;

            case ID_INIT:
               // Modify should only be for a virtual share
               if (NewShareType == SELECT_TYPE_MODIFY) {
                  hCtrl = GetDlgItem(hDlg, IDC_EDIT2);
                  if (CurrentDShare->VFlag) {
                     VShare = (VIRTUAL_SHARE_BUFFER *) CurrentDShare;
                     SendMessage(hCtrl, WM_SETTEXT, (WPARAM) 0, (LPARAM) VShare->Path);
                  }
               }

            case IDC_EDIT1:
            case IDC_EDIT2:
               if (wmEvent == EN_CHANGE) {
                  Enable = TRUE;
                  hCtrl = GetDlgItem(hDlg, IDC_EDIT1);
   
                  if (NewShareType == SELECT_TYPE_ADD)
                     if (!SendMessage(hCtrl, EM_LINELENGTH, 0, 0))
                        Enable = FALSE;

                  hCtrl = GetDlgItem(hDlg, IDC_EDIT2);
                  if (SendMessage(hCtrl, EM_LINELENGTH, 0, 0) < 3)
                     Enable = FALSE;

                  hCtrl = GetDlgItem(hDlg, IDOK);
                  EnableWindow(hCtrl, Enable);

               }
               break;

         }
         return TRUE;

   }

   return (FALSE); // Didn't process the message

   lParam;
} // NWShareNew


/*+-------------------------------------------------------------------------+
  | NWShareNew_Do()
  |
  +-------------------------------------------------------------------------+*/
void NWShareNew_Do(HWND hDlg) {
   DLGPROC lpfnDlg;

   lpfnDlg = MakeProcInstance( (DLGPROC) NWShareNew, hInst);
   DialogBox(hInst, TEXT("NWShareAdd"), hDlg, lpfnDlg) ;
   FreeProcInstance(lpfnDlg);

} // NWShareNew_Do


/*+-------------------------------------------------------------------------+
  |               Add / Modify Share Selection Dialog Routines              |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | FixShare()
  |
  +-------------------------------------------------------------------------+*/
void FixShare(LPTSTR OrigShare, LPTSTR ServName, LPTSTR DestShare) {
   LPTSTR pShare = OrigShare;

   lstrcpy(DestShare, TEXT(""));

   // Assume it is in the form \\server\share
   // Skip over leading double-back for server
   if ((pShare[0] == '\\') && (pShare[1] == '\\'))
      pShare+= 2;

   // Now skip over the server name
   while (*pShare && (*pShare != '\\'))
      pShare++;

   // pShare should point to the share-name, append this to the server-name
   if (*ServName != '\\')
      lstrcat(DestShare, TEXT("\\\\"));

   lstrcat(DestShare, ServName);
   lstrcat(DestShare, pShare);

} // FixShare


/*+-------------------------------------------------------------------------+
  | NTShareListFill()
  |
  +-------------------------------------------------------------------------+*/
void NTShareListFill(HWND hDlg) {
   HWND hCtrl;
   SHARE_LIST *ShareList = NULL;
   SHARE_BUFFER *SList;
   DWORD_PTR i, dwIndex;
   BOOL Match = FALSE;
   VIRTUAL_SHARE_BUFFER *VShare;

   // Clear it out
   hCtrl = GetDlgItem(hDlg, IDC_COMBO2);
   SendMessage(hCtrl, CB_RESETCONTENT, 0, 0L);

   // First enum all the regular shares
   ShareList = DServ->ShareList;
   if (ShareList != NULL) {
      SList = ShareList->SList;

      for (i = 0; i < ShareList->Count; i++) {
         dwIndex = SendMessage(hCtrl, CB_ADDSTRING, (WPARAM) 0, (LPARAM) SList[i].Name);
         SendMessage(hCtrl, CB_SETITEMDATA, (WPARAM) dwIndex, (LPARAM) &SList[i]);
      } 

   }

   // Now enum all the virtual shares
   VShare = DServ->VShareStart;
   while (VShare) {
      dwIndex = SendMessage(hCtrl, CB_ADDSTRING, (WPARAM) 0, (LPARAM) VShare->Name);
      SendMessage(hCtrl, CB_SETITEMDATA, (WPARAM) dwIndex, (LPARAM) VShare);
      VShare = VShare->next;
   }

   // Match the combo-box to the given share
   if (CurrentShare->DestShare != NULL)
      if (CurrentShare->Virtual) {
         VShare = (VIRTUAL_SHARE_BUFFER *) CurrentShare->DestShare;
         SendMessage(hCtrl, CB_SELECTSTRING, (WPARAM) -1, (LPARAM) VShare->Name);
      } else
         SendMessage(hCtrl, CB_SELECTSTRING, (WPARAM) -1, (LPARAM) CurrentShare->DestShare->Name);

} // NTShareListFill


/*+-------------------------------------------------------------------------+
  | NWShareSelect()
  |
  +-------------------------------------------------------------------------+*/
LRESULT CALLBACK NWShareSelect(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
   static TCHAR ServName[MAX_UNC_PATH+1];
   VIRTUAL_SHARE_BUFFER *VShare;
   SHARE_BUFFER *OrigShare = NULL;
   SHARE_BUFFER *NewShare;
   HWND hCtrl;
   DWORD_PTR dwData,dwIndex;
   int wmId, wmEvent;
   ULONG i;

   switch (message) {
      case WM_INITDIALOG:
         // Center the dialog over the application window
         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));

         if (SelectType == SELECT_TYPE_MODIFY) {
            SendMessage(hDlg, WM_SETTEXT, (WPARAM) 0, (LPARAM) Lids(IDS_D_6));
            // Disable Source combo box...
            hCtrl = GetDlgItem(hDlg, IDC_COMBO1);
            EnableWindow(hCtrl, FALSE);
            ShowWindow(hCtrl, SW_HIDE);
            OrigShare = CurrentShare->DestShare;
         }

         hCtrl = GetDlgItem(hDlg, IDC_FSERVER);
         lstrcpy(ServName, Lids(IDS_D_7));
         lstrcat(ServName, SServ->Name);
         SendMessage(hCtrl, WM_SETTEXT, (WPARAM) 0, (LPARAM) ServName);

         hCtrl = GetDlgItem(hDlg, IDC_TSERVER);
         lstrcpy(ServName, Lids(IDS_D_8));
         lstrcat(ServName, DServ->Name);
         SendMessage(hCtrl, WM_SETTEXT, (WPARAM) 0, (LPARAM) ServName);

         PostMessage(hDlg, WM_COMMAND, ID_INIT, 0L);

         hCtrl = GetDlgItem(hDlg, IDC_EDIT1);
         PostMessage(hCtrl, EM_LIMITTEXT, (WPARAM) MAX_PATH, 0);

         if (SelectType == SELECT_TYPE_MODIFY)
            SendMessage(hCtrl, WM_SETTEXT, (WPARAM) 0, (LPARAM) CurrentShare->SubDir);

         return (TRUE);

      case WM_COMMAND:
         wmId    = LOWORD(wParam);
         wmEvent = HIWORD(wParam);

         switch (wmId) {

            case IDOK:
               CurrentShare->Convert = TRUE;    // only really needed for add

               hCtrl = GetDlgItem(hDlg, IDC_COMBO2);
               dwIndex = SendMessage(hCtrl, CB_GETCURSEL, 0, 0L);

               if (dwIndex != CB_ERR) {
                  dwData = SendMessage(hCtrl, CB_GETITEMDATA, dwIndex, 0L);
                  NewShare = (SHARE_BUFFER *) dwData;

                  if (OrigShare != NewShare) {
                     CurrentShare->DestShare = NewShare;

                     // this is actually a flag for the destination share
                     CurrentShare->Virtual = NewShare->VFlag;
                  }
               }

               hCtrl = GetDlgItem(hDlg, IDC_EDIT1);
               * (WORD *)CurrentShare->SubDir = sizeof(CurrentShare->SubDir);
               SendMessage(hCtrl, EM_GETLINE, 0, (LPARAM) CurrentShare->SubDir);

               EndDialog(hDlg, 0);
               break;

            case IDCANCEL:
               if (SelectType == SELECT_TYPE_ADD) {

                  // If we are in ADD - then we might have added a virtual
                  // share when we did the match, if so get rid of it...
                  if ((CurrentShare !=NULL) && (CurrentShare->DestShare != NULL))
                     if (CurrentShare->Virtual) {
                        VShare = (VIRTUAL_SHARE_BUFFER *) CurrentShare->DestShare;
                        VShareListDelete(DServ, VShare);
                        CurrentShare->DestShare = NULL;
                     }

                  CurrentShare = NULL;
               }

               EndDialog(hDlg, 0);
               break;

            case IDHELP:
               if (SelectType == SELECT_TYPE_MODIFY)
                  WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDC_HELP_SHAREMOD);
               else
                  WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDC_HELP_SHAREADD);
               break;

            case IDC_NEWSHARE:
               CurrentDShare = NULL;
               NewShareType = SELECT_TYPE_ADD;
               NWShareNew_Do(hDlg);

               // Match the combo-box to the given share
               NTShareListFill(hDlg);
               PostMessage(hDlg, WM_COMMAND, ID_UPDATECOMBO, 0L);
               break;

            case IDC_PROPERTIES:
               NewShareType = SELECT_TYPE_MODIFY;
               hCtrl = GetDlgItem(hDlg, IDC_COMBO2);
               dwIndex = SendMessage(hCtrl, CB_GETCURSEL, 0, 0L);

               if (dwIndex != CB_ERR) {
                  dwData = SendMessage(hCtrl, CB_GETITEMDATA, dwIndex, 0L);
                  CurrentDShare = (SHARE_BUFFER *) dwData;
                  NWShareNew_Do(hDlg);
               }

               break;

            case ID_INIT:
               if (SelectType == SELECT_TYPE_ADD) {
                  hCtrl = GetDlgItem(hDlg, IDC_COMBO1);

                  if (ShareList == NULL)
                     break;

                  CurrentShare = NULL;
                  for (i = 0; i < ShareList->Count; i++)
                     if (!SList[i].Convert) {
                        if (CurrentShare == NULL)
                           CurrentShare = &SList[i];

                        dwIndex = SendMessage(hCtrl, CB_ADDSTRING, (WPARAM) 0, (LPARAM) SList[i].Name);
                        SendMessage(hCtrl, CB_SETITEMDATA, (WPARAM) dwIndex, (LPARAM) &SList[i]);
                     }

                  if (CurrentShare != NULL) {
                     SendMessage(hCtrl, CB_SELECTSTRING, (WPARAM) -1, (LPARAM) CurrentShare->Name);
                     MapShare(CurrentShare, DServ);
                  }

               } else {
                  // Display the static text
                  hCtrl = GetDlgItem(hDlg, IDC_VOLUME);
                  EnableWindow(hCtrl, TRUE);
                  ShowWindow(hCtrl, SW_SHOW);
                  SendMessage(hCtrl, WM_SETTEXT, (WPARAM) 0, (LPARAM) CurrentShare->Name);
               }

               NTShareListFill(hDlg);
               PostMessage(hDlg, WM_COMMAND, ID_UPDATECOMBO, 0L);
               break;

            // Used to update which volume we are pointing at
            case ID_UPDATELIST:
               // We might have added a virtual share when we did the 
               // match, if so get rid of it...
               if ((CurrentShare !=NULL) && (CurrentShare->DestShare != NULL))
                  if (CurrentShare->Virtual) {
                     VShare = (VIRTUAL_SHARE_BUFFER *) CurrentShare->DestShare;
                     VShareListDelete(DServ, VShare);
                     CurrentShare->DestShare = NULL;
                  }

               hCtrl = GetDlgItem(hDlg, IDC_COMBO1);
               dwIndex = SendMessage(hCtrl, CB_GETCURSEL, 0, 0L);

               if (dwIndex != CB_ERR) {
                  dwData = SendMessage(hCtrl, CB_GETITEMDATA, dwIndex, 0L);
                  CurrentShare = (SHARE_BUFFER *) dwData;

                  // Now need to map this to a new share
                  if (CurrentShare != NULL) {
                     MapShare(CurrentShare, DServ);

                     // Match the combo-box to the given share
                     NTShareListFill(hDlg);
                  }
               }

               break;

            // updateded the share list selection
            case ID_UPDATECOMBO:
               hCtrl = GetDlgItem(hDlg, IDC_COMBO2);
               dwIndex = SendMessage(hCtrl, CB_GETCURSEL, 0, 0L);

               if (dwIndex != CB_ERR) {
                  dwData = SendMessage(hCtrl, CB_GETITEMDATA, dwIndex, 0L);
                  CurrentDShare = (SHARE_BUFFER *) dwData;
                  hCtrl = GetDlgItem(hDlg, IDC_PROPERTIES);

                  if (CurrentDShare->VFlag) {
                     EnableWindow(hCtrl, TRUE);
                  } else {
                     EnableWindow(hCtrl, FALSE);
                  }

               }
               break;

            case IDC_COMBO1:
               if (wmEvent == CBN_SELCHANGE)
                  PostMessage(hDlg, WM_COMMAND, ID_UPDATELIST, 0L);

               break;

            case IDC_COMBO2:
               if (wmEvent == CBN_SELCHANGE)
                  PostMessage(hDlg, WM_COMMAND, ID_UPDATECOMBO, 0L);

               break;
         }
         return TRUE;

   }

   return (FALSE); // Didn't process the message

   lParam;
} // NWShareSelect


/*+-------------------------------------------------------------------------+
  | ShareSelect_Do()
  |
  +-------------------------------------------------------------------------+*/
void NWShareSelect_Do(HWND hDlg) {
   DLGPROC lpfnDlg;

   lpfnDlg = MakeProcInstance((DLGPROC)NWShareSelect, hInst);
   DialogBox(hInst, TEXT("NWShareSelect"), hDlg, lpfnDlg) ;
   FreeProcInstance(lpfnDlg);

} // NWShareSelect_Do


/*+-------------------------------------------------------------------------+
  |                    Main File Options Dialog Routines                    |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | FileOptionsToggleControls()
  |
  +-------------------------------------------------------------------------+*/
void FileOptionsToggleControls(HWND hDlg, BOOL Toggle) {
   HWND hCtrl;

   hCtrl = GetDlgItem(hDlg, IDC_DELETE);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_MODIFY);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_FILES);
   EnableWindow(hCtrl, Toggle);

} // FileOptionsToggleControls


/*+-------------------------------------------------------------------------+
  | FileDialogToggle()
  |
  +-------------------------------------------------------------------------+*/
void FileDialogToggle(HWND hDlg, BOOL Toggle) {
   HWND hCtrl;

   hCtrl = GetDlgItem(hDlg, IDC_LIST1);
   EnableWindow(hCtrl, Toggle);
   FileOptionsToggleControls(hDlg, Toggle);

   hCtrl = GetDlgItem(hDlg, IDC_ADD);
   if (Toggle == FALSE)
      EnableWindow(hCtrl, FALSE);
   else
      if (ShareList && ShareList->Count != ShareList->ConvertCount)
         EnableWindow(hCtrl, TRUE);
      else
         EnableWindow(hCtrl, FALSE);

} // FileDialogToggle


/*+-------------------------------------------------------------------------+
  | DlgFileOptions_Save()
  |
  +-------------------------------------------------------------------------+*/
void DlgFileOptions_Save(HWND hDlg) {
   HWND hCtrl;

   hCtrl = GetDlgItem(hDlg, IDC_CHKFILES);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      FileOptions->TransferFileInfo = TRUE;
   else
      FileOptions->TransferFileInfo = FALSE;

} // DlgFileOptions_Save


/*+-------------------------------------------------------------------------+
  | DlgFileOptions_Setup()
  |
  +-------------------------------------------------------------------------+*/
void DlgFileOptions_Setup(HWND hDlg) {
   HWND hCtrl;

   hCtrl = GetDlgItem(hDlg, IDC_CHKFILES);
   if (FileOptions->TransferFileInfo) {
      SendMessage(hCtrl, BM_SETCHECK, 1, 0);
      FileDialogToggle(hDlg, TRUE);
   } else {
      SendMessage(hCtrl, BM_SETCHECK, 0, 0);
      FileDialogToggle(hDlg, FALSE);
   }

} // DlgFileOptions_Setup


/*+-------------------------------------------------------------------------+
  | DlgFileOptions_ListboxAdd()
  |
  +-------------------------------------------------------------------------+*/
void DlgFileOptions_ListboxAdd(HWND hDlg, SHARE_BUFFER *CurrentShare, DWORD *wItem, BOOL Insert ) {
   HWND hCtrl;
   static TCHAR AddLine[256];
   VIRTUAL_SHARE_BUFFER *VShare;
   DWORD wItemNum;

   wItemNum = *wItem;
   hCtrl = GetDlgItem(hDlg, IDC_LIST1);
   if (CurrentShare->Virtual) {
      VShare = (VIRTUAL_SHARE_BUFFER *) CurrentShare->DestShare;
      wsprintf(AddLine, TEXT("%s\\%s:\t\\\\%s\\%s\t"), SServ->Name, CurrentShare->Name, DServ->Name, VShare->Name);
   } else
      wsprintf(AddLine, TEXT("%s\\%s:\t\\\\%s\\%s\t"), SServ->Name, CurrentShare->Name, DServ->Name, CurrentShare->DestShare->Name);

   if (Insert)
      ColumnLB_InsertString(hCtrl, wItemNum, AddLine);
   else
      wItemNum = ColumnLB_AddString(hCtrl, AddLine);

   ColumnLB_SetItemData(hCtrl, wItemNum, (DWORD_PTR) CurrentShare);
   *wItem = wItemNum;

} // DlgFileOptions_ListboxAdd


/*+-------------------------------------------------------------------------+
  | DlgFileOptions()
  |
  +-------------------------------------------------------------------------+*/
LRESULT CALLBACK DlgFileOptions(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
   HWND hCtrl;
   DWORD wItemNum;
   DWORD_PTR dwData;
   static short FilesTab, FileOptionsTab;
   int wmId, wmEvent;
   ULONG i;
   SHARE_BUFFER *pShare;
   VIRTUAL_SHARE_BUFFER *VShare;
   RECT rc;
   int TabStop;

   switch (message) {
      case WM_INITDIALOG:
         // Center the dialog over the application window
         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));

         hCtrl = GetDlgItem(hDlg, IDC_LIST1);
         GetClientRect(hCtrl, &rc);

         // Size is half width of listbox - vertical scrollbar
         TabStop = (((rc.right - rc.left) - GetSystemMetrics(SM_CXVSCROLL)) / 2);
         ColumnLB_SetNumberCols(hCtrl, 2);
         ColumnLB_SetColTitle(hCtrl, 0, Lids(IDS_D_9));
         ColumnLB_SetColTitle(hCtrl, 1, Lids(IDS_D_10));
         ColumnLB_SetColWidth(hCtrl, 0, TabStop);

         // Calculate 2nd this way instead of just using TabStop to get rid of roundoff
         ColumnLB_SetColWidth(hCtrl, 1, (rc.right - rc.left) - TabStop);

         DlgFileOptions_Setup(hDlg);

         // Fill listbox and set selection (is assumed there is always a selection)...
         PostMessage(hDlg, WM_COMMAND, ID_INIT, 0L);
         return (TRUE);

      case WM_COMMAND:
         wmId    = LOWORD(wParam);
         wmEvent = HIWORD(wParam);

         switch (wmId) {
            case IDOK:
               DlgFileOptions_Save(hDlg);
               FileOptionsDefaultsSet(FileOptions);
               EndDialog(hDlg, 0);
               return (TRUE);

            case IDCANCEL:
               EndDialog(hDlg, 0);
               return (TRUE);

            case IDHELP:
               WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDC_HELP_FILE);
               return (TRUE);

            case IDC_CHKFILES:
               hCtrl = GetDlgItem(hDlg, IDC_CHKFILES);
               if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
                  FileDialogToggle(hDlg, TRUE);
               else
                  FileDialogToggle(hDlg, FALSE);

               return (TRUE);

            case IDC_ADD:
               SelectType = SELECT_TYPE_ADD;
               CurrentShare = NULL;
               NWShareSelect_Do(hDlg);

               if (CurrentShare != NULL) {
                  DlgFileOptions_ListboxAdd(hDlg, CurrentShare, &wItemNum, FALSE );

                  // Check if Add button needs to be disabled
                  ShareList->ConvertCount++;
                  if (ShareList->Count == ShareList->ConvertCount) {
                     hCtrl = GetDlgItem(hDlg, IDC_ADD);
                     EnableWindow(hCtrl, FALSE);
                  }

                  // Buttons need to be re-enabled
                  FileOptionsToggleControls(hDlg, TRUE);

                  // Now make sure focus is set
                  hCtrl = GetDlgItem(hDlg, IDC_LIST1);
                  ColumnLB_SetCurSel(hCtrl, wItemNum);
                  wItemNum = ColumnLB_GetCurSel(hCtrl);
                  if (wItemNum == LB_ERR)
                     ColumnLB_SetCurSel(hCtrl, 0);

               };

               return (TRUE);

            case IDC_DELETE:
               hCtrl = GetDlgItem(hDlg, IDC_LIST1);
               wItemNum = ColumnLB_GetCurSel(hCtrl);
               if (wItemNum != LB_ERR) {
                  dwData = ColumnLB_GetItemData(hCtrl, wItemNum);
                  pShare = (SHARE_BUFFER *)dwData;
                  pShare->Convert = FALSE;
                  ShareList->ConvertCount--;

                  // Now need to delete dest share, or reduce use count
                  if (pShare->DestShare != NULL)
                     if (pShare->Virtual) {
                        VShare = (VIRTUAL_SHARE_BUFFER *) pShare->DestShare;
                        VShareListDelete(DServ, VShare);
                        pShare->DestShare = NULL;
                     }

                  ColumnLB_DeleteString(hCtrl, wItemNum);
               }

               if (!ShareList->ConvertCount)
                  FileOptionsToggleControls(hDlg, FALSE);
               else {
                  wItemNum = ColumnLB_GetCurSel(hCtrl);
                  if (wItemNum == LB_ERR)
                     ColumnLB_SetCurSel(hCtrl, 0);
               }

               if (ShareList->Count != ShareList->ConvertCount) {
                  hCtrl = GetDlgItem(hDlg, IDC_ADD);
                  EnableWindow(hCtrl, TRUE);
               }

               return (TRUE);

            case IDC_MODIFY:
               SelectType = SELECT_TYPE_MODIFY;
               hCtrl = GetDlgItem(hDlg, IDC_LIST1);
               wItemNum = ColumnLB_GetCurSel(hCtrl);
               if (wItemNum != LB_ERR) {
                  dwData = ColumnLB_GetItemData(hCtrl, wItemNum);
                  CurrentShare = (SHARE_BUFFER *)dwData;
                  NWShareSelect_Do(hDlg);

                  // Now update listbox to reflect any changes
                  ColumnLB_DeleteString(hCtrl, wItemNum);

                  DlgFileOptions_ListboxAdd(hDlg, CurrentShare, &wItemNum, TRUE );

                  // now reset focus back to this item
                  ColumnLB_SetCurSel(hCtrl, wItemNum);
               }
               return (TRUE);

            case IDC_FILES:
               hCtrl = GetDlgItem(hDlg, IDC_LIST1);
               wItemNum = ColumnLB_GetCurSel(hCtrl);
               if (wItemNum != LB_ERR) {
                  dwData = ColumnLB_GetItemData(hCtrl, wItemNum);
                  CurrentShare = (SHARE_BUFFER *)dwData;
                  FileSelect_Do(hDlg, SServ, CurrentShare);
               }
               return (TRUE);

            case IDC_FOPTIONS:
               return (TRUE);

            case ID_INIT:

               if (ShareList != NULL) {
                  SList = ShareList->SList;

                  for (i = 0; i < ShareList->Count; i++)
                     if (SList[i].Convert) {
                        DlgFileOptions_ListboxAdd(hDlg, &SList[i], &wItemNum, FALSE );
                        hCtrl = GetDlgItem(hDlg, IDC_LIST1);
                        ColumnLB_SetCurSel(hCtrl, 0);
                     }

                  if (ShareList->Count == ShareList->ConvertCount) {
                     hCtrl = GetDlgItem(hDlg, IDC_ADD);
                     EnableWindow(hCtrl, FALSE);
                  }

                  if (!ShareList->ConvertCount)
                     FileOptionsToggleControls(hDlg, FALSE);

               } else
                  FileOptionsToggleControls(hDlg, FALSE);

               return (TRUE);

            case IDC_LIST1:
               switch (wmEvent) {
                  case LBN_DBLCLK:
                     PostMessage(hDlg, WM_COMMAND, IDC_MODIFY, 0L);
                     break;

                  case LBN_SELCHANGE:
                     if (!ShareList || !ShareList->ConvertCount)
                        FileOptionsToggleControls(hDlg, TRUE);

                     break;

               }
               break;

         }
         break;
   }

   return (FALSE); // Didn't process the message

   lParam;
} // DlgFileOptions


/*+-------------------------------------------------------------------------+
  | FileOptions_Do()
  |
  +-------------------------------------------------------------------------+*/
void FileOptions_Do(HWND hDlg, void *ConvOptions, SOURCE_SERVER_BUFFER *SourceServer, DEST_SERVER_BUFFER *DestServer) {
   DLGPROC lpfnDlg;

   SServ = SourceServer;
   DServ = DestServer;

   NWServerFree();
   NWServerSet(SourceServer->Name);
   NTServerSet(DestServer->Name);
   FileOptions = (FILE_OPTIONS *) ConvOptions;
   ShareList = SServ->ShareList;

   lpfnDlg = MakeProcInstance((DLGPROC)DlgFileOptions, hInst);
   DialogBox(hInst, TEXT("FileMain"), hDlg, lpfnDlg) ;

   FreeProcInstance(lpfnDlg);
} // FileOptions_Do
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\filedlg.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _FILEDLG_
#define _FILEDLG_

#ifdef __cplusplus
extern "C"{
#endif

typedef struct _FILE_OPTIONS {
   BOOL TransferFileInfo;
   BOOL Validated;         // Has user validated our mappings?
} FILE_OPTIONS;


void FileOptions_Do(HWND hDlg, void *ConvOptions, SOURCE_SERVER_BUFFER *SourceServ, DEST_SERVER_BUFFER *DestServ);
void FileOptionsInit(void **lpfo);
void FileOptionsDefaultsReset();
void FileOptionsLoad(HANDLE hFile, void **lpfo);
void FileOptionsSave(HANDLE hFile, void *fo);

// These are actually in filesel.h - but for simplicity put them here
void FillDirInit();
void TreeFillRecurse(UINT Level, LPTSTR Path, DIR_BUFFER *Dir);
void TreeCompact(DIR_BUFFER *Dir);
void TreeRootInit(SHARE_BUFFER *CShare, LPTSTR NewPath);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\globals.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _HGLOBALS_
#define _HGLOBALS_

#ifdef __cplusplus
extern "C"{
#endif

#include "switches.h"
#include "constant.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <ctype.h>
#include <winnetwk.h>
#include <lm.h>
#include <commdlg.h>

#include "resource.h"
#include "debug.h"
#include "nwlog.h"
#include "tab.h"
#include "mem.h"
#include "error.h"
#include "strings.h"
#include "utils.h"

extern HINSTANCE hInst;

#define XCHG(x)         MAKEWORD( HIBYTE(x), LOBYTE(x) )
#define DXCHG(x)        MAKELONG( XCHG(HIWORD(x)), XCHG(LOWORD(x)) )
#define SWAPBYTES(w)    ((w) = XCHG(w))
#define SWAPWORDS(d)    ((d) = DXCHG(d))

#define HELP_FILE TEXT("NWConv.HLP")

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\filesel.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _HFILESEL_
#define _HFILESEL_

#ifdef __cplusplus
extern "C"{
#endif

// Forward references as the structures are recursively linked
struct _DIR_BUFFER;
struct _DIR_LIST;
struct _FILE_BUFFER;
struct _FILE_LIST;
struct SHARE_BUFFER;

/*+-------------------------------------------------------------------------+
  |
  |  The dir/file lists contain all the information used when working with
  |  a file tree.  The naming convention is that a buffer (I.E.
  |  DIR_BUFFER) contains the information for one entry (one directory
  |  or one file).  A List is an array of buffers of the appropriate
  |  type (DIR_LIST contains an array of DIR_BUFFERS).
  |
  |  The whole mess starts with a root DIR_BUFFER, the DIR_BUFFER then 
  |  points to a cascading chain of DIR and FILE LISTS.
  |
  |  Almost all of the structures are a doubly linked list with a pointer back
  |  to their parent.  A buffer parent pointer, points to it's parent list
  |  structure.  The List structure then has a back pointer to the parent
  |  DIR_BUFFER.  This facilitates recursing up and down the chain when
  |  an item is checked/un-checked and it's parent and/or children are affected.
  |  
  |  +--------+     +----------+
  |  |  Dir   |<--->| Dir List |
  |  | Buffer |<-+  +----------+
  |  +--------+  |  |   Dir    |-->Dir List...
  |              |  |  Buffer  |-->File List...
  |              |  + - - - - -+
  |              |  |          |
  |              |  + - - - - -+
  |              |  |          |
  |              |
  |              |
  |              |  +-----------+
  |              +->| File List |
  |                 +-----------+
  |                 |   File    |
  |                 |  Buffer   |
  |                 + - - - - - +
  |                 |           |
  |                 + - - - - - +
  |                 |           |
  |
  +-------------------------------------------------------------------------+*/
#define CONVERT_NONE 0
#define CONVERT_ALL 1
#define CONVERT_PARTIAL 2
  
// A dir buffer holds a directory or sub-directory entry, with pointers to the
// files and other dirs within it.
typedef struct _DIR_BUFFER {
   TCHAR Name[MAX_PATH];
   struct _DIR_LIST *parent;
   BOOL Last;                    // Flag is last dir-buffer in list
   DWORD Attributes;
   BYTE Convert;                 // None, All or Partial
   BOOL Special;

   struct _DIR_LIST *DirList;    // Directory List structure
   struct _FILE_LIST *FileList;  // File List structure
} DIR_BUFFER;

// A dir list contains the sub-directories in a directory - basically a count
// and then array of sub-dirs.
typedef struct _DIR_LIST {
   ULONG Count;
   DIR_BUFFER *parent;
   UINT Level;             // how deeply nested in file tree (nesting level)
   DIR_BUFFER DirBuffer[];
} DIR_LIST;


// Structures to hold information on individual files selected/de-selected for
// conversion
typedef struct _FILE_BUFFER {
   TCHAR Name[MAX_PATH];
   struct _FILE_LIST *parent;
   BOOL Convert;
   DWORD Attributes;
   ULONG Size;
} FILE_BUFFER;

typedef struct _FILE_LIST {
   ULONG Count;
   DIR_BUFFER *parent;
   FILE_BUFFER FileBuffer[];
} FILE_LIST;


typedef struct _FILE_PATH_BUFFER {
   LPTSTR Server;
   LPTSTR Share;
   LPTSTR Path;
   TCHAR FullPath[MAX_PATH + 1];
} FILE_PATH_BUFFER;


/*+-------------------------------------------------------------------------+
  | Function Prototypes                                                     |
  +-------------------------------------------------------------------------+*/
void TreeDelete(DIR_BUFFER *Dir);
void TreePrune(DIR_BUFFER *Dir);
ULONG TreeCount(DIR_BUFFER *Dir);
DIR_BUFFER *TreeCopy(DIR_BUFFER *Dir);

FILE_PATH_BUFFER *FilePathInit();
void FilePathServerSet(FILE_PATH_BUFFER *fpBuf, LPTSTR Server);
void FilePathShareSet(FILE_PATH_BUFFER *fpBuf, LPTSTR Share);
void FilePathPathSet(FILE_PATH_BUFFER *fpBuf, LPTSTR Path);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\filesel.c ===
/*++

Copyright (c) 1993-1995  Microsoft Corporation

Module Name:

   FileSel.c

Abstract:

   Handles processing for the file selection listbox.  This is a
   hierarchical file/directory tree with checkboxes besides the files
   and directories.

   If the checkbox is checked then that file or directory will be
   copied, otherwise it won't.  There are some directories that are
   excluded by default.  These are directories on the NW server that
   are known to contain binaries that are not needed on the NT side
   (such as the NetWare administration tools).

Author:

    Arthur Hanson (arth) 10-Feb-1994

Revision History:

--*/

#include "globals.h"

#include "hierfile.h"
#include "nwconv.h"
#include "convapi.h"
#include "ntnetapi.h"
#include "nwnetapi.h"
#include "columnlb.h"
#include "statbox.h"
#include "userdlg.h"

#include <math.h>    // For pow function

#define X_BORDER 10
#define Y_BORDER 10
#define SPLITTER_WIDTH 3
#define BUTTON_Y_BORDER 6
#define BUTTON_X_BORDER 10

static int List1Width;
static int Splitter_Left;
static int Splitter_Bottom;
static HCURSOR CursorSplitter;
static HWND hwndList2 = 0;
static HWND hwndList1 = 0;

static SHARE_BUFFER *CurrentShare;
static SOURCE_SERVER_BUFFER *SServ;
static BOOL HiddenFiles = FALSE;
static BOOL SystemFiles = FALSE;
static DIR_BUFFER *oDir = NULL;

static ULONG TotalFileSize = 0;
static LPARAM mouseHit = 0;
static WORD LastFocus = 0;
static HWND ListFocus = NULL;

static ULONG TCount;

static WNDPROC _wpOrigWndProc;
static WNDPROC _wpOrigWndProc2;


HEIRDRAWSTRUCT HierDrawStruct;
BOOL SysDir = FALSE;

#define ROWS 2
#define COLS 2

// define a scratch buffer for quickly building up dir/file lists
#define DEF_NUM_RECS 50
#define DEF_REC_DELTA 25
static UINT BufferSize = 0;
static WIN32_FIND_DATA *ffd = NULL;


/*+-------------------------------------------------------------------------+
  |                    Routines for Directory/File Trees                    |
  +-------------------------------------------------------------------------+*/


/////////////////////////////////////////////////////////////////////////
FILE_PATH_BUFFER *
FilePathInit()

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   FILE_PATH_BUFFER *fpBuf = NULL;

   fpBuf = AllocMemory(sizeof(FILE_PATH_BUFFER));
   if (fpBuf == NULL)
      return NULL;

   memset(fpBuf, 0, sizeof(FILE_PATH_BUFFER));
   return fpBuf;

} // FilePathInit


/////////////////////////////////////////////////////////////////////////
VOID 
FilePathServerSet(
   FILE_PATH_BUFFER *fpBuf, 
   LPTSTR Server
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   fpBuf->Server = Server;

   if (fpBuf->Server == NULL)
      return;

   wsprintf(fpBuf->FullPath, TEXT("\\\\%s\\"), Server);

} // FilePathServerSet


/////////////////////////////////////////////////////////////////////////
VOID
FilePathShareSet(
   FILE_PATH_BUFFER *fpBuf,
   LPTSTR Share
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   fpBuf->Share = Share;
   if ((fpBuf->Server == NULL) || (fpBuf->Share == NULL))
      return;

   wsprintf(fpBuf->FullPath, TEXT("\\\\%s\\%s"), fpBuf->Server, Share);
   fpBuf->Path = &fpBuf->FullPath[lstrlen(fpBuf->FullPath)];

} // FilePathShareSet


/////////////////////////////////////////////////////////////////////////
VOID
FilePathPathSet(
   FILE_PATH_BUFFER *fpBuf,
   LPTSTR Path
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   if ((fpBuf->Server == NULL) || (fpBuf->Share == NULL))
      return;

   *fpBuf->Path = TEXT('\0');
   if (Path == NULL)
      return;

   lstrcat(fpBuf->FullPath, Path);

} // FilePathPathSet



/////////////////////////////////////////////////////////////////////////
VOID
TreeDelete(
   DIR_BUFFER *Dir
   )

/*++

Routine Description:

   Walks an in-memory directory tree and free's up all the memory associated
   with it and all child nodes.

Arguments:


Return Value:


--*/

{
   DIR_BUFFER *DList;
   ULONG i;

   if (Dir == NULL)
      return;

   if (Dir->DirList) {
      DList = Dir->DirList->DirBuffer;
      for (i = 0; i < Dir->DirList->Count; i++)
         TreeDelete(&DList[i]);

      FreeMemory(Dir->DirList);
   }

   if (Dir->FileList)
      FreeMemory(Dir->FileList);

} // TreeDelete


/////////////////////////////////////////////////////////////////////////
VOID
TreePrune(
   DIR_BUFFER *Dir
   )

/*++

Routine Description:

   Prunes a tree down by removing un-needed nodes.  If a node is marked
   as CONVERT_ALL or CONVERT_NONE then we don't need any of the child
   leaves as we know these will be the same.  Only CONVERT_PARTIAL
   needs to be saved.

   This is used so we only copy/save the minimum needed.

Arguments:


Return Value:


--*/

{
   BYTE Convert;
   DIR_BUFFER *DList;
   ULONG i;

   if (Dir == NULL)
      return;

   // First visit all of the children sub-dirs and prune them.  Next:
   // if partial convert then we can't delete this node, else we can
   // clean up all the children - we leave it to the parent node to 
   // delete the current node.
   Convert = Dir->Convert;
   if (Dir->DirList) {
      DList = Dir->DirList->DirBuffer;
      for (i = 0; i < Dir->DirList->Count; i++)
         TreePrune(&DList[i]);

      if (Convert == CONVERT_PARTIAL)
         return;

      if (Dir->Special && (Convert == CONVERT_ALL))
         return;

      for (i = 0; i < Dir->DirList->Count; i++)
         TreeDelete(&DList[i]);

      Dir->DirList = NULL;
   }

   if (Convert == CONVERT_PARTIAL)
      return;

   if (Dir->FileList)
      FreeMemory(Dir->FileList);

   Dir->FileList = NULL;

} // TreePrune


/////////////////////////////////////////////////////////////////////////
VOID
_TreeCountR(
   DIR_BUFFER *Dir
   )

/*++

Routine Description:

   Count all the files under a sub-dir.  This recuses down all the child
   nodes.

Arguments:


Return Value:


--*/

{
   BYTE Convert;
   DIR_BUFFER *DList;
   ULONG i;

   if ((Dir == NULL) || (!Dir->Convert))
      return;

   Convert = Dir->Convert;
   if (Dir->DirList) {
      DList = Dir->DirList->DirBuffer;
      for (i = 0; i < Dir->DirList->Count; i++)
         _TreeCountR(&DList[i]);

   }

   if (Dir->FileList)
      for (i = 0; i < Dir->FileList->Count; i++)
      if (Dir->FileList->FileBuffer[i].Convert)
         TCount++;

} // _TreeCountR


ULONG TreeCount(DIR_BUFFER *Dir) {
   TCount = 0;
   if (Dir == NULL)
      return TCount;

   _TreeCountR(Dir);
   return TCount;

} // TreeCount


/////////////////////////////////////////////////////////////////////////
VOID 
_TreeCopyR(
   DIR_BUFFER *Dir
   )

/*++

Routine Description:

   Duplicates a directory/File tree structure in memory.

Arguments:


Return Value:


--*/

{
   DIR_LIST *DList;
    DIR_BUFFER *DBuff;
   FILE_LIST *FList;
   FILE_BUFFER *FBuff;
   ULONG Size;
   ULONG i;

   if (Dir == NULL)
      return;

   if (Dir->FileList) {
      // Create clone of file list
      Size = sizeof(FILE_LIST) + (sizeof(FILE_BUFFER) * Dir->FileList->Count);
      FList = AllocMemory(Size);

      if (FList != NULL)
         memcpy(FList, Dir->FileList, Size);

      // Copied it, now fixup the internal pointers.
      FList->parent = Dir;

      FBuff = FList->FileBuffer;
      for (i = 0; i < FList->Count; i++)
         FBuff[i].parent = FList;

      // Now replace pointer with cloned tree
      Dir->FileList = FList;
   }

   if (Dir->DirList) {
      // Create clone of Dir List
      Size = sizeof(DIR_LIST) + (sizeof(DIR_BUFFER) * Dir->DirList->Count);
      DList = AllocMemory(Size);

      if (DList != NULL)
         memcpy(DList, Dir->DirList, Size);

      // Copied it, now fixup the internal pointers.
      DList->parent = Dir;

      DBuff = DList->DirBuffer;
      for (i = 0; i < DList->Count; i++)
         DBuff[i].parent = DList;

      // Now replace pointer with cloned tree
      Dir->DirList = DList;

      // Now recurse into children and fix them up
      for (i = 0; i < DList->Count; i++)
         _TreeCopyR(&DBuff[i]);

   }

} // _TreeCopyR


/////////////////////////////////////////////////////////////////////////
DIR_BUFFER *
TreeCopy(
   DIR_BUFFER *Dir
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   DIR_BUFFER *nDir = NULL;

   if (Dir == NULL)
      return NULL;

   nDir = AllocMemory(sizeof(DIR_BUFFER));
   if (nDir != NULL) {
      memcpy(nDir, Dir, sizeof(DIR_BUFFER));
      _TreeCopyR(nDir);
   }

   return nDir;

} // TreeCopy



/////////////////////////////////////////////////////////////////////////
int __cdecl 
FileBufferCompare(
   const VOID *arg1, 
   const VOID *arg2
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   WIN32_FIND_DATA *Farg1, *Farg2;

   Farg1 = (WIN32_FIND_DATA *) arg1;
   Farg2 = (WIN32_FIND_DATA *) arg2;

   // This works as the first item of the structure is the string
   return lstrcmpi( Farg1->cFileName, Farg2->cFileName);

} // FileBufferCompare


/////////////////////////////////////////////////////////////////////////
VOID
DirAdjustConvert(
   DIR_BUFFER *Dir
   )

/*++

Routine Description:

  Need to adjust convert flag (none, full, partial) down the tree to the
  root.

Arguments:


Return Value:


--*/

{
   BOOL Partial = FALSE;
   ULONG ChildCount = 0;
   ULONG ChildSelected = 0;
   DIR_LIST *DirList = NULL;
   FILE_LIST *FileList = NULL;
   ULONG i;

   if (Dir == NULL)
      return;

   // if no files or dirs don't try to re-adjust current setting.
   if ((Dir->DirList == NULL) && (Dir->FileList == NULL))
      goto DirAdjRecurse;

   // Scan the children directories to see what is to be converted.
   DirList = Dir->DirList;
   if (DirList != NULL) {
      ChildCount += DirList->Count;
      for (i = 0; i < DirList->Count; i++)
         if (DirList->DirBuffer[i].Convert == CONVERT_PARTIAL)
            Partial = TRUE;
         else
            ChildSelected += DirList->DirBuffer[i].Convert;
   }

   // if any of the children were partial convert then it is easy, as
   // we are partial convert as well.
   if (Partial) {
      Dir->Convert = CONVERT_PARTIAL;
      goto DirAdjRecurse;
   }


   // Scan the children files to see what is to be converted.
   FileList = Dir->FileList;
   if (FileList != NULL) {
      ChildCount += FileList->Count;
      for (i = 0; i < FileList->Count; i++)
         ChildSelected += FileList->FileBuffer[i].Convert;
   }

   if (ChildSelected == ChildCount)
      Dir->Convert = CONVERT_ALL;
   else
      if (ChildSelected == 0)
         Dir->Convert = CONVERT_NONE;
      else
         Dir->Convert = CONVERT_PARTIAL;

DirAdjRecurse:
   DirList = Dir->parent;
   if (DirList != NULL)
      DirAdjustConvert(DirList->parent);

} // DirAdjustConvert


/////////////////////////////////////////////////////////////////////////
VOID
DirAdjustConvertChildren(
   DIR_BUFFER *Dir,
   BYTE Convert
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   DIR_LIST *DirList = NULL;
   FILE_LIST *FileList = NULL;
   ULONG i;

   if (Dir == NULL)
      return;

   Dir->Convert = Convert;

   // Scan the children files
   FileList = Dir->FileList;
   if (FileList != NULL)
      for (i = 0; i < FileList->Count; i++)
         FileList->FileBuffer[i].Convert = Convert;

   // Scan the children directories
   DirList = Dir->DirList;
   if (DirList != NULL)
      for (i = 0; i < DirList->Count; i++)
         DirAdjustConvertChildren(&DirList->DirBuffer[i], Convert);

} // DirAdjustConvertChildren


/////////////////////////////////////////////////////////////////////////
BOOL
SubdirRestrict(
   LPTSTR Path, 
   LPTSTR Subdir
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   ULONG i = 0;
   LPTSTR RestrictPath[5];
   CONVERT_OPTIONS * ConvertOptions;

   // if the user has specified the 'transfer netware specific info'
   // option the we should transfer the mail directory by default...
   ConvertOptions = (CONVERT_OPTIONS *)CurrentConvertList->ConvertOptions;

   if (ConvertOptions->NetWareInfo)
      RestrictPath[i++] = Lids(IDS_S_3);

   RestrictPath[i++] = Lids(IDS_S_2);
   RestrictPath[i++] = Lids(IDS_S_4);
   RestrictPath[i++] = Lids(IDS_S_5);
   RestrictPath[i++] = NULL;

   i = 0;
   while(RestrictPath[i] != NULL) {
      if (!lstrcmpi(RestrictPath[i], Subdir))
         return TRUE;

      i++;
   }

   return FALSE;

} // SubdirRestrict


/////////////////////////////////////////////////////////////////////////
VOID
FillDirInit()

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   if (ffd == NULL) {
      ffd = AllocMemory(sizeof(WIN32_FIND_DATA) * DEF_NUM_RECS);
      BufferSize = DEF_NUM_RECS;
   }

} // FillDirInit


/////////////////////////////////////////////////////////////////////////
VOID
FillDir(
   UINT Level, 
   LPTSTR Path, 
   DIR_BUFFER *Dir, 
   BOOL DoDirs
   )

/*++

Routine Description:

   Given a DIR_BUFFER, enumerate the files and sub-dirs under it and
   attach them (one level-deep only).

Arguments:


Return Value:


--*/

{
   static TCHAR NewPath[MAX_UNC_PATH + 1];
   DIR_LIST *DirList = NULL;
   DIR_LIST *OldDirList = NULL;
   DIR_BUFFER *DBuff;

   FILE_LIST *FileList = NULL;
   FILE_LIST *OldFileList = NULL;
   FILE_BUFFER *FBuff;

   HANDLE fHandle = NULL;
   ULONG DirCount = 0;
   ULONG FileCount = 0;
   ULONG Count = 0;
   BOOL ret = TRUE;
   ULONG i;
   BYTE Convert;
   BOOL ConvFlag;

   FixPathSlash(NewPath, Path);
   lstrcat(NewPath, TEXT("*.*"));

#ifdef DEBUG
dprintf(TEXT("Working on dir: %u %s\r\n"), Level, Path);
#endif

   Panel_Line(7, TEXT("%s"), Path);
   fHandle = FindFirstFile(NewPath, &ffd[Count]);

   ret = (fHandle != INVALID_HANDLE_VALUE);

   // loop filling in the temp buffer - figure out how many dirs and files
   // we have to remember - and build up a temporary buffer of them
   while (ret) {

      if (ffd[Count].dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
         ConvFlag = TRUE;

         if (!((lstrcmp(ffd[Count].cFileName, TEXT("."))) && (lstrcmp(ffd[Count].cFileName, TEXT("..")))))
            ConvFlag = FALSE;

         if (!HiddenFiles && (ffd[Count].dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
            ConvFlag = FALSE;

         if (!SystemFiles && (ffd[Count].dwFileAttributes & FILE_ATTRIBUTE_SYSTEM))
            ConvFlag = FALSE;

         // Use the cAlternateFileName as a flag whether to convert
         if (ConvFlag) {
            ffd[Count].cAlternateFileName[0] = 1;
            DirCount++;
         } else
            ffd[Count].cAlternateFileName[0] = 0;

      } else {
         ConvFlag = TRUE;

         if (!HiddenFiles && (ffd[Count].dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
            ConvFlag = FALSE;

         if (!SystemFiles && (ffd[Count].dwFileAttributes & FILE_ATTRIBUTE_SYSTEM))
            ConvFlag = FALSE;

         if (ConvFlag) {
            ffd[Count].cAlternateFileName[0] = 1;
            FileCount++;
         } else
            ffd[Count].cAlternateFileName[0] = 0;

      }

      Count++;

      // check if we are going to run out of space in our buffer - if so
      // allocate more space
      if (Count >= BufferSize) {
         BufferSize += DEF_REC_DELTA;
         ffd = ReallocMemory(ffd, sizeof(WIN32_FIND_DATA) * BufferSize);
      }

      if (ffd == NULL) {
         FindClose(fHandle);
         return;
      } else
         ret = FindNextFile(fHandle, &ffd[Count]);

   }

   FindClose(fHandle);

#ifdef DEBUG
dprintf(TEXT("   Num Dirs / Files: %li %li\r\n"), DirCount, FileCount);
#endif

   // Temp buffer is all filled in at this point.  Sort it first
   if (Count != 0)
      qsort((void *) ffd, (size_t) Count, sizeof(WIN32_FIND_DATA), FileBufferCompare);

   // Now create the actual list structures
   if (DoDirs && DirCount)
      DirList = AllocMemory(sizeof(DIR_LIST) + (sizeof(DIR_BUFFER) * DirCount));

   if (FileCount)
      FileList = AllocMemory(sizeof(FILE_LIST) + (sizeof(FILE_BUFFER) * FileCount));

   // if there is no dirlist and there is an old one, clean up the old-one.
   if (DoDirs && (DirList == NULL) && (Dir->DirList != NULL)) {
      // save off file list so it isn't nuked
      OldFileList = (FILE_LIST *) Dir->FileList;
      Dir->FileList = NULL;
      TreeDelete(Dir);
      Dir->DirList = NULL;

      // Now restore file list
      Dir->FileList = OldFileList;
   }

   // same for file list.
   if ((FileList == NULL) && (Dir->FileList != NULL)) {
      FreeMemory(Dir->FileList);
      Dir->FileList = NULL;
   }

   // If nothing to copy, or couldn't alloc memory then no reason to continue
   // further...
   if ((DirList == NULL) && (FileList == NULL))
      return;

   if (Dir->Convert == CONVERT_PARTIAL)
      Convert = CONVERT_ALL;
   else
      Convert = Dir->Convert;

   if (DoDirs && (DirList != NULL)) {
      DirList->Count = DirCount;
      DirList->Level = Level;
      DirList->parent = Dir;
      DirList->DirBuffer[DirCount - 1].Last = TRUE;
   }

   if (FileList != NULL) {
      FileList->Count = FileCount;
      FileList->parent = Dir;
   }

   // transfer the temp buffers to our list structures
   DirCount = FileCount = 0;
   for (i = 0; i < Count; i++) {
      if (ffd[i].dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
         // Directories
         if (DoDirs) {
            // Check our Flag
            if (ffd[i].cAlternateFileName[0] == 1) {
               DBuff = &DirList->DirBuffer[DirCount];
               DBuff->Attributes = ffd[i].dwFileAttributes;
               lstrcpy(DBuff->Name, ffd[i].cFileName);
               DBuff->parent = DirList;

               // Check against the subdirs we don't want to convert by default
               // if the user has already toggled that these should be converted,
               // then the copy of the old info below will fix it back up.
               if (SysDir && (Level == 1) && SubdirRestrict(Path, DBuff->Name)) {
                  DBuff->Convert = CONVERT_NONE;
                  DBuff->Special = TRUE;
               } else
                  DBuff->Convert = Convert;

               DirCount++;
            }
         }
      } else {
         // Files
         Panel_Line(8, TEXT("%s"), ffd[i].cFileName);

         // Check our Flag
         if (ffd[i].cAlternateFileName[0] == 1) {
            FBuff = &FileList->FileBuffer[FileCount];
            FBuff->Attributes = ffd[i].dwFileAttributes;
            lstrcpy(FBuff->Name, ffd[i].cFileName);
            FBuff->parent = FileList;
            FBuff->Convert = Convert;
            FBuff->Size = ffd[i].nFileSizeLow;

            TotalFileSize += ffd[i].nFileSizeLow;
            Panel_Line(9, TEXT("%s"), lToStr(TotalFileSize));
            FileCount++;
         }
      }

   }


   // Now have the new lists filled in.  If there was an old list then we must 
   // now merge ... can we say pain in the #$$
   if (DoDirs) {
      OldDirList = (DIR_LIST *) Dir->DirList;
      Dir->DirList = DirList;
   }

   OldFileList = (FILE_LIST *) Dir->FileList;
   Dir->FileList = FileList;

   // Check the directories
   if (DoDirs && (OldDirList != NULL) && (DirList != NULL)) {
      int cmp;

      DirCount = 0;
      i = 0;

      while (i < OldDirList->Count) {
         do {
            cmp = lstrcmpi(OldDirList->DirBuffer[i].Name, DirList->DirBuffer[DirCount].Name);

            // a match so copy old data into new...
            if (!cmp) {
               DBuff = &DirList->DirBuffer[DirCount];
               DBuff->Convert = OldDirList->DirBuffer[i].Convert;
               DBuff->DirList = OldDirList->DirBuffer[i].DirList;
               DBuff->FileList = OldDirList->DirBuffer[i].FileList;

               // Now point these back to the new structures
               if (DBuff->DirList)
                  DBuff->DirList->parent = DBuff;

               if (DBuff->FileList)
                  DBuff->FileList->parent = DBuff;
            }

            // keep incrementing new dir list until we go past old server
            // list, then must skip out and increment old server list
            DirCount++;
         } while ((DirCount < DirList->Count) && (cmp > 0));

         if (DirCount >= DirList->Count)
            break;

         i++;
      }
   }

   // Same stuff for the files
   if ((OldFileList != NULL) && (FileList != NULL)) {
      int cmp;

      FileCount = 0;
      i = 0;

      while (i < OldFileList->Count) {
         do {
            cmp = lstrcmpi(OldFileList->FileBuffer[i].Name, FileList->FileBuffer[FileCount].Name);

            // a match so copy old data into new...
            if (!cmp)
               FileList->FileBuffer[FileCount].Convert = OldFileList->FileBuffer[i].Convert;

            FileCount++;
         } while ((FileCount < FileList->Count) && (cmp > 0));

         if (FileCount >= FileList->Count)
            break;

         i++;
      }
   }

   // Clean up any old lists
   if (OldDirList != NULL)
      FreeMemory(OldDirList);

   if (OldFileList != NULL)
      FreeMemory(OldFileList);

   DirAdjustConvert(Dir);

} // FillDir


/////////////////////////////////////////////////////////////////////////
VOID
_TreeFillRecurse(
   UINT Level, 
   LPTSTR Path, 
   DIR_BUFFER *Dir
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   TCHAR NewPath[MAX_UNC_PATH + 1];
   DIR_LIST *DirList = NULL;
   ULONG i;

   FillDir(Level, Path, Dir, TRUE);
   DirList = Dir->DirList;

   if (DirList != NULL)
      for (i = 0; i < DirList->Count; i++) {

         if (Panel_Cancel())
            return;

         if (DirList->DirBuffer[i].Convert) {
            wsprintf(NewPath, TEXT("%s\\%s"), Path, DirList->DirBuffer[i].Name);
            _TreeFillRecurse(Level + 1, NewPath, &DirList->DirBuffer[i]);
         }
      }

} // _TreeFillRecurse


/////////////////////////////////////////////////////////////////////////
VOID
TreeFillRecurse(
   UINT Level, 
   LPTSTR Path, 
   DIR_BUFFER *Dir
   )
{
   TotalFileSize = 0;
   FillDirInit();
   _TreeFillRecurse(Level, Path, Dir);
} // TreeFillRecurse


/////////////////////////////////////////////////////////////////////////
ULONG 
TotalFileSizeGet()

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   return TotalFileSize;
} // TotalFileSizeGet


/////////////////////////////////////////////////////////////////////////
VOID
TreeRecurseCurrentShareSet(
   SHARE_BUFFER *CShare
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   CurrentShare = CShare;

   SysDir = FALSE;
   if (!CShare)
      return;

   if (!lstrcmpi(CShare->Name, Lids(IDS_S_6)))
      SysDir = TRUE;

   return;

} // TreeRecurseCurrentShareSet


/////////////////////////////////////////////////////////////////////////
VOID
   TreeRootInit(
   SHARE_BUFFER *CShare,
   LPTSTR NewPath
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   TreeRecurseCurrentShareSet(CShare);

   if (CShare->Root)
      return;

   CShare->Root = AllocMemory(sizeof(DIR_BUFFER));
   lstrcpy(CShare->Root->Name, NewPath);
   CShare->Root->Last = TRUE;
   CShare->Root->Attributes = FILE_ATTRIBUTE_DIRECTORY;

   CShare->Root->DirList = NULL;
   CShare->Root->FileList = NULL;
   CShare->Root->parent = NULL;

   // have to set this to preserve user selection of special excluded dirs...
   if (SysDir)
      CShare->Root->Special = TRUE;

   CShare->Root->Convert = CONVERT_ALL;

   FillDir(1, CShare->Root->Name, CShare->Root, TRUE);
   DirAdjustConvert(CShare->Root);

} // TreeRootInit


/////////////////////////////////////////////////////////////////////////
VOID
ControlsResize(
   HWND hDlg, 
   int Height, 
   int Width
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   HWND hCtrl;
   int nHeight, nWidth, BtnWidth, BtnHeight;
   RECT rc;

   hCtrl = GetDlgItem(hDlg, IDOK);
   GetWindowRect(hCtrl, &rc);
   BtnWidth = (rc.right - rc.left);
   BtnHeight = (rc.bottom - rc.top);

   // Get size of first listbox and figure height as it is same for both
   hCtrl = GetDlgItem(hDlg, IDC_LIST1);
   GetWindowRect(hCtrl, &rc);
   List1Width = (rc.right - rc.left);
   nHeight = Height - Y_BORDER - BtnHeight - (2 * BUTTON_Y_BORDER);     // subtract out borders
   Splitter_Bottom = nHeight + Y_BORDER;
   Splitter_Left = List1Width + X_BORDER;

   // First Listbox never changes width on Window resize
   MoveWindow(hCtrl, X_BORDER, Y_BORDER, List1Width, nHeight, TRUE);
   GetWindowRect(hCtrl, &rc);
   nHeight = (rc.bottom - rc.top);

   // Second Listbox has width based on first and new size of Window.
   if (Width > (2 * X_BORDER) + SPLITTER_WIDTH)
      nWidth = Width - ( 2 * X_BORDER) - SPLITTER_WIDTH;
   else
      nWidth = 1;

   // Now must take off from first listbox
   if (nWidth > List1Width)
      nWidth -= List1Width;
   else
      nWidth = 1;

   hCtrl = GetDlgItem(hDlg, IDC_LIST2);
   MoveWindow(hCtrl, X_BORDER + List1Width + SPLITTER_WIDTH, Y_BORDER, nWidth, nHeight, TRUE);

   // Figure out where to put the buttons
   nWidth = (Width / 2) - (((3 * BtnWidth) + (2 * BUTTON_X_BORDER)) / 2);
   nHeight = Height - BtnHeight - BUTTON_Y_BORDER;
   hCtrl = GetDlgItem(hDlg, IDOK);
   MoveWindow(hCtrl, nWidth, nHeight, BtnWidth, BtnHeight, TRUE);
   nWidth += BtnWidth + BUTTON_X_BORDER;

   hCtrl = GetDlgItem(hDlg, IDCANCEL);
   MoveWindow(hCtrl, nWidth, nHeight, BtnWidth, BtnHeight, TRUE);
   nWidth += BtnWidth + BUTTON_X_BORDER;

   hCtrl = GetDlgItem(hDlg, IDHELP);
   MoveWindow(hCtrl, nWidth, nHeight, BtnWidth, BtnHeight, TRUE);

} // ControlsResize


/////////////////////////////////////////////////////////////////////////
VOID 
FileSelect_OnDrawItem(
   HWND hwnd, 
   DRAWITEMSTRUCT FAR* lpDrawItem
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   TCHAR  szText[MAX_PATH + 1];
   DWORD_PTR dwData;
   int nLevel = 0;
   int nTempLevel;
   int nRow = 0;
   int nColumn = 0;
   int chkColumn = 0;
   DWORD dwConnectLevel = 0;
   DWORD dwMask;
   DIR_BUFFER *Dir, *Dir2;
   FILE_BUFFER *File;
   DIR_LIST *DirList, *DirList2;
   BOOL FileBox = FALSE;

   dwData = lpDrawItem->itemData;
   if (dwData == 0)
      return;

   if ((lpDrawItem->CtlID != IDC_LIST1) && (lpDrawItem->CtlID != IDC_LIST2))
      return;

   if (lpDrawItem->CtlID == IDC_LIST2)
      FileBox = TRUE;

   // Select the correct icon, open folder, closed folder, or document.

   if (FileBox) {
      File = (FILE_BUFFER *) dwData;
      lstrcpy(szText, File->Name);
      nRow = 1;
      chkColumn = File->Convert;
   } else {

      Dir2 = Dir = (DIR_BUFFER *) dwData;
      lstrcpy(szText, Dir->Name);
      chkColumn = Dir->Convert;
      DirList2 = DirList = (DIR_LIST *) Dir->parent;

      if (DirList != NULL)
         nLevel = DirList->Level;

      // Is it open ?
      if ( HierFile_IsOpened(&HierDrawStruct, dwData) )
         nColumn = 1;
      else
         nColumn = 0;

      // Connect level figures out what connecting lines should be drawn
      // - stored as a bitmask.
      if (nLevel == 0)
         dwConnectLevel = 0;
      else {
         nTempLevel = nLevel - 1;

         // First bit to set
         dwMask = (DWORD) pow(2, nLevel - 1);

         // Now go through and figure out what else to set...
         while (nTempLevel >= 0) {
            // Check if last child at this level...
            if (!Dir2->Last)
               dwConnectLevel |= dwMask;

            // figure out next parent...
            Dir2 = DirList2->parent;
            DirList2 = Dir2->parent;

            // move mask bit over, and up a level.
            dwMask /= 2;

            // move up one level.
            nTempLevel--;
         }
      }
   }

   // All set to call drawing function.
   HierFile_OnDrawItem(hwnd, lpDrawItem, nLevel, dwConnectLevel, szText,
                  nRow, nColumn, chkColumn, &HierDrawStruct);

   return;

} // FileSelect_OnDrawItem


/////////////////////////////////////////////////////////////////////////
VOID
RecursePath(
   LPTSTR Path, 
   DIR_BUFFER *Dir
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   DIR_LIST *DirList;
   ULONG i;

   DirList = (DIR_LIST *) Dir->parent;

   if (DirList != NULL)
      RecursePath(Path, (DIR_BUFFER *) DirList->parent);

   i = lstrlen(Path);
   if (i)
      if (Path[i-1] != TEXT('\\'))
         lstrcat(Path, TEXT("\\"));

   lstrcat(Path, Dir->Name);
} // RecursePath


/////////////////////////////////////////////////////////////////////////
VOID 
CloseList(
   HWND hWndList, 
   DIR_BUFFER *Dir, 
   WORD wItemNum
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   DWORD_PTR dwIncr;
   DWORD Count;
   DIR_LIST *DirList;

   HierFile_CloseItem(&HierDrawStruct, (DWORD_PTR) Dir);
   DirList = (DIR_LIST *) Dir->DirList;

   if (DirList != NULL) {
      Count = DirList->Count;

      // Remove the child items. Close any children that are open on the way.
      // wItem can stay constant - we are moveing stuff up in the listbox as we are deleting.
      wItemNum++;
      dwIncr = SendMessage(hWndList, LB_GETITEMDATA, wItemNum, 0L);

      while (Count) {
         // Is this child open ?
         if ( HierFile_IsOpened(&HierDrawStruct, dwIncr) ) {
            CloseList(hWndList, (DIR_BUFFER *) dwIncr, wItemNum);
         }

         SendMessage(hWndList, LB_DELETESTRING, wItemNum, 0L);
         dwIncr = SendMessage(hWndList, LB_GETITEMDATA, wItemNum, 0L);
         Count--;
      }

   }

} // CloseList


/////////////////////////////////////////////////////////////////////////
VOID 
FileSelect_ActionItem(
   HWND hWndList, 
   DWORD_PTR dwData, 
   WORD wItemNum
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR NewPath[MAX_PATH + 1];
   DWORD Count = 0;
   DIR_BUFFER *Dir;
   DIR_LIST *DirList;
   FILE_LIST *FileList;
   ULONG i;

   if (!dwData)
      return;

   // Is it open ?
   if ( HierFile_IsOpened(&HierDrawStruct, dwData) ) {

      // It's open ... Close it
      Dir = (DIR_BUFFER *) dwData;
      DirList = (DIR_LIST *) Dir->DirList;
      CloseList(hWndList, Dir, wItemNum);
   } else {

      // It's closed ... Open it
      HierFile_OpenItem(&HierDrawStruct, dwData);

      SendMessage(hWndList, WM_SETREDRAW, FALSE, 0L);   // Disable redrawing.

      CursorHourGlass();

      Dir = (DIR_BUFFER *) dwData;
#ifdef DEBUG
dprintf(TEXT("Opening dir: %s\r\n"), Dir->Name);
#endif

      DirList = (DIR_LIST *) Dir->parent;
      if (DirList == NULL)
         FillDir(1, Dir->Name, Dir, TRUE);
      else {
         // recurse backwards to create full path
         lstrcpy(NewPath, TEXT(""));
         RecursePath(NewPath, Dir);
         FillDir(DirList->Level + 1, NewPath, Dir, TRUE);
      }

      DirList = NULL;

      // Check if we have visited this node, if not allocate and fill it in.
      if (Dir->DirList != NULL) {
         DirList = (DIR_LIST *) Dir->DirList;
         Count = DirList->Count;

         for (i = 0; i < DirList->Count; i++) {
            SendMessage(hWndList, LB_INSERTSTRING, (WPARAM) wItemNum + i + 1, (LPARAM) &DirList->DirBuffer[i]);
         }

      }

#ifdef DEBUG
if (Dir->FileList == NULL)
   dprintf(TEXT("FileList NULL\r\n"));
#endif

      if (Dir->FileList != NULL) {
         FileList = (FILE_LIST *) Dir->FileList;

#ifdef DEBUG
dprintf(TEXT("FileList Count: %li\r\n"), FileList->Count);
#endif
         SendMessage(hwndList2, LB_RESETCONTENT, (WPARAM) 0, (LPARAM) 0L);
         for (i = 0; i < FileList->Count; i++) {
            SendMessage(hwndList2, LB_ADDSTRING, (WPARAM) 0, (LPARAM) &FileList->FileBuffer[i]);
         }

      }

      // Make sure as many child items as possible are showing
      HierFile_ShowKids(&HierDrawStruct, hWndList, (WORD) wItemNum, (WORD) Count );

      CursorNormal();
   }

   SendMessage(hWndList, WM_SETREDRAW, TRUE, 0L);   // Enable redrawing.
   InvalidateRect(hWndList, NULL, TRUE);            // Force redraw

} // FileSelect_ActionItem


/////////////////////////////////////////////////////////////////////////
VOID
TreeOpenRecurse(
   DIR_BUFFER *Dir,
   WORD *wItemNum
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   DIR_LIST *DirList = NULL;
   ULONG i;

   // if it's closed, open it
   if ( !HierFile_IsOpened(&HierDrawStruct, (DWORD_PTR) Dir) )
      FileSelect_ActionItem(hwndList1, (DWORD_PTR) Dir, *wItemNum);

   DirList = Dir->DirList;
   if (DirList != NULL) {

      for (i = 0; i < DirList->Count; i++) {
         (*wItemNum)++;
         // Now recurse down the children
         TreeOpenRecurse(&DirList->DirBuffer[i], wItemNum);
      }
   }

} // TreeOpenRecurse


/////////////////////////////////////////////////////////////////////////
VOID
FileSelect_UpdateFiles(
   HWND hDlg
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR NewPath[MAX_PATH + 1];
   WORD wItemNum;
   DWORD dwData;
   HWND hCtrl;
   ULONG i;
   FILE_LIST *FileList;
   DIR_BUFFER *Dir;
   DIR_LIST *DirList;

   hCtrl = GetDlgItem(hDlg, IDC_LIST1);
   wItemNum = (WORD) SendMessage(hCtrl, LB_GETCURSEL, 0, 0L);

   if (wItemNum == (WORD) LB_ERR)
      wItemNum = LastFocus;

   // Check first listbox and resynch the directory information so that we
   // pick up the current file list.
   LastFocus = wItemNum;
   dwData = (DWORD) SendMessage(hCtrl, LB_GETITEMDATA, wItemNum, 0L);

   if ((dwData == (DWORD) LB_ERR) || (dwData == 0))
      return;

   Dir = (DIR_BUFFER *) dwData;
#ifdef DEBUG
dprintf(TEXT("Opening dir: %lX %s\r\n"), Dir->parent, Dir->Name);
#endif

   DirList = (DIR_LIST *) Dir->parent;
   if (DirList == NULL)
      FillDir(1, Dir->Name, Dir, FALSE);
   else {
      // recurse backwards to create full path
      lstrcpy(NewPath, TEXT(""));
      RecursePath(NewPath, Dir);
      FillDir(DirList->Level + 1, NewPath, Dir, FALSE);
   }

   // Since Dir pointer was changed need to update listbox pointer
   SendMessage(hCtrl, LB_SETITEMDATA, wItemNum, (LPARAM) Dir);

   // We have not re-synched the directory so we have the correct file info
   // now reset the file listbox and fill it with the new file-list.
   SendMessage(hwndList2, LB_RESETCONTENT, (WPARAM) 0, (LPARAM) 0L);

   if (Dir->FileList != NULL) {
      FileList = (FILE_LIST *) Dir->FileList;

#ifdef DEBUG
dprintf(TEXT("FileList Count: %li\r\n"), FileList->Count);
#endif
       for (i = 0; i < FileList->Count; i++)
          SendMessage(hwndList2, LB_ADDSTRING, (WPARAM) 0, (LPARAM) &FileList->FileBuffer[i]);

   }

} // FileSelect_UpdateFiles


/////////////////////////////////////////////////////////////////////////
VOID
FileSelect_OnCommand(
   HWND hDlg, 
   WPARAM wParam, 
   LPARAM lParam
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR NewPath[MAX_PATH + 1];
   int wmId, wmEvent;
   WORD wItemNum;
   DWORD dwData;
   HWND hCtrl;
   DIR_LIST *DirList;
   FILE_LIST *FileList;
   DIR_BUFFER *Dir;
   int nLevel = 0;

   wmId    = LOWORD(wParam);
   wmEvent = HIWORD(wParam);

   switch (wmId) {

      case IDOK:
         // If we are on either of the listboxes, then use the Enter key to
         // activate the selected item
         if (ListFocus == hwndList1) {
            hCtrl = GetDlgItem(hDlg, IDC_LIST1);
            wItemNum = (WORD) SendMessage(hCtrl, LB_GETCURSEL, 0, 0L);
            dwData = (DWORD) SendMessage(hCtrl, LB_GETITEMDATA, wItemNum, 0L);

            if ((wItemNum == (WORD) LB_ERR) || (dwData == LB_ERR) || (dwData == 0))
               break;

            FileSelect_ActionItem(hCtrl, dwData, wItemNum);
         } else {
            CurrentShare->HiddenFiles = HiddenFiles;
            CurrentShare->SystemFiles = SystemFiles;

            // Delete our copy of the tree and prune the tree down to minimum
            // storage space
            TreeDelete(oDir);
            TreePrune(CurrentShare->Root);

            EndDialog(hDlg, 0);
         }

         break;

      case IDCANCEL:

         // Disable listboxes since we are deleting their item data
         SendDlgItemMessage(hDlg, IDC_LIST1, WM_SETREDRAW, FALSE, 0L);
         SendDlgItemMessage(hDlg, IDC_LIST2, WM_SETREDRAW, FALSE, 0L);

         // Get back our old tree
         if (CurrentShare->Root != NULL)
            TreeDelete(CurrentShare->Root);
         CurrentShare->Root = oDir;

         EndDialog(hDlg, 0);
         break;

      case IDHELP:
         WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDC_HELP_FTRANS);
         break;

      case IDM_EXP_ONE:
         // expand the current node
         hCtrl = GetDlgItem(hDlg, IDC_LIST1);
         wItemNum = (WORD) SendMessage(hCtrl, LB_GETCURSEL, 0, 0L);
         dwData = (DWORD) SendMessage(hCtrl, LB_GETITEMDATA, wItemNum, 0L);

         if ((wItemNum == (WORD) LB_ERR) || (dwData == LB_ERR) || (dwData == 0))
            break;

         if ( !HierFile_IsOpened(&HierDrawStruct, dwData) )
            FileSelect_ActionItem(hCtrl, dwData, wItemNum);

         break;

      case IDM_EXP_ALL:
         // Open all children from the root
         wItemNum = 0;
         hCtrl = GetDlgItem(hDlg, IDC_LIST1);
         goto ExpandTree;

      case IDM_EXP_BRANCH:
         // Traverse down the branch, opening up all children
         hCtrl = GetDlgItem(hDlg, IDC_LIST1);
         wItemNum = (WORD) SendMessage(hCtrl, LB_GETCURSEL, 0, 0L);

ExpandTree:
         dwData = (DWORD) SendMessage(hCtrl, LB_GETITEMDATA, wItemNum, 0L);
         if ((wItemNum == (WORD) LB_ERR) || (dwData == LB_ERR) || (dwData == 0))
            break;

         Dir = (DIR_BUFFER *) dwData;
         CursorHourGlass();

         TreeOpenRecurse(Dir, &wItemNum);

         CursorNormal();

         // Force redraw
         InvalidateRect(hwndList1, NULL, TRUE);
         break;

      case IDM_COLLAPSE:
         // Close the current branch
         hCtrl = GetDlgItem(hDlg, IDC_LIST1);
         wItemNum = (WORD) SendMessage(hCtrl, LB_GETCURSEL, 0, 0L);
         dwData = (DWORD) SendMessage(hCtrl, LB_GETITEMDATA, wItemNum, 0L);

         if ((wItemNum == (WORD) LB_ERR) || (dwData == LB_ERR) || (dwData == 0))
            break;

         if ( HierFile_IsOpened(&HierDrawStruct, dwData) )
            FileSelect_ActionItem(hCtrl, dwData, wItemNum);

         break;

      // Not used currently
      case IDM_VIEW_BOTH:
      case IDM_VIEW_TREE:
      case IDM_VIEW_DIR:
         break;

      case IDM_HIDDEN:
         HiddenFiles = !HiddenFiles;
         CheckMenuItem((HMENU) wParam, IDM_HIDDEN, HiddenFiles ? MF_CHECKED : MF_UNCHECKED);
         PostMessage(hDlg, WM_COMMAND, ID_REDRAWLIST, 0L);
         break;

      case IDM_SYSTEM:
         SystemFiles = !SystemFiles;
         CheckMenuItem((HMENU) wParam, IDM_SYSTEM, SystemFiles ? MF_CHECKED : MF_UNCHECKED);
         PostMessage(hDlg, WM_COMMAND, ID_REDRAWLIST, 0L);
         break;

      case ID_REDRAWLIST:
         FileSelect_UpdateFiles(hDlg);
         break;

      case IDC_LIST1:

         switch (wmEvent) {
            case LBN_SETFOCUS:
               ListFocus = hwndList1;
               break;

            case LBN_KILLFOCUS:
               ListFocus = NULL;
               break;

            case LBN_DBLCLK:
               // Disregard the DBLCLK message if it is inside a checkbox.
               hCtrl = GetDlgItem(hDlg, IDC_LIST1);

               // First figure out where checkbox is located in listbox
               wItemNum = (WORD)  SendMessage(hCtrl, LB_GETCURSEL, 0, 0L);
               dwData   = (DWORD) SendMessage(hCtrl, LB_GETITEMDATA, wItemNum, 0L);

               if ((wItemNum == (WORD) LB_ERR) || (dwData == LB_ERR) || (dwData == 0))
                  break;

               Dir = (DIR_BUFFER *) dwData;
               DirList = (DIR_LIST *) Dir->parent;

               if (DirList != NULL)
                  nLevel = DirList->Level;

               if (!HierFile_InCheck(nLevel, LOWORD(mouseHit), &HierDrawStruct)) {
                  CursorHourGlass();
                  FileSelect_ActionItem(hCtrl, dwData, wItemNum);
                  CursorNormal();
               }

               break;

            case LBN_SELCHANGE:
               FileSelect_UpdateFiles(hDlg);
               break;

         }

         break;

      case ID_UPDATELIST:
         hCtrl = GetDlgItem(hDlg, IDC_LIST1);
         if (CurrentShare->Root == NULL) {
            wsprintf(NewPath, TEXT("\\\\%s\\%s\\"), SServ->Name, CurrentShare->Name);

#ifdef DEBUG
// lstrcpy(NewPath, TEXT("c:\\"));
dprintf(TEXT("Root Path: %s\n"), NewPath);
#endif
            TreeRootInit(CurrentShare, NewPath);
         }

         PostMessage(hCtrl, LB_SETCURSEL, (WPARAM) 0, 0L);
         LastFocus = 0;

         DirList = (DIR_LIST *) CurrentShare->Root->DirList;
         FileList = (FILE_LIST *) CurrentShare->Root->FileList;

         wItemNum = (WORD) SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) CurrentShare->Root);
         PostMessage(hDlg, WM_COMMAND, ID_REDRAWLIST, 0L);

         break;

   }

} // FileSelect_OnCommand


/////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK 
FileSelectSubClassProc(
   HWND hWnd, 
   UINT message, 
   WPARAM wParam, 
   LPARAM lParam
   )

/*++

Routine Description:

    Handles key processing for the hierarchical listbox.  Specifically
    the up/down arrow keys and the letter keys.

Arguments:


Return Value:


--*/

{
   LRESULT lResult = 0;
   BOOL fCallOrigProc = TRUE;
   WORD wItemNum, wNewNum;
   DWORD dwData;
   DIR_BUFFER *Dir;
   DIR_LIST *DirList;
   FILE_BUFFER *File;
   int nLevel = 0;
   DWORD_PTR lHeight;
   DWORD PageCount, ListHeight;

   RECT rc;

   switch (message) {
      case WM_LBUTTONDOWN:
         // Send message to check if button-down is within our checkbox
         wItemNum = (WORD)  SendMessage(hWnd, LB_GETCURSEL, 0, 0L);

         // Save the location off so we can check it during a DBLCLK message
         // to see if we are inside a checkbox.
         mouseHit = lParam;

         // Post the message so the current selection is correct
         PostMessage(hWnd, WM_COMMAND, ID_CHECKCHECK, lParam);
         break;

      case WM_COMMAND:
         // Code for handling checkbox clicking
         if (wParam == ID_CHECKCHECK) {
            // First figure out where checkbox is located in listbox
            wItemNum = (WORD)  SendMessage(hWnd, LB_GETCURSEL, 0, 0L);
            dwData   = (DWORD) SendMessage(hWnd, LB_GETITEMDATA, wItemNum, 0L);

            if (wItemNum == (WORD) LB_ERR)
               break;

            if (hWnd == hwndList2) {
               File = (FILE_BUFFER *) dwData;

               if (HierFile_InCheck(nLevel, LOWORD(lParam), &HierDrawStruct)) {
                  if (File->Convert == CONVERT_NONE)
                     File->Convert = CONVERT_ALL;
                  else
                     File->Convert = CONVERT_NONE;

                  DirAdjustConvert(File->parent->parent);
               }

            } else {
               Dir = (DIR_BUFFER *) dwData;
               DirList = (DIR_LIST *) Dir->parent;

               if (DirList != NULL)
                  nLevel = DirList->Level;

               if (HierFile_InCheck(nLevel, LOWORD(lParam), &HierDrawStruct)) {
                  if (Dir->Convert == CONVERT_NONE)
                     DirAdjustConvertChildren(Dir, CONVERT_ALL);
                  else
                     DirAdjustConvertChildren(Dir, CONVERT_NONE);

                  DirAdjustConvert(Dir);
               }
            }

            // Now check if button click was within checkbox boundaries...
            if (HierFile_InCheck(nLevel, LOWORD(lParam), &HierDrawStruct)) {

               // We have set the checkbox state correctly on the current item,
               //  and propageted this up and down the tree as necessary, now
               //  update the screen to reflect these changes.
               InvalidateRect(hWnd, NULL, TRUE);     // Force redraw

               // if this is the directory listbox then also need to redraw
               // the file listbox
               if (hWnd == hwndList1)
                  InvalidateRect(hwndList2, NULL, TRUE);

            }
         }

         break;

      case WM_KEYDOWN:
         wItemNum = (WORD)  SendMessage(hWnd, LB_GETCURSEL, 0, 0L);
         if (wItemNum != (WORD) LB_ERR)
            dwData = (DWORD) SendMessage(hWnd, LB_GETITEMDATA, wItemNum, 0L);
         else {
            wItemNum = 0;
            dwData = (DWORD) SendMessage(hWnd, LB_GETITEMDATA, wItemNum, 0L);
         }

         if ((wItemNum == (WORD) LB_ERR) || (dwData == LB_ERR) || (dwData == 0))
            break;

         fCallOrigProc = FALSE;

         switch (LOWORD(wParam)) {

            case VK_PRIOR:
               // Need to figure out the number of items to page.  This 
               // would be the listbox height divided by the height of
               // a listbox item
               lHeight = SendMessage(hWnd, LB_GETITEMHEIGHT, 0, 0L);
               GetWindowRect(hWnd, &rc);
               ListHeight = (rc.bottom - rc.top);

               if (ListHeight)
                  PageCount = ListHeight / (LONG) lHeight;
               else
                  PageCount = 0;

               // See if we page past the top - if so adjust it.
               if (wItemNum > PageCount)
                  wNewNum = (USHORT) (wItemNum - PageCount);
               else
                  wNewNum = 0;

               PostMessage(hWnd, LB_SETCURSEL, (WPARAM) wNewNum, 0L);

               if (hWnd == hwndList1)
                  PostMessage(GetParent(hWnd), WM_COMMAND, ID_REDRAWLIST, 0L);

               break;

            case VK_NEXT:
               // Need to figure out the number of items to page.  This 
               // would be the listbox height divided by the height of
               // a listbox item
               lHeight = SendMessage(hWnd, LB_GETITEMHEIGHT, 0, 0L);
               GetWindowRect(hWnd, &rc);
               ListHeight = (rc.bottom - rc.top);

               if (ListHeight)
                  PageCount = ListHeight / (ULONG) lHeight;
               else
                  PageCount = 0;

               // Figure out if we page past the end - if so adjust it
               wItemNum = (USHORT) (wItemNum + PageCount);
               wNewNum = (WORD) SendMessage(hWnd, LB_GETCOUNT, (WPARAM) 0, 0L);

               if (wItemNum < wNewNum)
                  PostMessage(hWnd, LB_SETCURSEL, (WPARAM) wItemNum, 0L);
               else
                  PostMessage(hWnd, LB_SETCURSEL, (WPARAM) (wNewNum - 1), 0L);

               if (hWnd == hwndList1)
                  PostMessage(GetParent(hWnd), WM_COMMAND, ID_REDRAWLIST, 0L);

               break;

            case VK_END:
               wItemNum = (WORD) SendMessage(hWnd, LB_GETCOUNT, (WPARAM) 0, 0L);

               if (wItemNum != (WORD) LB_ERR)
                  PostMessage(hWnd, LB_SETCURSEL, (WPARAM) (wItemNum - 1), 0L);

               if (hWnd == hwndList1)
                  PostMessage(GetParent(hWnd), WM_COMMAND, ID_REDRAWLIST, 0L);

               break;

            case VK_HOME:
               PostMessage(hWnd, LB_SETCURSEL, (WPARAM) 0, 0L);

               if (hWnd == hwndList1)
                  PostMessage(GetParent(hWnd), WM_COMMAND, ID_REDRAWLIST, 0L);

               break;

            case VK_UP:
               if (wItemNum > 0) {
                  wItemNum--;
                  PostMessage(hWnd, LB_SETCURSEL, (WPARAM) wItemNum, 0L);

                  if (hWnd == hwndList1)
                     PostMessage(GetParent(hWnd), WM_COMMAND, ID_REDRAWLIST, 0L);

               }
               break;

            case VK_DOWN:
               wItemNum++;
               PostMessage(hWnd, LB_SETCURSEL, (WPARAM) wItemNum, 0L);

               if (hWnd == hwndList1)
                  PostMessage(GetParent(hWnd), WM_COMMAND, ID_REDRAWLIST, 0L);

               break;

            case VK_F1:
               fCallOrigProc = TRUE;
               break;

            case VK_SPACE:
               // First figure out where checkbox is located in listbox
               wItemNum = (WORD)  SendMessage(hWnd, LB_GETCURSEL, 0, 0L);
               dwData   = (DWORD) SendMessage(hWnd, LB_GETITEMDATA, wItemNum, 0L);

               if (wItemNum == (WORD) LB_ERR)
                  break;

               if (hWnd == hwndList2) {
                  File = (FILE_BUFFER *) dwData;

                  if (File->Convert == CONVERT_NONE)
                     File->Convert = CONVERT_ALL;
                  else
                     File->Convert = CONVERT_NONE;

                  DirAdjustConvert(File->parent->parent);
               } else {
                  Dir = (DIR_BUFFER *) dwData;
                  DirList = (DIR_LIST *) Dir->parent;

                  if (DirList != NULL)
                     nLevel = DirList->Level;

                  if (Dir->Convert == CONVERT_NONE)
                     DirAdjustConvertChildren(Dir, CONVERT_ALL);
                  else
                     DirAdjustConvertChildren(Dir, CONVERT_NONE);

                  DirAdjustConvert(Dir);
               }

               // We have set the checkbox state correctly on the current item,
               //  and propageted this up and down the tree as necessary, now
               //  update the screen to reflect these changes.
               InvalidateRect(hWnd, NULL, TRUE);     // Force redraw

               // if this is the directory listbox then also need to redraw
               // the file listbox
               if (hWnd == hwndList1)
                  InvalidateRect(hwndList2, NULL, TRUE);

               break;

            default:
               break;

         }

         break;

   }

   if (fCallOrigProc)
      if (hWnd == hwndList2)
         lResult = CallWindowProc(_wpOrigWndProc2, hWnd, message, wParam, lParam);
      else
         lResult = CallWindowProc(_wpOrigWndProc, hWnd, message, wParam, lParam);

   return (lResult);

} // FileSelectSubClassProc


/////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK 
DlgFileSelect(
   HWND hDlg, 
   UINT message, 
   WPARAM wParam, 
   LPARAM lParam
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   int xPos;
   int yPos;
   BOOL InRange;
   RECT rc;
   HWND hCtrl;

   switch (message) {
      case WM_INITDIALOG:
         // Copy the tree
         oDir = CurrentShare->Root;
         CurrentShare->Root = TreeCopy(oDir);

         // Center the dialog over the application window
         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));
         GetClientRect(hDlg, &rc);
         ControlsResize(hDlg, (rc.bottom - rc.top), (rc.right - rc.left));

         // subclass listbox handler
         hCtrl = GetDlgItem(hDlg, IDC_LIST1);
         _wpOrigWndProc = SubclassWindow(hCtrl, FileSelectSubClassProc);
         hCtrl = GetDlgItem(hDlg, IDC_LIST2);
         _wpOrigWndProc2 = SubclassWindow(hCtrl, FileSelectSubClassProc);

         FillDirInit();

         hwndList2 = hCtrl = GetDlgItem(hDlg, IDC_LIST2);
         hwndList1 = GetDlgItem(hDlg, IDC_LIST1);

         // Fill listbox and set selection (is assumed there is always a selection)...
         PostMessage(hDlg, WM_COMMAND, ID_UPDATELIST, 0L);
         return (TRUE);

      case WM_INITMENU:
         if (GetMenu(hDlg) != (HMENU) wParam)
            break;

         CheckMenuItem((HMENU) wParam, IDM_HIDDEN, HiddenFiles ? MF_CHECKED : MF_UNCHECKED);
         CheckMenuItem((HMENU) wParam, IDM_SYSTEM, SystemFiles ? MF_CHECKED : MF_UNCHECKED);
         break;

      case WM_SIZE:
         ControlsResize(hDlg, HIWORD(lParam), LOWORD(lParam));
         break;

      case WM_SETFONT:
         // Set the text height
          HierFile_DrawSetTextHeight(GetDlgItem(hDlg, IDC_LIST1), (HFONT)wParam, &HierDrawStruct);
         break;

      case WM_DRAWITEM:
         FileSelect_OnDrawItem(hDlg, (DRAWITEMSTRUCT FAR*)(lParam));
         return TRUE;

      case WM_MEASUREITEM:
         HierFile_OnMeasureItem(hDlg, (MEASUREITEMSTRUCT FAR*)(lParam), &HierDrawStruct);
         return TRUE;

      case WM_MOUSEMOVE: {
            xPos = LOWORD(lParam);
            yPos = HIWORD(lParam);

            InRange = TRUE;

            // Check if it is correct Y-coordinate
            if ((yPos <= Y_BORDER) || (yPos >= Splitter_Bottom))
               InRange = FALSE;

            // Now Check X-coordinate
            if ((xPos < Splitter_Left) || (xPos > (Splitter_Left + X_BORDER)))
               InRange = FALSE;

            // Is within range of splitter, so handle it...
         }
         break;

      case WM_COMMAND:
         FileSelect_OnCommand(hDlg, wParam, lParam);
         break;
   }

   return (FALSE); // Didn't process the message

   lParam;
} // DlgFileSelect


/////////////////////////////////////////////////////////////////////////
VOID 
FileSelect_Do(
   HWND hDlg, 
   SOURCE_SERVER_BUFFER *SourceServ, 
   SHARE_BUFFER *CShare
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   DLGPROC lpfnDlg;

   TreeRecurseCurrentShareSet(CShare);
   SServ = SourceServ;

   HiddenFiles = CurrentShare->HiddenFiles;
   SystemFiles = CurrentShare->SystemFiles;

   // Init the Hier Draw stuff - Need to do this here so we have a value
   // for WM_MEASUREITEM which is sent before the WM_INITDIALOG message
   HierFile_DrawInit(hInst, IDR_FILEICONS, IDR_CHECKICONS, ROWS, COLS, TRUE, &HierDrawStruct, TRUE );

   lpfnDlg = MakeProcInstance((DLGPROC)DlgFileSelect, hInst);
   DialogBox(hInst, TEXT("FileSelect"), hDlg, lpfnDlg) ;
   FreeProcInstance(lpfnDlg);

   HierFile_DrawTerm(&HierDrawStruct);

} // FileSelect_Do
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\fpnwapi.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

// Munged needed defines from FPNW code - fpnwapi.h file

#ifndef _FPNWAPI_H_
#define _FPNWAPI_H_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

//
//  Volume types : disk or printer
//

#define NWVOL_TYPE_DISKTREE             FPNWVOL_TYPE_DISKTREE
#define NWVOL_TYPE_CDROM                FPNWVOL_TYPE_CDROM
#define NWVOL_TYPE_REMOVABLE            FPNWVOL_TYPE_REMOVABLE

#define NWVOL_MAX_USES_UNLIMITED        ((ULONG)-1)

//
//  Volume flags returned by VolumeGetInfo
//

#define FPNWVOL_TYPE_DISKTREE             0
#define FPNWVOL_TYPE_CDROM                104
#define FPNWVOL_TYPE_REMOVABLE            105

//
//  Permissions flags returned in structure FPNWFILEINFO
//

#define FPNWFILE_PERM_NONE                0
#define FPNWFILE_PERM_READ                0x01
#define FPNWFILE_PERM_WRITE               0x02
#define FPNWFILE_PERM_CREATE              0x04
#define FPNWFILE_PERM_EXEC                0x08
#define FPNWFILE_PERM_DELETE              0x10
#define FPNWFILE_PERM_ATRIB               0x20
#define FPNWFILE_PERM_PERM                0x40

typedef BYTE FPNWSERVERADDR[12];        // Network address, first 4 bytes is
                                        // the network number, and bytes
                                        // 5-10 is the physical node
                                        // address. The last two bytes are
                                        // reserved.

//
//  This is the level 1 structure for FpnwVolumeAdd, FpnwVolumeDel, FpnwVolumeEnum,
//  FpnwVolumeGetInfo, & FpnwVolumeSetInfo.
//

typedef struct _FPNWVolumeInfo
{
    LPWSTR    lpVolumeName;           // Name of the volume
    DWORD     dwType;                 // The type of the volume. It can be one of the
                                      // following: FPNWVOL_TYPE_DISK, FPNWVOL_TYPE_PRINT
    DWORD     dwMaxUses;              // Maximum number of connections that are
                                      // allowed to the volume
    DWORD     dwCurrentUses;          // Current number of connections to the volume
    LPWSTR    lpPath;                 // Path of the volume

} FPNWVOLUMEINFO, *PFPNWVOLUMEINFO;

typedef FPNWVOLUMEINFO  NWVOLUMEINFO, *PNWVOLUMEINFO;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\helpid.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _HHELPID_
#define _HHELPID_

#ifdef __cplusplus
extern "C"{
#endif

// Identifiers for help contexts

// Main dialog box
#define IDM_HELP_OPEN      500
#define IDM_HELP_INDEX     501
#define IDM_HELP_USING     502
#define IDC_HELP_MAIN      503

#define IDM_HELP_RCONFIG   504
#define IDM_HELP_SCONFIG   505
#define IDM_HELP_RDCONFIG  506
#define IDM_HELP_EXIT      507

#define IDM_HELP_HELPABOUT 508

// Select Servers for Conversion & Server Browse
#define IDC_HELP_ADD       520
#define IDC_HELP_BROWSENW  521
#define IDC_HELP_BROWSENT  522

// Logging dialog box
#define IDC_HELP_LOGGING   530

// User Options
#define IDC_HELP_USER      540
#define IDC_HELP_USERADV   541
#define IDC_HELP_TRUSTED   542

// File Options
#define IDC_HELP_FILE      550

// Add/Modify Share
#define IDC_HELP_SHAREADD  560
#define IDC_HELP_SHAREMOD  561
#define IDC_HELP_SHARENEW  562
#define IDC_HELP_SHAREPROP 563

// Files to Transfer
#define IDC_HELP_FTRANS    570
#define IDM_HELP_EXPL      571
#define IDM_HELP_EXPB      572
#define IDM_HELP_EXPA      573
#define IDM_HELP_COLLAPSE  574
#define IDM_HELP_VTDIR     575
#define IDM_HELP_VTREE     576
#define IDM_HELP_VDIR      577
#define IDM_HELP_SPLIT     578
#define IDM_HELP_THIDDEN   579
#define IDM_HELP_TSYSTEM   580
#define IDM_HELP_TKEEP     581

// Mapping Create
#define IDC_HELP_CMAP      590

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\hierdraw.c ===
#include <windows.h>
#include <windowsx.h>
#include <malloc.h>
#include <string.h>

#include "hierdraw.h"


VOID HierDraw_DrawTerm(LPHEIRDRAWSTRUCT lpHierDrawStruct) {
   if (lpHierDrawStruct->hbmIcons) {
       if (lpHierDrawStruct->hbmMem)
           SelectObject(lpHierDrawStruct->hdcMem,lpHierDrawStruct->hbmMem);
       lpHierDrawStruct->hbmMem = NULL;
       DeleteObject(lpHierDrawStruct->hbmIcons);
       lpHierDrawStruct->hbmIcons = NULL;
   }

   if ( lpHierDrawStruct->hdcMem ) {
      DeleteDC(lpHierDrawStruct->hdcMem);
      lpHierDrawStruct->hdcMem = NULL;
   }
} // HierDraw_DrawTerm

VOID HierDraw_DrawCloseAll(LPHEIRDRAWSTRUCT lpHierDrawStruct ) {
   lpHierDrawStruct->NumOpened= 0;
   if ( lpHierDrawStruct->Opened ) {
      _ffree(lpHierDrawStruct->Opened);
   }
   lpHierDrawStruct->Opened = NULL;
} // HierDraw_DrawCloseAll

VOID HierDraw_OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT FAR* lpMeasureItem,
                            LPHEIRDRAWSTRUCT lpHierDrawStruct) {
   lpMeasureItem->itemHeight = max(lpHierDrawStruct->nBitmapHeight,
                                   lpHierDrawStruct->nTextHeight);
} // HierDraw_OnMeasureItem

VOID HierDraw_DrawSetTextHeight (HWND hwndList, HFONT hFont, LPHEIRDRAWSTRUCT lpHierDrawStruct ) {
   TEXTMETRIC      TextMetrics;
   HANDLE          hOldFont=NULL;
   HDC             hdc;

   //
   // This sure looks like a lot of work to find the character height
   //
   hdc = GetDC(hwndList);

   hOldFont = SelectObject(hdc, hFont);
   GetTextMetrics(hdc, &TextMetrics);
   SelectObject(hdc, hOldFont);
   ReleaseDC(hwndList, hdc);

   lpHierDrawStruct->nTextHeight = TextMetrics.tmHeight;

   lpHierDrawStruct->nLineHeight =
         max(lpHierDrawStruct->nBitmapHeight, lpHierDrawStruct->nTextHeight);

   if ( hwndList != NULL )
       SendMessage(hwndList, LB_SETITEMHEIGHT, 0,
                   MAKELPARAM(lpHierDrawStruct->nLineHeight, 0));
} // HierDraw_DrawSetTextHeight

static DWORD near RGB2BGR(DWORD rgb) {
    return RGB(GetBValue(rgb),GetGValue(rgb),GetRValue(rgb));
} // RGB2BGR

/*
 *  Creates the objects used while drawing the tree.  This may be called
 *  repeatedly in the event of a WM_SYSCOLORCHANGED message.
 *
 *  WARNING: the Tree icons bitmap is assumed to be a 16 color DIB!
 */

BOOL HierDraw_DrawInit(HINSTANCE hInstance,
                       int  nBitmap,
                       int  nRows,
                       int  nColumns,
                       BOOL bLines,
                       LPHEIRDRAWSTRUCT lpHierDrawStruct,
                       BOOL bInit) {
    HANDLE hRes;
    HANDLE hResMem;
    LPBITMAPINFOHEADER lpbiReadOnly;
    LPBITMAPINFOHEADER lpbiReadWrite;
    DWORD *lpColorTable;
    LPSTR lpBits;
    int biSize;
    int bc;
    HDC hDC;

    if ( bInit ) {
       lpHierDrawStruct->NumOpened = 0;
       lpHierDrawStruct->Opened = NULL;
       lpHierDrawStruct->bLines = bLines;
    }

    //
    // If the Memory DC is not created yet do that first.
    //
    if (!lpHierDrawStruct->hdcMem) {
        //
        // get a screen DC
        //
        hDC = GetDC(NULL);
        //
        // Create a memory DC compatible with the screen
        //
        lpHierDrawStruct->hdcMem = CreateCompatibleDC(hDC);
        //
        // Release the Screen DC
        ReleaseDC(NULL,hDC);

        if (!lpHierDrawStruct->hdcMem)
            return FALSE;

        lpHierDrawStruct->hbmMem = NULL;
    }

    //
    // (Re)Load the Bitmap ( original from disk )
    //
    // Use the FindResource,LoadResource,LockResource since it makes
    // it easy to get the pointer to the BITMAPINFOHEADER we need.
    //
    //
    hRes = FindResource(hInstance, MAKEINTRESOURCE(nBitmap), RT_BITMAP);
    if (!hRes)
        return FALSE;

    hResMem = LoadResource(hInstance, hRes);
    if (!hResMem)
        return FALSE;

    // Now figure out the bitmaps background color.
    // This code assumes the lower left corner is a
    // bit in the background color.
    lpbiReadOnly = (LPBITMAPINFOHEADER)LockResource(hResMem);
    if (!lpbiReadOnly)
        return FALSE;

    // Determine size of bitmap information header plus color table entries
    biSize = lpbiReadOnly->biSize + ((1 << (lpbiReadOnly->biBitCount)) * sizeof(RGBQUAD));

    // Allocate copy of the bitmap information to munge on
    lpbiReadWrite = (LPBITMAPINFOHEADER)GlobalAlloc(GPTR, biSize);
    if (!lpbiReadWrite)
        return FALSE;

    memcpy(lpbiReadWrite, lpbiReadOnly, biSize);

    // Color table immediately follows bitmap information header
    lpColorTable = (DWORD FAR *)((LPBYTE)lpbiReadWrite + lpbiReadWrite->biSize);

    // No need to munge bits so use original
    lpBits = (LPBYTE)lpbiReadOnly + biSize;

    bc = (lpBits[0] & 0xF0) >> 4;   // ASSUMES LOWER LEFT CORNER IS BG!!

    lpColorTable[bc] = RGB2BGR(GetSysColor(COLOR_WINDOW));

    hDC = GetDC(NULL);

    lpHierDrawStruct->hbmIcons = CreateDIBitmap(
                                    hDC,
                                    lpbiReadWrite,
                                    CBM_INIT,
                                    lpBits,
                                    (LPBITMAPINFO)lpbiReadWrite,
                                    DIB_RGB_COLORS
                                    );

    ReleaseDC(NULL,hDC);

    lpHierDrawStruct->nBitmapHeight = (WORD)lpbiReadWrite->biHeight / nRows;
    lpHierDrawStruct->nBitmapWidth = (WORD)lpbiReadWrite->biWidth / nColumns;

    lpHierDrawStruct->nLineHeight =
         max(lpHierDrawStruct->nBitmapHeight, lpHierDrawStruct->nTextHeight);

    GlobalFree(lpbiReadWrite);
    UnlockResource(hResMem);
    FreeResource(hResMem);

    if (!lpHierDrawStruct->hbmIcons)
        return FALSE;

    lpHierDrawStruct->hbmMem = SelectObject(lpHierDrawStruct->hdcMem,lpHierDrawStruct->hbmIcons);
    if (!lpHierDrawStruct->hbmMem)
        return FALSE;

    return TRUE;
} // HierDraw_DrawInit



VOID HierDraw_OnDrawItem(HWND  hwnd,
                         const DRAWITEMSTRUCT FAR* lpDrawItem,
                         int   nLevel,
                         DWORD dwConnectLevel,
                         TCHAR  *szText,
                         int   nRow,
                         int   nColumn,
                         LPHEIRDRAWSTRUCT lpHierDrawStruct) {
    HDC        hDC;
    WORD       wIndent, wTopBitmap, wTopText;
    RECT       rcTemp;


    if ( lpDrawItem->itemID == (UINT)-1 )
       return ;

    hDC = lpDrawItem->hDC;
    CopyRect(&rcTemp, &lpDrawItem->rcItem);

    wIndent = (WORD)(rcTemp.left + ((int)(nLevel) * lpHierDrawStruct->nBitmapWidth) + XBMPOFFSET);
    rcTemp.left = wIndent + lpHierDrawStruct->nBitmapWidth;
    wTopText = (WORD)(rcTemp.top + ((rcTemp.bottom - rcTemp.top) / 2) - (lpHierDrawStruct->nTextHeight / 2));
    wTopBitmap = (WORD)(rcTemp.top + ((rcTemp.bottom - rcTemp.top) / 2) - (lpHierDrawStruct->nBitmapHeight / 2));

    if (lpDrawItem->itemAction == ODA_FOCUS)
        goto DealWithFocus;
    else if (lpDrawItem->itemAction == ODA_SELECT)
        goto DealWithSelection;

    //
    // Draw some lions, if we like lions
    //

    if (lpHierDrawStruct->bLines && nLevel)
      {
        DWORD    dwMask = 1;
        int      nTempLevel;
        int      x,y;

        // draw lines in text color
        SetBkColor(hDC,GetSysColor(COLOR_WINDOWTEXT));

        //
        // Draw a series of | lines for outer levels
        //

        x = lpHierDrawStruct->nBitmapWidth/2 + XBMPOFFSET;

        for ( nTempLevel = 0; nTempLevel < nLevel ; nTempLevel++)
          {
            if ( dwConnectLevel & dwMask )
                FastRect(hDC,x,rcTemp.top,1,rcTemp.bottom - rcTemp.top);

            x += lpHierDrawStruct->nBitmapWidth;
            dwMask *= 2;
          }


        //
        // Draw the short vert line up towards the parent
        //
        nTempLevel = nLevel-1;
        dwMask *= 2;

        x = nTempLevel * lpHierDrawStruct->nBitmapWidth + lpHierDrawStruct->nBitmapWidth / 2 + XBMPOFFSET;

        if ( dwConnectLevel & dwMask )
            y = rcTemp.bottom;
        else
            y = rcTemp.bottom - lpHierDrawStruct->nLineHeight / 2;

        FastRect(hDC,x,rcTemp.top,1,y-rcTemp.top);

        //
        // Draw short horiz bar to right
        //
        FastRect(hDC,x,rcTemp.bottom-lpHierDrawStruct->nLineHeight/2,lpHierDrawStruct->nBitmapWidth/2,1);
      }

    //
    // Draw the selected bitmap
    //

    BitBlt(hDC,
           wIndent,wTopBitmap,
           lpHierDrawStruct->nBitmapWidth,lpHierDrawStruct->nBitmapHeight,
           lpHierDrawStruct->hdcMem,
           nColumn*lpHierDrawStruct->nBitmapWidth,
           nRow*lpHierDrawStruct->nBitmapHeight,
           SRCCOPY);

DealWithSelection:

    if (lpDrawItem->itemState & ODS_SELECTED)
      {
        SetBkColor(hDC,GetSysColor(COLOR_HIGHLIGHT));
        SetTextColor(hDC,GetSysColor(COLOR_HIGHLIGHTTEXT));
      }
    else
      {
        SetBkColor(hDC,GetSysColor(COLOR_WINDOW));
        SetTextColor(hDC,GetSysColor(COLOR_WINDOWTEXT));
      }


    ExtTextOut(hDC, rcTemp.left + 1, wTopText, ETO_CLIPPED|ETO_OPAQUE,
               &rcTemp,szText,lstrlen(szText), NULL);

    if (lpDrawItem->itemState & ODS_FOCUS && lpDrawItem->itemAction != ODA_SELECT) {
DealWithFocus:
        DrawFocusRect(hDC, &rcTemp);
    }


} // HierDraw_OnDrawItem


//
// draw a solid color rectangle quickly
//
static VOID near FastRect(HDC hDC, int x, int y, int cx, int cy) {
    RECT rc;

    rc.left = x;
    rc.right = x+cx;
    rc.top = y;
    rc.bottom = y+cy;
    ExtTextOut(hDC,x,y,ETO_OPAQUE,&rc,NULL,0,NULL);
} // FastRect


BOOL HierDraw_IsOpened(LPHEIRDRAWSTRUCT lpHierDrawStruct, DWORD_PTR dwData) {
   // For Now just a dumb  search
   //
   int Count;

   for ( Count = 0; Count < lpHierDrawStruct->NumOpened; Count++ ) {
     if ( lpHierDrawStruct->Opened[Count] == dwData ) {
        return TRUE;
     }
   }

   return FALSE;

} // HierDraw_IsOpened


VOID HierDraw_OpenItem(LPHEIRDRAWSTRUCT lpHierDrawStruct, DWORD_PTR dwData) {
    lpHierDrawStruct->NumOpened++;

    if (lpHierDrawStruct->Opened == NULL )
       lpHierDrawStruct->Opened =
        (DWORD_PTR *)_fmalloc(sizeof(DWORD_PTR)*lpHierDrawStruct->NumOpened);
    else
       lpHierDrawStruct->Opened =
        (DWORD_PTR *)_frealloc(lpHierDrawStruct->Opened,
               sizeof(DWORD_PTR)*lpHierDrawStruct->NumOpened);

    lpHierDrawStruct->Opened[lpHierDrawStruct->NumOpened-1] = dwData;
} // HierDraw_OpenItem


VOID HierDraw_CloseItem(LPHEIRDRAWSTRUCT lpHierDrawStruct, DWORD_PTR dwData) {
   // For Now just a dumb  search
   //
   int Count;

   for ( Count = 0; Count < lpHierDrawStruct->NumOpened; Count++ ) {
     if ( lpHierDrawStruct->Opened[Count] == dwData ) {
        if (--lpHierDrawStruct->NumOpened == 0 ) {
            _ffree(lpHierDrawStruct->Opened);
            lpHierDrawStruct->Opened = NULL;
        }
        else {
            if ( Count < lpHierDrawStruct->NumOpened ) {
               _fmemmove(&(lpHierDrawStruct->Opened[Count]),
                     &(lpHierDrawStruct->Opened[Count+1]),
                     sizeof(DWORD)*(lpHierDrawStruct->NumOpened-Count));
            }
            lpHierDrawStruct->Opened =
                  (DWORD_PTR *)_frealloc(lpHierDrawStruct->Opened,
                     sizeof(DWORD_PTR)*lpHierDrawStruct->NumOpened);
        }
     }
   }
} // HierDraw_CloseItem


VOID HierDraw_ShowKids(LPHEIRDRAWSTRUCT lpHierDrawStruct,
                       HWND hwndList, WORD wCurrentSelection, WORD wKids) {
   WORD wBottomIndex;
   WORD wTopIndex;
   WORD wNewTopIndex;
   WORD wExpandInView;
   RECT rc;

   wTopIndex = (WORD)SendMessage(hwndList, LB_GETTOPINDEX, 0, 0L);
   GetClientRect(hwndList, &rc);
   wBottomIndex = (WORD)(wTopIndex + (rc.bottom+1) / lpHierDrawStruct->nLineHeight);

   wExpandInView = (wBottomIndex - wCurrentSelection);

   if (wKids >= wExpandInView) {
        wNewTopIndex = min(wCurrentSelection, wTopIndex + wKids - wExpandInView + 1);
        SendMessage(hwndList, LB_SETTOPINDEX, (WORD)wNewTopIndex, 0L);
   }

} // HierDraw_ShowKids
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\hierdraw.h ===
#define XBMPOFFSET  2


typedef struct _HierDrawStruct {
    HDC       hdcMem;
    HBITMAP   hbmIcons;
    HBITMAP   hbmMem;
    int       nBitmapHeight;
    int       nBitmapWidth;
    int       nTextHeight;
    int       nLineHeight;
    BOOL      bLines;
    int       NumOpened;
    DWORD_PTR *Opened;

} HEIRDRAWSTRUCT;

typedef HEIRDRAWSTRUCT FAR *  LPHEIRDRAWSTRUCT ;


//
// Interface functions
//
VOID HierDraw_DrawTerm(LPHEIRDRAWSTRUCT lpHierDrawStruct);

VOID HierDraw_DrawSetTextHeight (HWND hwnd, HFONT hFont, LPHEIRDRAWSTRUCT lpHierDrawStruct );

BOOL HierDraw_DrawInit(HINSTANCE hInstance,
                       int  nBitmap,
                       int  nRows,
                       int  nColumns,
                       BOOL bLines,
                       LPHEIRDRAWSTRUCT lpHierDrawStruct,
                       BOOL bInit);


VOID HierDraw_OnDrawItem(HWND  hwnd,
                         const DRAWITEMSTRUCT FAR* lpDrawItem,
                         int   nLevel,
                         DWORD dwConnectLevel,
                         TCHAR  *szText,
                         int   nRow,
                         int   nColumn,
                         LPHEIRDRAWSTRUCT lpHierDrawStruct);


VOID HierDraw_OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT FAR* lpMeasureItem,
                            LPHEIRDRAWSTRUCT lpHierDrawStruct);

BOOL HierDraw_IsOpened(LPHEIRDRAWSTRUCT lpHierDrawStruct, DWORD_PTR dwData);

VOID HierDraw_OpenItem(LPHEIRDRAWSTRUCT lpHierDrawStruct, DWORD_PTR dwData);

VOID HierDraw_CloseItem(LPHEIRDRAWSTRUCT lpHierDrawStruct, DWORD_PTR dwData);

VOID HierDraw_DrawCloseAll(LPHEIRDRAWSTRUCT lpHierDrawStruct );

VOID HierDraw_ShowKids(LPHEIRDRAWSTRUCT lpHierDrawStruct,
                       HWND hwndList, WORD wCurrentSelection, WORD wKids);

//
// Support functions
//
static VOID  near FastRect(HDC hDC, int x, int y, int cx, int cy);
static DWORD near RGB2BGR(DWORD rgb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\loghours.c ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    loghours.c

Abstract:

    Private routines to support rotation of logon hours between local time
    and GMT time.

Author:

    Cliff Van Dyke (cliffv) 16-Mar-93

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>

#include <limits.h>
#include <math.h>

#include <lmcons.h>
#include <lmaccess.h>
#include <loghours.h>



BOOLEAN
NetpRotateLogonHoursPhase1(
    IN BOOL  ConvertToGmt,
    OUT PULONG RotateCount
    )

/*++

Routine Description:

    Determine the amount to rotate the logon hours by to convert to/from GMT

Arguments:

    ConvertToGmt -
        True to convert the logon hours from local time to GMT relative
        False to convert the logon hours from GMT relative to local time

    RotateCount - Returns the number of bits to shift by.

Return Value:

    TRUE if the RotateCount could be computed
    FALSE if a RotateCount could not be computed

--*/
{
    RTL_TIME_ZONE_INFORMATION tzi;
    LONG BiasInHours;
    NTSTATUS Status;

    //
    // Get the timezone data from the registry
    //

    Status = RtlQueryTimeZoneInformation( &tzi );
    if ( !NT_SUCCESS(Status) ) {
        return FALSE;
    }

    //
    // Compute the amount to rotate the logon hours by
    //
    // Round the bias in minutes to the closest bias in hours.
    // Take into consideration that Bias can be negative.
    // Do this by forcing the Bias to be positive, rounding,
    // then adjusting it back negative again.
    //

    ASSERT( tzi.Bias > -(24*60) );
    BiasInHours = ((tzi.Bias + (24*60) + 30)/60) - 24;

    if ( !ConvertToGmt ) {
        BiasInHours = - BiasInHours;
    }

    *RotateCount = BiasInHours;
    return TRUE;

}


BOOLEAN
NetpRotateLogonHoursPhase2(
    IN PBYTE LogonHours,
    IN DWORD UnitsPerWeek,
    IN LONG  RotateCount
    )

/*++

Routine Description:

    Rotate the LogonHours bit mask by the required amount.


Arguments:

    LogonHours - Pointer to LogonHour bit mask

    UnitsPerWeek - Number of bits in the bit mask. Must be UNITS_PER_WEEK (168).

    RotateCount - Number of bits to rotate by.  Must be between 31 and -31.
        Negative means to rotate left.
        Positive means to rotate right.

Return Value:

    TRUE if the rotation succeeded.
    FALSE if a parameter was out of range

--*/
{
    //
    // Useful constants
    //

#define DWORDS_PER_WEEK ((UNITS_PER_WEEK+31)/32)
#define BYTES_PER_WEEK  (UNITS_PER_WEEK/8)

    DWORD AlignedLogonHours[DWORDS_PER_WEEK+1];
    LONG i;

    BOOLEAN RotateLeft;

    //
    // Ensure there are 8 bits per byte,
    //  32 bits per DWORD and
    //  units per week is even number of bytes.
    //

    ASSERT( CHAR_BIT == 8 );
    ASSERT( sizeof(DWORD) * CHAR_BIT == 32 );
    ASSERT( UNITS_PER_WEEK/8*8 == UNITS_PER_WEEK );


    //
    // Validate the input parameters
    //

    if ( UnitsPerWeek != UNITS_PER_WEEK ) {
        ASSERT( UnitsPerWeek == UNITS_PER_WEEK );
        return FALSE;
    }

    if ( RotateCount == 0 ) {
        return TRUE;
    }

    RotateLeft = (RotateCount < 0);
    RotateCount = labs( RotateCount );
    if ( RotateCount > 31 ) {
        ASSERT ( RotateCount <= 31 );
        return FALSE;
    }


    //
    // Do the left rotate.
    //

    if (RotateLeft) {


        //
        // Copy the logon hours to a DWORD aligned buffer.
        //
        //  Duplicate the first dword at the end of the buffer to make
        //  the rotation code trivial.
        //

        RtlCopyMemory(AlignedLogonHours, LogonHours, BYTES_PER_WEEK );

        RtlCopyMemory( ((PBYTE)AlignedLogonHours)+BYTES_PER_WEEK,
                        LogonHours,
                        sizeof(DWORD) );

        //
        // Actually rotate the data.
        //

        for ( i=0; i < DWORDS_PER_WEEK; i++ ) {
            AlignedLogonHours[i] =
                (AlignedLogonHours[i] >> RotateCount) |
                (AlignedLogonHours[i+1] << (32-RotateCount));
        }

        //
        // Copy the logon hours back to the input buffer.
        //

        RtlCopyMemory( LogonHours, AlignedLogonHours, BYTES_PER_WEEK );


    //
    // Do the right rotate.
    //

    } else {


        //
        // Copy the logon hours to a DWORD aligned buffer.
        //
        // Duplicate the last DWORD at the front of the buffer to make
        //  the rotation code trivial.
        //

        RtlCopyMemory( &AlignedLogonHours[1], LogonHours, BYTES_PER_WEEK );
        RtlCopyMemory( AlignedLogonHours,
                       &LogonHours[BYTES_PER_WEEK-4],
                        sizeof(DWORD));

        //
        // Actually rotate the data.
        //

        for ( i=DWORDS_PER_WEEK-1; i>=0; i-- ) {
            AlignedLogonHours[i+1] =
                (AlignedLogonHours[i+1] << RotateCount) |
                (AlignedLogonHours[i] >> (32-RotateCount));
        }

        //
        // Copy the logon hours back to the input buffer.
        //

        RtlCopyMemory( LogonHours, &AlignedLogonHours[1], BYTES_PER_WEEK );

    }

    //
    // Done
    //

    return TRUE;

}



BOOLEAN
NetpRotateLogonHours(
    IN PBYTE LogonHours,
    IN DWORD UnitsPerWeek,
    IN BOOL  ConvertToGmt
    )

/*++

Routine Description:

    Rotate the LogonHours bit mask to/from GMT relative time.


Arguments:

    LogonHours - Pointer to LogonHour bit mask

    UnitsPerWeek - Number of bits in the bit mask. Must be UNITS_PER_WEEK (168).

    ConvertToGmt -
        True to convert the logon hours from local time to GMT relative
        False to convert the logon hours from GMT relative to local time

Return Value:

    TRUE if the rotation succeeded.
    FALSE if a parameter was out of range

--*/
{
    ULONG RotateCount;

    //
    // Break the functionality into two phases so that if the caller is doing
    //  this multiple time, he just calls Phase 1 once and Phase 2 multiple
    //  times.
    //

    if ( !NetpRotateLogonHoursPhase1( ConvertToGmt, &RotateCount ) ) {
        return FALSE;
    }

    return NetpRotateLogonHoursPhase2( LogonHours, UnitsPerWeek, RotateCount );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\hierfile.h ===
#define XBMPOFFSET  2


typedef struct _HierFileStruct {
    HDC       hdcMem1;
    HDC       hdcMem2;
    HBITMAP   hbmIcons1;
    HBITMAP   hbmMem1;
    int       nBitmapHeight1;
    int       nBitmapWidth1;
    HBITMAP   hbmIcons2;
    HBITMAP   hbmMem2;
    int       nBitmapHeight2;
    int       nBitmapWidth2;
    int       nTextHeight;
    int       nLineHeight;
    BOOL      bLines;
    int       NumOpened;
    DWORD_PTR *Opened;

} HEIRDRAWSTRUCT;

typedef HEIRDRAWSTRUCT FAR *  LPHEIRDRAWSTRUCT ;


//
// Interface functions
//
VOID HierFile_DrawTerm(LPHEIRDRAWSTRUCT lpHierFileStruct);

VOID HierFile_DrawSetTextHeight (HWND hwnd, HFONT hFont, LPHEIRDRAWSTRUCT lpHierFileStruct );

BOOL HierFile_DrawInit(HINSTANCE hInstance,
                       int  nBitmap1,
                       int  nBitmap2,
                       int  nRows,
                       int  nColumns,
                       BOOL bLines,
                       LPHEIRDRAWSTRUCT lpHierFileStruct,
                       BOOL bInit);


VOID HierFile_OnDrawItem(HWND  hwnd,
                         const DRAWITEMSTRUCT FAR* lpDrawItem,
                         int   nLevel,
                         DWORD dwConnectLevel,
                         TCHAR  *szText,
                         int   nRow,
                         int   nColumn,
                         int   nColumn2,
                         LPHEIRDRAWSTRUCT lpHierFileStruct);


VOID HierFile_OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT FAR* lpMeasureItem,
                            LPHEIRDRAWSTRUCT lpHierFileStruct);

BOOL HierFile_IsOpened(LPHEIRDRAWSTRUCT lpHierFileStruct, DWORD_PTR dwData);

VOID HierFile_OpenItem(LPHEIRDRAWSTRUCT lpHierFileStruct, DWORD_PTR dwData);

VOID HierFile_CloseItem(LPHEIRDRAWSTRUCT lpHierFileStruct, DWORD_PTR dwData);

VOID HierFile_DrawCloseAll(LPHEIRDRAWSTRUCT lpHierFileStruct );

VOID HierFile_ShowKids(LPHEIRDRAWSTRUCT lpHierFileStruct,
                       HWND hwndList, WORD wCurrentSelection, WORD wKids);

BOOL HierFile_InCheck(int nLevel, int xPos, LPHEIRDRAWSTRUCT lpHierFileStruct);

//
// Support functions
//
static VOID  near FastRect(HDC hDC, int x, int y, int cx, int cy);
static DWORD near RGB2BGR(DWORD rgb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\hierfile.c ===
#include <windows.h>
#include <windowsx.h>
#include <malloc.h>
#include <string.h>

#include "debug.h"
#include "HierFile.h"


VOID HierFile_DrawTerm(LPHEIRDRAWSTRUCT lpHierFileStruct) {
   if (lpHierFileStruct->hbmIcons1) {
       if (lpHierFileStruct->hbmMem1)
           SelectObject(lpHierFileStruct->hdcMem1, lpHierFileStruct->hbmMem1);
       lpHierFileStruct->hbmMem1 = NULL;
       DeleteObject(lpHierFileStruct->hbmIcons1);
       lpHierFileStruct->hbmIcons1 = NULL;
   }

   if ( lpHierFileStruct->hdcMem1 ) {
      DeleteDC(lpHierFileStruct->hdcMem1);
      lpHierFileStruct->hdcMem1 = NULL;
   }

   if (lpHierFileStruct->hbmIcons2) {
       if (lpHierFileStruct->hbmMem2)
           SelectObject(lpHierFileStruct->hdcMem2, lpHierFileStruct->hbmMem2);
       lpHierFileStruct->hbmMem2 = NULL;
       DeleteObject(lpHierFileStruct->hbmIcons2);
       lpHierFileStruct->hbmIcons2 = NULL;
   }

   if ( lpHierFileStruct->hdcMem2 ) {
      DeleteDC(lpHierFileStruct->hdcMem2);
      lpHierFileStruct->hdcMem2 = NULL;
   }

} // HierFile_DrawTerm

VOID HierFile_DrawCloseAll(LPHEIRDRAWSTRUCT lpHierFileStruct ) {
   lpHierFileStruct->NumOpened= 0;
   if ( lpHierFileStruct->Opened ) {
      _ffree(lpHierFileStruct->Opened);
   }
   lpHierFileStruct->Opened = NULL;
} // HierFile_DrawCloseAll

VOID HierFile_OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT FAR* lpMeasureItem,
                            LPHEIRDRAWSTRUCT lpHierFileStruct) {
   lpMeasureItem->itemHeight = max(lpHierFileStruct->nBitmapHeight1,
                                   lpHierFileStruct->nTextHeight);
} // HierFile_OnMeasureItem

VOID HierFile_DrawSetTextHeight (HWND hwndList, HFONT hFont, LPHEIRDRAWSTRUCT lpHierFileStruct ) {
   TEXTMETRIC      TextMetrics;
   HANDLE          hOldFont=NULL;
   HDC             hdc;

   //
   // This sure looks like a lot of work to find the character height
   //
   hdc = GetDC(hwndList);

   hOldFont = SelectObject(hdc, hFont);
   GetTextMetrics(hdc, &TextMetrics);
   SelectObject(hdc, hOldFont);
   ReleaseDC(hwndList, hdc);

   lpHierFileStruct->nTextHeight = TextMetrics.tmHeight;

   lpHierFileStruct->nLineHeight =
         max(lpHierFileStruct->nBitmapHeight1, lpHierFileStruct->nTextHeight);

   if ( hwndList != NULL )
       SendMessage(hwndList, LB_SETITEMHEIGHT, 0,
                   MAKELPARAM(lpHierFileStruct->nLineHeight, 0));
} // HierFile_DrawSetTextHeight

static DWORD near RGB2BGR(DWORD rgb) {
    return RGB(GetBValue(rgb),GetGValue(rgb),GetRValue(rgb));
} // RGB2BGR



/*
 *  Creates the objects used while drawing the tree.  This may be called
 *  repeatedly in the event of a WM_SYSCOLORCHANGED message.
 */

BOOL HierFile_DrawInit(HINSTANCE hInstance,
                       int  nBitmap1,
                       int  nBitmap2,
                       int  nRows,
                       int  nColumns,
                       BOOL bLines,
                       LPHEIRDRAWSTRUCT lpHierFileStruct,
                       BOOL bInit) {
    HANDLE hRes;
    HANDLE hResMem;
    LPBITMAPINFOHEADER lpbiReadOnly;
    LPBITMAPINFOHEADER lpbiReadWrite;
    DWORD FAR * lpColorTable;
    LPSTR lpBits;
    int biSize;
    int bc;
    HDC hDC;


    if ( bInit ) {
       lpHierFileStruct->NumOpened = 0;
       lpHierFileStruct->Opened = NULL;
       lpHierFileStruct->bLines = bLines;
    }

    // If the Memory DC is not created yet do that first.
    if (!lpHierFileStruct->hdcMem1) {

        // get a screen DC
        hDC = GetDC(NULL);

        // Create a memory DC compatible with the screen
        lpHierFileStruct->hdcMem1 = CreateCompatibleDC(hDC);

        // Release the Screen DC
        ReleaseDC(NULL, hDC);

        if (!lpHierFileStruct->hdcMem1)
            return FALSE;

        lpHierFileStruct->hbmMem1 = NULL;
    }

    // If the Memory DC is not created yet do that first.
    if (!lpHierFileStruct->hdcMem2) {

        // get a screen DC
        hDC = GetDC(NULL);

        // Create a memory DC compatible with the screen
        lpHierFileStruct->hdcMem2 = CreateCompatibleDC(hDC);

        // Release the Screen DC
        ReleaseDC(NULL, hDC);

        if (!lpHierFileStruct->hdcMem2)
            return FALSE;

        lpHierFileStruct->hbmMem2 = NULL;
    }

   /*+----------------------------------------------------------------------------------+
     |                                   For First Bitmap                               |
     +----------------------------------------------------------------------------------+*/

    // (Re)Load the Bitmap ( original from disk )

    // Use the FindResource,LoadResource,LockResource since it makes it easy to get the
    // pointer to the BITMAPINFOHEADER we need.
    hRes = FindResource(hInstance, MAKEINTRESOURCE(nBitmap1), RT_BITMAP);
    if (!hRes)
        return FALSE;

    hResMem = LoadResource(hInstance, hRes);
    if (!hResMem)
        return FALSE;

    // Now figure out the bitmaps background color.
    // This code assumes the lower left corner is a
    // bit in the background color.
    lpbiReadOnly = (LPBITMAPINFOHEADER)LockResource(hResMem);
    if (!lpbiReadOnly)
        return FALSE;

    // Determine size of bitmap information header plus color table entries
    biSize = lpbiReadOnly->biSize + ((1 << (lpbiReadOnly->biBitCount)) * sizeof(RGBQUAD));

    // Allocate copy of the bitmap information to munge on
    lpbiReadWrite = (LPBITMAPINFOHEADER)GlobalAlloc(GPTR, biSize);
    if (!lpbiReadWrite)
        return FALSE;

    memcpy(lpbiReadWrite, lpbiReadOnly, biSize);

    // Color table immediately follows bitmap information header
    lpColorTable = (DWORD FAR *)((LPBYTE)lpbiReadWrite + lpbiReadWrite->biSize);

    // No need to munge bits so use original
    lpBits = (LPBYTE)lpbiReadOnly + biSize;

    bc = (lpBits[0] & 0xF0) >> 4;   // ASSUMES LOWER LEFT CORNER IS BG!!

    lpColorTable[bc] = RGB2BGR(GetSysColor(COLOR_WINDOW));

    hDC = GetDC(NULL);
    lpHierFileStruct->hbmIcons1 = CreateDIBitmap(
                                    hDC,
                                    lpbiReadWrite,
                                    CBM_INIT,
                                    lpBits,
                                    (LPBITMAPINFO)lpbiReadWrite,
                                    DIB_RGB_COLORS
                                    );
    ReleaseDC(NULL, hDC);

    lpHierFileStruct->nBitmapHeight1 = (WORD)lpbiReadWrite->biHeight / nRows;
    lpHierFileStruct->nBitmapWidth1 = (WORD)lpbiReadWrite->biWidth / nColumns;

    lpHierFileStruct->nLineHeight =
         max(lpHierFileStruct->nBitmapHeight1, lpHierFileStruct->nTextHeight);

    GlobalFree(lpbiReadWrite);
    UnlockResource(hResMem);
    FreeResource(hResMem);

    if (!lpHierFileStruct->hbmIcons1)
        return FALSE;

    lpHierFileStruct->hbmMem1 = SelectObject(lpHierFileStruct->hdcMem1, lpHierFileStruct->hbmIcons1);
    if (!lpHierFileStruct->hbmMem1)
        return FALSE;

   /*+----------------------------------------------------------------------+
     |                           For Second Bitmap                          |
     +----------------------------------------------------------------------+*/

    // (Re)Load the Bitmap ( original from disk )
    hRes = FindResource(hInstance, MAKEINTRESOURCE(nBitmap2), RT_BITMAP);
    if (!hRes)
        return FALSE;

    hResMem = LoadResource(hInstance, hRes);
    if (!hResMem)
        return FALSE;

    // Now figure out the bitmaps background color.
    // This code assumes the lower left corner is a
    // bit in the background color.
    lpbiReadOnly = (LPBITMAPINFOHEADER) LockResource(hResMem);
    if (!lpbiReadOnly)
        return FALSE;

    // Determine size of bitmap information header plus color table entries
    biSize = lpbiReadOnly->biSize + ((1 << (lpbiReadOnly->biBitCount)) * sizeof(RGBQUAD));

    // Allocate copy of the bitmap information to munge on
    lpbiReadWrite = (LPBITMAPINFOHEADER)GlobalAlloc(GPTR, biSize);
    if (!lpbiReadWrite)
        return FALSE;

    memcpy(lpbiReadWrite, lpbiReadOnly, biSize);

    // Color table immediately follows bitmap information header
    lpColorTable = (DWORD FAR *)((LPBYTE)lpbiReadWrite + lpbiReadWrite->biSize);

    // No need to munge bits so use original
    lpBits = (LPBYTE)lpbiReadOnly + biSize;

    bc = (lpBits[0] & 0xF0) >> 4;   // ASSUMES LOWER LEFT CORNER IS BG!!

    lpColorTable[bc] = RGB2BGR(GetSysColor(COLOR_WINDOW));

    hDC = GetDC(NULL);
    lpHierFileStruct->hbmIcons2 = CreateDIBitmap(
                                    hDC,
                                    lpbiReadWrite,
                                    CBM_INIT,
                                    lpBits,
                                    (LPBITMAPINFO)lpbiReadWrite,
                                    DIB_RGB_COLORS
                                    );
    ReleaseDC(NULL, hDC);

    // These are hard-coded as 1 row and 3 columns for the checkbox bitmap
    lpHierFileStruct->nBitmapHeight2 = (WORD)lpbiReadWrite->biHeight / 1;
    lpHierFileStruct->nBitmapWidth2 = (WORD)lpbiReadWrite->biWidth / 3;

    GlobalFree(lpbiReadWrite);
    UnlockResource(hResMem);
    FreeResource(hResMem);

    if (!lpHierFileStruct->hbmIcons2)
        return FALSE;

    lpHierFileStruct->hbmMem2 = SelectObject(lpHierFileStruct->hdcMem2, lpHierFileStruct->hbmIcons2);
    if (!lpHierFileStruct->hbmMem2)
        return FALSE;

    return TRUE;
} // HierFile_DrawInit


BOOL HierFile_InCheck(int nLevel, int xPos, LPHEIRDRAWSTRUCT lpHierFileStruct) {
   WORD       wIndent;

   wIndent = ((int)(nLevel) * lpHierFileStruct->nBitmapWidth1) + XBMPOFFSET;

   if ((xPos > wIndent) && (xPos < wIndent + lpHierFileStruct->nBitmapWidth2))
      return TRUE;

   return FALSE;

} // HierFile_InCheck


VOID HierFile_OnDrawItem(HWND hwnd,
                         const DRAWITEMSTRUCT FAR* lpDrawItem,
                         int nLevel,
                         DWORD dwConnectLevel,
                         TCHAR *szText,
                         int nRow,
                         int nColumn,
                         int nColumn2,
                         LPHEIRDRAWSTRUCT lpHierFileStruct) {
    HDC        hDC;
    WORD       wIndent, wTopBitmap, wTopText;
    RECT       rcTemp;


    if ( lpDrawItem->itemID == (UINT)-1 )
       return ;

    hDC = lpDrawItem->hDC;
    CopyRect(&rcTemp, &lpDrawItem->rcItem);

    wIndent = (WORD)(rcTemp.left + ((int)(nLevel) * lpHierFileStruct->nBitmapWidth1) + XBMPOFFSET);
    rcTemp.left = wIndent + lpHierFileStruct->nBitmapWidth1 + lpHierFileStruct->nBitmapWidth2;
    wTopText = (WORD)(rcTemp.top + ((rcTemp.bottom - rcTemp.top) / 2) - (lpHierFileStruct->nTextHeight / 2));
    wTopBitmap = (WORD)(rcTemp.top + ((rcTemp.bottom - rcTemp.top) / 2) - (lpHierFileStruct->nBitmapHeight1 / 2));

    if (lpDrawItem->itemAction == ODA_FOCUS)
        goto DealWithFocus;
    else if (lpDrawItem->itemAction == ODA_SELECT)
        goto DealWithSelection;

   /*+-----------------------------------------------------------------------+
     |                         Connecting Line code                          |
     +-----------------------------------------------------------------------+*/
    if (lpHierFileStruct->bLines && nLevel) {
        DWORD    dwMask = 1;
        int      nTempLevel;
        int      x,y;

        // draw lines in text color
        SetBkColor(hDC, GetSysColor(COLOR_WINDOWTEXT));

        // Draw a series of | lines for outer levels
        x = lpHierFileStruct->nBitmapWidth1 / 2 + XBMPOFFSET;

        for ( nTempLevel = 0; nTempLevel < nLevel ; nTempLevel++)
          {
            if ( dwConnectLevel & dwMask )
                FastRect(hDC, x, rcTemp.top, 1, rcTemp.bottom - rcTemp.top);

            x += lpHierFileStruct->nBitmapWidth2;
            dwMask *= 2;
          }


        // Draw the short vert line up towards the parent
        nTempLevel = nLevel-1;
        dwMask *= 2;

        x = nTempLevel * lpHierFileStruct->nBitmapWidth1 + lpHierFileStruct->nBitmapWidth1 / 2 + XBMPOFFSET;

        if ( dwConnectLevel & dwMask )
            y = rcTemp.bottom;
        else
            y = rcTemp.bottom - lpHierFileStruct->nLineHeight / 2;

        FastRect(hDC, x, rcTemp.top, 1, y - rcTemp.top);

        // Draw short horiz bar to right
        FastRect(hDC, x, rcTemp.bottom-lpHierFileStruct->nLineHeight / 2, lpHierFileStruct->nBitmapWidth1 / 2, 1);
      }

   /*+-----------------------------------------------------------------------+
     |                                  Bitmaps                              |
     +-----------------------------------------------------------------------+*/
    // Draw the checkbox bitmap
    BitBlt(hDC,
           wIndent, wTopBitmap,
           lpHierFileStruct->nBitmapWidth2, lpHierFileStruct->nBitmapHeight2,
           lpHierFileStruct->hdcMem2,
           nColumn2 * lpHierFileStruct->nBitmapWidth2,
           0 * lpHierFileStruct->nBitmapHeight2,
           SRCCOPY);

    // Now the other app specific bitmap adjusted over for the checkbox bitmap
    BitBlt(hDC,
           wIndent + lpHierFileStruct->nBitmapWidth2, wTopBitmap,
           lpHierFileStruct->nBitmapWidth1, lpHierFileStruct->nBitmapHeight1,
           lpHierFileStruct->hdcMem1,
           nColumn * lpHierFileStruct->nBitmapWidth1,
           nRow * lpHierFileStruct->nBitmapHeight1,
           SRCCOPY);

DealWithSelection:

    if (lpDrawItem->itemState & ODS_SELECTED) {
        SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
        SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    } else {
        SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    }


    ExtTextOut(hDC, rcTemp.left + 1, wTopText, ETO_CLIPPED | ETO_OPAQUE,
               &rcTemp, szText, lstrlen(szText), NULL);

    if (lpDrawItem->itemState & ODS_FOCUS && lpDrawItem->itemAction != ODA_SELECT) {
DealWithFocus:
        DrawFocusRect(hDC, &rcTemp);
    }


} // HierFile_OnDrawItem


// draw a solid color rectangle quickly
static VOID near FastRect(HDC hDC, int x, int y, int cx, int cy) {
    RECT rc;

    rc.left = x;
    rc.right = x+cx;
    rc.top = y;
    rc.bottom = y+cy;
    ExtTextOut(hDC,x,y,ETO_OPAQUE,&rc,NULL,0,NULL);
} // FastRect


BOOL HierFile_IsOpened(LPHEIRDRAWSTRUCT lpHierFileStruct, DWORD_PTR dwData) {
   // For Now just a dumb  search
   //
   int Count;

   for ( Count = 0; Count < lpHierFileStruct->NumOpened; Count++ ) {
     if ( lpHierFileStruct->Opened[Count] == dwData ) {
        return TRUE;
     }
   }

   return FALSE;

} // HierFile_IsOpened


VOID HierFile_OpenItem(LPHEIRDRAWSTRUCT lpHierFileStruct, DWORD_PTR dwData) {
    lpHierFileStruct->NumOpened++;

    if (lpHierFileStruct->Opened == NULL )
       lpHierFileStruct->Opened =
        (DWORD_PTR *)_fmalloc(sizeof(DWORD_PTR)*lpHierFileStruct->NumOpened);
    else
       lpHierFileStruct->Opened =
        (DWORD_PTR *)_frealloc(lpHierFileStruct->Opened,
               sizeof(DWORD_PTR)*lpHierFileStruct->NumOpened);

    lpHierFileStruct->Opened[lpHierFileStruct->NumOpened-1] = dwData;
} // HierFile_OpenItem

VOID HierFile_CloseItem(LPHEIRDRAWSTRUCT lpHierFileStruct, DWORD_PTR dwData) {
   // For Now just a dumb  search
   //
   int Count;

   for ( Count = 0; Count < lpHierFileStruct->NumOpened; Count++ ) {
     if ( lpHierFileStruct->Opened[Count] == dwData ) {
        if (--lpHierFileStruct->NumOpened == 0 ) {
            _ffree(lpHierFileStruct->Opened);
            lpHierFileStruct->Opened = NULL;
        }
        else {
            if ( Count < lpHierFileStruct->NumOpened ) {
               _fmemmove(&(lpHierFileStruct->Opened[Count]),
                     &(lpHierFileStruct->Opened[Count+1]),
                     sizeof(DWORD_PTR)*(lpHierFileStruct->NumOpened-Count));
            }
            lpHierFileStruct->Opened =
                  (DWORD_PTR *)_frealloc(lpHierFileStruct->Opened,
                     sizeof(DWORD_PTR)*lpHierFileStruct->NumOpened);
        }
     }
   }
} // HierFile_CloseItem


VOID HierFile_ShowKids(LPHEIRDRAWSTRUCT lpHierFileStruct,
                       HWND hwndList, WORD wCurrentSelection, WORD wKids) {
   WORD wBottomIndex;
   WORD wTopIndex;
   WORD wNewTopIndex;
   WORD wExpandInView;
   RECT rc;

   wTopIndex = (WORD)SendMessage(hwndList, LB_GETTOPINDEX, 0, 0L);
   GetClientRect(hwndList, &rc);
   wBottomIndex = (WORD)(wTopIndex + (rc.bottom+1) / lpHierFileStruct->nLineHeight);

   wExpandInView = (wBottomIndex - wCurrentSelection);

   if (wKids >= wExpandInView) {
        wNewTopIndex = min(wCurrentSelection, wTopIndex + wKids - wExpandInView + 1);
        SendMessage(hwndList, LB_SETTOPINDEX, (WORD)wNewTopIndex, 0L);
   }

} // HierFile_ShowKids
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\map.c ===
/*
  +-------------------------------------------------------------------------+
  |                        User Options Dialog                              |
  +-------------------------------------------------------------------------+
  |                     (c) Copyright 1993-1994                             |
  |                          Microsoft Corp.                                |
  |                        All rights reserved                              |
  |                                                                         |
  | Program               : [MAP.c]                                         |
  | Programmer            : Arthur Hanson                                   |
  | Original Program Date : [Sep 28, 1994]                                  |
  | Last Update           : [Sep 28, 1994]                                  |
  |                                                                         |
  | Version:  1.00                                                          |
  |                                                                         |
  | Description:                                                            |
  |                                                                         |
  | History:                                                                |
  |   arth  Sep 28, 1994    1.00    Original Version.                       |
  |                                                                         |
  +-------------------------------------------------------------------------+
*/


#include "globals.h"
#include "convapi.h"
#include "ntnetapi.h"
#include "nwnetapi.h"
#include "map.h"
#include "nwlog.h"
#include "nwconv.h"

// from userdlg.c
DWORD UserFileGet(HWND hwnd, LPTSTR FilePath);

// The map file is kept as a doubly-linked list of sections, each of which has
// a doubly-linked list of lines in that section.  A header is used to point to
// the first section, and also contains a pointer to any lines that appear
// before the first section (usually only comment lines) - it also keeps the
// current line and section pointer.
//
// All the linked lists have a dummy header and tail, with the tail pointing
// back on itself (this simplifies the logic for list manipulation)...
//
//  +-------------+                    +----------------+
//  |     Dummy   |                    |  Dummy         |
//  |   head node v                    v tail node      |
//  |  +-----------+   +-----------+   +-----------+    |
//  |  |  Node 1   |-->|  Node 2   |-->|  Node 3   |----+
//  +--| (not used)|<--|  (data)   |<--| (not used)|
//     +-----------+   +-----------+   +-----------+
//
// The dummy head/tail nodes make it easy to keep track of the start and
// end of the list (we never have to worry about updating the head and tail
// pointers in the owning data structures, since they never change).  It does,
// however, make for some obtuse cases in the add/delete node code.

typedef struct _LINKED_LIST {
   struct _LINKED_LIST *prev;
   struct _LINKED_LIST *next;

} LINKED_LIST;

typedef struct _LINK_HEAD {
   LINKED_LIST *Head;
   LINKED_LIST *Tail;

   LINKED_LIST *Current;
   ULONG Count;

   TCHAR Name[];
} LINK_HEAD;


static TCHAR MappingFile[MAX_PATH + 1];
static TCHAR PasswordConstant[MAX_PW_LEN + 1];
static BOOL DoUsers = TRUE;
static BOOL DoGroups = TRUE;
static UINT PasswordOption = 0;
static LPTSTR SourceServ;

/*+-------------------------------------------------------------------------+
  |                       Common Linked List Routines
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | ll_Init()
  |
  +-------------------------------------------------------------------------+*/
LINKED_LIST *ll_Init(ULONG Size) {
   LINKED_LIST *llHead;
   LINKED_LIST *llTail;

   llHead = (LINKED_LIST *) AllocMemory(Size);
   if (llHead == NULL)
      return NULL;

   llTail = (LINKED_LIST *) AllocMemory(Size);
   if (llTail == NULL) {
      FreeMemory(llHead);
      return NULL;
   }

   llHead->prev = llHead;
   llHead->next = llTail;

   llTail->next = llTail;
   llTail->prev = llHead;

   return llHead;

} // ll_Init


/*+-------------------------------------------------------------------------+
  | ll_Next()
  |
  +-------------------------------------------------------------------------+*/
LINKED_LIST *ll_Next(void *vllCurrent) {
   LINKED_LIST *llCurrent;

   llCurrent = (LINKED_LIST *) vllCurrent;

   if ((llCurrent == NULL) || (llCurrent->next == NULL) || (llCurrent->prev == NULL))
      return NULL;

   llCurrent = llCurrent->next;

   if (llCurrent->next == llCurrent)
      return NULL;
   else
      return llCurrent;

} // ll_Next


/*+-------------------------------------------------------------------------+
  | ll_Prev()
  |
  +-------------------------------------------------------------------------+*/
LINKED_LIST *ll_Prev(void *vllCurrent) {
   LINKED_LIST *llCurrent;

   llCurrent = (LINKED_LIST *) vllCurrent;

   if ((llCurrent == NULL) || (llCurrent->next == NULL) || (llCurrent->prev == NULL))
      return NULL;

   llCurrent = llCurrent->prev;

   if (llCurrent->prev == llCurrent)
      return NULL;
   else
      return llCurrent;

} // ll_Prev


/*+-------------------------------------------------------------------------+
  | ll_InsertAfter()
  |
  +-------------------------------------------------------------------------+*/
LINKED_LIST *ll_InsertAfter(void *vllCurrent, void *vllNew) {
   LINKED_LIST *llCurrent;
   LINKED_LIST *llNew;

   llCurrent = (LINKED_LIST *) vllCurrent;
   llNew = (LINKED_LIST *) vllNew;

   if ((vllCurrent == NULL) || (llNew == NULL))
      return NULL;

   // change pointers to insert it into the list
   llNew->next = llCurrent->next;

   // check if at end of list
   if (llCurrent->next == llCurrent)
      llNew->prev = llCurrent->prev;
   else
      llNew->prev = llCurrent;

   llNew->prev->next = llNew;
   llNew->next->prev = llNew;
   return llNew;
} // ll_InsertAfter


/*+-------------------------------------------------------------------------+
  | ll_InsertBefore()
  |
  +-------------------------------------------------------------------------+*/
LINKED_LIST *ll_InsertBefore(void *vllCurrent, void *vllNew) {
   LINKED_LIST *llCurrent;
   LINKED_LIST *llNew;

   llCurrent = (LINKED_LIST *) vllCurrent;
   llNew = (LINKED_LIST *) vllNew;

   if ((vllCurrent == NULL) || (llNew == NULL))
      return NULL;

   // change pointers to insert it into the list
   llNew->prev = llCurrent->prev;

   // check if at start of list
   if (llCurrent->prev = llCurrent)
      llNew->next = llCurrent->next;
   else
      llNew->next = llCurrent;

   llNew->prev->next = llNew;
   llNew->next->prev = llNew;
   return llNew;
} // ll_InsertBefore


/*+-------------------------------------------------------------------------+
  | ll_Delete()
  |
  +-------------------------------------------------------------------------+*/
LINKED_LIST *ll_Delete(void *vllCurrent) {
   LINKED_LIST *llCurrent;

   llCurrent = (LINKED_LIST *) vllCurrent;

   if ((llCurrent == NULL) || (llCurrent->next == NULL) || (llCurrent->prev == NULL))
      return NULL;

   // make sure not on one of the dummy end headers
   if ((llCurrent->next == llCurrent) || (llCurrent->prev == llCurrent))
      return NULL;

   // changed pointers to remove it from list
   llCurrent->prev->next = llCurrent->next;
   llCurrent->next->prev = llCurrent->prev;

   // Get which one to return as new current record - we generally want to
   // go to the previous record - unless we deleted the first record, in
   // which case get the next record.  If there are no records, then return
   // the list head
   llCurrent = llCurrent->prev;

   // check if at start of list
   if (llCurrent->prev == llCurrent)
      llCurrent = llCurrent->next;

   // make sure not at end of list (may have moved here if empty list) - if
   // so we want to return the starting node
   if (llCurrent->next == llCurrent)
      llCurrent = llCurrent->prev;

   return llCurrent;
} // ll_Delete


/*+-------------------------------------------------------------------------+
  | ll_Home()
  |
  +-------------------------------------------------------------------------+*/
LINKED_LIST *ll_Home(void *vllCurrent) {
   LINKED_LIST *llCurrent;

   llCurrent = (LINKED_LIST *) vllCurrent;
   if (llCurrent == NULL)
      return (LINKED_LIST *) NULL;

   // make sure at start of list
   while (llCurrent->prev != llCurrent)
      llCurrent = llCurrent->prev;

   return llCurrent;

} // ll_Home


/*+-------------------------------------------------------------------------+
  | ll_End()
  |
  +-------------------------------------------------------------------------+*/
LINKED_LIST *ll_End(void *vllCurrent) {
   LINKED_LIST *llCurrent;

   llCurrent = (LINKED_LIST *) vllCurrent;
   if (llCurrent == NULL)
      return (LINKED_LIST *) NULL;

   // make sure at end of list
   while (llCurrent->next != llCurrent)
      llCurrent = llCurrent->next;

   return llCurrent;

} // ll_End


/*+-------------------------------------------------------------------------+
  | ll_ListFree()
  |
  +-------------------------------------------------------------------------+*/
void ll_ListFree(void *vllHead) {
   LINKED_LIST *llCurrent;
   LINKED_LIST *llNext;

   llCurrent = (LINKED_LIST *) vllHead;
   if (llCurrent == NULL)
      return;

   // make sure at start of list
   while (llCurrent->prev != llCurrent)
      llCurrent = llCurrent->prev;

   // walk the chain - freeing it
   while ((llCurrent != NULL) && (llCurrent->next != llCurrent)) {
      llNext = llCurrent->next;
      FreeMemory(llCurrent);
      llCurrent = llNext;
   }

   // at the ending node - kill it as well
   FreeMemory(llCurrent);

} // ll_ListFree




/*+-------------------------------------------------------------------------+
  |                               List Routines
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | map_LineListInit()
  |
  +-------------------------------------------------------------------------+*/
MAP_LINE *map_LineListInit() {
   MAP_LINE *NewHead;
   MAP_LINE *NewTail;

   // Create our linked list
   NewHead = (MAP_LINE *) ll_Init(sizeof(MAP_LINE));
   if (NewHead == NULL)
      return (MAP_LINE *) NULL;

   NewTail = NewHead->next;

   // Now init them as appropriate
   NewHead->Line = NULL;
   NewTail->Line = NULL;

   return NewHead;

} // map_LineListInit


/*+-------------------------------------------------------------------------+
  | map_SectionListInit()
  |
  +-------------------------------------------------------------------------+*/
MAP_SECTION *map_SectionListInit() {
   MAP_SECTION *NewHead;
   MAP_SECTION *NewTail;

   // Create our linked list
   NewHead = (MAP_SECTION *) ll_Init(sizeof(MAP_SECTION));
   if (NewHead == NULL)
      return (MAP_SECTION *) NULL;

   NewTail = NewHead->next;

   // Now init them as appropriate
   NewHead->Name = NULL;
   NewTail->Name = NULL;

   NewHead->FirstLine = NewHead->LastLine = NewTail->FirstLine = NewTail->LastLine = NULL;
   NewHead->LineCount = NewTail->LineCount = 0;

   return NewHead;

} // map_SectionListInit


/*+-------------------------------------------------------------------------+
  | map_LineListFree()
  |
  +-------------------------------------------------------------------------+*/
void map_LineListFree(MAP_LINE *CurrentLine) {
   MAP_LINE *NextLine;

   if (CurrentLine == NULL)
      return;

   // make sure at start of list
   while (CurrentLine->prev != CurrentLine)
      CurrentLine = CurrentLine->prev;

   // walk the chain - freeing it
   while ((CurrentLine != NULL) && (CurrentLine->next != CurrentLine)) {
      NextLine = CurrentLine->next;

      if (CurrentLine->Line != NULL)
         FreeMemory(CurrentLine->Line);

      FreeMemory(CurrentLine);
      CurrentLine = NextLine;
   }

   // at the ending node - kill it as well
   FreeMemory(CurrentLine);

} // map_LineListFree


/*+-------------------------------------------------------------------------+
  | map_SectionListFree()
  |
  +-------------------------------------------------------------------------+*/
void map_SectionListFree(MAP_SECTION *CurrentSection) {
   MAP_SECTION *NextSection;

   if (CurrentSection == NULL)
      return;

   // make sure at start of list
   while (CurrentSection->prev != CurrentSection)
      CurrentSection = CurrentSection->prev;

   // walk the chain - freeing it
   while ((CurrentSection != NULL) && (CurrentSection->next != CurrentSection)) {
      NextSection = CurrentSection->next;

      map_LineListFree(CurrentSection->FirstLine);

      if (CurrentSection->Name != NULL)
         FreeMemory(CurrentSection->Name);

      FreeMemory(CurrentSection);
      CurrentSection = NextSection;
   }

   // at the ending node - kill it as well
   FreeMemory(CurrentSection);

} // map_SectionListFree




/*+-------------------------------------------------------------------------+
  |                             Section Routines
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | map_SectionInit()
  |
  +-------------------------------------------------------------------------+*/
MAP_SECTION *map_SectionInit(LPTSTR Section) {
   MAP_SECTION *NewSection;
   MAP_LINE *FirstLine;

   NewSection = (MAP_SECTION *) AllocMemory(sizeof(MAP_SECTION));
   if (NewSection == NULL)
      return (MAP_SECTION *) NULL;

   // Init the section name
   NewSection->Name = (LPTSTR) AllocMemory((lstrlen(Section) + 1) * sizeof(TCHAR));

   if (NewSection->Name == NULL) {
      FreeMemory(NewSection);
      return (MAP_SECTION *) NULL;
   }

   // Now create the line list
   FirstLine = map_LineListInit();
   if (FirstLine == NULL) {
      FreeMemory(NewSection->Name);
      FreeMemory(NewSection);
      return (MAP_SECTION *) NULL;
   }

   lstrcpy(NewSection->Name, Section);
   NewSection->LineCount = 0;
   NewSection->FirstLine = FirstLine;
   NewSection->LastLine = FirstLine->next;

   return NewSection;
} // map_SectionInit


/*+-------------------------------------------------------------------------+
  | map_SectionAdd()
  |
  +-------------------------------------------------------------------------+*/
void map_SectionAdd(MAP_FILE *hMap, LPTSTR Section) {
   MAP_SECTION *NewSection;

   NewSection = map_SectionInit(Section);
   if (NewSection == NULL)
      return;

   // Add it to the section list
   ll_InsertBefore((void *) hMap->LastSection, (void *) NewSection);

   // Init it so the added section is currently selected
   hMap->CurrentSection = NewSection;
   hMap->CurrentLine = hMap->CurrentSection->FirstLine;

} // map_SectionAdd


/*+-------------------------------------------------------------------------+
  | map_SectionDelete()
  |
  +-------------------------------------------------------------------------+*/
void map_SectionDelete(MAP_FILE *hMap) {
   MAP_SECTION *CurrentSection;
   MAP_SECTION *NewSection;

   // if no section is currently selected then get out
   CurrentSection = hMap->CurrentSection;
   if (CurrentSection == NULL)
      return;

   // Remove this from the chain
   NewSection = (MAP_SECTION *) ll_Delete((void *) CurrentSection);

   // walk the lines and remove them...
   map_LineListFree(CurrentSection->FirstLine);

   // All lines have been removed, so remove section header itself
   FreeMemory(CurrentSection->Name);
   FreeMemory(CurrentSection);

   // Update Section count
   if (hMap->SectionCount > 0)
      hMap->SectionCount--;

} // map_SectionDelete


/*+-------------------------------------------------------------------------+
  | map_SectionInsertBefore()
  |
  +-------------------------------------------------------------------------+*/
void map_SectionInsertBefore(MAP_FILE *hMap, LPTSTR Section) {
   MAP_SECTION *CurrentSection;

   if (hMap->CurrentSection == NULL)
      return;

   CurrentSection = map_SectionInit(Section);
   if (CurrentSection == NULL)
      return;

   ll_InsertBefore((void *) hMap->CurrentSection, (void *) CurrentSection);

} // map_SectionInsertBefore


/*+-------------------------------------------------------------------------+
  | map_SectionInsertAfter()
  |
  +-------------------------------------------------------------------------+*/
void map_SectionInsertAfter(MAP_FILE *hMap, LPTSTR Section) {
   MAP_SECTION *CurrentSection;

   if (hMap->CurrentSection == NULL)
      return;

   CurrentSection = map_SectionInit(Section);
   if (CurrentSection == NULL)
      return;

   ll_InsertAfter((void *) hMap->CurrentSection, (void *) CurrentSection);

} // map_SectionInsertAfter


/*+-------------------------------------------------------------------------+
  | map_SectionNext()
  |
  +-------------------------------------------------------------------------+*/
MAP_SECTION *map_SectionNext(MAP_FILE *hMap) {
   MAP_SECTION *CurrentSection;

   if (hMap->CurrentSection == NULL)
      return NULL;

   CurrentSection = (MAP_SECTION *) ll_Next((void *) hMap->CurrentSection);
   if (CurrentSection != NULL)
      hMap->CurrentSection = CurrentSection;

   return CurrentSection;
} // map_SectionNext


/*+-------------------------------------------------------------------------+
  | map_SectionPrev()
  |
  +-------------------------------------------------------------------------+*/
MAP_SECTION *map_SectionPrev(MAP_FILE *hMap) {
   MAP_SECTION *CurrentSection;

   if (hMap->CurrentSection == NULL)
      return NULL;

   CurrentSection = (MAP_SECTION *) ll_Prev((void *) hMap->CurrentSection);

   if (CurrentSection != NULL)
      hMap->CurrentSection = CurrentSection;

   return CurrentSection;
} // map_SectionPrev


/*+-------------------------------------------------------------------------+
  | map_SectionFind()
  |
  +-------------------------------------------------------------------------+*/
MAP_SECTION *map_SectionFind(MAP_FILE *hMap, LPTSTR Section) {
   MAP_SECTION *CurrentSection;

   CurrentSection = hMap->FirstSection;
   while (CurrentSection && lstrcmpi(CurrentSection->Name, Section))
      CurrentSection = (MAP_SECTION *) ll_Next((void *) CurrentSection);

   if (CurrentSection != NULL) {
      hMap->CurrentSection = CurrentSection;
      hMap->CurrentLine = hMap->CurrentSection->FirstLine;
   }

   return CurrentSection;
} // map_SectionFind


/*+-------------------------------------------------------------------------+
  | map_SectionHome()
  |
  +-------------------------------------------------------------------------+*/
void map_SectionHome(MAP_FILE *hMap) {
   hMap->CurrentSection = hMap->FirstSection;

   hMap->CurrentLine = hMap->CurrentSection->FirstLine;
} // map_SectionHome


/*+-------------------------------------------------------------------------+
  | map_SectionEnd()
  |
  +-------------------------------------------------------------------------+*/
void map_SectionEnd(MAP_FILE *hMap) {
   MAP_SECTION *CurrentSection;

   CurrentSection = hMap->FirstSection;
   while (CurrentSection && (CurrentSection->next != NULL))
      CurrentSection = CurrentSection->next;

   hMap->CurrentSection = CurrentSection;
   hMap->CurrentLine = CurrentSection->FirstLine;
} // map_SectionEnd




/*+-------------------------------------------------------------------------+
  |                               Line Routines
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | map_LineInit()
  |
  +-------------------------------------------------------------------------+*/
MAP_LINE *map_LineInit(LPTSTR Line) {
   MAP_LINE *NewLine;

   NewLine = (MAP_LINE *) AllocMemory(sizeof(MAP_LINE));
   if (NewLine == NULL)
      return (MAP_LINE *) NULL;

   NewLine->Line = (LPTSTR) AllocMemory((lstrlen(Line) + 1) * sizeof(TCHAR));

   if (NewLine->Line == NULL) {
      FreeMemory(NewLine);
      return (MAP_LINE *) NULL;
   }

   lstrcpy(NewLine->Line, Line);
   return NewLine;

} // map_LineInit


/*+-------------------------------------------------------------------------+
  | map_LineAdd()
  |
  +-------------------------------------------------------------------------+*/
MAP_LINE *map_LineAdd(MAP_FILE *hMap, LPTSTR Line) {
   MAP_LINE *NewLine;

   // make sure there is something to add it to
   if ((hMap->CurrentSection == NULL) || (hMap->CurrentSection->LastLine == NULL))
      return (MAP_LINE *) NULL;

   // Create the new line
   NewLine = map_LineInit(Line);

   if (NewLine->Line == NULL)
      return (MAP_LINE *) NULL;

   // ...and add it to our list
   ll_InsertBefore((void *) hMap->CurrentSection->LastLine, (void *) NewLine);

   // Init it so the added line is currently selected
   hMap->CurrentLine = NewLine;
   hMap->CurrentSection->LineCount++;
   return NewLine;

} // map_LineAdd


/*+-------------------------------------------------------------------------+
  | map_LineDelete()
  |
  +-------------------------------------------------------------------------+*/
void map_LineDelete(MAP_FILE *hMap) {
   MAP_LINE *CurrentLine;
   MAP_LINE *NewLine;

   // if no section is currently selected then get out
   if ((hMap->CurrentSection == NULL) || (hMap->CurrentLine == NULL))
      return;

   CurrentLine = hMap->CurrentLine;
   NewLine = (MAP_LINE *) ll_Delete((void *) CurrentLine);

   // All lines have been removed, so remove section header itself
   FreeMemory(CurrentLine->Line);
   FreeMemory(CurrentLine);

   // update hMap
   if (NewLine != NULL)
      hMap->CurrentLine = NewLine;
   else
      hMap->CurrentLine = hMap->CurrentSection->FirstLine;

   if (hMap->CurrentSection->LineCount > 0)
      hMap->CurrentSection->LineCount--;

} // map_LineDelete


/*+-------------------------------------------------------------------------+
  | map_LineInsertBefore()
  |
  +-------------------------------------------------------------------------+*/
void map_LineInsertBefore(MAP_FILE *hMap, LPTSTR Line) {
   MAP_LINE *NewLine;

   if ((hMap->CurrentSection == NULL) || (hMap->CurrentLine == NULL))
      return;

   NewLine = map_LineInit(Line);
   if (NewLine == NULL)
      return;

   ll_InsertBefore((void *) hMap->CurrentLine, (void *) NewLine);
} // map_LineInsertBefore


/*+-------------------------------------------------------------------------+
  | map_LineInsertAfter()
  |
  +-------------------------------------------------------------------------+*/
void map_LineInsertAfter(MAP_FILE *hMap, LPTSTR Line) {
   MAP_LINE *NewLine;

   if ((hMap->CurrentSection == NULL) || (hMap->CurrentLine == NULL))
      return;

   NewLine = map_LineInit(Line);
   if (NewLine == NULL)
      return;

   ll_InsertAfter((void *) hMap->CurrentLine, (void *) NewLine);
} // map_LineInsertAfter


/*+-------------------------------------------------------------------------+
  | map_LineNext()
  |
  +-------------------------------------------------------------------------+*/
MAP_LINE *map_LineNext(MAP_FILE *hMap) {
   MAP_LINE *CurrentLine;

   if ((hMap->CurrentSection == NULL) || (hMap->CurrentLine == NULL))
      return NULL;

   CurrentLine = (MAP_LINE *) ll_Next((void *) hMap->CurrentLine);
   if (CurrentLine != NULL)
      hMap->CurrentLine = CurrentLine;

   return CurrentLine;
} // map_LineNext


/*+-------------------------------------------------------------------------+
  | map_LinePrev()
  |
  +-------------------------------------------------------------------------+*/
MAP_LINE *map_LinePrev(MAP_FILE *hMap) {
   MAP_LINE *CurrentLine;

   if ((hMap->CurrentSection == NULL) || (hMap->CurrentLine == NULL))
      return NULL;

   CurrentLine = (MAP_LINE *) ll_Prev((void *) hMap->CurrentLine);
   if (CurrentLine != NULL)
      hMap->CurrentLine = CurrentLine;

   return CurrentLine;
} // map_LinePrev


/*+-------------------------------------------------------------------------+
  | map_LineHome()
  |
  +-------------------------------------------------------------------------+*/
void map_LineHome(MAP_FILE *hMap) {

   if ((hMap->CurrentSection == NULL) || (hMap->CurrentLine == NULL))
      return;

   hMap->CurrentLine = (MAP_LINE *) ll_Home((void *) hMap->CurrentLine);
} // map_LineHome


/*+-------------------------------------------------------------------------+
  | map_LineEnd()
  |
  +-------------------------------------------------------------------------+*/
void map_LineEnd(MAP_FILE *hMap) {
   if ((hMap->CurrentSection == NULL) || (hMap->CurrentLine == NULL))
      return;

   hMap->CurrentLine = (MAP_LINE *) ll_End((void *) hMap->CurrentLine);
} // map_LineEnd




/*+-------------------------------------------------------------------------+
  |                            Map File Routines
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | map_Home()
  |
  +-------------------------------------------------------------------------+*/
void map_Home(MAP_FILE *hMap) {
   hMap->CurrentSection = hMap->FirstSection;

} // map_Home


/*+-------------------------------------------------------------------------+
  | map_End()
  |
  +-------------------------------------------------------------------------+*/
void map_End(MAP_FILE *hMap) {
   MAP_SECTION *CurrentSection;
   MAP_LINE *CurrentLine = NULL;

   CurrentSection = hMap->FirstSection;
   while (CurrentSection->next != NULL)
      CurrentSection = CurrentSection->next;

   CurrentLine = CurrentSection->FirstLine;

   if (CurrentLine != NULL)
      while (CurrentLine->next != NULL)
         CurrentLine = CurrentLine->next;

   hMap->CurrentSection = CurrentSection;
   hMap->CurrentLine = CurrentLine;
} // map_End


/*+-------------------------------------------------------------------------+
  | map_Open()
  |
  +-------------------------------------------------------------------------+*/
MAP_FILE *map_Open(TCHAR *FileName) {
   MAP_FILE *hMap = NULL;
   HANDLE hFile = NULL;
   char *FileCache = NULL;
   char *chA;
   char *pchA;
   DWORD wrote;
   char lpszA[MAX_LINE_LEN + 1];
   TCHAR lpsz[MAX_LINE_LEN + 1];
   TCHAR tmpStr[MAX_LINE_LEN + 1];
   char FileNameA[MAX_PATH + 1];
   ULONG Size;
   TCHAR *ch;
   TCHAR *pch;
   TCHAR *lch;
   DWORD FSize;

   MAP_SECTION *CurrentSection = NULL;
   MAP_LINE *CurrentLine = NULL;

   WideCharToMultiByte(CP_ACP, 0, FileName, -1, FileNameA, sizeof(FileNameA), NULL, NULL);

   hFile = CreateFileA( FileNameA, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                  FILE_ATTRIBUTE_NORMAL, NULL);

   if (hFile == (HANDLE) INVALID_HANDLE_VALUE)
      return hMap;

   FSize = GetFileSize(hFile, NULL);

   FileCache = (char *) AllocMemory(FSize + 1);
   if (FileCache == NULL)
      goto map_OpenExit;

   hMap = (MAP_FILE *) AllocMemory(sizeof(MAP_FILE) + ((lstrlen(FileName) + 1) * sizeof(TCHAR)));
   if (hMap == NULL)
      goto map_OpenExit;

   // Init the section list
   CurrentSection = map_SectionListInit();
   if (CurrentSection == NULL) {
      FreeMemory(hMap);
      hMap = NULL;
      goto map_OpenExit;
   }

   hMap->FirstSection = CurrentSection;
   hMap->CurrentSection = CurrentSection;
   hMap->LastSection = CurrentSection->next;

   // Init the header info
   if (hMap != NULL) {
      hMap->hf = hFile;
      hMap->Modified = FALSE;
      hMap->CurrentLine = NULL;
      hMap->SectionCount = 0;

      lstrcpy(hMap->Name, FileName);
   }

   memset(FileCache, 0, FSize + 1);

   // Read in the whole file then parse it - it shouldn't be that large, a
   // very full NW server generated ~20K map file
   if (!ReadFile(hFile, FileCache, FSize, &wrote, NULL))
      goto map_OpenExit;

   // Now walk and parse the buffer - remember it's in ASCII
   chA = FileCache;
   while (*chA) {
      // Get past any white space junk at beginning of line
      while(*chA && ((*chA == ' ') || (*chA == '\t')))
         chA++;

      // transfer a line of text
      Size = 0;
      pchA = lpszA;
      while (*chA && (*chA != '\n') && (*chA != '\r') && (Size < MAX_LINE_LEN))
         *pchA++ = *chA++;

      *pchA = '\0';
      if (*chA == '\r')
         chA++;
      if (*chA == '\n')
         chA++;

      // ...convert line to Unicode
      MultiByteToWideChar(CP_ACP, 0, lpszA, -1, lpsz, sizeof(lpsz) );

      //
      // Now have a line of text - figure out what it is and update data
      // structures
      //

      // ...Check for section header
      ch = lpsz;
      lch = pch = tmpStr;
      if (*ch == TEXT(SECTION_BEGIN_CHAR)) {
         // Find end section brace - keeping track of last non-white space char
         // anything after end-section-brace is discarded.  Any trailing/
         // leading whitespace in section header is removed
         ch++;      // get past section-begin

         // remove any leading whitespace
         while(*ch && ((*ch == TEXT(' ')) || (*ch == TEXT('\t'))))
            ch++;

         // transfer it to tmpStr (via pch pointer)
         while (*ch && (*ch != TEXT(SECTION_END_CHAR))) {
            // keep track of last non-whitespace
            if ((*ch != TEXT(' ')) && (*ch != TEXT('\t'))) {
               lch = pch;
               lch++;
            }

            *pch++ = *ch++;
         }

         // NULL terminate before last section of whitespace
         *lch = TEXT('\0');

         // Allocate a new section-header block and init
         map_SectionAdd(hMap, tmpStr);
      } else {
         // Not section header, so normal line - copy to tmpStr via pch pointer
         while (*ch) {
            // keep track of last non-whitespace
            if ((*ch != TEXT(' ')) && (*ch != TEXT('\t'))) {
               lch = pch;
               lch++;
            }

            *pch++ = *ch++;
         }

         // NULL terminate before last section of whitespace
         *lch = TEXT('\0');

         // ...add it to the list
         map_LineAdd(hMap, tmpStr);
      }

      // Done with the line of text, so just loop back up to parse next
      // line
   }

map_OpenExit:

   FreeMemory(FileCache);
   return hMap;

} // map_Open


/*+-------------------------------------------------------------------------+
  | map_Close()
  |
  +-------------------------------------------------------------------------+*/
void map_Close(MAP_FILE *hMap) {
   // If file modified then re-write file.
   if ( hMap->Modified )
      ;

   // Write out cache of file, close it and clean up all the data structures
   CloseHandle( hMap->hf );
   hMap = NULL;
} // map_Close


/*+-------------------------------------------------------------------------+
  | ParseWord()
  |
  +-------------------------------------------------------------------------+*/
void ParseWord(TCHAR **lpch, LPTSTR tmpStr) {
   TCHAR *ch;
   TCHAR *lch;
   TCHAR *pch;

   ch = *lpch;
   lch = pch = tmpStr;

   // remove any leading whitespace
   while(*ch && ((*ch == TEXT(' ')) || (*ch == TEXT('\t'))))
      ch++;

   // transfer it to tmpStr (via pch pointer)
   while (*ch && (*ch != TEXT(WORD_DELIMITER))) {
      // keep track of last non-whitespace
      if ((*ch != TEXT(' ')) && (*ch != TEXT('\t'))) {
         lch = pch;
         lch++;
      }

      *pch++ = *ch++;
   }

   if (*ch == TEXT(WORD_DELIMITER))
      ch++;

   // NULL terminate before last section of whitespace
   *lch = TEXT('\0');
   *lpch = ch;

} // ParseWord


/*+-------------------------------------------------------------------------+
  | map_ParseUser()
  |
  +-------------------------------------------------------------------------+*/
void map_ParseUser(LPTSTR Line, LPTSTR Name, LPTSTR NewName, LPTSTR Password) {
   TCHAR *pch = Line;

   lstrcpy(Name, TEXT(""));
   lstrcpy(NewName, TEXT(""));
   lstrcpy(Password, TEXT(""));

   if (Line == NULL)
      return;

   ParseWord(&pch, Name);
   if (lstrlen(Name) >= MAX_USER_NAME_LEN)
      lstrcpy(Name, TEXT(""));

   ParseWord(&pch, NewName);
   if (lstrlen(NewName) >= MAX_USER_NAME_LEN)
      lstrcpy(NewName, TEXT(""));

   ParseWord(&pch, Password);
   if (lstrlen(Password) > MAX_PW_LEN)
      lstrcpy(Password, TEXT(""));

} // map_ParseUser


/*+-------------------------------------------------------------------------+
  | map_ParseGroup()
  |
  +-------------------------------------------------------------------------+*/
void map_ParseGroup(LPTSTR Line, LPTSTR Name, LPTSTR NewName) {
   TCHAR *pch = Line;

   lstrcpy(Name, TEXT(""));
   lstrcpy(NewName, TEXT(""));

   if (Line == NULL)
      return;

   ParseWord(&pch, Name);
   if (lstrlen(Name) >= MAX_GROUP_NAME_LEN)
      lstrcpy(Name, TEXT(""));

   ParseWord(&pch, NewName);
   if (lstrlen(NewName) >= MAX_GROUP_NAME_LEN)
      lstrcpy(NewName, TEXT(""));

} // map_ParseGroup


/*+-------------------------------------------------------------------------+
  | map_UsersEnum()
  |
  +-------------------------------------------------------------------------+*/
DWORD map_UsersEnum(MAP_FILE *hMap, USER_LIST **lpUsers) {
   DWORD ret = 0;
   USER_LIST *UserList = NULL;
   USER_BUFFER *UserBuffer = NULL;
   MAP_SECTION *CurrentSection = NULL;
   MAP_LINE *CurrentLine = NULL;
   ULONG Entries = 0;
   ULONG ActualEntries = 0;
   TCHAR Name[MAX_LINE_LEN + 1];
   TCHAR NewName[MAX_LINE_LEN + 1];
   TCHAR Password[MAX_LINE_LEN + 1];
   ULONG i;

   CurrentSection = map_SectionFind(hMap, Lids(IDS_M_7));
   if (CurrentSection != NULL)
      Entries = CurrentSection->LineCount;

   UserList = AllocMemory(sizeof(USER_LIST) + (sizeof(USER_BUFFER) * Entries));

   if (!UserList) {
      ret = ERROR_NOT_ENOUGH_MEMORY;
   } else {
      UserBuffer = UserList->UserBuffer;

      for (i = 0; i < Entries; i++) {
         CurrentLine = map_LineNext(hMap);

         if (CurrentLine != NULL) {
            map_ParseUser(CurrentLine->Line, Name, NewName, Password);

            if (lstrlen(Name)) {
               lstrcpy(UserBuffer[ActualEntries].Name, Name);
               lstrcpy(UserBuffer[ActualEntries].NewName, NewName);
               lstrcpy(UserBuffer[ActualEntries].Password, Password);

               if (lstrcmpi(Name, NewName))
                  UserBuffer[ActualEntries].IsNewName = TRUE;

               ActualEntries++;
            }
         }
      }

      if (ActualEntries != Entries)
         UserList = (USER_LIST *) ReallocMemory((HGLOBAL) UserList, sizeof(USER_LIST) + (sizeof(USER_BUFFER)* ActualEntries));

      if (UserList == NULL)
         ret = ERROR_NOT_ENOUGH_MEMORY;
      else {
         // Sort the server list before putting it in the dialog
         UserBuffer = UserList->UserBuffer;
         qsort((void *) UserBuffer, (size_t) ActualEntries, sizeof(USER_BUFFER), UserListCompare);
         UserList->Count = ActualEntries;
      }

      *lpUsers = UserList;
   }

   return ret;
} // map_UsersEnum


/*+-------------------------------------------------------------------------+
  | map_GroupsEnum()
  |
  +-------------------------------------------------------------------------+*/
DWORD map_GroupsEnum(MAP_FILE *hMap, GROUP_LIST **lpGroups) {
   DWORD ret = 0;
   GROUP_LIST *GroupList = NULL;
   GROUP_BUFFER *GroupBuffer = NULL;
   MAP_SECTION *CurrentSection = NULL;
   MAP_LINE *CurrentLine = NULL;
   ULONG Entries = 0;
   ULONG ActualEntries = 0;
   TCHAR Name[MAX_LINE_LEN + 1];
   TCHAR NewName[MAX_LINE_LEN + 1];
   ULONG i;


   CurrentSection = map_SectionFind(hMap, Lids(IDS_M_8));
   if (CurrentSection != NULL)
      Entries = CurrentSection->LineCount;

   GroupList = AllocMemory(sizeof(GROUP_LIST) + (sizeof(GROUP_BUFFER) * Entries));

   if (!GroupList) {
      ret = ERROR_NOT_ENOUGH_MEMORY;
   } else {
      GroupBuffer = GroupList->GroupBuffer;

      for (i = 0; i < Entries; i++) {
         CurrentLine = map_LineNext(hMap);

         if (CurrentLine != NULL) {
            map_ParseGroup(CurrentLine->Line, Name, NewName);

            if (lstrlen(Name)) {
               lstrcpy(GroupBuffer[ActualEntries].Name, Name);
               lstrcpy(GroupBuffer[ActualEntries].NewName, NewName);

               if (lstrcmpi(Name, NewName))
                  GroupBuffer[ActualEntries].IsNewName = TRUE;

               ActualEntries++;
            }
         }
      }

      if (ActualEntries != Entries)
         GroupList = (GROUP_LIST *) ReallocMemory((HGLOBAL) GroupList, sizeof(GROUP_LIST) + (sizeof(GROUP_BUFFER)* ActualEntries));

      if (GroupList == NULL)
         ret = ERROR_NOT_ENOUGH_MEMORY;
      else
         GroupList->Count = ActualEntries;

      *lpGroups = GroupList;
   }

   return ret;
} // map_GroupsEnum


/*+-------------------------------------------------------------------------+
  | MapFileWrite()
  |
  +-------------------------------------------------------------------------+*/
BOOL MapFileWrite(HANDLE hFile, LPTSTR String) {
   DWORD wrote;
   static char tmpStr[MAX_LINE_LEN + 1];

   WideCharToMultiByte(CP_ACP, 0, String, -1, tmpStr, sizeof(tmpStr), NULL, NULL);

   if (!WriteFile(hFile, tmpStr, strlen(tmpStr), &wrote, NULL))
      return FALSE;

   return TRUE;
} // MapFileWrite


/*+-------------------------------------------------------------------------+
  | MapFileOpen()
  |
  +-------------------------------------------------------------------------+*/
HANDLE MapFileOpen(LPTSTR FileNameW) {
   int ret;
   HANDLE hFile = NULL;
   char FileName[MAX_PATH + 1];

   WideCharToMultiByte(CP_ACP, 0, FileNameW, -1, FileName, sizeof(FileName), NULL, NULL);

   DeleteFile(FileNameW);

   // Now do the actual creation with error handling...
   do {
      ret = IDOK;
      hFile = CreateFileA( FileName, GENERIC_WRITE, 0, NULL, CREATE_NEW,
                           FILE_ATTRIBUTE_NORMAL, NULL );

      if (hFile == INVALID_HANDLE_VALUE)
         ret = ErrorBoxRetry(Lids(IDS_MAPCREATEFAIL));

   } while(ret == IDRETRY);

   return(hFile);

} // MapFileOpen



/*+-------------------------------------------------------------------------+
  | MappingFileCreate()
  |
  |    Creates a mapping file.  This allows the admin to specify for each
  |    user a new username and password.
  |
  +-------------------------------------------------------------------------+*/
BOOL MappingFileCreate(LPTSTR FileName, LPTSTR Server) {
   BOOL status = FALSE;
   DWORD ret = 0;
   USER_LIST *Users;
   DWORD UserCount;
   GROUP_LIST *Groups;
   GROUP_BUFFER *GroupBuffer;
   USER_BUFFER *UserBuffer;
   DWORD GroupCount;
   int Count;
   HANDLE hFile = NULL;
   static TCHAR tmpStr[MAX_LINE_LEN + 1];
   static TCHAR tmpStr2[MAX_LINE_LEN + 1];

   // Create Empty map file
   hFile = MapFileOpen(FileName);
   if (hFile == INVALID_HANDLE_VALUE)
      return FALSE;

   CursorHourGlass();

   // Now write out header gunk
   status = MapFileWrite(hFile, Lids(IDS_LINE));
   wsprintf(tmpStr, Lids(IDS_M_1), Server);
   wsprintf(tmpStr2, Lids(IDS_BRACE), tmpStr);
   if (status)
      status = MapFileWrite(hFile, tmpStr2);

   wsprintf(tmpStr, Lids(IDS_BRACE), Lids(IDS_M_2));
   if (status)
      status = MapFileWrite(hFile, tmpStr);

   wsprintf(tmpStr, Lids(IDS_BRACE), TEXT(""));
   if (status)
      status = MapFileWrite(hFile, tmpStr);

   wsprintf(tmpStr, Lids(IDS_BRACE), Lids(IDS_M_3));
   if (status)
      status = MapFileWrite(hFile, tmpStr);

   wsprintf(tmpStr, Lids(IDS_BRACE), Lids(IDS_M_4));
   if (status)
      status = MapFileWrite(hFile, tmpStr);

   wsprintf(tmpStr, Lids(IDS_BRACE), TEXT(""));
   if (status)
      status = MapFileWrite(hFile, tmpStr);

   if (status)
      status = MapFileWrite(hFile, Lids(IDS_LINE));

   // [USERS] section header
   if (DoUsers && status)
      status = MapFileWrite(hFile, Lids(IDS_M_5));

   // If anything went wrong with writing header, get out
   if (!status) {
      CursorNormal();
      return FALSE;
   }

   // Header is all done - now lets do the actual users and such
   if (!(ret = NWServerSet(Server))) {
      //
      // If users were selected then put them into the map file
      //
      if (DoUsers) {
         if (!NWUsersEnum(&Users, FALSE) && (Users != NULL)) {
            UserCount = Users->Count;
            UserBuffer = Users->UserBuffer;

            for (Count = 0; Count < (int) UserCount; Count++) {
               if (status) {
                  switch(PasswordOption) {
                     case 0:  // No password
                        wsprintf(tmpStr, TEXT("%s, %s,\r\n"), UserBuffer[Count].Name, UserBuffer[Count].Name);
                        break;

                     case 1:  // Password is username
                        wsprintf(tmpStr, TEXT("%s, %s, %s\r\n"), UserBuffer[Count].Name, UserBuffer[Count].Name, UserBuffer[Count].Name);
                        break;

                     case 2:  // Password is constant
                        wsprintf(tmpStr, TEXT("%s, %s, %s\r\n"), UserBuffer[Count].Name, UserBuffer[Count].Name, PasswordConstant);
                        break;
                  }
                  status = MapFileWrite(hFile, tmpStr);
               }
            }

            FreeMemory((LPBYTE) Users);
         }
      }

      //
      // If groups were selected then put them in map file
      //
      if (DoGroups) {
         // [GROUPS] section header
         if (status)
            status = MapFileWrite(hFile, Lids(IDS_M_6));

         if (!NWGroupsEnum(&Groups, FALSE) && (Groups != NULL)) {
            GroupCount = Groups->Count;
            GroupBuffer = Groups->GroupBuffer;

            for (Count = 0; Count < (int) GroupCount; Count++) {
               if (status) {
                  wsprintf(tmpStr, TEXT("%s, %s\r\n"), GroupBuffer[Count].Name, GroupBuffer[Count].Name);
                  status = MapFileWrite(hFile, tmpStr);
               }
            }

            FreeMemory((LPBYTE) Groups);
         }

      }

      NWServerFree();
   }

   CloseHandle( hFile );
   CursorNormal();
   return status;

} // MappingFileCreate


/*+-------------------------------------------------------------------------+
  | MappingFileNameResolve()
  |
  +-------------------------------------------------------------------------+*/
BOOL MappingFileNameResolve(HWND hDlg) {
   HWND hCtrl;
   static char FileNameA[MAX_PATH + 1];
   static char CmdLine[MAX_PATH + 1 + 12];    // Editor + file
   TCHAR drive[MAX_DRIVE + 1];
   TCHAR dir[MAX_PATH + 1];
   TCHAR fname[MAX_PATH + 1];
   TCHAR ext[_MAX_EXT + 1];
   UINT uReturn;
   BOOL ret = TRUE;

   // First check filename
   hCtrl = GetDlgItem(hDlg, IDC_MAPPINGFILE);
   * (WORD *)MappingFile = sizeof(MappingFile);
   SendMessage(hCtrl, EM_GETLINE, 0, (LPARAM) MappingFile);
   lsplitpath(MappingFile, drive, dir, fname, ext);

   // remake path so it is fully qualified
   if ((drive[0] == TEXT('\0')) && (dir[0] == TEXT('\0')))
      lstrcpy(dir, ProgPath);

   if (ext[0] == TEXT('\0'))
      lstrcpy(ext, Lids(IDS_S_36));

   lmakepath(MappingFile, drive, dir, fname, ext);

   if (MappingFileCreate(MappingFile, SourceServ)) {
      if (MessageBox(hDlg, Lids(IDS_MAPCREATED), Lids(IDS_APPNAME), MB_YESNO | MB_ICONQUESTION) == IDYES) {

         WideCharToMultiByte(CP_ACP, 0, MappingFile, -1, FileNameA, sizeof(FileNameA), NULL, NULL);

         wsprintfA(CmdLine, "Notepad %s", FileNameA);
         uReturn = WinExec(CmdLine, SW_SHOW);
      }
   } else {
      MessageBox(hDlg, Lids(IDS_MAPCREATEFAIL), Lids(IDS_TXTWARNING), MB_OK);
      ret = FALSE;
   }

   return ret;

} // MappingFileNameResolve


/*+-------------------------------------------------------------------------+
  | MapCreate()
  |
  +-------------------------------------------------------------------------+*/
LRESULT CALLBACK MapCreateProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
   HWND hCtrl;
   int wmId, wmEvent;
   static short UserNameTab, GroupNameTab, PasswordsTab, DefaultsTab;

   switch (message) {

      case WM_INITDIALOG:
         // Center the dialog over the application window
         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));

         // limit edit field lengths
         hCtrl = GetDlgItem(hDlg, IDC_MAPPINGFILE);
         PostMessage(hCtrl, EM_LIMITTEXT, (WPARAM) MAX_PATH, 0);
         hCtrl = GetDlgItem(hDlg, IDC_PWCONST);
         PostMessage(hCtrl, EM_LIMITTEXT, (WPARAM) MAX_PW_LEN, 0);

         // set mapping file name and init OK button appropriatly
         hCtrl = GetDlgItem(hDlg, IDC_MAPPINGFILE);
         SendMessage(hCtrl, WM_SETTEXT, 0, (LPARAM) MappingFile);
         hCtrl = GetDlgItem(hDlg, IDC_MAPPINGFILE);

         if (SendMessage(hCtrl, EM_LINELENGTH, 0, 0)) {
            hCtrl = GetDlgItem(hDlg, IDOK);
            EnableWindow(hCtrl, TRUE);
         } else {
            hCtrl = GetDlgItem(hDlg, IDOK);
            EnableWindow(hCtrl, FALSE);
         }

         // check Users and Groups checkbox's
         hCtrl = GetDlgItem(hDlg, IDC_USERS);
         SendMessage(hCtrl, BM_SETCHECK, 1, 0);
         hCtrl = GetDlgItem(hDlg, IDC_GROUPS);
         SendMessage(hCtrl, BM_SETCHECK, 1, 0);
         CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO3, IDC_RADIO1);
         return (TRUE);

      case WM_COMMAND:
         wmId    = LOWORD(wParam);
         wmEvent = HIWORD(wParam);

      switch (wmId) {
         // [OK] button
         case IDOK:
            // Figure out what password option is checked...
            hCtrl = GetDlgItem(hDlg, IDC_RADIO1);
            if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
               PasswordOption = 0;

            hCtrl = GetDlgItem(hDlg, IDC_RADIO2);
            if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
               PasswordOption = 1;

            hCtrl = GetDlgItem(hDlg, IDC_RADIO3);
            if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
               PasswordOption = 2;

            hCtrl = GetDlgItem(hDlg, IDC_PWCONST);
            * (WORD *)PasswordConstant = sizeof(PasswordConstant);
            SendMessage(hCtrl, EM_GETLINE, 0, (LPARAM) PasswordConstant);

            EnableWindow(hDlg, FALSE);
            MappingFileNameResolve(hDlg);
            EnableWindow(hDlg, TRUE);
            EndDialog(hDlg, 0);
            return (TRUE);
            break;

         // [CANCEL] button
         case IDCANCEL:
            EndDialog(hDlg, 0);
            return (TRUE);
            break;

         // [HELP] button
         case IDHELP:
            WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDC_HELP_CMAP);
            return (TRUE);
            break;

         // Checkbox for Users
         case IDC_USERS:
            DoUsers = !DoUsers;

            hCtrl = GetDlgItem(hDlg, IDC_RADIO1);
            EnableWindow(hCtrl, DoUsers);
            hCtrl = GetDlgItem(hDlg, IDC_RADIO2);
            EnableWindow(hCtrl, DoUsers);
            hCtrl = GetDlgItem(hDlg, IDC_RADIO3);
            EnableWindow(hCtrl, DoUsers);
            hCtrl = GetDlgItem(hDlg, IDC_PWCONST);
            EnableWindow(hCtrl, DoUsers);

            return (TRUE);
            break;

         // Checkbox for Groups
         case IDC_GROUPS:
            DoGroups = !DoGroups;
            return (TRUE);
            break;

         // Edit field for password constant
         case IDC_PWCONST:

            if (wmEvent == EN_CHANGE)
               CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO3, IDC_RADIO3);

            break;

         // Edit field for password constant
         case IDC_MAPPINGFILE:
            if (wmEvent == EN_CHANGE) {
               hCtrl = GetDlgItem(hDlg, IDC_MAPPINGFILE);

               if (SendMessage(hCtrl, EM_LINELENGTH, 0, 0)) {
                  hCtrl = GetDlgItem(hDlg, IDOK);
                  EnableWindow(hCtrl, TRUE);
               } else {
                  hCtrl = GetDlgItem(hDlg, IDOK);
                  EnableWindow(hCtrl, FALSE);
               }

            }
            break;

         // [...] button for mapping file
         case IDC_BTNMAPPINGFILE:
            // Let the user browse for a file
            if (!UserFileGet(hDlg, MappingFile)) {
               hCtrl = GetDlgItem(hDlg, IDC_MAPPINGFILE);
               SendMessage(hCtrl, WM_SETTEXT, 0, (LPARAM) MappingFile);
               SetFocus(hCtrl);
            }
            return (TRUE);
            break;

      }
      break;
   }

   return (FALSE); // Didn't process the message

   lParam;
} // MapCreateProc



/*+-------------------------------------------------------------------------+
  | MapFileCreate()
  |
  +-------------------------------------------------------------------------+*/
BOOL MapFileCreate(HWND hDlg, LPTSTR FileName, LPTSTR Server) {
   DLGPROC lpfnDlg;

   DoUsers = TRUE;
   DoGroups = TRUE;
   PasswordOption = 0;
   lstrcpy(MappingFile, FileName);
   lstrcpy(PasswordConstant, TEXT(""));
   SourceServ = Server;

   lpfnDlg = MakeProcInstance((DLGPROC)MapCreateProc, hInst);
   DialogBox(hInst, TEXT("MAPCreate"), hDlg, lpfnDlg) ;
   FreeProcInstance(lpfnDlg);

   lstrcpy(FileName, MappingFile);
   return TRUE;
} // MapFileCreate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\loghours.h ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    loghours.h

Abstract:

    Private routines to support rotation of logon hours between local time
    and GMT time.

Author:

    Cliff Van Dyke (cliffv) 16-Mar-93

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/



//
// Procedure forwards from loghours.c
//

BOOLEAN
NetpRotateLogonHoursPhase1(
    IN BOOL  ConvertToGmt,
    OUT PULONG RotateCount
    );

BOOLEAN
NetpRotateLogonHoursPhase2(
    IN PBYTE LogonHours,
    IN DWORD UnitsPerWeek,
    IN LONG  RotateCount
    );

BOOLEAN
NetpRotateLogonHours(
    IN PBYTE LogonHours,
    IN DWORD UnitsPerWeek,
    IN BOOL  ConvertToGmt
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\mem.h ===
//=============================================================================
//  Microsoft (R) Bloodhound (tm). Copyright (C) 1991-1993.
//
//  MODULE: objmgr.h
//
//  Modification History
//
//  raypa           03/17/93    Created.
//=============================================================================

#if !defined(_OBJMGR_)


#define _OBJMGR_
#pragma pack(1)

#ifdef __cplusplus
extern "C"{
#endif

//=============================================================================
//  Memory functions.
//=============================================================================

extern LPVOID     WINAPI AllocMemory(DWORD size);

extern LPVOID     WINAPI ReallocMemory(LPVOID ptr, DWORD NewSize);

extern VOID       WINAPI FreeMemory(LPVOID ptr);

extern DWORD_PTR  WINAPI MemorySize(LPVOID ptr);

void MemInit();

#ifdef __cplusplus
}
#endif

#pragma pack()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\mem.c ===
//=============================================================================
//  Microsoft (R) Bloodhound (tm). Copyright (C) 1991-1992.
//
//  MODULE: mem.c
//
//  Modification History
//
//  raypa               01/28/93    Created
//  stevehi             07/21/93    Added memory checking functionality
//  raypa               07/21/93    Changed to use LPTR rather than LocalLock.
//  Tom Laird-McConnell 08/16/93    Changed to fix no size info in functions
//  arth                06/16/94    Added extra debug tracing code
//=============================================================================

#include "switches.h"

#include <windows.h>
#include "mem.h"
#include <memory.h>
#include <stdio.h>
#include "debug.h"
#include "strings.h"
#include <process.h>
#include "utils.h"

#ifdef DEBUG_MEM
BOOL _rtlpheapvalidateoncall = TRUE;

typedef struct _MEM_BUFFER {
   struct _MEM_BUFFER *Next;
   struct _MEM_BUFFER *Prev;
   ULONG Size;

} MEM_BUFFER;

MEM_BUFFER *MemList = NULL;
ULONG AllocCount = 0;
#endif

//=============================================================================
//  Define Tags used by the following routines to stick into memory
//  and compare later.
//=============================================================================

#define AllocTagTakeStart     0x3e4b4154  //... TAK>
#define AllocTagTakeStop      0x4b41543c  //... <TAK
#define AllocTagReAllocStart  0x3e414552  //... REA>
#define AllocTagReAllocStop   0x4145523c  //... <REA
#define AllocTagFreeStart     0x3e455246  //... FRE>
#define AllocTagFreeStop      0x4552463c  //... <FRE

// Just load the dynamic strings so we don't have to do it if we run out of 
// memory (otherwise we might not be able to load them then).
void MemInit() {
   LPTSTR x;

   x = Lids(IDS_S_7);
   x = Lids(IDS_S_8);

} // MemInit


#ifdef DEBUG_MEM

void DBG_MemEnum(void) {
   MEM_BUFFER *lpMem;
   ULONG TotSize = 0;
   ULONG i = 1;
   UNALIGNED LPBYTE lpByte;

   lpMem = MemList;

   dprintf(TEXT("\nMem Dump\n# Allocations: %lu\n\n"), AllocCount);

   while (lpMem != NULL) {
      TotSize += lpMem->Size;

      lpByte = (LPBYTE) lpMem;
      lpByte -= sizeof(DWORD);

      dprintf(TEXT("%lu %lX) Alloc Size: %lu\n"), i++, lpMem, lpMem->Size);

      if ( *(LPDWORD)(lpByte) != AllocTagTakeStart ) {
         dprintf(TEXT("AllocTagStart Corrupt\n"));
         dprintf(TEXT("Total Alloc Mem: %lu\n"), TotSize);
         DebugBreak;
      }

      lpByte += sizeof(DWORD) + sizeof(MEM_BUFFER) + lpMem->Size;
      if ( *(LPDWORD)(lpByte) != AllocTagTakeStop ) {
         dprintf(TEXT("AllocTagStop Corrupt\n"));
         dprintf(TEXT("Total Alloc Mem: %lu\n"), TotSize);
         DebugBreak;
      }

      lpMem = lpMem->Next;
   }

   dprintf(TEXT("\nTotal Alloc Mem: %lu\n"), TotSize);
} // DBG_MemEnum

#endif


//=============================================================================
//  FUNCTION: AllocMemory()
//
//  Modification History
//
//  raypa       01/28/93    Created.
//  stevehi     07/21/93    Added memory checking functionality
//  raypa       07/21/93    Changed to use LPTR rather than LocalLock.
//  raypa       07/21/93    Return NULL if size is zero.
//=============================================================================

LPVOID WINAPI AllocMemory(DWORD size) {
   register LPBYTE lpByte;
   int ret;

#ifndef DEBUG_MEM
    do {
       ret = IDOK;
       lpByte = LocalAlloc(LPTR, size);

       if ((lpByte == NULL) && (size != 0)) {
          MessageBeep(MB_ICONHAND);
          ret = MessageBox(NULL, Lids(IDS_S_7), Lids(IDS_S_8), MB_ICONHAND | MB_SYSTEMMODAL | MB_RETRYCANCEL);

          if (ret == IDCANCEL)
             exit(1);
       }

    } while (ret == IDRETRY);

   return (LPVOID) lpByte;
#else
    DWORD ActualSize;
    MEM_BUFFER *lpMem;

    if ( size != 0 ) {
       do {
          ret = IDOK;
          // take into account 2 tags and buffer header
          lpByte = LocalAlloc(LPTR, size + (2 * sizeof(DWORD)) + sizeof(MEM_BUFFER));

          if (lpByte == NULL) {
             MessageBeep(MB_ICONHAND);
             DBG_MemEnum();
             ret = MessageBox(NULL, TEXT("Out of Memory"), TEXT("NwConv - Error"), MB_ICONHAND | MB_SYSTEMMODAL | MB_RETRYCANCEL);

             if (ret == IDCANCEL)
                exit(1);
          }
                  
       } while (ret == IDRETRY);

        AllocCount++;
        ActualSize = LocalSize(lpByte) - (2 * sizeof(DWORD)) - sizeof(MEM_BUFFER);
        *((LPDWORD)(lpByte)) = AllocTagTakeStart;
        lpMem = (MEM_BUFFER *) &lpByte[sizeof(DWORD)];

        lpMem->Next = MemList;
        lpMem->Prev = NULL;
        if (MemList != NULL)
            MemList->Prev = lpMem;

        lpMem->Size = ActualSize;
        MemList = lpMem;
        
        *((LPDWORD)(lpByte + ActualSize + sizeof(DWORD) + sizeof(MEM_BUFFER))) = AllocTagTakeStop;

        return (LPVOID) &lpByte[sizeof(DWORD) + sizeof(MEM_BUFFER)];
    }

    return NULL;
#endif

} // AllocMemory


//=============================================================================
//  FUNCTION: ReallocMemory()
//
//  Modification History
//
//  raypa       01/28/93                Created.
//  stevehi     07/21/93                Added memory checking functionality
//  raypa       07/21/93                Changed to use LPTR rather than LocalLock.
//  raypa       10/22/93                If the ptr is NULL then use AllocMemory.
//=============================================================================

LPVOID WINAPI ReallocMemory(LPVOID ptr, DWORD NewSize) {
#ifdef DEBUG_MEM
    DWORD GSize;
    MEM_BUFFER *lpMem;
    MEM_BUFFER *OldMem;
#endif

    //=========================================================================
    //  If the ptr is NULL then use AllocMemory.
    //=========================================================================

    if ( ptr == NULL ) {
        return AllocMemory(NewSize);
    }

#ifndef DEBUG_MEM
    return LocalReAlloc(ptr, NewSize, LHND);
#else
    // we are reallocing... might as well check the tags here...

    (LPBYTE)ptr -= (sizeof(DWORD) + sizeof(MEM_BUFFER));

    GSize = LocalSize (ptr);

    if ( *(LPDWORD)(ptr) != AllocTagTakeStart )
        DebugBreak;

    // get the size and check the end tag

    if (GSize && ( *(LPDWORD)((LPBYTE)ptr + GSize - sizeof(DWORD))) != AllocTagTakeStop ) {
        DebugBreak;
    }

    // just for grins, mark the realloc part.

    *(LPDWORD)(ptr) = AllocTagReAllocStart;

    if ( GSize )
        *(LPDWORD)((LPBYTE)ptr + GSize - sizeof(DWORD) ) = AllocTagReAllocStop;

    OldMem = (MEM_BUFFER *) ((LPBYTE)ptr + sizeof(DWORD));

    ptr = LocalReAlloc(ptr, NewSize + sizeof(MEM_BUFFER) + (2 * sizeof(DWORD)), LHND);

    if (ptr == NULL ) {
        dprintf(TEXT("NWConv - Local Realloc failed with %ld.\r\n"), GetLastError() );

        DebugBreak;

        return NULL;
    }

    lpMem = (MEM_BUFFER *) ((LPBYTE)ptr + sizeof(DWORD));

    if (MemList == OldMem)
      MemList = lpMem;

    if (lpMem->Prev != NULL)
      lpMem->Prev->Next = lpMem;

    if (lpMem->Next != NULL)
      lpMem->Next->Prev = lpMem;

    lpMem->Size = NewSize;

    *((LPDWORD)ptr) = AllocTagTakeStart;
    *((LPDWORD)((LPBYTE)ptr + NewSize + sizeof(MEM_BUFFER) + sizeof(DWORD))) = AllocTagTakeStop;

    return (LPVOID)((LPBYTE)ptr + sizeof(DWORD) + sizeof(MEM_BUFFER));
#endif
} // ReAllocMemory


//=============================================================================
//  FUNCTION: FreeMemory()
//
//  Modification History
//
//  raypa       01/28/93                Created.
//  stevehi     07/21/93                Added memory checking functionality
//  raypa       07/21/93                Changed to use LPTR rather than LocalLock.
//  raypa       07/21/93                Fixed GP-fault on NULL ptr.
//  raypa       11/21/93                Allow freeing of NULL pointer.
//=============================================================================

VOID WINAPI FreeMemory(LPBYTE ptr) {
    //=========================================================================
    //  If the pointer is NULL, exit.
    //=========================================================================

    if ( ptr != NULL ) {
#ifdef DEBUG_MEM
        register DWORD Size;
        register LPDWORD DwordPtr;
        MEM_BUFFER *lpMem;

        ptr -= (sizeof(DWORD) + sizeof(MEM_BUFFER));
        lpMem = (MEM_BUFFER *) ((LPBYTE)ptr + sizeof(DWORD));

        Size = LocalSize(ptr);
    
        //... Check start tag
        DwordPtr = (LPDWORD) &ptr[0];

        if ( *DwordPtr != AllocTagTakeStart ) {
            dprintf(TEXT("NWConv - FreeMemory: Invalid start signature: ptr = %X\r\n"), ptr);

            DebugBreak();
        }
        else {
            *DwordPtr = AllocTagFreeStart;
        }

        //... get the size and check the end tag

        DwordPtr = (LPDWORD) &ptr[Size - sizeof(DWORD)];

        if ( *DwordPtr != AllocTagTakeStop ) {
            dprintf(TEXT("NWConv - FreeMemory: Invalid end signature: ptr = %X\r\n"), ptr);

            DebugBreak();
        }
        else {
            *DwordPtr = AllocTagFreeStop;
        }

        AllocCount--;
        if (MemList == lpMem)
            MemList = lpMem->Next;

        if (lpMem->Prev != NULL)
            lpMem->Prev->Next = lpMem->Next;

        if (lpMem->Next != NULL)
           lpMem->Next->Prev = lpMem->Prev;
#endif

        LocalFree(ptr);
    }
} // FreeMemory


//=============================================================================
//  FUNCTION: MemorySize()
//
//  Modification History
//
//  Tom Laird-McConnell 08/02/93    Created.
//  Tom Laird-McConnell 08/02/93    Changed to use local var for size...
//=============================================================================

DWORD_PTR WINAPI MemorySize(LPBYTE ptr) {
#ifdef DEBUG_MEM
    register DWORD_PTR Size;

    if ( ptr != NULL ) {
        register LPDWORD DwordPtr;

        ptr -= (sizeof(DWORD) + sizeof(MEM_BUFFER));

        Size = LocalSize(ptr);

        DwordPtr = (LPDWORD) &ptr[0];

        // Check start tag

        if ( *DwordPtr != AllocTagTakeStart ) {
            dprintf(TEXT("NWConv - MemorySize: Invalid start signature!\r\n"));

            DebugBreak;
        }

        // get the size and check the end tag

        DwordPtr = (LPDWORD) &ptr[Size - sizeof(DWORD)];

        if ( *DwordPtr != AllocTagTakeStop ) {
            dprintf(TEXT("NWConv - MemorySize: Invalid end signature!\r\n"));

            DebugBreak;
        }

        return (Size - (2 * sizeof(DWORD)) - sizeof(MEM_BUFFER));
    }
#endif

    return LocalSize(ptr);
} // MemorySize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\map.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _HMAPFILE_
#define _HMAPFILE_

#ifdef __cplusplus
extern "C"{
#endif


typedef struct _MAP_LINE {
   struct _MAP_LINE *next;
   struct _MAP_LINE *prev;

   LPTSTR Line;
} MAP_LINE;

typedef struct _MAP_SECTION {
   struct _MAP_SECTION *next;
   struct _MAP_SECTION *prev;

   LPTSTR Name;
   MAP_LINE *FirstLine;
   MAP_LINE *LastLine;
   ULONG LineCount;
} MAP_SECTION;

typedef struct _MAP_FILE {
   HANDLE hf;
   BOOL Modified;

   MAP_SECTION *FirstSection;
   MAP_SECTION *LastSection;
   MAP_SECTION *CurrentSection;
   MAP_LINE *CurrentLine;
   ULONG SectionCount;
   TCHAR Name[];
} MAP_FILE;

#define FILE_CACHE_SIZE 2048
#define MAX_LINE_LEN 512

#define SECTION_BEGIN_CHAR '['
#define SECTION_END_CHAR ']'
#define COMMENT_CHAR ';'
#define WORD_DELIMITER ','

BOOL MapFileCreate(HWND hDlg, LPTSTR FileName, LPTSTR Server);
DWORD map_UsersEnum(MAP_FILE *hMap, USER_LIST **lpUsers);
DWORD map_GroupsEnum(MAP_FILE *hMap, GROUP_LIST **lpGroups);

MAP_FILE *map_Open(TCHAR *FileName);
void map_Close(MAP_FILE *hMap);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\netutil.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _HNETUTIL_
#define _HNETUTIL_

#ifdef __cplusplus
extern "C"{
#endif

// made to match usri3 info structure for easy save/retrieval
typedef struct _NT_USER_INFO {
    LPWSTR   name;
    LPWSTR   password;
    DWORD    password_age;
    DWORD    priv;
    LPWSTR   home_dir;
    LPWSTR   comment;
    DWORD    flags;
    LPWSTR   script_path;
    DWORD    auth_flags;
    LPWSTR   full_name;
    LPWSTR   usr_comment;
    LPWSTR   parms;
    LPWSTR   workstations;
    DWORD    last_logon;
    DWORD    last_logoff;
    DWORD    acct_expires;
    DWORD    max_storage;
    DWORD    units_per_week;
    PBYTE    logon_hours;
    DWORD    bad_pw_count;
    DWORD    num_logons;
    LPWSTR   logon_server;
    DWORD    country_code;
    DWORD    code_page;
    DWORD    user_id;
    DWORD    primary_group_id;
    LPWSTR   profile;
    LPWSTR   home_dir_drive;
    DWORD    password_expired;
} NT_USER_INFO, *PNT_USER_INFO, *LPNT_USER_INFO;


typedef struct _FPNW_INFO {
   WORD MaxConnections;
   WORD PasswordInterval;
   BYTE GraceLoginAllowed;
   BYTE GraceLoginRemaining;
   LPWSTR LoginFrom;
   LPWSTR HomeDir;
} FPNW_INFO, *PFPNW_INFO, *LPFPNW_INFO;



// made to match  USER_MODALS_INFO_0 info structure for easy save/retrieval
typedef struct _NT_DEFAULTS {
    DWORD min_passwd_len;
    DWORD max_passwd_age;
    DWORD min_passwd_age;
    DWORD force_logoff;
    DWORD password_hist_len;
} NT_DEFAULTS, *PNT_DEFAULTS, *LPNT_DEFAULTS;


typedef struct _EnumRec {
   struct _EnumRec *next;
   DWORD cEntries;
   DWORD cbBuffer;
   LPNETRESOURCE lpnr;
} ENUM_REC;

void FixPathSlash(LPTSTR NewPath, LPTSTR Path);
LPTSTR ShareNameParse(LPTSTR ShareName);
void GetLocalName(LPTSTR *lpLocalName);
BOOL SetProvider(LPTSTR Provider, NETRESOURCE *ResourceBuf);
ENUM_REC *AllocEnumBuffer();
DWORD FAR PASCAL EnumBufferBuild(ENUM_REC **BufHead, int *NumBufs, NETRESOURCE ResourceBuf);
BOOL UseAddPswd(HWND hwnd, LPTSTR UserName, LPTSTR lpszServer, LPTSTR lpszShare, LPTSTR Provider);
LPTSTR NicePath(int Len, LPTSTR Path);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\netutil.c ===
/*
  +-------------------------------------------------------------------------+
  |                    Network Utility Functions                            |
  +-------------------------------------------------------------------------+
  |                     (c) Copyright 1993-1994                             |
  |                          Microsoft Corp.                                |
  |                        All rights reserved                              |
  |                                                                         |
  | Program               : [NetUtil.c]                                     |
  | Programmer            : Arthur Hanson                                   |
  | Original Program Date : [Feb 16, 1993]                                  |
  | Last Update           : [Jun 16, 1994]                                  |
  |                                                                         |
  | Version:  1.00                                                          |
  |                                                                         |
  | Description:                                                            |
  |                                                                         |
  | History:                                                                |
  |   arth  Jun 16, 1994    1.00    Original Version.                       |
  |                                                                         |
  +-------------------------------------------------------------------------+
*/

#include "globals.h"
#include "netutil.h"

static LPTSTR ServName;
static TCHAR szPassword[PWLEN+1];
static TCHAR szUserName[MAX_USER_NAME_LEN + 1];

LRESULT CALLBACK PasswordDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL BadPassword;

/*+-------------------------------------------------------------------------+
  | FixPathSlash()
  |
  +-------------------------------------------------------------------------+*/
void FixPathSlash(LPTSTR NewPath, LPTSTR Path) {
   UINT PathLen;
   lstrcpy(NewPath, Path);

   PathLen = lstrlen(Path);
   // If ending character is not a slash then put one on
   if (PathLen && (Path[PathLen - 1] != '\\'))
      lstrcat(NewPath, TEXT("\\"));

} // FixPathSlash


/*+-------------------------------------------------------------------------+
  | ShareNameParse()
  |
  +-------------------------------------------------------------------------+*/
LPTSTR ShareNameParse(LPTSTR ShareName) {
   ULONG i;

   i = lstrlen(ShareName);
   if (!i)
      return ShareName;

   // Scan backwards for first slash
   i--;
   while (i && ShareName[i] != TEXT('\\'))
      i--;

   // if found slash then increment past it
   if (i)
      i++;

   return &ShareName[i];

} // ShareNameParse


static LPTSTR LocName = NULL;
/*+-------------------------------------------------------------------------+
  | GetLocalName()
  |
  +-------------------------------------------------------------------------+*/
void GetLocalName(LPTSTR *lpLocalName) {
   int size;

   if (LocName != NULL) {
      *lpLocalName = LocName;
   } else {
      LocName = AllocMemory((MAX_COMPUTERNAME_LENGTH + 1) * sizeof(TCHAR));
      size = MAX_COMPUTERNAME_LENGTH + 1;

      if (LocName) {
         GetComputerName(LocName, &size);
         *lpLocalName = LocName;
      } else
         *lpLocalName = NULL;
   }

} // GetLocalName


/*+-------------------------------------------------------------------------+
  | SetProvider()
  |
  +-------------------------------------------------------------------------+*/
BOOL SetProvider(LPTSTR Provider, NETRESOURCE *ResourceBuf) {
   ResourceBuf->dwScope = RESOURCE_GLOBALNET;
   ResourceBuf->dwType = RESOURCETYPE_DISK;
   ResourceBuf->dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
   
   // Don't take the frigging _RESERVED flag out - it isn't documented except in the include
   // file and it crashes without it!
   ResourceBuf->dwUsage = RESOURCEUSAGE_CONTAINER | RESOURCEUSAGE_RESERVED;
   
   ResourceBuf->lpLocalName = NULL;
   ResourceBuf->lpRemoteName = Provider;
   ResourceBuf->lpComment = NULL;
   ResourceBuf->lpProvider = Provider;
   return TRUE;
   
} // SetProvider


/*+-------------------------------------------------------------------------+
  | AllocEnumBuffer()
  |
  +-------------------------------------------------------------------------+*/
ENUM_REC *AllocEnumBuffer() {
   ENUM_REC *Buf;

   Buf = (ENUM_REC *) AllocMemory(sizeof(ENUM_REC));

   if (Buf) {
      // Init the record
      Buf->next = NULL;
      Buf->cEntries = 0;
      Buf->cbBuffer = 0;
      Buf->lpnr = NULL;
   }

   return Buf;

} // AllocEnumBuffer



/*+-------------------------------------------------------------------------+
  | EnumBufferBuild()
  |
  |    Uses WNetEnum to enumerate the resource.  WNetEnum is really brain-
  |    dead so we need to create a temporary holding array and then build
  |    up a finalized complete buffer in the end.  A linked list of inter-
  |    mediate buffer records is created first.
  |
  +-------------------------------------------------------------------------+*/
DWORD FAR PASCAL EnumBufferBuild(ENUM_REC **BufHead, int *NumBufs, NETRESOURCE ResourceBuf) {
   DWORD status = ERROR_NO_NETWORK;
   ENUM_REC *CurrBuf;
   DWORD dwResultEnum;
   HANDLE hEnum = NULL;
   DWORD cbBuffer = 16384;       // 16K default buffer size.
   DWORD cEntries = 0xFFFFFFFF;  // enumerate all possible entries
   ENUM_REC **lppEnumRec;
   LPNETRESOURCE lpnrLocal;

   status = WNetOpenEnum(RESOURCE_GLOBALNET, RESOURCETYPE_DISK, 0, &ResourceBuf, &hEnum);

   if (status == NO_ERROR) {

      *BufHead = NULL;
      lppEnumRec = BufHead;

      do {

         cbBuffer = 16384;             // 16K default buffer size
         cEntries = 0xFFFFFFFF;        // enumerate all possible entries

         // Allocate memory for NETRESOURCE structures.
         lpnrLocal =  (LPNETRESOURCE) AllocMemory(cbBuffer);

         if (lpnrLocal == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            break;
         }

         dwResultEnum = WNetEnumResource(hEnum, &cEntries, (LPVOID) lpnrLocal, &cbBuffer);

         if (dwResultEnum == NO_ERROR) {
            // Create a new Enum rec and link it to the chain
            *lppEnumRec = AllocEnumBuffer();

            if (*lppEnumRec == NULL) {
               status = ERROR_NOT_ENOUGH_MEMORY;
               break;
            }

            CurrBuf = *lppEnumRec;

            // Init for next loop through buffer
            lppEnumRec = &CurrBuf->next;

            // Put enumeration buffer in our Enum rec.
            CurrBuf->lpnr = lpnrLocal;
            CurrBuf->cEntries = cEntries;
            CurrBuf->cbBuffer = cbBuffer;
            (*NumBufs)++;

         } else { // Since this is not assigned in a rec we need to free it here.
            FreeMemory((HGLOBAL) lpnrLocal);

            if (dwResultEnum != ERROR_NO_MORE_ITEMS) {
               status = dwResultEnum;
               break;
            }
         }

      } while (dwResultEnum != ERROR_NO_MORE_ITEMS);

      status = WNetCloseEnum(hEnum);

   }

   return status;

} // EnumBufferBuild


/*+-------------------------------------------------------------------------+
  | UseAddPswd()
  |
  |   Attempts to make connections to \\szServer\admin$, asking for
  |   passwords if necessary.
  |
  | Returns TRUE if use was added,
  |         FALSE otherwise
  |
  +-------------------------------------------------------------------------+*/
BOOL UseAddPswd(HWND hwnd, LPTSTR UserName, LPTSTR lpszServer, LPTSTR lpszShare, LPTSTR Provider) {
    WORD nState;
    WORD fCancel;
    DLGPROC lpProc;
    NETRESOURCE nr;
    NET_API_STATUS retcode;
    LPTSTR lpPassword;
    static TCHAR szTmp[MAX_UNC_PATH+1];

    ServName = lpszServer;

    nr.dwScope = 0;
    nr.dwType = RESOURCETYPE_DISK;
    nr.dwDisplayType = 0;
    nr.dwUsage = 0;
    nr.lpProvider = NULL;

    nState = 1; // try default password
    lpPassword = NULL;
    BadPassword = FALSE;
    lstrcpy(szUserName, UserName);

    for(;;) {
        // Concatenate server and share
        wsprintf(szTmp, TEXT("%s\\%s"), lpszServer, lpszShare);

        // Fill in data structure
        nr.lpLocalName = NULL;
        nr.lpRemoteName = szTmp;
        nr.lpProvider = Provider;

        // Try to make the connection
        if (lstrlen(szUserName))
           retcode = WNetAddConnection2(&nr, lpPassword, szUserName, 0);
        else
           retcode = WNetAddConnection2(&nr, lpPassword, NULL, 0);

    switch(retcode) {
            case NERR_Success:
                lstrcpy(UserName, szUserName);
                return TRUE;

            case ERROR_INVALID_PASSWORD:
                BadPassword = TRUE;
                break;

            case ERROR_ACCESS_DENIED:
            case ERROR_NETWORK_ACCESS_DENIED:
        case ERROR_SESSION_CREDENTIAL_CONFLICT:
            case ERROR_NO_SUCH_USER:
            case ERROR_NO_MORE_ITEMS:
            case ERROR_LOGON_FAILURE:
                BadPassword = FALSE;
                break;

            case ERROR_BAD_NETPATH:
            case ERROR_BAD_NET_NAME:

            default:
                return FALSE;
        }

        // Get new password from user
        lpProc = (DLGPROC) MakeProcInstance(PasswordDlgProc, hInst);
        fCancel = !DialogBoxParam(hInst, TEXT("PasswordEnter"), hwnd, lpProc, 0);

        // Gamble call only once
        FreeProcInstance(lpProc);

    // Save...
        if(!fCancel) {
            if(nState) {
                nState = 2; // try specified password
                lpPassword = szPassword;
            } else {
                nState = 1; // try default password
                lpPassword = NULL;
            }
    } else {
        SetLastError(ERROR_SUCCESS); // just aborting...
        return FALSE;
    }
    }

} // UseAddPswd


/*+-------------------------------------------------------------------------+
  | PasswordDlgProc()
  |
  |   Gets a password from the user and copies it into the string pointed
  |   to by lParam.  This string must have room for at least (PWLEN + 1)
  |   characters.  Returns TRUE if OK is pressed, or FALSE if Cancel
  |
  +-------------------------------------------------------------------------+*/
LRESULT CALLBACK PasswordDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) {

   switch (msg) {
      case WM_INITDIALOG:
         CursorNormal();

         // Center the dialog over the application window
         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));

         SetDlgItemText(hDlg, IDC_SERVNAME, ServName);
         SendDlgItemMessage(hDlg, IDC_PASSWORD, EM_LIMITTEXT, PWLEN, 0L);
         SendDlgItemMessage(hDlg, IDC_USERNAME, EM_LIMITTEXT, MAX_USER_NAME_LEN, 0L);
         PostMessage(hDlg, WM_COMMAND, ID_INIT, 0L);
         break;

      case WM_COMMAND:
         switch(wParam) {
            case IDOK:
               CursorHourGlass();
               GetDlgItemText(hDlg, IDC_PASSWORD, szPassword, PWLEN+1);
               GetDlgItemText(hDlg, IDC_USERNAME, szUserName, MAX_USER_NAME_LEN+1);

               EndDialog(hDlg, TRUE);
               break;

            case IDCANCEL:
               CursorHourGlass();
               EndDialog(hDlg, FALSE);
               break;

            case ID_INIT:
               SendDlgItemMessage(hDlg, IDC_USERNAME, WM_SETTEXT, 0, (LPARAM) szUserName);

               if (BadPassword)
                  SetFocus(GetDlgItem(hDlg, IDC_PASSWORD));
               else {
                  SetFocus(GetDlgItem(hDlg, IDC_USERNAME));
                  SendDlgItemMessage(hDlg, IDC_USERNAME, EM_SETSEL, 0, (LPARAM) MAKELPARAM(0, -1) );
               }

               break;

            default:
               return FALSE;
         }
         break;

      default:
         return FALSE;
   }
   return TRUE;

} // PasswordDlgProc


/*+-------------------------------------------------------------------------+
  | NicePath()
  |
  +-------------------------------------------------------------------------+*/
LPTSTR NicePath(int Len, LPTSTR Path) {
   static TCHAR NewPath[MAX_PATH + 80];
   int eptr, fptr;

   // If the path fits then just return it
   if (lstrlen(Path) <= Len) {
      lstrcpy(NewPath, Path);
      return NewPath;
   }

   // The path doesn't fit, so need to reduce it down in size - to do this first try
   // to get the last part of the path looking for slash that starts it.
   eptr = fptr = 0;
   while (Path[eptr] != TEXT('\0'))
      eptr++;

   // back up before ending NULL also before any ending slash
   eptr--;
   while ((Path[eptr] == TEXT('\\')) && eptr > 0)
      eptr--;

   // now try to find beginning slash
   while ((Path[eptr] != TEXT('\\')) && eptr > 0)
      eptr--;

   // if at beginning of string then is just one name so copy all of it we can
   if (eptr == 0) {
      lstrcpyn(NewPath, Path, Len);
      return NewPath;
   }

   // check if the name after the last slash can all fit - also take into account
   // the "..." we are going to tack into the name
   fptr = lstrlen(Path) - eptr;
   fptr += 4;
   if (fptr >= Len) {
      lstrcpyn(NewPath, &Path[eptr], Len);
      return NewPath;
   }

   // We need to create a path shortening to the desired length by removing the mid
   // part of the path and replacing it with "..."
   fptr = Len - fptr;
   lstrcpyn(NewPath, Path, fptr);
   lstrcat(NewPath, TEXT("..."));
   lstrcat(NewPath, &Path[eptr]);
   return NewPath;

} // NicePath
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\ntnetapi.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _HNTNETAPI_
#define _HNTNETAPI_

#ifdef __cplusplus
extern "C"{
#endif

#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif

DWORD NTSAMConnect(LPTSTR FileServer, LPTSTR DomainName);
void NTSAMClose();
DWORD NTSAMParmsSet(LPTSTR ObjectName, FPNW_INFO fpnw, LPTSTR Password, BOOL ForcePasswordChange);
DWORD NTObjectIDGet( LPTSTR ObjectName );

DWORD NTShareAdd(LPTSTR ShareName, LPTSTR Path);
DWORD FPNWShareAdd(LPTSTR ShareName, LPTSTR Path);
void NTUseDel(LPTSTR ServerName);

DWORD NTServerEnum(LPTSTR Container, SERVER_BROWSE_LIST **ServList);
DWORD NTDomainEnum(SERVER_BROWSE_LIST **lpServList);
DWORD NTGroupsEnum(GROUP_LIST **lpGroupList);
DWORD NTUsersEnum(USER_LIST **lpUserList);

DWORD NTGroupSave(LPTSTR Name);
DWORD NTUserInfoSave(NT_USER_INFO *NT_UInfo, PFPNW_INFO fpnw);
void NTServerInfoReset(HWND hWnd, DEST_SERVER_BUFFER *DServ, BOOL ResetDomain);
DWORD NTUserInfoSet(NT_USER_INFO *NT_UInfo, PFPNW_INFO fpnw);
DWORD NTGroupUserAdd(LPTSTR GroupName, LPTSTR UserName, BOOL Local);

void NTUserRecInit(LPTSTR UserName, NT_USER_INFO *NT_UInfo);
void NTUserRecLog(NT_USER_INFO NT_UInfo);

DWORD NTSharesEnum(SHARE_LIST **lpShares, DRIVE_LIST *Drives);

void NTUseDel(LPTSTR ServerName);
void NTConnListDeleteAll();

DWORD NTServerSet(LPTSTR FileServer);
void NTServerInfoSet(HWND hWnd, LPTSTR ServerName, DEST_SERVER_BUFFER *DServ);
BOOL NTServerValidate(HWND hWnd, LPTSTR ServerName);
void NTServerGetInfo(LPTSTR ServerName);
void NTDomainSynch(DEST_SERVER_BUFFER *DServ);
BOOL NTDomainInSynch(LPTSTR Server);

// #define these so they can be changed easily. these macros
// should be used to free the memory allocated by the routines in
// this module.
#define NW_ALLOC(x) ((LPBYTE)LocalAlloc(LPTR,x))
#define NW_FREE(p)  ((void)LocalFree((HLOCAL)p))


NTSTATUS NwAddRight( PSECURITY_DESCRIPTOR pSD, PSID pSid, ACCESS_MASK AccessMask, PSECURITY_DESCRIPTOR *ppNewSD ) ;
NTSTATUS CreateNewSecurityDescriptor( PSECURITY_DESCRIPTOR *ppNewSD, PSECURITY_DESCRIPTOR pSD, PACL pAcl) ;

typedef struct _TRUSTED_DOMAIN_LIST {
   ULONG Count;
   TCHAR Name[][MAX_DOMAIN_NAME_LEN + 1];
} TRUSTED_DOMAIN_LIST;


BOOL NTDomainGet(LPTSTR ServerName, LPTSTR Domain);
BOOL IsNTAS(LPTSTR Server);
void NTTrustedDomainsEnum(LPTSTR ServerName, TRUSTED_DOMAIN_LIST **pTList);
DOMAIN_BUFFER *NTTrustedDomainSet(HWND hWnd, LPTSTR Server, LPTSTR TrustedDomain);

SID *NTSIDGet(LPTSTR ServerName, LPTSTR pUserName);
BOOL NTFile_AccessRightsAdd(LPTSTR ServerName, LPTSTR pUserName, LPTSTR pFileName, ACCESS_MASK AccessMask, BOOL Dir);
LPTSTR NTAccessLog(ACCESS_MASK AccessMask);

void NTUserDefaultsGet(NT_DEFAULTS **UDefaults);
DWORD NTUserDefaultsSet(NT_DEFAULTS UDefaults);
void NTUserDefaultsLog(NT_DEFAULTS UDefaults);
BOOL IsFPNW(LPTSTR ServerName);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\ntsecapi.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _NTSECAPI_
#define _NTSECAPI_

#ifdef __cplusplus
extern "C"{
#endif

typedef struct _TRUSTED_DOMAIN_LIST {
   ULONG Count;
   TCHAR Name[][MAX_DOMAIN_NAME_LEN + 1];
} TRUSTED_DOMAIN_LIST;


BOOL NTDomainGet(LPTSTR ServerName, LPTSTR Domain);
BOOL IsNTAS(LPTSTR Server);
void NTTrustedDomainsEnum(LPTSTR ServerName, TRUSTED_DOMAIN_LIST **pTList);
SID *NTSIDGet(LPTSTR ServerName, LPTSTR pUserName);
BOOL NTFile_AccessRightsAdd(LPTSTR ServerName, LPTSTR pUserName, LPTSTR pFileName, ULONG Rights, BOOL Dir);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\ntnetapi.c ===
/*++

Copyright (c) 1993-1995  Microsoft Corporation

Module Name:

   NTNetaAPI.c

Abstract:


Author:

    Arthur Hanson (arth) 16-Jun-1994

Revision History:

--*/


#include "globals.h"

#include <ntlsa.h>
#include <ntsam.h>
#include <ntddnwfs.h>
#include <align.h>

#include <math.h>
#include "convapi.h"
#include "ntnetapi.h"
#include "nwnetapi.h"
#include "loghours.h"
#include "usrprop.h"
#include "crypt.h"
// #include <nwstruct.h>
#include <nwconv.h>
#include "fpnwapi.h"

#ifdef DEBUG
int ErrorBoxRetry(LPTSTR szFormat, ...);
#endif

void ErrorIt(LPTSTR szFormat, ...);
NTSTATUS ACEAdd( PSECURITY_DESCRIPTOR pSD, PSID pSid, ACCESS_MASK AccessMask, ULONG AceFlags, PSECURITY_DESCRIPTOR *ppNewSD );

static LPTSTR LocalName = NULL;

// +3 for leading slashes and ending NULL
static TCHAR CachedServer[MAX_SERVER_NAME_LEN+3];
static BOOL LocalMachine = FALSE;

// keep this around so we don't have to keep re-do query
static LPSERVER_INFO_101 ServInfo = NULL;
// #define TYPE_DOMAIN SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL | SV_TYPE_DOMAIN_MEMBER
#define TYPE_DOMAIN SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL

static SAM_HANDLE SAMHandle = (SAM_HANDLE) 0;
static SAM_HANDLE DomainHandle = (SAM_HANDLE) 0;
static PSID DomainID;
static WCHAR UserParms[1024];

#define NCP_LSA_SECRET_KEY     L"G$MNSEncryptionKey"
#define NCP_LSA_SECRET_LENGTH  USER_SESSION_KEY_LENGTH

static char Secret[USER_SESSION_KEY_LENGTH];
static HANDLE FPNWLib = NULL;
static DWORD (FAR * NWVolumeAdd) (LPWSTR, DWORD, PNWVOLUMEINFO) = NULL;

//
//  This bit is set when the server is running on a NTAS machine or
//  the object is from a trusted domain.  NWConv is always on NTAS
//

#define BINDLIB_REMOTE_DOMAIN_BIAS              0x10000000

//
// misc macros that are useful
//
#define SWAPWORD(w)         ((WORD)((w & 0xFF) << 8)|(WORD)(w >> 8))
#define SWAPLONG(l)         MAKELONG(SWAPWORD(HIWORD(l)),SWAPWORD(LOWORD(l)))


typedef struct _NT_CONN_BUFFER {
   struct _NT_CONN_BUFFER *next;
   struct _NT_CONN_BUFFER *prev;

   LPTSTR Name;
} NT_CONN_BUFFER;

static NT_CONN_BUFFER *NTConnListStart = NULL;
static NT_CONN_BUFFER *NTConnListEnd = NULL;

HANDLE FpnwHandle = NULL;
static FARPROC pFpnwVolumeEnum = NULL;
static FARPROC pFpnwApiBufferFree = NULL;


/////////////////////////////////////////////////////////////////////////
LPSTR 
FPNWSecretGet(
   LPTSTR ServerName
   )

/*++

Routine Description:

   Checks the given machine for the FPNW secret.

Arguments:


Return Value:


--*/

{
    SECURITY_QUALITY_OF_SERVICE QualityOfService;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    LSA_HANDLE                  PolicyHandle;
    LSA_HANDLE                  SecretHandle;
    NTSTATUS                    Status;
    UNICODE_STRING              UnicodeSecretName;
    PUNICODE_STRING             punicodeCurrentValue;
    PUSER_INFO_2                pUserInfo = NULL;

    static TCHAR LocServer[MAX_SERVER_NAME_LEN+3];
    UNICODE_STRING UnicodeServerName;
    BOOL ret = TRUE;

    memset(Secret, 0, USER_SESSION_KEY_LENGTH);
    wsprintf(LocServer, TEXT("\\\\%s"), ServerName);

    //  Verify & init secret name.
    RtlInitUnicodeString( &UnicodeSecretName, NCP_LSA_SECRET_KEY );
    RtlInitUnicodeString( &UnicodeServerName, LocServer);

    //  Prepare to open the policy object.
    QualityOfService.Length              = sizeof(SECURITY_QUALITY_OF_SERVICE);
    QualityOfService.ImpersonationLevel  = SecurityImpersonation;
    QualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    QualityOfService.EffectiveOnly       = FALSE;

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0L, NULL, NULL );
    ObjectAttributes.SecurityQualityOfService = &QualityOfService;

    //  Open a handle to the target machine's LSA policy.
    Status = LsaOpenPolicy( &UnicodeServerName, &ObjectAttributes, 0, &PolicyHandle );

    if( !NT_SUCCESS( Status ) ) {
        ret = FALSE;
        goto FatalExit0;
    }

    //  Open the secret object.
    Status = LsaOpenSecret( PolicyHandle, &UnicodeSecretName, SECRET_QUERY_VALUE, &SecretHandle );

    if( !NT_SUCCESS( Status ) ) {
        ret = FALSE;
        goto FatalExit1;
    }

    //  Query the secret.
    Status = LsaQuerySecret( SecretHandle, &punicodeCurrentValue, NULL, NULL, NULL );

    if( !NT_SUCCESS( Status ) ) {
        ret = FALSE;
        goto FatalExit2;
    }

    if (punicodeCurrentValue != NULL) {
       memcpy(Secret, punicodeCurrentValue->Buffer, USER_SESSION_KEY_LENGTH);
       LsaFreeMemory( (PVOID)punicodeCurrentValue );
    }

FatalExit2:
    LsaClose( SecretHandle );

FatalExit1:
    LsaClose( PolicyHandle );

FatalExit0:

    if (ret)
      return Secret;
    else
      return NULL;

} // FPNWSecretGet


/////////////////////////////////////////////////////////////////////////
NTSTATUS 
SetGraceLoginAllowed(
   USHORT ushGraceLoginAllowed
   )

/*++

Routine Description:

    Store Grace Login Allowed in UserParms.

Arguments:


Return Value:


--*/

{
    NTSTATUS err = NERR_Success;
    USHORT ushTemp = ushGraceLoginAllowed;
    UNICODE_STRING uniGraceLoginAllowed;
    LPWSTR  lpNewUserParms = NULL;
    BOOL fUpdate;

    uniGraceLoginAllowed.Buffer = &ushTemp;
    uniGraceLoginAllowed.Length = 2;
    uniGraceLoginAllowed.MaximumLength = 2;

    err = SetUserProperty (UserParms, GRACELOGINALLOWED, uniGraceLoginAllowed, USER_PROPERTY_TYPE_ITEM, &lpNewUserParms, &fUpdate);
    if ((err == NERR_Success) && (lpNewUserParms != NULL)) {
       if (fUpdate)
          lstrcpyW(UserParms, lpNewUserParms);

       LocalFree(lpNewUserParms);
    }

    return err;
} // SetGraceLoginAllowed


/////////////////////////////////////////////////////////////////////////
NTSTATUS 
SetGraceLoginRemainingTimes(
   USHORT ushGraceLoginRemainingTimes
   )

/*++

Routine Description:

    Store Grace Login Remaining Times in UserParms. if ushGraceLogin is 0, 
    "GraceLogin" field will be deleted from UserParms.

Arguments:


Return Value:


--*/

{
    NTSTATUS err = NERR_Success;
    USHORT ushTemp = ushGraceLoginRemainingTimes;
    UNICODE_STRING uniGraceLoginRemainingTimes;
    LPWSTR  lpNewUserParms = NULL;
    BOOL fUpdate;

    uniGraceLoginRemainingTimes.Buffer = &ushTemp;
    uniGraceLoginRemainingTimes.Length = 2;
    uniGraceLoginRemainingTimes.MaximumLength = 2;

    err = SetUserProperty (UserParms, GRACELOGINREMAINING, uniGraceLoginRemainingTimes, USER_PROPERTY_TYPE_ITEM, &lpNewUserParms, &fUpdate);
    if ((err == NERR_Success) && (lpNewUserParms != NULL)) {
       if (fUpdate)
          lstrcpyW(UserParms, lpNewUserParms);

       LocalFree(lpNewUserParms);
    }

    return err;
} // SetGraceLoginRemainingTimes


/////////////////////////////////////////////////////////////////////////
NTSTATUS 
SetMaxConnections(
   USHORT ushMaxConnections
   )

/*++

Routine Description:

    Store Maximum Concurret Connections in UserParms.  If ushMaxConnections
    is 0xffff or 0, "MaxConnections" field will be deleted from UserParms, 
    otherwise the value is stored.

Arguments:


Return Value:


--*/

{
    NTSTATUS err = NERR_Success;
    USHORT ushTemp = ushMaxConnections;
    UNICODE_STRING uniMaxConnections;
    LPWSTR  lpNewUserParms = NULL;
    BOOL fUpdate;

    uniMaxConnections.Buffer = &ushMaxConnections;
    uniMaxConnections.Length = 2;
    uniMaxConnections.MaximumLength = 2;

    err = SetUserProperty (UserParms, MAXCONNECTIONS, uniMaxConnections, USER_PROPERTY_TYPE_ITEM, &lpNewUserParms, &fUpdate);
    if ((err == NERR_Success) && (lpNewUserParms != NULL)) {
       if (fUpdate)
          lstrcpyW(UserParms, lpNewUserParms);

       LocalFree(lpNewUserParms);
    }

    return err;
} // SetMaxConnections


/////////////////////////////////////////////////////////////////////////
NTSTATUS 
SetNWPasswordAge(
   BOOL fExpired
   )

/*++

Routine Description:

    If fExpired is TRUE, set the NWPasswordSet field to be all fs. 
    otherwise set it to be the current time.

Arguments:


Return Value:


--*/

{
    NTSTATUS err = NERR_Success;
    LARGE_INTEGER currentTime;
    LPWSTR  lpNewUserParms = NULL;
    UNICODE_STRING uniPasswordAge;
    BOOL fUpdate;

    if (fExpired) {
        currentTime.HighPart = 0xffffffff;
        currentTime.LowPart = 0xffffffff;
    } else
        NtQuerySystemTime (&currentTime);

    uniPasswordAge.Buffer = (PWCHAR) &currentTime;
    uniPasswordAge.Length = sizeof (LARGE_INTEGER);
    uniPasswordAge.MaximumLength = sizeof (LARGE_INTEGER);

    err = SetUserProperty (UserParms, NWTIMEPASSWORDSET, uniPasswordAge, USER_PROPERTY_TYPE_ITEM, &lpNewUserParms, &fUpdate);
    if ((err == NERR_Success) &&(lpNewUserParms != NULL)) {
       if (fUpdate)
          lstrcpyW(UserParms, lpNewUserParms);

       LocalFree(lpNewUserParms);
    }

    return err;
} // SetNWPasswordAge


/////////////////////////////////////////////////////////////////////////
NTSTATUS 
SetNWPassword(
   DWORD dwUserId, 
   const TCHAR *pchNWPassword,
   BOOL ForcePasswordChange
   )

/*++

Routine Description:

    Set "NWPassword" field is fIsNetWareUser is TRUE, Otherwise, delete 
    the field from UserParms.

Arguments:


Return Value:


--*/

{
    NTSTATUS err;
    TCHAR pchEncryptedNWPassword[NWENCRYPTEDPASSWORDLENGTH + 1];
    LPWSTR  lpNewUserParms = NULL;
    BOOL fUpdate;
    UNICODE_STRING uniPassword;

#ifdef DEBUG
   dprintf(TEXT("Set NetWare password: [%s]\r\n"), pchNWPassword);
#endif

    do {
        // Now munge the UserID to the format required by ReturnNetwareForm...
        dwUserId |= BINDLIB_REMOTE_DOMAIN_BIAS;
        err = ReturnNetwareForm( Secret, dwUserId, pchNWPassword, (UCHAR *) pchEncryptedNWPassword );

        if ( err != NERR_Success )
            break;

        uniPassword.Buffer = pchEncryptedNWPassword;
        uniPassword.Length = NWENCRYPTEDPASSWORDLENGTH * sizeof (WCHAR);
        uniPassword.MaximumLength = NWENCRYPTEDPASSWORDLENGTH * sizeof (WCHAR);

        err = SetUserProperty (UserParms, NWPASSWORD, uniPassword, USER_PROPERTY_TYPE_ITEM, &lpNewUserParms, &fUpdate);
        if ((err == NERR_Success) && (lpNewUserParms != NULL)) {
           if (fUpdate)
              lstrcpyW(UserParms, lpNewUserParms);

           LocalFree(lpNewUserParms);

           if ((err = SetNWPasswordAge (ForcePasswordChange)) != NERR_Success )
              break;
        }
    } while (FALSE);

    return err;
} // SetNWPassword


/////////////////////////////////////////////////////////////////////////
NTSTATUS 
SetNWWorkstations(
   const TCHAR * pchNWWorkstations
   )

/*++

Routine Description:

    Store NetWare allowed workstation addresses to UserParms.  If 
    pchNWWorkstations is NULL, this function will delete "NWLgonFrom" 
    field from UserParms.

Arguments:


Return Value:


--*/

{
    NTSTATUS err = NERR_Success;
    UNICODE_STRING uniNWWorkstations;
    CHAR * pchTemp = NULL;
    LPWSTR  lpNewUserParms = NULL;
    BOOL fUpdate;

    if (pchNWWorkstations == NULL) {
        uniNWWorkstations.Buffer = NULL;
        uniNWWorkstations.Length =  0;
        uniNWWorkstations.MaximumLength = 0;
    } else {
        BOOL fDummy;
        INT nStringLength = lstrlen(pchNWWorkstations) + 1;
        pchTemp = (CHAR *) LocalAlloc (LPTR, nStringLength);

        if ( pchTemp == NULL )
            err = ERROR_NOT_ENOUGH_MEMORY;

        if ( err == NERR_Success && !WideCharToMultiByte (CP_ACP, 0, pchNWWorkstations, nStringLength, pchTemp, nStringLength, NULL, &fDummy))
            err = GetLastError();

        if ( err == NERR_Success ) {
            uniNWWorkstations.Buffer = (WCHAR *) pchTemp;
            uniNWWorkstations.Length =  (USHORT) nStringLength;
            uniNWWorkstations.MaximumLength = (USHORT) nStringLength;
        }
    }

    err = err? err: SetUserProperty (UserParms, NWLOGONFROM, uniNWWorkstations, USER_PROPERTY_TYPE_ITEM, &lpNewUserParms, &fUpdate);

    if ((err == NERR_Success) && (lpNewUserParms != NULL)) {
       if (fUpdate)
          lstrcpyW(UserParms, lpNewUserParms);

       LocalFree(lpNewUserParms);
    }

    if (pchTemp != NULL)
        LocalFree (pchTemp);

    return err;
} // SetNWWorkstations


/////////////////////////////////////////////////////////////////////////
NTSTATUS SetNWHomeDir(
   const TCHAR * pchNWHomeDir
   )

/*++

Routine Description:

   Store NetWare Home Directory to UserParms If pchNWWorkstations is NULL, 
   this function will delete "NWLgonFrom" field from UserParms.

Arguments:


Return Value:


--*/

{
    NTSTATUS err = NERR_Success;
    UNICODE_STRING uniNWHomeDir;
    CHAR * pchTemp = NULL;
    LPWSTR  lpNewUserParms = NULL;
    BOOL fUpdate;

    if (pchNWHomeDir == NULL) {
        uniNWHomeDir.Buffer = NULL;
        uniNWHomeDir.Length =  0;
        uniNWHomeDir.MaximumLength = 0;
    } else {
        BOOL fDummy;
        INT  nStringLength = lstrlen(pchNWHomeDir) + 1;
        pchTemp = (CHAR *) LocalAlloc (LPTR, nStringLength);

        if ( pchTemp == NULL )
            err = ERROR_NOT_ENOUGH_MEMORY;

        if ( err == NERR_Success && !WideCharToMultiByte (CP_ACP, 0, pchNWHomeDir, nStringLength, pchTemp, nStringLength, NULL, &fDummy))
            err = GetLastError();

        if ( err == NERR_Success ) {
            uniNWHomeDir.Buffer = (WCHAR *) pchTemp;
            uniNWHomeDir.Length =  (USHORT) nStringLength;
            uniNWHomeDir.MaximumLength = (USHORT) nStringLength;
        }
    }

    err = err? err : SetUserProperty (UserParms, NWHOMEDIR, uniNWHomeDir, USER_PROPERTY_TYPE_ITEM, &lpNewUserParms, &fUpdate);

    if ((err == NERR_Success) && (lpNewUserParms != NULL)) {
       if (fUpdate)
          lstrcpyW(UserParms, lpNewUserParms);

       LocalFree(lpNewUserParms);
    }

    if (pchTemp != NULL)
        LocalFree (pchTemp);

    return err;
} // SetNWHomeDir


/////////////////////////////////////////////////////////////////////////
DWORD 
NTObjectIDGet(
   LPTSTR ObjectName 
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS       status;
   UNICODE_STRING UniNewObjectName;
   PULONG         pRids = NULL;
   PSID_NAME_USE  pSidNameUse = NULL;
   ULONG          ObjectID = 0;

   RtlInitUnicodeString(&UniNewObjectName, ObjectName);

   status = SamLookupNamesInDomain(DomainHandle,
                1,
                &UniNewObjectName,
                &pRids,
                &pSidNameUse);

   if ((status == STATUS_SUCCESS) && (pRids != NULL) && (pSidNameUse != NULL)) {
      // Found the name - so copy and free SAM garbage
      ObjectID = pRids[0];
      ObjectID |= BINDLIB_REMOTE_DOMAIN_BIAS;

      SamFreeMemory(pRids);
      SamFreeMemory(pSidNameUse);
   }

   return ObjectID;
} // NTObjectIDGet


/////////////////////////////////////////////////////////////////////////
DWORD 
NTSAMParmsSet(
   LPTSTR ObjectName, 
   FPNW_INFO fpnw, 
   LPTSTR Password,
   BOOL ForcePasswordChange
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS       status;
   UNICODE_STRING UniNewObjectName;
   PULONG         pRids = NULL;
   PSID_NAME_USE  pSidNameUse = NULL;
   ULONG          ObjectID;
   SID_NAME_USE   SidNameUse;
   SAM_HANDLE     Handle = (SAM_HANDLE) 0;
   PUSER_PARAMETERS_INFORMATION UserParmInfo = NULL;
   USER_PARAMETERS_INFORMATION NewUserParmInfo;
   LPWSTR         lpNewUserParms = NULL;

   RtlInitUnicodeString(&UniNewObjectName, ObjectName);

   status = SamLookupNamesInDomain(DomainHandle,
                1,
                &UniNewObjectName,
                &pRids,
                &pSidNameUse);

   if ((status == STATUS_SUCCESS) && (pRids != NULL) && (pSidNameUse != NULL)) {
      // Found the name - so copy and free SAM garbage
      ObjectID = pRids[0];
      SidNameUse = pSidNameUse[0];

      SamFreeMemory(pRids);
      SamFreeMemory(pSidNameUse);

      status = SamOpenUser(DomainHandle,
                STANDARD_RIGHTS_READ        |
                STANDARD_RIGHTS_WRITE       |
                USER_ALL_ACCESS,
                ObjectID,
                &Handle);


      // Now get the user parms
      if (status == STATUS_SUCCESS)
         status = SamQueryInformationUser(Handle, UserParametersInformation, (PVOID *) &UserParmInfo);

      memset(UserParms, 0, sizeof(UserParms));
      if ((status == STATUS_SUCCESS) && (UserParmInfo != NULL)) {
         memcpy(UserParms, UserParmInfo->Parameters.Buffer, UserParmInfo->Parameters.Length * sizeof(WCHAR));
         SamFreeMemory(UserParmInfo);

          if ( 
               ((status = SetNWPassword (ObjectID, Password, ForcePasswordChange)) == NERR_Success) &&
               ((status = SetMaxConnections (fpnw.MaxConnections)) == NERR_Success) &&
               ((status = SetGraceLoginAllowed (fpnw.GraceLoginAllowed)) == NERR_Success) &&
               ((status = SetGraceLoginRemainingTimes (fpnw.GraceLoginRemaining)) == NERR_Success) &&
               ((status = SetNWWorkstations (fpnw.LoginFrom)) == NERR_Success) &&
               ((status = SetNWHomeDir (fpnw.HomeDir)) == NERR_Success) )
          {
             RtlInitUnicodeString(&NewUserParmInfo.Parameters, UserParms);
             status = SamSetInformationUser(Handle, UserParametersInformation, (PVOID) &NewUserParmInfo);
          }

      }
   }

   if (Handle != (SAM_HANDLE) 0)
      SamCloseHandle(Handle);

   return 0;
} // NTSAMParmsSet


/////////////////////////////////////////////////////////////////////////
DWORD 
NTSAMConnect(
   LPTSTR ServerName, 
   LPTSTR DomainName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS status;
   OBJECT_ATTRIBUTES object_attrib;
   UNICODE_STRING UniDomainName;
   UNICODE_STRING UniServerName;

   // 
   // Do all the garbage for connecting to SAM
   //
   RtlInitUnicodeString(&UniServerName, ServerName);
   RtlInitUnicodeString(&UniDomainName, DomainName);
   InitializeObjectAttributes(&object_attrib, NULL, 0, NULL, NULL);
   status = SamConnect(&UniServerName, &SAMHandle, SAM_SERVER_ALL_ACCESS, &object_attrib);

   if (status == STATUS_SUCCESS)
      status = SamLookupDomainInSamServer(SAMHandle, &UniDomainName, &DomainID);

   if (status == STATUS_SUCCESS)
      status = SamOpenDomain(SAMHandle, DOMAIN_ALL_ACCESS, DomainID, &DomainHandle);

   FPNWSecretGet(ServerName);
   return (DWORD) status;
} // NTSAMConnect


/////////////////////////////////////////////////////////////////////////
VOID 
NTSAMClose()

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   if (DomainHandle != (SAM_HANDLE) 0)
      SamCloseHandle(DomainHandle);

   if (DomainID != (PSID) 0)
      SamFreeMemory(DomainID);

   if (SAMHandle != (SAM_HANDLE) 0)
      SamCloseHandle(SAMHandle);

   SAMHandle = (SAM_HANDLE) 0;
   DomainHandle = (SAM_HANDLE) 0;
   DomainID = (PSID) 0;

} // NTSAMClose


/////////////////////////////////////////////////////////////////////////
DWORD 
NTServerSet(
   LPTSTR ServerName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

   // Fixup the destination server name
   lstrcpy(CachedServer, TEXT("\\\\"));
   lstrcat(CachedServer, ServerName);

   if (!LocalName)
      GetLocalName(&LocalName);

   if (lstrcmpi(ServerName, LocalName) == 0)
      LocalMachine = TRUE;
   else
      LocalMachine = FALSE;

   if (FpnwHandle == NULL)
      FpnwHandle = LoadLibrary(TEXT("FPNWCLNT.DLL"));

   if ((FpnwHandle != NULL) && (pFpnwVolumeEnum == NULL)) {
      pFpnwVolumeEnum = GetProcAddress(FpnwHandle, ("FpnwVolumeEnum"));
      pFpnwApiBufferFree = GetProcAddress(FpnwHandle, ("FpnwApiBufferFree"));
   }

   return (0);

} // NTServerSet


/////////////////////////////////////////////////////////////////////////
DWORD 
NTServerFree()

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   LocalMachine = FALSE;
   lstrcpy(CachedServer, TEXT(""));
   return (0);

} // NTServerFree


/////////////////////////////////////////////////////////////////////////
DWORD 
FPNWShareAdd(
   LPTSTR ShareName, 
   LPTSTR Path
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NET_API_STATUS Status = 0;
   NWVOLUMEINFO NWVol;

   if (FPNWLib == NULL)
      FPNWLib = LoadLibrary(TEXT("FPNWCLNT.DLL"));

   if (FPNWLib == NULL)
      return 1;

   if (NWVolumeAdd == NULL)
      NWVolumeAdd = (DWORD (FAR * ) (LPWSTR, DWORD, PNWVOLUMEINFO)) GetProcAddress(FPNWLib, "NwVolumeAdd");

   NWVol.lpVolumeName = AllocMemory((lstrlen(ShareName) + 1) * sizeof(TCHAR));
   NWVol.lpPath = AllocMemory((lstrlen(Path) + 1) * sizeof(TCHAR));
   if ((NWVol.lpVolumeName == NULL) || (NWVol.lpPath == NULL))
      return 1;

   lstrcpy(NWVol.lpVolumeName, ShareName);
   NWVol.dwType = NWVOL_TYPE_DISKTREE;
   NWVol.dwMaxUses = NWVOL_MAX_USES_UNLIMITED;
   NWVol.dwCurrentUses = 0;
   lstrcpy(NWVol.lpPath, Path);

   if (LocalMachine)
      Status = NWVolumeAdd(NULL, 1, &NWVol);
   else
      Status = NWVolumeAdd(CachedServer, 1, &NWVol);

   return Status;

} // FPNWShareAdd


/////////////////////////////////////////////////////////////////////////
DWORD 
NTShareAdd(
   LPTSTR ShareName, 
   LPTSTR Path
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NET_API_STATUS Status = 0;
   SHARE_INFO_2 shi2;
   DWORD parmerr;

   memset(&shi2, 0, sizeof(SHARE_INFO_2));

   shi2.shi2_netname = ShareName;
   shi2.shi2_type = STYPE_DISKTREE;
   shi2.shi2_max_uses = (DWORD) 0xffffffff;
   shi2.shi2_path = Path;

   if (LocalMachine)
      Status = NetShareAdd(NULL, 2, (LPBYTE) &shi2, &parmerr);
   else
      Status = NetShareAdd(CachedServer, 2, (LPBYTE) &shi2, &parmerr);

   return Status;

} // NTShareAdd


/////////////////////////////////////////////////////////////////////////
DWORD 
NTUsersEnum(
   USER_LIST **lpUserList
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   LPUSER_INFO_0 buffer = NULL;
   NET_API_STATUS Status = 0;
   DWORD prefmaxlength = 0xffffffff;
   DWORD totalentries = 0;
   DWORD entriesread = 0;
   DWORD resumehandle = 0;
   DWORD i;
   USER_LIST *UserList = NULL;
   USER_BUFFER *UserBuffer = NULL;

   if (LocalMachine)
      Status = NetUserEnum(NULL, 0, 0, (LPBYTE *) &buffer, prefmaxlength, &entriesread, &totalentries, &resumehandle);
   else
      Status = NetUserEnum(CachedServer, 0, 0, (LPBYTE *) &buffer, prefmaxlength, &entriesread, &totalentries, &resumehandle);

   if (Status == NO_ERROR) {

      UserList = AllocMemory(sizeof(USER_LIST) + (sizeof(USER_BUFFER) * entriesread));

      if (!UserList) {
         Status = ERROR_NOT_ENOUGH_MEMORY;
      } else {
         UserBuffer = UserList->UserBuffer;

         for (i = 0; i < entriesread; i++) {
            lstrcpy(UserBuffer[i].Name, buffer[i].usri0_name);
            lstrcpy(UserBuffer[i].NewName, buffer[i].usri0_name);
         }

         qsort((void *) UserBuffer, (size_t) entriesread, sizeof(USER_BUFFER), UserListCompare);
      }
   }

   if (buffer != NULL)
      NetApiBufferFree((LPVOID) buffer);

   if (UserList != NULL)
      UserList->Count = entriesread;

   *lpUserList = UserList;
   return Status;

} // NTUsersEnum


/////////////////////////////////////////////////////////////////////////
DWORD 
NTGroupsEnum(
   GROUP_LIST **lpGroupList
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   LPGROUP_INFO_0 buffer = NULL;
   NET_API_STATUS Status = 0;
   DWORD prefmaxlength = 0xffffffff;
   DWORD totalentries = 0;
   DWORD entriesread = 0;
   DWORD_PTR resumehandle = 0;
   DWORD i;
   GROUP_LIST *GroupList = NULL;
   GROUP_BUFFER *GroupBuffer = NULL;

   if (LocalMachine)
      Status = NetGroupEnum(NULL, 0, (LPBYTE *) &buffer, prefmaxlength, &entriesread, &totalentries, &resumehandle);
   else
      Status = NetGroupEnum(CachedServer, 0, (LPBYTE *) &buffer, prefmaxlength, &entriesread, &totalentries, &resumehandle);

   if (Status == NO_ERROR) {

      GroupList = AllocMemory(sizeof(GROUP_LIST) + (sizeof(GROUP_BUFFER) * entriesread));

      if (!GroupList) {
         Status = ERROR_NOT_ENOUGH_MEMORY;
      } else {
         GroupBuffer = GroupList->GroupBuffer;

         for (i = 0; i < entriesread; i++) {
            lstrcpy(GroupBuffer[i].Name, buffer[i].grpi0_name);
            lstrcpy(GroupBuffer[i].NewName, buffer[i].grpi0_name);
         }
      }
   }

   if (buffer != NULL)
      NetApiBufferFree((LPVOID) buffer);

   if (GroupList != NULL)
      GroupList->Count = entriesread;

   *lpGroupList = GroupList;
   return Status;

} // NTGroupsEnum


/////////////////////////////////////////////////////////////////////////
DWORD 
NTDomainEnum(
   SERVER_BROWSE_LIST **lpServList
   )

/*++

Routine Description:

    Enumerates all NT servers in a given domain.

Arguments:


Return Value:


--*/

{
   LPSERVER_INFO_101 buffer = NULL;
   NET_API_STATUS Status = 0;
   DWORD prefmaxlength = 0xffffffff;
   DWORD totalentries = 0;
   DWORD entriesread = 0;
   DWORD resumehandle = 0;
   DWORD i;
   BOOL Container = FALSE;
   SERVER_BROWSE_LIST *ServList = NULL;
   SERVER_BROWSE_BUFFER *SList;

   Status = NetServerEnum(NULL, 101, (LPBYTE *) &buffer, prefmaxlength, &entriesread, &totalentries, SV_TYPE_DOMAIN_ENUM, NULL, &resumehandle);

   if (Status == NO_ERROR) {

      ServList = AllocMemory(sizeof(SERVER_BROWSE_LIST) + (sizeof(SERVER_BROWSE_BUFFER) * entriesread));

      if (!ServList) {
         Status = ERROR_NOT_ENOUGH_MEMORY;
      } else {
         ServList->Count = entriesread;
         SList = (SERVER_BROWSE_BUFFER *) &ServList->SList;

         for (i = 0; i < entriesread; i++) {
            lstrcpy(SList[i].Name, buffer[i].sv101_name);
            lstrcpy(SList[i].Description, buffer[i].sv101_comment);
            SList[i].Container = FALSE;
            SList[i].child = NULL;
         }
      }
   }

   if (buffer != NULL)
      NetApiBufferFree((LPVOID) buffer);

   *lpServList = ServList;
   return Status;

} // NTDomainEnum


/////////////////////////////////////////////////////////////////////////
DWORD 
NTServerEnum(
   LPTSTR szContainer, 
   SERVER_BROWSE_LIST **lpServList
   )

/*++

Routine Description:

    Enumerates all NT servers in a given domain.

Arguments:


Return Value:


--*/

{
   LPSERVER_INFO_101 buffer = NULL;
   NET_API_STATUS Status = 0;
   DWORD prefmaxlength = 0xffffffff;
   DWORD totalentries = 0;
   DWORD entriesread = 0;
   DWORD resumehandle = 0;
   DWORD i;
   BOOL Container = FALSE;
   SERVER_BROWSE_LIST *ServList = NULL;
   SERVER_BROWSE_BUFFER *SList;

   if (((szContainer != NULL) && (lstrlen(szContainer))))
      Container = TRUE;

   if (Container)
      Status = NetServerEnum(NULL, 101, (LPBYTE *) &buffer, prefmaxlength, &entriesread, &totalentries, SV_TYPE_NT, szContainer, &resumehandle);
   else
      Status = NetServerEnum(NULL, 101, (LPBYTE *) &buffer, prefmaxlength, &entriesread, &totalentries, SV_TYPE_DOMAIN_ENUM, NULL, &resumehandle);

   if (Status == NO_ERROR) {

      ServList = AllocMemory(sizeof(SERVER_BROWSE_LIST) + (sizeof(SERVER_BROWSE_BUFFER) * entriesread));

      if (!ServList) {
         Status = ERROR_NOT_ENOUGH_MEMORY;
      } else {
         ServList->Count = entriesread;
         SList = (SERVER_BROWSE_BUFFER *) &ServList->SList;

         for (i = 0; i < entriesread; i++) {
            lstrcpy(SList[i].Name, buffer[i].sv101_name);
            lstrcpy(SList[i].Description, buffer[i].sv101_comment);
            SList[i].Container = !Container;
            SList[i].child = NULL;
         }
      }
   }

   if (buffer != NULL)
      NetApiBufferFree((LPVOID) buffer);

   *lpServList = ServList;
   return Status;

} // NTServerEnum


/////////////////////////////////////////////////////////////////////////
BOOL 
NTShareNameValidate(
   LPTSTR szShareName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   TCHAR *ptr = szShareName;
   BOOL ret;

   ret = TRUE;

   if (*ptr) {
      // go to end
      while (*ptr)
         ptr++;

      // now back up to last character
      ptr--;
      if (*ptr == TEXT('$'))  // for ADMIN$, IPC$, etc...
         ret = FALSE;

   } else
      // Don't allow zero length - not sure why we would ever get these...
      ret = FALSE;

   return ret;

} // NTShareNameValidate


/////////////////////////////////////////////////////////////////////////
DWORD 
NTSharesEnum(
   SHARE_LIST **lpShares, 
   DRIVE_LIST *Drives
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   LPSHARE_INFO_2 buffer = NULL;
   NET_API_STATUS Status = 0;
   DWORD prefmaxlength = 0xffffffff;
   DWORD totalentries = 0;
   DWORD entriesread = 0;
   DWORD ActualEntries = 0;
   DWORD resumehandle = 0;
   DWORD i, di;
   SHARE_LIST *ShareList = NULL;
   SHARE_BUFFER *SList;
   DRIVE_BUFFER *DList;
   ULONG TotalDrives;
   TCHAR Drive[2];
   PFPNWVOLUMEINFO VolumeInfo, VolumeEntry;
   BOOL Found;

   if (LocalMachine)
      Status = NetShareEnum(NULL, 2, (LPBYTE *) &buffer, prefmaxlength, &entriesread, &totalentries, &resumehandle);
   else
      Status = NetShareEnum(CachedServer, 2, (LPBYTE *) &buffer, prefmaxlength, &entriesread, &totalentries, &resumehandle);

   if (Status == NO_ERROR) {

      // We have the list - but need to prune out IPC$, Admin$, etc...
      for (i = 0; i < entriesread; i++)
         if ((buffer[i].shi2_type == STYPE_DISKTREE) && NTShareNameValidate(buffer[i].shi2_netname))
            ActualEntries++;

      ShareList = AllocMemory(sizeof(SHARE_LIST) + (sizeof(SHARE_BUFFER) * ActualEntries));

      if (!ShareList) {
         Status = ERROR_NOT_ENOUGH_MEMORY;
      } else {
         SList = (SHARE_BUFFER *) &ShareList->SList;

         ShareList->Count = ActualEntries;
         ActualEntries = 0;

         TotalDrives = 0;
         Drive[1] = TEXT('\0');
         if (Drives != NULL) {
            DList = Drives->DList;
            TotalDrives = Drives->Count;
         }

         // loop through copying the data
         for (i = 0; i < entriesread; i++)
            if ((buffer[i].shi2_type == STYPE_DISKTREE) && NTShareNameValidate(buffer[i].shi2_netname)) {
               lstrcpy(SList[ActualEntries].Name, buffer[i].shi2_netname);
               lstrcpy(SList[ActualEntries].Path, buffer[i].shi2_path);
               SList[ActualEntries].Index = (USHORT) ActualEntries;

               // Scan drive list looking for match to share path
               for (di = 0; di < TotalDrives; di++) {
                  // Get first char from path - should be drive letter
                  Drive[0] = *buffer[i].shi2_path;
                  if (!lstrcmpi(Drive, DList[di].Drive))
                     SList[ActualEntries].Drive = &DList[di];
               }

               ActualEntries++;
            }

      }
   }

   //
   // Now loop through any FPNW shares and tack those on as well
   //
   VolumeInfo = NULL;
   resumehandle = entriesread = 0;

   if (pFpnwVolumeEnum != NULL)
      if (LocalMachine)
         Status = (ULONG) (*pFpnwVolumeEnum) ( NULL, 1, (LPBYTE *)&VolumeInfo, &entriesread, &resumehandle );
      else
         Status = (ULONG) (*pFpnwVolumeEnum) ( CachedServer, 1, (LPBYTE *)&VolumeInfo, &entriesread, &resumehandle );

#if DBG
dprintf(TEXT("Status: 0x%lX Entries: %lu\n"), Status, entriesread);
#endif
   if ( !Status && entriesread ) {

      if (ShareList)
         ShareList = ReallocMemory(ShareList, sizeof(SHARE_LIST) + (sizeof(SHARE_BUFFER) * (ActualEntries + entriesread)));
      else
         ShareList = AllocMemory(sizeof(SHARE_LIST) + (sizeof(SHARE_BUFFER) * entriesread));

      if (!ShareList) {
         Status = ERROR_NOT_ENOUGH_MEMORY;
      } else {
         SList = (SHARE_BUFFER *) &ShareList->SList; // reset pointer...    

         // loop through copying the data
         for (i = 0; i < entriesread; i++) {
            //
            // Make sure not in NT Share list already
            //
            Found = FALSE;

            for (di = 0; di < ShareList->Count; di++)
                if (!lstrcmpi(SList[di].Name, VolumeInfo[i].lpVolumeName))
                    Found = TRUE;

            if ((!Found) && (VolumeInfo[i].dwType == FPNWVOL_TYPE_DISKTREE) ) {
               lstrcpy(SList[ActualEntries].Name, VolumeInfo[i].lpVolumeName);
               lstrcpy(SList[ActualEntries].Path, VolumeInfo[i].lpPath);
               SList[ActualEntries].Index = (USHORT) ActualEntries;

               // Scan drive list looking for match to share path
               for (di = 0; di < TotalDrives; di++) {
                  // Get first char from path - should be drive letter
                  Drive[0] = *VolumeInfo[i].lpPath;
                  if (!lstrcmpi(Drive, DList[di].Drive))
                     SList[ActualEntries].Drive = &DList[di];
               }

               ActualEntries++;
            }
         }
      }
   }

   if (ShareList)
      ShareList->Count = ActualEntries;

   if (VolumeInfo && (pFpnwApiBufferFree != NULL))
      (*pFpnwApiBufferFree) ( VolumeInfo );

   if (buffer != NULL)
      NetApiBufferFree((LPVOID) buffer);

   *lpShares = ShareList;
   return Status;
} // NTSharesEnum


/////////////////////////////////////////////////////////////////////////
DWORD 
NTGroupSave(
   LPTSTR Name
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static NET_API_STATUS Status = 0;
   GROUP_INFO_0 grpi0;
   DWORD err;

   grpi0.grpi0_name = Name;

   if (LocalMachine)
      Status = NetGroupAdd(NULL, 0, (LPBYTE) &grpi0, &err);
   else {
      Status = NetGroupAdd(CachedServer, 0, (LPBYTE) &grpi0, &err);
   }
   return Status;

} // NTGroupSave


/////////////////////////////////////////////////////////////////////////
DWORD 
NTGroupUserAdd(
   LPTSTR GroupName, 
   LPTSTR UserName, 
   BOOL Local
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NET_API_STATUS Status = 0;
   SID *pUserSID = NULL;

   if (LocalMachine)
      if (Local) {
         pUserSID = NTSIDGet(NULL, UserName);

         if (pUserSID != NULL)
            Status = NetLocalGroupAddMember(NULL, GroupName, pUserSID);

      } else
         Status = NetGroupAddUser(NULL, GroupName, UserName);
   else {
      if (Local) {
         pUserSID = NTSIDGet(CachedServer, UserName);

         if (pUserSID != NULL)
            Status = NetLocalGroupAddMember(CachedServer, GroupName, pUserSID);
      } else
         Status = NetGroupAddUser(CachedServer, GroupName, UserName);
   }

   // If complaining because user is already there, ignore
   if (Status == NERR_UserInGroup)
      Status = 0;

   return Status;

} // NTGroupUserAdd


/////////////////////////////////////////////////////////////////////////
DWORD 
NTUserInfoSave(
   NT_USER_INFO *NT_UInfo, 
   PFPNW_INFO fpnw
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static NET_API_STATUS Status = 0;
   struct _USER_INFO_3 *usri3;
   DWORD err;

   usri3 = (struct _USER_INFO_3 *) NT_UInfo;
    
   // Map logon hours to GMT time - as NetAPI re-fixes it
   NetpRotateLogonHours(NT_UInfo->logon_hours, UNITS_PER_WEEK, TRUE);

   if (LocalMachine)
      Status = NetUserAdd(NULL, 3, (LPBYTE)  usri3, &err);
   else
      Status = NetUserAdd(CachedServer, 3, (LPBYTE)  usri3, &err);

   if ((!Status) && (fpnw != NULL)) {
      // Need to get user info via LSA call before calling setuserparms
   }

   return Status;

} // NTUserInfoSave


#define NEW_NULL_PASSWD TEXT("               ")
/////////////////////////////////////////////////////////////////////////
DWORD 
NTUserInfoSet(
   NT_USER_INFO *NT_UInfo, 
   PFPNW_INFO fpnw
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   LPWSTR Password;
   LPWSTR Name;
   static NET_API_STATUS Status = 0;
   struct _USER_INFO_3 *usri3;
   DWORD err;

   // Tell it not to replace the password
   Password = NT_UInfo->password;
   NT_UInfo->password = NULL;

   Name = NT_UInfo->name;
   usri3 = (struct _USER_INFO_3 *) NT_UInfo;
    
   // Map logon hours to GMT time - as NetAPI re-fixes it
   NetpRotateLogonHours(NT_UInfo->logon_hours, UNITS_PER_WEEK, TRUE);

   if (LocalMachine)
      Status = NetUserSetInfo(NULL,  Name, 3, (LPBYTE) usri3, &err);
   else
      Status = NetUserSetInfo(CachedServer, Name, 3, (LPBYTE) usri3, &err);

   if ((!Status) && (fpnw != NULL)) {
   }

   // Reset the password in our data structure.
   NT_UInfo->password = Password;
   return Status;

} // NTUserInfoSet


/////////////////////////////////////////////////////////////////////////
VOID 
NTUserRecInit(
   LPTSTR UserName, 
   NT_USER_INFO *NT_UInfo
   )

/*++

Routine Description:

    Initializes a user record, uses static variables for string holders
    so is not re-entrant, and will overwrite previous records data if
    called again.

Arguments:


Return Value:


--*/

{
   static TCHAR uname[UNLEN + 1];
   static TCHAR upassword[ENCRYPTED_PWLEN];
   static TCHAR uhomedir[PATHLEN + 1];
   static TCHAR ucomment[MAXCOMMENTSZ + 1];
   static TCHAR uscriptpath[PATHLEN + 1];
   static TCHAR ufullname[MAXCOMMENTSZ + 1];
   static TCHAR uucomment[MAXCOMMENTSZ + 1];
   static TCHAR uparms[MAXCOMMENTSZ + 1];
   static TCHAR uworkstations[1];
   static BYTE ulogonhours[21];
   static TCHAR ulogonserver[1];
   static TCHAR uprofile[1];
   static TCHAR uhome_dir_drive[1];

   // init all the static data holders.
   memset(uname, 0, sizeof( uname ));
   lstrcpy(uname, UserName);

   memset(upassword, 0, sizeof( upassword ));
   memset(uhomedir, 0, sizeof( uhomedir ));
   memset(ucomment, 0, sizeof( ucomment ));
   memset(uscriptpath, 0, sizeof( uscriptpath ));
   memset(ufullname, 0, sizeof( ufullname ));
   memset(uucomment, 0, sizeof( uucomment ));
   memset(uparms, 0, sizeof( uparms ));
   memset(uworkstations, 0, sizeof( uworkstations ));
   memset(ulogonhours, 0, sizeof( ulogonhours ));
   memset(ulogonserver, 0, sizeof( ulogonserver ));
   memset(uprofile, 0, sizeof( uprofile ));
   memset(uhome_dir_drive, 0, sizeof( uhome_dir_drive ));

   memset(NT_UInfo, 0, sizeof(NT_USER_INFO));

   // point the passed in record to these data holders
   NT_UInfo->name = uname;
   NT_UInfo->password = upassword;
   NT_UInfo->home_dir = uhomedir;
   NT_UInfo->comment = ucomment;
   NT_UInfo->script_path = uscriptpath;
   NT_UInfo->full_name = ufullname;
   NT_UInfo->usr_comment = uucomment;
   NT_UInfo->parms = uparms;
   NT_UInfo->workstations = uworkstations;
   NT_UInfo->logon_hours = ulogonhours;
   NT_UInfo->logon_server = ulogonserver;
   NT_UInfo->profile = uprofile;
   NT_UInfo->home_dir_drive = uhome_dir_drive;
   NT_UInfo->units_per_week = UNITS_PER_WEEK;

   // Set the default values for special fields
   NT_UInfo->primary_group_id = DOMAIN_GROUP_RID_USERS;
   NT_UInfo->priv = USER_PRIV_USER;
   NT_UInfo->acct_expires = TIMEQ_FOREVER;
   NT_UInfo->max_storage = USER_MAXSTORAGE_UNLIMITED;
   NT_UInfo->flags = UF_SCRIPT;

}  // NTUserRecInit


/////////////////////////////////////////////////////////////////////////
LPTSTR 
NTDriveShare(
   LPTSTR DriveLetter
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR RootPath[MAX_SERVER_NAME_LEN + 3];

   if (LocalMachine)
      wsprintf(RootPath, TEXT("%s:\\"), DriveLetter);
   else
      wsprintf(RootPath, TEXT("%s\\%s$\\"), CachedServer, DriveLetter);

   return RootPath;

} // NTDriveShare


/////////////////////////////////////////////////////////////////////////
VOID 
NTDriveInfoGet(
   DRIVE_BUFFER *DBuff
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   DWORD volMaxCompLength, volFileSystemFlags;
   DWORD sectorsPC, bytesPS, FreeClusters, Clusters;
   TCHAR NameBuffer[20];
   TCHAR volName[20];
   LPTSTR RootPath;
   UINT  previousErrorMode;

   //
   // Disable DriveAccess Error, because no media is inserted onto specified drive.
   //
   previousErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS|
                                    SEM_NOOPENFILEERRORBOX);

   volMaxCompLength = volFileSystemFlags = 0;
   sectorsPC = bytesPS = FreeClusters = Clusters = 0;

   // First get file system type
   RootPath = NTDriveShare(DBuff->Drive);
   if (GetVolumeInformation(RootPath, volName, sizeof(volName), NULL, &volMaxCompLength, &volFileSystemFlags, NameBuffer, sizeof(NameBuffer))) {
      if (GetDriveType(RootPath) == DRIVE_CDROM)
         lstrcpy(DBuff->DriveType, Lids(IDS_S_49));
      else
         lstrcpyn(DBuff->DriveType, NameBuffer, sizeof(DBuff->DriveType)-1);

      lstrcpyn(DBuff->Name, volName, sizeof(DBuff->Name)-1);

      if (!lstrcmpi(NameBuffer, Lids(IDS_S_9)))
         DBuff->Type = DRIVE_TYPE_NTFS;
   }
   else {
       if (GetDriveType(RootPath) == DRIVE_CDROM)
          lstrcpy(DBuff->DriveType, Lids(IDS_S_49));
       else
          lstrcpy(DBuff->DriveType, TEXT("\0"));
  
       lstrcpy(DBuff->Name, TEXT("\0"));

       if (!lstrcmpi(NameBuffer, Lids(IDS_S_9)))
          DBuff->Type = DRIVE_TYPE_NTFS;
   }

   if (GetDiskFreeSpace(RootPath, &sectorsPC, &bytesPS, &FreeClusters, &Clusters)) {
      DBuff->TotalSpace = Clusters * sectorsPC * bytesPS;
      DBuff->FreeSpace = FreeClusters * sectorsPC * bytesPS;
   }
   else {
      DBuff->TotalSpace = 0;
      DBuff->FreeSpace = 0;
   }

   //
   // Back to original error mode.
   //
   SetErrorMode(previousErrorMode);

} // NTDriveInfoGet


/////////////////////////////////////////////////////////////////////////
BOOL 
NTDriveValidate(
   TCHAR DriveLetter
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   BOOL ret = FALSE;

   // Just make sure it isn't one of the two floppys
   if (!((DriveLetter == TEXT('A')) || (DriveLetter == TEXT('B'))))
      ret = TRUE;

   return ret;

} // NTDriveValidate


/////////////////////////////////////////////////////////////////////////
VOID 
NTDrivesEnum(
   DRIVE_LIST **lpDrives
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   TCHAR *buffer = NULL;
   NET_API_STATUS Status = 0;
   DWORD entriesread, totalentries, resumehandle, actualentries, i;
   DRIVE_LIST *DriveList;
   DRIVE_BUFFER *DList;

   entriesread = totalentries = resumehandle = actualentries = 0;

   if (LocalMachine)
      Status = NetServerDiskEnum(NULL, 0, (LPBYTE *) &buffer, 0xFFFFFFFF, &entriesread, &totalentries, &resumehandle);
   else
      Status = NetServerDiskEnum(CachedServer, 0, (LPBYTE *) &buffer, 0xFFFFFFFF, &entriesread, &totalentries, &resumehandle);

   if (Status == NO_ERROR) {
      // We have the list - but need to prune out A:, B:
      for (i = 0; i < entriesread; i++)
         if (NTDriveValidate(buffer[i * 3]))
            actualentries++;

      // temporarily use i to hold total size of data structure
      i = sizeof(DRIVE_LIST) + (sizeof(DRIVE_BUFFER) * actualentries);
      DriveList = AllocMemory(i);

      if (!DriveList) {
         Status = ERROR_NOT_ENOUGH_MEMORY;
      } else {
         memset(DriveList, 0, i);
         DList = (DRIVE_BUFFER *) &DriveList->DList;
         DriveList->Count = actualentries;

         // Now fill in the individual data items
         actualentries = 0;
         for (i = 0; i < entriesread; i++)
            if (NTDriveValidate(buffer[i * 3])) {
               DList[actualentries].Drive[0] = buffer[i * 3];
               NTDriveInfoGet(&DList[actualentries]);
               actualentries++;
            }
      }
   }

   if (buffer != NULL)
      NetApiBufferFree((LPVOID) buffer);

   *lpDrives = DriveList;
   return;

} // NTDrivesEnum


/////////////////////////////////////////////////////////////////////////
VOID 
NTServerGetInfo(
   LPTSTR ServerName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   TCHAR LocServer[MAX_SERVER_NAME_LEN + 3];
   NET_API_STATUS Status = 0;

   if (ServInfo != NULL)
      NetApiBufferFree((LPVOID) ServInfo);

   ServInfo = NULL;

   wsprintf(LocServer, TEXT("\\\\%s"), ServerName);

   if (!LocalName)
      GetLocalName(&LocalName);

   if (lstrcmpi(ServerName, LocalName) == 0)
      Status = NetServerGetInfo(NULL, 101, (LPBYTE *) &ServInfo);
   else
      Status = NetServerGetInfo(LocServer, 101, (LPBYTE *) &ServInfo);

   if (Status) {
      ServInfo = NULL;
      return;
   }

} // NTServerGetInfo


/////////////////////////////////////////////////////////////////////////
NT_CONN_BUFFER *
NTConnListFind(
   LPTSTR ServerName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   BOOL Found = FALSE;
   static NT_CONN_BUFFER *ServList;

   ServList = NTConnListStart;

   while ((ServList && !Found)) {
      if (!lstrcmpi(ServList->Name, ServerName))
         Found = TRUE;
      else
         ServList = ServList->next;
   }

   if (!Found)
      ServList = NULL;

   return (ServList);

} // NTConnListFind


/////////////////////////////////////////////////////////////////////////
NT_CONN_BUFFER *
NTConnListAdd(
   LPTSTR ServerName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static NT_CONN_BUFFER *tmpPtr;
   ULONG Size, strlen1;

   tmpPtr = NULL;
   strlen1 = (lstrlen(ServerName) + 1) * sizeof(TCHAR);
   Size = sizeof(NT_CONN_BUFFER) + strlen1;
   tmpPtr = AllocMemory(Size);
   
   if (tmpPtr != NULL) {
      // init it to NULL's
      memset(tmpPtr, 0, Size);
      tmpPtr->Name = (LPTSTR) ((BYTE *) tmpPtr + sizeof(NT_CONN_BUFFER));
      lstrcpy(tmpPtr->Name, ServerName);

      // link it into the list
      if (!NTConnListStart)
         NTConnListStart = NTConnListEnd = tmpPtr;
      else {
         NTConnListEnd->next = tmpPtr;
         tmpPtr->prev = NTConnListEnd;
         NTConnListEnd = tmpPtr;
      }
   }

   return (tmpPtr);

} // NTConnListAdd


/////////////////////////////////////////////////////////////////////////
VOID 
NTConnListDelete(
   NT_CONN_BUFFER *tmpPtr
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NT_CONN_BUFFER *PrevPtr;
   NT_CONN_BUFFER *NextPtr;

   if (tmpPtr == NULL)
      return;

   // Now unlink the actual server record
   PrevPtr = tmpPtr->prev;
   NextPtr = tmpPtr->next;

   if (PrevPtr)
      PrevPtr->next = NextPtr;

   if (NextPtr)
      NextPtr->prev = PrevPtr;

   // Check if at end of list
   if (NTConnListEnd == tmpPtr)
      NTConnListEnd = PrevPtr;

   // Check if at start of list
   if (NTConnListStart == tmpPtr)
      NTConnListStart = NextPtr;

   FreeMemory(tmpPtr);

}  // NTConnListDelete


/////////////////////////////////////////////////////////////////////////
VOID 
NTConnListDeleteAll()

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR LocServer[MAX_SERVER_NAME_LEN + 3];
   NT_CONN_BUFFER *ServList;
   NT_CONN_BUFFER *ServListNext;

   // Now remove the entries from the internal list
   ServList = NTConnListStart;

   while (ServList) {
      ServListNext = ServList->next;

      wsprintf(LocServer, Lids(IDS_S_10), ServList->Name);
      WNetCancelConnection2(LocServer, 0, FALSE);

      NTConnListDelete(ServList);
      ServList = ServListNext;
   }

} // NTConnListDeleteAll


/////////////////////////////////////////////////////////////////////////
VOID 
NTUseDel(
   LPTSTR ServerName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR LocServer[MAX_SERVER_NAME_LEN + 3];
   NT_CONN_BUFFER *NTConn;

   // Find it in our connection list - if it exists get rid of it.
   NTConn = NTConnListFind(ServerName);
   if (NTConn != NULL)
      NTConnListDelete(NTConn);

   NTServerFree();
   wsprintf(LocServer, Lids(IDS_S_10), ServerName);
   WNetCancelConnection2(LocServer, 0, FALSE);

} // NTUseDel


/////////////////////////////////////////////////////////////////////////
BOOL 
NTServerValidate(
   HWND hWnd, 
   LPTSTR ServerName
   )

/*++

Routine Description:

    Validates a given server - makes sure it can be connected to and
    that the user has admin privs on it.

Arguments:


Return Value:


--*/

{
   BOOL ret = FALSE;
   DWORD idsErr = 0;
   DWORD lastErr = 0;
   DWORD Size;
   NET_API_STATUS Status;
   LPUSER_INFO_1 UserInfo1 = NULL;
   TCHAR UserName[MAX_NT_USER_NAME_LEN + 1];
   TCHAR ServName[MAX_SERVER_NAME_LEN + 3];   // +3 for leading slashes and ending NULL
   LPVOID lpMessageBuffer = NULL;

   NTServerSet(ServerName);

   // server already connected then return success
   if (NTConnListFind(ServerName)) {
      return TRUE;
   }

   CursorHourGlass();

   // Get Current Logged On User
   lstrcpy(UserName, TEXT(""));
   Size = sizeof(UserName);
   WNetGetUser(NULL, UserName, &Size);

   // Fixup the destination server name
   lstrcpy(ServName, TEXT( "\\\\" ));
   lstrcat(ServName, ServerName);

   // Make an ADMIN$ connection to the server
   if (UseAddPswd(hWnd, UserName, ServName, Lids(IDS_S_11), NT_PROVIDER)) {

      // Double check we have admin privs
      // Get connection to the system and check for admin privs...
      Status = NetUserGetInfo(ServName, UserName, 1, (LPBYTE *) &UserInfo1);

      if (Status == ERROR_SUCCESS) {

         // Got User info, now make sure admin flag is set
         if (!(UserInfo1->usri1_priv & USER_PRIV_ADMIN)) {
            idsErr = IDS_E_6;
            goto cleanup;
         }

         // We may have a connection to admin$ and we may have proven
         // that the user we made the connection with really is an admin
         // but sitting at the local machine we still may have a problem
         // acquiring all of the administrative information necessary to
         // accomplish a successful conversion. each and every one of the
         // functions that make network calls should return errors and if
         // that were the case then the errors would propagate up and we
         // could deal with the access denial reasonably.  unfortunately,
         // alot of assumptions are made after the success of this call
         // so we must perform yet another test here...
         if (LocalMachine) {

            DWORD EntriesRead = 0;
            DWORD TotalEntries = 0;
            LPSHARE_INFO_2 ShareInfo2 = NULL;

            Status = NetShareEnum(
                        ServName,
                        2,
                        (LPBYTE *) &ShareInfo2,
                        MAX_PREFERRED_LENGTH,
                        &EntriesRead,
                        &TotalEntries,
                        NULL
                        );

            if (ShareInfo2 != NULL)
               NetApiBufferFree((LPVOID) ShareInfo2); // discarded...

            if (Status != ERROR_SUCCESS) {
               idsErr = (Status == ERROR_ACCESS_DENIED) ? IDS_E_6 : IDS_E_5;
               goto cleanup;
            }
         }

         // Now get server info and make certain this is an NT server
         // instead of an LM type server.  Note:  Info from the call is
         // cached and used later, so don't remove it!!
         NTServerGetInfo(ServerName);

         if (ServInfo) {

            if (ServInfo->sv101_platform_id == SV_PLATFORM_ID_NT) {

               if (ServInfo->sv101_type & (TYPE_DOMAIN)) {

                  // If NTAS and have admin privs then we are set
                  // then add it to our connection list...
                  NTConnListAdd(ServerName);
                  ret = TRUE;

               } else {
                  idsErr = IDS_E_8;
               }

            } else {
               idsErr = IDS_E_8;
            }

         } else {
            idsErr = IDS_E_7;
         }

      } else {

         // determine error string id and bail out...
         idsErr = (Status == ERROR_ACCESS_DENIED) ? IDS_E_6 : IDS_E_5;
      }

   } else if (lastErr = GetLastError()) {

      // error string id
      idsErr = IDS_E_9;

      // use system default language resource
      FormatMessage(
         FORMAT_MESSAGE_ALLOCATE_BUFFER |
         FORMAT_MESSAGE_FROM_SYSTEM,
         NULL,
         lastErr,
         0,
         (LPTSTR)&lpMessageBuffer,
         0,
         NULL
         );

   }

cleanup:

   if (lpMessageBuffer) {
      WarningError(Lids((WORD)(DWORD)idsErr), ServerName, lpMessageBuffer);
      LocalFree(lpMessageBuffer);
   } else if (idsErr) {
      WarningError(Lids((WORD)(DWORD)idsErr), ServerName);
   }

   if (UserInfo1 != NULL)
      NetApiBufferFree((LPVOID) UserInfo1);

   CursorNormal();
   return ret;

} // NTServerValidate


/////////////////////////////////////////////////////////////////////////
VOID 
NTServerInfoReset(
   HWND hWnd, 
   DEST_SERVER_BUFFER *DServ, 
   BOOL ResetDomain
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   LPTSTR apiPDCName = NULL;
   TCHAR PDCName[MAX_SERVER_NAME_LEN + 1];
   TCHAR LocServer[MAX_SERVER_NAME_LEN + 3];
   DOMAIN_BUFFER *DBuff;
   TCHAR Domain[DNLEN + 1];
   NET_API_STATUS Status = 0;

   lstrcpy(PDCName, TEXT(""));

   if (ServInfo) {
      DServ->Type = ServInfo->sv101_type;
      DServ->VerMaj = ServInfo->sv101_version_major;
      DServ->VerMin = ServInfo->sv101_version_minor;
      DServ->IsNTAS = IsNTAS(DServ->Name);
      DServ->IsFPNW = IsFPNW(DServ->Name);

      // If there was no old domain, don't worry about reseting it
      if (ResetDomain && (DServ->Domain == NULL))
         ResetDomain = FALSE;

      // Check if we are a member of a domain.
      if (ServInfo->sv101_type & (TYPE_DOMAIN)) {
         wsprintf(LocServer, TEXT("\\\\%s"), DServ->Name);
         Status = NetGetDCName(LocServer, NULL, (LPBYTE *) &apiPDCName);

         if (!Status) {
            // get rid of leading 2 backslashes
            if (lstrlen(apiPDCName) > 2)
               lstrcpy(PDCName, &apiPDCName[2]);

            if (NTServerValidate(hWnd, PDCName)) {
               DServ->IsFPNW = IsFPNW(PDCName);
               DServ->InDomain = TRUE;

               // Get Domain
               memset(Domain, 0, sizeof(Domain));
               NTDomainGet(DServ->Name, Domain);

               if (ResetDomain) {
                  DomainListDelete(DServ->Domain);
                  DServ->Domain = NULL;
               }

               // Check if we need to add server to server list
               DBuff = DomainListFind(Domain);

               if (DBuff == NULL) {
                  DBuff = DomainListAdd(Domain, PDCName);
                  DBuff->Type = ServInfo->sv101_type;
                  DBuff->VerMaj = ServInfo->sv101_version_major;
                  DBuff->VerMin = ServInfo->sv101_version_minor;
               }

               DBuff->UseCount++;
               DServ->Domain = DBuff;
            } // if Domain valid

            if (apiPDCName != NULL)
               NetApiBufferFree((LPVOID) apiPDCName);
         }

      }

   }

   // make sure we are pointing to the right one
   NTServerSet(DServ->Name);

   // Fill in Drive Lists
   NTDrivesEnum(&DServ->DriveList);

} // NTServerInfoReset


/////////////////////////////////////////////////////////////////////////
VOID 
NTServerInfoSet(
   HWND hWnd, 
   LPTSTR ServerName, 
   DEST_SERVER_BUFFER *DServ
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   LPTSTR apiPDCName = NULL;
   NET_API_STATUS Status = 0;

   CursorHourGlass();
   DServ->UseCount++;

   NTServerInfoReset(hWnd, DServ, FALSE);

   // Fill in share and Drive Lists
   NTSharesEnum(&DServ->ShareList, DServ->DriveList);


#ifdef DEBUG
{
   DWORD i;

   dprintf(TEXT("Adding NT Server: %s\n"), DServ->Name);
   dprintf(TEXT("   Version: %lu.%lu\n"), DServ->VerMaj, DServ->VerMin);

   if (DServ->InDomain && DServ->Domain)
      dprintf(TEXT("   In Domain: %s [\\\\%s]\n"), DServ->Domain->Name, DServ->Domain->PDCName);

   dprintf(TEXT("\n"));
   dprintf(TEXT("   Drives:\n"));
   dprintf(TEXT("   +-------------------+\n"));
   for (i = 0; i < DServ->DriveList->Count; i++)
      dprintf(TEXT("   %s\n"), DServ->DriveList->DList[i].Drive);
   dprintf(TEXT("\n"));

   dprintf(TEXT("   Shares:\n"));
   dprintf(TEXT("   +-------------------+\n"));
   for (i = 0; i < DServ->ShareList->Count; i++)
      dprintf(TEXT("   %s\n"), DServ->ShareList->SList[i].Name);
   dprintf(TEXT("\n"));

}
#endif

   CursorNormal();

} // NTServerInfoSet


/////////////////////////////////////////////////////////////////////////
VOID 
NTLoginTimesLog(
   BYTE *Times
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   TCHAR *szDays[7];
   DWORD Day;
   DWORD Hours;
   int Bit = 0;
   static TCHAR szHours[80];

   szDays[0] = Lids(IDS_SUN);
   szDays[1] = Lids(IDS_MON);
   szDays[2] = Lids(IDS_TUE);
   szDays[3] = Lids(IDS_WED);
   szDays[4] = Lids(IDS_THU);
   szDays[5] = Lids(IDS_FRI);
   szDays[6] = Lids(IDS_SAT);

   LogWriteLog(1, Lids(IDS_CRLF));
   LogWriteLog(1, Lids(IDS_L_56));

   // while these should be indent 2, there isn't room on 80 cols - so indent 1
   LogWriteLog(1, Lids(IDS_L_1));
   LogWriteLog(1, Lids(IDS_L_2));
   LogWriteLog(1, Lids(IDS_L_3));

   for (Day = 0; Day < 7; Day++) {
      LogWriteLog(1, szDays[Day]);
      lstrcpy(szHours, TEXT(" "));

      for (Hours = 0; Hours < 24; Hours++) {
         if (BitTest(Bit, Times))
            lstrcat(szHours, TEXT("**"));
         else
            lstrcat(szHours, TEXT("  "));

         Bit++;

         lstrcat(szHours, TEXT(" "));    
      }

      LogWriteLog(0, szHours);
      LogWriteLog(0, Lids(IDS_CRLF));
   }

   LogWriteLog(0, Lids(IDS_CRLF));

} // NTLoginTimesLog


/////////////////////////////////////////////////////////////////////////
VOID 
NTUserRecLog(
   NT_USER_INFO NT_UInfo
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   LPTSTR tmpStr;

   LogWriteLog(1, Lids(IDS_L_57));

   LogWriteLog(2, Lids(IDS_L_58), NT_UInfo.full_name);
   LogWriteLog(2, Lids(IDS_L_59), NT_UInfo.password);

   switch(NT_UInfo.priv) {
      case 0:
         tmpStr = Lids(IDS_L_60);
         break;

      case 1:
         tmpStr = Lids(IDS_L_61);
         break;

      case 2:
         tmpStr = Lids(IDS_L_62);
         break;
   }

   LogWriteLog(2, Lids(IDS_L_63), tmpStr);

   LogWriteLog(2, Lids(IDS_L_64), NT_UInfo.home_dir);
   LogWriteLog(2, Lids(IDS_L_65), NT_UInfo.comment);

   // Flags
   LogWriteLog(2, Lids(IDS_L_66));
   if (NT_UInfo.flags & 0x01)
      LogWriteLog(3, Lids(IDS_L_67), Lids(IDS_YES));
   else
      LogWriteLog(3, Lids(IDS_L_67), Lids(IDS_NO));

   if (NT_UInfo.flags & 0x02)
      LogWriteLog(3, Lids(IDS_L_68), Lids(IDS_YES));
   else
      LogWriteLog(3, Lids(IDS_L_68), Lids(IDS_NO));

   if (NT_UInfo.flags & 0x04)
      LogWriteLog(3, Lids(IDS_L_69), Lids(IDS_YES));
   else
      LogWriteLog(3, Lids(IDS_L_69), Lids(IDS_NO));

   if (NT_UInfo.flags & 0x08)
      LogWriteLog(3, Lids(IDS_L_70), Lids(IDS_YES));
   else
      LogWriteLog(3, Lids(IDS_L_70), Lids(IDS_NO));

   if (NT_UInfo.flags & 0x20)
      LogWriteLog(3, Lids(IDS_L_71), Lids(IDS_NO));
   else
      LogWriteLog(3, Lids(IDS_L_71), Lids(IDS_YES));

   if (NT_UInfo.flags & 0x40)
      LogWriteLog(3, Lids(IDS_L_72), Lids(IDS_NO));
   else
      LogWriteLog(3, Lids(IDS_L_72), Lids(IDS_YES));

   // Script path
   LogWriteLog(2, Lids(IDS_L_73), NT_UInfo.script_path);

   LogWriteLog(2, Lids(IDS_L_74), NT_UInfo.full_name);

   LogWriteLog(2, Lids(IDS_L_75), NT_UInfo.logon_server);

   NTLoginTimesLog((BYTE *) NT_UInfo.logon_hours);

   LogWriteLog(0, Lids(IDS_CRLF));

} // NTUserRecLog


/////////////////////////////////////////////////////////////////////////
VOID 
NTDomainSynch(
   DEST_SERVER_BUFFER *DServ
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   LPBYTE buffer = NULL;
   BOOL UsePDC = FALSE;
   NET_API_STATUS Status;
   TCHAR LocServer[MAX_SERVER_NAME_LEN + 3];

   wsprintf(LocServer, TEXT("\\\\%s"), DServ->Name);

   if ((DServ->InDomain) && (DServ->Domain != NULL)) {
      wsprintf(LocServer, TEXT("\\\\%s"), DServ->Domain->PDCName);
      UsePDC = TRUE;
   }

   if (UsePDC)
      Status = I_NetLogonControl(LocServer, NETLOGON_CONTROL_PDC_REPLICATE, 1, &buffer);
   else
      Status = I_NetLogonControl(LocServer, NETLOGON_CONTROL_SYNCHRONIZE, 1, &buffer);

   if (buffer != NULL)
      NetApiBufferFree(buffer);

} // NTDomainSynch


/////////////////////////////////////////////////////////////////////////
BOOL 
NTDomainInSynch(
   LPTSTR Server
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PNETLOGON_INFO_1 buffer = NULL;
   NET_API_STATUS Status;

   Status = I_NetLogonControl(Server, NETLOGON_CONTROL_QUERY, 1, (PBYTE *) &buffer);

   if (Status) {
      return TRUE;
   }

   if (buffer && buffer->netlog1_flags)
      return FALSE;

   if (buffer != NULL)
      NetApiBufferFree(buffer);

   return TRUE;

} // NTDomainInSynch


/////////////////////////////////////////////////////////////////////////
BOOL 
NTDomainGet(
   LPTSTR ServerName, 
   LPTSTR Domain
   )

/*++

Routine Description:

    Gee - what a simple way to get the domain a server is part of!

Arguments:


Return Value:


--*/

{
   static TCHAR Serv[MAX_SERVER_NAME_LEN + 3];
   UNICODE_STRING us;
   NTSTATUS ret;
   OBJECT_ATTRIBUTES oa;
   ACCESS_MASK am;
   SECURITY_QUALITY_OF_SERVICE qos;
   LSA_HANDLE hLSA;
   PPOLICY_PRIMARY_DOMAIN_INFO pvBuffer;

   if (ServerName[0] == TEXT('\\'))
      lstrcpy(Serv, ServerName);
   else
      wsprintf(Serv, TEXT("\\\\%s"), ServerName);

   // Set up unicode string structure
   us.Length = (USHORT)(lstrlen(Serv) * sizeof(TCHAR));
   us.MaximumLength = us.Length + sizeof(TCHAR);
   us.Buffer = Serv;

   // only need read access
   am = POLICY_READ | POLICY_VIEW_LOCAL_INFORMATION;

   // set up quality of service
   qos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
   qos.ImpersonationLevel = SecurityImpersonation;
   qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
   qos.EffectiveOnly = FALSE;

   // Macro sets everything except security field
   InitializeObjectAttributes( &oa, NULL, 0L, NULL, NULL );
   oa.SecurityQualityOfService = &qos;

   ret = LsaOpenPolicy(&us, &oa, am, &hLSA);

   if (!ret) {
      ret = LsaQueryInformationPolicy(hLSA, PolicyPrimaryDomainInformation, (PVOID *) &pvBuffer);
      LsaClose(hLSA);
      if ((!ret) && (pvBuffer != NULL)) {
         lstrcpy(Domain, pvBuffer->Name.Buffer);
         LsaFreeMemory((PVOID) pvBuffer);
      }
   }

   if (ret)
      return FALSE;
   else
      return TRUE;

} // NTDomainGet


/////////////////////////////////////////////////////////////////////////
BOOL 
IsFPNW(
   LPTSTR ServerName
   )

/*++

Routine Description:

   Checks the given machine for the FPNW secret.

Arguments:


Return Value:


--*/

{
   return (FPNWSecretGet(ServerName) != NULL);

} // IsFPNW


/////////////////////////////////////////////////////////////////////////
BOOL 
IsNTAS(
   LPTSTR ServerName
   )

/*++

Routine Description:

   Checks the given machines registry to determine if it is an NTAS
   system.  The new 'Server' type is also counted as NTAS as all we
   use this for is to determine if local or global groups should be
   used.

Arguments:


Return Value:


--*/

{
   HKEY hKey, hKey2;
   DWORD dwType, dwSize;
   static TCHAR LocServer[MAX_SERVER_NAME_LEN + 3];
   static TCHAR Type[50];
   LONG Status;
   BOOL ret = FALSE;

   wsprintf(LocServer, TEXT("\\\\%s"), ServerName);

   dwSize = sizeof(Type);
   if (RegConnectRegistry(LocServer, HKEY_LOCAL_MACHINE, &hKey) == ERROR_SUCCESS)
      if ((Status = RegOpenKeyEx(hKey, Lids(IDS_S_12), 0, KEY_READ, &hKey2)) == ERROR_SUCCESS)
         if ((Status = RegQueryValueEx(hKey2, Lids(IDS_S_13), NULL, &dwType, (LPBYTE) Type, &dwSize)) == ERROR_SUCCESS)
            if (!lstrcmpi(Type, Lids(IDS_S_14)))
               ret = TRUE;

   RegCloseKey(hKey);
   return ret;

} // IsNTAS


/////////////////////////////////////////////////////////////////////////
VOID 
NTTrustedDomainsEnum(
   LPTSTR ServerName, 
   TRUSTED_DOMAIN_LIST **pTList
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR Serv[MAX_SERVER_NAME_LEN + 3];
   TRUSTED_DOMAIN_LIST *TList = NULL;
   UNICODE_STRING us;
   NTSTATUS ret;
   OBJECT_ATTRIBUTES oa;
   ACCESS_MASK am;
   SECURITY_QUALITY_OF_SERVICE qos;
   LSA_HANDLE hLSA;
   PPOLICY_PRIMARY_DOMAIN_INFO pvBuffer = NULL;
   LSA_ENUMERATION_HANDLE lsaenumh = 0;
   LSA_TRUST_INFORMATION *lsat;
   ULONG maxrequested = 0xffff;
   ULONG cItems;
   ULONG i;

   if (ServerName[0] == TEXT('\\'))
      lstrcpy(Serv, ServerName);
   else
      wsprintf(Serv, TEXT("\\\\%s"), ServerName);

   // Set up unicode string structure
   us.Length = (USHORT)(lstrlen(Serv) * sizeof(TCHAR));
   us.MaximumLength = us.Length + sizeof(TCHAR);
   us.Buffer = Serv;

   // only need read access
   am = POLICY_READ | POLICY_VIEW_LOCAL_INFORMATION;

   // set up quality of service
   qos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
   qos.ImpersonationLevel = SecurityImpersonation;
   qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
   qos.EffectiveOnly = FALSE;

   // Macro sets everything except security field
   InitializeObjectAttributes( &oa, NULL, 0L, NULL, NULL );
   oa.SecurityQualityOfService = &qos;

   ret = LsaOpenPolicy(&us, &oa, am, &hLSA);

   if (!ret) {
      ret = LsaEnumerateTrustedDomains(hLSA, &lsaenumh, (PVOID *) &pvBuffer, maxrequested, &cItems);
      LsaClose(hLSA);
      if ((!ret) && (pvBuffer != NULL)) {
         lsat = (LSA_TRUST_INFORMATION *) pvBuffer;
         TList = (TRUSTED_DOMAIN_LIST *) AllocMemory(sizeof(TRUSTED_DOMAIN_LIST) + (cItems * ((MAX_DOMAIN_NAME_LEN + 1) * sizeof(TCHAR))));
         memset(TList, 0, sizeof(TRUSTED_DOMAIN_LIST) + (cItems * ((MAX_DOMAIN_NAME_LEN + 1) * sizeof(TCHAR))));

         if (TList != NULL) {
            TList->Count = cItems;

            for (i = 0; i < cItems; i++)
               memcpy(TList->Name[i], lsat[i].Name.Buffer, lsat[i].Name.Length);
         }
         LsaFreeMemory((PVOID) pvBuffer);
      }
   }

   *pTList = TList;

} // NTTrustedDomainsEnum


/////////////////////////////////////////////////////////////////////////
DOMAIN_BUFFER *
NTTrustedDomainSet(
   HWND hWnd, 
   LPTSTR Server, 
   LPTSTR TrustedDomain
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   LPTSTR apiPDCName = NULL;
   TCHAR PDCName[MAX_SERVER_NAME_LEN];
   TCHAR LocServer[MAX_SERVER_NAME_LEN + 3];
   static DOMAIN_BUFFER *DBuff;
   NET_API_STATUS Status = 0;

   DBuff = NULL;
   lstrcpy(PDCName, TEXT(""));

   wsprintf(LocServer, TEXT("\\\\%s"), Server);
   Status = NetGetDCName(LocServer, TrustedDomain, (LPBYTE *) &apiPDCName);

   if (!Status) {
      // get rid of leading 2 backslashes
      if (lstrlen(apiPDCName) > 2)
         lstrcpy(PDCName, &apiPDCName[2]);

      if (NTServerValidate(hWnd, PDCName)) {
         // Check if we need to add domain to domain list
         DBuff = DomainListFind(TrustedDomain);

         if (DBuff == NULL) {
            DBuff = DomainListAdd(TrustedDomain, PDCName);
            DBuff->Type = ServInfo->sv101_type;
            DBuff->VerMaj = ServInfo->sv101_version_major;
            DBuff->VerMin = ServInfo->sv101_version_minor;
         }

         DBuff->UseCount++;
      } // if Domain valid

      if (apiPDCName != NULL)
         NetApiBufferFree((LPVOID) apiPDCName);
   }

   // make sure we are pointing to the right one
   NTServerSet(Server);
   return DBuff;

} // NTTrustedDomainSet


/////////////////////////////////////////////////////////////////////////
SID *
NTSIDGet(
   LPTSTR ServerName, 
   LPTSTR pUserName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR lpszDomain[80];
   DWORD dwDomainLength = 80;

   static UCHAR psnuType[1024];
   static SID UserSID[1024];
   DWORD dwSIDBufSize = 1024;
   BOOL Retry = TRUE;

   // Get SID for user
   while (Retry) {
      if (!LookupAccountName(ServerName, pUserName, UserSID, &dwSIDBufSize,
          lpszDomain, &dwDomainLength, (PSID_NAME_USE) psnuType)) {
#ifdef DEBUG
         dprintf(TEXT("Error %d: LookupAccountName\n"), GetLastError());
#endif
         if (GetLastError() == ERROR_NONE_MAPPED)
            if (NTDomainInSynch(ServerName))
               Retry = FALSE;
            else
               Sleep(5000L);

      } else
         return UserSID;
   }

   return NULL;

} // NTSIDGet


#define SD_SIZE (65536 + SECURITY_DESCRIPTOR_MIN_LENGTH)

/////////////////////////////////////////////////////////////////////////
BOOL 
NTFile_AccessRightsAdd(
   LPTSTR ServerName, 
   LPTSTR pUserName, 
   LPTSTR pFileName, 
   ACCESS_MASK AccessMask, 
   BOOL Dir
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NTSTATUS ret;
   SID *pUserSID;

   // File SD variables
   static UCHAR ucSDbuf[SD_SIZE];
   PSECURITY_DESCRIPTOR pFileSD = (PSECURITY_DESCRIPTOR) ucSDbuf;
   DWORD dwSDLengthNeeded = 0;

   // New SD variables
   UCHAR NewSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
   PSECURITY_DESCRIPTOR psdNewSD=(PSECURITY_DESCRIPTOR)NewSD;


   // +-----------------------------------------------------------------+
   // |                             Main Code                           |
   // +-----------------------------------------------------------------+
   pUserSID = NTSIDGet(ServerName, pUserName);
   if (pUserSID == NULL) {
      LogWriteLog(5, Lids(IDS_L_76), GetLastError());
      ErrorIt(Lids(IDS_L_77), GetLastError(), pUserName);
      return FALSE;
   }

   // Get security descriptor (SD) for file
   if(!GetFileSecurity(pFileName, (SECURITY_INFORMATION) (DACL_SECURITY_INFORMATION),
         pFileSD, SD_SIZE, (LPDWORD) &dwSDLengthNeeded)) {
#ifdef DEBUG
      dprintf(TEXT("Error %d: GetFileSecurity\n"), GetLastError());
#endif
      LogWriteLog(5, Lids(IDS_L_76), GetLastError());
      ErrorIt(Lids(IDS_L_77), GetLastError(), pUserName);
      return (FALSE);
   }

   if (Dir)
      ret = ACEAdd(pFileSD, pUserSID, AccessMask, DirRightsMapping.NtAceFlags, &psdNewSD );
   else
      ret = ACEAdd(pFileSD, pUserSID, AccessMask, FileRightsMapping.NtAceFlags, &psdNewSD );

   if (ret) {
#ifdef DEBUG
      dprintf(TEXT("Error %d: NWAddRight\n"), GetLastError());
#endif
      LogWriteLog(5, Lids(IDS_L_76), GetLastError());
      ErrorIt(Lids(IDS_L_77), GetLastError(), pUserName);
      return FALSE;
   }

   // Set the SD to the File
   if (!SetFileSecurity(pFileName, DACL_SECURITY_INFORMATION, psdNewSD)) {
#ifdef DEBUG
      dprintf(TEXT("Error %d: SetFileSecurity\n"), GetLastError());
#endif
      LogWriteLog(5, Lids(IDS_L_76), GetLastError());
      ErrorIt(Lids(IDS_L_77), GetLastError(), pUserName);

      if (psdNewSD != pFileSD)
          NW_FREE(psdNewSD);
      return FALSE;
   }

   // Free the memory allocated for the new ACL, but only if
   // it was allocated.
   if (psdNewSD != pFileSD)
       NW_FREE(psdNewSD);
   return TRUE;

} // NTFile_AccessRightsAdd


/////////////////////////////////////////////////////////////////////////
NTSTATUS 
ACEAdd( 
   PSECURITY_DESCRIPTOR pSD, 
   PSID pSid, 
   ACCESS_MASK AccessMask, 
   ULONG AceFlags, 
   PSECURITY_DESCRIPTOR *ppNewSD 
   )

/*++

Routine Description:

   ACEAdd() - Taken from ChuckC's NWRights.C

Arguments:

     psd - The security desciptor to modify. This must be a valid
           security descriptor.

     psid - The SID of the user/group for which we are adding this right.

     AccessMask - The access mask that we wish to add.

     ppNewSD - used to return the new Security descriptor.

Return Value:

     NTSTATUS code

--*/

{
    ACL  Acl ;
    PACL pAcl, pNewAcl = NULL ;
    PACCESS_ALLOWED_ACE pAccessAce, pNewAce = NULL ;
    NTSTATUS ntstatus ;
    BOOLEAN fDaclPresent, fDaclDefaulted;
    BOOLEAN Found = FALSE;
    LONG i ;

    // validate and initialize 
    if (!pSD || !pSid ||  !ppNewSD || !RtlValidSecurityDescriptor(pSD)) {
#ifdef DEBUG
        dprintf(TEXT("ACEAdd: got invalid parm\n"));
#endif
        return (STATUS_INVALID_PARAMETER) ;
    }

    // if AccessMask == 0, no need to add the ACE

    if( !AccessMask ) {

        *ppNewSD = pSD;
        return( STATUS_SUCCESS );
    }

    *ppNewSD = NULL ;

    // extract the DACL from the securiry descriptor
    ntstatus = RtlGetDaclSecurityDescriptor(pSD, &fDaclPresent, &pAcl, &fDaclDefaulted) ;
    if (!NT_SUCCESS(ntstatus)) {
#ifdef DEBUG
        dprintf(TEXT("ACEAdd: RtlGetDaclSecurityDescriptor failed\n"));
#endif
        goto CleanupAndExit ;
    }

    // if no DACL present, we create one
    if ((!fDaclPresent) || (pAcl == NULL)) {
        // create Dacl
        ntstatus = RtlCreateAcl(&Acl, sizeof(Acl), ACL_REVISION) ; 

        if (!NT_SUCCESS(ntstatus)) {
#ifdef DEBUG
            dprintf(TEXT("ACEAdd: RtlCreateAcl failed\n"));
#endif
            goto CleanupAndExit ;
        }

        pAcl = &Acl ;
    }   

    // loop thru ACEs, looking for entry with the user/group SID
    pAccessAce = NULL ;
    for (i = 0; i < pAcl->AceCount; i++) {
        ACE_HEADER *pAce ;

        ntstatus = RtlGetAce(pAcl,i,&pAce) ;

        if (!NT_SUCCESS(ntstatus)) {
#ifdef DEBUG
            dprintf(TEXT("ACEAdd: RtlGetAce failed\n"));
#endif
            goto CleanupAndExit ;
        }

        if (pAce->AceType == ACCESS_ALLOWED_ACE_TYPE) {
            // found a granting ace, which is what we want
            PSID pAceSid ;

            pAccessAce = (ACCESS_ALLOWED_ACE *) pAce ;
            pAceSid = (PSID) &pAccessAce->SidStart ;

            //
            // is this the same SID?
            // if yes, modify access mask and carry on.
            //
            if (RtlEqualSid(pAceSid, pSid)) {

                ACCESS_MASK access_mask ;

                ASSERT(pAccessAce != NULL) ;

                access_mask = pAccessAce->Mask ;

                if ( (access_mask & AccessMask) == access_mask ) {
                    ntstatus = STATUS_MEMBER_IN_GROUP ;
                    goto CleanupAndExit ;
                }

                pAccessAce->Mask = AccessMask ;
                Found = TRUE ;
            }
        } else {
            // ignore it. we only deal with granting aces.
        }
    }

    if ( !Found ) {         // now set the DACL to have the desired rights
            // reached end of ACE list without finding match. so we need to
            // create a new ACE.
            USHORT NewAclSize, NewAceSize ;
      
            // calculate the sizes
            NewAceSize = (USHORT)(sizeof(ACE_HEADER) +
                              sizeof(ACCESS_MASK) +
                              RtlLengthSid(pSid));

            NewAclSize = pAcl->AclSize + NewAceSize ;

            // allocate new ACE and new ACL (since we are growing it)
            pNewAce = (PACCESS_ALLOWED_ACE) NW_ALLOC(NewAceSize) ;
            if (!pNewAce) {
    #ifdef DEBUG
                dprintf(TEXT("ACEAdd: memory allocation failed for new ACE\n"));
    #endif
                ntstatus = STATUS_INSUFFICIENT_RESOURCES ;
                goto CleanupAndExit ;
            }

            pNewAce->Header.AceFlags = (UCHAR)AceFlags;
            pNewAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
            pNewAce->Header.AceSize = NewAceSize;
            pNewAce->Mask = AccessMask;  
            RtlCopySid( RtlLengthSid(pSid), (PSID)(&pNewAce->SidStart), pSid );

            pNewAcl = (PACL) NW_ALLOC(NewAclSize) ;
            if (!pNewAcl) {
    #ifdef DEBUG
                dprintf(TEXT("ACEAdd: memory allocation failed for new ACL\n"));
    #endif
                ntstatus = STATUS_INSUFFICIENT_RESOURCES ;
                goto CleanupAndExit ;
            }
       
            RtlCopyMemory(pNewAcl, pAcl, pAcl->AclSize) ;
            pNewAcl->AclSize = NewAclSize ;

            // Add the ACE to the end of the ACL
            ntstatus = RtlAddAce(pNewAcl, ACL_REVISION, pNewAcl->AceCount, pNewAce, NewAceSize) ;

            if (!NT_SUCCESS(ntstatus)) {
    #ifdef DEBUG
                dprintf(TEXT("ACEAdd: RtlAddAce failed\n"));
    #endif
                goto CleanupAndExit ;
            }

            pAcl = pNewAcl ;
    }

 

    // set the dacl back into the security descriptor. we need create
    // a new security descriptor, since the old one may not have space
    // for any additional ACE.
    ntstatus = CreateNewSecurityDescriptor(ppNewSD, pSD, pAcl) ;

    if (!NT_SUCCESS(ntstatus)) {
#ifdef DEBUG
        dprintf(TEXT("ACEAdd: CreateNewSecurityDescriptor failed\n"));
#endif
    }

CleanupAndExit:

    if (pNewAcl)
        NW_FREE(pNewAcl) ;

    if (pNewAce)
        NW_FREE(pNewAce) ;

    return ntstatus ;
} // ACEAdd


/////////////////////////////////////////////////////////////////////////
NTSTATUS 
CreateNewSecurityDescriptor( 
   PSECURITY_DESCRIPTOR *ppNewSD, 
   PSECURITY_DESCRIPTOR pSD, 
   PACL pAcl
   )

/*++

Routine Description:

   From a SD and a Dacl, create a new SD. The new SD will be fully self
   contained (it is self relative) and does not have pointers to other
   structures.

Arguments:

     ppNewSD - used to return the new SD. Caller should free with NW_FREE

     pSD     - the self relative SD we use to build the new SD

     pAcl    - the new DACL that will be used for the new SD

Return Value:

     NTSTATUS code

--*/

{
    PACL pSacl ;
    PSID psidGroup, psidOwner ;
    BOOLEAN fSaclPresent ;
    BOOLEAN fSaclDefaulted, fGroupDefaulted, fOwnerDefaulted ;
    ULONG NewSDSize ;
    SECURITY_DESCRIPTOR NewSD ;
    PSECURITY_DESCRIPTOR pNewSD ;
    NTSTATUS ntstatus ;


    // extract the originals from the securiry descriptor
    ntstatus = RtlGetSaclSecurityDescriptor(pSD, &fSaclPresent, &pSacl, &fSaclDefaulted) ;
    if (!NT_SUCCESS(ntstatus))
        return ntstatus ;

    ntstatus = RtlGetOwnerSecurityDescriptor(pSD, &psidOwner, &fOwnerDefaulted) ;
    if (!NT_SUCCESS(ntstatus))
        return ntstatus ;

    ntstatus = RtlGetGroupSecurityDescriptor(pSD, &psidGroup, &fGroupDefaulted) ;
    if (!NT_SUCCESS(ntstatus))
        return ntstatus ;

    // now create a new SD and set the info in it. we cannot return this one
    // since it has pointers to old SD.
    ntstatus = RtlCreateSecurityDescriptor(&NewSD, SECURITY_DESCRIPTOR_REVISION) ;
    if (!NT_SUCCESS(ntstatus))
        return ntstatus ;

    ntstatus = RtlSetDaclSecurityDescriptor(&NewSD, TRUE, pAcl, FALSE) ; 

    if (!NT_SUCCESS(ntstatus))
        return ntstatus ;

    ntstatus = RtlSetSaclSecurityDescriptor(&NewSD, fSaclPresent, pSacl, fSaclDefaulted) ;
    if (!NT_SUCCESS(ntstatus))
        return ntstatus ;

    ntstatus = RtlSetOwnerSecurityDescriptor(&NewSD, psidOwner, fOwnerDefaulted) ; 
    if (!NT_SUCCESS(ntstatus))
       return ntstatus ;

    ntstatus = RtlSetGroupSecurityDescriptor(&NewSD, psidGroup, fGroupDefaulted) ; 
    if (!NT_SUCCESS(ntstatus))
        return ntstatus ;

    // calculate size needed for the returned SD and allocated it
    NewSDSize = RtlLengthSecurityDescriptor(&NewSD) ;

    pNewSD = (PSECURITY_DESCRIPTOR) NW_ALLOC(NewSDSize) ;

    if (!pNewSD)
        return (STATUS_INSUFFICIENT_RESOURCES) ;

    // convert the absolute to self relative
    ntstatus = RtlAbsoluteToSelfRelativeSD(&NewSD, pNewSD, &NewSDSize) ;

    if (NT_SUCCESS(ntstatus))
        *ppNewSD = pNewSD ;
    else
        NW_FREE(pNewSD) ;

    return ntstatus ;
} // CreateNewSecurityDescriptor


/////////////////////////////////////////////////////////////////////////
LPTSTR 
NTAccessLog(
   ACCESS_MASK AccessMask
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR AccessDesc[80];
   TCHAR AccessStr[80];

   if (AccessMask == 0) {
      lstrcpy(AccessDesc, Lids(IDS_L_78));
      return AccessDesc;
   } else
      if ((AccessMask & GENERIC_ALL) == GENERIC_ALL) {
         lstrcpy(AccessDesc, Lids(IDS_L_79));
         return AccessDesc;
      } else {
         lstrcpy(AccessStr, TEXT("("));

         if ((AccessMask & GENERIC_READ) == GENERIC_READ)
            lstrcat(AccessStr, Lids(IDS_L_80));

         if ((AccessMask & GENERIC_WRITE) == GENERIC_WRITE)
            lstrcat(AccessStr, Lids(IDS_L_81));

         if ((AccessMask & GENERIC_EXECUTE) == GENERIC_EXECUTE)
            lstrcat(AccessStr, Lids(IDS_L_82));

         if ((AccessMask & DELETE) == DELETE)
            lstrcat(AccessStr, Lids(IDS_L_83));

         if ((AccessMask & WRITE_DAC) == WRITE_DAC)
            lstrcat(AccessStr, Lids(IDS_L_84));

         lstrcat(AccessStr, TEXT(")"));

         // Figured out the individual rights, now need to see if this corresponds
         // to a generic mapping
         if (!lstrcmpi(AccessStr, Lids(IDS_L_85))) {
            lstrcpy(AccessDesc, Lids(IDS_L_86));
            return AccessDesc;
         }

         if (!lstrcmpi(AccessStr, Lids(IDS_L_87))) {
            lstrcpy(AccessDesc, Lids(IDS_L_88));
            return AccessDesc;
         }

         if (!lstrcmpi(AccessStr, Lids(IDS_L_89))) {
            lstrcpy(AccessDesc, Lids(IDS_L_90));
            return AccessDesc;
         }

         if (!lstrcmpi(AccessStr, Lids(IDS_L_91))) {
            lstrcpy(AccessDesc, Lids(IDS_L_92));
            return AccessDesc;
         }

         wsprintf(AccessDesc, Lids(IDS_L_93), AccessStr);
      }

   return AccessDesc;

} // NTAccessLog


/////////////////////////////////////////////////////////////////////////
VOID 
NTUserDefaultsGet(
   NT_DEFAULTS **UDefaults
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   USER_MODALS_INFO_0 *NTDefaults = NULL;
   NET_API_STATUS Status = 0;

   if (LocalMachine)
      Status = NetUserModalsGet(NULL,  0, (LPBYTE *) &NTDefaults);
   else
      Status = NetUserModalsGet(CachedServer, 0, (LPBYTE *) &NTDefaults);

   if (Status) {
      NTDefaults = NULL;
      return;
   }

   *UDefaults = (NT_DEFAULTS *) NTDefaults;
} // NTUserDefaultsGet


/////////////////////////////////////////////////////////////////////////
DWORD 
NTUserDefaultsSet(
   NT_DEFAULTS NTDefaults
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NET_API_STATUS Status = 0;
   DWORD err;

   if (LocalMachine)
      Status = NetUserModalsSet(NULL,  0, (LPBYTE) &NTDefaults, &err);
   else
      Status = NetUserModalsSet(CachedServer, 0, (LPBYTE) &NTDefaults, &err);

   return Status;

} // NTUserDefaultsSet


/////////////////////////////////////////////////////////////////////////
VOID 
NTUserDefaultsLog(
   NT_DEFAULTS UDefaults
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   LogWriteLog(1, Lids(IDS_L_94), UDefaults.min_passwd_len);

   // Age is in seconds, convert to days
   LogWriteLog(1, Lids(IDS_L_95), UDefaults.max_passwd_age / 86400);
   LogWriteLog(1, Lids(IDS_L_96), UDefaults.force_logoff);
   LogWriteLog(0, Lids(IDS_CRLF));
} // NTUserDefaultsLog
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\nwconv.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _HNWCONV_
#define _HNWCONV_

#ifdef __cplusplus
extern "C"{
#endif

extern TCHAR NT_PROVIDER[];
extern TCHAR NW_PROVIDER[];

// Common utility routines
void CanonServerName(LPTSTR ServerName);

extern HINSTANCE hInst;         // current instance
extern TCHAR ProgPath[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\nwconv.c ===
/*++

Copyright (c) 1993-1995  Microsoft Corporation

Module Name:

   nwconv.c

Abstract:


Author:

    Arthur Hanson (arth) 16-Jun-1994

Revision History:

--*/


#include "globals.h"

#include "nwconv.h"
#include "convapi.h"
#include "userdlg.h"
#include "filedlg.h"
#include "transfer.h"
#include "columnlb.h"
#include "ntnetapi.h"
#include "nwnetapi.h"

HINSTANCE hInst;            // current instance

TCHAR szAppName[] = TEXT("NWConv");   // The name of this application
TCHAR ProgPath[MAX_PATH + 1];

TCHAR NT_PROVIDER[60];
TCHAR NW_PROVIDER[60];
TCHAR NW_SERVICE_NAME[80];

#define DEF_CONFIG_FILE TEXT("NWConv.DAT")

// version as x.yz expressed as xyz (no decimal point).
#define CONFIG_VER 026
#define CHECK_CONST 0xA5A56572

SOURCE_SERVER_BUFFER *lpSourceServer;
DEST_SERVER_BUFFER *lpDestServer;

BOOL TrialConversion = TRUE;
BOOL IsNetWareBrowse;
BOOL FirstTime = TRUE;
HICON MyIcon;
UINT NumServerPairs = 0;
HWND hDlgMain;

HHOOK hhkMsgFilter = NULL;
UINT wHelpMessage;

UINT   uMenuID;
HMENU  hMenu;
UINT   uMenuFlags;

#ifdef DEBUG
int DebugFlag = 0;
#endif

CONVERT_LIST *ConvertListStart = NULL;
CONVERT_LIST *ConvertListEnd = NULL;
CONVERT_LIST *CurrentConvertList = NULL;
int TotalConvertCount = 0;

SOURCE_SERVER_BUFFER *SServListStart = NULL;
SOURCE_SERVER_BUFFER *SServListEnd = NULL;
SOURCE_SERVER_BUFFER *SServListCurrent = NULL;
DEST_SERVER_BUFFER *DServListStart = NULL;
DEST_SERVER_BUFFER *DServListEnd = NULL;
DEST_SERVER_BUFFER *DServListCurrent = NULL;
DOMAIN_BUFFER *DomainListStart = NULL;
DOMAIN_BUFFER *DomainListEnd = NULL;

BOOL SuccessfulConversion = FALSE;
BOOL ViewLogs = FALSE;
BOOL InConversion = FALSE;

/*+-------------------------------------------------------------------------+
  | Function Prototypes.                                                    |
  +-------------------------------------------------------------------------+*/
LRESULT CALLBACK DlgUsers(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK DlgMoveIt(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
VOID AboutBox_Do(HWND hDlg);
VOID ToggleControls(HWND hDlg, BOOL Toggle);


/////////////////////////////////////////////////////////////////////////
VOID NTServInfoDlg_SwitchControls(
   HWND hDlg, 
   BOOL Toggle
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   HWND hCtrl;

   // The NW Controls
   hCtrl = GetDlgItem(hDlg, IDC_T_VOLUMES);
   ShowWindow(hCtrl, Toggle);
   EnableWindow(hCtrl, Toggle);

   hCtrl = GetDlgItem(hDlg, IDC_LIST3);
   ShowWindow(hCtrl, Toggle);
   EnableWindow(hCtrl, Toggle);

   // The NT Controls
   hCtrl = GetDlgItem(hDlg, IDC_LIST1);
   ShowWindow(hCtrl, !Toggle);
   EnableWindow(hCtrl, !Toggle);

   hCtrl = GetDlgItem(hDlg, IDC_LIST2);
   ShowWindow(hCtrl, !Toggle);
   EnableWindow(hCtrl, !Toggle);

   hCtrl = GetDlgItem(hDlg, IDC_T_DRIVES);
   ShowWindow(hCtrl, !Toggle);
   EnableWindow(hCtrl, !Toggle);

   hCtrl = GetDlgItem(hDlg, IDC_T_SHARES);
   ShowWindow(hCtrl, !Toggle);
   EnableWindow(hCtrl, !Toggle);

} // NTServInfoDlg_SwitchControls


/////////////////////////////////////////////////////////////////////////
VOID
NTServInfoDlg_EnableNT(
   HWND hDlg
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   TCHAR VerStr[TMP_STR_LEN_256];

   SetDlgItemText(hDlg, IDC_TYPE, Lids(IDS_S_15));
   wsprintf(VerStr, TEXT("%lu.%lu"), CurrentConvertList->FileServ->VerMaj, CurrentConvertList->FileServ->VerMin);
   SetDlgItemText(hDlg, IDC_VERSION, VerStr);

   NTServInfoDlg_SwitchControls(hDlg, FALSE);

} // NTServInfoDlg_EnableNT


/////////////////////////////////////////////////////////////////////////
VOID 
NTServInfoDlg_EnableNW(
   HWND hDlg
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   TCHAR VerStr[TMP_STR_LEN_256];

   SetDlgItemText(hDlg, IDC_TYPE, Lids(IDS_S_16));
   wsprintf(VerStr, TEXT("%u.%u"), CurrentConvertList->SourceServ->VerMaj, CurrentConvertList->SourceServ->VerMin);
   SetDlgItemText(hDlg, IDC_VERSION, VerStr);

   NTServInfoDlg_SwitchControls(hDlg, TRUE);

} // NTServInfoDlg_EnableNW


/////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK 
NTServInfoDlg(
   HWND hDlg, 
   UINT message, 
   WPARAM wParam, 
   LPARAM lParam
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR AddLine[TMP_STR_LEN_256];
   HWND hCtrl;
   UINT_PTR dwData, dwIndex;
   int wmId, wmEvent;
   ULONG i;
   DRIVE_LIST *DriveList;
   SHARE_LIST *ShareList;

   switch (message) {
      case WM_INITDIALOG:
         // Center the dialog over the application window
         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));

         // Add the servers to the combo-box and select the source server
         hCtrl = GetDlgItem(hDlg, IDC_COMBO1);
         dwIndex = SendMessage(hCtrl, CB_ADDSTRING, (WPARAM) 0, (LPARAM) CurrentConvertList->FileServ->Name);
         SendMessage(hCtrl, CB_SETITEMDATA, (WPARAM) dwIndex, (LPARAM) CurrentConvertList->FileServ);
         dwIndex = SendMessage(hCtrl, CB_ADDSTRING, (WPARAM) 0, (LPARAM) CurrentConvertList->SourceServ->Name);
         SendMessage(hCtrl, CB_SETITEMDATA, (WPARAM) dwIndex, (LPARAM) CurrentConvertList->SourceServ);

         SendMessage(hCtrl, CB_SELECTSTRING, (WPARAM) -1, (LPARAM) CurrentConvertList->SourceServ->Name);

         PostMessage(hDlg, WM_COMMAND, ID_INIT, 0L);
         return (TRUE);

      case WM_COMMAND:
         wmId    = LOWORD(wParam);
         wmEvent = HIWORD(wParam);

         switch (wmId) {
            case IDOK:
               EndDialog(hDlg, 0);
               return (TRUE);
               break;

            case ID_INIT:
               // Fill in the Drive and share lists for NT system
               hCtrl = GetDlgItem(hDlg, IDC_LIST1);
               DriveList = CurrentConvertList->FileServ->DriveList;
               if (DriveList != NULL) {
                  for (i = 0; i < DriveList->Count; i++) {
                     wsprintf(AddLine, TEXT("%s: [%4s] %s"), DriveList->DList[i].Drive, DriveList->DList[i].DriveType, DriveList->DList[i].Name);
                     SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) AddLine);

                     wsprintf(AddLine, Lids(IDS_S_17), lToStr(DriveList->DList[i].FreeSpace));
                     SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) AddLine);
                  }
               }

               hCtrl = GetDlgItem(hDlg, IDC_LIST2);
               ShareList = CurrentConvertList->FileServ->ShareList;
               if (ShareList != NULL)
                  for (i = 0; i < ShareList->Count; i++) {
                     SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) ShareList->SList[i].Name);
                     wsprintf(AddLine, Lids(IDS_S_18), ShareList->SList[i].Path);
                     SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) AddLine);
                  }


               hCtrl = GetDlgItem(hDlg, IDC_LIST3);
               ShareList = CurrentConvertList->SourceServ->ShareList;
               if (ShareList != NULL)
                  for (i = 0; i < ShareList->Count; i++) {
                     SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) ShareList->SList[i].Name);
                     wsprintf(AddLine, Lids(IDS_S_19), lToStr(ShareList->SList[i].Size));
                     SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) AddLine);
                  }


               PostMessage(hDlg, WM_COMMAND, ID_UPDATECOMBO, 0L);
               break;

            case ID_UPDATECOMBO:
               hCtrl = GetDlgItem(hDlg, IDC_COMBO1);
               dwIndex = SendMessage(hCtrl, CB_GETCURSEL, 0, 0L);

               if (dwIndex != CB_ERR) {
                  dwData = SendMessage(hCtrl, CB_GETITEMDATA, dwIndex, 0L);
                  if (dwData == (UINT_PTR) CurrentConvertList->FileServ)
                     NTServInfoDlg_EnableNT(hDlg);

                  if (dwData == (UINT_PTR) CurrentConvertList->SourceServ)
                     NTServInfoDlg_EnableNW(hDlg);

               }
               break;

            case IDC_COMBO1:
               if (wmEvent == CBN_SELCHANGE)
                  PostMessage(hDlg, WM_COMMAND, ID_UPDATECOMBO, 0L);

               break;

         }

         break;
   }

   return (FALSE); // Didn't process the message

   lParam;
} // NTServInfoDlg


/////////////////////////////////////////////////////////////////////////
VOID 
NTServInfoDlg_Do(
   HWND hDlg
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   DLGPROC lpfnDlg;

   lpfnDlg = MakeProcInstance((DLGPROC)NTServInfoDlg, hInst);
   DialogBox(hInst, TEXT("NTServInfo"), hDlg, lpfnDlg) ;
   FreeProcInstance(lpfnDlg);

} // NTServInfoDlg_Do


/////////////////////////////////////////////////////////////////////////
VOID 
MainListbox_Add(
   HWND hDlg, 
   DWORD_PTR Data, 
   LPTSTR SourceServ, 
   LPTSTR DestServ
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   TCHAR AddLine[256];
   CONVERT_LIST *ptr;
   CONVERT_LIST *nptr = NULL;
   DWORD_PTR dwData, ret;
   DWORD wItemNum = 0;
   HWND hCtrl;
   BOOL match = FALSE;
   ULONG_PTR nPairs;

   // We want to insert this after any any other conversion to this source
   // machine - unfortuantly it is cumbersome to do this.
   hCtrl = GetDlgItem(hDlg, IDC_LIST1);

   // start count at one less as it will always be one ahead of us
   nPairs = SendMessage(hCtrl, LB_GETCOUNT, 0, 0L);

   // Try to find a matching destination server for this in the listbox
   ptr = (CONVERT_LIST *) Data;
   while((wItemNum < nPairs) && !match) {
      dwData = ColumnLB_GetItemData(hCtrl, wItemNum);
      if (dwData != LB_ERR) {
         nptr = (CONVERT_LIST *) dwData;
         if (!lstrcmpi(ptr->FileServ->Name, nptr->FileServ->Name))
            match = TRUE;
      }

      if (!match)
         wItemNum++;
   }

   if (match) {
      // have a match - so go to the end of the matching servers...
      while((wItemNum < nPairs) && match) {
         dwData = ColumnLB_GetItemData(hCtrl, wItemNum);
         if (dwData != LB_ERR) {
            nptr = (CONVERT_LIST *) dwData;
            if (lstrcmpi(ptr->FileServ->Name, nptr->FileServ->Name))
               match = FALSE;
         }

         if (match)
            wItemNum++;
      }

   } else {
      if (ptr->FileServ->InDomain && ptr->FileServ->Domain) {
         wItemNum = 0;

         // No matching servers, so try to find matching domain
         while((wItemNum < nPairs) && !match) {
            dwData = ColumnLB_GetItemData(hCtrl, wItemNum);
            if (dwData != LB_ERR) {
               nptr = (CONVERT_LIST *) dwData;

               if (nptr->FileServ->InDomain && nptr->FileServ->Domain)
                  if (!lstrcmpi(ptr->FileServ->Domain->Name, nptr->FileServ->Domain->Name))
                     match = TRUE;
            }

            if (!match)
               wItemNum++;
         }

         if (match) {
            // have a match - so go to the end of the matching domain...
            while((wItemNum < nPairs) && match) {
               dwData = ColumnLB_GetItemData(hCtrl, wItemNum);
               if (dwData != LB_ERR) {
                  nptr = (CONVERT_LIST *) dwData;

                  if (nptr->FileServ->InDomain && nptr->FileServ->Domain) {
                     if (lstrcmpi(ptr->FileServ->Domain->Name, nptr->FileServ->Domain->Name))
                        match = FALSE;
                  } else
                     match = FALSE;
               }

               if (match)
                  wItemNum++;
            }
         } 
      } // if domain
   }

   wsprintf(AddLine, TEXT("%s\t%s\t"), SourceServ, DestServ);

   wItemNum = ColumnLB_InsertString(hCtrl, wItemNum, AddLine);
   ret = ColumnLB_SetItemData(hCtrl, wItemNum, Data);
   ColumnLB_SetCurSel(hCtrl, wItemNum);

} // MainListbox_Add


/////////////////////////////////////////////////////////////////////////
VOID 
ConfigurationReset(
   HWND hDlg
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   // Remove the listbox entries
   ColumnLB_ResetContent(GetDlgItem(hDlg, IDC_LIST1));

   ToggleControls(hDlg, FALSE);
   SetFocus(GetDlgItem(hDlg, IDC_ADD));

   ConvertListDeleteAll();
   UserOptionsDefaultsReset();
   FileOptionsDefaultsReset();
   LogOptionsInit();
   
} // ConfigurationReset


/////////////////////////////////////////////////////////////////////////
VOID 
ConfigurationSave(
   LPTSTR FileName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   DWORD wrote;
   HANDLE hFile;
   CHAR FileNameA[MAX_PATH + 1];
   DWORD Check, Ver;

   WideCharToMultiByte(CP_ACP, 0, FileName, -1, FileNameA, sizeof(FileNameA), NULL, NULL);

   // Create it no matter what
   hFile = CreateFileA( FileNameA, GENERIC_WRITE, 0,
                  NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

   if (hFile != INVALID_HANDLE_VALUE) {
      // Save out our check value and the version info
      Check = CHECK_CONST;
      WriteFile(hFile, &Check, sizeof(Check), &wrote, NULL);
      Ver = CONFIG_VER;
      WriteFile(hFile, &Ver, sizeof(Ver), &wrote, NULL);

      // Save global log file options
      LogOptionsSave(hFile);
         
      // Save out convert Lists
      ConvertListSaveAll(hFile);

   }

   if (hFile != INVALID_HANDLE_VALUE)
      CloseHandle(hFile);

   return;

} // ConfigurationSave


/////////////////////////////////////////////////////////////////////////
VOID 
ConfigurationLoad(
   HWND hDlg, 
   LPTSTR FileName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR AddLine[256];
   DWORD wrote;
   HANDLE hFile;
   CHAR FileNameA[MAX_PATH + 1];
   DWORD Check, Ver;

   WideCharToMultiByte(CP_ACP, 0, FileName, -1, FileNameA, sizeof(FileNameA), NULL, NULL);

   // Open, but fail if already exists.
   hFile = CreateFileA( FileNameA, GENERIC_READ, 0,
                  NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

   if (hFile != INVALID_HANDLE_VALUE) {
      ConfigurationReset(hDlg);
      ReadFile(hFile, &Check, sizeof(Check), &wrote, NULL);

      if (Check != CHECK_CONST) {
         CloseHandle(hFile);
         ErrorBox(Lids(IDS_E_10));
         return;
      }

      ReadFile(hFile, &Ver, sizeof(Ver), &wrote, NULL);

      if (Ver != CONFIG_VER) {
         CloseHandle(hFile);
         ErrorBox(Lids(IDS_E_11));
         return;
      }

      LogOptionsLoad(hFile);

      // Load in convert list and all associated info...
      ConvertListLoadAll(hFile);

      // Everything from the file is loaded in - but now the painful part
      // begins.  We need to take the following steps:
      //
      //    1. Walk all lists and refix pointers from their index
      //    2. Re-Validate servers, shares, domains, etc. to make sure they
      //       haven't changed underneath us since we saved out the file.
      //    3. Re-create info that wasn't saved out (like drive lists).

      // 1. Walk and refix lists
      ConvertListFixup(hDlg);

      // Now add them to the listbox
      CurrentConvertList = ConvertListStart;
      while (CurrentConvertList) {
         MainListbox_Add(hDlg, (DWORD_PTR) CurrentConvertList, CurrentConvertList->SourceServ->Name, CurrentConvertList->FileServ->Name);
         CurrentConvertList = CurrentConvertList->next;
      }

      // Re-enable all the toggles
      if (NumServerPairs)
         PostMessage(hDlg, WM_COMMAND, (WPARAM) IDM_ADDSEL, 0);

   }

   if (hFile != INVALID_HANDLE_VALUE)
      CloseHandle(hFile);

   return;

} // ConfigurationLoad


/////////////////////////////////////////////////////////////////////////
VOID 
CanonServerName(
   LPTSTR ServerName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   LPTSTR TmpStr = ServerName;

   while (*TmpStr == TEXT('\\'))
      TmpStr++;

   lstrcpy(ServerName, TmpStr);

} // CanonServerName


/////////////////////////////////////////////////////////////////////////
int 
MessageFilter(
   INT nCode, 
   WPARAM wParam, 
   LPMSG lpMsg
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   if (nCode < 0)
      goto DefHook;

   if (nCode == MSGF_MENU) {

      if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_F1) {
         // Window of menu we want help for is in loword of lParam.

         PostMessage(hDlgMain, wHelpMessage, MSGF_MENU, (LPARAM)lpMsg->hwnd);
         return 1;
      }

   }
   else
      if (nCode == MSGF_DIALOGBOX) {

         if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_F1) {
            // Dialog box we want help for is in loword of lParam

            PostMessage(hDlgMain, wHelpMessage, MSGF_DIALOGBOX, (LPARAM)lpMsg->hwnd);
            return 1;
         }

      } else

DefHook:
         return (INT)DefHookProc(nCode, wParam, (DWORD_PTR)lpMsg, &hhkMsgFilter);

  return 0;
} // MessageFilter


/////////////////////////////////////////////////////////////////////////
int APIENTRY 
WinMain( 
   HINSTANCE hInstance, 
   HINSTANCE hPrevInstance, 
   LPSTR lpCmdLine, 
   int nCmdShow
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   LPTSTR ptr;
   DLGPROC lpproc;
   HACCEL haccel;
   MSG msg;

   hInst = hInstance;

   if (!hPrevInstance) {
      BookTab_Initialize(hInst);
      ColumnLBClass_Register(hInst);
   }

   MultiByteToWideChar(CP_ACP, 0, _pgmptr, -1, ProgPath, sizeof(ProgPath) );

   // go to the end and rewind to remove program name
   ptr = ProgPath;
   while (*ptr)
      ptr++;

   while (*ptr != TEXT('\\'))
      ptr--;

      ptr++;

   *ptr = TEXT('\0');

   MemInit();
   MyIcon = LoadIcon(hInst, szAppName);

   lpproc = MakeProcInstance((DLGPROC) DlgMoveIt, hInst);
   hDlgMain = CreateDialog(hInst, szAppName, NULL, lpproc);
   wHelpMessage = RegisterWindowMessage(TEXT("ShellHelp"));
   haccel = LoadAccelerators(hInst, TEXT("MainAcc"));
   hhkMsgFilter = SetWindowsHook(WH_MSGFILTER, (HOOKPROC)MessageFilter);

   while (GetMessage(&msg, NULL, 0, 0)) {
      if (!TranslateAccelerator(hDlgMain, haccel, &msg))
         if ((hDlgMain == 0) || !IsDialogMessage(hDlgMain, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
         }
   }

   FreeProcInstance(lpproc);

   ColumnLBClass_Unregister(hInst);
   DestroyIcon(MyIcon);
   StringTableDestroy();

   return (int) msg.wParam;

} // WinMain


/////////////////////////////////////////////////////////////////////////
VOID 
ToggleControls(
   HWND hDlg, 
   BOOL Toggle
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   HWND hCtrl;

   hCtrl = GetDlgItem(hDlg, IDOK);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_TRIAL);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_DELETE);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_USERINF);
   EnableWindow(hCtrl, Toggle);

   hCtrl = GetDlgItem(hDlg, IDC_FILEINF);
   EnableWindow(hCtrl, Toggle);

} // ToggleControls


/////////////////////////////////////////////////////////////////////////
DWORD 
ConfigFileGet(
   HWND hwnd
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   OPENFILENAME ofn;
   TCHAR szDirName[MAX_PATH+1];
   TCHAR szFile[256], szFileTitle[256];
   UINT i, cbString;
   TCHAR chReplace;
   TCHAR szFilter[256];
   LPTSTR szExt = TEXT("CNF");

   lstrcpy(szDirName, ProgPath);
   lstrcpy(szFile, TEXT(""));

   if ((cbString = LoadString(hInst, IDS_MAINFILTERSTRING, szFilter, sizeof(szFilter))) == 0) {
      // Error occured
      return 1L;
   }

   chReplace = szFilter[cbString - 1];    // Retrieve wild character

   for (i = 0; szFilter[i] != TEXT('\0'); i++) {
      if (szFilter[i] == chReplace)
         szFilter[i] = TEXT('\0');
   }

   // Set all structure members to zero
   memset(&ofn, 0, sizeof(OPENFILENAME));

   ofn.lStructSize = sizeof(OPENFILENAME);
   ofn.hwndOwner = hwnd;
   ofn.lpstrFilter = szFilter;
   ofn.nFilterIndex = 1;
   ofn.lpstrFile = szFile;
   ofn.nMaxFile = sizeof(szFile);
   ofn.lpstrFileTitle = szFileTitle;
   ofn.nMaxFileTitle = sizeof(szFileTitle);
   ofn.lpstrInitialDir = szDirName;
   ofn.lpstrDefExt = szExt;
   ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_NOCHANGEDIR;

   if (GetOpenFileName(&ofn)) {
      // Load the configuration
      ConfigurationLoad(hwnd, ofn.lpstrFile);
      return 0L;
   } else {
      // Couldn't open the dang file
      return 1L;
   }

} // ConfigFileGet


/////////////////////////////////////////////////////////////////////////
DWORD 
ConfigFileSave(
   HWND hwnd
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   OPENFILENAME ofn;
   TCHAR szDirName[MAX_PATH + 1];
   TCHAR szFile[MAX_PATH + 1], szFileTitle[MAX_PATH + 1];
   UINT i, cbString;
   TCHAR chReplace;
   TCHAR szFilter[256];
   LPTSTR szExt;
   
   szExt = Lids(IDS_S_20);

   lstrcpy(szDirName, ProgPath);
   lstrcpy(szFile, TEXT(""));

   if ((cbString = LoadString(hInst, IDS_MAINFILTERSTRING, szFilter, sizeof(szFilter))) == 0) {
      // Error occured
      return 1L;
   }

   chReplace = szFilter[cbString - 1];    // Retrieve wild character

   for (i = 0; szFilter[i] != TEXT('\0'); i++) {
      if (szFilter[i] == chReplace)
         szFilter[i] = TEXT('\0');
   }

   // Set all structure members to zero
   memset(&ofn, 0, sizeof(OPENFILENAME));

   ofn.lStructSize = sizeof(OPENFILENAME);
   ofn.hwndOwner = hwnd;
   ofn.lpstrFilter = szFilter;
   ofn.nFilterIndex = 1;
   ofn.lpstrFile = szFile;
   ofn.nMaxFile = sizeof(szFile);
   ofn.lpstrFileTitle = szFileTitle;
   ofn.nMaxFileTitle = sizeof(szFileTitle);
   ofn.lpstrInitialDir = szDirName;
   ofn.lpstrDefExt = szExt;
   ofn.Flags = OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY | OFN_NOCHANGEDIR | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;

   if (GetSaveFileName(&ofn)) {
      // Save Configuration
      ConfigurationSave( ofn.lpstrFile);
      return 0L;
   } else {
      // Couldn't save it
      return 1L;
   }

} // ConfigFileSave


/////////////////////////////////////////////////////////////////////////
BOOL 
ProvidersInit() 

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   HKEY hKey;
   DWORD dwType, dwSize;
   LONG Status;
   BOOL ret = FALSE;

   dwSize = sizeof(NW_PROVIDER);
   if ((Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, Lids(IDS_S_23), 0, KEY_READ, &hKey)) == ERROR_SUCCESS)
      if ((Status = RegQueryValueEx(hKey, Lids(IDS_S_21), NULL, &dwType, (LPBYTE) NW_PROVIDER, &dwSize)) == ERROR_SUCCESS)
         ret = TRUE;

   RegCloseKey(hKey);

   if (ret) {
      ret = FALSE;
      hKey = 0;
      dwSize = sizeof(NT_PROVIDER);
      if ((Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, Lids(IDS_S_25), 0, KEY_READ, &hKey)) == ERROR_SUCCESS)
         if ((Status = RegQueryValueEx(hKey, Lids(IDS_S_21), NULL, &dwType, (LPBYTE) NT_PROVIDER, &dwSize)) == ERROR_SUCCESS)
            ret = TRUE;

      RegCloseKey(hKey);
   }

   if (ret) {
      ret = FALSE;
      hKey = 0;
      dwSize = sizeof(NW_SERVICE_NAME);
      if ((Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, Lids(IDS_S_24), 0, KEY_READ, &hKey)) == ERROR_SUCCESS)
         if ((Status = RegQueryValueEx(hKey, Lids(IDS_S_22), NULL, &dwType, (LPBYTE) Lids(IDS_S_24), &dwSize)) == ERROR_SUCCESS)
            ret = TRUE;

      RegCloseKey(hKey);
   }

   return ret;

} // ProvidersInit


/////////////////////////////////////////////////////////////////////////
BOOL 
CheckServiceInstall()

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   SC_HANDLE hSC;
   DWORD dwBytesNeeded, dwNumEntries, dwhResume;
   ENUM_SERVICE_STATUS *lpStatus = NULL;
   BOOL ret = FALSE;

   if (!ProvidersInit())
      return FALSE;

   // initialize variables for enumeration...
   dwBytesNeeded = dwNumEntries = dwhResume = 0;

   // acquire handle to svc controller to query for netware client...
   if (hSC = OpenSCManager(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE)) {

      UINT i;
      LPTSTR lpServiceName = Lids(IDS_S_26); // NWCWorkstation

      // ask for buffer size...      
      ret = EnumServicesStatus(
               hSC,
               SERVICE_WIN32,
               SERVICE_ACTIVE,
               NULL,
               0,
               &dwBytesNeeded,
               &dwNumEntries,
               &dwhResume
               );

      // intentionally called function with no buffer to size...
      if ((ret == FALSE) && (GetLastError() == ERROR_MORE_DATA)) {

         // allocate buffer with size passed back...
         if (lpStatus = AllocMemory(dwBytesNeeded)) {

            // ask for svc entries... 
            if (EnumServicesStatus(
                   hSC,
                   SERVICE_WIN32,
                   SERVICE_ACTIVE,
                   lpStatus,
                   dwBytesNeeded,
                   &dwBytesNeeded,
                   &dwNumEntries,
                   &dwhResume)) { 

               // search service names for match...
               for (i = 0; ((i < dwNumEntries) && (ret == FALSE)); i++) {
                  if (!lstrcmpi(lpStatus[i].lpServiceName, lpServiceName)) {
                     ret = TRUE; // found it...
                  }
               }   
            }

            FreeMemory(lpStatus); 
         }        
      } 

      CloseServiceHandle(hSC);
   }

   return ret;

} // CheckServiceInstall


/////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK 
DlgMoveIt(
   HWND hDlg, 
   UINT message, 
   WPARAM wParam, 
   LPARAM lParam
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR AddLine[256];
   int wmId, wmEvent;
   HWND hCtrl;
   PAINTSTRUCT ps;
   HDC hDC;
   RECT rc;
   DWORD Index;
   DWORD_PTR dwData;
   int TabStop;

   switch (message) {
      case WM_INITDIALOG:

         ConvertListStart = ConvertListEnd = NULL;
         UserOptionsDefaultsReset();
         FileOptionsDefaultsReset();
         LogOptionsInit();

         // Disable controls until server pair is choosen...
         ToggleControls(hDlg, FALSE);

         hCtrl = GetDlgItem(hDlg, IDC_LIST1);
         GetClientRect(hCtrl, &rc);

         // Size is half width of listbox - vertical scrollbar
         TabStop = (((rc.right - rc.left) - GetSystemMetrics(SM_CXVSCROLL)) / 2);
         ColumnLB_SetNumberCols(hCtrl, 2);
         ColumnLB_SetColTitle(hCtrl, 0, Lids(IDS_D_11));
         ColumnLB_SetColTitle(hCtrl, 1, Lids(IDS_D_12));
         ColumnLB_SetColWidth(hCtrl, 0, TabStop);
         // Calculate 2nd this way instead of just TabStop to get rid of roundoff
         ColumnLB_SetColWidth(hCtrl, 1, (rc.right - rc.left) - TabStop);

         // This is needed as otherwise only the Add box will display - weird...
         ShowWindow(hDlg, SW_SHOWNORMAL);

         // Check if NWCS is installed
         PostMessage(hDlg, WM_COMMAND, ID_INIT, 0L);

         break;

      case WM_ERASEBKGND:

         // Process so icon background isn't painted grey - main dlg
         // can't be DS_MODALFRAME either, or else a frame is painted around
         // the icon.
         if (IsIconic(hDlg))
            return TRUE;

         break;

      case WM_DESTROY:
         NTConnListDeleteAll();
         PostQuitMessage(0);
         break;

      case WM_PAINT:
         hDC = BeginPaint(hDlg, &ps);
         if (IsIconic(hDlg)) {
            GetClientRect(hDlg, &rc);
            DrawIcon(hDC, rc.left, rc.top, MyIcon);
         }

         EndPaint(hDlg, &ps);
         break;

      case WM_COMMAND:
         wmId    = LOWORD(wParam);
         wmEvent = HIWORD(wParam);

         // If we are currently doing a conversion then get out
         if (InConversion)
            break;

         switch (wmId) {
            case IDOK:
               InConversion = TRUE;
               DoConversion(hDlg, FALSE);
               InConversion = FALSE;

               if (ConversionSuccessful()) {
                  ConfigurationReset(hDlg);
                  DeleteFile(DEF_CONFIG_FILE);
               }
               
               break;

            case ID_INIT:
               CursorHourGlass();
               if (!CheckServiceInstall()) {
                  CursorNormal();
                  WarningError(Lids(IDS_E_12));
                  PostMessage(hDlg, WM_DESTROY, 0, 0);
               } else {

                  ConfigurationLoad(hDlg, DEF_CONFIG_FILE);
                  CursorNormal();

                  if (!NumServerPairs) {
                     // Put up the add dialog box
                     if (FirstTime) {
                        FirstTime = FALSE;
                        PostMessage(hDlg, WM_COMMAND, IDC_ADD, 0);
                     }
                  }

               }

               break;

            case IDC_TRIAL:
               InConversion = TRUE;
               DoConversion(hDlg, TRUE);
               InConversion = FALSE;
               break;

            case IDCANCEL:
            case IDC_EXIT:
               CursorHourGlass();

               if (NumServerPairs)
                  ConfigurationSave(DEF_CONFIG_FILE);
               else {
                  DeleteFile(DEF_CONFIG_FILE);
               }
               
               ConfigurationReset(hDlg);
               CursorNormal();
               PostMessage(hDlg, WM_DESTROY, 0, 0);
               break;

            case ID_FILE_OPEN:
               ConfigFileGet(hDlg);
               break;

            case ID_FILE_SAVE:
               ConfigFileSave(hDlg);
               break;

            case ID_FILE_DEFAULT:
               if (MessageBox(hDlg, Lids(IDS_RESTOREDEFAULTS), Lids(IDS_TXTWARNING), MB_OKCANCEL | MB_ICONEXCLAMATION) == IDOK) {
                  // Remove the listbox entries
                  hCtrl = GetDlgItem(hDlg, IDC_LIST1);
                  ColumnLB_ResetContent(hCtrl);

                  ToggleControls(hDlg, FALSE);

                  ConvertListDeleteAll();
                  UserOptionsDefaultsReset();
                  FileOptionsDefaultsReset();
                  ViewLogs = FALSE;
               }
               break;

            case ID_LOGGING:
               DoLoggingDlg(hDlg);
               return TRUE;

               break;

            case IDC_USERINF:
               // Figure out which server pair is selected and pass server pair to user config dialog
               hCtrl = GetDlgItem(hDlg, IDC_LIST1);
               Index = ColumnLB_GetCurSel(hCtrl);
               dwData = ColumnLB_GetItemData(hCtrl, Index);
               CurrentConvertList = (CONVERT_LIST *) dwData;

               UserOptions_Do(hDlg, CurrentConvertList->ConvertOptions, CurrentConvertList->SourceServ, CurrentConvertList->FileServ);
               return TRUE;

            case IDC_FILEINF:
               // Figure out which server pair is selected and pass server pair to file config dialog
               hCtrl = GetDlgItem(hDlg, IDC_LIST1);
               Index = ColumnLB_GetCurSel(hCtrl);
               dwData = ColumnLB_GetItemData(hCtrl, Index);
               CurrentConvertList = (CONVERT_LIST *) dwData;

               FileOptions_Do(hDlg, CurrentConvertList->FileOptions, CurrentConvertList->SourceServ, CurrentConvertList->FileServ);
               break;

            case IDHELP:
               WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDC_HELP_MAIN);
               break;

            case ID_HELP_CONT:
               WinHelp(hDlg, HELP_FILE, HELP_CONTENTS, 0L);
               break;

            case ID_HELP_INDEX:
               WinHelp(hDlg, HELP_FILE, HELP_PARTIALKEY, 0L);
               break;

            case ID_HELP_USING:
               WinHelp(hDlg, HELP_FILE, HELP_HELPONHELP, 0L);
               break;

            case IDC_ADD:
               if (!DialogServerBrowse(hInst, hDlg, &lpSourceServer, &lpDestServer)) {
                  dwData = (DWORD_PTR) ConvertListAdd(lpSourceServer, lpDestServer);
                  MainListbox_Add(hDlg, dwData, lpSourceServer->Name, lpDestServer->Name);
                  PostMessage(hDlg, WM_COMMAND, (WPARAM) IDM_ADDSEL, 0);
               }

               return TRUE;

            case IDC_DELETE:
               hCtrl = GetDlgItem(hDlg, IDC_LIST1);
               Index = ColumnLB_GetCurSel(hCtrl);

               if (Index != LB_ERR) {
                  dwData = ColumnLB_GetItemData(hCtrl, Index);
                  ConvertListDelete((CONVERT_LIST *) dwData);
                  ColumnLB_DeleteString(hCtrl, Index);
               }

               if (!NumServerPairs) {
                  hCtrl = GetDlgItem(hDlg, IDC_ADD);
                  SetFocus(hCtrl);
                  ToggleControls(hDlg, FALSE);
                  UserOptionsDefaultsReset();
                  FileOptionsDefaultsReset();

               } else {
                  Index = ColumnLB_GetCurSel(hCtrl);

                  if (Index == LB_ERR)
                     ColumnLB_SetCurSel(hCtrl, 0);
               }

               break;

            case IDM_ADDSEL:
               ToggleControls(hDlg, TRUE);
               break;

            case IDC_LIST1:
               if (wmEvent == LBN_SELCHANGE) {
                  if (NumServerPairs)
                     ToggleControls(hDlg, TRUE);
               } else
                  if (wmEvent == LBN_DBLCLK) {
                     hCtrl = GetDlgItem(hDlg, IDC_LIST1);
                     Index = ColumnLB_GetCurSel(hCtrl);

                     if (Index != LB_ERR) {
                        dwData = ColumnLB_GetItemData(hCtrl, Index);
                        if (dwData != 0) {
                           CurrentConvertList = (CONVERT_LIST *) dwData;

                           NTServInfoDlg_Do(hDlg);
                        }
                     }
                  }
               break;

            case ID_APP_ABOUT:
               AboutBox_Do(hDlg);
               return TRUE;

         }

         break;

      case WM_MENUSELECT:
         // when a menu is selected we must remember which one it was so that
         // when F1 is pressed we know what help to bring up.
         if (GET_WM_MENUSELECT_HMENU(wParam, lParam)) {

            // Save the menu the user selected
            uMenuID = GET_WM_MENUSELECT_CMD(wParam, lParam);
            uMenuFlags = GET_WM_MENUSELECT_FLAGS(wParam, lParam);
            hMenu = GET_WM_MENUSELECT_HMENU(wParam, lParam);
         }

         break;

      default:
         if (message == wHelpMessage) {

            if (GET_WM_COMMAND_ID(wParam, lParam) == MSGF_MENU) {
               // Get outta menu mode if help for a menu item
               if (uMenuID && hMenu) {
                  // save and restore menu vars so they aren't overwritten by
                  // the message we are sending
                  UINT m = uMenuID;
                  HMENU hM = hMenu;
                  UINT mf = uMenuFlags;

                  SendMessage(hDlg, WM_CANCELMODE, 0, 0L);

                  uMenuID = m;
                  hMenu = hM;
                  uMenuFlags = mf;
               }

               if (!(uMenuFlags & MF_POPUP)) {
                  switch(uMenuID) {
                     case ID_FILE_OPEN:
                        WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDM_HELP_RCONFIG);
                        break;

                     case ID_FILE_SAVE:
                        WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDM_HELP_SCONFIG);
                        break;

                     case ID_FILE_DEFAULT:
                        WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDM_HELP_RDCONFIG);
                        break;

                     case IDC_EXIT:
                        WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDM_HELP_EXIT);
                        break;

                  }

#ifdef fooo
                  // According to winhelp: GetSystemMenu, uMenuID >= 0x7000
                  // means system menu items!
                  //
                  // This should not be nec since MF_SYSMENU is set!
                  if (uMenuFlags & MF_SYSMENU || uMenuID >= 0xf000)
                     dwContext = bMDIFrameSysMenu ? IDH_SYSMENU : IDH_SYSMENUCHILD;

                  WFHelp(hwnd);
#endif
               }

            }
#ifdef fooo
            else if (GET_WM_COMMAND_ID(wParam, lParam) == MSGF_DIALOGBOX) {

               // context range for message boxes
               if (dwContext >= IDH_MBFIRST && dwContext <= IDH_MBLAST)
                  WFHelp(hwnd);
               else
                  // let dialog box deal with it
                  PostMessage(GetRealParent((HWND)lParam), wHelpMessage, 0, 0L);
            }
#endif

         }

         break;
   }


   return (FALSE); // Didn't process the message

} // DlgMoveIt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\nwnetapi.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _HNWNETAPI_
#define _HNWNETAPI_

#ifdef __cplusplus
extern "C"{
#endif

#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif

typedef struct _USER_RIGHTS_LIST {
   TCHAR Name[MAX_USER_NAME_LEN];
   DWORD Rights;
} USER_RIGHTS_LIST;

int NWGetMaxServerNameLen();
int NWGetMaxUserNameLen();

BOOL NWObjectNameGet( DWORD ObjectID, LPTSTR ObjectName );

VOID NWUserInfoGet(LPTSTR szUserName, VOID **UInfo);
VOID NWUserInfoLog(LPTSTR szUserName, VOID *UInfo);
DWORD NWServerSet(LPTSTR FileServer);
DWORD NWServerFree();

DWORD NWUsersEnum(USER_LIST **lpUsers, BOOL Display);
DWORD NWGroupsEnum(GROUP_LIST **lpGroups, BOOL Display);
DWORD NWGroupUsersEnum(LPTSTR GroupName, USER_LIST **lpUsers);
DWORD NWUserEquivalenceEnum(LPTSTR UserName, USER_LIST **lpUsers);
DWORD NWServerEnum(LPTSTR Container, SERVER_BROWSE_LIST **lpServList);
DWORD NWSharesEnum(SHARE_LIST **lpShares);

VOID NWUserDefaultsGet(VOID **UDefaults);
VOID NWUserDefaultsMap(VOID *NWUDefaults, NT_DEFAULTS *NTDefaults);
VOID NWUserDefaultsLog(VOID *UDefaults);
VOID NWNetUserMapInfo (LPTSTR szUserName, VOID *UInfo, NT_USER_INFO *NT_UInfo );
VOID NWFPNWMapInfo(VOID *NWUInfo, PFPNW_INFO fpnw);

VOID NWUseDel(LPTSTR ServerName);
BOOL NWIsAdmin(LPTSTR UserName);
VOID NWServerInfoReset(SOURCE_SERVER_BUFFER *SServ);
VOID NWServerInfoSet(LPTSTR ServerName, SOURCE_SERVER_BUFFER *SServ);
BOOL NWServerValidate(HWND hWnd, LPTSTR ServerName, BOOL DupFlag);
DWORD NWFileRightsEnum(LPTSTR FileName, USER_RIGHTS_LIST **lpUsers, DWORD *UserCount, BOOL DownLevel);
LPTSTR NWRightsLog(DWORD Rights);
LPTSTR NWSpecialNamesMap(LPTSTR Name);

VOID NWServerTimeGet();

typedef struct _NW_TO_NT_MAPPING {
    ULONG           NWRight ;
    ULONG           NTAccess ;
} NW_TO_NT_MAPPING, *PNW_TO_NT_MAPPING ;


//
// structure used to define how the Rights for a Netware object maps
// to the corresponding NT AccessMasks. 
//  
// first entry is the AceFlags to distinguish between ACE for the Object
// and ACE for inheritted objects
//
// the GENERIC_MAPPING structure should match that already defined for 
// the NT object in question.
//
// the array of NW mappings defines the NT Access Mask for each NW Right
// the object uses. the last entry should be {0, 0}.
//
// for example, file object mappings:
//
//     RIGHTS_MAPPING FileRightsMapping = 
//     {
//         0,
//         { FILE_GENERIC_READ, 
//           FILE_GENERIC_WRITE, 
//           FILE_GENERIC_EXECUTE,
//           FILE_ALL_ACCESS 
//         },
//         { { NW_FILE_READ,       GENERIC_READ }
//             { NW_FILE_WRITE,      GENERIC_WRITE }
//             { NW_FILE_CREATE,     0 }
//             { NW_FILE_DELETE,     GENERIC_WRITE }
//             { NW_FILE_PERM,       WRITE_DAC }
//             { NW_FILE_SCAN,       0 }
//             { NW_FILE_MODIFY,     GENERIC_WRITE }
//             { NW_FILE_SUPERVISOR, GENERIC_ALL }
//             { 0, 0 }
//         } 
//     } ;
//
//

typedef struct _RIGHTS_MAPPING {
    ULONG            NtAceFlags ;
    GENERIC_MAPPING  GenericMapping ;
    NW_TO_NT_MAPPING Nw2NtMapping[] ;
} RIGHTS_MAPPING, *PRIGHTS_MAPPING ;


// predefined mappings (defined in nwnetapi.c)
extern RIGHTS_MAPPING FileRightsMapping ;
extern RIGHTS_MAPPING DirRightsMapping ;
extern RIGHTS_MAPPING PrintRightsMapping ;
extern RIGHTS_MAPPING JobRightsMapping ;

// define the NW_FILE_* rights
#define NW_FILE_READ        0x0001
#define NW_FILE_WRITE       0x0002
#define NW_FILE_CREATE      0x0008
#define NW_FILE_DELETE      0x0010
#define NW_FILE_PERM        0x0020
#define NW_FILE_SCAN        0x0040
#define NW_FILE_MODIFY      0x0080
#define NW_FILE_SUPERVISOR  0x0100

#define NW_PRINT_USER       0x0001
#define NW_PRINT_ADMIN      0x0002
#define NW_PRINTJOB_ADMIN   0x0004

NTSTATUS MapNwRightsToNTAccess( ULONG NWRights, PRIGHTS_MAPPING pMap, ACCESS_MASK *pAccessMask ) ; 
DWORD NWPrintOpsEnum(USER_LIST **lpUsers);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\nwnetapi.c ===
/*++

Copyright (c) 1993-1995  Microsoft Corporation

Module Name:

   nwnetapi.c

Abstract:


Author:

    Arthur Hanson (arth) 16-Jun-1994

Revision History:

--*/


#include "globals.h"

#include <nwapi32.h>
#include "nwconv.h"
#include "convapi.h"
#include "nwnetapi.h"
#include "statbox.h"

#define SUPERVISOR          "SUPERVISOR"
#define ACCOUNT_LOCKOUT     "ACCT_LOCKOUT"
#define GROUP_MEMBERS       "GROUP_MEMBERS"
#define GROUPS_IM_IN        "GROUPS_I'M_IN"
#define IDENTIFICATION      "IDENTIFICATION"
#define LOGIN_CONTROL       "LOGIN_CONTROL"
#define PS_OPERATORS        "PS_OPERATORS"
#define SECURITY_EQUALS     "SECURITY_EQUALS"
#define USER_DEFAULTS       "USER_DEFAULTS"
#define MS_EXTENDED_NCPS    "MS_EXTENDED_NCPS"
#define FPNW_PDC            "FPNWPDC"

#ifdef DEBUG
int ErrorBoxRetry(LPTSTR szFormat, ...);
#endif

// Couple of NetWare specific data structures - see NetWare programming books for
// info on these structures
#pragma pack(1)
typedef struct tagLoginControl {
   BYTE byAccountExpires[3];
   BYTE byAccountDisabled;
   BYTE byPasswordExpires[3];
   BYTE byGraceLogins;
   WORD wPasswordInterval;
   BYTE byGraceLoginReset;
   BYTE byMinPasswordLength;
   WORD wMaxConnections;
   BYTE byLoginTimes[42];
   BYTE byLastLogin[6];
   BYTE byRestrictions;
   BYTE byUnused;
   long lMaxDiskBlocks;
   WORD wBadLogins;
   LONG lNextResetTime;
   BYTE byBadLoginAddr[12];
};  // tagLoginControl
#pragma pack()


typedef struct tagAccountBalance {
   long lBalance;
   long lCreditLimit;
}; // tagAccountBalance


typedef struct tagUserDefaults {
   BYTE byAccountExpiresYear;
   BYTE byAccountExpiresMonth;
   BYTE byAccountExpiresDay;
   BYTE byRestrictions;
   WORD wPasswordInterval;
   BYTE byGraceLoginReset;
   BYTE byMinPasswordLength;
   WORD wMaxConnections;
   BYTE byLoginTimes[42];
   long lBalance;
   long lCreditLimit;
   long lMaxDiskBlocks;
}; // tagUserDefaults


// define the mapping for FILE objects. Note: we only use GENERIC and 
// STANDARD bits!
RIGHTS_MAPPING FileRightsMapping = {
    0,
    { FILE_GENERIC_READ, 
      FILE_GENERIC_WRITE, 
      FILE_GENERIC_EXECUTE,
      FILE_ALL_ACCESS 
    },
    {   { NW_FILE_READ,       GENERIC_READ},
        { NW_FILE_WRITE,      GENERIC_WRITE},
        { NW_FILE_CREATE,     0},
        { NW_FILE_DELETE,     GENERIC_WRITE|DELETE},
        { NW_FILE_PERM,       WRITE_DAC},
        { NW_FILE_SCAN,       0},
        { NW_FILE_MODIFY,     GENERIC_WRITE},
        { NW_FILE_SUPERVISOR, GENERIC_ALL},
        { 0, 0 } 
    } 
} ;

RIGHTS_MAPPING DirRightsMapping = {
    CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
    { FILE_GENERIC_READ, 
      FILE_GENERIC_WRITE, 
      FILE_GENERIC_EXECUTE,
      FILE_ALL_ACCESS 
    },
    {   { NW_FILE_READ,       GENERIC_READ|GENERIC_EXECUTE},
        { NW_FILE_WRITE,      GENERIC_WRITE},
        { NW_FILE_CREATE,     GENERIC_WRITE},
        { NW_FILE_DELETE,     DELETE},
        { NW_FILE_PERM,       WRITE_DAC},
        { NW_FILE_SCAN,       GENERIC_READ},
        { NW_FILE_MODIFY,     GENERIC_WRITE},
        { NW_FILE_SUPERVISOR, GENERIC_ALL},
        { 0, 0 } 
    } 
} ;

VOID UserInfoLog(LPTSTR UserName, struct tagLoginControl tag);
VOID Moveit(NWCONN_HANDLE Conn, LPTSTR UserName);
VOID UserRecInit(NT_USER_INFO *UserInfo);
BOOL IsNCPServerFPNW(NWCONN_HANDLE Conn);

static NWCONN_HANDLE CachedConn = 0;

static TCHAR CachedServer[MAX_SERVER_NAME_LEN + 1];
static DWORD CachedServerTime = 0xffffffff; // minutes since 1985...

typedef struct _PRINT_SERVER_BUFFER {
   TCHAR Name[20];
} PRINT_SERVER_BUFFER;

typedef struct _PRINT_SERVER_LIST {
   ULONG Count;
   PRINT_SERVER_BUFFER PSList[];
} PRINT_SERVER_LIST;



/////////////////////////////////////////////////////////////////////////
int 
NWGetMaxServerNameLen()

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   return MAX_SERVER_NAME_LEN;

} // NWGetMaxServerNameLen


/////////////////////////////////////////////////////////////////////////
int 
NWGetMaxUserNameLen()

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   return MAX_USER_NAME_LEN;

} // NWGetMaxUserNameLen


/////////////////////////////////////////////////////////////////////////
DWORD 
NWServerFree()

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

   if (CachedConn)
      NWDetachFromFileServer(CachedConn);

   CachedConn = 0;

   return (0);

} // NWServerFree


/////////////////////////////////////////////////////////////////////////
DWORD 
NWServerSet(
   LPTSTR FileServer
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   NWLOCAL_SCOPE ScopeFlag = 0;
   NWCONN_HANDLE Conn = 0;
   NWCCODE ret = 0;
   char szAnsiFileServer[MAX_SERVER_NAME_LEN + 1];

   NWServerFree();

   lstrcpy(CachedServer, FileServer);
   CharToOem(FileServer, szAnsiFileServer);

   ret = NWAttachToFileServer(szAnsiFileServer, ScopeFlag, &Conn);

   if (!ret) {
      CachedConn = Conn;
      NWServerTimeGet();
    }

   return ((DWORD) ret);

} // NWServerSet


/////////////////////////////////////////////////////////////////////////
VOID
NWUseDel(
   LPTSTR ServerName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR LocServer[MAX_SERVER_NAME_LEN+3];

   NWServerFree();
   wsprintf(LocServer, Lids(IDS_S_27), ServerName);
   WNetCancelConnection2(LocServer, 0, FALSE);

} // NWUseDel


/////////////////////////////////////////////////////////////////////////
BOOL
NWUserNameValidate(
   LPTSTR szUserName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   TCHAR UserName[MAX_USER_NAME_LEN + 1];
   DWORD Size;

   // if same as logged on user then don't convert or overwrite
   Size = sizeof(UserName);
   WNetGetUser(NULL, UserName, &Size);
   if (!lstrcmpi(szUserName, UserName))
      return FALSE;

   // Now check for other special names
   if (!lstrcmpi(szUserName, Lids(IDS_S_28)))
      return FALSE;

   if (!lstrcmpi(szUserName, Lids(IDS_S_29)))
      return FALSE;

   if (!lstrcmpi(szUserName, Lids(IDS_S_30)))
      return FALSE;

   return TRUE;

} // NWUserNameValidate


/////////////////////////////////////////////////////////////////////////
BOOL
NWGroupNameValidate(
   LPTSTR szGroupName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

   if (!lstrcmpi(szGroupName, Lids(IDS_S_31)))
      return FALSE;

   if (!lstrcmpi(szGroupName, Lids(IDS_S_28)))
      return FALSE;

   return TRUE;

} // NWGroupNameValidate


/////////////////////////////////////////////////////////////////////////
LPTSTR
NWSpecialNamesMap(
   LPTSTR Name
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   ULONG i;
   static BOOL InitStrings = FALSE;
   static LPTSTR SpecialNames[5];
   static LPTSTR SpecialMap[5];

   if (!InitStrings) {
      InitStrings = TRUE;
      SpecialNames[0] = Lids(IDS_S_28);
      SpecialNames[1] = Lids(IDS_S_30);
      SpecialNames[2] = Lids(IDS_S_31);
      SpecialNames[3] = Lids(IDS_S_29);
      SpecialNames[4] = NULL;

      SpecialMap[0] = Lids(IDS_S_32);
      SpecialMap[1] = Lids(IDS_S_32);
      SpecialMap[2] = Lids(IDS_S_33);
      SpecialMap[3] = Lids(IDS_S_29);
      SpecialMap[4] = NULL;
   }

   i = 0;
   while(SpecialNames[i] != NULL) {
      if (!lstrcmpi(SpecialNames[i], Name)) {
         return SpecialMap[i];
      }

      i++;
   }

   return Name;

} // NWSpecialNamesMap


/////////////////////////////////////////////////////////////////////////
BOOL
NWIsAdmin(
   LPTSTR UserName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   char szAnsiUserName[MAX_USER_NAME_LEN];
   NWCCODE ret;

   CharToOem(UserName, szAnsiUserName);
   ret = NWIsObjectInSet(CachedConn, szAnsiUserName, OT_USER, SECURITY_EQUALS,
                     SUPERVISOR, OT_USER);

   if (ret == SUCCESSFUL)
      return TRUE;
   else
      return FALSE;

} // NWIsAdmin


/////////////////////////////////////////////////////////////////////////
BOOL
NWObjectNameGet(
   DWORD ObjectID,
   LPTSTR ObjectName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   char szAnsiObjectName[MAX_USER_NAME_LEN + 1];
   WORD wFoundUserType = 0;
   NWCCODE ret;

   lstrcpy(ObjectName, TEXT(""));

   if (!(ret = NWGetObjectName(CachedConn, ObjectID, szAnsiObjectName, &wFoundUserType))) {

      //
      // Got user - now convert and save off the information
      //
      OemToChar(szAnsiObjectName, ObjectName);
   }

   if (ret == SUCCESSFUL)
      return TRUE;
   else
      return FALSE;

} // NWObjectNameGet


#define DEF_NUM_RECS 200
/////////////////////////////////////////////////////////////////////////
DWORD
NWUsersEnum(
   USER_LIST **lpUsers,
   BOOL Display
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   USER_LIST *Users = NULL;
   USER_BUFFER *UserBuffer = NULL; 
   DWORD NumRecs = DEF_NUM_RECS;   // Default 200 names
   DWORD Count = 0;
   DWORD status = 0;
   char szAnsiUserName[MAX_USER_NAME_LEN + 1];
   TCHAR szUserName[MAX_USER_NAME_LEN + 1];
   WORD wFoundUserType = 0;
   DWORD dwObjectID = 0xFFFFFFFFL;
   BYTE byPropertiesFlag = 0;
   BYTE byObjectFlag = 0;
   BYTE byObjectSecurity = 0;
   NWCCODE ret;

   if (Display)
      Status_ItemLabel(Lids(IDS_S_44));

   Users =  (USER_LIST *) AllocMemory(sizeof(USER_LIST) + (sizeof(USER_BUFFER) * NumRecs));

   if (!Users) {
      status = ERROR_NOT_ENOUGH_MEMORY;
   } else {
      UserBuffer = Users->UserBuffer;

      // init to NULL so doesn't have garbage if call fails
      lstrcpyA(szAnsiUserName, "");

      // Loop through bindery getting all the users.
      while ((ret = NWScanObject(CachedConn, "*", OT_USER, &dwObjectID, szAnsiUserName,
                           &wFoundUserType, &byPropertiesFlag,
                           &byObjectFlag, &byObjectSecurity)) == SUCCESSFUL) {

         // Got user - now convert and save off the information
         OemToChar(szAnsiUserName, szUserName);

         if (NWUserNameValidate(szUserName)) {
            if (Display)
               Status_Item(szUserName);

            lstrcpy(UserBuffer[Count].Name, szUserName);
            lstrcpy(UserBuffer[Count].NewName, szUserName);
            Count++;
         }

         // Check if we have to re-allocate buffer
         if (Count >= NumRecs) {
            NumRecs += DEF_NUM_RECS;
            Users = (USER_LIST *) ReallocMemory((HGLOBAL) Users, sizeof(USER_LIST) + (sizeof(USER_BUFFER) * NumRecs));

            if (!Users) {
               status = ERROR_NOT_ENOUGH_MEMORY;
               break;
            }

            UserBuffer = Users->UserBuffer;
         }

      }

      // Gotta clear this out from the last loop
      if (Count)
         ret = 0;

   }

   // check if error occured...
   if (ret) 
      status = ret;

   // Now slim down the list to just what we need.
   if (!status) {
      Users = (USER_LIST *) ReallocMemory((HGLOBAL) Users, sizeof(USER_LIST) + (sizeof(USER_BUFFER)* Count));

      if (!Users)
         status = ERROR_NOT_ENOUGH_MEMORY;
      else {
         // Sort the server list before putting it in the dialog
         UserBuffer = Users->UserBuffer;
         qsort((void *) UserBuffer, (size_t) Count, sizeof(USER_BUFFER), UserListCompare);
      }
   }

   if (Users != NULL)
      Users->Count = Count;

   *lpUsers = Users;

   return status;

} // NWUsersEnum


/////////////////////////////////////////////////////////////////////////
DWORD
NWGroupsEnum(
   GROUP_LIST **lpGroups,
   BOOL Display
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   GROUP_LIST *Groups = NULL;
   GROUP_BUFFER *GroupBuffer;
   DWORD NumRecs = DEF_NUM_RECS;   // Default 200 names
   DWORD Count = 0;
   DWORD status = 0;
   char szAnsiGroupName[MAX_GROUP_NAME_LEN + 1];
   TCHAR szGroupName[MAX_GROUP_NAME_LEN + 1];
   WORD wFoundGroupType = 0;
   DWORD dwObjectID = 0xFFFFFFFFL;
   BYTE byPropertiesFlag = 0;
   BYTE byObjectFlag = 0;
   BYTE byObjectSecurity = 0;
   NWCCODE ret;

   if (Display)
      Status_ItemLabel(Lids(IDS_S_45));

   Groups =  (GROUP_LIST *) AllocMemory(sizeof(GROUP_LIST) + (sizeof(GROUP_BUFFER) * NumRecs));

   if (!Groups) {
      status = ERROR_NOT_ENOUGH_MEMORY;
   } else {
      GroupBuffer = Groups->GroupBuffer;

      // init to NULL so doesn't have garbage if call fails
      lstrcpyA(szAnsiGroupName, "");

      // Loop through bindery getting all the users.
      while ((ret = NWScanObject(CachedConn, "*", OT_USER_GROUP, &dwObjectID, szAnsiGroupName,
                           &wFoundGroupType, &byPropertiesFlag,
                           &byObjectFlag, &byObjectSecurity)) == SUCCESSFUL) {

         // Got user - now convert and save off the information
         OemToChar(szAnsiGroupName, szGroupName);

         if (NWGroupNameValidate(szGroupName)) {
            if (Display)
               Status_Item(szGroupName);

            lstrcpy(GroupBuffer[Count].Name, szGroupName);
            lstrcpy(GroupBuffer[Count].NewName, szGroupName);
            Count++;
         }

         // Check if we have to re-allocate buffer
         if (Count >= NumRecs) {
            NumRecs += DEF_NUM_RECS;
            Groups = (GROUP_LIST *) ReallocMemory((HGLOBAL) Groups, sizeof(GROUP_LIST) + (sizeof(GROUP_BUFFER) * NumRecs));

            if (!Groups) {
               status = ERROR_NOT_ENOUGH_MEMORY;
               break;
            }

            GroupBuffer = Groups->GroupBuffer;
         }

      }

      // Gotta clear this out from the last loop
      if (Count)
         ret = 0;

   }

   // check if error occured...
   if (ret) 
      status = ret;

   // Now slim down the list to just what we need.
   if (!status) {
      Groups = (GROUP_LIST *) ReallocMemory((HGLOBAL) Groups, sizeof(GROUP_LIST) + (sizeof(GROUP_BUFFER) * Count));

      if (!Groups)
         status = ERROR_NOT_ENOUGH_MEMORY;
      else {
         // Sort the server list before putting it in the dialog
         GroupBuffer = Groups->GroupBuffer;
         qsort((void *) GroupBuffer, (size_t) Count, sizeof(GROUP_BUFFER), UserListCompare);
      }
   }

   if (Groups != NULL)
      Groups->Count = Count;

   *lpGroups = Groups;

   return status;

} // NWGroupsEnum


/////////////////////////////////////////////////////////////////////////
DWORD
NWGroupUsersEnum(
   LPTSTR GroupName,
   USER_LIST **lpUsers
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   USER_LIST *Users = NULL;
   USER_BUFFER *UserBuffer;
   DWORD NumRecs = DEF_NUM_RECS;   // Default 200 names
   DWORD Count = 0;
   DWORD i = 0;
   DWORD status = 0;
   char szAnsiUserName[MAX_USER_NAME_LEN + 1];
   char szAnsiGroupName[MAX_GROUP_NAME_LEN + 1];
   TCHAR szUserName[MAX_USER_NAME_LEN + 1];
   WORD wFoundUserType = 0;
   BYTE byPropertyFlags = 0;
   BYTE byObjectFlag = 0;
   BYTE byObjectSecurity = 0;
   UCHAR Segment = 1;
   DWORD bySegment[32];
   BYTE byMoreSegments;
   NWCCODE ret;

   Users =  (USER_LIST *) AllocMemory(sizeof(USER_LIST) + (sizeof(USER_BUFFER) * NumRecs));

   if (!Users) {
      status = ERROR_NOT_ENOUGH_MEMORY;
   } else {
      UserBuffer = Users->UserBuffer;

      // init to NULL so doesn't have garbage if call fails
      lstrcpyA(szAnsiUserName, "");
      CharToOem(GroupName, szAnsiGroupName);

      // Loop through bindery getting all the users.
      do {
         if (!(ret = NWReadPropertyValue(CachedConn, szAnsiGroupName, OT_USER_GROUP, GROUP_MEMBERS,
                        Segment, (BYTE *) bySegment, &byMoreSegments, &byPropertyFlags))) {

            Segment++;
            // loop through properties converting them to user names
            i = 0;
            while ((bySegment[i]) && (i < 32)) {
               if (!(ret = NWGetObjectName(CachedConn, bySegment[i], szAnsiUserName, &wFoundUserType))) {
                  // Got user - now convert and save off the information
                  OemToChar(szAnsiUserName, szUserName);

                  lstrcpy(UserBuffer[Count].Name, szUserName);
                  lstrcpy(UserBuffer[Count].NewName, szUserName);
                  Count++;

                  // Check if we have to re-allocate buffer
                  if (Count >= NumRecs) {
                     NumRecs += DEF_NUM_RECS;
                     Users = (USER_LIST *) ReallocMemory((HGLOBAL) Users, sizeof(USER_LIST) + (sizeof(USER_BUFFER) * NumRecs));
               
                     if (!Users) {
                        status = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                     }

                     UserBuffer = Users->UserBuffer;
                  }
               }
               i++;
            }

         } else // if NWReadPropertyValue
            byMoreSegments = 0;

      } while (byMoreSegments);

      // Gotta clear this out from the last loop
      if (Count)
         ret = 0;

   }

   // check if error occured...
   if (ret) 
      status = ret;

   // Now slim down the list to just what we need.
   if (!status) {
      Users = (USER_LIST *) ReallocMemory((HGLOBAL) Users, sizeof(USER_LIST) + (sizeof(USER_BUFFER) * Count));

      if (!Users)
         status = ERROR_NOT_ENOUGH_MEMORY;
      else  {
         // Sort the server list before putting it in the dialog
         UserBuffer = Users->UserBuffer;
         qsort((void *) UserBuffer, (size_t) Count, sizeof(USER_BUFFER), UserListCompare);
      }
   }

   if (Users != NULL)
      Users->Count = Count;

   *lpUsers = Users;

   return status;

} // NWGroupUsersEnum


/////////////////////////////////////////////////////////////////////////
DWORD
NWUserEquivalenceEnum(
   LPTSTR UserName,
   USER_LIST **lpUsers
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   USER_LIST *Users;
   USER_BUFFER *UserBuffer;
   DWORD NumRecs = DEF_NUM_RECS;   // Default 200 names
   DWORD Count = 0;
   DWORD i = 0;
   DWORD status = 0;
   char szAnsiUserName[MAX_USER_NAME_LEN + 1];
   char szAnsiName[MAX_GROUP_NAME_LEN + 1];
   TCHAR szUserName[MAX_USER_NAME_LEN + 1];
   WORD wFoundUserType = 0;
   DWORD dwObjectID = 0xFFFFFFFFL;
   BYTE byPropertyFlags = 0;
   BYTE byObjectFlag = 0;
   BYTE byObjectSecurity = 0;
   UCHAR Segment = 1;
   DWORD bySegment[32];
   BYTE byMoreSegments;
   NWCCODE ret;

   Users =  (USER_LIST *) AllocMemory(sizeof(USER_LIST) + (sizeof(USER_BUFFER) * NumRecs));

   if (!Users) {
      status = ERROR_NOT_ENOUGH_MEMORY;
   } else {
      UserBuffer = Users->UserBuffer;

      // init to NULL so doesn't have garbage if call fails
      lstrcpyA(szAnsiUserName, "");
      CharToOem(UserName, szAnsiName);

      // Loop through bindery getting all the users.
      do {
         if (!(ret = NWReadPropertyValue(CachedConn, szAnsiName, OT_USER, SECURITY_EQUALS,
                        Segment, (BYTE *) bySegment, &byMoreSegments, &byPropertyFlags))) {

            Segment++;
            // loop through properties converting them to user names
            i = 0;
            while ((bySegment[i]) && (i < 32)) {
               if (!(ret = NWGetObjectName(CachedConn, bySegment[i], szAnsiUserName, &wFoundUserType))) {
                  // Got user - now convert and save off the information
                  OemToChar(szAnsiUserName, szUserName);

                  // Map out Everyone equivalence
                  if (lstrcmpi(szUserName, Lids(IDS_S_31))) {
                     lstrcpy(UserBuffer[Count].Name, szUserName);
                     lstrcpy(UserBuffer[Count].NewName, szUserName);
                     Count++;
                  }

                  // Check if we have to re-allocate buffer
                  if (Count >= NumRecs) {
                     NumRecs += DEF_NUM_RECS;
                     Users = (USER_LIST *) ReallocMemory((HGLOBAL) Users, sizeof(USER_LIST) + (sizeof(USER_BUFFER) * NumRecs));
               
                     if (!Users) {
                        status = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                     }

                     UserBuffer = Users->UserBuffer;
                  }
               }
               i++;
            }

         } else // if NWReadPropertyValue
            byMoreSegments = 0;

      } while (byMoreSegments);

      // Gotta clear this out from the last loop
      if (Count)
         ret = 0;

   }

   // check if error occured...
   if (ret) 
      status = ret;

   // Now slim down the list to just what we need.
   if (!status) {
      Users = (USER_LIST *) ReallocMemory((HGLOBAL) Users, sizeof(USER_LIST) + (sizeof(USER_BUFFER) * Count));

      if (!Users)
         status = ERROR_NOT_ENOUGH_MEMORY;
      else {
         // Sort the server list before putting it in the dialog
         UserBuffer = Users->UserBuffer;
         qsort((void *) UserBuffer, (size_t) Count, sizeof(USER_BUFFER), UserListCompare);
      }
   }

   if (Users != NULL)
      Users->Count = Count;

   *lpUsers = Users;

   return status;

} // NWUserEquivalenceEnum


/////////////////////////////////////////////////////////////////////////
DWORD
NWFileRightsEnum(
   LPTSTR FileName, 
   USER_RIGHTS_LIST **lpUsers, 
   DWORD *UserCount, 
   BOOL DownLevel
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   BOOL Continue = TRUE;
   USER_RIGHTS_LIST *Users = NULL;
   DWORD NumRecs = DEF_NUM_RECS;   // Default 200 names
   DWORD Count = 0;
   DWORD i = 0;
   DWORD status = 0;
   char szAnsiUserName[MAX_USER_NAME_LEN + 1];
   char szAnsiSearchDir[MAX_PATH + 1];
   TCHAR szUserName[MAX_USER_NAME_LEN + 1];
   WORD wFoundUserType = 0;
   NWCCODE ret;
   char FoundDir[16];
   ULONG Entries;

   TRUSTEE_INFO ti[20];
   BYTE DirHandle, nDirHandle;
   BYTE Sequence;
   BYTE NumEntries = 0;
   NWDATE_TIME dtime = 0;
   NWOBJ_ID ownerID = 0;

   if (DownLevel) {
      Entries = 5;
      Sequence = 1;
   } else {
      Entries = 20;
      Sequence = 0;
   }

   DirHandle = nDirHandle = 0;
   memset(ti, 0, sizeof(ti));

   Users = (USER_RIGHTS_LIST *) AllocMemory(NumRecs * sizeof(USER_RIGHTS_LIST));

   if (!Users) {
      status = ERROR_NOT_ENOUGH_MEMORY;
   } else {

      // init to NULL so doesn't have garbage if call fails
      lstrcpyA(szAnsiUserName, "");
      CharToOem(FileName, szAnsiSearchDir);

      // Loop through bindery getting all the users.
      do {
         if (DownLevel)
            ret = NWCScanDirectoryForTrustees2(CachedConn, nDirHandle, szAnsiSearchDir,
                        &Sequence, FoundDir, &dtime, &ownerID, ti);
         else
            ret = NWCScanForTrustees(CachedConn, nDirHandle, szAnsiSearchDir,
                           &Sequence, &NumEntries, ti);

         if (!ret) {
            // loop through properties converting them to user names
            for (i = 0; i < Entries; i++) {
               if (ti[i].objectID != 0) {
                  if (!(ret = NWGetObjectName(CachedConn, ti[i].objectID, szAnsiUserName, &wFoundUserType))) {
                     // Got user - now convert and save off the information
                     OemToChar(szAnsiUserName, szUserName);

                     lstrcpy(Users[Count].Name, szUserName);
                     Users[Count].Rights = ti[i].objectRights;
                     Count++;

                     // Check if we have to re-allocate buffer
                     if (Count >= NumRecs) {
                        NumRecs += DEF_NUM_RECS;
                        Users = (USER_RIGHTS_LIST *) ReallocMemory((HGLOBAL) Users, NumRecs * sizeof(USER_RIGHTS_LIST));
               
                        if (!Users) {
                           status = ERROR_NOT_ENOUGH_MEMORY;
                           break;
                        }
                     } // if realloc buffer
                  }
               } // if objectID != 0
            }

         } else // NWScan failed
            Continue = FALSE;

      } while (Continue);

      // Gotta clear this out from the last loop
      if (Count)
         ret = 0;

   }

   // check if error occured...
   if (ret)  {
      status = ret;

      if (Users != NULL) {
         FreeMemory(Users);
         Count = 0;
      }
   }

   // Now slim down the list to just what we need.
   if (!status) {
      Users = (USER_RIGHTS_LIST *) ReallocMemory((HGLOBAL) Users, Count * sizeof(USER_RIGHTS_LIST));

      if (!Users)
         status = ERROR_NOT_ENOUGH_MEMORY;
      else 
         // Sort the server list before putting it in the dialog
         qsort((void *) Users, (size_t) Count, sizeof(USER_RIGHTS_LIST), UserListCompare);
   }

   *UserCount = Count;
   *lpUsers = Users;

   return status;

} // NWFileRightsEnum


/////////////////////////////////////////////////////////////////////////
VOID
NWLoginTimesMap(
   BYTE *Times, 
   BYTE *NewTimes
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   DWORD i, j;
   int Bit = 0;
   int Val;
   BYTE BitSet;

   for (i = 0; i < 21; i++) {
      BitSet = 0;

      for (j = 0; j < 8; j++) {
         if (BitTest(Bit, Times) || BitTest(Bit+1, Times)) {
            Val = 0x1 << j;
            BitSet = BitSet + (BYTE) Val;
         }

         Bit++; Bit++;
      }

      NewTimes[i] = BitSet;
   }


} // NWLoginTimesMap


/*+-------------------------------------------------------------------------+
  |                          Time Conversion                                |
  +-------------------------------------------------------------------------+*/

#define IS_LEAP(y)          ((y % 4 == 0) && (y % 100 != 0 || y % 400 == 0))
#define DAYS_IN_YEAR(y)     (IS_LEAP(y) ? 366 : 365)
#define DAYS_IN_MONTH(m,y)  (IS_LEAP(y) ? _days_month_leap[m] : _days_month[m])
#define SECS_IN_DAY         (60L * 60L * 24L)
#define SECS_IN_HOUR        (60L * 60L)
#define SECS_IN_MINUTE      (60L)

static short _days_month_leap[] = { 31,29,31,30,31,30,31,31,30,31,30,31 };
static short _days_month[]      = { 31,28,31,30,31,30,31,31,30,31,30,31 };

/////////////////////////////////////////////////////////////////////////
BOOL 
NWTimeMap(
   DWORD Days, 
   DWORD dwMonth, 
   DWORD dwYear, 
   DWORD dwBasis,
   ULONG *Time
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   DWORD dw = 0;
   DWORD dwDays = 0;

   // Zero
   *Time = 0L;

   // Adjust year
   if(dwYear < 70)
      dwYear += 2000L;
   else
      if(dwYear < 100)
         dwYear += 1900L;

   if (dwYear < dwBasis)
      return FALSE;

   // Calculate days in previous years, take -1 so we skip current year
   dw = dwYear - 1;
   while(dw >= dwBasis) {
      dwDays += DAYS_IN_YEAR(dw);
      --dw;
   }

   // Days from month
   if((dwMonth < 1)||(dwMonth > 12))
      return FALSE;

   // Loop through adding number of days in each month.  Take -2 (-1 to skip
   // current month, and -1 to make 0 based).
   dw = dwMonth;
   while(dw > 1) {
      dwDays += DAYS_IN_MONTH(dw-2, dwYear);
      --dw;
   }

   // Convert days
   dw = Days;
   if((dw >= 1) && (dw <= (DWORD) DAYS_IN_MONTH(dwMonth - 1, dwYear)))
      dwDays += dw;
   else
      return FALSE;   // out of range

   *Time += dwDays * SECS_IN_DAY;
    return TRUE;
} // NWTimeMap


/////////////////////////////////////////////////////////////////////////
LPTSTR 
NWUserNameGet(
   LPTSTR szUserName
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR UserName[128];
   char szAnsiUserName[MAX_USER_NAME_LEN];
   NWCCODE ret;
   BYTE bySegment[128];
   BYTE byMoreSegments, byPropertyFlags;
   LPSTR szAnsiFullName;

   CharToOem(szUserName, szAnsiUserName);
   ret = NWReadPropertyValue(CachedConn, szAnsiUserName, OT_USER, IDENTIFICATION,
                     1, bySegment, &byMoreSegments, &byPropertyFlags);

   if (ret == SUCCESSFUL) {
      szAnsiFullName = (LPSTR) bySegment;
      OemToChar(szAnsiFullName, UserName);
      return UserName;
   }

   return NULL;

} // NWUserNameGet


/////////////////////////////////////////////////////////////////////////
VOID
NWNetUserMapInfo (
   LPTSTR szUserName, 
   VOID *UInfo, 
   NT_USER_INFO *NT_UInfo
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   ULONG expires;
   struct tagLoginControl *tag;
   LPTSTR FullName;

   tag = (struct tagLoginControl *) UInfo;

   FullName = NWUserNameGet(szUserName);
   if (FullName != NULL)
      lstrcpyn(NT_UInfo->full_name, FullName, MAXCOMMENTSZ);

   // Account disabled
   if (tag->byAccountDisabled)
      NT_UInfo->flags = NT_UInfo->flags | 0x02;

   // account locked out
   if ((tag->wBadLogins == 0xffff) &&
       (tag->lNextResetTime > (LONG)CachedServerTime))
      NT_UInfo->flags = NT_UInfo->flags | 0x02; // disable account...

   // user can change password
   if ((tag->byRestrictions & 0x01))
      NT_UInfo->flags = NT_UInfo->flags | 0x40;

   NWLoginTimesMap(tag->byLoginTimes, NT_UInfo->logon_hours);

   // account expires
   if (tag->byAccountExpires[0] == 0)
      NT_UInfo->acct_expires = TIMEQ_FOREVER;
   else
      if (tag->byAccountExpires[0] < 70)
         NT_UInfo->acct_expires = 0;
      else {
         // fits within time range so convert to #seconds since 1970
         expires = 0;
         NWTimeMap((DWORD) tag->byAccountExpires[2], 
                   (DWORD) tag->byAccountExpires[1], 
                   (DWORD) tag->byAccountExpires[0], 1970, &expires);
         NT_UInfo->acct_expires = expires;
      }

} // NWNetUserMapInfo


/////////////////////////////////////////////////////////////////////////
VOID 
NWFPNWMapInfo(
   VOID *NWUInfo, 
   PFPNW_INFO fpnw
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   struct tagLoginControl *tag;

   tag = (struct tagLoginControl *) NWUInfo;

   fpnw->MaxConnections = tag->wMaxConnections;
   fpnw->PasswordInterval = tag->wPasswordInterval;
   fpnw->GraceLoginAllowed = tag->byGraceLogins;
   fpnw->GraceLoginRemaining = tag->byGraceLoginReset;
   fpnw->LoginFrom = NULL;
   fpnw->HomeDir = NULL;

} // NWFPNWMapInfo


/////////////////////////////////////////////////////////////////////////
VOID 
NWUserDefaultsGet(
   VOID **UDefaults
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   struct tagUserDefaults *UserDefaults = NULL;
   NWCCODE ret;
   BYTE bySegment[128];
   BYTE byMoreSegments, byPropertyFlags;

   ret = NWReadPropertyValue(CachedConn, SUPERVISOR, OT_USER, USER_DEFAULTS, 1, bySegment, &byMoreSegments, &byPropertyFlags);

   if (ret == SUCCESSFUL) {
      UserDefaults = AllocMemory(sizeof(struct tagUserDefaults));
      memcpy(UserDefaults, bySegment, sizeof (struct tagUserDefaults));

      // Now put the data in 'normal' Intel format
      SWAPBYTES(UserDefaults->wPasswordInterval);
      SWAPBYTES(UserDefaults->wMaxConnections);
      SWAPWORDS(UserDefaults->lBalance);
      SWAPWORDS(UserDefaults->lCreditLimit);
      SWAPWORDS(UserDefaults->lMaxDiskBlocks);
   }

   *UDefaults = (void *) UserDefaults;

} // NWUserDefaultsGet


/////////////////////////////////////////////////////////////////////////
VOID 
NWUserDefaultsMap(
   VOID *NWUDefaults, 
   NT_DEFAULTS *NTDefaults
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   struct tagUserDefaults *UserDefaults = NULL;

   if ((NWUDefaults == NULL) || (NTDefaults == NULL))
      return;

   UserDefaults = (struct tagUserDefaults *) NWUDefaults;

   NTDefaults->min_passwd_len = (DWORD) UserDefaults->byMinPasswordLength;
   NTDefaults->max_passwd_age = (DWORD) UserDefaults->wPasswordInterval * 86400;
   NTDefaults->force_logoff = (DWORD) UserDefaults->byGraceLoginReset;

   // These fields aren't used/converted
   //   NTDefaults->min-passwd_age - no such thing for NetWare
   //   NTDefaults->password_hist_len - no such thing for NetWare

} // NWUserDefaultsMap


/////////////////////////////////////////////////////////////////////////
VOID
NWLoginTimesLog(
   BYTE *Times
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   TCHAR *szDays[7];
   DWORD Day;
   DWORD Hours;
   int Bit = 0, i;
   static TCHAR szHours[80];

   szDays[0] = Lids(IDS_SUN);
   szDays[1] = Lids(IDS_MON);
   szDays[2] = Lids(IDS_TUE);
   szDays[3] = Lids(IDS_WED);
   szDays[4] = Lids(IDS_THU);
   szDays[5] = Lids(IDS_FRI);
   szDays[6] = Lids(IDS_SAT);

   LogWriteLog(1, Lids(IDS_CRLF));
   LogWriteLog(1, Lids(IDS_L_104));

   // while these should be level 2, there isn't room on 80 cols - so level 1
   LogWriteLog(1, Lids(IDS_L_1));
   LogWriteLog(1, Lids(IDS_L_2));
   LogWriteLog(1, Lids(IDS_L_3));

   for (Day = 0; Day < 7; Day++) {
      LogWriteLog(1, szDays[Day]);
      lstrcpy(szHours, TEXT(" "));

      for (Hours = 0; Hours < 24; Hours++) {
         for (i = 0; i < 2; i++) {
            if (BitTest(Bit, Times))
               lstrcat(szHours, TEXT("*"));
            else
               lstrcat(szHours, TEXT(" "));

            Bit++;
         }

         lstrcat(szHours, TEXT(" "));    
      }

      LogWriteLog(0, szHours);
      LogWriteLog(0, Lids(IDS_CRLF));
   }

   LogWriteLog(0, Lids(IDS_CRLF));

} // NWLoginTimesLog


/////////////////////////////////////////////////////////////////////////
VOID
NWUserDefaultsLog(
   VOID *UDefaults
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   struct tagUserDefaults *tag;

   tag = (struct tagUserDefaults *) UDefaults;

   // Account expires
   LogWriteLog(1, Lids(IDS_L_109));
   if (tag->byAccountExpiresYear == 0)
      LogWriteLog(0, Lids(IDS_L_107));
   else
      LogWriteLog(0, TEXT("%02u/%02u/%04u"), (UINT) tag->byAccountExpiresDay,
               (UINT) tag->byAccountExpiresMonth, (UINT) 1900 + tag->byAccountExpiresYear);

   LogWriteLog(0, Lids(IDS_CRLF));

   // Restrictions
   LogWriteLog(1, Lids(IDS_L_110));
   // user can change password
   if ((tag->byRestrictions & 0x01))
      LogWriteLog(2, Lids(IDS_L_111));
   else
      LogWriteLog(2, Lids(IDS_L_112));

   // unique password required
   if ((tag->byRestrictions & 0x02))
      LogWriteLog(2, Lids(IDS_L_113), Lids(IDS_YES));
   else
      LogWriteLog(2, Lids(IDS_L_113), Lids(IDS_NO));

   // Password interval
   LogWriteLog(1, Lids(IDS_L_114));
   if (tag->wPasswordInterval == 0)
      LogWriteLog(0, Lids(IDS_L_107));
   else
      LogWriteLog(0, TEXT("%u"), (UINT) tag->wPasswordInterval);

   LogWriteLog(0, Lids(IDS_CRLF));

   // Grace Logins
   LogWriteLog(1, Lids(IDS_L_115));
   if (tag->byGraceLoginReset == 0xff)
      LogWriteLog(0, Lids(IDS_L_108));
   else
      LogWriteLog(0, TEXT("%u"), (UINT) tag->byGraceLoginReset);

   LogWriteLog(0, Lids(IDS_CRLF));

   LogWriteLog(1, Lids(IDS_L_116), (UINT) tag->byMinPasswordLength);

   // Max Connections
   LogWriteLog(1, Lids(IDS_L_117));
   if (tag->wMaxConnections == 0)
      LogWriteLog(0, Lids(IDS_L_108));
   else
      LogWriteLog(0, TEXT("%u"), (UINT) tag->wMaxConnections);

   LogWriteLog(0, Lids(IDS_CRLF));

   LogWriteLog(1, Lids(IDS_L_118), (ULONG) tag->lBalance);
   LogWriteLog(1, Lids(IDS_L_119), (ULONG) tag->lCreditLimit);

   // Max Disk blocks
   LogWriteLog(1, Lids(IDS_L_120));
   if (tag->lMaxDiskBlocks == 0x7FFFFFFF)
      LogWriteLog(0, Lids(IDS_L_108));
   else
      LogWriteLog(0, TEXT("%lu"), (ULONG) tag->lMaxDiskBlocks);

   LogWriteLog(0, Lids(IDS_CRLF));
   LogWriteLog(0, Lids(IDS_CRLF));

} // NWUserDefaultsLog


/////////////////////////////////////////////////////////////////////////
VOID
NWUserInfoLog(
   LPTSTR szUserName, 
   VOID *UInfo
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   struct tagLoginControl *tag;
   LPTSTR FullName;

   tag = (struct tagLoginControl *) UInfo;

   LogWriteLog(1, Lids(IDS_L_105));

   // Full Name
   LogWriteLog(2, Lids(IDS_L_106));

   FullName = NWUserNameGet(szUserName);
   if (FullName != NULL)
      LogWriteLog(2, FullName);
   
   LogWriteLog(0, Lids(IDS_CRLF));

   // Account disabled
   if (tag->byAccountDisabled == 0xff)
      LogWriteLog(2, Lids(IDS_L_121), Lids(IDS_YES));
   else if ((tag->wBadLogins == 0xffff) &&
            (tag->lNextResetTime > (LONG)CachedServerTime))
      LogWriteLog(2,  Lids(IDS_L_121), Lids(IDS_LOCKED_OUT));
   else
      LogWriteLog(2,  Lids(IDS_L_121), Lids(IDS_NO));

   // Account expires
   LogWriteLog(2, Lids(IDS_L_109));
   if (tag->byAccountExpires[0] == 0)
      LogWriteLog(0, Lids(IDS_L_107));
   else
      LogWriteLog(0, TEXT("%02u/%02u/%04u"), (UINT) tag->byAccountExpires[1],
               (UINT) tag->byAccountExpires[2], (UINT) 1900 + tag->byAccountExpires[0]);

   LogWriteLog(0, Lids(IDS_CRLF));

   // Password Expires
   LogWriteLog(2, Lids(IDS_L_122));
   if (tag->byPasswordExpires[0] == 0)
      LogWriteLog(0, Lids(IDS_L_107));
   else
      LogWriteLog(0, TEXT("%02u/%02u/19%02u"), (int) tag->byPasswordExpires[1],
               (int) tag->byPasswordExpires[2], (int) tag->byPasswordExpires[0]);

   LogWriteLog(0, Lids(IDS_CRLF));

   // Grace logins
   LogWriteLog(2, Lids(IDS_L_123));
   if (tag->byGraceLogins == 0xff)
      LogWriteLog(0, Lids(IDS_L_108));
   else
      LogWriteLog(0, TEXT("%u"), (UINT) tag->byGraceLogins);

   LogWriteLog(0, Lids(IDS_CRLF));

   // initial grace logins
   LogWriteLog(2, Lids(IDS_L_115));
   if (tag->byGraceLoginReset == 0xff)
      LogWriteLog(0, Lids(IDS_L_108));
   else
      LogWriteLog(0, TEXT("%u"), (UINT) tag->byGraceLoginReset);

   LogWriteLog(0, Lids(IDS_CRLF));

   // Min password length
   LogWriteLog(2, Lids(IDS_L_116), (UINT) tag->byMinPasswordLength);

   // Password expiration
   LogWriteLog(2, Lids(IDS_L_114));
   if (tag->wPasswordInterval == 0)
      LogWriteLog(0, Lids(IDS_L_107));
   else
      LogWriteLog(0, TEXT("%u"), (UINT) tag->wPasswordInterval);

   LogWriteLog(0, Lids(IDS_CRLF));

   // Max connections
   LogWriteLog(2, Lids(IDS_L_117));
   if (tag->wMaxConnections == 0)
      LogWriteLog(0, Lids(IDS_L_108));
   else
      LogWriteLog(0, TEXT("%u"), (UINT) tag->wMaxConnections);

   LogWriteLog(0, Lids(IDS_CRLF));

   // Restrictions
   // user can change password
   LogWriteLog(2, Lids(IDS_L_110));
   if ((tag->byRestrictions & 0x01))
      LogWriteLog(3, Lids(IDS_L_111));
   else
      LogWriteLog(3, Lids(IDS_L_112));

   // unique password required
   if ((tag->byRestrictions & 0x02))
      LogWriteLog(3, Lids(IDS_L_113), Lids(IDS_YES));
   else
      LogWriteLog(3, Lids(IDS_L_113), Lids(IDS_NO));

   LogWriteLog(2, Lids(IDS_L_124), (UINT) tag->wBadLogins);

   // Max Disk Blocks
   LogWriteLog(2, Lids(IDS_L_120));
   if (tag->lMaxDiskBlocks == 0x7FFFFFFF)
      LogWriteLog(0, Lids(IDS_L_108));
   else
      LogWriteLog(0, TEXT("%lX"), tag->lMaxDiskBlocks);

   LogWriteLog(0, Lids(IDS_CRLF));

   // Login Times
   NWLoginTimesLog(tag->byLoginTimes);

} // NWUserInfoLog


/////////////////////////////////////////////////////////////////////////
VOID
NWUserInfoGet(
   LPTSTR szUserName, 
   VOID **UInfo
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static struct tagLoginControl xUI;
   struct tagLoginControl *UserInfo = NULL;
   char szAnsiUserName[MAX_USER_NAME_LEN];
   NWCCODE ret;
   BYTE bySegment[128];
   BYTE byMoreSegments, byPropertyFlags;

   CharToOem(szUserName, szAnsiUserName);
   ret = NWReadPropertyValue(CachedConn, szAnsiUserName, OT_USER, LOGIN_CONTROL, 1, bySegment, &byMoreSegments, &byPropertyFlags);

   if (ret == SUCCESSFUL) {
      UserInfo = &xUI;
      memset(UserInfo, 0, sizeof(struct tagLoginControl));
      memcpy(UserInfo, bySegment, sizeof (struct tagLoginControl));

      // Now put the data in 'normal' Intel format
      SWAPBYTES(UserInfo->wPasswordInterval);
      SWAPBYTES(UserInfo->wMaxConnections);
      SWAPWORDS(UserInfo->lMaxDiskBlocks);
      SWAPBYTES(UserInfo->wBadLogins);
      SWAPWORDS(UserInfo->lNextResetTime);
   }

   *UInfo = (void *) UserInfo;

} // NWUserInfoGet


/////////////////////////////////////////////////////////////////////////
DWORD
NWServerEnum(
   LPTSTR Container, 
   SERVER_BROWSE_LIST **lpServList
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   int NumBufs = 0;
   DWORD TotalEntries = 0;
   ENUM_REC *BufHead, *CurrBuf, *OldBuf;
   SERVER_BROWSE_LIST *ServList = NULL;
   SERVER_BROWSE_BUFFER *SList = NULL;
   DWORD status = 0;
   DWORD i, j;
   NETRESOURCE ResourceBuf;

   // Container is ignored - NW is a flat network topology...
   SetProvider(NW_PROVIDER, &ResourceBuf);

   BufHead = CurrBuf = OldBuf = NULL;   
   status = EnumBufferBuild(&BufHead, &NumBufs, ResourceBuf);

   if (!status) {
      // We have 0 to xxx Enum recs each with a buffer sitting off of it.  Now
      // need to consolidate these into one global enum list...
      if (NumBufs) {
         CurrBuf = BufHead;

         // Figure out how many total entries there are
         while (CurrBuf) {
            TotalEntries += CurrBuf->cEntries;
            CurrBuf = CurrBuf->next;
         }

         CurrBuf = BufHead;

         // Now create a Server List to hold all of these.
         ServList =  AllocMemory(sizeof(SERVER_BROWSE_LIST) + TotalEntries * sizeof(SERVER_BROWSE_BUFFER));

         if (ServList == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
         } else {
            ServList->Count = TotalEntries;
            SList = (SERVER_BROWSE_BUFFER *) &ServList->SList;

            j = 0;

            // Now loop through copying the data...
            while (CurrBuf) {
               for(i = 0; i < CurrBuf->cEntries; i++) {
                  if (CurrBuf->lpnr[i].lpRemoteName != NULL)
                     if (CurrBuf->lpnr[i].lpRemoteName[0] == TEXT('\\') && CurrBuf->lpnr[i].lpRemoteName[1] == TEXT('\\'))
                        lstrcpy(SList[j].Name, &CurrBuf->lpnr[i].lpRemoteName[2]);
                     else
                        lstrcpy(SList[j].Name, CurrBuf->lpnr[i].lpRemoteName);
                  else
                     lstrcpy(SList[j].Name, TEXT(""));

                  if (CurrBuf->lpnr[i].lpComment != NULL)
                     lstrcpy(SList[j].Description, CurrBuf->lpnr[i].lpComment);
                  else
                     lstrcpy(SList[j].Description, TEXT(""));

                  SList[j].Container = FALSE;
                  j++;
               }

               OldBuf = CurrBuf;
               CurrBuf = CurrBuf->next;

               // Free the old buffer
               FreeMemory((HGLOBAL) OldBuf);
   
            } // while

         } // else  (ServList)

      } // if (numbufs)

   }

   *lpServList = ServList;
   return status;

} // NWServerEnum


/////////////////////////////////////////////////////////////////////////
ULONG 
NWShareSizeGet(
   LPTSTR Share
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR RootPath[MAX_PATH + 1];
   DWORD sectorsPC, bytesPS, FreeClusters, Clusters;
   DWORD TotalSpace, FreeSpace;

   TotalSpace = FreeSpace = 0;

   wsprintf(RootPath, TEXT("\\\\%s\\%s\\"), CachedServer, Share);
   if (GetDiskFreeSpace(RootPath, &sectorsPC, &bytesPS, &FreeClusters, &Clusters)) {
      TotalSpace = Clusters * sectorsPC * bytesPS;
      FreeSpace = FreeClusters * sectorsPC * bytesPS;
   }

   // total - free = approx allocated space (if multiple shares on drive then
   // this doesn't take that into account, we just want an approximation...
   return TotalSpace - FreeSpace;

} // NWShareSizeGet


/////////////////////////////////////////////////////////////////////////
DWORD 
NWSharesEnum(
   SHARE_LIST **lpShares
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   int NumBufs = 0;
   DWORD TotalEntries = 0;
   ENUM_REC *BufHead, *CurrBuf, *OldBuf;
   SHARE_LIST *ShareList = NULL;
   SHARE_BUFFER *SList = NULL;
   DWORD status;
   DWORD i, j;
   NETRESOURCE ResourceBuf;

   // Setup NETRESOURCE data structure
   SetProvider(NW_PROVIDER, &ResourceBuf);

   ResourceBuf.lpRemoteName = CachedServer;
   ResourceBuf.dwUsage = RESOURCEUSAGE_CONTAINER;
   
   status = EnumBufferBuild(&BufHead, &NumBufs, ResourceBuf);

   if (!status) {
      // We have 0 to xxx Enum recs each with a buffer sitting off of it.  Now
      // need to consolidate these into one global enum list...
      if (NumBufs) {
         CurrBuf = BufHead;

         // Figure out how many total entries there are
         while (CurrBuf) {
            TotalEntries += CurrBuf->cEntries;
            CurrBuf = CurrBuf->next;
         }

         CurrBuf = BufHead;

         // Now create a Server List to hold all of these.
         ShareList =  (SHARE_LIST *) AllocMemory(sizeof(SHARE_LIST) + (TotalEntries * sizeof(SHARE_BUFFER)));

         if (ShareList == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
         } else {
            j = 0;

            // Zero out everything and get pointer to list
            memset(ShareList, 0, sizeof(SHARE_LIST) + (TotalEntries * sizeof(SHARE_BUFFER)));
            ShareList->Count = TotalEntries;
            SList = (SHARE_BUFFER *) &ShareList->SList;

            // Now loop through copying the data...
            while (CurrBuf) {
               for(i = 0; i < CurrBuf->cEntries; i++) {
                  if (CurrBuf->lpnr[i].lpRemoteName != NULL)
                     lstrcpy(SList[j].Name, ShareNameParse(CurrBuf->lpnr[i].lpRemoteName));
                  else
                     lstrcpy(SList[j].Name, TEXT(""));

                  SList[j].Size = NWShareSizeGet(SList[j].Name);
                  SList[j].Index = (USHORT) j;
                  j++;
               }

               OldBuf = CurrBuf;
               CurrBuf = CurrBuf->next;

               // Free the old buffer
               FreeMemory((HGLOBAL) OldBuf);
   
            } // while

         } // else  (ShareList)

      } // if (numbufs)

   }

   *lpShares = ShareList;
   return status;

} // NWSharesEnum


/////////////////////////////////////////////////////////////////////////
VOID 
NWServerInfoReset(
   SOURCE_SERVER_BUFFER *SServ
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static VERSION_INFO NWInfo;
   NWCCODE ret = 0;

   ret = NWGetFileServerVersionInfo(CachedConn, &NWInfo);

   // BUGBUG:  This API returns fail (8801) - but is actually succeding,
   // just ignore error for right now as it really doesn't matter for the
   // version info.
//   if (ret == SUCCESSFUL) {
      SServ->VerMaj = NWInfo.Version;
      SServ->VerMin = NWInfo.SubVersion;
//   }

} // NWServerInfoReset


/////////////////////////////////////////////////////////////////////////
VOID 
NWServerInfoSet(
   LPTSTR ServerName, 
   SOURCE_SERVER_BUFFER *SServ
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static VERSION_INFO NWInfo;
   NWCCODE ret = 0;

   CursorHourGlass();
   lstrcpy(SServ->Name, ServerName);
   NWServerInfoReset(SServ);

   // Fill in share list
   NWSharesEnum(&SServ->ShareList);

#ifdef DEBUG
{
   DWORD i;

   dprintf(TEXT("Adding NW Server: %s\n"), SServ->Name);
   dprintf(TEXT("   Version: %u.%u\n"), (UINT) SServ->VerMaj, (UINT) SServ->VerMin);
   dprintf(TEXT("   Shares\n"));
   dprintf(TEXT("   +---------------------------------------+\n"));
   if (SServ->ShareList) {
      for (i = 0; i < SServ->ShareList->Count; i++) {
         dprintf(TEXT("   %-15s     AllocSpace %lu\n"), SServ->ShareList->SList[i].Name, SServ->ShareList->SList[i].Size);
      }
   }
   else
      dprintf(TEXT("   <Serv List enum failed!!>\n"));

   dprintf(TEXT("\n"));

}
#endif

   CursorNormal();

} // NWServerInfoSet


/////////////////////////////////////////////////////////////////////////
BOOL 
NWServerValidate(
   HWND hWnd, 
   LPTSTR ServerName, 
   BOOL DupFlag
   )

/*++

Routine Description:

    Validates a given server - makes sure it can be connected to and
    that the user has admin privs on it.

Arguments:


Return Value:


--*/

{
   DWORD Status;
   BOOL ret = FALSE;
   SOURCE_SERVER_BUFFER *SServ = NULL;
   DWORD dwObjectID = 0;
   DWORD Size;
   BYTE AccessLevel;
   TCHAR UserName[MAX_USER_NAME_LEN + 1];
   static TCHAR LocServer[MAX_SERVER_NAME_LEN+3];
   LPVOID lpMessageBuffer;

   CursorHourGlass();

   if (DupFlag)
      SServ = SServListFind(ServerName);

   if (SServ == NULL) {
      // Get Current Logged On User
      lstrcpy(UserName, TEXT(""));
      Size = sizeof(UserName);
      WNetGetUser(NULL, UserName, &Size);

      lstrcpy(LocServer, TEXT("\\\\"));
      lstrcat(LocServer, ServerName);

      if (UseAddPswd(hWnd, UserName, LocServer, Lids(IDS_S_6), NW_PROVIDER)) {

         Status = NWServerSet(ServerName);

         if (Status) {

            if (GetLastError() != 0)
               WarningError(Lids(IDS_NWCANT_CON), ServerName);

         } else {
            if (IsNCPServerFPNW(CachedConn))
               WarningError(Lids(IDS_E_18), ServerName);
            else {
               Status = NWCGetBinderyAccessLevel(CachedConn, &AccessLevel, &dwObjectID);

               if (!Status) {
                  AccessLevel &= BS_SUPER_READ;
                  if (AccessLevel == BS_SUPER_READ)
                     ret = TRUE;
                  else
                     WarningError(Lids(IDS_NWNO_ADMIN), ServerName);
               }
            }
         }
      } else {
         FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL, GetLastError(), 0,
                        (LPTSTR) &lpMessageBuffer, 0, NULL );

            if (GetLastError() != 0)
               WarningError(Lids(IDS_E_9), ServerName, lpMessageBuffer);

         LocalFree(lpMessageBuffer);
      }
   } else {
      // Already in source server list - can't appear more then once
      WarningError(Lids(IDS_E_14), ServerName);
   }

   CursorNormal();
   return ret;

} // NWServerValidate


/////////////////////////////////////////////////////////////////////////
LPTSTR 
NWRightsLog(
   DWORD Rights
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR NWRights[15];
   
   lstrcpy(NWRights, Lids(IDS_S_34));

   // Read
   if (!(Rights & 0x01))
      NWRights[2] = TEXT(' ');

   // Write
   if (!(Rights & 0x02))
      NWRights[3] = TEXT(' ');

   // Create
   if (!(Rights & 0x08))
      NWRights[4] = TEXT(' ');

   // Delete (Erase)
   if (!(Rights & 0x10))
      NWRights[5] = TEXT(' ');

   // Parental
   if (!(Rights & 0x20))
      NWRights[8] = TEXT(' ');

   // Search
   if (!(Rights & 0x40))
      NWRights[7] = TEXT(' ');

   // Modify
   if (!(Rights & 0x80))
      NWRights[6] = TEXT(' ');

   // Supervisor (all rights set)
   if ((Rights & 0xFB) != 0xFB)
      NWRights[1] = TEXT(' ');

   return NWRights;

} // NWRightsLog


/////////////////////////////////////////////////////////////////////////
NTSTATUS 
MapNwRightsToNTAccess( 
   ULONG NWRights, 
   PRIGHTS_MAPPING pMap, 
   ACCESS_MASK *pAccessMask
   )

/*++

Routine Description:

  Map a NW Right to the appropriate NT AccessMask

Arguments:

   NWRights - Netware rights we wish to map
   pMap - pointer to structure that defines the mapping

Return Value:

   The NT AccessMask corresponding to the NW Rights

--*/

{
    PNW_TO_NT_MAPPING pNWToNtMap = pMap->Nw2NtMapping ;
    ACCESS_MASK AccessMask = 0 ;

    if (!pAccessMask)
        return STATUS_INVALID_PARAMETER ;

    *pAccessMask = 0x0 ;

    // go thru the mapping structuring, OR-ing in bits along the way
    while (pNWToNtMap->NWRight) {

        if (pNWToNtMap->NWRight & NWRights)
            AccessMask |= pNWToNtMap->NTAccess ;

        pNWToNtMap++ ;
    }

    *pAccessMask = AccessMask ;

    return STATUS_SUCCESS ;
} // MapNwRightsToNTAccess


/////////////////////////////////////////////////////////////////////////
DWORD 
NWPrintServersEnum(
   PRINT_SERVER_LIST **PS
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   PRINT_SERVER_LIST *psl;
   PRINT_SERVER_BUFFER *pbuff;
   DWORD NumRecs = DEF_NUM_RECS;   // Default 200 names
   DWORD Count = 0;
   DWORD status = 0;
   char szAnsiPrinterName[MAX_USER_NAME_LEN + 1];
   TCHAR szPrinterName[MAX_USER_NAME_LEN + 1];
   WORD wFoundUserType = 0;
   DWORD dwObjectID = 0xFFFFFFFFL;
   BYTE byPropertiesFlag = 0;
   BYTE byObjectFlag = 0;
   BYTE byObjectSecurity = 0;
   NWCCODE ret;

   psl =  (PRINT_SERVER_LIST *) AllocMemory(sizeof(PRINT_SERVER_LIST) + (NumRecs * sizeof(PRINT_SERVER_BUFFER)));

   if (!psl) {
      status = ERROR_NOT_ENOUGH_MEMORY;
   } else {
      pbuff = psl->PSList;

      // init to NULL so doesn't have garbage if call fails
      lstrcpyA(szAnsiPrinterName, "");

      // Loop through bindery getting all the users.
      while ((ret = NWScanObject(CachedConn, "*", OT_PRINT_SERVER, &dwObjectID, szAnsiPrinterName,
                           &wFoundUserType, &byPropertiesFlag,
                           &byObjectFlag, &byObjectSecurity)) == SUCCESSFUL) {

         // Got user - now convert and save off the information
         OemToChar(szAnsiPrinterName, szPrinterName);

         lstrcpy(pbuff[Count].Name, szPrinterName);
         Count++;

         // Check if we have to re-allocate buffer
         if (Count >= NumRecs) {
            NumRecs += DEF_NUM_RECS;
            psl =  (PRINT_SERVER_LIST *) ReallocMemory((HGLOBAL) psl, sizeof(PRINT_SERVER_LIST) + (NumRecs * sizeof(PRINT_SERVER_BUFFER)));
            pbuff = psl->PSList;

            if (!psl) {
               status = ERROR_NOT_ENOUGH_MEMORY;
               break;
            }

         }

      }

      // Gotta clear this out from the last loop
      if (Count)
         ret = 0;

   }

   // check if error occured...
   if (ret) 
      status = ret;

   // Now slim down the list to just what we need.
   if (!status) {
      psl =  (PRINT_SERVER_LIST *) ReallocMemory((HGLOBAL) psl, sizeof(PRINT_SERVER_LIST) + (Count * sizeof(PRINT_SERVER_BUFFER)));

      if (!psl)
         status = ERROR_NOT_ENOUGH_MEMORY;
   }

   psl->Count = Count;
   *PS = psl;

   return status;

} // NWPrintServersEnum


/////////////////////////////////////////////////////////////////////////
DWORD 
NWPrintOpsEnum(
   USER_LIST **lpUsers
   )

/*++

Routine Description:

   First need to enumerate all the print servers on the NetWare system
   we are pointing to.  Next loop through each of these print servers
   and enumerate the print operators on each of them.

Arguments:


Return Value:


--*/

{
   PRINT_SERVER_LIST *psl = NULL;
   PRINT_SERVER_BUFFER *PSList;
   ULONG pCount;
   USER_LIST *Users = NULL;
   USER_BUFFER *UserBuffer;
   DWORD NumRecs = DEF_NUM_RECS;   // Default 200 names
   DWORD Count = 0;
   DWORD ipsl = 0, iseg = 0;
   DWORD status = 0;
   char szAnsiUserName[MAX_USER_NAME_LEN + 1];
   char szAnsiName[MAX_GROUP_NAME_LEN + 1];
   TCHAR szUserName[MAX_USER_NAME_LEN + 1];
   WORD wFoundUserType = 0;
   DWORD dwObjectID = 0xFFFFFFFFL;
   BYTE byPropertyFlags = 0;
   BYTE byObjectFlag = 0;
   BYTE byObjectSecurity = 0;
   UCHAR Segment = 1;
   DWORD bySegment[32];
   BYTE byMoreSegments;
   NWCCODE ret;

   *lpUsers = NULL;

   // Enumerate the print servers - if there are none, then there are no printer ops
   NWPrintServersEnum(&psl);
   if ((psl == NULL) || (psl->Count == 0)) {
      if (psl != NULL)
         FreeMemory(psl);

      return 0;
   }

   // Got some servers - loop through them enumerating users
   Users =  (USER_LIST *) AllocMemory(sizeof(USER_LIST) + (sizeof(USER_BUFFER) * NumRecs));

   if (!Users) {
      status = ERROR_NOT_ENOUGH_MEMORY;
   } else {
      UserBuffer = Users->UserBuffer;
      PSList = psl->PSList;

      for (pCount = 0; pCount < psl->Count; pCount++) {
         // init to NULL so doesn't have garbage if call fails
         lstrcpyA(szAnsiUserName, "");
         CharToOem(PSList[ipsl++].Name, szAnsiName);

         // Loop through bindery getting all the users.
         do {
            if (!(ret = NWReadPropertyValue(CachedConn, szAnsiName, OT_PRINT_SERVER, PS_OPERATORS,
                           Segment, (BYTE *) bySegment, &byMoreSegments, &byPropertyFlags))) {

               Segment++;
               // loop through properties converting them to user names
               iseg = 0;
               while ((bySegment[iseg]) && (iseg < 32)) {
                  if (!(ret = NWGetObjectName(CachedConn, bySegment[iseg], szAnsiUserName, &wFoundUserType))) {
                     // Got user - now convert and save off the information
                     OemToChar(szAnsiUserName, szUserName);

                     // Map out Supervisor (already print-op privs)
                     if (lstrcmpi(szUserName, Lids(IDS_S_28))) {
                        lstrcpy(UserBuffer[Count].Name, szUserName);
                        lstrcpy(UserBuffer[Count].NewName, szUserName);
                        Count++;
                     }

                     // Check if we have to re-allocate buffer
                     if (Count >= NumRecs) {
                        NumRecs += DEF_NUM_RECS;
                        Users = (USER_LIST *) ReallocMemory((HGLOBAL) Users, sizeof(USER_LIST) + (sizeof(USER_BUFFER) * NumRecs));
               
                        if (!Users) {
                           status = ERROR_NOT_ENOUGH_MEMORY;
                           break;
                        }

                        UserBuffer = Users->UserBuffer;
                     }
                  }
                  iseg++;
               }

            } else // if NWReadPropertyValue
               byMoreSegments = 0;

         } while (byMoreSegments);

         // Gotta clear this out from the last loop
         if (Count)
            ret = 0;
      }
   }

   // check if error occured...
   if (ret) 
      status = ret;

   // Now slim down the list to just what we need.
   if (!status) {
      Users = (USER_LIST *) ReallocMemory((HGLOBAL) Users, sizeof(USER_LIST) + (sizeof(USER_BUFFER) * Count));

      if (!Users)
         status = ERROR_NOT_ENOUGH_MEMORY;
      else {
         // Sort the server list before putting it in the dialog
         UserBuffer = Users->UserBuffer;
         qsort((void *) UserBuffer, (size_t) Count, sizeof(USER_BUFFER), UserListCompare);
      }
   }

   Users->Count = Count;
   *lpUsers = Users;

   return status;

} // NWPrintOpsEnum



/////////////////////////////////////////////////////////////////////////

VOID
NWServerTimeGet(
    )

/*++

Routine Description:

    Queries server for it's current local time which is then converted to
    elasped minutes since 1985 in order to compare with the lNextResetTime
    field of the LOGIN_CONTROL structure (which must be byte-aligned).

Arguments:

    None.

Return Value:

    None.

--*/

{
    DWORD dwYear = 0;
    DWORD dwMonth = 0;
    DWORD dwDay = 0;
    DWORD dwHour = 0;
    DWORD dwMinute = 0;
    DWORD dwSecond = 0;
    DWORD dwDayOfWeek = 0;
    DWORD dwServerTime = 0;

    CachedServerTime = 0xffffffff; // re-initialize...

    if (!NWGetFileServerDateAndTime(
            CachedConn,
            (LPBYTE)&dwYear,
            (LPBYTE)&dwMonth,
            (LPBYTE)&dwDay,
            (LPBYTE)&dwHour,
            (LPBYTE)&dwMinute,
            (LPBYTE)&dwSecond,
            (LPBYTE)&dwDayOfWeek))
    {
        if (NWTimeMap(dwDay, dwMonth, dwYear, 1985, &dwServerTime))
        {
            dwServerTime += dwHour * 3600;
            dwServerTime += dwMinute * 60;
            dwServerTime += dwSecond;

            CachedServerTime = dwServerTime / 60; // convert to minutes...
        }
    }
}

/////////////////////////////////////////////////////////////////////////

BOOL
IsNCPServerFPNW(
    NWCONN_HANDLE Conn
    )

/*++

Routine Description:

    Check if this an FPNW server by checking for a specific object
    type and property.

Arguments:

    Conn - connection id of ncp server.

Return Value:

    Returns true if ncp server is fpnw.

--*/

{
    NWCCODE ret;
    BYTE bySegment[128];
    BYTE byMoreSegments, byPropertyFlags;

    memset(bySegment, 0, sizeof(bySegment));

    ret = NWReadPropertyValue(
            CachedConn,
            MS_EXTENDED_NCPS,
            0x3B06,
            FPNW_PDC,
            1,
            bySegment,
            &byMoreSegments,
            &byPropertyFlags
            );

    return (ret == SUCCESSFUL) && (BOOL)(BYTE)bySegment[0];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\nwlog.c ===
/*
  +-------------------------------------------------------------------------+
  |                         Logging Routines                                |
  +-------------------------------------------------------------------------+
  |                        (c) Copyright 1994                               |
  |                          Microsoft Corp.                                |
  |                        All rights reserved                              |
  |                                                                         |
  | Program               : [NWLog.c]                                       |
  | Programmer            : Arthur Hanson                                   |
  | Original Program Date : [Dec 01, 1993]                                  |
  | Last Update           : [Jun 16, 1994]                                  |
  |                                                                         |
  | Version:  1.00                                                          |
  |                                                                         |
  | Description:                                                            |
  |                                                                         |
  | History:                                                                |
  |   arth  Jun 16, 1994    1.00    Original Version.                       |
  |                                                                         |
  +-------------------------------------------------------------------------+
*/


#include "globals.h"

#include <io.h>
#include <malloc.h>
#include <string.h>

#define VER_HI  1
#define VER_LOW 1

HANDLE hErr = NULL;
HANDLE hLog = NULL;
HANDLE hSummary = NULL;

#define STD_EXT "LOG"
#define ERR_FILENAME "Error."
#define LOG_FILENAME "LogFile."
#define SUMMARY_FILENAME "Summary."

#define MAX_LOG_STR 1024
#define FILENAME_LOG "LogFile.LOG"
#define FILENAME_ERROR "Error.LOG"
#define FILENAME_SUMMARY "Summary.LOG"

static char LogFileName[MAX_PATH + 1];
static char ErrorLogFileName[MAX_PATH + 1];
static char SummaryLogFileName[MAX_PATH + 1];
static char Spaces[] = "                             ";

static BOOL ErrorFlag;
static TCHAR ErrorContext[MAX_LOG_STR];
static TCHAR ErrorCategory[MAX_LOG_STR];
static TCHAR ErrorItem[MAX_LOG_STR];
static TCHAR ErrorText[MAX_LOG_STR];
static TCHAR tmpStr[MAX_LOG_STR];
static BOOL CategoryWritten;
static BOOL ContextWritten;
static BOOL CategorySet;
static BOOL ItemSet;

static BOOL VerboseULogging = TRUE;
static BOOL VerboseFLogging = TRUE;
static BOOL ErrorBreak = FALSE;

static BOOL LogCancel = FALSE;

/*+-------------------------------------------------------------------------+
  | ErrorResetAll()
  |
  +-------------------------------------------------------------------------+*/
void ErrorResetAll() {
   ErrorFlag = FALSE;
   CategoryWritten = FALSE;
   ContextWritten = FALSE;
   CategorySet = FALSE;
   ItemSet = FALSE;

   lstrcpy(ErrorContext, TEXT(""));
   lstrcpy(ErrorCategory, TEXT(""));
   
} // ErrorResetAll


/*+-------------------------------------------------------------------------+
  | ErrorContextSet()
  |
  |    Sets the context for the error message, generally this would be
  |    the source and destination server pair.
  |
  +-------------------------------------------------------------------------+*/
void ErrorContextSet(LPTSTR szFormat, ...) {
   va_list marker;

   va_start(marker, szFormat);
   wvsprintf(ErrorContext, szFormat, marker);
   
   // Do category and item as well since context is higher level
   lstrcpy(ErrorCategory, TEXT(""));
   lstrcpy(ErrorItem, TEXT(""));
   
   ContextWritten = FALSE;
   CategoryWritten = FALSE;
   va_end(marker);

} // ErrorContextSet


/*+-------------------------------------------------------------------------+
  | ErrorCategorySet()
  |
  |    Sets the category for the error message, generally this would tell
  |    what type of items is being converted: "Converting Users"
  |
  +-------------------------------------------------------------------------+*/
void ErrorCategorySet(LPTSTR szFormat, ...) {
   va_list marker;

   va_start(marker, szFormat);
   wvsprintf(ErrorCategory, szFormat, marker);
   CategorySet = TRUE;
   ItemSet = FALSE;
   lstrcpy(ErrorItem, TEXT(""));
   CategoryWritten = FALSE;
   va_end(marker);

} // ErrorCategorySet


/*+-------------------------------------------------------------------------+
  | ErrorItemSet()
  |
  |    Defines the specific item that error'd.  This is usually a user,
  |    group or file name.
  |
  +-------------------------------------------------------------------------+*/
void ErrorItemSet(LPTSTR szFormat, ...) {
   va_list marker;

   va_start(marker, szFormat);
   ItemSet = TRUE;
   wvsprintf(ErrorItem, szFormat, marker);
   va_end(marker);

} // ErrorItemSet


/*+-------------------------------------------------------------------------+
  | ErrorReset()
  |
  +-------------------------------------------------------------------------+*/
void ErrorReset() {
   ErrorFlag = FALSE;
   lstrcpy(ErrorText, TEXT(""));
   
} // ErrorReset


/*+-------------------------------------------------------------------------+
  | ErrorSet()
  |
  +-------------------------------------------------------------------------+*/
void ErrorSet(LPTSTR szFormat, ...) {
   va_list marker;

   va_start(marker, szFormat);
   wvsprintf(ErrorText, szFormat, marker);
   ErrorFlag = TRUE;
   va_end(marker);

} // ErrorSet


BOOL ErrorOccured() {
   return ErrorFlag;
   
} // ErrorOccured


/*+-------------------------------------------------------------------------+
  | ErrorBox()
  |
  +-------------------------------------------------------------------------+*/
void ErrorBox(LPTSTR szFormat, ...) {
   va_list marker;

   va_start(marker, szFormat);
   wvsprintf(ErrorText, szFormat, marker);

   MessageBeep(MB_ICONASTERISK);
   MessageBox(NULL, ErrorText, (LPTSTR) Lids(IDS_E_2), MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OK);

   va_end(marker);
} // ErrorBox


/*+-------------------------------------------------------------------------+
  | ErrorBoxRetry()
  |
  +-------------------------------------------------------------------------+*/
int ErrorBoxRetry(LPTSTR szFormat, ...) {
   int ret;
   LPVOID lpMessageBuffer;
   va_list marker;

   va_start(marker, szFormat);
   wvsprintf(ErrorText, szFormat, marker);

   FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL, GetLastError(), 0,
                  (LPTSTR) &lpMessageBuffer, 0, NULL );

   MessageBeep(MB_ICONASTERISK);
   ret = MessageBox(NULL, (LPTSTR) lpMessageBuffer, ErrorText, 
                     MB_TASKMODAL | MB_ICONEXCLAMATION | MB_RETRYCANCEL);
   LocalFree(lpMessageBuffer);

   va_end(marker);

   return ret;
} // ErrorBoxRetry


/*+-------------------------------------------------------------------------+
  | FileOpenBackup()
  |
  |    Tries to open a file, if it already exists then creates a backup
  |    with the extension in the form (.001 to .999).  It tries .001 first
  |    and if already used then tries .002, etc...
  |
  +-------------------------------------------------------------------------+*/
HANDLE FileOpenBackup(CHAR *FileRoot, CHAR *FileExt) {
   int ret;
   HANDLE hFile = NULL;
   DWORD dwFileNumber;
   char FileName[MAX_PATH + 1];
   char buffer[MAX_PATH + 1];
   TCHAR FileNameW[MAX_PATH + 1];

   wsprintfA(FileName, "%s%s", FileRoot, FileExt);

   // Open, but fail if already exists.
   hFile = CreateFileA( FileName, GENERIC_READ | GENERIC_WRITE, 0,
                  NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL );

   // Check if Error - file exists
   if(hFile == INVALID_HANDLE_VALUE) {
      dwFileNumber = 0;

      // Find next backup number...
      // Files are backed up as .xxx where xxx is a number in the form .001,
      // the first backup is stored as .001, second as .002, etc...
      do {
         dwFileNumber++;
         wsprintfA(FileName, "%s%03u", FileRoot, dwFileNumber);

         hFile = CreateFileA( FileName, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, NULL);

         if (hFile != (HANDLE) INVALID_HANDLE_VALUE)
            CloseHandle( hFile );

      } while ( (hFile != INVALID_HANDLE_VALUE) );

      // Rename the last log file to the first available number
      wsprintfA( buffer, "%s%s", FileRoot, FileExt);
      MoveFileA( buffer, FileName);

      lstrcpyA(FileName, buffer);
      // Create the new log file
      hFile = CreateFileA( FileName, GENERIC_READ | GENERIC_WRITE, 0,
                     NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL );


      if (hFile != (HANDLE) INVALID_HANDLE_VALUE)
         CloseHandle( hFile );

   } else
      CloseHandle(hFile);

   wsprintfA(FileName, "%s%s", FileRoot, FileExt);

   // Now do the actual creation with error handling...
   do {
      ret = IDOK;
      hFile = CreateFileA( FileName, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 
                           FILE_ATTRIBUTE_NORMAL, NULL );

      if (hFile == INVALID_HANDLE_VALUE) {
         MultiByteToWideChar(CP_ACP, 0, FileName, -1, FileNameW, sizeof(FileNameW) );
         ret = ErrorBoxRetry(Lids(IDS_E_13), FileNameW);
      }

   } while(ret == IDRETRY);

   return(hFile);

} // FileOpenBackup


/*+-------------------------------------------------------------------------+
  | GetTime()
  |
  +-------------------------------------------------------------------------+*/
void GetTime(TCHAR *str) {
   SYSTEMTIME st;
   static TCHAR *aszDay[7];
   
   aszDay[0] = Lids(IDS_SUNDAY);
   aszDay[1] = Lids(IDS_MONDAY);
   aszDay[2] = Lids(IDS_TUESDAY);
   aszDay[3] = Lids(IDS_WEDNESDAY);
   aszDay[4] = Lids(IDS_THURSDAY);
   aszDay[5] = Lids(IDS_FRIDAY);
   aszDay[6] = Lids(IDS_SATURDAY);

   GetLocalTime(&st);

   wsprintf(str, TEXT("%s, %02u/%02u/%4u (%02u:%02u:%02u)"),
            aszDay[st.wDayOfWeek], st.wMonth,
            st.wDay, st.wYear,
            st.wHour, st.wMinute, st.wSecond);
} // GetTime


/*+-------------------------------------------------------------------------+
  | WriteLog()
  |
  +-------------------------------------------------------------------------+*/
DWORD WriteLog(HANDLE hFile, int Level, LPTSTR String) {
   int ret;
   DWORD wrote;
   static char tmpStr[MAX_LOG_STR];
   static char LogStr[MAX_LOG_STR];

   // If the user canceled writing to the log, then don't keep trying
   if (LogCancel)
      return 1;

   // Put ending NULL at correct place
   Spaces[Level * 3] = '\0';

   // Build up indented ANSI string to write out
   lstrcpyA(tmpStr, Spaces);
   WideCharToMultiByte(CP_ACP, 0, String, -1, LogStr, sizeof(LogStr), NULL, NULL);
   lstrcatA(tmpStr, LogStr);

   // reset for later writes
   Spaces[Level * 3] = ' ';


   // Now do the actual write with error handling...
   do {
      ret = IDOK;

      if (!WriteFile(hFile, tmpStr, strlen(tmpStr), &wrote, NULL)) {
         ret = ErrorBoxRetry(Lids(IDS_E_NWLOG));
      }

   } while(ret == IDRETRY);

   if (ret == IDCANCEL) {
      LogCancel = TRUE;
      return 1;
   }
   else
      return 0;

} // WriteLog


/*+-------------------------------------------------------------------------+
  | LogHeader()
  |
  +-------------------------------------------------------------------------+*/
void LogHeader(HANDLE hFile, TCHAR *Title) {
   DWORD ret;
   DWORD wrote;
   static TCHAR time[40];
   static TCHAR tmpStr[MAX_LOG_STR];
   static TCHAR tmpStr2[MAX_LOG_STR];
   static TCHAR *line;

   ret = WriteLog(hFile, 0, Lids(IDS_LINE));
   wsprintf(tmpStr, Lids(IDS_BRACE), Title);

   if (!ret)
      ret = WriteLog(hFile, 0, tmpStr);

   if (!ret)
      ret = WriteLog(hFile, 0, Lids(IDS_LINE));

   GetTime(time);
   wsprintf(tmpStr, Lids(IDS_L_97), time);

   if (!ret)
      ret = WriteLog(hFile, 0, tmpStr);

   wrote = sizeof(tmpStr2);
   GetComputerName(tmpStr2, &wrote);
   wsprintf(tmpStr, Lids(IDS_L_98), tmpStr2);

   if (!ret)
      WriteLog(hFile, 0, tmpStr);
         
   wrote = sizeof(tmpStr);
   WNetGetUser(NULL, tmpStr2, &wrote);
   wsprintf(tmpStr, Lids(IDS_L_99), tmpStr2);

   if (!ret)
      ret = WriteLog(hFile, 0, tmpStr);

   wsprintf(tmpStr, Lids(IDS_L_100), VER_HI, VER_LOW);

   if (!ret)
      ret = WriteLog(hFile, 0, tmpStr);

   if (!ret)
      ret = WriteLog(hFile, 0, Lids(IDS_LINE));

} // LogHeader


/*+-------------------------------------------------------------------------+
  | LogInit()
  |
  +-------------------------------------------------------------------------+*/
void LogInit() {
   lstrcpyA(LogFileName, FILENAME_LOG);
   lstrcpyA(ErrorLogFileName, FILENAME_ERROR);
   lstrcpyA(SummaryLogFileName, FILENAME_SUMMARY);

   LogCancel = FALSE;

   hErr = FileOpenBackup(ERR_FILENAME, STD_EXT);
   hLog = FileOpenBackup(LOG_FILENAME, STD_EXT);
   hSummary = FileOpenBackup(SUMMARY_FILENAME, STD_EXT);

   LogHeader(hErr, Lids(IDS_L_101));
   CloseHandle(hErr);

   LogHeader(hLog, Lids(IDS_L_102));
   CloseHandle(hLog);

   LogHeader(hSummary, Lids(IDS_L_103));
   CloseHandle(hSummary);

} // LogInit


/*+-------------------------------------------------------------------------+
  | LogWriteLog()
  |
  +-------------------------------------------------------------------------+*/
void LogWriteLog(int Level, LPTSTR szFormat, ...) {
   va_list marker;

   va_start(marker, szFormat);
   wvsprintf(tmpStr, szFormat, marker);

   hLog = CreateFileA( LogFileName, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
   SetFilePointer(hLog, 0, NULL, FILE_END);
   WriteLog(hLog, Level, tmpStr);
   CloseHandle(hLog);
   va_end(marker);

} // LogWriteLog


/*+-------------------------------------------------------------------------+
  | LogWritErr()
  |
  +-------------------------------------------------------------------------+*/
void LogWriteErr(LPTSTR szFormat, ...) {
   int Indent = 3;
   DWORD wrote;
   static char LogStr[MAX_LOG_STR];
   va_list marker;

   va_start(marker, szFormat);
   wvsprintf(tmpStr, szFormat, marker);

   hErr = CreateFileA( ErrorLogFileName, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
   SetFilePointer(hErr, 0, NULL, FILE_END);

   if (!ContextWritten) {
      ContextWritten = TRUE;
      WideCharToMultiByte(CP_ACP, 0, ErrorContext, -1, LogStr, sizeof(LogStr), NULL, NULL);
      WriteFile(hErr, LogStr, strlen(LogStr), &wrote, NULL);
   }
   
   if (CategorySet && !CategoryWritten) {
      CategoryWritten = TRUE;
      Spaces[3] = '\0';
      WriteFile(hLog, Spaces, strlen(Spaces), &wrote, NULL);
      WideCharToMultiByte(CP_ACP, 0, ErrorCategory, -1, LogStr, sizeof(LogStr), NULL, NULL);
      WriteFile(hErr, LogStr, strlen(LogStr), &wrote, NULL);
      Spaces[3] = ' ';
   }

   if (ItemSet) {
      Spaces[6] = '\0';
      WriteFile(hLog, Spaces, strlen(Spaces), &wrote, NULL);
      WideCharToMultiByte(CP_ACP, 0, ErrorItem, -1, LogStr, sizeof(LogStr), NULL, NULL);
      WriteFile(hErr, LogStr, strlen(LogStr), &wrote, NULL);
      Spaces[6] = ' ';
   }

   if (CategorySet)
      Indent +=3;

   if (ItemSet)
      Indent +=3;

   Spaces[Indent] = '\0';
   WriteFile(hLog, Spaces, strlen(Spaces), &wrote, NULL);
   WideCharToMultiByte(CP_ACP, 0, tmpStr, -1, LogStr, sizeof(LogStr), NULL, NULL);
   WriteFile(hErr, LogStr, strlen(LogStr), &wrote, NULL);
   Spaces[Indent] = ' ';
   CloseHandle(hErr);
   va_end(marker);

} // LogWriteErr


/*+-------------------------------------------------------------------------+
  | LogWriteSummary()
  |
  +-------------------------------------------------------------------------+*/
void LogWriteSummary(int Level, LPTSTR szFormat, ...) {
   DWORD wrote;
   static char LogStr[MAX_LOG_STR];
   va_list marker;

   va_start(marker, szFormat);
   Spaces[Level * 3] = '\0';
   wvsprintf(tmpStr, szFormat, marker);
   WideCharToMultiByte(CP_ACP, 0, tmpStr, -1, LogStr, sizeof(LogStr), NULL, NULL);

   hSummary = CreateFileA( SummaryLogFileName, GENERIC_WRITE, 0,
                     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
   SetFilePointer(hSummary, 0, NULL, FILE_END);
   WriteFile(hLog, Spaces, strlen(Spaces), &wrote, NULL);
   WriteFile(hSummary, LogStr, strlen(LogStr), &wrote, NULL);
   Spaces[Level * 3] = ' ';
   CloseHandle(hSummary);
   va_end(marker);

} // LogWriteSummary



/*+-------------------------------------------------------------------------+
  | DlgLogging()
  |
  +-------------------------------------------------------------------------+*/
LRESULT CALLBACK DlgLogging(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
   HANDLE hFile;
   static BOOL UserLogging, FileLogging, ErrorFlag;
   int wmId, wmEvent;
   static char CmdLine[256];
   HWND hCtrl;

   switch (message) {
      case WM_INITDIALOG:
         // Center the dialog over the application window
         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));

         // Toggle User Logging Control
         UserLogging = VerboseULogging;
         hCtrl = GetDlgItem(hDlg, IDC_CHKUVERBOSE);
         if (VerboseULogging)
            SendMessage(hCtrl, BM_SETCHECK, 1, 0);
         else
            SendMessage(hCtrl, BM_SETCHECK, 0, 0);

         // Toggle File Logging Control
         FileLogging = VerboseFLogging;
         hCtrl = GetDlgItem(hDlg, IDC_CHKFVERBOSE);
         if (VerboseFLogging)
            SendMessage(hCtrl, BM_SETCHECK, 1, 0);
         else
            SendMessage(hCtrl, BM_SETCHECK, 0, 0);

         // Toggle Error Popup Control
         ErrorFlag = ErrorBreak;
         hCtrl = GetDlgItem(hDlg, IDC_CHKERROR);
         if (ErrorBreak)
            SendMessage(hCtrl, BM_SETCHECK, 1, 0);
         else
            SendMessage(hCtrl, BM_SETCHECK, 0, 0);

         hCtrl = GetDlgItem(hDlg, IDC_VIEWLOG);
         
         // check if logfile exists, if it does allow log file viewing...
         hFile = CreateFileA( FILENAME_LOG, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, NULL);

         if (hFile != (HANDLE) INVALID_HANDLE_VALUE)
            CloseHandle( hFile );
         else
            EnableWindow(hCtrl, FALSE);

         return (TRUE);

      case WM_COMMAND:
         wmId    = LOWORD(wParam);
         wmEvent = HIWORD(wParam);

         switch (wmId) {
            case IDOK:
            VerboseULogging = UserLogging;
            VerboseFLogging = FileLogging;
            ErrorBreak = ErrorFlag;
            EndDialog(hDlg, 0);
            return (TRUE);
            break;

         case IDCANCEL:
            EndDialog(hDlg, 0);
            return (TRUE);

         case IDHELP:
            WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDC_HELP_LOGGING);
            break;

         case IDC_VIEWLOG:
            lstrcpyA(CmdLine, "LogView ");
            lstrcatA(CmdLine, "Error.LOG Summary.LOG LogFile.LOG");
            WinExec(CmdLine, SW_SHOW);
            return (TRUE);
            break;

         case IDC_CHKUVERBOSE:
            UserLogging = !UserLogging;
            return (TRUE);
            break;
            
         case IDC_CHKFVERBOSE:
            FileLogging = !FileLogging;
            return (TRUE);
            break;
            
         case IDC_CHKERROR:
            ErrorFlag = !ErrorFlag;
            return (TRUE);
            break;
         }

         break;
   }

   return (FALSE); // Didn't process the message

   lParam;
} // DlgLogging


/*+-------------------------------------------------------------------------+
  | LogOptionsInit()
  |
  +-------------------------------------------------------------------------+*/
void LogOptionsInit() {
   ErrorBreak = FALSE;
   VerboseULogging = TRUE;
   VerboseFLogging = FALSE;
} // LogOptionsInit


/*+-------------------------------------------------------------------------+
  | LogOptionsSave()
  |
  +-------------------------------------------------------------------------+*/
void LogOptionsSave( HANDLE hFile ) {
   DWORD wrote;
   
   WriteFile(hFile, &ErrorBreak, sizeof(ErrorBreak), &wrote, NULL);
   WriteFile(hFile, &VerboseFLogging, sizeof(VerboseFLogging), &wrote, NULL);
   WriteFile(hFile, &VerboseULogging, sizeof(VerboseULogging), &wrote, NULL);
} // LogOptionsSave


/*+-------------------------------------------------------------------------+
  | LogOptionsLoad()
  |
  +-------------------------------------------------------------------------+*/
void LogOptionsLoad( HANDLE hFile ) {
   DWORD wrote;
   
   ReadFile(hFile, &ErrorBreak, sizeof(ErrorBreak), &wrote, NULL);
   ReadFile(hFile, &VerboseFLogging, sizeof(VerboseFLogging), &wrote, NULL);
   ReadFile(hFile, &VerboseULogging, sizeof(VerboseULogging), &wrote, NULL);

#ifdef DEBUG
dprintf(TEXT("<Log Options Load>\n"));
dprintf(TEXT("   Error Break: %lx\n"), ErrorBreak);
dprintf(TEXT("   Verbose File Logging: %lx\n"), VerboseFLogging);
dprintf(TEXT("   Verbose User Logging: %lx\n\n"), VerboseULogging);
#endif
} // LogOptionsLoad


/*+-------------------------------------------------------------------------+
  | PopupOnError()
  |
  +-------------------------------------------------------------------------+*/
BOOL PopupOnError() {
   return ErrorBreak;
   
} // PopupOnError


/*+-------------------------------------------------------------------------+
  | VerboseFileLogging()
  |
  +-------------------------------------------------------------------------+*/
BOOL VerboseFileLogging() {
   return VerboseFLogging;

} // VerboseFileLogging


/*+-------------------------------------------------------------------------+
  | VerboseUserLogging()
  |
  +-------------------------------------------------------------------------+*/
BOOL VerboseUserLogging() {
   return VerboseULogging;

} // VerboseUserLogging


/*+-------------------------------------------------------------------------+
  | DoLoggingDlg()
  |
  +-------------------------------------------------------------------------+*/
void DoLoggingDlg(HWND hDlg) {
   DLGPROC lpfnDlg;

   lpfnDlg = MakeProcInstance((DLGPROC)DlgLogging, hInst);
   DialogBox(hInst, TEXT("DlgLogging"), hDlg, lpfnDlg) ;
   FreeProcInstance(lpfnDlg);

} // DoLoggingDlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\nwlog.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _NWLOG_
#define _NWLOG_

#ifdef __cplusplus
extern "C"{
#endif

void LogInit();
void LogWriteLog(int Level, LPTSTR szFormat, ...);
void LogWriteErr(LPTSTR szFormat, ...);
void LogWriteSummary(int Level, LPTSTR szFormat, ...);
void GetTime(TCHAR *str);
void ErrorResetAll();
void ErrorContextSet(LPTSTR szFormat, ...);
void ErrorCategorySet(LPTSTR szFormat, ...);
void ErrorItemSet(LPTSTR szFormat, ...);
void ErrorReset();
void ErrorSet(LPTSTR szFormat, ...);
BOOL ErrorOccured();
void ErrorBox(LPTSTR szFormat, ...);
int ErrorBoxRetry(LPTSTR szFormat, ...);

void LogOptionsInit();
void LogOptionsSave( HANDLE hFile );
void LogOptionsLoad( HANDLE hFile );
BOOL PopupOnError();
BOOL VerboseFileLogging();
BOOL VerboseUserLogging();
void DoLoggingDlg(HWND hDlg);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\nwrights.h ===
/*++

Copyright (c) 1993  Microsoft Corporation


Module Name:

    nwrights.h

Abstract:

    This module contains the prototypes for the
    routines called to manipulate security descriptors.

Author:

    Chuck Y. Chan (chuckc)

Revision History:

    ChuckC      24th Oct 1993    Created

--*/


//
// structure used to define how a single NW Right maps to 
// an NT Access mask.
//

typedef struct _NW_TO_NT_MAPPING {
    ULONG           NWRight ;
    ULONG           NTAccess ;
} NW_TO_NT_MAPPING, *PNW_TO_NT_MAPPING ;


//
// structure used to define how the Rights for a Netware object maps
// to the corresponding NT AccessMasks. 
//  
// first entry is the AceFlags to distinguish between ACE for the Object
// and ACE for inheritted objects
//
// the GENERIC_MAPPING structure should match that already defined for 
// the NT object in question.
//
// the array of NW mappings defines the NT Access Mask for each NW Right
// the object uses. the last entry should be {0, 0}.
//
// for example, file object mappings:
//
//     RIGHTS_MAPPING FileRightsMapping = 
//     {
//         0,
//         { FILE_GENERIC_READ, 
//           FILE_GENERIC_WRITE, 
//           FILE_GENERIC_EXECUTE,
//           FILE_ALL_ACCESS 
//         },
//         { { NW_FILE_READ,       GENERIC_READ }
//             { NW_FILE_WRITE,      GENERIC_WRITE }
//             { NW_FILE_CREATE,     0 }
//             { NW_FILE_DELETE,     GENERIC_WRITE }
//             { NW_FILE_PERM,       WRITE_DAC }
//             { NW_FILE_SCAN,       0 }
//             { NW_FILE_MODIFY,     GENERIC_WRITE }
//             { NW_FILE_SUPERVISOR, GENERIC_ALL }
//             { 0, 0 }
//         } 
//     } ;
//
//

typedef struct _RIGHTS_MAPPING {
    ULONG            NtAceFlags ;
    GENERIC_MAPPING  GenericMapping ;
    NW_TO_NT_MAPPING Nw2NtMapping[] ;
} RIGHTS_MAPPING, *PRIGHTS_MAPPING ;

//
// define the NW_FILE_* rights
//

#define NW_FILE_READ        0x0001
#define NW_FILE_WRITE       0x0002
#define NW_FILE_CREATE      0x0008
#define NW_FILE_DELETE      0x0010
#define NW_FILE_PERM        0x0020
#define NW_FILE_SCAN        0x0040
#define NW_FILE_MODIFY      0x0080
#define NW_FILE_SUPERVISOR  0x0100

#define NW_PRINT_USER       0x0001
#define NW_PRINT_ADMIN      0x0002
#define NW_PRINTJOB_ADMIN   0x0004

//
// #define these so they can be changed easily. these macros
// should be used to free the memory allocated by the routines in
// this module.
//

#define NW_ALLOC(x) ((LPBYTE)LocalAlloc(LPTR,x))
#define NW_FREE(p)  ((void)LocalFree((HLOCAL)p))

//
// predefined mappings (defined in nwrights.c)
//

extern RIGHTS_MAPPING FileRightsMapping ;
extern RIGHTS_MAPPING DirRightsMapping ;
extern RIGHTS_MAPPING PrintRightsMapping ;
extern RIGHTS_MAPPING JobRightsMapping ;

//
// function prototypes. details of parameters can be found in nwrights.c
//

NTSTATUS
NwAddRight(
    PSECURITY_DESCRIPTOR pSD,
    PSID pSid,
    ULONG Rights,
    PRIGHTS_MAPPING pMap,
    PSECURITY_DESCRIPTOR *ppNewSD
    ) ;

NTSTATUS
NwRemoveRight(
    PSECURITY_DESCRIPTOR pSD,
    PSID pSid,
    ULONG Rights,
    PRIGHTS_MAPPING pMap
    ) ;

NTSTATUS
NwCheckTrusteeRights(
    PSECURITY_DESCRIPTOR pSD,
    PSID pSid,
    ULONG Rights,
    PRIGHTS_MAPPING pMap
    ) ;

NTSTATUS
NwScanTrustees(
    PSECURITY_DESCRIPTOR pSD,
    PSID **pppSids,
    ULONG **ppRights,
    ULONG *pCount,
    BOOL  fAccessRightsOnly,
    PRIGHTS_MAPPING pMapObject,
    PRIGHTS_MAPPING pMapNewObject
    ) ;

NTSTATUS MapNwRightsToNTAccess(
    ULONG             NWRights,
    PRIGHTS_MAPPING   pMap,
    ACCESS_MASK      *pAccessMask
    ) ; 

NTSTATUS MapSpecificToGeneric(
    ACCESS_MASK * pAccessMask,
    PGENERIC_MAPPING  pGenMapping ) ;

NTSTATUS CreateNewSecurityDescriptor(
    PSECURITY_DESCRIPTOR *ppNewSD,
    PSECURITY_DESCRIPTOR pSD,
    PACL pAcl) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\resource.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _HRESOURCE_
#define _HRESOURCE_

#ifdef __cplusplus
extern "C"{
#endif

#include "helpid.h"

// +------------------------------------------------------------------------+
// | Main MoveIt Dialog
// +------------------------------------------------------------------------+

#define IDR_MAINFRAME                   1
#define IDD_ABOUTBOX                    999

#define ID_FILE_OPEN                    1000
#define ID_HELP_CONT                    1001
#define ID_HELP_INDEX                   1002
#define ID_HELP_USING                   1003
#define ID_APP_ABOUT                    1004
#define ID_FILE_SAVE                    1005
#define ID_LOGGING                      1006
#define ID_FILE_DEFAULT                 1007
#define IDC_EXIT                        1008

#define IDC_EDIT1                       1010
#define IDC_LIST1                       1011
#define IDC_TRIAL                       1012
#define IDC_USERINF                     1013
#define IDC_ADD                         1014
#define IDC_DELETE                      1015
#define IDC_FILEINF                     1016

#ifndef IDHELP
#define IDHELP                          1017
#endif // IDHELP

// Common Advanced>> button
#define IDC_ADVANCED                    1018
#define ID_INIT                         1019

// +------------------------------------------------------------------------+
// | Get Servers Dialog
// +------------------------------------------------------------------------+
#define IDC_EDITNWSERV                  1020
#define IDC_EDITNTSERV                  1021
#define IDC_NWBROWSE                    1022
#define IDC_NTBROWSE                    1023
#define ID_SETSEL                       1024

// +------------------------------------------------------------------------+
// | User Dialog
// +------------------------------------------------------------------------+
#define IDC_CHKUSERS                    1030
#define IDC_TABUSERS                    1031

#define IDC_PWCONST                     1032

#define IDC_CHKPWFORCE                  1033
#define IDC_USERCONST                   1034
#define IDC_GROUPCONST                  1035

#define IDC_CHKSUPER                    1036
#define IDC_CHKADMIN                    1037
#define IDC_CHKNETWARE                  1038
#define IDC_CHKMAPPING                  1039
#define IDC_MAPPINGFILE                 1040
#define IDC_BTNMAPPINGFILE              1041
#define IDC_BTNMAPPINGEDIT              1042
#define IDC_CHKFPNW                     1043

// These must be contiguous...
#define IDC_RADIO1                      1045
#define IDC_RADIO2                      1046
#define IDC_RADIO3                      1047
#define IDC_RADIO4                      1048
#define IDC_RADIO5                      1049
#define IDC_RADIO6                      1050
#define IDC_RADIO7                      1051
#define IDC_RADIO8                      1052
#define IDC_RADIO9                      1053
#define IDC_RADIO10                     1054

#define IDC_TRUSTED                     1055
#define IDC_CHKTRUSTED                  1056
#define IDC_BTNTRUSTED                  1057

#define IDC_STATDUP                     1058

#define IDC_DEFAULTBOX                  1059

// +------------------------------------------------------------------------+
// +------------------------------------------------------------------------+

#define IDC_DOMAIN                      1060
#define IDC_LOADNWSERV                  1061
#define IDC_LOADNTSERV                  1062
#define IDC_LOADDOMAIN                  1063
#define IDC_ALTOK                       1064

// +------------------------------------------------------------------------+
// +------------------------------------------------------------------------+
#define IDC_CHKUVERBOSE                 1070
#define IDC_CHKFVERBOSE                 1071
#define IDC_CHKERROR                    1072
#define IDC_VIEWLOG                     1073

// +------------------------------------------------------------------------+
// +------------------------------------------------------------------------+

#define IDC_S_CUR_CONV                  1100
#define IDC_S_TOT_CONV                  1101
#define IDC_S_SRCSERV                   1102
#define IDC_S_DESTSERV                  1103
#define IDC_S_CONVTXT                   1104
#define IDC_S_CUR_NUM                   1105
#define IDC_S_CUR_TOT                   1106
#define IDC_S_ITEMLABEL                 1107
#define IDC_S_STATUSITEM                1108
#define IDC_S_TOT_COMP                  1109
#define IDC_S_TOT_GROUPS                1110
#define IDC_S_TOT_USERS                 1111
#define IDC_S_TOT_FILES                 1112
#define IDC_S_TOT_ERRORS                1113

// +------------------------------------------------------------------------+
// +------------------------------------------------------------------------+
#define IDC_PANEL1                      1130 
#define IDC_PANEL2                      1131 
#define IDC_PANEL3                      1132 
#define IDC_PANEL4                      1133 
#define IDC_PANEL5                      1134 

#define IDC_PANEL6                      1135 
#define IDC_PANEL7                      1136 
#define IDC_PANEL8                      1137 
#define IDC_PANEL9                      1138 
#define IDC_PANEL10                     1139

#define IDR_LISTICONS                   1200

// +------------------------------------------------------------------------+
// +------------------------------------------------------------------------+

#define IDC_CHKFILES                   1301
#define IDC_MODIFY                     1302
#define IDC_FILES                      1303
#define IDC_FOPTIONS                   1304
#define IDC_TABFILES                   1305
#define IDC_LIST2                      1306

#define IDC_COMBO1                     1307
#define IDC_COMBO2                     1308
#define IDC_NEWSHARE                   1309
#define IDC_PROPERTIES                 1310

#define ID_UPDATELIST                  1311
#define IDC_VOLUME                     1312
#define IDC_FSERVER                    1313
#define IDC_TSERVER                    1314

#define IDR_FILEICONS                  1320
#define IDR_CHECKICONS                 1321
#define ID_CHECKCHECK                  1322

// Menus for the dialog
#define IDM_EXP_ONE                    1330
#define IDM_EXP_BRANCH                 1331
#define IDM_EXP_ALL                    1332
#define IDM_COLLAPSE                   1333

#define IDM_VIEW_BOTH                  1334
#define IDM_VIEW_TREE                  1335
#define IDM_VIEW_DIR                   1336

#define IDM_HIDDEN                     1337
#define IDM_SYSTEM                     1338

// +------------------------------------------------------------------------+
// +------------------------------------------------------------------------+
#define IDC_PASSWORD                   1340
#define IDC_SERVNAME                   1341
#define IDC_USERNAME                   1342

// +------------------------------------------------------------------------+
// +------------------------------------------------------------------------+
#define IDC_SHARENAME                  1350
#define IDC_EDIT2                      1352
#define IDC_EDIT3                      1353
#define ID_UPDATECOMBO                 1354

// +------------------------------------------------------------------------+
// +------------------------------------------------------------------------+
#define IDC_OLDNAME                    1360
#define IDC_NEWNAME                    1361

// +------------------------------------------------------------------------+
// +------------------------------------------------------------------------+
#define IDC_LIST3                       1370
#define IDC_T_DRIVES                    1371
#define IDC_T_SHARES                    1372
#define IDC_T_VOLUMES                   1373
#define IDC_VERSION                     1374
#define IDC_TYPE                        1375

#define ID_REDRAWLIST                   1380

// +------------------------------------------------------------------------+
// +------------------------------------------------------------------------+
#define IDC_USERS                       1390
#define IDC_GROUPS                      1391

// +------------------------------------------------------------------------+
// +------------------------------------------------------------------------+
#define IDC_DLGMAIN                     1999
#define IDC_STATIC                      -1

#define IDH_H                           3000

// +------------------------------------------------------------------------+
// | About Box
// +------------------------------------------------------------------------+
#define IDC_AVAIL_MEM                   101
#define IDC_PHYSICAL_MEM                101
#define IDC_LICENSEE_COMPANY            104
#define IDC_LICENSEE_NAME               105
#define IDD_SPLASH                      105
#define IDC_MATH_COPR                   106
#define IDC_DISK_SPACE                  107
#define IDC_BIGICON                     1001


#define IDM_ADDSEL                      2000
#define IDC_SIZEHORZ                    500

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\sbrowse.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _HSBROWSE_
#define _HSBROWSE_

#ifdef __cplusplus
extern "C"{
#endif

#define BROWSE_TYPE_NT 0
#define BROWSE_TYPE_NW 1
#define BROWSE_TYPE_DOMAIN 2

/*+-------------------------------------------------------------------------+
  | Server Browsing Stuff                                                   |
  +-------------------------------------------------------------------------+*/
typedef struct _SERVER_BROWSE_BUFFER {
   TCHAR Name[MAX_SERVER_NAME_LEN+1];
   TCHAR Description[MAX_PATH+1];
   BOOL Container;
   struct _SERVER_BROWSE_LIST *child;     // Points to a server list
} SERVER_BROWSE_BUFFER;


typedef struct _SERVER_BROWSE_LIST {
   DWORD Count;
   SERVER_BROWSE_BUFFER SList[];
} SERVER_BROWSE_LIST;


/*+-------------------------------------------------------------------------+
  | Function Prototypes                                                     |
  +-------------------------------------------------------------------------+*/
LRESULT CALLBACK DlgServSel(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
DWORD DialogServerBrowse(HINSTANCE hInst, HWND hDlg, SOURCE_SERVER_BUFFER **lpSourceServer, DEST_SERVER_BUFFER **lpDestServer);
int DlgServSel_Do(int BType, HWND hwndOwner);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\sbrowse.c ===
/*
  +-------------------------------------------------------------------------+
  |                  Server Browsing Dialog Routines                        |
  +-------------------------------------------------------------------------+
  |                     (c) Copyright 1993-1994                             |
  |                          Microsoft Corp.                                |
  |                        All rights reserved                              |
  |                                                                         |
  | Program               : [sbrowse.c]                                     |
  | Programmer            : Arthur Hanson                                   |
  | Original Program Date : [Dec 01, 1993]                                  |
  | Last Update           : [Jun 16, 1994]                                  |
  |                                                                         |
  | Version:  1.00                                                          |
  |                                                                         |
  | Description:                                                            |
  |                                                                         |
  | History:                                                                |
  |   arth  Jun 16, 1994    1.00    Original Version.                       |
  |                                                                         |
  +-------------------------------------------------------------------------+
*/

#include "globals.h"

#include <math.h>

#include "nwconv.h"
#include "hierdraw.h"
#include "convapi.h"
#include "ntnetapi.h"
#include "nwnetapi.h"

#define SERVER_TYPE_NT 0
#define SERVER_TYPE_NW 1

extern BOOL IsNetWareBrowse;
static int BrowseType;


TCHAR NetProvider[30];


// Internal defines
VOID DlgServSel_OnDrawItem(HWND hwnd, DRAWITEMSTRUCT FAR* lpDrawItem);
BOOL DlgServSel_OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam);
VOID DlgServSel_ActionItem(HWND hWndList, DWORD_PTR dwData, WORD wItemNum);
LRESULT CALLBACK DlgServSel(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
BOOL EnumServs(HWND hDlg);


#define ROWS 2
#define COLS 3

HEIRDRAWSTRUCT HierDrawStruct;

static HWND hEdit;
static HWND hParent;
static SERVER_BROWSE_LIST *ServList = NULL;
static TCHAR SourceServer[256];
static TCHAR DestServer[256];
static DEST_SERVER_BUFFER *DServ = NULL;
static SOURCE_SERVER_BUFFER *SServ = NULL;
BOOL DlgOk;


/*+-------------------------------------------------------------------------+
  | BrowseListCompare()
  |
  +-------------------------------------------------------------------------+*/
int __cdecl BrowseListCompare(const void *arg1, const void *arg2) {
   SERVER_BROWSE_BUFFER *SLarg1, *SLarg2;

   SLarg1 = (SERVER_BROWSE_BUFFER *) arg1;
   SLarg2 = (SERVER_BROWSE_BUFFER *) arg2;

   // This works as the first item of the structure is the string
   return lstrcmpi( SLarg1->Name, SLarg2->Name);

} // BrowseListCompare


/*+-------------------------------------------------------------------------+
  | BrowseListInit()
  |
  +-------------------------------------------------------------------------+*/
void BrowseListInit(HWND hDlg, int ServerType) {
   SERVER_BROWSE_BUFFER *SList;
   DWORD Status;
   DWORD Count;
   DWORD Index;
   DWORD i;
   HWND hCtrl;

   switch (BrowseType) {
      case BROWSE_TYPE_NT:
         Status = NTServerEnum(NULL, &ServList);
         break;

      case BROWSE_TYPE_NW:
         Status = NWServerEnum(NULL, &ServList);
         break;   
   }

   if (ServList) {
      Count = ServList->Count;
      SList = ServList->SList;

      // Sort the server list before putting it in the dialog
      qsort((void *) SList, (size_t) Count, sizeof(SERVER_BROWSE_BUFFER), BrowseListCompare);

      hCtrl = GetDlgItem(hDlg, IDC_LIST1);
      for (i = 0; i < Count; i++) {
         Index = i;
         SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) Index);
      }

   }

} // BrowseListInit


/*+-------------------------------------------------------------------------+
  | BrowseListFree()
  |
  +-------------------------------------------------------------------------+*/
void BrowseListFree(SERVER_BROWSE_LIST *ServList) {
   DWORD i;
   DWORD Count;
   SERVER_BROWSE_BUFFER *SList;

   if (!ServList)
      return;

   SList = ServList->SList;
   Count = ServList->Count;
   for (i = 0; i < Count; i++)
      if (SList[i].child)
         FreeMemory((LPBYTE) SList[i].child);

   FreeMemory((LPBYTE) ServList);
   ServList = NULL;

} // BrowseListFree


/*+-------------------------------------------------------------------------+
  | DlgServSel_Do()
  |
  +-------------------------------------------------------------------------+*/
int DlgServSel_Do(int BType, HWND hwndOwner) {
    int result;
    DLGPROC lpfndp;

   BrowseType = BType;

    // Init the Hier Draw stuff - Need to do this here so we have a value
    // for WM_MEASUREITEM which is sent before the WM_INITDIALOG message
    HierDraw_DrawInit(hInst, IDR_LISTICONS, ROWS, COLS, FALSE, &HierDrawStruct, TRUE );

    lpfndp = (DLGPROC)MakeProcInstance((FARPROC)DlgServSel, hInst);
    result = (int) DialogBox(hInst, TEXT("DlgServSel"), hwndOwner, lpfndp) ;

    FreeProcInstance((FARPROC)lpfndp);
    HierDraw_DrawTerm(&HierDrawStruct);

    return result;
} // DlgServSel_Do



/*+-------------------------------------------------------------------------+
  | BrowseListFind()
  |
  +-------------------------------------------------------------------------+*/
SERVER_BROWSE_BUFFER *BrowseListFind(DWORD_PTR dwData) {
   DWORD ContainerNum;
   DWORD Index = 0;
   SERVER_BROWSE_LIST *ServerSubList;

   Index = LOWORD(dwData);
   ContainerNum = HIWORD(dwData);

   if (!ContainerNum)
      return(&ServList->SList[Index]);
   else {
      ContainerNum--;      // Adjust for 0 index
      ServerSubList = (SERVER_BROWSE_LIST *) ServList->SList[ContainerNum].child;
      return(&ServerSubList->SList[Index]);
   }

} // BrowseListFind


/*+-------------------------------------------------------------------------+
  | DlgServSel_OnDrawItem()
  |
  +-------------------------------------------------------------------------+*/
VOID DlgServSel_OnDrawItem(HWND hwnd, DRAWITEMSTRUCT FAR* lpDrawItem) {
   TCHAR  szText[MAX_PATH + 1];
   DWORD_PTR dwData;
   int   nLevel = 0;
   int   nRow = 0;
   int   nColumn = 0;
   DWORD dwConnectLevel = 0;
   SERVER_BROWSE_BUFFER *SList;

   // if there is nothing to browse then don't need to draw anything.
   if (ServList == NULL)
      return;

   dwData = lpDrawItem->itemData;

   SList = BrowseListFind(dwData);

   // if there is a double back-slash then trim it off...
   if ((SList->Name[0] == TEXT('\\')) && (SList->Name[1] == TEXT('\\')))
      lstrcpy(szText, &(SList->Name[2]));
   else
      lstrcpy(szText, SList->Name);

   // Select the correct icon, open folder, closed folder, or document.
   switch(BrowseType) {
      case BROWSE_TYPE_NT:
         break;

      case BROWSE_TYPE_NW:
         nRow = 1;
         break;

   }

   // Can this item be opened ?
   if (SList->Container) {

      // Is it open ?
      if ( HierDraw_IsOpened(&HierDrawStruct, dwData) )
         nColumn = 1;
      else
         nColumn = 0;
   }
   else {
      if (!IsNetWareBrowse)
         nLevel = 1;

      nColumn = 2;
   }

   // All set to call drawing function.
   HierDraw_OnDrawItem(hwnd, lpDrawItem, nLevel, dwConnectLevel, szText, nRow, nColumn, &HierDrawStruct);

   return;

} // DlgServSel_OnDrawItem



/*+-------------------------------------------------------------------------+
  | DlgServSel_OnCommand()
  |
  +-------------------------------------------------------------------------+*/
BOOL DlgServSel_OnCommand(HWND hDlg, WPARAM wParam, LPARAM lParam) {
   int wmId, wmEvent;
   WORD wItemNum;
   DWORD_PTR dwData;
   HWND hCtrl;
   TCHAR ServerName[MAX_NW_OBJECT_NAME_LEN + 1];
   HWND hParent;
   SERVER_BROWSE_BUFFER *SList;

   wmId    = LOWORD(wParam);
   wmEvent = HIWORD(wParam);

   switch (wmId) {
      case IDOK:
         hCtrl = GetDlgItem(hDlg, IDC_LIST1);

         wItemNum = (WORD) SendMessage(hCtrl, LB_GETCURSEL, 0, 0L);

         if (wItemNum != (WORD) LB_ERR) {
            dwData = (DWORD) SendMessage(hCtrl, LB_GETITEMDATA, wItemNum, 0L);

            if (dwData != LB_ERR)
               DlgServSel_ActionItem(hCtrl, dwData, (WORD) wItemNum);
         }
         break;

      case IDC_ALTOK:
         hCtrl = GetDlgItem(hDlg, IDC_EDIT1);
         * (WORD *)ServerName = sizeof(ServerName);
         SendMessage(hCtrl, EM_GETLINE, 0, (LPARAM) ServerName);

         CanonServerName((LPTSTR) ServerName);

         hParent = GetWindow (hDlg, GW_OWNER);

         if (IsNetWareBrowse)
            hCtrl = GetDlgItem(hParent, IDC_EDITNWSERV);
         else
            hCtrl = GetDlgItem(hParent, IDC_EDITNTSERV);

         SendMessage(hCtrl, WM_SETTEXT, (WPARAM) 0, (LPARAM) ServerName);
         EndDialog(hDlg, 0);
         break;

      case ID_INIT:
         SetFocus(GetDlgItem(hDlg, IDC_EDIT1));
         break;

      case IDCANCEL:
         EndDialog(hDlg, 0);
         break;

      case IDHELP:
         switch (BrowseType) {
            case BROWSE_TYPE_NT:
               WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDC_HELP_BROWSENT);
               break;

            case BROWSE_TYPE_NW:
               WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDC_HELP_BROWSENW);
               break;

         }
         break;

      case IDC_CHKUSERS:
         break;

      case IDC_LOADNWSERV:
         BrowseListInit(hDlg, SERVER_TYPE_NW);
         break;

      case IDC_LOADNTSERV:
         BrowseListInit(hDlg, SERVER_TYPE_NT);
         break;

      case IDC_LOADDOMAIN:
         BrowseListInit(hDlg, SERVER_TYPE_NT);
         break;

      case ID_SETSEL:
            hCtrl = GetDlgItem(hDlg, IDC_LIST1);
            wItemNum = (WORD) SendMessage(hCtrl, LB_GETCURSEL, 0, 0L);

            if (wItemNum != (WORD) LB_ERR) {
               dwData = (DWORD) SendMessage(hCtrl, LB_GETITEMDATA, wItemNum, 0L);

               if (dwData != LB_ERR) {
                  SList = BrowseListFind(dwData);

                  // Is this an item or folder
                  if (!SList->Container) {
                       // is a server - so put it up in edit box
                       if (SList->Name[0] == TEXT('\\') && SList->Name[1] == TEXT('\\'))
                          SendMessage(hEdit, WM_SETTEXT, (WPARAM) 0, (LPARAM) &SList->Name[2]);
                       else
                          SendMessage(hEdit, WM_SETTEXT, (WPARAM) 0, (LPARAM) SList->Name);

                     hCtrl = GetDlgItem(hDlg, IDC_ALTOK);
                     EnableWindow(hCtrl, TRUE);
                  } else {
                     SendMessage(hEdit, WM_SETTEXT, (WPARAM) 0, (LPARAM) TEXT(""));
                     hCtrl = GetDlgItem(hDlg, IDC_ALTOK);
                     EnableWindow(hCtrl, FALSE);
                  }
               }
            }
         break;

      case IDC_LIST1:

         switch (wmEvent) {
            case LBN_DBLCLK:
               hCtrl = GetDlgItem(hDlg, IDC_LIST1);
               wItemNum = (WORD)  SendMessage(hCtrl, LB_GETCURSEL, 0, 0L);

               if (wItemNum != (WORD) LB_ERR) {
                  dwData   = (DWORD) SendMessage(hCtrl, LB_GETITEMDATA, wItemNum, 0L);

                  if (dwData != LB_ERR)
                     DlgServSel_ActionItem(hCtrl, dwData, wItemNum);
               }
               break;

            case LBN_SELCHANGE:
               PostMessage(hDlg, WM_COMMAND, (WPARAM) ID_SETSEL, 0L);
               break;

         }
         break;

      case IDC_EDIT1:

         if (wmEvent == EN_CHANGE) {
            hCtrl = GetDlgItem(hDlg, IDC_EDIT1);

            if (SendMessage(hCtrl, EM_LINELENGTH, 0, 0)) {
               hCtrl = GetDlgItem(hDlg, IDC_ALTOK);
               EnableWindow(hCtrl, TRUE);
            } else {
               hCtrl = GetDlgItem(hDlg, IDC_ALTOK);
               EnableWindow(hCtrl, FALSE);
            }

         }

         break;

      default:
         return FALSE;

   }

   return TRUE;
} // DlgServSel_OnCommand



/*+-------------------------------------------------------------------------+
  | DlgServSel_ActionItem()
  |
  +-------------------------------------------------------------------------+*/
VOID DlgServSel_ActionItem(HWND hWndList, DWORD_PTR dwData, WORD wItemNum) {
   DWORD_PTR dwIncr;
   DWORD Parent;
   DWORD Status;
   DWORD Count;
   SERVER_BROWSE_BUFFER *SList;
   SERVER_BROWSE_LIST *SubList;
   DWORD wItem, wCount, dwAddItem;

   if (dwData == LB_ERR)
      return;

   SList = BrowseListFind(dwData);

   // Is this an item or folder
   if (!SList->Container) {
      // is a server - so put it up in edit box
      if (SList->Name[0] == TEXT('\\') && SList->Name[1] == TEXT('\\'))
         SendMessage(hEdit, WM_SETTEXT, (WPARAM) 0, (LPARAM) &SList->Name[2]);
      else
         SendMessage(hEdit, WM_SETTEXT, (WPARAM) 0, (LPARAM) SList->Name);

      PostMessage(hParent, WM_COMMAND, (WPARAM) IDC_ALTOK, (LPARAM) 0);

   }
   else {
      SendMessage(hEdit, WM_SETTEXT, (WPARAM) 0, (LPARAM) TEXT(""));

      // Is it open ?
      if ( HierDraw_IsOpened(&HierDrawStruct, dwData) ) {

         // It's open ... Close it
         HierDraw_CloseItem(&HierDrawStruct, dwData);

         // Remove the child items. Close any children that are
         // open on the way.

         // wItem can stay constant as we are moveing stuff up in the listbox as we
         // are deleting.
         wItemNum++;
         dwIncr = SendMessage(hWndList, LB_GETITEMDATA, wItemNum, 0L);
         SList = BrowseListFind(dwIncr);

         while (!SList->Container) {
            SendMessage(hWndList, LB_DELETESTRING, wItemNum, 0L);
            dwIncr = SendMessage(hWndList, LB_GETITEMDATA, wItemNum, 0L);
            SList = BrowseListFind(dwIncr);
         }

         Parent = HIWORD(dwIncr);
         if (Parent) {
            Parent--;
            SList = BrowseListFind(Parent);
            FreeMemory((LPBYTE) SList->child);
            SList->child = NULL;
         }

      }
      else {

         // It's closed ... Open it
         HierDraw_OpenItem(&HierDrawStruct, dwData);

         SendMessage(hWndList, WM_SETREDRAW, FALSE, 0L);   // Disable redrawing.

         CursorHourGlass();

         // Enumerate the servers in this container (domain)
         Status = NTServerEnum(SList->Name, (SERVER_BROWSE_LIST **) &SList->child);

         if (!Status) {
            Parent = LOWORD(dwData);
            SubList = (SERVER_BROWSE_LIST *) SList->child;
            Count = SubList->Count;
            SList = SubList->SList;

            // Sort the server list before putting it in the dialog
            qsort((void *) SList, (size_t) Count, sizeof(SERVER_BROWSE_BUFFER), BrowseListCompare);

             for (wItem = wItemNum, wCount = 0, wItem++; 
                   wCount < SubList->Count; wItem++, wCount++) {
               dwAddItem = ((Parent + 1) << 16) + wCount;
               SendMessage(hWndList, LB_INSERTSTRING, wItem, dwAddItem);
            }

         }

         // Make sure as many child items as possible are showing
         HierDraw_ShowKids(&HierDrawStruct, hWndList, (WORD) wItemNum, (WORD) SubList->Count );

         CursorNormal();

         SendMessage(hWndList, WM_SETREDRAW, TRUE, 0L);   // Enable redrawing.
         InvalidateRect(hWndList, NULL, TRUE);            // Force redraw
      }
   }

} // DlgServSel_ActionItem


/*+-------------------------------------------------------------------------+
  | ServerListScan()
  |
  |    Given a key, scans the list of servers to find a matching first
  |    letter in the server name.
  |
  +-------------------------------------------------------------------------+*/
WORD ServerListScan(HWND hWnd, DWORD dwData, TCHAR Key) {
   BOOL Found = FALSE;
   WORD wItemNum;
   DWORD dwFindItem;
   DWORD dwData2;
   DWORD ContainerNum;
   WORD Index = 0;
   DWORD Count = 0;
   SERVER_BROWSE_LIST *ptrServList;
   SERVER_BROWSE_BUFFER *SList;

   Index = LOWORD(dwData);
   ContainerNum = HIWORD(dwData);

   // Get the head of the Server list for the current item
   if (!ContainerNum)
      ptrServList = ServList;
   else {
      ptrServList = (SERVER_BROWSE_LIST *) ServList->SList[ContainerNum-1].child;
   }

   // Now iterate down through the list trying to find the key...
   SList = ptrServList->SList;
   while ((!Found) && (Count < ptrServList->Count)) {
      if (SList[Count].Name[0] == Key) {
         dwFindItem = Count;
         Found = TRUE;
      } else
         Count++;
   }

   // If we found the key now have to find the appropriate index value
   if (Found && (Index != Count)) {
      // Fix up the new item data to find
      if (ContainerNum)
         dwFindItem += (ContainerNum << 16);

      wItemNum = (WORD)  SendMessage(hWnd, LB_GETCURSEL, 0, 0L);
      Found = FALSE;
      if (Index < Count) {
         // search forward in list
         dwData2 = 0;
         while ((dwData2 != LB_ERR) && !Found) {
            dwData2 = (DWORD) SendMessage(hWnd, LB_GETITEMDATA, wItemNum, 0L);

            if (dwData2 == dwFindItem)
               Found = TRUE;
            else 
               wItemNum++;

         }
      } else {
         // search backwards in list
         Count = Index;
         while ((wItemNum > 0) && !Found) {
            wItemNum--;
            dwData2 = (DWORD) SendMessage(hWnd, LB_GETITEMDATA, wItemNum, 0L);
            Count--;

            if (dwData2 == dwFindItem)
               Found = TRUE;
         }
      }
   } else
      return (Index);

   if (Found)
      return(wItemNum);
   else
      return (Index);

} // ServerListScan



static WNDPROC _wpOrigWndProc;
#define LISTBOX_COUNT 13

/*+-------------------------------------------------------------------------+
  | ListSubClassProc()
  |
  |    Handles key processing for the hierarchical listbox.  Specifically
  |    the up/down arrow keys and the letter keys.
  |
  +-------------------------------------------------------------------------+*/
LRESULT CALLBACK ListSubClassProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
   LRESULT lResult = 0;
   BOOL fCallOrigProc = TRUE;
   DWORD wItemNum;
   DWORD wNewNum;
   DWORD dwData;

   switch (message) {
   
      case WM_KEYDOWN:
         wItemNum = (DWORD)  SendMessage(hWnd, LB_GETCURSEL, 0, 0L);
         if (wItemNum != (DWORD) LB_ERR)
            dwData = (DWORD) SendMessage(hWnd, LB_GETITEMDATA, (WPARAM) wItemNum, 0L);
         else {
            wItemNum = 0;
            SendMessage(hWnd, LB_SETCURSEL, (WPARAM) 0, 0L);
            dwData = (DWORD) SendMessage(hWnd, LB_GETITEMDATA, (WPARAM) wItemNum, 0L);

            if ((dwData == LB_ERR) || (dwData == LB_ERR))
               break;
         }

         fCallOrigProc = FALSE;

         switch (LOWORD(wParam)) {
         
            case VK_PRIOR:
               if (wItemNum > LISTBOX_COUNT)
                  wNewNum = wItemNum - LISTBOX_COUNT;
               else
                  wNewNum = 0;

               PostMessage(hWnd, LB_SETCURSEL, (WPARAM) wNewNum, 0L);
               PostMessage(hParent, WM_COMMAND, (WPARAM) ID_SETSEL, 0L);
               break;

            case VK_NEXT:
               wItemNum = wItemNum + LISTBOX_COUNT;
               wNewNum = (WORD) SendMessage(hWnd, LB_GETCOUNT, (WPARAM) 0, 0L);

               if (wItemNum < wNewNum)
                  PostMessage(hWnd, LB_SETCURSEL, (WPARAM) wItemNum, 0L);
               else
                  PostMessage(hWnd, LB_SETCURSEL, (WPARAM) (wNewNum - 1), 0L);

               PostMessage(hParent, WM_COMMAND, (WPARAM) ID_SETSEL, 0L);
               break;

            case VK_END:
               wItemNum = (WORD) SendMessage(hWnd, LB_GETCOUNT, (WPARAM) 0, 0L);

               if (wItemNum != LB_ERR)
                  PostMessage(hWnd, LB_SETCURSEL, (WPARAM) (wItemNum - 1), 0L);

               PostMessage(hParent, WM_COMMAND, (WPARAM) ID_SETSEL, 0L);
               break;

            case VK_HOME:
               PostMessage(hWnd, LB_SETCURSEL, (WPARAM) 0, 0L);
               PostMessage(hParent, WM_COMMAND, (WPARAM) ID_SETSEL, 0L);
               break;

            case VK_UP:
               if (wItemNum > 0) {
                  wItemNum--;
                  PostMessage(hWnd, LB_SETCURSEL, (WPARAM) wItemNum, 0L);
               }
               PostMessage(hParent, WM_COMMAND, (WPARAM) ID_SETSEL, 0L);
               break;

            case VK_DOWN:
               wItemNum++;
               PostMessage(hWnd, LB_SETCURSEL, (WPARAM) wItemNum, 0L);
               PostMessage(hParent, WM_COMMAND, (WPARAM) ID_SETSEL, 0L);
               break;

            case VK_F1:
               fCallOrigProc = TRUE;
               break;

            default:
               wItemNum = ServerListScan(hWnd, dwData, (TCHAR) wParam);
               PostMessage(hWnd, LB_SETCURSEL, (WPARAM) wItemNum, 0L);
               PostMessage(hParent, WM_COMMAND, (WPARAM) ID_SETSEL, 0L);
               break;

         }

         break;

   }

   if (fCallOrigProc)
      lResult = CallWindowProc(_wpOrigWndProc, hWnd, message, wParam, lParam);

   return (lResult);

} // ListSubClassProc



/*+-------------------------------------------------------------------------+
  | DlgServSel()
  |
  +-------------------------------------------------------------------------+*/
LRESULT CALLBACK DlgServSel(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
   HWND hCtrl;

   switch (message) {

      case WM_INITDIALOG:
         // Center the dialog over the application window
         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));
         hParent = hDlg;

         // Disable the Add button until server is selected
         hCtrl = GetDlgItem(hDlg, IDC_ALTOK);
         EnableWindow(hCtrl, FALSE);

         // subclass listbox handler
         hCtrl = GetDlgItem(hDlg, IDC_LIST1);
         _wpOrigWndProc = SubclassWindow(hCtrl, ListSubClassProc);

         switch (BrowseType) {
            case BROWSE_TYPE_NT:
                  PostMessage(hDlg, WM_COMMAND, IDC_LOADNTSERV, 0);
                  lstrcpy( NetProvider, NT_PROVIDER);
                  hCtrl = GetDlgItem(hDlg, IDC_EDIT1);
                  PostMessage(hCtrl, EM_LIMITTEXT, (WPARAM) MAX_NT_SERVER_NAME_LEN, 0);
               break;

            case BROWSE_TYPE_NW:
                  lstrcpy( NetProvider, NW_PROVIDER);
                  SetWindowText(hDlg, Lids(IDS_S_35));
                  PostMessage(hDlg, WM_COMMAND, IDC_LOADNWSERV, 0);
                  hCtrl = GetDlgItem(hDlg, IDC_EDIT1);
                  PostMessage(hCtrl, EM_LIMITTEXT, (WPARAM) MAX_NW_OBJECT_NAME_LEN, 0);
               break;

         }

         hEdit = GetDlgItem(hDlg, IDC_EDIT1);
         PostMessage(hDlg, WM_COMMAND, ID_INIT, 0);
         return (TRUE);

      case WM_DESTROY:
         BrowseListFree(ServList);
         break;

      case WM_SETFONT:
         // Set the text height
         HierDraw_DrawSetTextHeight(GetDlgItem(hDlg, IDC_LIST1),   (HFONT)wParam, &HierDrawStruct);

         break;

      case WM_COMMAND:
         return DlgServSel_OnCommand(hDlg, wParam, lParam);

      case WM_DRAWITEM:
         DlgServSel_OnDrawItem(hDlg, (DRAWITEMSTRUCT FAR*)(lParam));
         return TRUE;
         break;

      case WM_MEASUREITEM:
         HierDraw_OnMeasureItem(hDlg, (MEASUREITEMSTRUCT FAR*)(lParam), &HierDrawStruct);
         return TRUE;
         break;

   }

   return (FALSE); 

   lParam; 

} // DlgServSel


/*+-------------------------------------------------------------------------+
  | DlgGetServ_OnInitDialog()
  |
  +-------------------------------------------------------------------------+*/
BOOL DlgGetServ_OnInitDialog(HWND hDlg, HWND hwndFocus, LPARAM lParam) {
   HWND hCtrl;

   // Center the dialog over the application window
   CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));

   // Disable the Add button until both servers are selected
   hCtrl = GetDlgItem(hDlg, IDOK);
   EnableWindow(hCtrl, FALSE);

   hCtrl = GetDlgItem(hDlg, IDC_EDITNWSERV);
   PostMessage(hCtrl, EM_LIMITTEXT, (WPARAM) MAX_NW_OBJECT_NAME_LEN, 0);
   hCtrl = GetDlgItem(hDlg, IDC_EDITNTSERV);
   PostMessage(hCtrl, EM_LIMITTEXT, (WPARAM) MAX_NT_SERVER_NAME_LEN, 0);
   PostMessage(hDlg, WM_COMMAND, ID_INIT, 0);
   return (TRUE);

} // DlgGetServ_OnInitDialog


/*+-------------------------------------------------------------------------+
  | MapShare()
  |
  +-------------------------------------------------------------------------+*/
// CODEWORK:  This routine can be condensed - all the virtual add share stuff 
// can be compacted to a subroutine
BOOL MapShare(SHARE_BUFFER *Share, DEST_SERVER_BUFFER *DServ) {
   static TCHAR Path[MAX_PATH + 1];
   SHARE_LIST *ShareList;
   SHARE_BUFFER *SList;
   SHARE_BUFFER *MatchShare;
   VIRTUAL_SHARE_BUFFER *VShare;
   DRIVE_BUFFER *DList;
   DRIVE_BUFFER *MaxNTFS = NULL;
   DRIVE_BUFFER *MaxFAT = NULL;
   BOOL Match = FALSE;
   BOOL NTFS = FALSE;
   BOOL Virtual = FALSE;
   DWORD i;

   // First see if there is a 1:1 share correspondence already in existance

   // the normal shares first...
   ShareList = DServ->ShareList;
   SList = ShareList->SList;

   if (ShareList != NULL)
      for (i = 0; ((i < ShareList->Count) && (!Match)); i++) {
         if (!lstrcmpi(SList[i].Name, Share->Name)) {
            MatchShare = &SList[i];
            Match = TRUE;
         }
      } // match normal share 1:1

   if (!Match) {
      VShare = DServ->VShareStart;

      while(VShare && !Match) {
         if (!lstrcmpi(VShare->Name, Share->Name)) {
            // will use VShare to point to matched share
            Virtual = TRUE;
            Match = TRUE;
         } else
            VShare = VShare->next;
      }
   } // match VShare 1:1

   if (!Match) {
      // No match so make share name the same - try to find NTFS drive with 
      // enough room to put it on.
      DList = DServ->DriveList->DList;
      if (DList != NULL)
         for (i = 0; ((i < DServ->DriveList->Count) && (!Match)); i++) {
            if (DList[i].Type == DRIVE_TYPE_NTFS) {
               // Find our Max NTFS
               if (!MaxNTFS)
                  MaxNTFS = &DList[i];
               else
                  if ( (MaxNTFS->FreeSpace - MaxNTFS->AllocSpace) < (DList[i].FreeSpace - DList[i].AllocSpace) )
                     MaxNTFS = &DList[i];

               // Is an NTFS Drive - check for space
               if ((DList[i].FreeSpace - DList[i].AllocSpace) > Share->Size) {
                  // Checks out - create a new virutal share for this
                  Match = TRUE;
                  Virtual = TRUE;
                  wsprintf(Path, TEXT("%s:\\%s"), DList[i].Drive, Share->Name);
                  VShare = VShareListAdd(DServ, Share->Name, Path);
                  VShare->Drive = &DList[i];
               }
            }
         }
   } // match new NTFS share

   if (!Match) {
      // No NTFS drive so try other drives...
      DList = DServ->DriveList->DList;
      if (DList != NULL)
         for (i = 0; ((i < DServ->DriveList->Count) && (!Match)); i++) {
            if (DList[i].Type != DRIVE_TYPE_NTFS) {
               // Find our Max FAT
               if (!MaxFAT)
                  MaxFAT = &DList[i];
               else
                  if ( (MaxFAT->FreeSpace - MaxFAT->AllocSpace) < (DList[i].FreeSpace - DList[i].AllocSpace) )
                     MaxFAT = &DList[i];

               // Is an other Drive - check for space
               if ((DList[i].FreeSpace - DList[i].AllocSpace) > Share->Size) {
                  // Checks out - create a new virutal share for this
                  Match = TRUE;
                  Virtual = TRUE;
                  wsprintf(Path, TEXT("%s:\\%s"), DList[i].Drive, Share->Name);
                  VShare = VShareListAdd(DServ, Share->Name, Path);
                  VShare->Drive = &DList[i];
               }
            }
         }
   } // match new FAT share

   if (!Match) {
      // we are going to assign some virtual share for this
      Virtual = TRUE;

      // use max space for NTFS else FAT
      if (MaxNTFS) {
         // if also have some fat partitions if they have more space use them
         if (!(MaxFAT && ( (MaxNTFS->FreeSpace - MaxNTFS->AllocSpace) < (MaxFAT->FreeSpace - MaxFAT->AllocSpace) ))) {
            Match = TRUE;
            wsprintf(Path, TEXT("%s:\\%s"), MaxNTFS->Drive, Share->Name);
            VShare = VShareListAdd(DServ, Share->Name, Path);
            VShare->Drive = MaxNTFS;
         }
      }

      // if we couldn't match with NTFS then use other drive types
      if (!Match) {
         Match = TRUE;
         wsprintf(Path, TEXT("%s:\\%s"), MaxFAT->Drive, Share->Name);
         VShare = VShareListAdd(DServ, Share->Name, Path);
         VShare->Drive = MaxFAT;
      }

   } // match anything!!!

   if (Match) {
      // Have the match so adjust the params
      if (!Virtual) {
         Share->Virtual = FALSE;
         Share->DestShare = MatchShare;

         // if there is no drive specified (can be the case if the share points
         // to an invalid drive - like a floppy) then we skip out and ignore it
         // for right now.  We will alert the user when they try to do the 
         // transfer.
         if (MatchShare->Drive == NULL)
            return TRUE;

         MatchShare->Drive->AllocSpace += Share->Size;
#ifdef DEBUG
dprintf(TEXT("Matched Share: %s -> %s\n"), Share->Name, MatchShare->Name);
#endif
      } else {
         Share->Virtual = TRUE;
         Share->DestShare = (SHARE_BUFFER *) VShare;
         VShare->Drive->AllocSpace += Share->Size;
         VShare->UseCount++;
#ifdef DEBUG
dprintf(TEXT("Matched Virtual Share: %s -> %s\n"), Share->Name, VShare->Path);
#endif
      }

      return TRUE;
   } else {
#ifdef DEBUG
dprintf(TEXT("Couldn't Map Share: %s\n"), Share->Name);
#endif
      // Bad news - the destination server just can't handle this!
      return FALSE;
   }

} // MapShare


/*+-------------------------------------------------------------------------+
  | ShareListInit()
  |
  +-------------------------------------------------------------------------+*/
void ShareListInit(SHARE_LIST *ShareList, DEST_SERVER_BUFFER *DServ) {
   SHARE_BUFFER *SList;
   DWORD i;

   // Mark that we want to convert all the shares
   if (ShareList != NULL) {
      SList = ShareList->SList;
      ShareList->ConvertCount = ShareList->Count;

      for (i = 0; i < ShareList->Count; i++) {
         if (MapShare(&SList[i], DServ))
            SList[i].Convert = TRUE;
      }
   }

} // ShareListInit


/*+-------------------------------------------------------------------------+
  | DlgGetServ_OnCommand()
  |
  +-------------------------------------------------------------------------+*/
BOOL DlgGetServ_OnCommand(HWND hDlg, int wmId, HWND hwndCtl, UINT wmEvent) {
   HWND hCtrl;
   BOOL Enable = FALSE;

   switch (wmId) {
      case IDOK:
         hCtrl = GetDlgItem(hDlg, IDC_EDITNWSERV);
         * (WORD *)SourceServer = sizeof(SourceServer);
         * (WORD *)DestServer = sizeof(DestServer);
         SendMessage(hCtrl, EM_GETLINE, 0, (LPARAM) SourceServer);
         hCtrl = GetDlgItem(hDlg, IDC_EDITNTSERV);
         SendMessage(hCtrl, EM_GETLINE, 0, (LPARAM) DestServer);

         CanonServerName(SourceServer);
         CanonServerName(DestServer);

         if ( NWServerValidate(hDlg, SourceServer, TRUE) ) {
            if ( NTServerValidate(hDlg, DestServer) ) {
               // Check if we need to add server to server list
               DServ = DServListFind(DestServer);

               if (DServ == NULL) {
                  DServ = DServListAdd(DestServer);
                  NTServerInfoSet(hDlg, DestServer, DServ);
               } else
                  DServ->UseCount++;

               SServ = SServListFind(SourceServer);

               if (SServ == NULL) {
                  SServ = SServListAdd(SourceServer);
                  NWServerInfoSet(SourceServer, SServ);
                  ShareListInit(SServ->ShareList, DServ);
               }

               DlgOk = TRUE;
               EndDialog(hDlg, 0);
            } else {
               // Clean up connections that the Validation routines made
               NWUseDel(SourceServer);
               NTUseDel(DestServer);
               hCtrl = GetDlgItem(hDlg, IDC_EDITNTSERV);
               SetFocus(hCtrl);
            }
         } else {
               // Clean up use validation routine made
               NWUseDel(SourceServer);
               hCtrl = GetDlgItem(hDlg, IDC_EDITNWSERV);
               SetFocus(hCtrl);
         }

         return (TRUE);

      case ID_INIT:
         SetFocus(GetDlgItem(hDlg, IDC_EDITNWSERV));
         break;

      case IDCANCEL:
         EndDialog(hDlg, 0);
         DlgOk = FALSE;
         return (TRUE);
         break;

      case IDHELP:
         WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDC_HELP_ADD);
         return (TRUE);
         break;

      case IDC_NWBROWSE:
         IsNetWareBrowse = TRUE;
         DlgServSel_Do(BROWSE_TYPE_NW, hDlg);
         return (TRUE);
         break;

      case IDC_NTBROWSE:
         IsNetWareBrowse = FALSE;
         DlgServSel_Do(BROWSE_TYPE_NT, hDlg);
         return (TRUE);
         break;

      case IDC_EDITNWSERV:
      case IDC_EDITNTSERV:
         if (wmEvent == EN_CHANGE) {
            hCtrl = GetDlgItem(hDlg, IDC_EDITNWSERV);
   
            if (SendMessage(hCtrl, EM_LINELENGTH, 0, 0)) {
               hCtrl = GetDlgItem(hDlg, IDC_EDITNTSERV);
               if (SendMessage(hCtrl, EM_LINELENGTH, 0, 0))
                  Enable = TRUE;
            }

            hCtrl = GetDlgItem(hDlg, IDOK);
            if (Enable)
               EnableWindow(hCtrl, TRUE);
            else   
            EnableWindow(hCtrl, FALSE);

         }
         break;
   }

   return FALSE;

}  // DlgGetServ_OnCommand



/*+-------------------------------------------------------------------------+
  | DlgGetServ()
  |
  +-------------------------------------------------------------------------+*/
LRESULT CALLBACK DlgGetServ(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) {

   switch (msg) {
      HANDLE_MSG(hDlg, WM_INITDIALOG, DlgGetServ_OnInitDialog);
      HANDLE_MSG(hDlg, WM_COMMAND, DlgGetServ_OnCommand);

   }

   return (FALSE); // Didn't process the message

   lParam;
} // DlgGetServ


/*+-------------------------------------------------------------------------+
  | DialogGetServ()
  |
  +-------------------------------------------------------------------------+*/
DWORD DialogServerBrowse(HINSTANCE hInst, HWND hDlg, SOURCE_SERVER_BUFFER **lpSourceServer, DEST_SERVER_BUFFER **lpDestServer) {
   DLGPROC lpfnDlg;

   SServListCurrent = NULL;
   DServListCurrent = NULL;
   SServ = NULL;
   DServ = NULL;

   lpfnDlg = MakeProcInstance((DLGPROC)DlgGetServ, hInst);
   DialogBox(hInst, TEXT("DlgGetServ"), hDlg, lpfnDlg) ;
   FreeProcInstance(lpfnDlg);

   if (DlgOk) {
      *lpSourceServer = SServ;
      *lpDestServer = DServ;
      return 0;
   } else
      return 1;

} // DialogServerBrowse
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\servlist.c ===
/*
  +-------------------------------------------------------------------------+
  |               Server Linked List Manipulation Routines                  |
  +-------------------------------------------------------------------------+
  |                     (c) Copyright 1993-1994                             |
  |                          Microsoft Corp.                                |
  |                        All rights reserved                              |
  |                                                                         |
  | Program               : [ServList.c]                                    |
  | Programmer            : Arthur Hanson                                   |
  | Original Program Date : [Feb 15, 1994]                                  |
  | Last Update           : [Jun 16, 1994]                                  |
  |                                                                         |
  | Version:  1.00                                                          |
  |                                                                         |
  | Description:                                                            |
  |   Bunch of similar utility functions for adding to, deleting from,      |
  |   saving and restoring data lists.                                      |
  |                                                                         |
  |                                                                         |
  | History:                                                                |
  |   arth  Jun 16, 1994    1.00    Original Version.                       |
  |                                                                         |
  +-------------------------------------------------------------------------+
*/

#include "globals.h"
#include "convapi.h"
#include "columnlb.h"
#include "ntnetapi.h"
#include "nwnetapi.h"
#include "userdlg.h"
#include "filedlg.h"

// define from SBrowse.c -> for SourceShareListFixup
BOOL MapShare(SHARE_BUFFER *Share, DEST_SERVER_BUFFER *DServ);

static ULONG NumDServs = 0;
static ULONG NumSServs = 0;
static ULONG NumDomains = 0;

// Note:  Most of these routines are a bunch of doubly-linked list functions
//        as such it should be possible to condense them to use some common
//        functions for add/delete/insert.  However virtual-shares will have
//        to be different as the Virtual BOOL has to be the first field.


/*+-------------------------------------------------------------------------+
  |                    Routines for Directory/File Trees                    |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | TreeSave()
  |
  +-------------------------------------------------------------------------+*/
void _TreeSaveR(HANDLE hFile, DIR_BUFFER *Dir) {
   DIR_BUFFER *DList;
   ULONG Size;
   ULONG i;
   DWORD wrote;

   if (Dir == NULL)
      return;

   // First save out the file list for this node
   if (Dir->FileList) {
      WriteFile(hFile, &Dir->FileList->Count, sizeof(Dir->FileList->Count), &wrote, NULL);
      Size = sizeof(FILE_LIST) + (Dir->FileList->Count * sizeof(FILE_BUFFER));
      WriteFile(hFile, Dir->FileList, Size, &wrote, NULL);
   }

   if (Dir->DirList) {
      DList = Dir->DirList->DirBuffer;

      // first write out this dirlist then recurse down tree.
      WriteFile(hFile, &Dir->DirList->Count, sizeof(Dir->DirList->Count), &wrote, NULL);
      Size = sizeof(DIR_LIST) + (Dir->DirList->Count * sizeof(DIR_BUFFER));
      WriteFile(hFile, Dir->DirList, Size, &wrote, NULL);

      for (i = 0; i < Dir->DirList->Count; i++)
         _TreeSaveR(hFile, &DList[i]);

   }

} // _TreeSaveR


void TreeSave(HANDLE hFile, DIR_BUFFER *Dir) {
   DWORD wrote;

   if (Dir == NULL)
      return;

   // Make sure we save the minimum amount
   TreePrune(Dir);

   // write out the actual dir
   WriteFile(hFile, Dir, sizeof(DIR_BUFFER), &wrote, NULL);

   // now save it's child info recursively
   _TreeSaveR(hFile, Dir);

} // TreeSave


/*+-------------------------------------------------------------------------+
  | TreeLoad()
  |
  +-------------------------------------------------------------------------+*/
void _TreeLoadR(HANDLE hFile, DIR_BUFFER *Dir) {
   DIR_LIST *DList;
   DIR_BUFFER *DBuff;
   FILE_LIST *FList;
   FILE_BUFFER *FBuff;
   ULONG Size;
   ULONG i;
   DWORD wrote;
   ULONG Count;

   if (Dir == NULL)
      return;

   // First save out the file list for this node
   if (Dir->FileList) {
      ReadFile(hFile, &Count, sizeof(Count), &wrote, NULL);
      Size = sizeof(FILE_LIST) + (sizeof(FILE_BUFFER) * Count);
      FList = AllocMemory(Size);
      ReadFile(hFile, FList, Size, &wrote, NULL);

      // Read it in, now fixup the internal pointers.
      FList->parent = Dir;

      FBuff = FList->FileBuffer;
      for (i = 0; i < FList->Count; i++)
         FBuff[i].parent = FList;

      Dir->FileList = FList;
   }

   if (Dir->DirList) {
      ReadFile(hFile, &Count, sizeof(Count), &wrote, NULL);
      Size = sizeof(DIR_LIST) + (sizeof(DIR_BUFFER) * Count);
      DList = AllocMemory(Size);
      ReadFile(hFile, DList, Size, &wrote, NULL);

      // Read it in, now fixup the internal pointers.
      DList->parent = Dir;

      DBuff = DList->DirBuffer;
      for (i = 0; i < DList->Count; i++)
         DBuff[i].parent = DList;

      Dir->DirList = DList;

      // Now recurse into children and fix them up
      for (i = 0; i < DList->Count; i++)
         _TreeLoadR(hFile, &DBuff[i]);

   }

} // _TreeLoadR


void TreeLoad(HANDLE hFile, DIR_BUFFER **pDir) {
   DIR_BUFFER *Dir;
   DWORD wrote;

   if (pDir == NULL)
      return;

   // Allocate space for the new root
   Dir = AllocMemory(sizeof(DIR_BUFFER));
   if (Dir == NULL)
      return;

   memset(Dir, 0, sizeof(DIR_BUFFER));

   // set passed in var to new memory and read in values from file
   *pDir = Dir;
   ReadFile(hFile, Dir, sizeof(DIR_BUFFER), &wrote, NULL);

   // now recursively load child information
   _TreeLoadR(hFile, Dir);

} // TreeLoad


/*+-------------------------------------------------------------------------+
  |                        Routines for User Lists                          |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | UserListCompare()
  |
  +-------------------------------------------------------------------------+*/
int __cdecl UserListCompare(const void *arg1, const void *arg2) {
   USER_BUFFER *ULarg1, *ULarg2;

   ULarg1 = (USER_BUFFER *) arg1;
   ULarg2 = (USER_BUFFER *) arg2;

   // This works as the first item of the structure is the string
   return lstrcmpi( ULarg1->Name, ULarg2->Name);

} // UserListCompare


/*+-------------------------------------------------------------------------+
  |                        Routines for Share Lists                         |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | ShareListDelete()
  |
  +-------------------------------------------------------------------------+*/
void ShareListDelete(SHARE_LIST *ShareList) {
   SHARE_BUFFER *SList;
   VIRTUAL_SHARE_BUFFER *VShare;
   ULONG i;

   if (ShareList == NULL)
      return;

   SList = ShareList->SList;
   for (i = 0; i < ShareList->Count; i++) {
      if (SList[i].Root != NULL) {
         TreeDelete(SList[i].Root);
         FreeMemory(SList[i].Root);
      }

      // Note:  SList[i].Drive points to a dest server drive, so we don't
      //        free it here.
      if (!ShareList->Fixup)
         if (SList[i].Virtual) {
            VShare = (VIRTUAL_SHARE_BUFFER *) SList[i].DestShare;

            if ((VShare != NULL) && VShare->UseCount)
               VShare->UseCount--;
         }

   }

} // ShareListDelete


/*+-------------------------------------------------------------------------+
  | SourceShareListFixup()
  |
  +-------------------------------------------------------------------------+*/
void SourceShareListFixup(DEST_SERVER_BUFFER *DServ, SHARE_LIST *ShareList) {
   TCHAR tmpName[MAX_SHARE_NAME_LEN + 1];
   SHARE_BUFFER *SList;
   ULONG i;
   DWORD_PTR *VMap = NULL;

   if (ShareList == NULL)
      return;

   ShareList->Fixup = FALSE;
   // Generate Virtual Share Map
   VShareListIndexMapGet(DServ, &VMap);

   SList = ShareList->SList;
   for (i = 0; i < ShareList->Count; i++) {
      if (SList[i].DestShare != NULL)
         if (SList[i].Virtual)
            SList[i].DestShare = (SHARE_BUFFER *) VMap[(DWORD_PTR) SList[i].DestShare - 1];
         else {
            // Not a virtual share - now need to take name from path and rematch it
            // to the new destination share list (dest sharename was stored in 
            // path in the ShareListSave routine).
            lstrcpy(tmpName, SList[i].Name);
            lstrcpy(SList[i].Name, SList[i].Path);

            // clear out path and the old DestShare
            memset(SList[i].Path, 0, sizeof(SList[i].Path));
            SList[i].DestShare = NULL;

            // Now map it to a dest share
            MapShare(&SList[i], DServ);

            // Restore real name
            lstrcpy(SList[i].Name, tmpName);
         }
   }

   if (VMap != NULL)
      FreeMemory(VMap);

} // SourceShareListFixup


/*+-------------------------------------------------------------------------+
  | DestShareListFixup()
  |
  +-------------------------------------------------------------------------+*/
void DestShareListFixup(DEST_SERVER_BUFFER *DServ) {
   SHARE_BUFFER *SList, *oSList;
   SHARE_LIST *oShareList;
   ULONG i, oi;
   DRIVE_LIST *DList;
   DRIVE_BUFFER *DBuff;
   BOOL match;

   if (DServ->ShareList == NULL)
      return;

   if (DServ->ShareList->Fixup == FALSE)
      return; // do not fixup twice...

   DServ->ShareList->Fixup = FALSE;
   DList = DServ->DriveList;
   DBuff = DList->DList;

   oShareList = DServ->ShareList;
   NTSharesEnum(&DServ->ShareList, DServ->DriveList);
   if (DServ->ShareList == NULL)
      return;

   SList = DServ->ShareList->SList;
   oSList = oShareList->SList;
   for (i = 0; i < DServ->ShareList->Count; i++) {
      match = FALSE;
      oi = 0;

      while ((!match) && (oi < oShareList->Count)) {
         if (!lstrcmpi(SList[i].Name, oSList[oi].Name)) {
            SList[i].Convert = oSList[oi].Convert;
            SList[i].HiddenFiles = oSList[oi].HiddenFiles;
            SList[i].SystemFiles = oSList[oi].SystemFiles;
            match = TRUE;
         }
         
         oi++;
      }

   }

   FreeMemory(oShareList);

} // DestShareListFixup


/*+-------------------------------------------------------------------------+
  | ShareListSave()
  |
  +-------------------------------------------------------------------------+*/
void ShareListSave(HANDLE hFile, SHARE_LIST *ShareList) {
   SHARE_BUFFER *SList;
   VIRTUAL_SHARE_BUFFER *VShare;
   DWORD wrote;
   ULONG Size, i;
   DWORD_PTR *sb = NULL;

   if (ShareList == NULL)
      return;

   Size = sizeof(SHARE_LIST) + (ShareList->Count * sizeof(SHARE_BUFFER));
   WriteFile(hFile, &Size, sizeof(Size), &wrote, NULL);

   // Need to make a temp array to hold DestShare info
   sb = AllocMemory(ShareList->Count * sizeof(DWORD_PTR));

   SList = ShareList->SList;

   // Copy DestShares to temp holding place and replace them with 
   // their index
   for (i = 0; i < ShareList->Count; i++) {
      sb[i] = (DWORD_PTR) SList[i].DestShare;

      if (SList[i].DestShare != NULL)
         if (SList[i].Virtual) {
            VShare = (VIRTUAL_SHARE_BUFFER *) SList[i].DestShare;
            SList[i].DestShare = (SHARE_BUFFER *) (VShare->Index + 1);
         } else  {
            // put the dest sharename into the path (temporarily) so that on load
            // we have the name to match to the new share list.  Can't match just
            // the sharename to dest-sharename as the admin may have pointed it to
            // a new one.
            lstrcpy(SList[i].Path, SList[i].DestShare->Name);
            SList[i].DestShare = (SHARE_BUFFER *) (SList[i].DestShare->Index + 1);
         }
   }

   ShareList->Fixup = TRUE;
   WriteFile(hFile, ShareList, Size, &wrote, NULL);
   ShareList->Fixup = FALSE;

   // Restore DestShare pointers
   for (i = 0; i < ShareList->Count; i++)
      SList[i].DestShare = (SHARE_BUFFER *) sb[i];


   if (sb != NULL)
      FreeMemory(sb);

   // Share list array is saved out - now save out linked information
   for (i = 0; i < ShareList->Count; i++)
      if (SList[i].Root != NULL)
         TreeSave(hFile, SList[i].Root);

} // ShareListSave


/*+-------------------------------------------------------------------------+
  | ShareListLoad()
  |
  +-------------------------------------------------------------------------+*/
void ShareListLoad(HANDLE hFile, SHARE_LIST **lpShareList) {
   SHARE_BUFFER *SList;
   SHARE_LIST *ShareList;
   ULONG Size, i;
   DWORD wrote;

   // Get how long this record is
   ReadFile(hFile, &Size, sizeof(Size), &wrote, NULL);

   ShareList = AllocMemory(Size);
   if (ShareList == NULL)
      return;

   ReadFile(hFile, ShareList, Size, &wrote, NULL);

   // Share list array is read in - now load linked information
   SList = ShareList->SList;
   for (i = 0; i < ShareList->Count; i++)
      if (SList[i].Root != NULL) {
         SList[i].Root = NULL;
         TreeLoad(hFile, &SList[i].Root);
      }

   *lpShareList = ShareList;

#ifdef DEBUG
dprintf(TEXT("<Share List Load>\n"));
dprintf(TEXT("   Number of Entries: %lu\n\n"), ShareList->Count);

for (i = 0; i < ShareList->Count; i++) {
   dprintf(TEXT("   Name: %s\n"), SList[i].Name);
   dprintf(TEXT("   Path: %s\n"), SList[i].Path);
}
dprintf(TEXT("\n"));
#endif

} // ShareListLoad


/*+-------------------------------------------------------------------------+
  | ShareListLog()
  |
  +-------------------------------------------------------------------------+*/
void ShareListLog(SHARE_LIST *ShareList, BOOL DestServer) {
   ULONG i;

   if ((ShareList == NULL) || (ShareList->Count == 0))
      return;

   LogWriteLog(0, Lids(IDS_CRLF));
   LogWriteLog(1, Lids(IDS_L_125));

   for (i = 0; i < ShareList->Count; i++) {
      LogWriteLog(2, TEXT("%s\r\n"), ShareList->SList[i].Name);

      if (DestServer)
         LogWriteLog(3, Lids(IDS_L_8), ShareList->SList[i].Path);
   }

   LogWriteLog(0, Lids(IDS_CRLF));

} // ShareListLog


/*+-------------------------------------------------------------------------+
  |                  Routines for Source Server List                        |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | SServListAdd()
  |
  +-------------------------------------------------------------------------+*/
SOURCE_SERVER_BUFFER *SServListAdd(LPTSTR ServerName) {
   SOURCE_SERVER_BUFFER *tmpPtr;
   ULONG Size;

   Size = sizeof(SOURCE_SERVER_BUFFER) + ((lstrlen(ServerName) + 3) * sizeof(TCHAR));
   tmpPtr = AllocMemory(Size);
   
   if (tmpPtr != NULL) {
      // init it to NULL's
      memset(tmpPtr, 0, Size);
      tmpPtr->Name = (LPTSTR) ((BYTE *) tmpPtr + sizeof(SOURCE_SERVER_BUFFER));
      tmpPtr->LName = tmpPtr->Name;
      lstrcpy(tmpPtr->Name, TEXT("\\\\"));
      tmpPtr->Name += 2;
      lstrcpy(tmpPtr->Name, ServerName);

      // link it into the list
      if (!SServListStart)
         SServListStart = SServListEnd = tmpPtr;
      else {
         SServListEnd->next = tmpPtr;
         tmpPtr->prev = SServListEnd;
         SServListEnd = tmpPtr;
      }

      NumSServs++;
   }

   return (tmpPtr);

} // SServListAdd


/*+-------------------------------------------------------------------------+
  | SServListDelete()
  |
  +-------------------------------------------------------------------------+*/
void SServListDelete(SOURCE_SERVER_BUFFER *tmpPtr) {
   SOURCE_SERVER_BUFFER *PrevPtr;
   SOURCE_SERVER_BUFFER *NextPtr;

   if (tmpPtr == NULL)
      return;

   // Delete any attached share list first
   ShareListDelete(tmpPtr->ShareList);

   // Free any admin share we made
   NWUseDel(tmpPtr->Name);

   // Now unlink the actual server record
   PrevPtr = tmpPtr->prev;
   NextPtr = tmpPtr->next;

   if (PrevPtr)
      PrevPtr->next = NextPtr;

   if (NextPtr)
      NextPtr->prev = PrevPtr;

   // Check if at end of list
   if (SServListEnd == tmpPtr)
      SServListEnd = PrevPtr;

   // Check if at start of list
   if (SServListStart == tmpPtr)
      SServListStart = NextPtr;

   FreeMemory(tmpPtr);
   NumSServs--;

   if (!NumSServs)
      SServListStart = SServListEnd = NULL;

}  // SServListDelete


/*+-------------------------------------------------------------------------+
  | SServListDeleteAll()
  |
  +-------------------------------------------------------------------------+*/
void SServListDeleteAll() {
   SOURCE_SERVER_BUFFER *ServList;
   SOURCE_SERVER_BUFFER *ServListNext;

   // Now remove the entries from the internal list
   ServList = SServListStart;

   while (ServList) {
      ServListNext = ServList->next;
      SServListDelete(ServList);
      ServList = ServListNext;
   }

} // SServListDeleteAll


/*+-------------------------------------------------------------------------+
  | SServListFind()
  |
  +-------------------------------------------------------------------------+*/
SOURCE_SERVER_BUFFER *SServListFind(LPTSTR ServerName) {
   BOOL Found = FALSE;
   SOURCE_SERVER_BUFFER *ServList;

   ServList = SServListStart;

   while ((ServList && !Found)) {
      if (!lstrcmpi(ServList->Name, ServerName))
         Found = TRUE;
      else
         ServList = ServList->next;
   }

   if (!Found)
      ServList = NULL;

   return (ServList);

} // SServListFind


/*+-------------------------------------------------------------------------+
  | SServListIndex()
  |
  |   The index routines place an index number into each item of the list,
  |   and is called just before saving out the list.  This is so when we
  |   read them in we can reference pointer links.  In their normal state
  |   these data structures are cross referenced via pointers, but once
  |   saved/restored the pointers have no meaning, so we use the index to
  |   re-reference the pointers to the correct data items when they are
  |   read back in.
  |
  +-------------------------------------------------------------------------+*/
void SServListIndex() {
   SOURCE_SERVER_BUFFER *ServList;
   USHORT Count = 0;

   ServList = SServListStart;
   while (ServList) {
      ServList->Index = Count++;
      ServList = ServList->next;
   }

} // SServListIndex


/*+-------------------------------------------------------------------------+
  | SServListIndexMapGet()
  |
  +-------------------------------------------------------------------------+*/
void SServListIndexMapGet(DWORD_PTR **pMap) {
   DWORD_PTR *Map = NULL;
   SOURCE_SERVER_BUFFER *ServList;

   Map = AllocMemory(NumSServs * sizeof(DWORD_PTR));

   *pMap = Map;
   if (Map == NULL)
      return;

   ServList = SServListStart;
   while (ServList) {
      Map[ServList->Index] = (DWORD_PTR) ServList;
      ServList = ServList->next;
   }

} // SServListIndexMapGet


/*+-------------------------------------------------------------------------+
  | SServListFixup()
  |
  +-------------------------------------------------------------------------+*/
void SServListFixup() {

   // There is nothing to fixup in the source server list right now - the
   // share list is done later...

} // SServListFixup


/*+-------------------------------------------------------------------------+
  | SServListSave()
  |
  +-------------------------------------------------------------------------+*/
void SServListSave(HANDLE hFile) {
   DWORD wrote;
   ULONG Size;
   SOURCE_SERVER_BUFFER *ServList;

   ServList = SServListStart;

   while (ServList) {
      Size = (lstrlen(ServList->Name) + 3) * sizeof(TCHAR);
      Size += sizeof(SOURCE_SERVER_BUFFER);
      WriteFile(hFile, &Size, sizeof(Size), &wrote, NULL);
      WriteFile(hFile, ServList, Size, &wrote, NULL);

      // Now save out linked information
      ShareListSave(hFile, ServList->ShareList);

      ServList = ServList->next;
   }

} // SServListSave


/*+-------------------------------------------------------------------------+
  | SServListLoad()
  |
  +-------------------------------------------------------------------------+*/
void SServListLoad(HANDLE hFile) {
   BOOL Continue = TRUE;
   ULONG Size;
   SOURCE_SERVER_BUFFER *tmpPtr;
   DWORD wrote;

   while (Continue) {
      // Get how long this record is
      ReadFile(hFile, &Size, sizeof(Size), &wrote, NULL);

      tmpPtr = AllocMemory(Size);
      if (tmpPtr == NULL)
         return;

      // Read in the record
      ReadFile(hFile, tmpPtr, Size, &wrote, NULL);

      // See if there are more records
      if (tmpPtr->next == NULL)
         Continue = FALSE;

      // clear out the old links - and fixup new ones
      tmpPtr->next = NULL;
      tmpPtr->prev = NULL;

      tmpPtr->LName = (LPTSTR) ((BYTE *) tmpPtr + sizeof(SOURCE_SERVER_BUFFER));
      tmpPtr->Name  = tmpPtr->LName + 2;

      // link it into the list
      if (!SServListStart)
         SServListStart = SServListEnd = tmpPtr;
      else {
         SServListEnd->next = tmpPtr;
         tmpPtr->prev = SServListEnd;
         SServListEnd = tmpPtr;
      }

#ifdef DEBUG
dprintf(TEXT("<Source Server Load>\n"));
dprintf(TEXT("   Name: %s\n"), tmpPtr->Name);
dprintf(TEXT("   Version: %u.%u\n\n"), (UINT) tmpPtr->VerMaj, (UINT) tmpPtr->VerMin);
#endif

      // Now load in linked information
      if (tmpPtr->ShareList != NULL) {
         tmpPtr->ShareList = NULL;
         ShareListLoad(hFile, &tmpPtr->ShareList);
      }

      NumSServs++;
   }

} // SServListLoad



/*+-------------------------------------------------------------------------+
  |                 Routines for Destination Server List                    |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | DServListAdd()
  |
  +-------------------------------------------------------------------------+*/
DEST_SERVER_BUFFER *DServListAdd(LPTSTR ServerName) {
   DEST_SERVER_BUFFER *tmpPtr;
   ULONG Size, strlen1;

   strlen1 = (lstrlen(ServerName) + 3) * sizeof(TCHAR);
   Size = sizeof(DEST_SERVER_BUFFER) + strlen1;
   tmpPtr = AllocMemory(Size);
   
   if (tmpPtr != NULL) {
      // init it to NULL's
      memset(tmpPtr, 0, Size);
      tmpPtr->Name = (LPTSTR) ((BYTE *) tmpPtr + sizeof(DEST_SERVER_BUFFER));
      tmpPtr->LName = tmpPtr->Name;
      lstrcpy(tmpPtr->Name, TEXT("\\\\"));
      tmpPtr->Name += 2;
      lstrcpy(tmpPtr->Name, ServerName);

      // link it into the list
      if (!DServListStart)
         DServListStart = DServListEnd = tmpPtr;
      else {
         DServListEnd->next = tmpPtr;
         tmpPtr->prev = DServListEnd;
         DServListEnd = tmpPtr;
      }

      NumDServs++;
   }

   return (tmpPtr);

} // DServListAdd


/*+-------------------------------------------------------------------------+
  | DServListDelete()
  |
  +-------------------------------------------------------------------------+*/
void DServListDelete(DEST_SERVER_BUFFER *tmpPtr) {
   DEST_SERVER_BUFFER *PrevPtr;
   DEST_SERVER_BUFFER *NextPtr;

   if (tmpPtr == NULL)
      return;

   if (tmpPtr->UseCount) {
      // Decrement use count, only delete if actually gone.
      tmpPtr->UseCount--;
      if (tmpPtr->UseCount)
         return;
   }

   // Delete any attached share list first
   ShareListDelete(tmpPtr->ShareList);

   // ...and virtual share list
   VShareListDeleteAll(tmpPtr);

   // ...and any drive list
   if (tmpPtr->DriveList)
      FreeMemory(tmpPtr->DriveList);

   // ... domain as well
   DomainListDelete(tmpPtr->Domain);

   // -- don't free for user convenience, we will clean up at end, otherwise
   // user must enter in password if delete/add
   // Free any admin share we made
   // NTUseDel(tmpPtr->Name);

   // Now unlink the actual server record
   PrevPtr = tmpPtr->prev;
   NextPtr = tmpPtr->next;

   if (PrevPtr)
      PrevPtr->next = NextPtr;

   if (NextPtr)
      NextPtr->prev = PrevPtr;

   // Check if at end of list
   if (DServListEnd == tmpPtr)
      DServListEnd = PrevPtr;

   // Check if at start of list
   if (DServListStart == tmpPtr)
      DServListStart = NextPtr;

   FreeMemory(tmpPtr);
   NumDServs--;

   if (!NumDServs)
      DServListStart = DServListEnd = NULL;

}  // DServListDelete


/*+-------------------------------------------------------------------------+
  | DServListDeleteAll()
  |
  +-------------------------------------------------------------------------+*/
void DServListDeleteAll() {
   DEST_SERVER_BUFFER *ServList;
   DEST_SERVER_BUFFER *ServListNext;

   // Now remove the entries from the internal list
   ServList = DServListStart;

   while (ServList) {
      ServListNext = ServList->next;
      ServList->UseCount = 0;
      DServListDelete(ServList);
      ServList = ServListNext;
   }

} // DServListDeleteAll


/*+-------------------------------------------------------------------------+
  | DServListFind()
  |
  +-------------------------------------------------------------------------+*/
DEST_SERVER_BUFFER *DServListFind(LPTSTR ServerName) {
   BOOL Found = FALSE;
   DEST_SERVER_BUFFER *ServList;

   ServList = DServListStart;

   while ((ServList && !Found)) {
      if (!lstrcmpi(ServList->Name, ServerName))
         Found = TRUE;
      else
         ServList = ServList->next;
   }

   if (!Found)
      ServList = NULL;

   return (ServList);

} // DServListFind


/*+-------------------------------------------------------------------------+
  | DServListIndex()
  |
  +-------------------------------------------------------------------------+*/
void DServListIndex() {
   DEST_SERVER_BUFFER *ServList;
   USHORT Count = 0;

   ServList = DServListStart;
   while (ServList) {
      ServList->Index = Count++;

      // Now index the virtual shares for this server
      VShareListIndex(ServList);
      ServList = ServList->next;
   }

} // DServListIndex


/*+-------------------------------------------------------------------------+
  | DServListIndexMapGet()
  |
  +-------------------------------------------------------------------------+*/
void DServListIndexMapGet(DWORD_PTR **pMap) {
   DWORD_PTR *Map = NULL;
   DEST_SERVER_BUFFER *ServList;

   Map = AllocMemory(NumDServs * sizeof(DWORD_PTR));

   *pMap = Map;
   if (Map == NULL)
      return;

   ServList = DServListStart;
   while (ServList) {
      Map[ServList->Index] = (DWORD_PTR) ServList;
      ServList = ServList->next;
   }

} // DServListIndexMapGet


/*+-------------------------------------------------------------------------+
  | DServListFixup()
  |
  +-------------------------------------------------------------------------+*/
void DServListFixup() {
   DEST_SERVER_BUFFER *ServList;
   DWORD_PTR *DMap = NULL;

   DomainListIndexMapGet(&DMap);

   if (DMap == NULL)
      return;

   // Just need to fixup the domain list pointers
   ServList = DServListStart;
   while (ServList) {

      if (ServList->Domain != NULL)
         ServList->Domain = (DOMAIN_BUFFER *) DMap[(DWORD_PTR) ServList->Domain - 1];

      ServList = ServList->next;
   }

   FreeMemory(DMap);

} // DServListFixup


/*+-------------------------------------------------------------------------+
  | DServListSave()
  |
  +-------------------------------------------------------------------------+*/
void DServListSave(HANDLE hFile) {
   DWORD wrote;
   ULONG Size;
   DEST_SERVER_BUFFER *ServList;
   DOMAIN_BUFFER *db;

   ServList = DServListStart;

   while (ServList) {
      Size = (lstrlen(ServList->Name) + 3) * sizeof(TCHAR);
      Size += sizeof(DEST_SERVER_BUFFER);
      WriteFile(hFile, &Size, sizeof(Size), &wrote, NULL);

      // Need to de-reference the domain pointers to their index, and after 
      // saving restore them.
      db = ServList->Domain;
      if (ServList->Domain != NULL)
         ServList->Domain = (DOMAIN_BUFFER *) (ServList->Domain->Index + 1);

      WriteFile(hFile, ServList, Size, &wrote, NULL);
      ServList->Domain = db;

      // Now save out linked information
      ShareListSave(hFile, ServList->ShareList);
      VShareListSave(hFile, ServList);

      ServList = ServList->next;
   }

} // DServListSave


/*+-------------------------------------------------------------------------+
  | DServListLoad()
  |
  +-------------------------------------------------------------------------+*/
void DServListLoad(HANDLE hFile) {
   BOOL Continue = TRUE;
   ULONG Size;
   DEST_SERVER_BUFFER *tmpPtr;
   DWORD wrote;

   while (Continue) {
      // Get how long this record is
      ReadFile(hFile, &Size, sizeof(Size), &wrote, NULL);

      tmpPtr = AllocMemory(Size);
      if (tmpPtr == NULL)
         return;

      // Read in the record
      ReadFile(hFile, tmpPtr, Size, &wrote, NULL);

      // See if there are more records
      if (tmpPtr->next == NULL)
         Continue = FALSE;

      // clear out the old links - and fixup new ones
      tmpPtr->next = NULL;
      tmpPtr->prev = NULL;

      tmpPtr->LName = (LPTSTR) ((BYTE *) tmpPtr + sizeof(DEST_SERVER_BUFFER));
      tmpPtr->Name  = tmpPtr->LName + 2;

      // link it into the list
      if (!DServListStart)
         DServListStart = DServListEnd = tmpPtr;
      else {
         DServListEnd->next = tmpPtr;
         tmpPtr->prev = DServListEnd;
         DServListEnd = tmpPtr;
      }

      // The drive list is no longer valid - so clear it out.
      tmpPtr->DriveList = NULL;

#ifdef DEBUG
dprintf(TEXT("<Dest Server Load>\n"));
dprintf(TEXT("   Name: %s\n"), tmpPtr->Name);
dprintf(TEXT("   Version: %u.%u\n\n"), (UINT) tmpPtr->VerMaj, (UINT) tmpPtr->VerMin);
#endif

      // Now load in linked information
      if (tmpPtr->ShareList != NULL) {
         tmpPtr->ShareList = NULL;
         ShareListLoad(hFile, &tmpPtr->ShareList);
      }

      if (tmpPtr->VShareStart != NULL) {
         tmpPtr->NumVShares = 0;
         tmpPtr->VShareStart = tmpPtr->VShareEnd = NULL;
         VShareListLoad(hFile, tmpPtr);
      }

      NumDServs++;
   }

} // DServListLoad


/*+-------------------------------------------------------------------------+
  | DServListSpaceFree()
  |
  +-------------------------------------------------------------------------+*/
void DServListSpaceFree() {
   DEST_SERVER_BUFFER *ServList;
   DRIVE_BUFFER *Drive;
   DRIVE_LIST *DList;
   ULONG i;

   ServList = DServListStart;
   while (ServList) {
      DList = ServList->DriveList;

      if (DList != NULL) {
         Drive = DList->DList;
         for (i = 0; i < DList->Count; i++)
            Drive[i].AllocSpace = 0;
      }

      ServList = ServList->next;
   }

} // DServListSpaceFree



/*+-------------------------------------------------------------------------+
  |                   Routines for Virtual Share Lists                      |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | VShareListAdd()
  |
  +-------------------------------------------------------------------------+*/
VIRTUAL_SHARE_BUFFER *VShareListAdd(DEST_SERVER_BUFFER *DServ, LPTSTR ShareName, LPTSTR Path) {
   VIRTUAL_SHARE_BUFFER *tmpPtr;
   ULONG Size, strlen1;

   // base struct + both strings and 2 ending NULL's
   strlen1 = ((lstrlen(ShareName)+ 1) * sizeof(TCHAR));
   Size = sizeof(VIRTUAL_SHARE_BUFFER) + strlen1;
   tmpPtr = AllocMemory(Size);
   
   if (tmpPtr != NULL) {
      // init it to NULL's
      memset(tmpPtr, 0, Size);
      tmpPtr->VFlag = TRUE;
      tmpPtr->Name = (LPTSTR) ((BYTE *) tmpPtr + sizeof(VIRTUAL_SHARE_BUFFER));
      lstrcpy(tmpPtr->Name, ShareName);
      lstrcpy(tmpPtr->Path, Path);

      // link it into the list
      if (!DServ->VShareStart)
         DServ->VShareStart = DServ->VShareEnd = tmpPtr;
      else {
         DServ->VShareEnd->next = tmpPtr;
         tmpPtr->prev = DServ->VShareEnd;
         DServ->VShareEnd = tmpPtr;
      }

      DServ->NumVShares++;
   }

   return (tmpPtr);

} // VShareListAdd


/*+-------------------------------------------------------------------------+
  | VShareListDelete()
  |
  +-------------------------------------------------------------------------+*/
void VShareListDelete(DEST_SERVER_BUFFER *DServ, VIRTUAL_SHARE_BUFFER *tmpPtr) {
   VIRTUAL_SHARE_BUFFER *PrevPtr;
   VIRTUAL_SHARE_BUFFER *NextPtr;

   if (tmpPtr == NULL)
      return;

   if (tmpPtr->UseCount) {
      // Decrement use count, only delete if actually gone.
      tmpPtr->UseCount--;
      if (tmpPtr->UseCount > 0)
         return;
   }

   PrevPtr = tmpPtr->prev;
   NextPtr = tmpPtr->next;

   if (PrevPtr)
      PrevPtr->next = NextPtr;

   if (NextPtr)
      NextPtr->prev = PrevPtr;

   // Check if at end of list
   if (DServ->VShareEnd == tmpPtr)
      DServ->VShareEnd = PrevPtr;

   // Check if at start of list
   if (DServ->VShareStart == tmpPtr)
      DServ->VShareStart = NextPtr;

   FreeMemory(tmpPtr);
   DServ->NumVShares--;

   if (!DServ->NumVShares)
      DServ->VShareStart = DServ->VShareEnd = NULL;

}  // VShareListDelete


/*+-------------------------------------------------------------------------+
  | VShareListDeleteAll()
  |
  +-------------------------------------------------------------------------+*/
void VShareListDeleteAll(DEST_SERVER_BUFFER *DServ) {
   VIRTUAL_SHARE_BUFFER *ShareList;
   VIRTUAL_SHARE_BUFFER *ShareListNext;

   // Now remove the entries from the internal list
   ShareList = DServ->VShareStart;

   while (ShareList) {
      ShareListNext = ShareList->next;

      // Flag to zero to make sure destroyed
      ShareList->UseCount = 0;
      VShareListDelete(DServ, ShareList);
      ShareList = ShareListNext;
   }

} // VShareListDeleteAll


/*+-------------------------------------------------------------------------+
  | VShareListIndex()
  |
  +-------------------------------------------------------------------------+*/
void VShareListIndex(DEST_SERVER_BUFFER *DServ) {
   VIRTUAL_SHARE_BUFFER *ShareList;
   USHORT Count = 0;

   ShareList = DServ->VShareStart;
   while (ShareList) {
      ShareList->Index = Count++;
      ShareList = ShareList->next;
   }

} // VShareListIndex


/*+-------------------------------------------------------------------------+
  | VShareListIndexMapGet()
  |
  +-------------------------------------------------------------------------+*/
void VShareListIndexMapGet(DEST_SERVER_BUFFER *DServ, DWORD_PTR **pMap) {
   DWORD_PTR *Map = NULL;
   VIRTUAL_SHARE_BUFFER *ShareList;

   Map = AllocMemory( DServ->NumVShares * sizeof(DWORD_PTR) );

   *pMap = Map;
   if (Map == NULL)
      return;

   ShareList = DServ->VShareStart;
   while (ShareList) {
      Map[ShareList->Index] = (DWORD_PTR) ShareList;
      ShareList = ShareList->next;
   }

} // VShareListIndexMapGet


/*+-------------------------------------------------------------------------+
  | VShareListSave()
  |
  +-------------------------------------------------------------------------+*/
void VShareListSave(HANDLE hFile, DEST_SERVER_BUFFER *DServ) {
   DWORD wrote;
   ULONG Size;
   VIRTUAL_SHARE_BUFFER *ShareList;

   ShareList = DServ->VShareStart;

   while (ShareList) {
      Size = (lstrlen(ShareList->Name) + 1) * sizeof(TCHAR);
      Size += sizeof(VIRTUAL_SHARE_BUFFER);
      WriteFile(hFile, &Size, sizeof(Size), &wrote, NULL);
      WriteFile(hFile, ShareList, Size, &wrote, NULL);
      ShareList = ShareList->next;
   }

} // VShareListSave


/*+-------------------------------------------------------------------------+
  | VShareListLoad()
  |
  +-------------------------------------------------------------------------+*/
void VShareListLoad(HANDLE hFile, DEST_SERVER_BUFFER *DServ) {
   BOOL Continue = TRUE;
   ULONG Size;
   VIRTUAL_SHARE_BUFFER *tmpPtr;
   DWORD wrote;

   while (Continue) {
      // Get how long this record is
      ReadFile(hFile, &Size, sizeof(Size), &wrote, NULL);

      tmpPtr = AllocMemory(Size);
      if (tmpPtr == NULL)
         return;

      // Read in the record
      ReadFile(hFile, tmpPtr, Size, &wrote, NULL);

      // See if there are more records
      if (tmpPtr->next == NULL)
         Continue = FALSE;

      // clear out the old links - and fixup new ones
      tmpPtr->next = NULL;
      tmpPtr->prev = NULL;
      tmpPtr->Name = (LPTSTR) ((BYTE *) tmpPtr + sizeof(VIRTUAL_SHARE_BUFFER));
      tmpPtr->Drive = NULL;

      // link it into the list
      if (!DServ->VShareStart)
         DServ->VShareStart = DServ->VShareEnd = tmpPtr;
      else {
         DServ->VShareEnd->next = tmpPtr;
         tmpPtr->prev = DServ->VShareEnd;
         DServ->VShareEnd = tmpPtr;
      }

      DServ->NumVShares++;
   }

} // VShareListLoad


/*+-------------------------------------------------------------------------+
  | VShareListFixup()
  |
  +-------------------------------------------------------------------------+*/
void VShareListFixup(DEST_SERVER_BUFFER *DServ) {
   VIRTUAL_SHARE_BUFFER *VShare;
   USHORT Count = 0;
   DWORD di;
   DRIVE_LIST *Drives;
   DRIVE_BUFFER *DList;
   ULONG TotalDrives;
   TCHAR Drive[2];

   if (DServ->DriveList == NULL)
      return;

   TotalDrives = 0;
   Drives = DServ->DriveList;
   Drive[1] = TEXT('\0');
   DList = Drives->DList;
   TotalDrives = Drives->Count;

   VShare = DServ->VShareStart;
   while (VShare) {
      VShare->Drive = NULL;

      // Scan drive list looking for match to share path
      for (di = 0; di < TotalDrives; di++) {
         // Get first char from path - should be drive letter
         Drive[0] = *VShare->Path;
         if (!lstrcmpi(Drive, DList[di].Drive))
            VShare->Drive = &DList[di];
      }

      VShare = VShare->next;
   }

} // VShareListFixup



/*+-------------------------------------------------------------------------+
  |                       Routines for Domain Lists                         |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | DomainListAdd()
  |
  +-------------------------------------------------------------------------+*/
DOMAIN_BUFFER *DomainListAdd(LPTSTR DomainName, LPTSTR PDCName) {
   DOMAIN_BUFFER *tmpPtr;
   ULONG Size, strlen1, strlen2;

   // base struct + both strings and 2 ending NULL's
   strlen1 = ((lstrlen(DomainName) + 1) * sizeof(TCHAR));
   strlen2 = ((lstrlen(PDCName) + 1) * sizeof(TCHAR));
   Size = sizeof(DOMAIN_BUFFER) + strlen1 + strlen2;
   tmpPtr = AllocMemory(Size);
   
   if (tmpPtr != NULL) {
      // init it to NULL's
      memset(tmpPtr, 0, Size);
      tmpPtr->Name = (LPTSTR) ((BYTE *) tmpPtr + sizeof(DOMAIN_BUFFER));
      tmpPtr->PDCName = (LPTSTR) ((BYTE *) tmpPtr + sizeof(DOMAIN_BUFFER) + strlen1);
      lstrcpy(tmpPtr->Name, DomainName);
      lstrcpy(tmpPtr->PDCName, PDCName);

      // link it into the list
      if (!DomainListStart)
         DomainListStart = DomainListEnd = tmpPtr;
      else {
         DomainListEnd->next = tmpPtr;
         tmpPtr->prev = DomainListEnd;
         DomainListEnd = tmpPtr;
      }

      NumDomains++;
   }

   return (tmpPtr);

} // DomainListAdd


/*+-------------------------------------------------------------------------+
  | DomainListDelete()
  |
  +-------------------------------------------------------------------------+*/
void DomainListDelete(DOMAIN_BUFFER *tmpPtr) {
   DOMAIN_BUFFER *PrevPtr;
   DOMAIN_BUFFER *NextPtr;

   if (tmpPtr == NULL)
      return;

   if (tmpPtr->UseCount) {
      // Decrement use count, only delete if actually gone.
      tmpPtr->UseCount--;
      if (tmpPtr->UseCount)
         return;
   }

   PrevPtr = tmpPtr->prev;
   NextPtr = tmpPtr->next;

   if (PrevPtr)
      PrevPtr->next = NextPtr;

   if (NextPtr)
      NextPtr->prev = PrevPtr;

   // Check if at end of list
   if (DomainListEnd == tmpPtr)
      DomainListEnd = PrevPtr;

   // Check if at start of list
   if (DomainListStart == tmpPtr)
      DomainListStart = NextPtr;

   FreeMemory(tmpPtr);
   NumDomains--;

   if (!NumDomains)
      DomainListStart = DomainListEnd = NULL;

}  // DomainListDelete


/*+-------------------------------------------------------------------------+
  | DomainListDeleteAll()
  |
  +-------------------------------------------------------------------------+*/
void DomainListDeleteAll() {
   DOMAIN_BUFFER *DomList;
   DOMAIN_BUFFER *DomListNext;

   // Now remove the entries from the internal list
   DomList = DomainListStart;

   while (DomList) {
      DomListNext = DomList->next;
      DomList->UseCount = 0;
      DomainListDelete(DomList);
      DomList = DomListNext;
   }

} // DomainListDeleteAll


/*+-------------------------------------------------------------------------+
  | DomainListFind()
  |
  +-------------------------------------------------------------------------+*/
DOMAIN_BUFFER *DomainListFind(LPTSTR DomainName) {
   BOOL Found = FALSE;
   DOMAIN_BUFFER *DomainList;

   DomainList = DomainListStart;

   while ((DomainList && !Found)) {
      if (!lstrcmpi(DomainList->Name, DomainName))
         Found = TRUE;
      else
         DomainList = DomainList->next;
   }

   if (!Found)
      DomainList = NULL;

   return (DomainList);

} // DomainListFind


/*+-------------------------------------------------------------------------+
  | DomainListIndex()
  |
  +-------------------------------------------------------------------------+*/
void DomainListIndex() {
   DOMAIN_BUFFER *DomList;
   USHORT Count = 0;

   DomList = DomainListStart;
   while (DomList) {
      DomList->Index = Count++;
      DomList = DomList->next;
   }

} // DomainListIndex


/*+-------------------------------------------------------------------------+
  | DomainListIndexMapGet()
  |
  +-------------------------------------------------------------------------+*/
void DomainListIndexMapGet(DWORD_PTR **pMap) {
   DWORD_PTR *Map = NULL;
   DOMAIN_BUFFER *DomList;

   Map = AllocMemory(NumDomains * sizeof(DWORD_PTR));

   *pMap = Map;
   if (Map == NULL)
      return;

   DomList = DomainListStart;
   while (DomList) {
      Map[DomList->Index] = (DWORD_PTR) DomList;
      DomList = DomList->next;
   }

} // DomainListIndexMapGet


/*+-------------------------------------------------------------------------+
  | DomainListSave()
  |
  +-------------------------------------------------------------------------+*/
void DomainListSave(HANDLE hFile) {
   DWORD wrote;
   ULONG Size;
   DOMAIN_BUFFER *DomList;

   WriteFile(hFile, &NumDomains, sizeof(NumDomains), &wrote, NULL);

   DomList = DomainListStart;
   while (DomList) {
      Size = (lstrlen(DomList->Name) + 1) * sizeof(TCHAR);
      Size += (lstrlen(DomList->PDCName) + 1) * sizeof(TCHAR);
      Size += sizeof(DOMAIN_BUFFER);
      WriteFile(hFile, &Size, sizeof(Size), &wrote, NULL);
      WriteFile(hFile, DomList, Size, &wrote, NULL);
      DomList = DomList->next;
   }

} // DomainListSave


/*+-------------------------------------------------------------------------+
  | DomainListLoad()
  |
  +-------------------------------------------------------------------------+*/
void DomainListLoad(HANDLE hFile) {
   BOOL Continue = TRUE;
   ULONG Size, namelen;
   DOMAIN_BUFFER *tmpPtr;
   DWORD wrote;

   ReadFile(hFile, &NumDomains, sizeof(NumDomains), &wrote, NULL);
   if (NumDomains == 0)
      Continue = FALSE;
      
   NumDomains = 0;
   while (Continue) {
      // Get how long this record is
      ReadFile(hFile, &Size, sizeof(Size), &wrote, NULL);

      tmpPtr = AllocMemory(Size);
      if (tmpPtr == NULL)
         return;

      // Read in the record
      ReadFile(hFile, tmpPtr, Size, &wrote, NULL);

      // See if there are more records
      if (tmpPtr->next == NULL)
         Continue = FALSE;

      // clear out the old links - and fixup new ones
      tmpPtr->next = NULL;
      tmpPtr->prev = NULL;
      tmpPtr->Name = (LPTSTR) ((BYTE *) tmpPtr + sizeof(DOMAIN_BUFFER));
      namelen = ((lstrlen(tmpPtr->Name) + 1) * sizeof(TCHAR));
      tmpPtr->PDCName = (LPTSTR) ((BYTE *) tmpPtr + sizeof(DOMAIN_BUFFER) + namelen);

#ifdef DEBUG
dprintf(TEXT("<Domain List Load>\n"));
dprintf(TEXT("   Name: %s\n"), tmpPtr->Name);
dprintf(TEXT("   PDC Name: %s\n\n"), tmpPtr->PDCName);
#endif

      // link it into the list
      if (!DomainListStart)
         DomainListStart = DomainListEnd = tmpPtr;
      else {
         DomainListEnd->next = tmpPtr;
         tmpPtr->prev = DomainListEnd;
         DomainListEnd = tmpPtr;
      }

      NumDomains++;
   }

} // DomainListLoad



/*+-------------------------------------------------------------------------+
  |                      Routines for Convert Lists                         |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | ConvertListAdd()
  |
  |    Allocates and inserts a new record for holding a server pair and
  |    associated conversion options.
  |
  | Comments:
  |    The convert list is a doubly linked list of records.  Each record
  |    contains the source and destination server (server-pair) and a
  |    pointer to the conversion specific information.  The exact info
  |    is specific to the platform being converted from (source server type)
  |
  +-------------------------------------------------------------------------+*/
CONVERT_LIST *ConvertListAdd(SOURCE_SERVER_BUFFER *SourceServer, DEST_SERVER_BUFFER *DestServer) {
   CONVERT_OPTIONS *cvo;
   CONVERT_LIST *tmpPtr;
   CONVERT_LIST *cPtr;
   BOOL match = FALSE;

   tmpPtr = AllocMemory(sizeof(CONVERT_LIST));

   if (tmpPtr != NULL) {
      // zero it out
      memset(tmpPtr, 0, sizeof(CONVERT_LIST));

      tmpPtr->SourceServ = SourceServer;
      tmpPtr->FileServ = DestServer;

      // initialize the conversion options
      UserOptionsInit(&tmpPtr->ConvertOptions);

      // Set NetWareInfo based on current FPNW setting...
      cvo = (CONVERT_OPTIONS *) tmpPtr->ConvertOptions;
      cvo->NetWareInfo = DestServer->IsFPNW;

      FileOptionsInit(&tmpPtr->FileOptions);

      // link it into the list - we want to link right after another
      // convert to this same server, or to the same domain. otherwise
      // tag it onto the end of the list.
      if (!ConvertListStart)
         ConvertListStart = ConvertListEnd = tmpPtr;
      else {
         // Have some files in the list - find out if destination server
         // is already in the list and if so append after it.
         if (DestServer->UseCount > 1) {
            // should be in the list so find it.
            cPtr = ConvertListStart;
            while (cPtr && !match) {
               if (!lstrcmpi(DestServer->Name, cPtr->FileServ->Name))
                  match = TRUE;
               else
                  cPtr = cPtr->next;
            }

            if (match) {
               // have a match - so go to the end of the matching pairs...
               while (cPtr && match) {
                  if (lstrcmpi(DestServer->Name, cPtr->FileServ->Name))
                     match = FALSE;
                  else
                     cPtr = cPtr->next;
               }

               match = !match;
            }
         }

         // if didn't find a server match - look for a domain match
         if (!match) {
            if (DestServer->InDomain && DestServer->Domain) {
               // should be in the list so find it.
               cPtr = ConvertListStart;
               while (cPtr && !match) {
                  if (cPtr->FileServ->InDomain && cPtr->FileServ->Domain)
                     if (!lstrcmpi(DestServer->Domain->Name, cPtr->FileServ->Domain->Name))
                        match = TRUE;

                  if (!match)
                     cPtr = cPtr->next;
               }

               if (match) {
                  // have a match - so go to the end of the matching pairs...
                  while (cPtr && match) {
                     if (cPtr->FileServ->InDomain && cPtr->FileServ->Domain) {
                        if (lstrcmpi(DestServer->Domain->Name, cPtr->FileServ->Domain->Name))
                           match = FALSE;
                     } else
                        match = FALSE;

                     if (match)
                        cPtr = cPtr->next;
                  }

                  match = !match;
               }
            }
         }

         // if match then in middle of buffer, else use end
         if (match && (cPtr != ConvertListEnd)) {
            tmpPtr->prev = cPtr->prev;
            tmpPtr->next = cPtr;
            cPtr->prev->next = tmpPtr;
         } else {
            // only one in list so add at end
            ConvertListEnd->next = tmpPtr;
            tmpPtr->prev = ConvertListEnd;
            ConvertListEnd = tmpPtr;
         }

      }

      NumServerPairs++;
   }

   return (tmpPtr);

} // ConvertListAdd


/*+-------------------------------------------------------------------------+
  | ConvertListDelete()
  |
  |    Removes and deallocates a convert list entry from the conversion
  |    list.
  |
  +-------------------------------------------------------------------------+*/
void ConvertListDelete(CONVERT_LIST *tmpPtr) {
   CONVERT_LIST *PrevPtr;
   CONVERT_LIST *NextPtr;

   // First get rid of the source and destination server this is pointing to -
   // those routines take care of freeing up chained data structures. Also
   // DServList will only be delete if it's UseCount goes to 0.
   SServListDelete(tmpPtr->SourceServ);
   DServListDelete(tmpPtr->FileServ);

   // Now unlink the actual convert list record
   PrevPtr = tmpPtr->prev;
   NextPtr = tmpPtr->next;

   if (PrevPtr)
      PrevPtr->next = NextPtr;

   if (NextPtr)
      NextPtr->prev = PrevPtr;

   // Check if at end of list
   if (ConvertListEnd == tmpPtr)
      ConvertListEnd = PrevPtr;

   // Check if at start of list
   if (ConvertListStart == tmpPtr)
      ConvertListStart = NextPtr;

   FreeMemory(tmpPtr->ConvertOptions);
   FreeMemory(tmpPtr);
   NumServerPairs--;

   if (!NumServerPairs)
      ConvertListStart = ConvertListEnd = NULL;

}  // ConvertListDelete


/*+-------------------------------------------------------------------------+
  | ConvertListDeleteAll()
  |
  |    Removes and deallocates all the convert list entrys and removes them
  |    from the listbox.
  |
  +-------------------------------------------------------------------------+*/
void ConvertListDeleteAll() {
   CONVERT_LIST *ConvList;
   CONVERT_LIST *ConvListNext;

   // Now remove the entries from the internal list
   ConvList = ConvertListStart;

   while (ConvList) {
      ConvListNext = ConvList->next;
      ConvertListDelete(ConvList);
      ConvList = ConvListNext;
   }

} // ConvertListDeleteAll


/*+-------------------------------------------------------------------------+
  | ConvertListSaveAll()
  |
  +-------------------------------------------------------------------------+*/
void ConvertListSaveAll(HANDLE hFile) {
   DWORD wrote;
   SOURCE_SERVER_BUFFER *ss;
   DEST_SERVER_BUFFER *ds;

   // First need to walk source and dest server lists and re-synch the 
   // index numbers as we can't use pointers loading them back in.
   SServListIndex();
   DServListIndex();       // Takes care of the VShares
   DomainListIndex();

   // Done with re-synch of indexes - do actual saving.
   CurrentConvertList = ConvertListStart;
   while (CurrentConvertList) {
      // Need to de-reference the server pointers to their index, and after 
      // saving restore them.
      ss = CurrentConvertList->SourceServ;
      ds = CurrentConvertList->FileServ;
      CurrentConvertList->SourceServ = (SOURCE_SERVER_BUFFER *) CurrentConvertList->SourceServ->Index;
      CurrentConvertList->FileServ = (DEST_SERVER_BUFFER *) CurrentConvertList->FileServ->Index;

      WriteFile(hFile, CurrentConvertList, sizeof(CONVERT_LIST), &wrote, NULL);

      CurrentConvertList->SourceServ = ss;
      CurrentConvertList->FileServ = ds;

      // Now the options
      UserOptionsSave(hFile, CurrentConvertList->ConvertOptions);
      FileOptionsSave(hFile, CurrentConvertList->FileOptions);

      CurrentConvertList = CurrentConvertList->next;
   }

   // Saved out the convert list - now need to save out the linked
   // information (these routines save their linked info as well).
   DomainListSave(hFile);
   DServListSave(hFile);
   SServListSave(hFile);

} // ConvertListSaveAll


/*+-------------------------------------------------------------------------+
  | ConvertListLoadAll()
  |
  +-------------------------------------------------------------------------+*/
void ConvertListLoadAll(HANDLE hFile) {
   CONVERT_LIST *tmpPtr;
   BOOL Continue = TRUE;
   DWORD wrote;

   while (Continue) {
      tmpPtr = AllocMemory(sizeof(CONVERT_LIST));
      if (tmpPtr == NULL)
         return;

      // Read in the record
      ReadFile(hFile, tmpPtr, sizeof(CONVERT_LIST), &wrote, NULL);

      // See if there are more records
      if (tmpPtr->next == NULL)
         Continue = FALSE;

      // clear out the old links - and fixup new ones
      tmpPtr->next = NULL;
      tmpPtr->prev = NULL;
      tmpPtr->ConvertOptions = NULL;
      tmpPtr->FileOptions = NULL;

      // Read in options - note the trusted domain must be fixed up later
      // after the domain list is read in
      UserOptionsLoad(hFile, &tmpPtr->ConvertOptions);
      FileOptionsLoad(hFile, &tmpPtr->FileOptions);

      // link it into the list
      if (!ConvertListStart)
         ConvertListStart = ConvertListEnd = tmpPtr;
      else {
         ConvertListEnd->next = tmpPtr;
         tmpPtr->prev = ConvertListEnd;
         ConvertListEnd = tmpPtr;
      }

      NumServerPairs++;
   }

   // Loaded the convert list - now need to bring in the linked
   // information (these routines load their linked info as well).
   DomainListLoad(hFile);
   DServListLoad(hFile);
   SServListLoad(hFile);

} // ConvertListLoadAll


/*+-------------------------------------------------------------------------+
  | ConvertListFixup()
  |
  +-------------------------------------------------------------------------+*/
void ConvertListFixup(HWND hWnd) {
   BOOL ok = TRUE;
   DWORD_PTR *SMap = NULL;
   DWORD_PTR *DMap = NULL;
   CONVERT_LIST *NextList;
   CONVERT_OPTIONS *cvto;

   // Generate Source and Destination server Index -> pointer maps
   DServListIndexMapGet(&DMap);
   SServListIndexMapGet(&SMap);

   if ((DMap == NULL) || (SMap == NULL))
      return;

   CurrentConvertList = ConvertListStart;
   while (CurrentConvertList) {
      CurrentConvertList->FileServ = (DEST_SERVER_BUFFER *) DMap[(DWORD_PTR) CurrentConvertList->FileServ];
      CurrentConvertList->SourceServ = (SOURCE_SERVER_BUFFER *) SMap[(DWORD_PTR) CurrentConvertList->SourceServ];

      CurrentConvertList = CurrentConvertList->next;
   }

   // Free up the index maps
   FreeMemory(DMap);
   FreeMemory(SMap);

   // Fixed the convert list - now need to fix the linked information 
   // (these routines fix-up their linked info as well).
   DServListFixup();
   SServListFixup();

   // For the user options later on
   DomainListIndexMapGet(&DMap);

   // Now validate each of the machines
   CurrentConvertList = ConvertListStart;
   while (CurrentConvertList) {
      ok = TRUE;
      if (!NTServerValidate(hWnd, CurrentConvertList->FileServ->Name))
         ok = FALSE;

      if (ok)
         if (!NWServerValidate(hWnd, CurrentConvertList->SourceServ->Name, FALSE))
            ok = FALSE;

      NextList = CurrentConvertList->next;

      if (!ok) {
         ConvertListDelete(CurrentConvertList);
      } else {
         // The connections were okay to these so resynch their information
         NWServerInfoReset(CurrentConvertList->SourceServ);
         NTServerInfoReset(hWnd, CurrentConvertList->FileServ, TRUE);
         DestShareListFixup(CurrentConvertList->FileServ);
         VShareListFixup(CurrentConvertList->FileServ);
         SourceShareListFixup(CurrentConvertList->FileServ, CurrentConvertList->SourceServ->ShareList);

         // need to fixup the trusted domain in the user options to the new 
         // domain list...
         cvto = (CONVERT_OPTIONS *) CurrentConvertList->ConvertOptions;

         if (cvto->UseTrustedDomain)
            cvto->TrustedDomain = (DOMAIN_BUFFER *) DMap[(DWORD_PTR) cvto->TrustedDomain];
         else
            cvto->TrustedDomain = NULL;

      }

      CurrentConvertList = NextList;
   }

   // Free up the domain index map
   FreeMemory(DMap);

} // ConvertListFixup


/*+-------------------------------------------------------------------------+
  | ConvertListLog()
  |
  +-------------------------------------------------------------------------+*/
void ConvertListLog() {
   DEST_SERVER_BUFFER *DServ = NULL;
   SOURCE_SERVER_BUFFER *SServ = NULL;
   ULONG i;

   CurrentConvertList = ConvertListStart;

   // Log format is:
   //
   // Number of Servers = 1
   //
   // [Servers]
   //     From:  Source1      To: Dest1
   //     From:  Source2      To: Dest2
   LogWriteLog(0, Lids(IDS_L_126), NumServerPairs);
   LogWriteLog(0, Lids(IDS_CRLF));
   LogWriteLog(0, Lids(IDS_L_127));

   LogWriteSummary(0, Lids(IDS_L_126), NumServerPairs);
   LogWriteSummary(0, Lids(IDS_CRLF));
   LogWriteSummary(0, Lids(IDS_L_127));

   // Loop through the conversion pairs (they are already in order)
   while (CurrentConvertList) {
      LogWriteLog(1, Lids(IDS_L_128), CurrentConvertList->SourceServ->Name, CurrentConvertList->FileServ->Name);
      LogWriteSummary(1, Lids(IDS_L_128), CurrentConvertList->SourceServ->Name, CurrentConvertList->FileServ->Name);
      CurrentConvertList = CurrentConvertList->next;
   }

   LogWriteLog(0, Lids(IDS_CRLF));
   LogWriteSummary(0, Lids(IDS_CRLF));

   // Now write detailed info on each server
   CurrentConvertList = ConvertListStart;

   // header for this section
   LogWriteLog(0, Lids(IDS_LINE));
   LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_129));
   LogWriteLog(0, Lids(IDS_LINE));
   LogWriteLog(0, Lids(IDS_CRLF));

   while (CurrentConvertList) {
      // Make sure to only log each source server once
      if (DServ != CurrentConvertList->FileServ) {
         // remember this new server
         DServ = CurrentConvertList->FileServ;

         LogWriteLog(0, TEXT("[%s]\r\n"), CurrentConvertList->FileServ->Name);
         LogWriteLog(1, Lids(IDS_L_130));
         LogWriteLog(1, Lids(IDS_L_131), DServ->VerMaj, DServ->VerMin);

         if (DServ->DriveList) {
            LogWriteLog(0, Lids(IDS_CRLF));
            LogWriteLog(1, Lids(IDS_L_132));

            for (i = 0; i < DServ->DriveList->Count; i++) {
               LogWriteLog(2, TEXT("%s: [%4s] %s\r\n"), DServ->DriveList->DList[i].Drive, DServ->DriveList->DList[i].DriveType, DServ->DriveList->DList[i].Name);
               LogWriteLog(3, Lids(IDS_L_133), lToStr(DServ->DriveList->DList[i].FreeSpace));
            }
         }

         // Log Shares
         ShareListLog(DServ->ShareList, TRUE);
      }

      // Now for the source server
      SServ = CurrentConvertList->SourceServ;
      LogWriteLog(0, TEXT("[%s]\r\n"), CurrentConvertList->SourceServ->Name);
      LogWriteLog(1, Lids(IDS_L_134));
      LogWriteLog(1, Lids(IDS_L_135), (UINT) SServ->VerMaj, (UINT) SServ->VerMin);

      ShareListLog(SServ->ShareList, FALSE);

      CurrentConvertList = CurrentConvertList->next;
   }

} // ConvertListLog


/*+-------------------------------------------------------------------------+
  | UserServerNameGet()
  |
  +-------------------------------------------------------------------------+*/
LPTSTR UserServerNameGet(DEST_SERVER_BUFFER *DServ, void *COpt) {
   CONVERT_OPTIONS *ConvOpt;
   LPTSTR ServName = NULL;

   ConvOpt = (CONVERT_OPTIONS *) COpt;
   // If going to a trusted domain then point to it's PDC for user transfers
   if (ConvOpt->UseTrustedDomain && (ConvOpt->TrustedDomain != NULL) && (ConvOpt->TrustedDomain->PDCName != NULL)) {
      ServName = ConvOpt->TrustedDomain->PDCName;
   } else
      // If in a domain then point to the PDC for user transfers
      if (DServ->InDomain && DServ->Domain) {
         ServName = DServ->Domain->PDCName;
      } else {
         ServName = DServ->Name;
      }

   return ServName;
} // UserServerNameGet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\statbox.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _HSTATBOX_
#define _HSTATBOX_

#ifdef __cplusplus
extern "C"{
#endif

void Status_CurConv(UINT Num);
void Status_TotConv(UINT Num);
void Status_SrcServ(LPTSTR Server);
void Status_DestServ(LPTSTR Server);
void Status_ConvTxt(LPTSTR Text);
void Status_CurNum(UINT Num);
void Status_CurTot(UINT Num);
void Status_ItemLabel(LPTSTR Text, ...);
void Status_Item(LPTSTR Text);
void Status_TotComplete(UINT Num);
void Status_TotGroups(UINT Num);
void Status_TotUsers(UINT Num);
void Status_TotFiles(UINT Num);
void Status_TotErrors(UINT Num);
void Status_BytesTxt(LPTSTR Text);
void Status_Bytes(LPTSTR Text);
void Status_TotBytes(LPTSTR Text);
void Status_BytesSep(LPTSTR Text);

void DoStatusDlg(HWND hDlg);
void StatusDlgKill();

void Panel_Line(int Line, LPTSTR szFormat, ...);
void PanelDlg_Do(HWND hDlg, LPTSTR Title);
BOOL Panel_Cancel();
void PanelDlgKill();

ULONG UserNameErrorDlg_Do(LPTSTR Title, LPTSTR Problem, USER_BUFFER *User);
ULONG GroupNameErrorDlg_Do(LPTSTR Title, LPTSTR Problem, GROUP_BUFFER *Group);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\switches.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _SWITCHES_
#define _SWITCHES_

#if DBG && !defined(DEBUG)
#define DEBUG
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\strings.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _STRINGS_
#define _STRINGS_

#define MAX_STRING_SIZE 256

#define IDS_STRINGBASE              (1500)

#define IDS_APPNAME                 (IDS_STRINGBASE+1)

#define IDS_DISK_SPACE_UNAVAIL      (IDS_STRINGBASE+2)
#define IDS_DISK_SPACE              (IDS_STRINGBASE+3)
#define IDS_MATH_COPR_NOTPRESENT    (IDS_STRINGBASE+4)
#define IDS_MATH_COPR_PRESENT       (IDS_STRINGBASE+5)
#define IDS_PHYSICAL_MEM            (IDS_STRINGBASE+6)

#define IDS_USERFILTERSTRING        (IDS_STRINGBASE+7)
#define IDS_MAINFILTERSTRING        (IDS_STRINGBASE+8)

#define IDS_TXTWARNING              (IDS_STRINGBASE+9)
#define IDS_RESTOREDEFAULTS         (IDS_STRINGBASE+10)

#define IDS_MAPNEWNAME              (IDS_STRINGBASE+11)
#define IDS_MAPNEWPASSWORD          (IDS_STRINGBASE+12)
#define IDS_MAPGROUPS               (IDS_STRINGBASE+13)

#define IDS_NOREADMAP               (IDS_STRINGBASE+14)
#define IDS_MAPCREATED              (IDS_STRINGBASE+15)
#define IDS_MAPCREATEFAIL           (IDS_STRINGBASE+16)

#define IDS_CRLF                    (IDS_STRINGBASE+17)

#define IDS_SUN                     (IDS_STRINGBASE+18)
#define IDS_MON                     (IDS_STRINGBASE+19)
#define IDS_TUE                     (IDS_STRINGBASE+20)
#define IDS_WED                     (IDS_STRINGBASE+21)
#define IDS_THU                     (IDS_STRINGBASE+22)
#define IDS_FRI                     (IDS_STRINGBASE+23)
#define IDS_SAT                     (IDS_STRINGBASE+24)

#define IDS_SUNDAY                  (IDS_STRINGBASE+25)
#define IDS_MONDAY                  (IDS_STRINGBASE+26)
#define IDS_TUESDAY                 (IDS_STRINGBASE+27)
#define IDS_WEDNESDAY               (IDS_STRINGBASE+28)
#define IDS_THURSDAY                (IDS_STRINGBASE+29)
#define IDS_FRIDAY                  (IDS_STRINGBASE+30)
#define IDS_SATURDAY                (IDS_STRINGBASE+31)

#define IDS_NWCANT_CON              (IDS_STRINGBASE+32)
#define IDS_NWNO_ADMIN              (IDS_STRINGBASE+33)

#define IDS_LINE                    (IDS_STRINGBASE+34)
#define IDS_BRACE                   (IDS_STRINGBASE+35)
#define IDS_YES                     (IDS_STRINGBASE+36)
#define IDS_NO                      (IDS_STRINGBASE+37)

#define IDS_E_NWLOG                 (IDS_STRINGBASE+38)
#define IDS_NOEDITMAP               (IDS_STRINGBASE+39)

#define IDS_LOCKED_OUT              (IDS_STRINGBASE+40)

/////////////////
#define IDS_D_STRINGBASE            (IDS_STRINGBASE+40)

#define IDS_D_1                     (IDS_D_STRINGBASE+1)
#define IDS_D_2                     (IDS_D_STRINGBASE+2)
#define IDS_D_3                     (IDS_D_STRINGBASE+3)
#define IDS_D_4                     (IDS_D_STRINGBASE+4)
#define IDS_D_5                     (IDS_D_STRINGBASE+5)
#define IDS_D_6                     (IDS_D_STRINGBASE+6)
#define IDS_D_7                     (IDS_D_STRINGBASE+7)
#define IDS_D_8                     (IDS_D_STRINGBASE+8)
#define IDS_D_9                     (IDS_D_STRINGBASE+9)
#define IDS_D_10                    (IDS_D_STRINGBASE+10)

#define IDS_D_11                    (IDS_D_STRINGBASE+11)
#define IDS_D_12                    (IDS_D_STRINGBASE+12)

#define IDS_D_13                    (IDS_D_STRINGBASE+13)
#define IDS_D_14                    (IDS_D_STRINGBASE+14)

#define IDS_D_15                    (IDS_D_STRINGBASE+15)
#define IDS_D_16                    (IDS_D_STRINGBASE+16)

#define IDS_D_17                    (IDS_D_STRINGBASE+17)

#define IDS_D_18                    (IDS_D_STRINGBASE+18)
#define IDS_D_19                    (IDS_D_STRINGBASE+19)

#define IDS_D_20                    (IDS_D_STRINGBASE+20)
#define IDS_D_21                    (IDS_D_STRINGBASE+21)

#define IDS_D_22                    (IDS_D_STRINGBASE+22)


////////////
#define IDS_S_STRINGBASE            (IDS_D_STRINGBASE+22)

#define IDS_S_1                     (IDS_S_STRINGBASE+1)
#define IDS_S_2                     (IDS_S_STRINGBASE+2)
#define IDS_S_3                     (IDS_S_STRINGBASE+3)
#define IDS_S_4                     (IDS_S_STRINGBASE+4)
#define IDS_S_5                     (IDS_S_STRINGBASE+5)
#define IDS_S_6                     (IDS_S_STRINGBASE+6)

#define IDS_S_7                     (IDS_S_STRINGBASE+7)
#define IDS_S_8                     (IDS_S_STRINGBASE+8)

#define IDS_S_9                     (IDS_S_STRINGBASE+9)
#define IDS_S_10                    (IDS_S_STRINGBASE+10)
#define IDS_S_11                    (IDS_S_STRINGBASE+11)

#define IDS_S_12                    (IDS_S_STRINGBASE+12)
#define IDS_S_13                    (IDS_S_STRINGBASE+13)
#define IDS_S_14                    (IDS_S_STRINGBASE+14)

#define IDS_S_15                    (IDS_S_STRINGBASE+15)
#define IDS_S_16                    (IDS_S_STRINGBASE+16)
#define IDS_S_17                    (IDS_S_STRINGBASE+17)
#define IDS_S_18                    (IDS_S_STRINGBASE+18)
#define IDS_S_19                    (IDS_S_STRINGBASE+19)

#define IDS_S_20                    (IDS_S_STRINGBASE+20)

#define IDS_S_21                    (IDS_S_STRINGBASE+21)
#define IDS_S_22                    (IDS_S_STRINGBASE+22)
#define IDS_S_23                    (IDS_S_STRINGBASE+23)
#define IDS_S_24                    (IDS_S_STRINGBASE+24)
#define IDS_S_25                    (IDS_S_STRINGBASE+25)
#define IDS_S_26                    (IDS_S_STRINGBASE+26)

#define IDS_S_27                    (IDS_S_STRINGBASE+27)

#define IDS_S_28                    (IDS_S_STRINGBASE+28)
#define IDS_S_29                    (IDS_S_STRINGBASE+29)
#define IDS_S_30                    (IDS_S_STRINGBASE+30)
#define IDS_S_31                    (IDS_S_STRINGBASE+31)
#define IDS_S_32                    (IDS_S_STRINGBASE+32)
#define IDS_S_33                    (IDS_S_STRINGBASE+33)

#define IDS_S_34                    (IDS_S_STRINGBASE+34)
                                                       
#define IDS_S_35                    (IDS_S_STRINGBASE+35)

#define IDS_S_36                    (IDS_S_STRINGBASE+36)
#define IDS_S_37                    (IDS_S_STRINGBASE+37)

#define IDS_S_38                    (IDS_S_STRINGBASE+38)
#define IDS_S_39                    (IDS_S_STRINGBASE+39)
#define IDS_S_40                    (IDS_S_STRINGBASE+40)
#define IDS_S_41                    (IDS_S_STRINGBASE+41)

#define IDS_S_42                    (IDS_S_STRINGBASE+42)
#define IDS_S_43                    (IDS_S_STRINGBASE+43)

#define IDS_S_44                    (IDS_S_STRINGBASE+44)
#define IDS_S_45                    (IDS_S_STRINGBASE+45)
#define IDS_S_46                    (IDS_S_STRINGBASE+46)
#define IDS_S_47                    (IDS_S_STRINGBASE+47)
#define IDS_S_48                    (IDS_S_STRINGBASE+48)

#define IDS_S_49                    (IDS_S_STRINGBASE+49)

////////////
#define IDS_E_STRINGBASE            (IDS_S_STRINGBASE+49)

#define IDS_E_1                     (IDS_E_STRINGBASE+1)
#define IDS_E_2                     (IDS_E_STRINGBASE+2)
#define IDS_E_3                     (IDS_E_STRINGBASE+3)
#define IDS_E_4                     (IDS_E_STRINGBASE+4)
#define IDS_E_5                     (IDS_E_STRINGBASE+5)
#define IDS_E_6                     (IDS_E_STRINGBASE+6)
#define IDS_E_7                     (IDS_E_STRINGBASE+7)
#define IDS_E_8                     (IDS_E_STRINGBASE+8)
#define IDS_E_9                     (IDS_E_STRINGBASE+9)
                                                       
#define IDS_E_10                    (IDS_E_STRINGBASE+10)
#define IDS_E_11                    (IDS_E_STRINGBASE+11)

#define IDS_E_12                    (IDS_E_STRINGBASE+12)

#define IDS_E_13                    (IDS_E_STRINGBASE+13)

#define IDS_E_14                    (IDS_E_STRINGBASE+14)

#define IDS_E_15                    (IDS_E_STRINGBASE+15)
#define IDS_E_16                    (IDS_E_STRINGBASE+16)

#define IDS_E_17                    (IDS_E_STRINGBASE+17)

#define IDS_E_18                    (IDS_E_STRINGBASE+18)

////////////
#define IDS_M_STRINGBASE            (IDS_E_STRINGBASE+18)

#define IDS_M_1                     (IDS_M_STRINGBASE+1)
#define IDS_M_2                     (IDS_M_STRINGBASE+2)
#define IDS_M_3                     (IDS_M_STRINGBASE+3)
#define IDS_M_4                     (IDS_M_STRINGBASE+4)
#define IDS_M_5                     (IDS_M_STRINGBASE+5)
#define IDS_M_6                     (IDS_M_STRINGBASE+6)
#define IDS_M_7                     (IDS_M_STRINGBASE+7)
#define IDS_M_8                     (IDS_M_STRINGBASE+8)

////////////
#define IDS_L_STRINGBASE            (IDS_M_STRINGBASE+8)

#define IDS_L_1                     (IDS_L_STRINGBASE+1)
#define IDS_L_2                     (IDS_L_STRINGBASE+2)
#define IDS_L_3                     (IDS_L_STRINGBASE+3)

#define IDS_L_4                     (IDS_L_STRINGBASE+4)
#define IDS_L_5                     (IDS_L_STRINGBASE+5)
#define IDS_L_6                     (IDS_L_STRINGBASE+6)

#define IDS_L_7                     (IDS_L_STRINGBASE+7)
#define IDS_L_8                     (IDS_L_STRINGBASE+8)
#define IDS_L_9                     (IDS_L_STRINGBASE+9)
#define IDS_L_10                    (IDS_L_STRINGBASE+10)

#define IDS_L_11                    (IDS_L_STRINGBASE+11)
#define IDS_L_12                    (IDS_L_STRINGBASE+12)
#define IDS_L_13                    (IDS_L_STRINGBASE+13)
#define IDS_L_14                    (IDS_L_STRINGBASE+14)
#define IDS_L_15                    (IDS_L_STRINGBASE+15)
#define IDS_L_16                    (IDS_L_STRINGBASE+16)

#define IDS_L_17                    (IDS_L_STRINGBASE+17)
#define IDS_L_18                    (IDS_L_STRINGBASE+18)
#define IDS_L_19                    (IDS_L_STRINGBASE+19)
#define IDS_L_20                    (IDS_L_STRINGBASE+20)

#define IDS_L_21                    (IDS_L_STRINGBASE+21)
#define IDS_L_22                    (IDS_L_STRINGBASE+22)

#define IDS_L_23                    (IDS_L_STRINGBASE+23)
#define IDS_L_24                    (IDS_L_STRINGBASE+24)
#define IDS_L_25                    (IDS_L_STRINGBASE+25)
#define IDS_L_26                    (IDS_L_STRINGBASE+26)
#define IDS_L_27                    (IDS_L_STRINGBASE+27)
#define IDS_L_28                    (IDS_L_STRINGBASE+28)
#define IDS_L_29                    (IDS_L_STRINGBASE+29)
#define IDS_L_30                    (IDS_L_STRINGBASE+30)
#define IDS_L_31                    (IDS_L_STRINGBASE+31)
#define IDS_L_32                    (IDS_L_STRINGBASE+32)
#define IDS_L_33                    (IDS_L_STRINGBASE+33)
#define IDS_L_34                    (IDS_L_STRINGBASE+34)
#define IDS_L_35                    (IDS_L_STRINGBASE+35)
#define IDS_L_36                    (IDS_L_STRINGBASE+36)
#define IDS_L_37                    (IDS_L_STRINGBASE+37)
#define IDS_L_38                    (IDS_L_STRINGBASE+38)
#define IDS_L_39                    (IDS_L_STRINGBASE+39)
#define IDS_L_40                    (IDS_L_STRINGBASE+40)
#define IDS_L_41                    (IDS_L_STRINGBASE+41)
#define IDS_L_42                    (IDS_L_STRINGBASE+42)
#define IDS_L_43                    (IDS_L_STRINGBASE+43)
#define IDS_L_44                    (IDS_L_STRINGBASE+44)
#define IDS_L_45                    (IDS_L_STRINGBASE+45)
#define IDS_L_46                    (IDS_L_STRINGBASE+46)
#define IDS_L_47                    (IDS_L_STRINGBASE+47)
#define IDS_L_48                    (IDS_L_STRINGBASE+48)
#define IDS_L_49                    (IDS_L_STRINGBASE+49)

#define IDS_L_50                    (IDS_L_STRINGBASE+50)
#define IDS_L_51                    (IDS_L_STRINGBASE+51)

#define IDS_L_52                    (IDS_L_STRINGBASE+52)
#define IDS_L_53                    (IDS_L_STRINGBASE+53)
#define IDS_L_54                    (IDS_L_STRINGBASE+54)
#define IDS_L_55                    (IDS_L_STRINGBASE+55)

#define IDS_L_56                    (IDS_L_STRINGBASE+56)
#define IDS_L_57                    (IDS_L_STRINGBASE+57)
#define IDS_L_58                    (IDS_L_STRINGBASE+58)
#define IDS_L_59                    (IDS_L_STRINGBASE+59)
#define IDS_L_60                    (IDS_L_STRINGBASE+60)
#define IDS_L_61                    (IDS_L_STRINGBASE+61)
#define IDS_L_62                    (IDS_L_STRINGBASE+62)
#define IDS_L_63                    (IDS_L_STRINGBASE+63)
#define IDS_L_64                    (IDS_L_STRINGBASE+64)
#define IDS_L_65                    (IDS_L_STRINGBASE+65)
#define IDS_L_66                    (IDS_L_STRINGBASE+66)
#define IDS_L_67                    (IDS_L_STRINGBASE+67)
#define IDS_L_68                    (IDS_L_STRINGBASE+68)
#define IDS_L_69                    (IDS_L_STRINGBASE+69)
#define IDS_L_70                    (IDS_L_STRINGBASE+70)
#define IDS_L_71                    (IDS_L_STRINGBASE+71)
#define IDS_L_72                    (IDS_L_STRINGBASE+72)
#define IDS_L_73                    (IDS_L_STRINGBASE+73)
#define IDS_L_74                    (IDS_L_STRINGBASE+74)
#define IDS_L_75                    (IDS_L_STRINGBASE+75)

#define IDS_L_76                    (IDS_L_STRINGBASE+76)
#define IDS_L_77                    (IDS_L_STRINGBASE+77)

#define IDS_L_78                    (IDS_L_STRINGBASE+78)
#define IDS_L_79                    (IDS_L_STRINGBASE+79)
#define IDS_L_80                    (IDS_L_STRINGBASE+80)
#define IDS_L_81                    (IDS_L_STRINGBASE+81)
#define IDS_L_82                    (IDS_L_STRINGBASE+82)
#define IDS_L_83                    (IDS_L_STRINGBASE+83)
#define IDS_L_84                    (IDS_L_STRINGBASE+84)
#define IDS_L_85                    (IDS_L_STRINGBASE+85)
#define IDS_L_86                    (IDS_L_STRINGBASE+86)
#define IDS_L_87                    (IDS_L_STRINGBASE+87)
#define IDS_L_88                    (IDS_L_STRINGBASE+88)
#define IDS_L_89                    (IDS_L_STRINGBASE+89)
#define IDS_L_90                    (IDS_L_STRINGBASE+90)
#define IDS_L_91                    (IDS_L_STRINGBASE+91)
#define IDS_L_92                    (IDS_L_STRINGBASE+92)
#define IDS_L_93                    (IDS_L_STRINGBASE+93)

#define IDS_L_94                    (IDS_L_STRINGBASE+94)
#define IDS_L_95                    (IDS_L_STRINGBASE+95)
#define IDS_L_96                    (IDS_L_STRINGBASE+96)

#define IDS_L_97                    (IDS_L_STRINGBASE+97)
#define IDS_L_98                    (IDS_L_STRINGBASE+98)
#define IDS_L_99                    (IDS_L_STRINGBASE+99)
#define IDS_L_100                   (IDS_L_STRINGBASE+100)

#define IDS_L_101                   (IDS_L_STRINGBASE+101)
#define IDS_L_102                   (IDS_L_STRINGBASE+102)
#define IDS_L_103                   (IDS_L_STRINGBASE+103)

#define IDS_L_104                   (IDS_L_STRINGBASE+104)

#define IDS_L_105                   (IDS_L_STRINGBASE+105)
#define IDS_L_106                   (IDS_L_STRINGBASE+106)
#define IDS_L_107                   (IDS_L_STRINGBASE+107)
#define IDS_L_108                   (IDS_L_STRINGBASE+108)
#define IDS_L_109                   (IDS_L_STRINGBASE+109)
#define IDS_L_110                   (IDS_L_STRINGBASE+110)
#define IDS_L_111                   (IDS_L_STRINGBASE+111)
#define IDS_L_112                   (IDS_L_STRINGBASE+112)
#define IDS_L_113                   (IDS_L_STRINGBASE+113)
#define IDS_L_114                   (IDS_L_STRINGBASE+114)
#define IDS_L_115                   (IDS_L_STRINGBASE+115)
#define IDS_L_116                   (IDS_L_STRINGBASE+116)
#define IDS_L_117                   (IDS_L_STRINGBASE+117)
#define IDS_L_118                   (IDS_L_STRINGBASE+118)
#define IDS_L_119                   (IDS_L_STRINGBASE+119)
#define IDS_L_120                   (IDS_L_STRINGBASE+120)
#define IDS_L_121                   (IDS_L_STRINGBASE+121)
#define IDS_L_122                   (IDS_L_STRINGBASE+122)
#define IDS_L_123                   (IDS_L_STRINGBASE+123)
#define IDS_L_124                   (IDS_L_STRINGBASE+124)

#define IDS_L_125                   (IDS_L_STRINGBASE+125)

#define IDS_L_126                   (IDS_L_STRINGBASE+126)
#define IDS_L_127                   (IDS_L_STRINGBASE+127)
#define IDS_L_128                   (IDS_L_STRINGBASE+128)
#define IDS_L_129                   (IDS_L_STRINGBASE+129)
#define IDS_L_130                   (IDS_L_STRINGBASE+130)
#define IDS_L_131                   (IDS_L_STRINGBASE+131)
#define IDS_L_132                   (IDS_L_STRINGBASE+132)
#define IDS_L_133                   (IDS_L_STRINGBASE+133)
#define IDS_L_134                   (IDS_L_STRINGBASE+134)
#define IDS_L_135                   (IDS_L_STRINGBASE+135)

#define IDS_L_136                   (IDS_L_STRINGBASE+136)
#define IDS_L_137                   (IDS_L_STRINGBASE+137)
#define IDS_L_138                   (IDS_L_STRINGBASE+138)
#define IDS_L_139                   (IDS_L_STRINGBASE+139)
#define IDS_L_140                   (IDS_L_STRINGBASE+140)
#define IDS_L_141                   (IDS_L_STRINGBASE+141)
#define IDS_L_142                   (IDS_L_STRINGBASE+142)
#define IDS_L_143                   (IDS_L_STRINGBASE+143)
#define IDS_L_144                   (IDS_L_STRINGBASE+144)
#define IDS_L_145                   (IDS_L_STRINGBASE+145)
#define IDS_L_146                   (IDS_L_STRINGBASE+146)
#define IDS_L_147                   (IDS_L_STRINGBASE+147)
#define IDS_L_148                   (IDS_L_STRINGBASE+148)
#define IDS_L_149                   (IDS_L_STRINGBASE+149)
#define IDS_L_150                   (IDS_L_STRINGBASE+150)
#define IDS_L_151                   (IDS_L_STRINGBASE+151)
#define IDS_L_152                   (IDS_L_STRINGBASE+152)
#define IDS_L_153                   (IDS_L_STRINGBASE+153)
#define IDS_L_154                   (IDS_L_STRINGBASE+154)

#define IDS_L_155                   (IDS_L_STRINGBASE+155)
#define IDS_L_156                   (IDS_L_STRINGBASE+156)

#define IDS_L_157                   (IDS_L_STRINGBASE+157)
#define IDS_L_158                   (IDS_L_STRINGBASE+158)
#define IDS_L_159                   (IDS_L_STRINGBASE+159)

#define IDS_L_160                   (IDS_L_STRINGBASE+160)
#define IDS_L_161                   (IDS_L_STRINGBASE+161)

#define IDS_L_162                   (IDS_L_STRINGBASE+162)
#define IDS_L_163                   (IDS_L_STRINGBASE+163)
#define IDS_L_164                   (IDS_L_STRINGBASE+164)

#define IDS_L_165                   (IDS_L_STRINGBASE+165)
#define IDS_L_166                   (IDS_L_STRINGBASE+166)
#define IDS_L_167                   (IDS_L_STRINGBASE+167)
#define IDS_L_168                   (IDS_L_STRINGBASE+168)

#define IDS_L_169                   (IDS_L_STRINGBASE+169)
#define IDS_L_170                   (IDS_L_STRINGBASE+170)
#define IDS_L_171                   (IDS_L_STRINGBASE+171)

#define IDS_L_172                   (IDS_L_STRINGBASE+172)
#define IDS_L_173                   (IDS_L_STRINGBASE+173)
#define IDS_L_174                   (IDS_L_STRINGBASE+174)
#define IDS_L_175                   (IDS_L_STRINGBASE+175)
#define IDS_L_176                   (IDS_L_STRINGBASE+176)
#define IDS_L_177                   (IDS_L_STRINGBASE+177)

#define IDS_L_178                   (IDS_L_STRINGBASE+178)
#define IDS_L_179                   (IDS_L_STRINGBASE+179)

#define IDS_L_180                   (IDS_L_STRINGBASE+180)

#define IDS_L_181                   (IDS_L_STRINGBASE+181)

#define IDS_L_182                   (IDS_L_STRINGBASE+182)
#define IDS_L_183                   (IDS_L_STRINGBASE+183)
#define IDS_L_184                   (IDS_L_STRINGBASE+184)
#define IDS_L_185                   (IDS_L_STRINGBASE+185)

#define IDS_L_186                   (IDS_L_STRINGBASE+186)
#define IDS_L_187                   (IDS_L_STRINGBASE+187)
#define IDS_L_188                   (IDS_L_STRINGBASE+188)

#define IDS_L_189                   (IDS_L_STRINGBASE+189)
#define IDS_L_190                   (IDS_L_STRINGBASE+190)
#define IDS_L_191                   (IDS_L_STRINGBASE+191)
#define IDS_L_192                   (IDS_L_STRINGBASE+192)
#define IDS_L_193                   (IDS_L_STRINGBASE+193)

#define IDS_L_194                   (IDS_L_STRINGBASE+194)
#define IDS_L_195                   (IDS_L_STRINGBASE+195)
#define IDS_L_196                   (IDS_L_STRINGBASE+196)
#define IDS_L_197                   (IDS_L_STRINGBASE+197)

#define IDS_L_198                   (IDS_L_STRINGBASE+198)
#define IDS_L_199                   (IDS_L_STRINGBASE+199)

#define IDS_L_200                   (IDS_L_STRINGBASE+200)
#define IDS_L_201                   (IDS_L_STRINGBASE+201)

#define IDS_L_202                   (IDS_L_STRINGBASE+202)

#define IDS_L_203                   (IDS_L_STRINGBASE+203)
#define IDS_L_204                   (IDS_L_STRINGBASE+204)
#define IDS_L_205                   (IDS_L_STRINGBASE+205)
#define IDS_L_206                   (IDS_L_STRINGBASE+206)

#define IDS_L_207                   (IDS_L_STRINGBASE+207)
#define IDS_L_208                   (IDS_L_STRINGBASE+208)

#define IDS_L_209                   (IDS_L_STRINGBASE+209)
#define IDS_L_210                   (IDS_L_STRINGBASE+210)
#define IDS_L_211                   (IDS_L_STRINGBASE+211)

#define IDS_L_212                   (IDS_L_STRINGBASE+212)

#define IDS_L_213                   (IDS_L_STRINGBASE+213)
#define IDS_L_214                   (IDS_L_STRINGBASE+214)

#define IDS_L_215                   (IDS_L_STRINGBASE+215)
#define IDS_L_216                   (IDS_L_STRINGBASE+216)

#define IDS_L_217                   (IDS_L_STRINGBASE+217)

#define IDS_L_218                   (IDS_L_STRINGBASE+218)
#define IDS_L_219                   (IDS_L_STRINGBASE+219)

#define STRING_TABLE_END            (IDS_L_STRINGBASE+219)

#define TOTAL_STRINGS               (STRING_TABLE_END - IDS_STRINGBASE)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\servlist.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _HSERVLIST_
#define _HSERVLIST_

#ifdef __cplusplus
extern "C"{
#endif

/*+-------------------------------------------------------------------------+
  | User List                                                               |
  +-------------------------------------------------------------------------+*/
typedef struct _USER_BUFFER {
   TCHAR Name[MAX_USER_NAME_LEN + 1];
   TCHAR NewName[MAX_USER_NAME_LEN + MAX_UCONST_LEN];
   TCHAR Password[MAX_PW_LEN + 1];

   USHORT err;
   BOOL Overwrite;
   BOOL IsNewName;
} USER_BUFFER;
  
typedef struct _USER_LIST {
   ULONG Count;
   USER_BUFFER UserBuffer[];
} USER_LIST;


/*+-------------------------------------------------------------------------+
  | Group List                                                              |
  +-------------------------------------------------------------------------+*/
typedef struct _GROUP_BUFFER {
   TCHAR Name[MAX_GROUP_NAME_LEN + 1];
   TCHAR NewName[MAX_GROUP_NAME_LEN + MAX_UCONST_LEN];
   
   USHORT err;
   BOOL IsNewName;
} GROUP_BUFFER;

typedef struct _GROUP_LIST {
   ULONG Count;
   GROUP_BUFFER GroupBuffer[];
} GROUP_LIST;


/*+-------------------------------------------------------------------------+
  | Drive Lists                                                             |
  +-------------------------------------------------------------------------+*/
  
// Drive type of 1 is okay to set perms on, all others are not...
#define DRIVE_TYPE_NTFS 1

// Drive list is only kept for destination servers and is mainly used to track
// remaining free space on the drive.
typedef struct _DRIVE_BUFFER {
   UINT Type;
   TCHAR Drive[2];
   TCHAR DriveType[20];
   TCHAR Name[20];
   ULONG TotalSpace;
   ULONG FreeSpace;           // Free space before stuff we are transfering
   ULONG AllocSpace;          // Approx size of stuff we are transferring
} DRIVE_BUFFER;

typedef struct _DRIVE_LIST {
   ULONG Count;
   DRIVE_BUFFER DList[];
} DRIVE_LIST;


// Stores a server share and a link to the structures describing the files 
// to convert
typedef struct _SHARE_BUFFER {
   BOOL VFlag;             // to distinguish between virtual and normal share
   
   USHORT Index;
   
   TCHAR Name[MAX_SHARE_NAME_LEN + 1];
   BOOL Convert;
   BOOL HiddenFiles;
   BOOL SystemFiles;
   BOOL ToFat;             // Flag if user says OK to go to a FAT drive
   DIR_BUFFER *Root;
   DRIVE_BUFFER *Drive;    // Used only for dest shares - for free space calcs.
   ULONG Size;             // Used for source shares - approx allocated space
   TCHAR Path[MAX_PATH + 1];
   TCHAR SubDir[MAX_PATH + 1];  // for source - subdir to copy to
   
   // Following only used for source shares - describes destination share.
   // Virtual tells whether data pointed to is a SHARE_BUFFER or 
   // VIRTUAL_SHARE_BUFFER.  (Note:  Use struct SHARE_BUFFER even though
   // it may be VIRTUAL to simplify logic if it is a SHARE_BUFFER).
   BOOL Virtual;
   struct _SHARE_BUFFER *DestShare;
} SHARE_BUFFER;

// List of all server shares and files under them to convert.
typedef struct _SHARE_LIST {
   ULONG Count;
   ULONG ConvertCount;
   BOOL Fixup;
   SHARE_BUFFER SList[];
} SHARE_LIST;


// Virtual shares are ones that we need to create - these are only for 
// destination shares as all source shares must obviously already exist.
// This must be a linked list as it can be dynamically added to / deleted from.
typedef struct _VIRTUAL_SHARE_BUFFER {
   BOOL VFlag;
   
   struct _VIRTUAL_SHARE_BUFFER *next;
   struct _VIRTUAL_SHARE_BUFFER *prev;

   USHORT Index;   
   
   LPTSTR Name;
   LONG UseCount;       // How many things going to it (so can del if unused)
   TCHAR Path[MAX_PATH + 1];
   DRIVE_BUFFER *Drive;
} VIRTUAL_SHARE_BUFFER;


// Keep the domain buffers for when servers are part of a domain to point
// to the PDC and also when you choose a trusted domain.  It contains an
// abreviated form of a server buffer for the PDC info.
typedef struct _DOMAIN_BUFFER {
   struct _DOMAIN_BUFFER *next;
   struct _DOMAIN_BUFFER *prev;

   USHORT Index;   
   
   LPTSTR Name;
   
   // PDC Info
   LPTSTR PDCName;
   DWORD Type;
   DWORD VerMaj;
   DWORD VerMin;
   LONG UseCount;
} DOMAIN_BUFFER;


#define SERV_TYPE_NETWARE 1
#define SERV_TYPE_NT 2
/*+-------------------------------------------------------------------------+
  | Server Lists
  |
  | The source and destination SERVER_BUFFER lists are kept independantly 
  | of the conversion list as multiple conversions can be done to one server.  
  | This allows easier tracking of virtual shares that need to be created and 
  | total free space on the server after all of the conversions are counted in
  | (to see if there is enough free space to transfer files).
  |
  | Source server has no use count as a source server can only be included once
  | in a conversion.  Also no drive list as we can't get the info (on NetWare
  | at least) and it isn't needed.
  |
  +-------------------------------------------------------------------------+*/
typedef struct _SOURCE_SERVER_BUFFER {
   struct _SOURCE_SERVER_BUFFER *next;
   struct _SOURCE_SERVER_BUFFER *prev;

   USHORT Index;
      
   UINT Type;                    // Type of server (NetWare only for now)
   BYTE VerMaj;
   BYTE VerMin;
   LPTSTR LName;
   LPTSTR Name;
   SHARE_LIST *ShareList;
} SOURCE_SERVER_BUFFER;


// Destination server must contain useage count as several source servers can 
// be merged into it.  If UseCount goes to 0, then we can purge this record 
// out as it is no longer needed.
typedef struct _DEST_SERVER_BUFFER {
   struct _DEST_SERVER_BUFFER *next;
   struct _DEST_SERVER_BUFFER *prev;

   USHORT Index;
      
   DWORD Type;
   DWORD VerMaj;
   DWORD VerMin;
   LPTSTR LName;        // Name with double whack pre-pended
   LPTSTR Name;
   SHARE_LIST *ShareList;

   ULONG NumVShares;
   VIRTUAL_SHARE_BUFFER *VShareStart;
   VIRTUAL_SHARE_BUFFER *VShareEnd;
   ULONG UseCount;
   BOOL IsNTAS;
   BOOL IsFPNW;
   BOOL InDomain;
   DOMAIN_BUFFER *Domain;
   DRIVE_LIST *DriveList;
} DEST_SERVER_BUFFER;


/*+-------------------------------------------------------------------------+
  | Convert List
  |
  |   This is the main data structure that everything links off of.  The
  |   ConvertOptions is a void type to allow it to be based on the type
  |   of server being converted.  This allows the program to be (relatively)
  |   easily modified to work with other source server types (like
  |   LAN Server).
  |
  |   The Server list constructs (SOURCE_SERVER_BUFFER and
  |   DEST_SERVER_BUFFER) are kept in addition to this, but this contains
  |   some links to those structures.
  |
  +-------------------------------------------------------------------------+*/
typedef struct _CONVERT_LIST {
   struct _CONVERT_LIST *next;
   struct _CONVERT_LIST *prev;
   SOURCE_SERVER_BUFFER *SourceServ;
   DEST_SERVER_BUFFER *FileServ;

   void *ConvertOptions;
   void *FileOptions;
} CONVERT_LIST;


/*+-------------------------------------------------------------------------+
  | Function Prototypes                                                     |
  +-------------------------------------------------------------------------+*/
void TreeSave(HANDLE hFile, DIR_BUFFER *Dir);
void TreeLoad(HANDLE hFile, DIR_BUFFER **pDir);

int __cdecl UserListCompare(const void *arg1, const void *arg2);

void ShareListDelete(SHARE_LIST *ShareList);
void DestShareListFixup(DEST_SERVER_BUFFER *DServ);
void ShareListSave(HANDLE hFile, SHARE_LIST *ShareList);
void ShareListLoad(HANDLE hFile, SHARE_LIST **lpShareList);

SOURCE_SERVER_BUFFER *SServListAdd(LPTSTR ServerName);
void SServListDelete(SOURCE_SERVER_BUFFER *tmpPtr);
void SServListDeleteAll();
SOURCE_SERVER_BUFFER *SServListFind(LPTSTR ServerName);
void SServListIndex();
void SServListIndexMapGet(DWORD_PTR **pMap);
void SServListFixup();
void SServListSave(HANDLE hFile);
void SServListLoad(HANDLE hFile);

DEST_SERVER_BUFFER *DServListAdd(LPTSTR ServerName);
void DServListDelete(DEST_SERVER_BUFFER *tmpPtr);
void DServListDeleteAll();
DEST_SERVER_BUFFER *DServListFind(LPTSTR ServerName);
void DServListIndex();
void DServListIndexMapGet(DWORD_PTR **pMap);
void DServListFixup();
void DServListSave(HANDLE hFile);
void DServListLoad(HANDLE hFile);
void DServListSpaceFree();

VIRTUAL_SHARE_BUFFER *VShareListAdd(DEST_SERVER_BUFFER *DServ, LPTSTR ShareName, LPTSTR Path);
void VShareListDelete(DEST_SERVER_BUFFER *DServ, VIRTUAL_SHARE_BUFFER *tmpPtr);
void VShareListDeleteAll(DEST_SERVER_BUFFER *DServ);
void VShareListIndex(DEST_SERVER_BUFFER *DServ) ;
void VShareListIndexMapGet(DEST_SERVER_BUFFER *DServ, DWORD_PTR **pMap);
void VShareListSave(HANDLE hFile, DEST_SERVER_BUFFER *DServ);
void VShareListLoad(HANDLE hFile, DEST_SERVER_BUFFER *DServ);

DOMAIN_BUFFER *DomainListAdd(LPTSTR DomainName, LPTSTR PDCName);
void DomainListDelete(DOMAIN_BUFFER *tmpPtr);
void DomainListDeleteAll();
DOMAIN_BUFFER *DomainListFind(LPTSTR DomainName);
void DomainListIndex();
void DomainListIndexMapGet(DWORD_PTR **pMap);
void DomainListSave(HANDLE hFile);
void DomainListLoad(HANDLE hFile);

CONVERT_LIST *ConvertListAdd(SOURCE_SERVER_BUFFER *SourceServer, DEST_SERVER_BUFFER *DestServer);
void ConvertListDelete(CONVERT_LIST *tmpPtr);
void ConvertListDeleteAll();
void ConvertListSaveAll(HANDLE hFile);
void ConvertListLoadAll(HANDLE hFile);
void ConvertListFixup(HWND hWnd);
void ConvertListLog();

LPTSTR UserServerNameGet(DEST_SERVER_BUFFER *DServ, void *ConvOpt);

// Internal Data Structures
extern UINT NumServerPairs;
extern CONVERT_LIST *ConvertListStart;
extern CONVERT_LIST *ConvertListEnd;
extern CONVERT_LIST ConvertListDefault;
extern CONVERT_LIST *CurrentConvertList;

extern SOURCE_SERVER_BUFFER *SServListStart;
extern SOURCE_SERVER_BUFFER *SServListEnd;
extern SOURCE_SERVER_BUFFER *SServListCurrent;
extern DEST_SERVER_BUFFER *DServListStart;
extern DEST_SERVER_BUFFER *DServListEnd;
extern DEST_SERVER_BUFFER *DServListCurrent;
extern DOMAIN_BUFFER *DomainListStart;
extern DOMAIN_BUFFER *DomainListEnd;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\statbox.c ===
/*
  +-------------------------------------------------------------------------+
  |           Status Dialog box routines - Used during Conversion           |
  +-------------------------------------------------------------------------+
  |                     (c) Copyright 1993-1994                             |
  |                          Microsoft Corp.                                |
  |                        All rights reserved                              |
  |                                                                         |
  | Program               : [StatBox.c]                                     |
  | Programmer            : Arthur Hanson                                   |
  | Original Program Date : [Feb 08, 1994]                                  |
  | Last Update           : [Feb 08, 1994]                                  |
  |                                                                         |
  | Version:  1.00                                                          |
  |                                                                         |
  | Description:                                                            |
  |                                                                         |
  | History:                                                                |
  |   arth  Feb 08, 1994    1.00    Original Version.                       |
  |                                                                         |
  +-------------------------------------------------------------------------+
*/


#include "globals.h"
#include "convapi.h"

static TCHAR tmpStr[1024];
static TCHAR PanelTitle[80];
static HANDLE hStatus = NULL;
static HANDLE hPanel = NULL;
static BOOL DoCancel = FALSE;

/*+-------------------------------------------------------------------------+
  | Routines for status dialog put up during conversion.                    |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | DrainPump()
  +-------------------------------------------------------------------------+*/
void DrainPump() {
   MSG msg;

   while (PeekMessage(&msg, hStatus, 0, 0xfff, PM_REMOVE)) {
       if ((IsDialogMessage(hStatus, &msg) == FALSE) &&
           (IsDialogMessage(hPanel, &msg) == FALSE)) {
           TranslateMessage(&msg);
           DispatchMessage(&msg);
       }
   }

} // DrainPump


/*+-------------------------------------------------------------------------+
  | Status_CurConv()
  +-------------------------------------------------------------------------+*/
// Current server pair being converted
void Status_CurConv(UINT Num) {
   wsprintf(tmpStr, TEXT("%5u"), Num);
   SendDlgItemMessage(hStatus, IDC_S_CUR_CONV, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();
} // Status_CurConv


/*+-------------------------------------------------------------------------+
  | Status_TotConv()
  +-------------------------------------------------------------------------+*/
// Total number of server pairs to convert
void Status_TotConv(UINT Num) {
   wsprintf(tmpStr, TEXT("%5u"), Num);
   SendDlgItemMessage(hStatus, IDC_S_TOT_CONV, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();
} // Status_TotConv


/*+-------------------------------------------------------------------------+
  | Status_SrcServ()
  +-------------------------------------------------------------------------+*/
// Current source server of server pair being converted
void Status_SrcServ(LPTSTR Server) {
   wsprintf(tmpStr, TEXT("%-15s"), Server);
   SendDlgItemMessage(hStatus, IDC_S_SRCSERV, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();
} // Status_SrcServ


/*+-------------------------------------------------------------------------+
  | Status_DestServ()
  +-------------------------------------------------------------------------+*/
// Current destination server of server pair being converted
void Status_DestServ(LPTSTR Server) {
   wsprintf(tmpStr, TEXT("%-15s"), Server);
   SendDlgItemMessage(hStatus, IDC_S_DESTSERV, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();
} // Status_DestServ


/*+-------------------------------------------------------------------------+
  | Status_ConvTxt()
  +-------------------------------------------------------------------------+*/
// Text describing what is being converted (Groups, Users Files)
void Status_ConvTxt(LPTSTR Text) {
   wsprintf(tmpStr, TEXT("%-20s"), Text);
   SendDlgItemMessage(hStatus, IDC_S_CONVTXT, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();
} // Status_ConvTxt


/*+-------------------------------------------------------------------------+
  | Status_CurNum()
  +-------------------------------------------------------------------------+*/
// Current item number being converted (current group # or User # or file #)...
void Status_CurNum(UINT Num) {
   wsprintf(tmpStr, TEXT("%7s"), lToStr(Num));
   SendDlgItemMessage(hStatus, IDC_S_CUR_NUM, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();
} // Status_CurNum


/*+-------------------------------------------------------------------------+
  | Status_CurTot()
  +-------------------------------------------------------------------------+*/
// Total items in set being converted (user, group, files...)
void Status_CurTot(UINT Num) {
   wsprintf(tmpStr, TEXT("%7s"), lToStr(Num));
   SendDlgItemMessage(hStatus, IDC_S_CUR_TOT, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();
} // Status_CurTot


/*+-------------------------------------------------------------------------+
  | Status_ItemLabel()
  +-------------------------------------------------------------------------+*/
// Label for set being converted ("Group:", "User:")
void Status_ItemLabel(LPTSTR Text, ...) {
   va_list marker;

   va_start(marker, Text);

   wvsprintf(tmpStr, Text, marker);
   SendDlgItemMessage(hStatus, IDC_S_ITEMLABEL, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();

   va_end(marker);

} // Status_ItemLabel


/*+-------------------------------------------------------------------------+
  | Status_Item()
  +-------------------------------------------------------------------------+*/
// Name of current thing being converted (actual user or group name)
void Status_Item(LPTSTR Text) {
   wsprintf(tmpStr, TEXT("%-15s"), Text);
   SendDlgItemMessage(hStatus, IDC_S_STATUSITEM, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();
} // Status_Item


/*+-------------------------------------------------------------------------+
  | Status_TotComplete()
  +-------------------------------------------------------------------------+*/
// Total #server pairs converted so far
void Status_TotComplete(UINT Num) {
   wsprintf(tmpStr, TEXT("%7s"), lToStr(Num));
   SendDlgItemMessage(hStatus, IDC_S_TOT_COMP, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();
} // Status_TotComplete


/*+-------------------------------------------------------------------------+
  | Status_TotGroups()
  +-------------------------------------------------------------------------+*/
void Status_TotGroups(UINT Num) {
   wsprintf(tmpStr, TEXT("%7s"), lToStr(Num));
   SendDlgItemMessage(hStatus, IDC_S_TOT_GROUPS, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();
} // Status_TotGroup


/*+-------------------------------------------------------------------------+
  | Status_TotUsers()
  +-------------------------------------------------------------------------+*/
void Status_TotUsers(UINT Num) {
   wsprintf(tmpStr, TEXT("%7s"), lToStr(Num));
   SendDlgItemMessage(hStatus, IDC_S_TOT_USERS, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();
} // Status_TotUsers


/*+-------------------------------------------------------------------------+
  | Status_TotFiles()
  +-------------------------------------------------------------------------+*/
void Status_TotFiles(UINT Num) {
   wsprintf(tmpStr, TEXT("%7s"), lToStr(Num));
   SendDlgItemMessage(hStatus, IDC_S_TOT_FILES, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();
} // Status_TotFiles


/*+-------------------------------------------------------------------------+
  | Status_TotErrors()
  +-------------------------------------------------------------------------+*/
void Status_TotErrors(UINT Num) {
   wsprintf(tmpStr, TEXT("%7s"), lToStr(Num));
   SendDlgItemMessage(hStatus, IDC_S_TOT_ERRORS, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();
} // Status_TotErrors


/*+-------------------------------------------------------------------------+
  | Status_BytesTxt()
  +-------------------------------------------------------------------------+*/
void Status_BytesTxt(LPTSTR Text) {
   wsprintf(tmpStr, TEXT("%-15s"), Text);
   SendDlgItemMessage(hStatus, IDC_PANEL1, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();
} // Status_BytesTxt


/*+-------------------------------------------------------------------------+
  | Status_Bytes()
  +-------------------------------------------------------------------------+*/
void Status_Bytes(LPTSTR Text) {
   wsprintf(tmpStr, TEXT("%s"), Text);
   SendDlgItemMessage(hStatus, IDC_PANEL2, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();
} // Status_Bytes


/*+-------------------------------------------------------------------------+
  | Status_TotBytes()
  +-------------------------------------------------------------------------+*/
void Status_TotBytes(LPTSTR Text) {
   wsprintf(tmpStr, TEXT("%s"), Text);
   SendDlgItemMessage(hStatus, IDC_PANEL3, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();
} // Status_TotBytes


/*+-------------------------------------------------------------------------+
  | Status_BytesSep()
  +-------------------------------------------------------------------------+*/
void Status_BytesSep(LPTSTR Text) {
   wsprintf(tmpStr, TEXT("%s"), Text);
   SendDlgItemMessage(hStatus, IDC_PANEL4, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hStatus, WM_PAINT, 0, 0L);
   DrainPump();
} // Status_BytesSep


/*+-------------------------------------------------------------------------+
  | DlgStatus()
  +-------------------------------------------------------------------------+*/
LRESULT CALLBACK DlgStatus(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
   RECT rc;

   switch (message) {
      case WM_INITDIALOG:
         // Center the dialog over the application window
         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));
         return (TRUE);

      case WM_SETFOCUS:
         GetWindowRect(hDlg, &rc);
         InvalidateRect(hDlg, &rc, FALSE);
         SendMessage(hStatus, WM_PAINT, 0, 0L);
         break;
   }

   return (FALSE); // Didn't process the message

   lParam;
} // DlgStatus



/*+-------------------------------------------------------------------------+
  | DoStatusDlg()
  +-------------------------------------------------------------------------+*/
void DoStatusDlg(HWND hDlg) {
   DLGPROC lpfnDlg;

   lpfnDlg = MakeProcInstance((DLGPROC)DlgStatus, hInst);
   hStatus = CreateDialog(hInst, TEXT("StatusDlg"), hDlg, lpfnDlg) ;
   FreeProcInstance(lpfnDlg);

} // DoStatusDlg


/*+-------------------------------------------------------------------------+
  | StatusDlgKill()
  +-------------------------------------------------------------------------+*/
void StatusDlgKill() {
   DestroyWindow(hStatus);
   hStatus = NULL;

} // StatusDlgKill



/*+-------------------------------------------------------------------------+
  |                 Information (Panel) Dialog Routines                     |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | Panel_Line()
  +-------------------------------------------------------------------------+*/
void Panel_Line(int Line, LPTSTR szFormat, ...) {
   va_list marker;

   if (hPanel == NULL)
      return;

   va_start(marker, szFormat);

   wvsprintf(tmpStr, szFormat, marker);
   tmpStr[60] = TEXT('\0');
   SendDlgItemMessage(hPanel, IDC_PANEL1 - 1 + Line, WM_SETTEXT, 0, (LPARAM) tmpStr);
   SendMessage(hPanel, WM_PAINT, 0, 0L);
   DrainPump();

   va_end(marker);

} // Panel_ConvTxt


/*+-------------------------------------------------------------------------+
  | Panel_Cancel()
  +-------------------------------------------------------------------------+*/
BOOL Panel_Cancel() {

   if ((hPanel == NULL) || !DoCancel)
      return FALSE;

   return TRUE;

} // Panel_Cancel


/*+-------------------------------------------------------------------------+
  | DlgPanel()
  +-------------------------------------------------------------------------+*/
LRESULT CALLBACK DlgPanel(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
   int wmId, wmEvent;
   RECT rc;

   switch (message) {
      case WM_INITDIALOG:
         // Center the dialog over the application window
         DoCancel = FALSE;
         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));
         SendMessage(hDlg, WM_SETTEXT, (WPARAM) 0, (LPARAM) PanelTitle);
         return (TRUE);

      case WM_SETFOCUS:
         GetWindowRect(hDlg, &rc);
         InvalidateRect(hDlg, &rc, FALSE);
         SendMessage(hPanel, WM_PAINT, 0, 0L);
         break;

      case WM_COMMAND:
         wmId    = LOWORD(wParam);
         wmEvent = HIWORD(wParam);

         switch (wmId) {
            case IDCANCEL:
               DoCancel = TRUE;
               return (TRUE);

               break;
         }

         break;
   }

   return (FALSE); // Didn't process the message

   lParam;
} // DlgPanel


/*+-------------------------------------------------------------------------+
  | PanelDlg_Do()
  +-------------------------------------------------------------------------+*/
void PanelDlg_Do(HWND hDlg, LPTSTR Title) {
   DLGPROC lpfnDlg;

   lstrcpy(PanelTitle, Title);
   lpfnDlg = MakeProcInstance((DLGPROC)DlgPanel, hInst);
   hPanel = CreateDialog(hInst, TEXT("PanelDLG"), hDlg, lpfnDlg) ;
   FreeProcInstance(lpfnDlg);

} // PanelDlg_Do


/*+-------------------------------------------------------------------------+
  | PanelDlgKill()
  +-------------------------------------------------------------------------+*/
void PanelDlgKill() {

   if (hPanel == NULL)
      return;

   DestroyWindow(hPanel);
   hPanel = NULL;
   DoCancel = FALSE;

} // PanelDlgKill


/*+-------------------------------------------------------------------------+
  |                   Name Error Dialog (User and Group)                    |
  +-------------------------------------------------------------------------+*/

static TCHAR OldName[60];
static TCHAR NewName[60];
static LPTSTR DlgTitle;
static LPTSTR NameErrorProblem;
static ULONG RetType;
static ULONG MaxNameLen;
/*+-------------------------------------------------------------------------+
  | NameErrorDlg()
  |
  +-------------------------------------------------------------------------+*/
LRESULT CALLBACK NameErrorDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
   int wmId, wmEvent;

   switch (message) {
      case WM_INITDIALOG:
         // Center the dialog over the application window
         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));

         // Init all the display fields
         SendMessage(hDlg, WM_SETTEXT, (WPARAM) 0, (LPARAM) DlgTitle);
         SendMessage(GetDlgItem(hDlg, IDC_OLDNAME), WM_SETTEXT, (WPARAM) 0, (LPARAM) OldName);
         SendMessage(GetDlgItem(hDlg, IDC_NEWNAME), WM_SETTEXT, (WPARAM) 0, (LPARAM) NewName);
         SendMessage(GetDlgItem(hDlg, IDC_PANEL1), WM_SETTEXT, (WPARAM) 0, (LPARAM) NameErrorProblem);

         // limit the name length
         PostMessage(GetDlgItem(hDlg, IDC_NEWNAME), EM_LIMITTEXT, (WPARAM) MaxNameLen, 0);
         return (TRUE);

      case WM_COMMAND:
         wmId    = LOWORD(wParam);
         wmEvent = HIWORD(wParam);

         switch (wmId) {
            case IDABORT:
               // This will cancel the conversion - but need to check with the user
               // if this is what they really want to do
               if (MessageBox(hDlg, Lids(IDS_E_15), Lids(IDS_E_16), MB_YESNO) == IDYES) {
                  RetType = (ULONG) IDABORT;
                  EndDialog(hDlg, 0);
               }

               return (TRUE);
               break;

            case IDRETRY:
               * (WORD *)NewName = (WORD) MaxNameLen + 1;
               SendMessage(GetDlgItem(hDlg, IDC_NEWNAME), EM_GETLINE, 0, (LPARAM) NewName);
               RetType = (ULONG) IDRETRY;
               EndDialog(hDlg, 0);
               return (TRUE);
               break;

            case IDIGNORE:
               RetType = (ULONG) IDCANCEL;
               EndDialog(hDlg, 0);
               return (TRUE);
               break;

         }

         break;
   }

   return (FALSE); // Didn't process the message

   lParam;
} // NameErrorDlg


/*+-------------------------------------------------------------------------+
  | UserNameErrorDlg_Do()
  |
  +-------------------------------------------------------------------------+*/
ULONG UserNameErrorDlg_Do(LPTSTR Title, LPTSTR Problem, USER_BUFFER *User) {
   DLGPROC lpfnDlg;

   lstrcpy(OldName, User->Name);
   lstrcpy(NewName, User->NewName);
   MaxNameLen = MAX_USER_NAME_LEN;

   DlgTitle = Title;
   NameErrorProblem = Problem;
   lpfnDlg = MakeProcInstance((DLGPROC) NameErrorDlg, hInst);
   CursorNormal();
   DialogBox(hInst, TEXT("NameError"), hStatus, lpfnDlg) ;
   CursorHourGlass();
   FreeProcInstance(lpfnDlg);

   if (RetType == IDRETRY) {
      User->err = 0;
      lstrcpy(User->NewName, NewName);

      // if the name is different then flag that it is a new name
      if (lstrcmpi(User->NewName, User->Name))
         User->IsNewName = TRUE;
   }

   return RetType;

} // UserNameErrorDlg_Do


/*+-------------------------------------------------------------------------+
  | GroupNameErrorDlg_Do()
  |
  +-------------------------------------------------------------------------+*/
ULONG GroupNameErrorDlg_Do(LPTSTR Title, LPTSTR Problem, GROUP_BUFFER *Group) {
   DLGPROC lpfnDlg;

   lstrcpy(OldName, Group->Name);
   lstrcpy(NewName, Group->NewName);
   MaxNameLen = MAX_NT_GROUP_NAME_LEN;

   DlgTitle = Title;
   NameErrorProblem = Problem;
   lpfnDlg = MakeProcInstance((DLGPROC) NameErrorDlg, hInst);
   CursorNormal();
   DialogBox(hInst, TEXT("NameError"), hStatus, lpfnDlg) ;
   CursorHourGlass();
   FreeProcInstance(lpfnDlg);

   if (RetType == IDRETRY) {
      Group->err = 0;
      lstrcpy(Group->NewName, NewName);

      // if the name is different then flag that it is a new name
      if (lstrcmpi(Group->NewName, Group->Name))
         Group->IsNewName = TRUE;
   }

   return RetType;

} // GroupNameErrorDlg_Do
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\tab.h ===
//////////////////////////////////////////////////////////////////////////////
// Book Tab Control Name
//////////////////////////////////////////////////////////////////////////////
#define BOOK_TAB_CONTROL    TEXT("BOOKTAB")

//////////////////////////////////////////////////////////////////////////////
// Book Tab specific input messages
//////////////////////////////////////////////////////////////////////////////
//
// message           wParam lParam  return     action
// -------           ------ ------  ------     ------
// BT_ADDITEM          --   pItem   index      adds tab at next avail. spot
// BT_INSERTITEM     index  pItem   index      adds a new item at index
// BT_DELETEITEM     index    --    <nothing>  deletes the tab at index
// BT_DELETEALLITEMS   --     --    <nothing>  deletes all tabs
// BT_SETITEM        index  pItem   succ/fail  replaces text on tab
// BT_GETITEM        index  pItem   succ/fail  retrieves text on tab
// BT_SETCURSEL      index    --    succ/fail  sets the current selection
// BT_GETCURSEL        --     --    index      
// BT_GETITEMCOUNT     --     --    item count 
// BT_SETITEMDATA    index  data    succ/fail  store a DWORD with a tab
// BT_GETITEMDATA    index    --    data       retrieve the DWORD from a tab
// BT_PUTINBACK        --     --    <nothing>  solves focus problem
//
//
#define BT_BASE           WM_USER + 777
#define BT_ADDITEM        BT_BASE + 0
#define BT_INSERTITEM     BT_BASE + 1
#define BT_DELETEITEM     BT_BASE + 2
#define BT_DELETEALLITEMS BT_BASE + 3
#define BT_SETITEM        BT_BASE + 4
#define BT_GETITEM        BT_BASE + 5
#define BT_SETCURSEL      BT_BASE + 6
#define BT_GETCURSEL      BT_BASE + 7
#define BT_GETITEMCOUNT   BT_BASE + 8
#define BT_SETITEMDATA    BT_BASE + 9
#define BT_GETITEMDATA    BT_BASE + 10
#define BT_PUTINBACK      BT_BASE + 11

//////////////////////////////////////////////////////////////////////////////
// Book Tab specific notification messages
//////////////////////////////////////////////////////////////////////////////
// message           wParam  lParam  meaning
// -------           ------  ------  ------- 
// BTN_SELCHANGE     index   my hwnd the current selection has changed
//                   (please note that this notfification WILL NOT BE
//                    SENT if the selection is changed by the
//                    BT_SETCURSEL message). 
//
#define BTN_SELCHANGE    BT_BASE + 100

//////////////////////////////////////////////////////////////////////////////
// Book Tab functions for all to see
//////////////////////////////////////////////////////////////////////////////
void   BookTab_Initialize(HINSTANCE hInstance);

//////////////////////////////////////////////////////////////////////////////
// Book Tab macros to make messages look like functions
//////////////////////////////////////////////////////////////////////////////
#define BookTab_AddItem(hwndCtl, text)            ((UINT)(DWORD)SendMessage((hwndCtl), BT_ADDITEM,        (WPARAM)(0),           (LPARAM)(LPCTSTR)(text) ))
#define BookTab_InsertItem(hwndCtl, index, text)  ((UINT)(DWORD)SendMessage((hwndCtl), BT_INSERTITEM,     (WPARAM)(UINT)(index), (LPARAM)(LPCTSTR)(text) ))
#define BookTab_DeleteItem(hwndCtl, index)        ((void)(DWORD)SendMessage((hwndCtl), BT_DELETEITEM,     (WPARAM)(UINT)(index), (LPARAM)(0)            ))
#define BookTab_DeleteAllItems(hwndCtl)           ((void)(DWORD)SendMessage((hwndCtl), BT_DELETEALLITEMS, (WPARAM)(0),           (LPARAM)(0)            ))
#define BookTab_SetItem(hwndCtl, index, text)     ((BOOL)(DWORD)SendMessage((hwndCtl), BT_SETITEM,        (WPARAM)(UINT)(index), (LPARAM)(LPCTSTR)(text) ))
#define BookTab_GetItem(hwndCtl, index, text)     ((BOOL)(DWORD)SendMessage((hwndCtl), BT_GETITEM,        (WPARAM)(UINT)(index), (LPARAM)(LPCTSTR)(text) ))
#define BookTab_SetCurSel(hwndCtl, index)         ((BOOL)(DWORD)SendMessage((hwndCtl), BT_SETCURSEL,      (WPARAM)(UINT)(index), (LPARAM)(0)            ))
#define BookTab_GetCurSel(hwndCtl)                ((UINT)(DWORD)SendMessage((hwndCtl), BT_GETCURSEL,      (WPARAM)(0),           (LPARAM)(0)            ))
#define BookTab_GetItemCount(hwndCtl)             ((UINT)(DWORD)SendMessage((hwndCtl), BT_GETITEMCOUNT,   (WPARAM)(0),           (LPARAM)(0)            ))
#define BookTab_SetItemData(hwndCtl, index, data) ((BOOL)(DWORD)SendMessage((hwndCtl), BT_SETITEMDATA,    (WPARAM)(UINT)(index), (LPARAM)(DWORD)(data)  ))
#define BookTab_GetItemData(hwndCtl, index)      ((DWORD)(DWORD)SendMessage((hwndCtl), BT_GETITEMDATA,    (WPARAM)(UINT)(index), (LPARAM)(0)            ))
#define BookTab_PutInBack(hwndCtl)               ((DWORD)(DWORD)PostMessage((hwndCtl), BT_PUTINBACK,      (WPARAM)(0),           (LPARAM)(0)            ))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\tab.c ===
//////////////////////////////////////////////////////////////////////////////
//      Copyright 1990-1993 Microsoft corporation
//          all rights reservered
//////////////////////////////////////////////////////////////////////////////
//
// Program: (nominally)Bloodhound
// Module:  tab.c
// Purpose: creates and operates a book tab (big file folder) custom control
//
// Note: the current implementation is limited to 4 booktabs, sorry.
//
//
//  ---------------------------- TABSTOP = 4 -------------------
//
//  Entry Points:
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// BookTab
//
// 
//
// Input:
//      hwnd - our window handle
//
// Returns:
//      
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
#define STRICT
#include "switches.h"
#include <windows.h>
#include <windowsx.h>

#include "tab.h"
// #include "..\bhmem.h"

//////////////////////////////////////////////////////////////////////////////
// Constants
//////////////////////////////////////////////////////////////////////////////
#define MAX_TABS          4
#define MAX_TAB_LABEL_LEN 128

#define ANGLE_X 5
#define ANGLE_Y 5

#define CARAT_X 2
#define CARAT_Y 2

#define FLUFF_X 0
#define FLUFF_Y 0

#define FOOTROOM_Y 3

// We use the selected tab for these calculations:
//
// tab_rect:
//
//    ANGLE_X|--|
//          
//         -    BBBBBBBBBBBBBBB
// ANGLE_Y |   BWWWWWWWWWWWWWWW
//         |  BWWWWWWWWWWWWWWWW
//         - BWWW
//           BWW *  <-- this is where the text_rect starts
//           BWW
//           BWW
//
//
// text_rect: (defined by the *'s)
//
//     FLUFF_X|----|
//
//          - *                                   *
//          | 
//  FLUFF_Y | 
//          |       CARAT_X
//          |      |---|
//          -       .............................   -
//                 .                             .  |
//                 .                             .  | CARAT_Y
//                 .                             .  |
//          -      .   XXXXX XXXXX X   X XXXXX   .  -
// text hght|      .     X   X      X X    X     .
// is from  |      .     X   XXX     X     X     .
// font     |      .     X   X      X X    X     .
//          _      .     X   XXXXX X   X   X     .
//                 .                             .
//                 .                             .
//                 .                             .
//                  ............................. 
//
//                     |---------------------|
//                      text width is directly
//                      from the font itself
//            *                                   *
//
//


//////////////////////////////////////////////////////////////////////////////
// Data Structures for this file
//////////////////////////////////////////////////////////////////////////////
typedef struct _ONETAB
{
    TCHAR label[ MAX_TAB_LABEL_LEN + 1 ];
    DWORD data;
    RECT  tab_rect;
    RECT  text_rect;
} ONETAB;

typedef struct _TABDATA
{
    // do the tabs need updating ?
    BOOL fUpdate;
    RECT tabs_rect;

    // font data
    HFONT   hfSelected;
    HFONT   hfUnselected;

    // windows data
    HWND    hwndParent;

    // tab data
    UINT   total_tabs;
    UINT   selected_tab;
    ONETAB  tab[ MAX_TABS ];

} TABDATA;
typedef TABDATA *LPTABDATA;


//////////////////////////////////////////////////////////////////////////////
// Variables Global to this file
//////////////////////////////////////////////////////////////////////////////
TCHAR szBookTabName[]=BOOK_TAB_CONTROL;

//////////////////////////////////////////////////////////////////////////////
// Macros Global to this file
//////////////////////////////////////////////////////////////////////////////
#define GetInstanceDataPtr(hwnd)   ((LPTABDATA)GetWindowLongPtr(hwnd, 0))
#define SetInstanceDataPtr(hwnd,x) (SetWindowLongPtr(hwnd, 0, (DWORD_PTR)x))


//////////////////////////////////////////////////////////////////////////////
// Functional Prototypes for Functions Local to this File
//////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK BookTab_WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL BookTab_OnCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct);
void BookTab_OnDestroy(HWND hwnd);
void BookTab_OnLButtonDown(HWND hwnd, BOOL fDblClk, int x, int y, UINT keyFlags);
void BookTab_OnPaint(HWND hwnd);
UINT BookTab_OnGetDlgCode(HWND hwnd, MSG FAR* lpmsg);
void BookTab_OnSize(HWND hwnd, UINT state, int cx, int cy);
void BookTab_OnSetFocus(HWND hwnd, HWND hwndOldFocus);
void BookTab_OnKillFocus(HWND hwnd, HWND hwndNewFocus);
void BookTab_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags);
void BookTab_OnEnable(HWND hwnd, BOOL fEnable);

UINT BookTab_OnAddItem( HWND hwnd, LPTSTR text );
UINT BookTab_OnInsertItem( HWND hwnd, UINT index, LPTSTR text);
BOOL BookTab_OnDeleteItem( HWND hwnd, UINT index );
BOOL BookTab_OnDeleteAllItems( HWND hwnd);
BOOL BookTab_OnSetItem( HWND hwnd, UINT index, LPTSTR text );
BOOL BookTab_OnGetItem( HWND hwnd, UINT index, LPTSTR text );
UINT BookTab_OnSetCurSel( HWND hand, UINT newsel );
UINT BookTab_OnGetCurSel( HWND hand );
UINT BookTab_OnGetItemCount( HWND hwnd );
BOOL BookTab_OnSetItemData( HWND hwnd, UINT index, DWORD data );
DWORD BookTab_OnGetItemData( HWND hwnd, UINT index);
void BookTab_OnPutInBack( HWND hwnd );

BOOL IsPointInRect( int given_x, int given_y, LPRECT pRect );
void BookTab_UpdateButtons( HWND hwnd );

//////////////////////////////////////////////////////////////////////////////
// BookTab_Initialize()
//
// Initializes and registers the BookTab custom class
//
// Input:
//      hInstance - the handle to our parent's instance
//
// Returns:
//      True if successful, else False
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
void BookTab_Initialize(HINSTANCE hInstance)
{
    WNDCLASS wndclass;

    wndclass.style          = CS_HREDRAW | CS_VREDRAW | CS_GLOBALCLASS | CS_PARENTDC;
    wndclass.lpfnWndProc    = BookTab_WndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = sizeof( LPTABDATA );
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = NULL;
    wndclass.hCursor        = LoadCursor(NULL,IDC_ARROW);
    wndclass.hbrBackground  = NULL;
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = szBookTabName;

    RegisterClass ( &wndclass );
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_WndProc()
//
// Distributes messages coming in to the BookTab control
//
// Input:
//      hwnd -    Our handle
//      message - the ordinal of the incoming message 
//      wParam  - half of the incoming data
//      lParam  - the other half of the incoming data
//
// Returns:
//      True if we handled the message, else False
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK BookTab_WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        // standard windows messages
        HANDLE_MSG( hwnd, WM_CREATE,      BookTab_OnCreate);
        HANDLE_MSG( hwnd, WM_DESTROY,     BookTab_OnDestroy);
        HANDLE_MSG( hwnd, WM_LBUTTONDOWN, BookTab_OnLButtonDown);
        HANDLE_MSG( hwnd, WM_PAINT,       BookTab_OnPaint);
        HANDLE_MSG( hwnd, WM_SIZE,        BookTab_OnSize);
        HANDLE_MSG( hwnd, WM_SETFOCUS,    BookTab_OnSetFocus);
        HANDLE_MSG( hwnd, WM_KILLFOCUS,   BookTab_OnKillFocus);
        HANDLE_MSG( hwnd, WM_KEYDOWN,     BookTab_OnKey);
        HANDLE_MSG( hwnd, WM_KEYUP,       BookTab_OnKey);

        // messages specific to all custom controls
        HANDLE_MSG( hwnd, WM_GETDLGCODE,  BookTab_OnGetDlgCode);
        HANDLE_MSG( hwnd, WM_ENABLE,      BookTab_OnEnable);

        // messages specific to THIS custom control
        case BT_ADDITEM:
            return( BookTab_OnAddItem( hwnd, (LPTSTR)lParam ));
        case BT_INSERTITEM:
            return( BookTab_OnInsertItem( hwnd, (UINT)wParam, (LPTSTR)lParam ));
        case BT_DELETEITEM:
            return( BookTab_OnDeleteItem( hwnd, (UINT)wParam ));
        case BT_DELETEALLITEMS:
            return( BookTab_OnDeleteAllItems( hwnd ));
        case BT_SETITEM:    
            return( BookTab_OnSetItem( hwnd, (UINT)wParam, (LPTSTR)lParam ));
        case BT_GETITEM:    
            return( BookTab_OnGetItem( hwnd, (UINT)wParam, (LPTSTR)lParam ));
        case BT_SETCURSEL:   
            return( BookTab_OnSetCurSel( hwnd, (UINT)wParam ));
        case BT_GETCURSEL:   
            return( BookTab_OnGetCurSel( hwnd ));
        case BT_GETITEMCOUNT:  
            return( BookTab_OnGetItemCount( hwnd ));
        case BT_SETITEMDATA:
            return( BookTab_OnSetItemData( hwnd, (UINT)wParam, (DWORD)lParam ));
        case BT_GETITEMDATA:
            return( BookTab_OnGetItemData( hwnd, (UINT)wParam ));
        case BT_PUTINBACK:
            BookTab_OnPutInBack( hwnd );
            return (TRUE);
    }
    // pass unprocessed messages to DefWndProc...
    return DefWindowProc(hwnd, message, wParam, lParam);
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnCreate()
//
// Initializes a new instance of our lovely custom control
//
// Input:
//      hwnd - our window handle
//      lpcreatestruct - pointer to the data with which to do our thing
//
// Returns:
//      True if the instance is created, else false
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
BOOL BookTab_OnCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct)
{
    LPTABDATA pData;
    UINT i;

    // allocate the instance data for this control    
    pData = LocalAlloc( LPTR, sizeof( TABDATA ));
    if( pData == NULL )
        return FALSE;
    SetInstanceDataPtr( hwnd, pData );

    // initialize values in the control
    pData->total_tabs = 0;
    pData->selected_tab = 0;

    pData->hwndParent = lpCreateStruct->hwndParent;

    // fill the prospective tab slots with data
    for( i = 0; i < MAX_TABS; i++ )
    {
        pData->tab[i].label[0] = TEXT('\0');
        pData->tab[i].data = (DWORD)0;
    }

    // create the proper fonts:
    // 8 pt sans serif bold for selected and
    // 8 pt sans serif regular for not selected 

    pData->hfSelected   = CreateFont( -MulDiv(9, GetDeviceCaps(GetDC(hwnd),
                                      LOGPIXELSY), 72), 0, 0, 0,
                                      FW_BOLD, FALSE, FALSE, FALSE,
                                      DEFAULT_CHARSET, OUT_TT_PRECIS,
                                      CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                                      0x4, TEXT("MS Shell Dlg") );
    pData->hfUnselected   = CreateFont( -MulDiv(9, GetDeviceCaps(GetDC(hwnd),
                                      LOGPIXELSY), 72), 0, 0, 0,
                                      FW_NORMAL, FALSE, FALSE, FALSE,
                                      DEFAULT_CHARSET, OUT_TT_PRECIS,
                                      CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                                      0x4, TEXT("MS Shell Dlg") );

    // fill the rest of the sizing info 
    BookTab_OnSize( hwnd, 0, lpCreateStruct->cx, lpCreateStruct->cy );

    // make sure that we are on the bottom
    SetWindowPos( hwnd, HWND_BOTTOM, 0, 0, 0, 0, 
                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW );

    // make sure we update
    pData->fUpdate = TRUE;

    // put us last
    BookTab_PutInBack( hwnd );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnDestroy()
//
// Cleans up as our control goes away
//
// Input:
//      hwnd - our window handle
//
// Returns:
//      nothing
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
void BookTab_OnDestroy(HWND hwnd)
{
    LPTABDATA pData;

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // delete our fonts
    DeleteObject( pData->hfSelected );
    DeleteObject( pData->hfUnselected );

    // free up our instance data
    LocalFree( pData );
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnLButtonDown()
//
// Handles the event where a user has the left mouse button down
//
// Input:
//      hwnd     - our window handle
//      fDblClk  - an indication on the second message of a double click
//      x        - the mouses x coordinate at the time of the message
//      y        - the mouses y coordinate at the time of the message
//      keyFlags - an indication of which keys were pressed at the time
//
// Returns:
//      nuthin'
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
void BookTab_OnLButtonDown(HWND hwnd, BOOL fDblClk, int x, int y, UINT keyFlags)
{
    LPTABDATA pData;
    UINT      i;

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // where did they click the mouse...
    // loop thru the tabs to find the one struck
    for( i = 0; i < pData->total_tabs; i++ )
    {
        if( IsPointInRect( x, y, &(pData->tab[i].tab_rect) ) )
        {
            // this is the correct spot
            BookTab_OnSetCurSel( hwnd, i );

            // notify our parent that the selection has changed
            SendMessage( pData->hwndParent, BTN_SELCHANGE, 
                         pData->selected_tab, (DWORD_PTR)hwnd);

            SetFocus( hwnd );
            return;
        }
    }         

    // the mouse was clicked outside any of the button areas
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnPaint()
//
// Handles requests from windows that the control repaint itself
//
// Input:
//      hwnd - our window handle
//
// Returns:
//      hopefully :)
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
void BookTab_OnPaint(HWND hwnd)
{
    LPTABDATA   pData;
    PAINTSTRUCT ps;
    HDC         hdc;
    TEXTMETRIC  tm;
    UINT        i;
    HWND        hwndFocus;

    HPEN        hOldPen;
    HPEN        hShadowPen;
    HPEN        hHighlightPen;
    HPEN        hFramePen;
    HPEN        hBackPen;
    HBRUSH      hBackBrush;
    HFONT       hfOldFont;

    WORD        cyChar;
    WORD        yWidth;
    WORD        xWidth;
    RECT        total;
    RECT        temp;
    LPRECT      pTab;
    LPRECT      pText;

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // right before drawing, make sure that the button sizes are accurate
    BookTab_UpdateButtons( hwnd );

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // get the handle to the window with the current focus
    hwndFocus = GetFocus();

    // prepare for painting...
    BeginPaint( hwnd, &ps );
    hdc = GetDC( hwnd );

    // set text stuff
    SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));
    SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));
    SetTextAlign( hdc, TA_TOP | TA_LEFT );

    // determine proper sizes
    GetTextMetrics(hdc, &tm);
    cyChar    = (WORD)tm.tmHeight;
    xWidth = (WORD) GetSystemMetrics(SM_CXBORDER);
    yWidth = (WORD) GetSystemMetrics(SM_CYBORDER);
    GetClientRect( hwnd, &total );
    //BUGBUG fudge the rectangle so that the bottom and left do not get cut off
    total.bottom -= yWidth;
    total.right  -= xWidth;

    // set up the pens that we will need
    hHighlightPen = CreatePen(PS_SOLID, yWidth, GetSysColor(COLOR_BTNHIGHLIGHT));
    hShadowPen    = CreatePen(PS_SOLID, yWidth, GetSysColor(COLOR_BTNSHADOW));
    hFramePen     = CreatePen(PS_SOLID, yWidth, GetSysColor(COLOR_WINDOWFRAME));
    hBackPen      = CreatePen(PS_SOLID, yWidth, GetSysColor(COLOR_BTNFACE));
    hBackBrush    = CreateSolidBrush(           GetSysColor(COLOR_BTNFACE));

    // get the old pen by setting a new one
    hOldPen = SelectPen( hdc, hHighlightPen );

    // clear out behind the tabs if we need to
    if( pData->fUpdate == TRUE )
    {
        FillRect( hdc, &(pData->tabs_rect), hBackBrush );
        pData->fUpdate = FALSE;
    }   

    // draw the box...
    // left side dark border
    SelectPen( hdc, hFramePen ); 
    MoveToEx( hdc, total.left, pData->tab[0].tab_rect.bottom+yWidth,  NULL );
    LineTo  ( hdc, total.left, total.bottom );
    // bottom dark border
    LineTo  ( hdc, total.right, total.bottom );
    // right side dark border
    LineTo  ( hdc, total.right, pData->tab[0].tab_rect.bottom+yWidth);
    // top dark border, right half (over to selection)
    LineTo  ( hdc, pData->tab[pData->selected_tab].tab_rect.right-yWidth,
              pData->tab[0].tab_rect.bottom+yWidth);
    // skip area under the selected tab
    MoveToEx( hdc, pData->tab[pData->selected_tab].tab_rect.left,
              pData->tab[0].tab_rect.bottom+yWidth, NULL);
    // top dark border, left half (from selection to left border)
    LineTo  ( hdc, total.left, pData->tab[0].tab_rect.bottom+yWidth);

    // left side highlight #1
    SelectPen( hdc, hHighlightPen );
    MoveToEx( hdc, total.left+xWidth, pData->tab[0].tab_rect.bottom+2*yWidth, NULL );
    LineTo( hdc, total.left+xWidth, total.bottom-yWidth );

    // bottom shadow #1
    SelectPen( hdc, hShadowPen );
    LineTo( hdc, total.right-xWidth, total.bottom-yWidth );
    // right side shadow #1
    LineTo( hdc, total.right-xWidth, pData->tab[0].tab_rect.bottom+2*yWidth );

    // top hilite #1
    SelectPen( hdc, hHighlightPen );
    // top hilite, right half (over to selection)
    LineTo  ( hdc, pData->tab[pData->selected_tab].tab_rect.right-yWidth,
              pData->tab[0].tab_rect.bottom+2*yWidth);
    // skip area under the selected tab
    MoveToEx( hdc, pData->tab[pData->selected_tab].tab_rect.left,
              pData->tab[0].tab_rect.bottom+2*yWidth, NULL);
    // top hilite, left half (from selection to left border)
    if( pData->selected_tab != 0 )
        LineTo  ( hdc, total.left+2*xWidth, 
                  pData->tab[0].tab_rect.bottom+2*yWidth);

    // left side highlight #2
    SelectPen( hdc, hHighlightPen );
    MoveToEx( hdc, total.left+2*xWidth, pData->tab[0].tab_rect.bottom+3*yWidth, NULL );
    LineTo( hdc, total.left+2*xWidth, total.bottom-2*yWidth );

    // bottom shadow #2
    SelectPen( hdc, hShadowPen );
    LineTo( hdc, total.right-2*xWidth, total.bottom-2*yWidth );
    // right side shadow #2
    LineTo( hdc, total.right-2*xWidth, pData->tab[0].tab_rect.bottom+3*yWidth );

    // top hilite #2
    SelectPen( hdc, hHighlightPen );
    // top hilite, right half (over to selection)
    LineTo  ( hdc, pData->tab[pData->selected_tab].tab_rect.right-2*yWidth,
              pData->tab[0].tab_rect.bottom+3*yWidth);
    // skip area under the selected tab
    MoveToEx( hdc, pData->tab[pData->selected_tab].tab_rect.left,
              pData->tab[0].tab_rect.bottom+3*yWidth, NULL);
    // top hilite, left half (from selection to left border)
    if( pData->selected_tab != 0 )
        LineTo  ( hdc, total.left+2*xWidth, 
                  pData->tab[0].tab_rect.bottom+3*yWidth);

    // Draw the tabs...
    // loop thru the tabs
    for( i = 0; i < pData->total_tabs; i++ )
    {
        // point our local variables at the current rects
        pTab = &(pData->tab[i].tab_rect);
        pText = &(pData->tab[i].text_rect);

        if( i == pData->selected_tab )
        {
            // this is the selection, it should not be pushed down...
            // left side dark border
            SelectPen( hdc, hFramePen );
            MoveToEx(hdc, pTab->left, pTab->bottom, NULL);
            LineTo(hdc, pTab->left, pTab->top + ANGLE_Y*yWidth);
            // left side angle dark border
            LineTo(hdc, pTab->left + ANGLE_X*xWidth, pTab->top);
            // top dark border
            LineTo(hdc, pTab->right - ANGLE_X*xWidth, pTab->top);
            // right side angle dark border
            LineTo(hdc, pTab->right, pTab->top + ANGLE_Y*yWidth);
            // right side dark border (overshoot by one)
            LineTo(hdc, pTab->right, pTab->bottom+yWidth);

            // left side hilite #1 (extends down 3 below the box to handle
            // melding the hilites with the box below)
            SelectPen( hdc, hHighlightPen);
            MoveToEx(hdc, pTab->left+xWidth, pTab->bottom+3*yWidth, NULL);
            LineTo(hdc, pTab->left+xWidth, pTab->top+ANGLE_Y*yWidth );
            // left side angle hilight #1
            LineTo(hdc, pTab->left+ANGLE_X*xWidth, pTab->top+yWidth );
            // top hilite #1
            LineTo(hdc, pTab->right-ANGLE_X*xWidth, pTab->top+yWidth );
            // right side angle shadow #1
            SelectPen( hdc, hShadowPen);
            LineTo(hdc, pTab->right-xWidth, pTab->top+ANGLE_Y*yWidth );
            // right side shadow #1 (overshoot by one) (see above)
            LineTo(hdc, pTab->right-xWidth, pTab->bottom+3*yWidth);

            // left side hilite #2 (the 2* are becaus we are the 2nd hilite)
            SelectPen( hdc, hHighlightPen);
            MoveToEx(hdc, pTab->left+2*xWidth, pTab->bottom+3*yWidth, NULL);
            LineTo(hdc, pTab->left+2*xWidth, pTab->top+ANGLE_Y*yWidth );
            // left side angle hilight #2
            LineTo(hdc, pTab->left+ANGLE_X*xWidth, pTab->top+2*yWidth );
            // top hilite #2
            LineTo(hdc, pTab->right-ANGLE_X*xWidth, pTab->top+2*yWidth );
            // right side angle shadow #2
            SelectPen( hdc, hShadowPen);
            LineTo(hdc, pTab->right-2*xWidth, pTab->top+ANGLE_Y*yWidth );
            // right side shadow #2 (overshoot by one) 
            LineTo(hdc, pTab->right-2*xWidth, pTab->bottom+4*yWidth );

            // clear out the chunk below the active tab
            SelectPen(hdc, hBackPen );
            MoveToEx(hdc, pTab->left+3*xWidth, pTab->bottom+yWidth, NULL);
            LineTo(hdc, pTab->right-2*xWidth, pTab->bottom+yWidth);
            MoveToEx(hdc, pTab->left+3*xWidth, pTab->bottom+2*yWidth, NULL);
            LineTo(hdc, pTab->right-2*xWidth, pTab->bottom+2*yWidth);
            MoveToEx(hdc, pTab->left+3*xWidth, pTab->bottom+3*yWidth, NULL);
            LineTo(hdc, pTab->right-2*xWidth, pTab->bottom+3*yWidth);

            // clear out the old label...
            FillRect( hdc, pText, hBackBrush );
            
            // now print in the label ...
            hfOldFont = SelectObject( hdc, pData->hfSelected );
            ExtTextOut( hdc, 
                        pText->left+ CARAT_X*xWidth + FLUFF_X*xWidth,
                        pText->top + CARAT_Y*yWidth + FLUFF_Y*yWidth,
                        0, NULL, pData->tab[i].label, 
                        lstrlen(pData->tab[i].label), NULL );
            SelectFont( hdc, hfOldFont );

            // if we have the focus, print the caret
            if( hwnd == hwndFocus )
            {
                // we have the focus
                temp.top    = pText->top    + FLUFF_X*xWidth;
                temp.left   = pText->left   + FLUFF_Y*yWidth;
                temp.bottom = pText->bottom - FLUFF_X*xWidth;
                temp.right  = pText->right  - FLUFF_Y*yWidth;
                DrawFocusRect( hdc, &temp );
            }

        }
        else
        {
            // push this tab down one border width...
            // this will mean an extra +1 on all ANGLE_Ys...
            // left side dark border
            SelectPen( hdc, hFramePen );
            MoveToEx(hdc, pTab->left, pTab->bottom, NULL);
            LineTo(hdc, pTab->left, pTab->top + (ANGLE_Y+1)*yWidth);
            // left side angle dark border
            LineTo(hdc, pTab->left + ANGLE_X*xWidth, pTab->top+yWidth);
            // top dark border
            LineTo(hdc, pTab->right - ANGLE_X*yWidth, pTab->top+yWidth);
            // right side angle dark border
            LineTo(hdc, pTab->right, pTab->top + (ANGLE_Y+1)*yWidth);
            // right side dark border (overshoot by one)
            LineTo(hdc, pTab->right, pTab->bottom+yWidth);

            // left side hilite
            SelectPen( hdc, hHighlightPen);
            MoveToEx(hdc, pTab->left+xWidth, pTab->bottom, NULL);
            LineTo(hdc, pTab->left+xWidth, pTab->top+(ANGLE_Y+1)*yWidth);
            // left side angle hilight
            LineTo(hdc, pTab->left+ANGLE_X*xWidth, pTab->top+2*yWidth);
            // top hilite
            LineTo(hdc, pTab->right-ANGLE_X*xWidth, pTab->top+2*yWidth);
            
            // right side angle shadow 
            SelectPen( hdc, hShadowPen);
            LineTo(hdc, pTab->right-xWidth, pTab->top+(ANGLE_Y+1)*yWidth);
            // right side shadow (overshoot by one)
            LineTo(hdc, pTab->right-xWidth, pTab->bottom+yWidth);

            // clean above left angle
            SelectPen( hdc, hBackPen );
            MoveToEx(hdc, pTab->left, pTab->top+ANGLE_Y*yWidth, NULL );
            LineTo(hdc, pTab->left+ANGLE_X*xWidth, pTab->top );
            // clean above top
            LineTo(hdc, pTab->right-ANGLE_X*xWidth, pTab->top);
            // clean above right angle 
            LineTo(hdc, pTab->right, pTab->top+ANGLE_Y*yWidth );
            // clean last corner
            LineTo(hdc, pTab->right, pTab->top+(ANGLE_Y+1)*yWidth );

            // clean up inside left hilite
            MoveToEx(hdc, pTab->left+2*xWidth, pTab->bottom, NULL );
            LineTo(hdc, pTab->left+2*xWidth, pTab->top+(ANGLE_Y+1)*yWidth);
            // clean up inside left angle hilite
            LineTo(hdc, pTab->left+ANGLE_X*xWidth, pTab->top+3*yWidth);
            // clean up inside top hilite (noop)
            LineTo(hdc, pTab->right-ANGLE_X*xWidth, pTab->top+3*yWidth);
            // clean up inside right angle shadow (noop)
            LineTo(hdc, pTab->right-2*xWidth, pTab->top+(ANGLE_Y+1)*yWidth);
            // clean up inside left hilite (overshoot by one)
            LineTo(hdc, pTab->right-2*xWidth, pTab->bottom+yWidth);

            // clear out the old label...
            FillRect( hdc, pText, hBackBrush );
            
            // now print in the label ...
            hfOldFont = SelectObject( hdc, pData->hfUnselected );
            ExtTextOut( hdc, 
                        pText->left+ CARAT_X*xWidth + FLUFF_X*xWidth,
                        pText->top + CARAT_Y*yWidth + FLUFF_Y*yWidth + yWidth,
                        0, NULL, pData->tab[i].label, 
                        lstrlen(pData->tab[i].label), NULL );
            SelectFont( hdc, hfOldFont );
        }
    }

    SelectPen( hdc, hOldPen);

    // put the DC we used back into circulation
    ReleaseDC( hwnd, hdc );

    // tell windows that we're done
    EndPaint( hwnd, &ps );
    
    // clean up
    DeleteObject( hHighlightPen );
    DeleteObject( hShadowPen );
    DeleteObject( hFramePen );
    DeleteObject( hBackPen );
    DeleteObject( hBackBrush );
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnSize()
//
// Handles requests from windows that we should resize ourselves
//
// Input:
//      hwnd  - our window handle
//      state - an indication of Minimized, maximized, iconic, blah blah blah
//      cx    - our new width
//      cy    - our new height
//
// Returns:
//      hopefully :)
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
void BookTab_OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    // need to update the button size stuff, just for hit testing
    BookTab_UpdateButtons(hwnd);
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnSetFocus()
//
// Handles windows telling us that we just got the focus
//
// Input:
//      hwnd - our window handle
//      hwndOld - the guy who used to have the focus (i don't use)
//
// Returns:
//      nyaytay
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
void BookTab_OnSetFocus(HWND hwnd, HWND hwndOldFocus)
{
    LPTABDATA pData;

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // make sure that we are on the bottom
    SetWindowPos( hwnd, HWND_BOTTOM, 0, 0, 0, 0, 
                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW );

    // we gotta repaint just the rect for the active tab
    InvalidateRect( hwnd, &(pData->tab[pData->selected_tab].tab_rect), FALSE );
    UpdateWindow( hwnd );
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnKillFocus()
//
// Handles windows telling us that we are just about to lose the focus
//
// Input:
//      hwnd - our window handle
//      hwndNew - the lucky guy who is about to have the focus (i don't use)
//
// Returns:
//      nyaytay
//      
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
void BookTab_OnKillFocus(HWND hwnd, HWND hwndNewFocus)
{
    LPTABDATA pData;

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // we gotta repaint just the rect for the active tab
    InvalidateRect( hwnd, &(pData->tab[pData->selected_tab].tab_rect), FALSE );
    UpdateWindow( hwnd );
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnKey()
//
// Handes key messages sent to the control
//
// Input:
//      hwnd - our window handle
//      vk   - the virtual key code
//      fDown - is the key down?
//      cRepeat - how many times it was pressed
//      flags - i don't use
//
// Returns:
//      nada
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
void BookTab_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags)
{
    LPTABDATA pData;

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // don't want key up messages
    if( fDown == FALSE )
        return;

    // we only handle left and right cursor
    switch( vk )
    {
        case VK_LEFT:
            // move to the tab to the left (wrap if needed)
            BookTab_OnSetCurSel( hwnd, (pData->selected_tab == 0)?
                (pData->total_tabs-1):(pData->selected_tab-1));

            // notify our parent that the selection has changed
            SendMessage( pData->hwndParent, BTN_SELCHANGE, 
                         pData->selected_tab, (DWORD_PTR)hwnd);
            break;



        case VK_RIGHT:
            BookTab_OnSetCurSel( hwnd,
                (pData->selected_tab+1) % (pData->total_tabs));

            // notify our parent that the selection has changed
            SendMessage( pData->hwndParent, BTN_SELCHANGE, 
                         pData->selected_tab, (DWORD_PTR)hwnd);
            break;
    }
}


//////////////////////////////////////////////////////////////////////////////
// BookTab_OnGetDlgCode()
//
// The windows dialog manager is asking us what type of user inputs we want
//
// Input:
//      hwnd -  our window handle
//      lpmsg - who knows, I don't use it, it's not in the paper docs...
//
// Returns:
//      a word which is a bitmap of input types
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
UINT BookTab_OnGetDlgCode(HWND hwnd, MSG FAR* lpmsg)
{
    // We just want cursor keys and character keys
    return( DLGC_WANTARROWS | DLGC_WANTCHARS );
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnEnable()
//
// Windows is telling us that we are being enabled/disabled
//
// Input:
//      hwnd    - our window handle
//      fEnable - Are we being enabled?
//
// Returns:
//      nada
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
void BookTab_OnEnable(HWND hwnd, BOOL fEnable)
{
    // BUGBUG - we look no different in either state
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnAddItem()
//
// Adds an item to the end of the tab list
//
// Input:
//      hwnd - our window handle
//      text - the label of the tab to add
//
// Returns:
//      the index of the item as added
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
UINT BookTab_OnAddItem( HWND hwnd, LPTSTR text )
{
    LPTABDATA pData;

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // call the worker for insert with the current end of the tab lizst
    return( BookTab_OnInsertItem( hwnd, pData->total_tabs, text) );
}


//////////////////////////////////////////////////////////////////////////////
// BookTab_OnInsertItem()
//
// Inserts the given item at the spot indicated and shoves the others down
//
// Input:
//      hwnd  - our window handle
//      index - the proposed index of the new item
//      text  - the label to add to the new tab
//
// Returns:
//      the ACTUAL new index of the item (we could sort or have to reduce
//      the initial request if it would leave a gap)
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
UINT BookTab_OnInsertItem( HWND hwnd, UINT index, LPTSTR text)
{
    LPTABDATA pData;
    int       i;

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // make sure that the text will fit
    if( lstrlen( text ) > MAX_TAB_LABEL_LEN-1 )
        return (UINT)-1;

    // are we full
    // BUGBUG, limit in the future
    if( pData->total_tabs >= MAX_TABS )
        // we can not add at this time
        return (UINT)-1;

    // make sure that the requested index is within or adjacent to currently
    // used spots
    if( index > pData->total_tabs )
        // change it so that index now points at the next open slot
        index = pData->total_tabs;

    // slide over all tabs above
    for( i = (int)pData->total_tabs; i > (int)index; i-- )
    {
        memcpy( &(pData->tab[i]), &(pData->tab[i-1]), sizeof( ONETAB) );
    }

    // your room is ready sir
    lstrcpy( pData->tab[index].label, text );
    pData->total_tabs++;

    // should clear the background
    pData->fUpdate = TRUE;

    return index;
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnDeleteItem()
//
// Deletes the item at the index given and closes up the gaps
//
// Input:
//      hwnd -  our window handle
//      index - item to be deleted
//
// Returns:
//      nuthin'
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
BOOL BookTab_OnDeleteItem( HWND hwnd, UINT index )
{
    LPTABDATA pData;
    UINT      i;

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // make sure that we even have an element like this 
    if( index >= pData->total_tabs )
        return FALSE;

    // slide all of the deceased successors over
    for( i = index+1; i < pData->total_tabs; i++ )
    {
        memcpy( &(pData->tab[i-1]), &(pData->tab[i]), sizeof( ONETAB) );
    }

    // reduce the count to account for the deletion
    pData->total_tabs--;

    // should clear the background
    pData->fUpdate = TRUE;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnDeleteAllItems()
//
// Genocide on tabs
//
// Input:
//      hwnd - our window handle
//
// Returns:
//      nothing
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
BOOL   BookTab_OnDeleteAllItems( HWND hwnd)
{
    LPTABDATA pData;

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // BUGBUG just set our count to zero
    pData->total_tabs = 0;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnSetItem()
//
// Sets the title of the booktab given
//
// Input:
//      hwnd  - our window handle
//      index - the tab to label
//      text - the words to put on the tab
//
// Returns:
//      TRUE if successful, else False
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
BOOL BookTab_OnSetItem( HWND hwnd, UINT index, LPTSTR text )
{
    LPTABDATA pData;

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // make sure that the text will fit
    if( lstrlen( text ) > MAX_TAB_LABEL_LEN-1 )
        return FALSE;

    // make sure that the index is legal
    if( index >= pData->total_tabs )
        return FALSE;

    // set the title
    lstrcpy( pData->tab[index].label, text );

    // we are changing the size of the tab, we will need to clean out behind
    pData->fUpdate = TRUE;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnGetItem()
//
// Retrieves a booktab title
//
// Input:
//      hwnd - our window handle
//      index - the tab to label
//      text - the buffer to fill with the tab title
//
// Returns:
//      a pointer to the filled buffer if successful, else NULL
//      
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
BOOL BookTab_OnGetItem( HWND hwnd, UINT index, LPTSTR text )
{
    LPTABDATA pData;

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // make sure that the index is legal
    if( index >= pData->total_tabs )
        return FALSE;

    // get the title
    lstrcpy( text, pData->tab[index].label );
    return( TRUE );
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnSetCurSel()
//
// Sets the current selection
//
// Input:
//      hwnd - our window handle
//      newsel - the requested selection
//
// Returns:
//      the new current selection    
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
UINT BookTab_OnSetCurSel( HWND hwnd, UINT newsel )
{
    LPTABDATA pData;

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // make sure that the requested selection is within the proper bounds
    if( newsel >= pData->total_tabs )
        return( pData->selected_tab );

    // make sure that the selection actually changed
    if( newsel != pData->selected_tab )
    {
        // set selection
        pData->selected_tab = newsel;

        // make us redraw
        InvalidateRect( hwnd, NULL, FALSE );
        UpdateWindow( hwnd );
    }

    return( pData->selected_tab );
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_GetCurSel()
//
// Retrieves the current selection
//
// Input:
//      hwnd - our window handle
//
// Returns:
//      the current selection
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
UINT BookTab_OnGetCurSel( HWND hwnd )
{
    LPTABDATA pData;

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // get selection
    return( pData->selected_tab );
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnGetItemCount()
//
// Retrieves the number of tabs currently in use
//
// Input:
//      hwnd - our window handle
//
// Returns:
//      the number of tabs in use
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
UINT BookTab_OnGetItemCount( HWND hwnd )
{
    LPTABDATA pData;

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // get the number of tabs
    return( pData->total_tabs );                
}    

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnSetItemData()
//
// Adds a DWORD of data to the data structure for the given tab
//
// Input:
//      hwnd - our window handle
//      index - which tab to add data to
//      data  - what to add
//
// Returns:
//      TRUE if succcessful, else FALSE
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
BOOL BookTab_OnSetItemData( HWND hwnd, UINT index, DWORD data )
{
    LPTABDATA pData;

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // set the instance data
    pData->tab[index].data = data;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnPutInBack()
//
// Sets the focus to the booktab and then back to whoever had it first,
// this seemes to put this control in the very back.
//
// Input:
//      hwnd - our window handle
//
// Returns:
//      <nothing>
//
// History
//      Arthur Brooking  1/21/93 created     
//////////////////////////////////////////////////////////////////////////////
void BookTab_OnPutInBack( HWND hwnd )
{
    HWND hwndOldFocus;

    // set the focus to us
    hwndOldFocus = SetFocus( hwnd );

    // if there was an old focus, set it back to that.
    if( hwndOldFocus )
        SetFocus( hwndOldFocus );

}

//////////////////////////////////////////////////////////////////////////////
// BookTab_OnGetItemData()
//
// Gets the DWORD of data stored in the data structure for the given tab
//
// Input:
//      hwnd - our window handle
//      index - which tab to get data from
//
// Returns:
//      the stored DWORD
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
DWORD BookTab_OnGetItemData( HWND hwnd, UINT index)
{
    LPTABDATA pData;

    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // get the instance data
    return( (DWORD)pData->tab[index].data );
}

//////////////////////////////////////////////////////////////////////////////
// IsPointInRect()
//
// determines if the point specifier is in the rectangle specified
//
// Input:
//      given_x - x coordinate of the point to be tested
//      given_y - y coordinate of the point to be tested
//      pTab   - a pointer to the rectangle to test against
//
// Returns:
//      True if the point is within the rectangle, False if not
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
BOOL IsPointInRect( int given_x, int given_y, LPRECT pRect )
{
    // is it above
    if( given_y < pRect->top )
        return FALSE;

    // is it below
    if( given_y > pRect->bottom )
        return FALSE;

    // is it to the left
    if( given_x < pRect->left )
        return FALSE;

    // is it to the right
    if( given_x > pRect->right )
        return FALSE;

    // well, it must be inside
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// BookTab_UpdateButtons()
//
// Takes the current data and updates the sizes of the tabs
//
// Input:
//      hwnd - our window handle
//
// Returns:
//      nuthin
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
void BookTab_UpdateButtons( HWND hwnd )
{
    LPTABDATA pData;
    HDC       hdc;
    SIZE      cur_size;
    RECT      total_rect;
    WORD      yWidth;
    WORD      xWidth;
    UINT      left;
    UINT      i;
    HFONT     hfOldFont;


    // get the instance data 
    pData = GetInstanceDataPtr( hwnd );

    // preset this so that the MAXes later will work
    pData->tabs_rect.bottom = 0;
    
    xWidth = (WORD) GetSystemMetrics(SM_CXBORDER);
    yWidth = (WORD) GetSystemMetrics(SM_CYBORDER);
    GetClientRect( hwnd, &total_rect);
    // BUGBUG cheat to see the whole thing
    total_rect.bottom -= yWidth;
    total_rect.right  -= xWidth;

    hdc = GetDC( hwnd );    

    // use the selected font (BOLD) to size the tabs
    hfOldFont = SelectObject( hdc, pData->hfSelected );

    // loop thru the tabs
    left = total_rect.left;
    for( i = 0; i < pData->total_tabs; i++ )
    {
        // get the size of the data for this tab
        GetTextExtentPoint( hdc, pData->tab[i].label, 
                       lstrlen( pData->tab[i].label), &cur_size);

        // calculate the text rectatangle first ...
        // the text top is down the size of the angle
        pData->tab[i].text_rect.top = total_rect.top + ANGLE_Y*yWidth;

        // the text left is over the size of the angle
        pData->tab[i].text_rect.left = left + ANGLE_X*xWidth;

        // the text bottom is down from the top the size of the text +
        // 2x the fluff(top and bottom) + 2x the carat space
        pData->tab[i].text_rect.bottom = pData->tab[i].text_rect.top +
            cur_size.cy + 2*FLUFF_Y*yWidth + 2*CARAT_Y*yWidth;

        // the text right is over from the left the size of the text +
        // 2x the fluff(left and right) + 2x the carat space
        pData->tab[i].text_rect.right = pData->tab[i].text_rect.left +
            cur_size.cx + 2*FLUFF_X*xWidth + 2*CARAT_X*xWidth;


        // then calculate the full tab rectangle
        // the tab top is the top of the control
        pData->tab[i].tab_rect.top = total_rect.top;

        // the left side of the tab is next to the previous right
        pData->tab[i].tab_rect.left = left;

        // the tab bottom is down the footroom from the text bottom
        pData->tab[i].tab_rect.bottom = pData->tab[i].text_rect.bottom +
                                        FOOTROOM_Y*yWidth;

        // the tab right is over the size of the angle from the text right
        pData->tab[i].tab_rect.right = pData->tab[i].text_rect.right +
                                       ANGLE_Y*yWidth;

        // set the left for the next guy to be our right
        left = pData->tab[i].tab_rect.right;

        // set the bottom of the all tabs rectangle
        pData->tabs_rect.bottom = max( pData->tabs_rect.bottom, 
                                       pData->tab[i].tab_rect.bottom);

        // BUGBUG check for run off the side
    }

    // set the rest of the cumulative tabs rect
    pData->tabs_rect.top = total_rect.top;
    pData->tabs_rect.right = total_rect.right;
    pData->tabs_rect.left = total_rect.left;
    // BUGBUG why
    pData->tabs_rect.bottom++;

    // reset the font
    SelectObject( hdc, hfOldFont );

    // free up the resources used
    ReleaseDC( hwnd, hdc );
}



//////////////////////////////////////////////////////////////////////////////
// BookTab_()
//
// 
//
// Input:
//      hwnd - our window handle
//
// Returns:
//      
//
// History
//      Arthur Brooking  8/06/93 created     
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\transfer.c ===
/*
  +-------------------------------------------------------------------------+
  |                 Netware to Windows NT Transfer Loop                     |
  +-------------------------------------------------------------------------+
  |                     (c) Copyright 1993-1994                             |
  |                          Microsoft Corp.                                |
  |                        All rights reserved                              |
  |                                                                         |
  | Program               : [Transfer.c]                                    |
  | Programmer            : Arthur Hanson                                   |
  | Original Program Date : [Jul 27, 1993]                                  |
  | Last Update           : [Jun 16, 1994]                                  |
  |                                                                         |
  | Version:  1.00                                                          |
  |                                                                         |
  | Description:                                                            |
  |                                                                         |
  | History:                                                                |
  |   arth  June 16, 1994    1.00    Original Version.                      |
  |                                                                         |
  +-------------------------------------------------------------------------+
*/


#include "globals.h"

#include <stdio.h>
#include <stdarg.h>
#include <limits.h>
#include <time.h>

#include "nwconv.h"
#include "convapi.h"
#include "ntnetapi.h"
#include "nwnetapi.h"
#include "userdlg.h"
#include "statbox.h"
#include "filedlg.h"
#include "map.h"

#define NWC_ERR_IGNORE 1
#define NWC_ERR_NAMELONG 2
#define NWC_ERR_DUPLICATE 3
#define NWC_ERR_NAMEINVALID 4

#define ILLEGAL_CHARS TEXT("\"\\/[]:;=,+*?<>")

// define for routines in fcopy.c
void ConvertFiles(HWND hDlg, BOOL TConversion, USER_LIST *Users, GROUP_LIST *Groups);
void ConvertFilesInit(HWND hDlg);
void VSharesCreate(DEST_SERVER_BUFFER *DServ, BOOL TConversion);

// Cache of user and group lists
typedef struct _LIST_CACHE {
   struct _LIST_CACHE *next;
   ULONG Count;
   void *ul;
} LIST_CACHE;

static LIST_CACHE *UserCacheHead = NULL;
static LIST_CACHE *GroupCacheHead = NULL;

// Misc string holders
static LPTSTR LocalName = NULL;
static LPTSTR SourceServer, DestServer;
TCHAR UserServerName[MAX_SERVER_NAME_LEN + 3];
static TCHAR tmpStr[80];
static TCHAR tmpStr2[60];
static TCHAR ErrorText[256];
static TCHAR NewName[256];
static TCHAR pLine[256];

static CONVERT_OPTIONS *ConvOpt = NULL;
static FILE_OPTIONS *FileOptions = NULL;
static BOOL TConversion;
static BOOL WarningDlgForNTFS;

// Totals for stat box
static UINT TotErrors;
static UINT TotGroups;
static UINT TotUsers;
static UINT TotConversions;
UINT TotFiles;
time_t StartTime;
time_t CurrTime;

// User and Group list pointers
static USER_LIST *Users = NULL;
static USER_LIST *NTUsers = NULL;
static GROUP_LIST *Groups = NULL;
static GROUP_LIST *NTGroups = NULL;
static DWORD UserCount, NTUserCount;
static DWORD GroupCount, NTGroupCount;
static BOOL TransferCancel = FALSE;

static MAP_FILE *hMap;

// All of this is used for transfer lists in the conversion
#define USER_SERVER 0
#define USER_SERVER_PDC 1
#define USER_SERVER_TRUSTED 2

typedef struct _TRANSFER_BUFFER {
   LPTSTR ServerName;
   UINT UserServerType;
   CONVERT_LIST *ConvertList;
} TRANSFER_BUFFER;
  
typedef struct _TRANSFER_LIST {
   ULONG Count;
   TRANSFER_BUFFER TList[];
} TRANSFER_LIST;


/*+-------------------------------------------------------------------------+
  | ErrorIt()
  |
  +-------------------------------------------------------------------------+*/
void ErrorIt(LPTSTR szFormat, ...) {
   static TCHAR tmpStr[1024];
   va_list marker;

   va_start(marker, szFormat);

   wvsprintf(tmpStr, szFormat, marker);
#ifdef DEBUG
   dprintf(TEXT("Errorit: %s\n"), tmpStr);
#endif

   TotErrors++;
   Status_TotErrors(TotErrors);
   LogWriteErr(TEXT("%s"),tmpStr);
   va_end(marker);

} // ErrorIt


/*+-------------------------------------------------------------------------+
  |                          NTFS Check Routines                            |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | ShareListNTFSCheck()
  |
  +-------------------------------------------------------------------------+*/
BOOL ShareListNTFSCheck() {
   CONVERT_LIST *ConvList;
   DEST_SERVER_BUFFER *DServ;
   SOURCE_SERVER_BUFFER *SServ;
   SHARE_LIST *ShareList;
   SHARE_BUFFER *SList;
   VIRTUAL_SHARE_BUFFER *VShare;
   DRIVE_BUFFER *Drive;
   ULONG i;
   FILE_OPTIONS *FileOptions;

   // Go through the convert list checking for any shares to non NTFS drives
   ConvList = ConvertListStart;

   while (ConvList != NULL) {
      DServ = ConvList->FileServ;
      SServ = ConvList->SourceServ;

      FileOptions = (FILE_OPTIONS *) ConvList->FileOptions;
      if (FileOptions->TransferFileInfo) {
         ShareList = SServ->ShareList;

         if (ShareList != NULL) {

            SList = ShareList->SList;
            for (i = 0; i < ShareList->Count; i++) {

               // if not flagged as okay for going to fat, then must check
               if (SList[i].Convert && !SList[i].ToFat)
                  if (SList[i].DestShare != NULL)
                     if (SList[i].Virtual) {
                        VShare = (VIRTUAL_SHARE_BUFFER *) SList[i].DestShare;
                        Drive = VShare->Drive;

                        if ((Drive == NULL) || (Drive->Type != DRIVE_TYPE_NTFS))
                              return FALSE;
                     } else {
                        Drive = SList[i].DestShare->Drive;
                        
                        if ((Drive == NULL) || (Drive->Type != DRIVE_TYPE_NTFS))
                              return FALSE;
                     }
            } // for loop through shares

         }

      } // if FileOptions

      ConvList = ConvList->next;
   }

   return TRUE;

} // ShareListNTFSCheck


/*+-------------------------------------------------------------------------+
  | ShareListNTFSListboxFill()
  |
  +-------------------------------------------------------------------------+*/
void ShareListNTFSListboxFill(HWND hDlg) {
   TCHAR AddLine[256];
   CONVERT_LIST *ConvList;
   DEST_SERVER_BUFFER *DServ;
   SOURCE_SERVER_BUFFER *SServ;
   SHARE_LIST *ShareList;
   SHARE_BUFFER *SList;
   VIRTUAL_SHARE_BUFFER *VShare;
   DRIVE_BUFFER *Drive;
   ULONG i;
   HWND hCtrl;
   FILE_OPTIONS *FileOptions;

   // Go through the convert list checking for any shares to non NTFS drives
   ConvList = ConvertListStart;
   hCtrl = GetDlgItem(hDlg, IDC_LIST1);

   while (ConvList != NULL) {
      DServ = ConvList->FileServ;
      SServ = ConvList->SourceServ;

      FileOptions = (FILE_OPTIONS *) ConvList->FileOptions;
      if (FileOptions->TransferFileInfo) {
         ShareList = SServ->ShareList;

         if (ShareList != NULL) {

            SList = ShareList->SList;
            for (i = 0; i < ShareList->Count; i++) {

               // if not flagged as okay for going to fat, then must check
               if (SList[i].Convert && !SList[i].ToFat)
                  if (SList[i].DestShare != NULL)
                     if (SList[i].Virtual) {
                        VShare = (VIRTUAL_SHARE_BUFFER *) SList[i].DestShare;
                        Drive = VShare->Drive;

                        if ((Drive == NULL) || (Drive->Type != DRIVE_TYPE_NTFS)) {
                              wsprintf(AddLine, TEXT("%s\\%s: -> \\\\%s\\%s"), SServ->Name, SList[i].Name, DServ->Name, VShare->Name);
                              SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) AddLine);
                           }
                     } else {
                        Drive = SList[i].DestShare->Drive;
                     
                        if ((Drive == NULL) || (Drive->Type != DRIVE_TYPE_NTFS)) {
                              wsprintf(AddLine, TEXT("%s\\%s: -> \\\\%s\\%s"), SServ->Name, SList[i].Name, DServ->Name, SList[i].DestShare->Name);
                              SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) AddLine);
                           }
                     }
            } // for loop through shares

         }
      } // if FileOptions

      ConvList = ConvList->next;
   }

} // ShareListNTFSListboxFill


/*+-------------------------------------------------------------------------+
  | ShareListFATOK()
  |
  +-------------------------------------------------------------------------+*/
void ShareListFATOK() {
   CONVERT_LIST *ConvList;
   DEST_SERVER_BUFFER *DServ;
   SOURCE_SERVER_BUFFER *SServ;
   SHARE_LIST *ShareList;
   SHARE_BUFFER *SList;
   ULONG i;
   FILE_OPTIONS *FileOptions;

   // Go through the convert list checking for any shares to non NTFS drives
   ConvList = ConvertListStart;

   while (ConvList != NULL) {
      DServ = ConvList->FileServ;
      SServ = ConvList->SourceServ;

      FileOptions = (FILE_OPTIONS *) ConvList->FileOptions;
      if (FileOptions->TransferFileInfo) {
         ShareList = SServ->ShareList;
   
         if (ShareList != NULL) {

            SList = ShareList->SList;
            for (i = 0; i < ShareList->Count; i++) {
               if (SList[i].Convert)
                  SList[i].ToFat = TRUE;
            }

         }
      } // if FileOptions

      ConvList = ConvList->next;
   }

} // ShareListFATOK


/*+-------------------------------------------------------------------------+
  |                          Space Check Routines                           |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | ShareListSpaceCheck()
  |
  +-------------------------------------------------------------------------+*/
BOOL ShareListSpaceCheck() {
   CONVERT_LIST *ConvList;
   DEST_SERVER_BUFFER *DServ;
   SOURCE_SERVER_BUFFER *SServ;
   SHARE_LIST *ShareList;
   SHARE_BUFFER *SList;
   VIRTUAL_SHARE_BUFFER *VShare;
   DRIVE_BUFFER *Drive;
   ULONG i;
   FILE_OPTIONS *FileOptions;

   // Go through the convert list checking for any shares to non NTFS drives
   ConvList = ConvertListStart;

   while (ConvList != NULL) {
      DServ = ConvList->FileServ;
      SServ = ConvList->SourceServ;

      FileOptions = (FILE_OPTIONS *) ConvList->FileOptions;
      if (FileOptions->TransferFileInfo) {
         ShareList = SServ->ShareList;

         if (ShareList != NULL) {

            SList = ShareList->SList;
            for (i = 0; i < ShareList->Count; i++) {

               if (SList[i].Convert && (SList[i].DestShare != NULL))
                  if (SList[i].Virtual) {
                     VShare = (VIRTUAL_SHARE_BUFFER *) SList[i].DestShare;
                     Drive = VShare->Drive;

                     if ((Drive == NULL) || (Drive->AllocSpace > Drive->FreeSpace))
                           return FALSE;
                  } else {
                     Drive = SList[i].DestShare->Drive;
                    
                     if ((Drive == NULL) || (Drive->AllocSpace > Drive->FreeSpace))
                           return FALSE;
                  }
            } // for loop through shares

         }
      } // if FileOptions

      ConvList = ConvList->next;
   }

   return TRUE;

} // ShareListSpaceCheck


/*+-------------------------------------------------------------------------+
  | ShareListSpaceListboxFill()
  |
  +-------------------------------------------------------------------------+*/
void ShareListSpaceListboxFill(HWND hDlg) {
   TCHAR AddLine[256];
   TCHAR Free[25];
   CONVERT_LIST *ConvList;
   DEST_SERVER_BUFFER *DServ;
   SOURCE_SERVER_BUFFER *SServ;
   SHARE_LIST *ShareList;
   SHARE_BUFFER *SList;
   VIRTUAL_SHARE_BUFFER *VShare;
   DRIVE_BUFFER *Drive;
   ULONG i;
   HWND hCtrl;
   FILE_OPTIONS *FileOptions;

   // Go through the convert list checking for any shares to non NTFS drives
   ConvList = ConvertListStart;
   hCtrl = GetDlgItem(hDlg, IDC_LIST1);

   while (ConvList != NULL) {
      DServ = ConvList->FileServ;
      SServ = ConvList->SourceServ;

      FileOptions = (FILE_OPTIONS *) ConvList->FileOptions;
      if (FileOptions->TransferFileInfo) {
         ShareList = SServ->ShareList;

         if (ShareList != NULL) {

            SList = ShareList->SList;
            for (i = 0; i < ShareList->Count; i++) {

               if (SList[i].Convert && (SList[i].DestShare != NULL))
                  if (SList[i].Virtual) {
                     VShare = (VIRTUAL_SHARE_BUFFER *) SList[i].DestShare;
                     Drive = VShare->Drive;

                     if (Drive != NULL) {
                        if (Drive->AllocSpace > Drive->FreeSpace) {
                           // List shares then space
                           wsprintf(AddLine, TEXT("%s\\%s: -> \\\\%s\\%s"), SServ->Name, SList[i].Name, DServ->Name, VShare->Name);
                           SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) AddLine);

                           lstrcpy(Free, lToStr(Drive->FreeSpace));
                           wsprintf(AddLine, Lids(IDS_D_13), Free, lToStr(Drive->AllocSpace));
                           SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) AddLine);
                        }
                     } else {
                        wsprintf(AddLine, TEXT("%s\\%s: -> \\\\%s\\%s"), SServ->Name, SList[i].Name, DServ->Name, VShare->Name);
                        SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) AddLine);

                        wsprintf(AddLine, Lids(IDS_D_14));
                        SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) AddLine);
                     }
                  } else {
                     Drive = SList[i].DestShare->Drive;
                     
                     if (Drive != NULL) {
                        if (Drive->AllocSpace > Drive->FreeSpace) {
                           // List shares then space
                           wsprintf(AddLine, TEXT("%s\\%s: -> \\\\%s\\%s"), SServ->Name, SList[i].Name, DServ->Name, SList[i].DestShare->Name);
                           SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) AddLine);

                           lstrcpy(Free, lToStr(Drive->FreeSpace));
                           wsprintf(AddLine, Lids(IDS_D_13), Free, lToStr(Drive->AllocSpace));
                           SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) AddLine);
                        }
                     } else {
                        wsprintf(AddLine, TEXT("%s\\%s: -> \\\\%s\\%s"), SServ->Name, SList[i].Name, DServ->Name, SList[i].DestShare->Name);
                        SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) AddLine);

                        wsprintf(AddLine, Lids(IDS_D_14));
                        SendMessage(hCtrl, LB_ADDSTRING, (WPARAM) 0, (LPARAM) AddLine);
                     }
                  } // if Virtual

            } // for loop through shares

         }
      } // if FileOptions

      ConvList = ConvList->next;
   }

} // ShareListSpaceListboxFill


/*+-------------------------------------------------------------------------+
  |                    Conversion Warning Dialog                            |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | DlgConversionWarning()
  |
  +-------------------------------------------------------------------------+*/
LRESULT CALLBACK DlgConversionWarning(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
   int wmId, wmEvent;

   switch (message) {
      case WM_INITDIALOG:
         // Center the dialog over the application window
         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));

         if (WarningDlgForNTFS) {
            SendDlgItemMessage(hDlg, IDC_PANEL1, WM_SETTEXT, 0, (LPARAM) Lids(IDS_D_15));
            ShareListNTFSListboxFill(hDlg);
         } else {
            SendDlgItemMessage(hDlg, IDC_PANEL1, WM_SETTEXT, 0, (LPARAM) Lids(IDS_D_16));
            ShareListSpaceListboxFill(hDlg);
         }

         return (TRUE);

      case WM_COMMAND:
         wmId    = LOWORD(wParam);
         wmEvent = HIWORD(wParam);

         switch (wmId) {
            case IDYES:
               if (WarningDlgForNTFS)
                  ShareListFATOK();

               EndDialog(hDlg, 0);
               return (TRUE);
               break;

            case IDNO:
               TransferCancel = TRUE;
               EndDialog(hDlg, 0);
               return (TRUE);
               break;

         }

         break;
   }

   return (FALSE); // Didn't process the message

   lParam;
} // DlgConversionWarning


/*+-------------------------------------------------------------------------+
  | ConversionWarningDlg_Do()
  |
  +-------------------------------------------------------------------------+*/
void ConversionWarningDlg_Do(HWND hDlg) {
   DLGPROC lpfnDlg;

   lpfnDlg = MakeProcInstance((DLGPROC) DlgConversionWarning, hInst);
   DialogBox(hInst, TEXT("AlertSel"), hDlg, lpfnDlg) ;
   FreeProcInstance(lpfnDlg);

} // ConversionWarningDlg_Do


/*+-------------------------------------------------------------------------+
  | NTFSCheck()
  |
  +-------------------------------------------------------------------------+*/
void NTFSCheck(HWND hDlg) {
   WarningDlgForNTFS = TRUE;

   if (!ShareListNTFSCheck())
      ConversionWarningDlg_Do(hDlg);

} // NTFSCheck


/*+-------------------------------------------------------------------------+
  | SpaceCheck()
  |
  +-------------------------------------------------------------------------+*/
void SpaceCheck(HWND hDlg) {
   WarningDlgForNTFS = FALSE;

   if (!ShareListSpaceCheck())
      ConversionWarningDlg_Do(hDlg);

} // SpaceCheck



/*+-------------------------------------------------------------------------+
  |                       End of Conversion Dialog                          |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | DlgConversionEnd()
  |
  +-------------------------------------------------------------------------+*/
LRESULT CALLBACK DlgConversionEnd(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
   HANDLE hFile;
   int wmId, wmEvent;
   static char CmdLine[256];
   HWND hCtrl;

   switch (message) {
      case WM_INITDIALOG:
         // Center the dialog over the application window
         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));

         hCtrl = GetDlgItem(hDlg, IDC_VIEWLOG);
         
         // check if logfile exists, if it does allow log file viewing...
         hFile = CreateFileA( "LogFile.LOG", GENERIC_READ, 0, NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, NULL);

         if (hFile != (HANDLE) INVALID_HANDLE_VALUE)
            CloseHandle( hFile );
         else
            EnableWindow(hCtrl, FALSE);

         SendDlgItemMessage(hDlg, IDC_S_TOT_COMP, WM_SETTEXT, 0, (LPARAM) lToStr(TotConversions));
         SendDlgItemMessage(hDlg, IDC_S_TOT_GROUPS, WM_SETTEXT, 0, (LPARAM) lToStr(TotGroups));
         SendDlgItemMessage(hDlg, IDC_S_TOT_USERS, WM_SETTEXT, 0, (LPARAM) lToStr(TotUsers));
         SendDlgItemMessage(hDlg, IDC_S_TOT_FILES, WM_SETTEXT, 0, (LPARAM) lToStr(TotFiles));
         SendDlgItemMessage(hDlg, IDC_S_TOT_ERRORS, WM_SETTEXT, 0, (LPARAM) lToStr(TotErrors));

         if (TransferCancel)
            SendMessage(hDlg, WM_SETTEXT, (WPARAM) 0, (LPARAM) Lids(IDS_D_17));

         return (TRUE);

      case WM_COMMAND:
         wmId    = LOWORD(wParam);
         wmEvent = HIWORD(wParam);

         switch (wmId) {
            case IDOK:
            case IDCANCEL:
               EndDialog(hDlg, 0);
               return (TRUE);
               break;

            case IDC_VIEWLOG:
               lstrcpyA(CmdLine, "LogView ");
               lstrcatA(CmdLine, "Error.LOG Summary.LOG LogFile.LOG");
               WinExec(CmdLine, SW_SHOW);
               return (TRUE);
               break;

         }

         break;
   }

   return (FALSE); // Didn't process the message

   lParam;
} // DlgConversionEnd


/*+-------------------------------------------------------------------------+
  | ConversionEndDlg_Do()
  |
  +-------------------------------------------------------------------------+*/
void ConversionEndDlg_Do(HWND hDlg) {
   DLGPROC lpfnDlg;

   lpfnDlg = MakeProcInstance((DLGPROC) DlgConversionEnd, hInst);
   DialogBox(hInst, TEXT("ConversionEnd"), hDlg, lpfnDlg) ;
   FreeProcInstance(lpfnDlg);

} // ConversionEndDlg_Do



/*+-------------------------------------------------------------------------+
  |                  User / Group lists and Cache routines                  |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | FindUserMatch()
  |
  |   Searches through the user list using a binary search.  Returns a
  |   pointer to the found user record or NULL if no match.
  |
  +-------------------------------------------------------------------------+*/
USER_BUFFER *FindUserMatch(LPTSTR Name, USER_LIST *UserList, BOOL NewName) {
   LONG begin = 0;
   LONG end;
   LONG cur;
   int match;
   USER_BUFFER *UserBuffer;

   if (UserList == NULL)
      return NULL;

   UserBuffer = UserList->UserBuffer;
   end = UserList->Count - 1;

   while (end >= begin) {
      // go halfway in-between
      cur = (begin + end) / 2;

      // compare the two result into match
      if (NewName)
         match = lstrcmpi(Name, UserBuffer[cur].NewName);
      else
         match = lstrcmpi(Name, UserBuffer[cur].Name);

      if (match < 0)
         // move new begin
         end = cur - 1;
      else
         begin = cur + 1;

      if (match == 0)
         return &UserBuffer[cur];
   }

   return NULL;

} // FindUserMatch


/*+-------------------------------------------------------------------------+
  | FindGroupMatch()
  |
  |   Searches through the group list using a binary search.  Returns a
  |   pointer to the found group record or NULL if no match.
  |
  +-------------------------------------------------------------------------+*/
GROUP_BUFFER *FindGroupMatch(LPTSTR Name, GROUP_LIST *GroupList, BOOL NewName) {
   LONG begin = 0;
   LONG end;
   LONG cur;
   int match;
   GROUP_BUFFER *GroupBuffer;

   if (GroupList == NULL)
      return NULL;

   GroupBuffer = GroupList->GroupBuffer;
   end = GroupList->Count - 1;

   while (end >= begin) {
      // go halfway in-between
      cur = (begin + end) / 2;

      // compare the two result into match
      if (NewName)
         match = lstrcmpi(Name, GroupBuffer[cur].NewName);
      else
         match = lstrcmpi(Name, GroupBuffer[cur].Name);

      if (match < 0)
         // move new begin
         end = cur - 1;
      else
         begin = cur + 1;

      if (match == 0)
         return &GroupBuffer[cur];
   }

   return NULL;

} // FindGroupMatch


/*+-------------------------------------------------------------------------+
  | The List Cache's are a linked list of previously converted user and
  | group lists.  This is mostly for when running trial conversions you can
  | check if a previously transferred name conflicts with a new name (since
  | the name won't actually be out on the destination server).
  |
  | The Cache is kept around while working with the same destination server
  | or domain.  Once a new domain/server is selected the cache and all lists
  | should be freed.
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | ListCachePut()
  |
  +-------------------------------------------------------------------------+*/
BOOL ListCachePut(LIST_CACHE **CacheHead, void *ul, ULONG Count) {
   LIST_CACHE *cc;
   LIST_CACHE *pc;

   cc =  (LIST_CACHE *) AllocMemory(sizeof(LIST_CACHE));

   if (cc == NULL)
      return FALSE;

   // Init the cache entry
   cc->next = NULL;
   cc->Count = Count;
   cc->ul = ul;

   // Now put it at the end of the chain
   if (*CacheHead == NULL) {
      *CacheHead = cc;
      return TRUE;
   }

   pc = *CacheHead;
   while (pc->next)
      pc = pc->next;

   pc->next = cc;
   return TRUE;

} // ListCachePut


/*+-------------------------------------------------------------------------+
  | ListCacheFree()
  |
  +-------------------------------------------------------------------------+*/
void ListCacheFree(LIST_CACHE **CacheHead) {
   LIST_CACHE *cc;
   LIST_CACHE *pc;

   cc = *CacheHead;

   while (cc) {
      // Free the user list attached to this cache entry
      FreeMemory(cc->ul);

      // Save next cache entry
      pc = cc->next;

      // Free up the cache entry and loop
      FreeMemory(cc);
      cc = pc;
   }

   *CacheHead = NULL;

} // ListCacheFree


/*+-------------------------------------------------------------------------+
  | UserCacheMatch()
  |
  +-------------------------------------------------------------------------+*/
BOOL UserCacheMatch(LPTSTR UserName) {
   LIST_CACHE *cc;
   BOOL match = FALSE;

   cc = UserCacheHead;

   // loop through the cache entries and try to match with each user list
   while (cc && !match) {
      if (FindUserMatch(UserName, (USER_LIST *) cc->ul, TRUE))
         match = TRUE;
      else
         cc = cc->next;
   }

   return match;

} // UserCacheMatch


/*+-------------------------------------------------------------------------+
  | GroupCacheMatch()
  |
  +-------------------------------------------------------------------------+*/
BOOL GroupCacheMatch(LPTSTR GroupName) {
   LIST_CACHE *cc;
   BOOL match = FALSE;

   cc = GroupCacheHead;

   // loop through the cache entries and try to match with each user list
   while (cc && !match) {
      if (FindGroupMatch(GroupName, (GROUP_LIST *) cc->ul, TRUE))
         match = TRUE;
      else
         cc = cc->next;
   }

   return match;

} // GroupCacheMatch


/*+-------------------------------------------------------------------------+
  |                              Logging Garbage                            |
  +-------------------------------------------------------------------------+*/

/*+-------------------------------------------------------------------------+
  | ConvertOptionsLog()
  |
  |   Writes all the admin selected conversion options to the log file.
  |
  +-------------------------------------------------------------------------+*/
void ConvertOptionsLog() {

   LogWriteLog(0, Lids(IDS_L_136));

   if (ConvOpt->TransferUserInfo)
      LogWriteLog(1, Lids(IDS_L_137), Lids(IDS_YES));
   else
      LogWriteLog(1, Lids(IDS_L_137), Lids(IDS_NO));

   LogWriteLog(0, Lids(IDS_CRLF));

   if (ConvOpt->TransferUserInfo) {
      LogWriteLog(1, Lids(IDS_L_140));

      if (ConvOpt->UseMappingFile) {
         LogWriteLog(2, Lids(IDS_L_138), Lids(IDS_YES));
         LogWriteLog(3, Lids(IDS_L_139), ConvOpt->MappingFile);
      } else {
         LogWriteLog(2, Lids(IDS_L_138), Lids(IDS_NO));

         // Password Options
         LogWriteLog(2, Lids(IDS_L_141));
         switch (ConvOpt->PasswordOption) {
            case 0: // Use NULL
               LogWriteLog(0, Lids(IDS_L_142));
               break;

            case 1: // Password is username
               LogWriteLog(0, Lids(IDS_L_143));
               break;

            case 2: // Use constant
               LogWriteLog(0, Lids(IDS_L_144), ConvOpt->PasswordConstant);
               break;
         }
      }

      if (ConvOpt->ForcePasswordChange)
         LogWriteLog(3, Lids(IDS_L_145), Lids(IDS_YES));
      else
         LogWriteLog(3, Lids(IDS_L_145), Lids(IDS_NO));

      if (!ConvOpt->UseMappingFile) {
         // User Names Options
         LogWriteLog(2, Lids(IDS_L_146));

         switch (ConvOpt->UserNameOption) {
            case 0: // Don't transfer - log failures
               LogWriteLog(0, Lids(IDS_L_148));
               break;

            case 1: // Ignore
               LogWriteLog(0, Lids(IDS_L_149));
               break;

            case 2: // Overwrite with new info
               LogWriteLog(0, Lids(IDS_L_151));
               break;

            case 3: // Pre-Pend constant
               LogWriteLog(0, Lids(IDS_L_150), ConvOpt->UserConstant);
               break;
         }

         LogWriteLog(0, Lids(IDS_CRLF));

         // Group Names Options
         LogWriteLog(2, Lids(IDS_L_147));

         switch (ConvOpt->GroupNameOption) {
            case 0: // Don't transfer - log failures
               LogWriteLog(0, Lids(IDS_L_148));
               break;

            case 1: // Overwrite with new info
               LogWriteLog(0, Lids(IDS_L_149));
               break;

            case 2: // Pre-Pend constant
               LogWriteLog(0, Lids(IDS_L_150), ConvOpt->GroupConstant);
               break;
         }

         LogWriteLog(0, Lids(IDS_CRLF));
      }

      if (ConvOpt->SupervisorDefaults)
         LogWriteLog(2, Lids(IDS_L_152), Lids(IDS_YES));
      else
         LogWriteLog(2, Lids(IDS_L_152), Lids(IDS_NO));

      if (ConvOpt->AdminAccounts)
         LogWriteLog(2, Lids(IDS_L_153), Lids(IDS_YES));
      else
         LogWriteLog(2, Lids(IDS_L_153), Lids(IDS_NO));

      if (ConvOpt->UseTrustedDomain && (ConvOpt->TrustedDomain != NULL))
         LogWriteLog(2, Lids(IDS_L_154), ConvOpt->TrustedDomain->Name);

      LogWriteLog(0, Lids(IDS_CRLF));
   }

   LogWriteLog(0, Lids(IDS_CRLF));

} // ConvertOptionsLog


/*+-------------------------------------------------------------------------+
  | OptionsFileLog()
  |
  +-------------------------------------------------------------------------+*/
void OptionsFileLog() {
   LogWriteLog(0, Lids(IDS_L_155));

   if (FileOptions->TransferFileInfo)
      LogWriteLog(1, Lids(IDS_L_156), Lids(IDS_YES));
   else
      LogWriteLog(1, Lids(IDS_L_156), Lids(IDS_NO));

   LogWriteLog(0, Lids(IDS_CRLF));
} // OptionsFileLog


/*+-------------------------------------------------------------------------+
  | ConvertPairLog()
  |
  +-------------------------------------------------------------------------+*/
void ConvertPairLog() {
   LogWriteLog(0, Lids(IDS_LINE));
   wsprintf(tmpStr, Lids(IDS_L_157), SourceServer);
   LogWriteLog(0, Lids(IDS_BRACE), tmpStr);

   wsprintf(tmpStr, Lids(IDS_L_158), DestServer);
   LogWriteLog(0, Lids(IDS_BRACE), tmpStr);

   LogWriteLog(0, Lids(IDS_LINE));
   GetTime(tmpStr2);
   wsprintf(tmpStr, Lids(IDS_L_159), tmpStr2);
   LogWriteLog(0, Lids(IDS_BRACE), tmpStr);
   LogWriteLog(0, Lids(IDS_LINE));
   LogWriteLog(0, Lids(IDS_CRLF));

   LogWriteSummary(0, Lids(IDS_CRLF));
   LogWriteSummary(0, TEXT("[%s -> %s]\r\n"), SourceServer, DestServer);
   ErrorContextSet(TEXT("[%s -> %s]\r\n"), SourceServer, DestServer);

} // ConvertPairLog


/*+-------------------------------------------------------------------------+
  | UsersLogNames()
  |
  +-------------------------------------------------------------------------+*/
void UsersLogNames(USER_LIST *Users) {
   ULONG i;
   DWORD UserCount;
   USER_BUFFER *UserBuffer;

   if (Users == NULL)
      return;

   UserCount = Users->Count;
   UserBuffer = Users->UserBuffer;

   if (UserCount) {
      LogWriteLog(1, Lids(IDS_L_160));
      LogWriteLog(1, Lids(IDS_L_161));

      // Check Mapping File
      for (i = 0; i < UserCount; i++) {
         if (UserBuffer[i].IsNewName)
            wsprintf(pLine, TEXT("%s -> %s"), UserBuffer[i].Name, UserBuffer[i].NewName);
         else
            wsprintf(pLine, TEXT("%s"), UserBuffer[i].NewName);

         LogWriteLog(1, TEXT(" %-50s"), pLine);

         if (UserBuffer[i].err) {
            if (UserBuffer[i].err == NWC_ERR_NAMELONG)
               LogWriteLog(0, Lids(IDS_L_162));

            if (UserBuffer[i].err == NWC_ERR_DUPLICATE)
               LogWriteLog(0, Lids(IDS_L_163));

            if (UserBuffer[i].err == NWC_ERR_NAMEINVALID)
               LogWriteLog(0, Lids(IDS_L_164));

         }

         // Need to check this seperatly - as it's not an error
         if (UserBuffer[i].Overwrite)
            LogWriteLog(0, Lids(IDS_L_163));

         LogWriteLog(0, Lids(IDS_CRLF));

      }

      LogWriteLog(0, Lids(IDS_CRLF));
   }

} // UsersLogNames


/*+-------------------------------------------------------------------------+
  | UserNewName_Check()
  |
  +-------------------------------------------------------------------------+*/
void UserNewName_Check(USER_BUFFER *Users) {
   // We have done any mappings that need to be done, now check for
   // name validity if there is a new name...
   if (Users->IsNewName)
      if (UserCacheMatch(Users->NewName)) {
         Users->err = NWC_ERR_DUPLICATE;
      }

   if (lstrlen(Users->NewName) > MAX_NT_USER_NAME_LEN) {
      // Name is too long
      Users->err = NWC_ERR_NAMELONG;
   }

   // Check if a valid name (no illegal characters)...
   if ((int) wcscspn(Users->NewName, ILLEGAL_CHARS) < (int) lstrlen(Users->NewName))
      Users->err = NWC_ERR_NAMEINVALID;

} // UserNewName_Check


/*+-------------------------------------------------------------------------+
  | UserNames_Resolve()
  |
  +-------------------------------------------------------------------------+*/
void UserNames_Resolve(USER_BUFFER *Users) {
   LPTSTR TheName;
   LPTSTR ErrorText;
   ULONG RetType;

   // Figure out which name to use
   if (Users->IsNewName)
      TheName = Users->Name;
   else
      TheName = Users->NewName;

   // If using mapping file then map the name appropriatly
   if (ConvOpt->UseMappingFile) {
      if (UserCacheMatch(TheName))
         Users->err = NWC_ERR_DUPLICATE;
   } else {
      // check if the user name is in the destination list (duplicate)
      if (UserCacheMatch(TheName)) {
         // There was - so figure out based on conversion options what
         // to do with it...
         switch (ConvOpt->UserNameOption) {
            case 0: // Log Errors
               Users->err = NWC_ERR_DUPLICATE;
               break;

            case 1: // ignore
               Users->err = NWC_ERR_IGNORE;
               break;

            case 2: // Overwrite
               Users->Overwrite = TRUE;
               break;

            case 3: // Pre-Pend constant
               lstrcpy(NewName, ConvOpt->UserConstant);
               lstrcat(NewName, Users->Name);
               lstrcpy(Users->NewName, NewName);
               Users->IsNewName = TRUE;
               break;
         } // switch
      }
   }

   do {
      RetType = IDIGNORE;
      UserNewName_Check(Users);

      if (Users->err && (Users->err != NWC_ERR_IGNORE) && PopupOnError()) {
         switch(Users->err) {
            case NWC_ERR_NAMELONG:
               ErrorText = Lids(IDS_L_165);
               break;

            case NWC_ERR_DUPLICATE:
               ErrorText = Lids(IDS_L_166);
               break;

            case NWC_ERR_NAMEINVALID:
               ErrorText = Lids(IDS_L_167);
               break;

         }

         RetType = UserNameErrorDlg_Do(Lids(IDS_L_168), ErrorText, Users);
      }
   } while (RetType == IDRETRY);

   if (RetType == IDABORT)
      TransferCancel = TRUE;

} // UserNames_Resolve


/*+-------------------------------------------------------------------------+
  | UserSave()
  |
  |    Given a user-name, moves their account information from the source
  |    to the destination server.
  |
  +-------------------------------------------------------------------------+*/
BOOL UserSave(BOOL *NWInfo, LPTSTR origUserName, LPTSTR newUserName, NT_USER_INFO *NTInfo, void **OldInfo, BOOL Replace) {
   NET_API_STATUS ret = 0;
   void *NWUInfo;
   FPNW_INFO fpnw;
   static TCHAR ServerName[MAX_SERVER_NAME_LEN+3];   // +3 for leading slashes and ending NULL

   *NWInfo = FALSE;

   // Overlay NetWare info into record
   NWUserInfoGet(origUserName, OldInfo);
   NWUInfo = *OldInfo;

   if (NWUInfo == NULL)
      return FALSE;

   *NWInfo = TRUE;
   NWNetUserMapInfo(origUserName, NWUInfo, NTInfo);

   // Force user to change password if required
   if (ConvOpt->ForcePasswordChange)
      NTInfo->password_expired = (DWORD) (-1L);

   // Now get/map special FPNW info
   if (ConvOpt->NetWareInfo) {
      NWFPNWMapInfo(NWUInfo, &fpnw);
   }

   if (!TConversion)
      if (Replace)
         if (ConvOpt->NetWareInfo)
            ret = NTUserInfoSet(NTInfo, &fpnw);
         else
            ret = NTUserInfoSet(NTInfo, NULL);
      else
         if (ConvOpt->NetWareInfo)
            ret = NTUserInfoSave(NTInfo, &fpnw);
         else
            ret = NTUserInfoSave(NTInfo, NULL);

   if (ret)
      return FALSE;
   else {
      // now save out FPNW Info
      if (ConvOpt->NetWareInfo)
         NTSAMParmsSet(newUserName, fpnw, NTInfo->password, ConvOpt->ForcePasswordChange);

      return TRUE;
   }

} // UserSave


/*+-------------------------------------------------------------------------+
  | UsersConvert()
  |
  +-------------------------------------------------------------------------+*/
void UsersConvert() {
   static TCHAR Password[MAX_PW_LEN + 1];
   USER_BUFFER *UserBuffer = NULL;
   BOOL NWInfo;
   DWORD status = 0;
   DWORD i;
   void *NW_UInfo;
   static NT_USER_INFO NT_UInfo;
   ULONG TotConv = 0;

   Status_ConvTxt(Lids(IDS_D_18));
   Status_ItemLabel(Lids(IDS_D_19));

   Status_CurTot((UINT) UserCount);

   LogWriteLog(0, Lids(IDS_L_169));
   LogWriteLog(1, Lids(IDS_L_170), UserCount);
   ErrorCategorySet(Lids(IDS_L_171));

   if (Users == NULL)
      return;

   UserBuffer = Users->UserBuffer;

   // This will update the status pane - but we will reset it afterwards
   for (i = 0; i < UserCount; i++) {
      // Don't update totals yet, but update item ref incase this takes 
      // awhile
      Status_CurNum((UINT) i + 1);
      Status_Item(UserBuffer[i].Name);

      UserNames_Resolve(&UserBuffer[i]);
      if (TransferCancel)
         return;
   }

   UsersLogNames(Users);

   i = 0;
   while (i < UserCount) {
      Status_CurNum((UINT) i + 1);
      Status_Item(UserBuffer[i].Name);
      lstrcpy(pLine, UserBuffer[i].Name);

      if (UserBuffer[i].IsNewName)
         wsprintf(pLine, TEXT("[%s -> %s]"), UserBuffer[i].Name, UserBuffer[i].NewName);
      else
         wsprintf(pLine, TEXT("[%s]"), UserBuffer[i].NewName);

      LogWriteLog(1, TEXT("%-50s"), pLine);
      ErrorItemSet(TEXT("%s\r\n"), pLine);

      // If duplicate or other type error just do logging - don't try to save
      if (UserBuffer[i].err) {
         if (UserBuffer[i].err == NWC_ERR_DUPLICATE) {
            LogWriteLog(0, Lids(IDS_L_172));
            ErrorIt(Lids(IDS_L_173));
         }

         if (UserBuffer[i].err == NWC_ERR_NAMELONG) {
            LogWriteLog(0, Lids(IDS_L_174));
            ErrorIt(Lids(IDS_L_175));
         }

         if (UserBuffer[i].err == NWC_ERR_NAMEINVALID) {
            LogWriteLog(0, Lids(IDS_L_176));
            ErrorIt(Lids(IDS_L_177));
         }

      } else {
         // Init the user record
         NTUserRecInit(UserBuffer[i].NewName, &NT_UInfo);

         // +-------------------------------------------------------------+
         // |  User name figured out - now map password                   |
         // +-------------------------------------------------------------+
         memset(Password, 0, sizeof(Password));
         if (ConvOpt->UseMappingFile)
            // If using map file, password is already set
            lstrcpy(Password, UserBuffer[i].Password);
         else
            if (lstrlen(Password) == 0) {
               // Didn't map password - so find what to use
               switch (ConvOpt->PasswordOption) {
                  case 0: // No Password
                     // Don't need to do anything
                     break;

                  case 1: // Username
                     // BUGBUG: Name can be longer then password!!!
                     lstrcpy(Password, UserBuffer[i].NewName);
                     break;

                  case 2: // Constant
                     lstrcpy(Password, ConvOpt->PasswordConstant);
                     break;

               } // switch
            }

         NT_UInfo.password = Password;

#ifdef DEBUG
dprintf(TEXT("User: %s\n"), UserBuffer[i].Name);
#endif

         if (!UserSave(&NWInfo, UserBuffer[i].Name, UserBuffer[i].NewName, &NT_UInfo, &NW_UInfo, UserBuffer[i].Overwrite )) {
            LogWriteLog(0, Lids(IDS_L_178));
            ErrorIt(Lids(IDS_L_179));
         } else {
            // only increment total if actually converted...
            TotUsers++;
            TotConv++;
            Status_TotUsers(TotUsers);

            LogWriteLog(0, Lids(IDS_L_180));
            LogWriteLog(0, Lids(IDS_CRLF));

            // Converted - now need to save info to logs...
            if (NWInfo) {
               if (VerboseUserLogging())
                  NWUserInfoLog(UserBuffer[i].Name, NW_UInfo);

               if (VerboseUserLogging())
                  NTUserRecLog(NT_UInfo);
            }

         }

         LogWriteLog(0, Lids(IDS_CRLF));

      }

      i++;
   }

   LogWriteLog(0, Lids(IDS_CRLF));
   LogWriteSummary(1, Lids(IDS_L_181), lToStr(TotConv));

} // UsersConvert


/*+-------------------------------------------------------------------------+
  | GroupSave()
  |
  +-------------------------------------------------------------------------+*/
BOOL GroupSave(LPTSTR Name, DWORD *Status) {

   *Status = 0;

   if (!TConversion)
      if ((*Status = NTGroupSave(Name)))
         return FALSE;

   return TRUE;

} // GroupSave


/*+-------------------------------------------------------------------------+
  | GroupNewName_Check()
  |
  +-------------------------------------------------------------------------+*/
void GroupNewName_Check(GROUP_BUFFER *Groups) {
   // We have done any mappings that need to be done, now check for
   // name validity if there is a new name...
   if (Groups->IsNewName)
      if (GroupCacheMatch(Groups->NewName)) {
         Groups->err = NWC_ERR_DUPLICATE;
      }

   // make sure not too long
   if (lstrlen(Groups->NewName) > MAX_NT_GROUP_NAME_LEN) {
      // Name is too long
      Groups->err = NWC_ERR_NAMELONG;
   }

   // Check if a valid name (no illegal characters)...
   if ((int) wcscspn(Groups->NewName, ILLEGAL_CHARS) < (int) lstrlen(Groups->NewName))
      Groups->err = NWC_ERR_NAMEINVALID;

} // GroupNewName_Check


/*+-------------------------------------------------------------------------+
  | GroupNames_Resolve()
  |
  +-------------------------------------------------------------------------+*/
void GroupNames_Resolve(GROUP_BUFFER *Groups) {
   LPTSTR TheName;
   LPTSTR ErrorText;
   ULONG RetType;

   // Figure out which name to use
   if (Groups->IsNewName)
      TheName = Groups->Name;
   else
      TheName = Groups->NewName;

   // If using mapping file then map the name appropriatly
   if (ConvOpt->UseMappingFile) {
      if (GroupCacheMatch(TheName))
         Groups->err = NWC_ERR_DUPLICATE;
   } else {
      // check if the user name is in the destination list (duplicate)
      if (GroupCacheMatch(TheName)) {
         // There was - so figure out based on conversion options what
         // to do with it...
         switch (ConvOpt->GroupNameOption) {
            case 0: // Log Errors
               Groups->err = NWC_ERR_DUPLICATE;
               break;

            case 1: // ignore
               Groups->err = NWC_ERR_IGNORE;
               break;

            case 2: // Pre-Pend constant
               lstrcpy(NewName, ConvOpt->GroupConstant);
               lstrcat(NewName, Groups->Name);
               lstrcpy(Groups->NewName, NewName);
               Groups->IsNewName = TRUE;
               break;
         } // switch
      }
   }

   do {
      RetType = IDIGNORE;
      GroupNewName_Check(Groups);

      if (Groups->err && (Groups->err != NWC_ERR_IGNORE) && PopupOnError()) {
         switch(Groups->err) {
            case NWC_ERR_NAMELONG:
               ErrorText = Lids(IDS_L_182);
               break;

            case NWC_ERR_DUPLICATE:
               ErrorText = Lids(IDS_L_183);
               break;

            case NWC_ERR_NAMEINVALID:
               ErrorText = Lids(IDS_L_184);
               break;

         }

         RetType = GroupNameErrorDlg_Do(Lids(IDS_L_185), ErrorText, Groups);
      }
   } while (RetType == IDRETRY);

   if (RetType == IDABORT)
      TransferCancel = TRUE;

} // GroupNames_Resolve


/*+-------------------------------------------------------------------------+
  | GroupsConvert()
  |
  +-------------------------------------------------------------------------+*/
void GroupsConvert() {
   USER_LIST *GUsers = NULL;
   USER_BUFFER *GUserBuffer;
   USER_BUFFER *pUser;
   GROUP_BUFFER *pGroup;
   GROUP_BUFFER *GroupBuffer = NULL;
   DWORD GUserCount;
   DWORD status = 0;
   ULONG Count, i;
   ULONG TotConv = 0;
   LPTSTR NewName;
   BOOL SecEquivTitle = FALSE;
   BOOL SecEquivUser = FALSE;
   TCHAR GroupTitle[TMP_STR_LEN_256];

   // update status pane
   Status_ConvTxt(Lids(IDS_D_20));
   Status_ItemLabel(Lids(IDS_D_21));
   ErrorCategorySet(Lids(IDS_L_186));

   Status_CurTot((UINT) GroupCount);
   LogWriteLog(0, Lids(IDS_L_187));
   LogWriteLog(1, Lids(IDS_L_188), GroupCount);

   if (Groups == NULL)
      return;

   GroupBuffer = Groups->GroupBuffer;

   for (i = 0; i < GroupCount; i++) {
      // Don't update totals yet, but update item ref incase this takes 
      // awhile
      Status_CurNum((UINT) i + 1);
      Status_Item(GroupBuffer[i].Name);

      GroupNames_Resolve(&GroupBuffer[i]);

      if (TransferCancel)
         return;
   }

   i = 0;
   while (i < GroupCount) {
      // update status pane for this group
      Status_CurNum((UINT) i + 1);
      Status_Item(GroupBuffer[i].Name);
      lstrcpy(pLine, GroupBuffer[i].Name);

#ifdef DEBUG
dprintf(TEXT("Working on Group: %s\r\n"), GroupBuffer[i].Name);
#endif

      if (GroupBuffer[i].IsNewName)
         wsprintf(pLine, TEXT("%s -> %s"), GroupBuffer[i].Name, GroupBuffer[i].NewName);
      else
         wsprintf(pLine, TEXT("%s"), GroupBuffer[i].NewName);

      LogWriteLog(1, TEXT("%-50s"), pLine);
      ErrorItemSet(TEXT("[%s]\r\n"), pLine);

      // If duplicate or other type error just do logging - don't try
      // to save...
      if (GroupBuffer[i].err) {
         if (GroupBuffer[i].err == NWC_ERR_DUPLICATE) {
            LogWriteLog(0, Lids(IDS_L_163));
            ErrorIt(Lids(IDS_L_189));
         }

         if (GroupBuffer[i].err == NWC_ERR_NAMELONG) {
            LogWriteLog(0, Lids(IDS_L_162));
            ErrorIt(Lids(IDS_L_190));
         }

         if (GroupBuffer[i].err == NWC_ERR_NAMEINVALID) {
            LogWriteLog(0, Lids(IDS_L_164));
            ErrorIt(Lids(IDS_L_191));
         }

      } else {
         // Try to save it and get any errors...
         if (!GroupSave(GroupBuffer[i].NewName, &status)) {
            LogWriteLog(0, Lids(IDS_L_192));
            ErrorIt(Lids(IDS_L_193));
         } else {
            // only increment total if actually converted...
            TotGroups++;
            TotConv++;
            Status_TotGroups(TotGroups);

            LogWriteLog(0, Lids(IDS_L_180));
         }
      }

      LogWriteLog(0, Lids(IDS_CRLF));

      i++;
   }
   LogWriteLog(0, Lids(IDS_CRLF));

   ErrorCategorySet(Lids(IDS_L_194));
   // +-------------------------------------------------------------+
   // | Go through and add users to the groups                      |
   // +-------------------------------------------------------------+
   for (Count = 0; Count < GroupCount; Count++) {
      GUserCount = 0;

      if (!(status = NWGroupUsersEnum(GroupBuffer[Count].Name, &GUsers)) && (GUsers != NULL)) {
         GUserCount = GUsers->Count;
         GUserBuffer = GUsers->UserBuffer;

         if (GUserCount > 0) {
            wsprintf(GroupTitle, Lids(IDS_S_46), GroupBuffer[Count].NewName);
            EscapeFormattingChars(GroupTitle,
                                  sizeof(GroupTitle)/sizeof(GroupTitle[0])) ;
            Status_ItemLabel(GroupTitle);
            LogWriteLog(1, TEXT("[%s]\r\n"), GroupBuffer[Count].NewName);
         }

         for (i = 0; i < GUserCount; i++) {
            pUser = FindUserMatch(GUserBuffer[i].Name, Users, FALSE);

            if (pUser == NULL)
               NewName = NWSpecialNamesMap(GUserBuffer[i].Name);
            else
               NewName = pUser->NewName;

            LogWriteLog(2, TEXT("%-20s"), NewName);
            Status_Item(NewName);

#ifdef DEBUG
dprintf(TEXT("Adding User [%s] to Group: %s\n"), NewName, GroupBuffer[Count].NewName );
#endif
            if (!TConversion)
               if (NTGroupUserAdd(GroupBuffer[Count].NewName, NewName, FALSE)) {
                  LogWriteLog(0, Lids(IDS_L_196));
                  ErrorIt(Lids(IDS_L_195), NewName, GroupBuffer[Count].NewName);
               }

            LogWriteLog(0, Lids(IDS_CRLF));
         }

         LogWriteLog(0, Lids(IDS_CRLF));
         FreeMemory((LPBYTE) GUsers);
      } else {
         LogWriteLog(1, Lids(IDS_L_197), GroupBuffer[Count].Name);
         ErrorIt(Lids(IDS_L_197), GroupBuffer[Count].Name);
      }

   } // loop adding users to groups

   ErrorCategorySet(Lids(IDS_L_198));
   // +-------------------------------------------------------------+
   // | Convert Security Equivalences to Group Names                |
   // +-------------------------------------------------------------+
   SecEquivTitle = FALSE;
   for (Count = 0; Count < UserCount; Count++) {
      GUserCount = 0;
      SecEquivUser = FALSE;

      if (!(status = NWUserEquivalenceEnum(Users->UserBuffer[Count].Name, &GUsers)) && (GUsers != NULL)) {
         GUserCount = GUsers->Count;
         GUserBuffer = GUsers->UserBuffer;

         if (GUserCount > 0) {
            for (i = 0; i < GUserCount; i++) {
               pGroup = FindGroupMatch(GUserBuffer[i].Name, Groups, FALSE);

               if (pGroup != NULL) {
                  if ((pGroup->err != NWC_ERR_NAMELONG) && (pGroup->err != NWC_ERR_NAMEINVALID))
                     if (!SecEquivTitle) {
                        SecEquivTitle = TRUE;
                        LogWriteLog(0, Lids(IDS_CRLF));
                        LogWriteLog(0, Lids(IDS_L_199));
                     }

                     if (!SecEquivUser) {
                        SecEquivUser = TRUE;
                        wsprintf(GroupTitle, Lids(IDS_S_47), Users->UserBuffer[Count].NewName);
                        EscapeFormattingChars(GroupTitle,
                                  sizeof(GroupTitle)/sizeof(GroupTitle[0])) ;
                        Status_ItemLabel(GroupTitle);
                        LogWriteLog(1, TEXT("[%s]\r\n"), Users->UserBuffer[Count].NewName);
                     }

                     LogWriteLog(2, TEXT("%-20s"), pGroup->NewName);
                     Status_Item(pGroup->NewName);
#ifdef DEBUG
dprintf(TEXT("User [%s] Security Equivalence: %s\n"), Users->UserBuffer[Count].NewName, pGroup->NewName );
#endif
                     if (!TConversion)
                        if (NTGroupUserAdd(pGroup->NewName, Users->UserBuffer[Count].NewName, FALSE)) {
                           LogWriteLog(0, Lids(IDS_L_196));
                           ErrorIt(Lids(IDS_L_195), Users->UserBuffer[Count].NewName, pGroup->NewName);
                        }

                     LogWriteLog(0, Lids(IDS_CRLF));
               } else {
                  // There was not a group match - check if this is supervisor
                  // equivalence
                  if (!lstrcmpi(GUserBuffer[i].Name, Lids(IDS_S_28))) {
                     // Check if we should add them
                     if (ConvOpt->AdminAccounts) {
                        if (!SecEquivTitle) {
                           SecEquivTitle = TRUE;
                           LogWriteLog(0, Lids(IDS_CRLF));
                           LogWriteLog(0, Lids(IDS_L_199));
                        }

                        if (!SecEquivUser) {
                           SecEquivUser = TRUE;
                           LogWriteLog(1, TEXT("[%s]\r\n"), Users->UserBuffer[Count].NewName);
                        }

                        LogWriteLog(2, TEXT("%-20s"), Lids(IDS_S_42));

                        if (!TConversion)
                           if (NTGroupUserAdd(Lids(IDS_S_42), Users->UserBuffer[Count].NewName, FALSE)) {
                              LogWriteLog(0, Lids(IDS_L_196));
                              ErrorIt(Lids(IDS_L_195), Users->UserBuffer[Count].NewName, Lids(IDS_S_42));
                           }

                        LogWriteLog(0, Lids(IDS_CRLF));
                     }
                  }
               }
            }

            // Only put blank line if we logged this user
            if (SecEquivUser)
               LogWriteLog(0, Lids(IDS_CRLF));

         }

         FreeMemory((LPBYTE) GUsers);
      }

   } // Loop converting security equivalences

   // Synchronize the domain - we need to synch as Print Operators are a
   // local group
   NTDomainSynch(CurrentConvertList->FileServ);

   // Now set server to appropriate dest server (local group - so must
   // be on dest server and not PDC or trusted domain)...
   if ((status = NTServerSet(CurrentConvertList->FileServ->Name))) {
      // Failed to set server so log it and loop to next server
      LogWriteLog(0, Lids(IDS_L_209), CurrentConvertList->FileServ->Name);
      ErrorIt(Lids(IDS_L_209), CurrentConvertList->FileServ->Name);
      return;
   }

   ErrorCategorySet(Lids(IDS_L_200));
   // +-------------------------------------------------------------+
   // | Do Print Operators                                          |
   // +-------------------------------------------------------------+
   SecEquivTitle = FALSE;
   if (!(status = NWPrintOpsEnum(&GUsers)) && (GUsers != NULL)) {
      GUserCount = GUsers->Count;
      GUserBuffer = GUsers->UserBuffer;

      if (GUserCount > 0) {
         for (i = 0; i < GUserCount; i++) {

            if (!SecEquivTitle) {
               SecEquivTitle = TRUE;
               LogWriteLog(0, Lids(IDS_CRLF));
               LogWriteLog(0, Lids(IDS_L_201));
            }

            pUser = FindUserMatch(GUserBuffer[i].Name, Users, FALSE);

            if ((pUser == NULL) || ((pUser->err != NWC_ERR_NAMELONG) && (pUser->err != NWC_ERR_NAMEINVALID))) {
               if (pUser == NULL)
                  NewName = NWSpecialNamesMap(GUserBuffer[i].Name);
               else
                  NewName = pUser->NewName;

               LogWriteLog(2, TEXT("%-20s"), NewName);
#ifdef DEBUG
dprintf(TEXT("Adding User [%s] to Group: %s\n"), NewName, Lids(IDS_S_43) );
#endif
               if (!TConversion)
                  if (NTGroupUserAdd(Lids(IDS_S_43), NewName, TRUE)) {
                     LogWriteLog(0, Lids(IDS_L_196));
                     ErrorIt(Lids(IDS_L_195), NewName, Lids(IDS_S_43));
                  }

               LogWriteLog(0, Lids(IDS_CRLF));
            }
         }
      }
   }

   LogWriteSummary(1, Lids(IDS_L_202), lToStr(TotConv));

} // GroupsConvert


/*+-------------------------------------------------------------------------+
  | SupervisorDefaultsConvert()
  |
  +-------------------------------------------------------------------------+*/
void SupervisorDefaultsConvert(TRANSFER_LIST *tl) {
   ULONG i;
   void *Defaults;
   BOOL ConvertDefaults = FALSE;
   NT_DEFAULTS *NTDefaults = NULL;
   NT_DEFAULTS CDefaults;
   DEST_SERVER_BUFFER *oDServ = NULL;
   TRANSFER_BUFFER *TList;
   CONVERT_OPTIONS *ConvOpt;

   if (tl == NULL)
      return;

   TList = tl->TList;

   memset(&CDefaults, 0, sizeof(CDefaults));
   LogWriteLog(0, Lids(IDS_LINE));
   LogWriteLog(0, Lids(IDS_BRACE), Lids(IDS_L_203));
   LogWriteLog(0, Lids(IDS_LINE));

   // Loop through the server pairs for conversion - this is sorted in order of
   // destination users servers.
   for (i = 0; i < tl->Count; i++) {
      CurrentConvertList = TList[i].ConvertList;
      ConvOpt = (CONVERT_OPTIONS *) CurrentConvertList->ConvertOptions;

      if (CurrentConvertList->FileServ != oDServ) {
         // if this is not the first time through the loop, then we need to save
         // off the converted defaults
         if (ConvertDefaults && (oDServ != NULL)) {
            ConvertDefaults = FALSE;
            LogWriteLog(0, Lids(IDS_L_204), oDServ->Name);

            if (NTDefaults != NULL) {
               NTUserDefaultsLog(*NTDefaults);

               if (!TConversion)
                  NTUserDefaultsSet(*NTDefaults);
            }

         }

         oDServ = CurrentConvertList->FileServ;

         // Point to dest server and get defaults
         NTServerSet(CurrentConvertList->FileServ->Name);
         NTUserDefaultsGet(&NTDefaults);
         memset(&CDefaults, 0, sizeof(CDefaults));

         if (NTDefaults != NULL)
            memcpy(&CDefaults, NTDefaults, sizeof(CDefaults));

      }

      // Supervisor defaults
      if (ConvOpt->SupervisorDefaults) {

         // if not flagged for this dest server, then flag and write out original
         // values
         if (!ConvertDefaults) {
            ConvertDefaults = TRUE;

            if (NTDefaults != NULL) {
               LogWriteLog(0, Lids(IDS_L_205), CurrentConvertList->FileServ->Name);
               NTUserDefaultsLog(*NTDefaults);
            }
         }

         NWServerSet(CurrentConvertList->SourceServ->Name);
         NWUserDefaultsGet(&Defaults);

         if (Defaults != NULL) {
            LogWriteLog(0, Lids(IDS_L_206), CurrentConvertList->SourceServ->Name);
            NWUserDefaultsLog(Defaults);
            NWUserDefaultsMap(Defaults, &CDefaults);

            // Now map in least restrictive values to the NT one
            if (NTDefaults != NULL) {
               if (CDefaults.min_passwd_len < NTDefaults->min_passwd_len)
                  NTDefaults->min_passwd_len = CDefaults.min_passwd_len;

               if (CDefaults.max_passwd_age < NTDefaults->max_passwd_age)
                  NTDefaults->max_passwd_age = CDefaults.max_passwd_age;

               if (CDefaults.force_logoff < NTDefaults->force_logoff)
                  NTDefaults->force_logoff = CDefaults.force_logoff;

            }

            FreeMemory(Defaults);
            Defaults = NULL;
         }
      }

   }

   // Need to catch the last one through the loop
   if (ConvertDefaults && (oDServ != NULL)) {
      ConvertDefaults = FALSE;
      LogWriteLog(0, Lids(IDS_L_204), oDServ->Name);

      if (NTDefaults != NULL) {
         NTUserDefaultsLog(*NTDefaults);

         if (!TConversion)
            NTUserDefaultsSet(*NTDefaults);
      }

   }


} // SupervisorDefaultsConvert


/*+-------------------------------------------------------------------------+
  | TransferListCompare()
  |
  +-------------------------------------------------------------------------+*/
int __cdecl TransferListCompare(const void *arg1, const void *arg2) {
   TRANSFER_BUFFER *TBarg1, *TBarg2;

   TBarg1 = (TRANSFER_BUFFER *) arg1;
   TBarg2 = (TRANSFER_BUFFER *) arg2;

   return lstrcmpi( TBarg1->ServerName, TBarg2->ServerName);

} // TransferListCompare


/*+-------------------------------------------------------------------------+
  | TransferListCreate()
  |
  +-------------------------------------------------------------------------+*/
TRANSFER_LIST *TransferListCreate() {
   CONVERT_OPTIONS *ConvOpt;
   static TRANSFER_LIST *tl;
   TRANSFER_BUFFER *TList;
   CONVERT_LIST *CList;
   ULONG Count = 0;

   tl = NULL;
   CList = ConvertListStart;
   while (CList != NULL) {
      Count++;
      CList = CList->next;
   }

   if (Count == 0)
      return NULL;

   tl = AllocMemory(sizeof(TRANSFER_LIST) + (sizeof(TRANSFER_BUFFER) * Count));
   if (tl == NULL)
      return NULL;

   tl->Count = Count;
   TList = tl->TList;

   // init it all to NULL
   memset(TList, 0, sizeof(TRANSFER_BUFFER) * Count);

   Count = 0;   
   CList = ConvertListStart;
   while (CList != NULL) {
      TList[Count].ConvertList = CList;

      // If going to a trusted domain then point to it's PDC for user transfers
      ConvOpt = (CONVERT_OPTIONS *) CList->ConvertOptions;
      if (ConvOpt->UseTrustedDomain && (ConvOpt->TrustedDomain != NULL) && (ConvOpt->TrustedDomain->PDCName != NULL)) {
         TList[Count].UserServerType = USER_SERVER_TRUSTED;
         TList[Count].ServerName = ConvOpt->TrustedDomain->PDCName;
      } else
         // If in a domain then point to the PDC for user transfers
         if (CList->FileServ->InDomain && CList->FileServ->Domain) {
            TList[Count].UserServerType = USER_SERVER_PDC;
            TList[Count].ServerName = CList->FileServ->Domain->PDCName;
         } else {
            TList[Count].UserServerType = USER_SERVER;
            TList[Count].ServerName = CList->FileServ->Name;
         }

      Count++;
      CList = CList->next;
   }

   // Have setup the main transfer list - now need to sort it in order of the
   // server names that users are being transfered to.
   qsort((void *) TList, (size_t) tl->Count, sizeof(TRANSFER_BUFFER), TransferListCompare);

#ifdef DEBUG
dprintf(TEXT("\nTransfer List:\n"));
for (Count = 0; Count < tl->Count; Count++) {
   dprintf(TEXT("   Name: %s "), TList[Count].ServerName);
   switch (TList[Count].UserServerType) {
      case USER_SERVER:
         dprintf(TEXT("(Normal)\n"));
         break;

      case USER_SERVER_PDC:
         dprintf(TEXT("(PDC)\n"));
         break;

      case USER_SERVER_TRUSTED:
         dprintf(TEXT("(TRUSTED)\n"));
         break;
   }
}

dprintf(TEXT("\n"));
#endif
   return tl;

} // TransferListCreate


/*+-------------------------------------------------------------------------+
  | DoConversion()
  |
  |   Main program that does the actuall conversion.  Loops through the
  |   convert list and transfer the information.
  |
  +-------------------------------------------------------------------------+*/
void DoConversion(HWND hDlg, BOOL TrialConversion) {
   TRANSFER_LIST *tl = NULL;
   TRANSFER_BUFFER *TList;
   LPTSTR oDServ = NULL;
   DWORD status = 0;
   UINT i;
   BOOL GotUserList;
   TCHAR sztime[40];
   LPTSTR DomainName;

   time(&StartTime);
   TransferCancel = FALSE;
   TConversion = TrialConversion;

   // Check if going to non NTFS drives - if so, let user abort
   NTFSCheck(hDlg);
   if (TransferCancel)
      return;

   CursorHourGlass();

   PanelDlg_Do(hDlg, Lids(IDS_D_22));
   ConvertFilesInit(hDlg);

   if (Panel_Cancel()) {
      PanelDlgKill();
      TransferCancel = TRUE;
      CursorNormal();
      return;
   }

   PanelDlgKill();

   // Check if enough space on destination drives, if not allow user to abort
   CursorNormal();
   SpaceCheck(hDlg);
   if (TransferCancel)
      return;

   CursorHourGlass();
   tl = TransferListCreate();
   TList = tl->TList;

   DoStatusDlg(hDlg);

   Status_TotConv((UINT) NumServerPairs);

   Users = NULL;
   NTUsers = NULL;
   Groups = NULL;
   NTGroups = NULL;
   UserCount = 0;
   NTUserCount = 0;
   GroupCount = 0;
   NTGroupCount= 0;

   // Initialize global statistics
   TotErrors = 0;
   TotGroups = 0;
   TotUsers = 0;
   TotFiles = 0;

   // Update statistics window
   Status_TotComplete(0);
   Status_TotGroups(TotGroups);
   Status_TotUsers(TotUsers);
   Status_TotFiles(TotFiles);
   Status_TotErrors(TotErrors);

   // Set up logs and do all the header stuff
   LogInit();

   if (TrialConversion) {
      LogWriteLog(0, Lids(IDS_L_207));
   } else {
      LogWriteLog(0, Lids(IDS_L_208));
   }

   LogWriteSummary(0, Lids(IDS_CRLF));
   LogWriteErr(Lids(IDS_CRLF));
   LogWriteLog(0, Lids(IDS_CRLF));

   // Log the list of servers to be converted
   ErrorResetAll();
   ConvertListLog();

   // Loop through source servers and conglomerate defaults into dest servers
   // and log the results
   SupervisorDefaultsConvert(tl);


   // +---------------------------------------------------------------------+
   // |  Done with init - loop through server pairs and do conversion       |
   // +---------------------------------------------------------------------+

   // Get Local computer name
   GetLocalName(&LocalName);

   // Loop through the server pairs for conversion
   for (i = 0; ((i < tl->Count) && !TransferCancel); i++) {
      CurrentConvertList = TList[i].ConvertList;

      // Get source and destination server - update logs and status window
      Status_CurConv(i + 1);

      SourceServer = CurrentConvertList->SourceServ->Name;
      DestServer = CurrentConvertList->FileServ->Name;

      Status_SrcServ(SourceServer);
      Status_DestServ(DestServer);

      // Log this server pair - section heading
      ConvertPairLog();

      // SetConvert options and log them out.
      ConvOpt = (CONVERT_OPTIONS *) CurrentConvertList->ConvertOptions;
      FileOptions = (FILE_OPTIONS *) CurrentConvertList->FileOptions;
      ConvertOptionsLog();
      OptionsFileLog();

      // If our destination server has changed then update the caches
      if (TList[i].ServerName != oDServ) {
         oDServ = TList[i].ServerName;
         GotUserList = TRUE;

         ListCacheFree(&UserCacheHead);
         ListCacheFree(&GroupCacheHead);
         if ((status = NTServerSet(DestServer))) {
            // Failed to set server so log it and loop to next server
            LogWriteLog(0, Lids(IDS_L_209), DestServer);
            ErrorIt(Lids(IDS_L_209), DestServer);
            goto ConvDo_Loop;
         }

         // Put VShares here so it doesn't get lost in user info
         if (FileOptions->TransferFileInfo)
            VSharesCreate(CurrentConvertList->FileServ, TConversion);

         // Get users on NT server and put in cache
         if (status = NTUsersEnum(&NTUsers)) {
            // Failed - make sure we don't try to convert users and log err
            NTUsers = NULL;
            NTUserCount = 0;
            LogWriteLog(0, Lids(IDS_L_210), DestServer);
            ErrorIt(Lids(IDS_L_210), DestServer);
            GotUserList = FALSE;
         } else
            NTUserCount = NTUsers->Count;

         if (!ListCachePut(&UserCacheHead, (void *) NTUsers, NTUserCount)) {
            // Failed - but clean up NT List first
            GotUserList = FALSE;
            FreeMemory(NTUsers);
         } else {
            // Now get Groups (if users succeded) and put in group cache
            if (status = NTGroupsEnum(&NTGroups)) {
               // Failed - make sure we don't try to convert users and log err
               NTGroupCount = 0;
               NTGroups = NULL;
               LogWriteLog(0, Lids(IDS_L_211), DestServer);
               ErrorIt(Lids(IDS_L_211), DestServer);
               FreeMemory(NTUsers);
               GotUserList = FALSE;
            } else
               NTGroupCount = NTGroups->Count;

            if (!ListCachePut(&GroupCacheHead, (void *) NTGroups, NTGroupCount)) {
               // Failed - but clean up NT List first
               GotUserList = FALSE;
               FreeMemory(NTUsers);
               FreeMemory(NTGroups);
            }
         }

      }

      wsprintf(UserServerName, TEXT("\\\\%s"), TList[i].ServerName);
      if ((status = NTServerSet(TList[i].ServerName))) {
         // Failed to set server so log it and loop to next server
         LogWriteLog(0, Lids(IDS_L_209), TList[i].ServerName);
         ErrorIt(Lids(IDS_L_209), TList[i].ServerName);
         goto ConvDo_Loop;
      }

      if (ConvOpt->NetWareInfo) {
         NTSAMClose();

         if (ConvOpt->UseTrustedDomain && (ConvOpt->TrustedDomain != NULL))
            DomainName = ConvOpt->TrustedDomain->Name;
         else
            if ((CurrentConvertList->FileServ->InDomain) && (CurrentConvertList->FileServ->Domain != NULL))
               DomainName = CurrentConvertList->FileServ->Domain->Name;
            else
               DomainName = TEXT("");

         if ((status = NTSAMConnect(TList[i].ServerName, DomainName))) {
            // Failed to set server so log it and loop to next server
            LogWriteLog(0, Lids(IDS_L_209), TList[i].ServerName);
            ErrorIt(Lids(IDS_L_209), TList[i].ServerName);
            goto ConvDo_Loop;
         }
      }

      if ((status = NWServerSet(SourceServer))) {
         // Failed to set server so log it and loop to next server
         LogWriteLog(0, Lids(IDS_L_209), SourceServer);
         ErrorIt(Lids(IDS_L_209), SourceServer);
         goto ConvDo_Loop;
      }

      //
      // If we are using mapping file then don't enum users and groups off
      // the server.  Get them from the mapping file instead.
      //
      hMap = NULL;
      if (ConvOpt->UseMappingFile) {
         //
         // This is mapping file stuff
         //
         hMap = map_Open(ConvOpt->MappingFile);
         if (hMap == NULL) {
            ErrorIt(Lids(IDS_L_217), ConvOpt->MappingFile);
            goto ConvDo_Loop;
         }

         if ((status = map_GroupsEnum(hMap, &Groups))) {
            // Failed - make sure we don't try to convert users and log err
            Groups = NULL;
            GroupCount = 0;
            LogWriteLog(0, Lids(IDS_L_219), ConvOpt->MappingFile);
            ErrorIt(Lids(IDS_L_219), ConvOpt->MappingFile);
            GotUserList = FALSE;
         } else
            GroupCount = Groups->Count;

         if ((status = map_UsersEnum(hMap, &Users))) {
            // Failed - make sure we don't try to convert users and log err
            Users = NULL;
            UserCount = 0;
            LogWriteLog(0, Lids(IDS_L_218), ConvOpt->MappingFile);
            ErrorIt(Lids(IDS_L_218), ConvOpt->MappingFile);
            GotUserList = FALSE;
         } else
            UserCount = Users->Count;

      } else {
         //
         // Enuming users and groups from NetWare Server instead of map file
         //
         if ((status = NWGroupsEnum(&Groups, TRUE))) {
            // Failed - make sure we don't try to convert users and log err
            Groups = NULL;
            GroupCount = 0;
            LogWriteLog(0, Lids(IDS_L_211), SourceServer);
            ErrorIt(Lids(IDS_L_211), SourceServer);
            GotUserList = FALSE;
         } else
            GroupCount = Groups->Count;

         if ((status = NWUsersEnum(&Users, TRUE))) {
            // Failed - make sure we don't try to convert users and log err
            Users = NULL;
            UserCount = 0;
            LogWriteLog(0, Lids(IDS_L_210), SourceServer);
            ErrorIt(Lids(IDS_L_210), SourceServer);
            GotUserList = FALSE;
         } else
            UserCount = Users->Count;
      }

      if (GotUserList) {
         // User and Groups
         if (ConvOpt->TransferUserInfo) {
            UsersConvert();

            if (!TransferCancel)
               GroupsConvert();
         }
      }

      // Note GroupsConvert switches servers for Print Operators to the
      // destination server (and not the PDC).

      // Files
      if (!(TransferCancel) && FileOptions->TransferFileInfo) {
         ErrorCategorySet(Lids(IDS_L_212));

         // Now set server to appropriate file dest server
         if ((status = NTServerSet(CurrentConvertList->FileServ->Name))) {
            // Failed to set server so log it and loop to next server
            LogWriteLog(0, Lids(IDS_L_209), CurrentConvertList->FileServ->Name);
            ErrorIt(Lids(IDS_L_209), CurrentConvertList->FileServ->Name);
            goto ConvDo_Loop;
         }

         Status_BytesTxt(Lids(IDS_L_213));
         Status_Bytes(TEXT("0"));
         Status_TotBytes(TEXT("0"));
         Status_BytesSep(Lids(IDS_L_214));
         ConvertFiles(hDlg, TConversion, Users, Groups);
         Status_BytesTxt(TEXT(""));
         Status_Bytes(TEXT(""));
         Status_TotBytes(TEXT(""));
         Status_BytesSep(TEXT(""));
      }

      NWServerFree();

ConvDo_Loop:
      Status_TotComplete(i);

      if (Users) {
         FreeMemory(Users);
         UserCount = 0;
      }

      if (Groups) {
         FreeMemory(Groups);
         GroupCount = 0;
      }

      if (hMap != NULL)
         map_Close(hMap);

   } // for loop through transfer list

   // Free up our caches
   ListCacheFree(&UserCacheHead);
   ListCacheFree(&GroupCacheHead);

   // Log out the finish time
   LogWriteSummary(0, Lids(IDS_CRLF));
   LogWriteSummary(0, Lids(IDS_CRLF));
   LogWriteLog(0, Lids(IDS_CRLF));
   LogWriteLog(0, Lids(IDS_CRLF));
   GetTime(sztime);

   if (TransferCancel) {
      LogWriteLog(0, Lids(IDS_L_215), sztime);
      LogWriteSummary(0, Lids(IDS_L_215), sztime);
   } else {
      LogWriteLog(0, Lids(IDS_L_216), sztime);
      LogWriteSummary(0, Lids(IDS_L_216), sztime);
   }

   if (tl != NULL)
      FreeMemory(tl);

   NTSAMClose();
   StatusDlgKill();
   CursorNormal();

   TotConversions = i;
   ConversionEndDlg_Do(hDlg);

} // DoConversion


/*+-------------------------------------------------------------------------+
  | ConversionSuccessful()
  |
  +-------------------------------------------------------------------------+*/
BOOL ConversionSuccessful() {
   if (TotErrors || TransferCancel)
      return FALSE;
   else
      return TRUE;

} // ConversionSuccesful
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\transfer.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _TRANSFER_
#define _TRANSFER_

#ifdef __cplusplus
extern "C"{
#endif

void DoConversion(HWND hDlg, BOOL TrialConversion);
BOOL ConversionSuccessful();

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\userdlg.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _USERDLG_
#define _USERDLG_

#ifdef __cplusplus
extern "C"{
#endif


typedef struct _CONVERT_OPTIONS {
   BOOL TransferUserInfo;

   BOOL UseMappingFile;
   TCHAR MappingFile[MAX_PATH + 1];

   int PasswordOption;
   TCHAR PasswordConstant[MAX_PW_LEN + 1];
   BOOL ForcePasswordChange;

   int UserNameOption;
   TCHAR UserConstant[MAX_UCONST_LEN + 1];

   int GroupNameOption;
   TCHAR GroupConstant[MAX_UCONST_LEN + 1];

   BOOL SupervisorDefaults;
   BOOL AdminAccounts;
   BOOL NetWareInfo;

   BOOL UseTrustedDomain;
   DOMAIN_BUFFER *TrustedDomain; 
} CONVERT_OPTIONS;

void UserOptionsDefaultsSet(void *cvto);
void UserOptionsDefaultsReset();
void UserOptionsInit(void **cvto);
void UserOptionsLoad(HANDLE hFile, void **lpcvto);
void UserOptionsSave(HANDLE hFile, void *cvto);

void UserOptions_Do(HWND hDlg, void *ConvOptions, SOURCE_SERVER_BUFFER *SourceServer, DEST_SERVER_BUFFER *DestServer);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\userdlg.c ===
/*
  +-------------------------------------------------------------------------+
  |                        User Options Dialog                              |
  +-------------------------------------------------------------------------+
  |                     (c) Copyright 1993-1994                             |
  |                          Microsoft Corp.                                |
  |                        All rights reserved                              |
  |                                                                         |
  | Program               : [UserDlg.c]                                     |
  | Programmer            : Arthur Hanson                                   |
  | Original Program Date : [Feb 15, 1993]                                  |
  | Last Update           : [Jun 16, 1994]                                  |
  |                                                                         |
  | Version:  1.00                                                          |
  |                                                                         |
  | Description:                                                            |
  |                                                                         |
  | History:                                                                |
  |   arth  Jun 16, 1994    1.00    Original Version.                       |
  |                                                                         |
  +-------------------------------------------------------------------------+
*/


#include "globals.h"

#include <limits.h>

#include "nwconv.h"
#include "convapi.h"
#include "userdlg.h"
#include "transfer.h"
#include "ntnetapi.h"
#include "map.h"

#define togmap 1

// Utility Macros for Advanced >> button
#define SetStyleOn(hWnd, Style) SetWindowLong(hWnd, GWL_STYLE, Style | GetWindowLong(hWnd, GWL_STYLE));

#define SetStyleOff(hWnd, Style) SetWindowLong(hWnd, GWL_STYLE, ~Style & GetWindowLong(hWnd, GWL_STYLE));


static CONVERT_OPTIONS cvoDefault;
static CONVERT_OPTIONS *CurrentConvertOptions;
static LPTSTR SourceServ;
static LPTSTR DestServ;
static SOURCE_SERVER_BUFFER *SServ;
static DEST_SERVER_BUFFER *DServ;
static BOOL FPNWChk;
static short TabSelection;

/*+-------------------------------------------------------------------------+
  | UserOptionsDefaultsSet()
  |
  +-------------------------------------------------------------------------+*/
void UserOptionsDefaultsSet(void *cvto) {
   memcpy((void *) &cvoDefault, cvto, sizeof(CONVERT_OPTIONS));

} // UserOptionsDefaultsSet


/*+-------------------------------------------------------------------------+
  | UserOptionsDefaultsReset()
  |
  +-------------------------------------------------------------------------+*/
void UserOptionsDefaultsReset() {
   memset(&cvoDefault, 0, sizeof(CONVERT_OPTIONS));

   cvoDefault.TransferUserInfo = TRUE;
   cvoDefault.ForcePasswordChange = TRUE;
   cvoDefault.SupervisorDefaults = TRUE;
   cvoDefault.AdminAccounts = FALSE;
   cvoDefault.NetWareInfo = FALSE;
   cvoDefault.GroupNameOption = 1;

} // UserOptionsDefaultsReset


/*+-------------------------------------------------------------------------+
  | UserOptionsInit()
  |
  +-------------------------------------------------------------------------+*/
void UserOptionsInit(void **lpcvto) {
   CONVERT_OPTIONS *cvto;

   cvto = (CONVERT_OPTIONS *) *lpcvto;

   // if we need to allocate space, do so
   if (cvto == NULL)
      cvto = AllocMemory(sizeof(CONVERT_OPTIONS));

   // make sure it was allocated
   if (cvto == NULL)
      return;

   memcpy(cvto, (void *) &cvoDefault, sizeof(CONVERT_OPTIONS));
   *lpcvto = (void *) cvto;

} // UserOptionsInit


/*+-------------------------------------------------------------------------+
  | UserOptionsLoad()
  |
  +-------------------------------------------------------------------------+*/
void UserOptionsLoad(HANDLE hFile, void **lpcvto) {
   CONVERT_OPTIONS *cvto;
   DWORD wrote;

   cvto = (CONVERT_OPTIONS *) *lpcvto;

   // if we need to allocate space, do so
   if (cvto == NULL)
      cvto = AllocMemory(sizeof(CONVERT_OPTIONS));

   // make sure it was allocated
   if (cvto == NULL)
      return;

   ReadFile(hFile, cvto, sizeof(CONVERT_OPTIONS), &wrote, NULL);
   *lpcvto = (void *) cvto;

} // UserOptionsLoad


/*+-------------------------------------------------------------------------+
  | UserOptionsSave()
  |
  +-------------------------------------------------------------------------+*/
void UserOptionsSave(HANDLE hFile, void *pcvto) {
   CONVERT_OPTIONS *cvto;
   DWORD wrote;
   DOMAIN_BUFFER *Trusted;

   cvto = (CONVERT_OPTIONS *) pcvto;

   // if trusted domain then index the domain list and save off the old
   // domain pointer so that we save the index instead.
   if (cvto->UseTrustedDomain && (cvto->TrustedDomain != NULL)) {
      DomainListIndex();
      Trusted = cvto->TrustedDomain;
      cvto->TrustedDomain = (DOMAIN_BUFFER *) cvto->TrustedDomain->Index;
   } else
      cvto->UseTrustedDomain = FALSE;

   WriteFile(hFile, pcvto, sizeof(CONVERT_OPTIONS), &wrote, NULL);

   // if we replaced the domain pointer, then restore it
   if (cvto->UseTrustedDomain)
      cvto->TrustedDomain = Trusted;

} // UserOptionsSave


/*+-------------------------------------------------------------------------+
  | Passwords_Toggle()
  |
  +-------------------------------------------------------------------------+*/
void Passwords_Toggle(HWND hDlg, BOOL Toggle) {
   HWND hCtrl;
   BOOL MainToggle = Toggle;

   hCtrl = GetDlgItem(hDlg, IDC_CHKUSERS);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 0)
      MainToggle = FALSE;

   hCtrl = GetDlgItem(hDlg, IDC_CHKPWFORCE);
   ShowWindow(hCtrl, Toggle);
   EnableWindow(hCtrl, MainToggle);

#ifdef togmap
   hCtrl = GetDlgItem(hDlg, IDC_CHKMAPPING);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      MainToggle = FALSE;
#endif

   hCtrl = GetDlgItem(hDlg, IDC_RADIO1);
   ShowWindow(hCtrl, Toggle);
   EnableWindow(hCtrl, MainToggle);

   hCtrl = GetDlgItem(hDlg, IDC_RADIO2);
   ShowWindow(hCtrl, Toggle);
   EnableWindow(hCtrl, MainToggle);

   hCtrl = GetDlgItem(hDlg, IDC_RADIO3);
   ShowWindow(hCtrl, Toggle);
   EnableWindow(hCtrl, MainToggle);

   hCtrl = GetDlgItem(hDlg, IDC_PWCONST);
   ShowWindow(hCtrl, Toggle);
   EnableWindow(hCtrl, MainToggle);

} // Passwords_Toggle


/*+-------------------------------------------------------------------------+
  | DuplicateUsers_Toggle()
  |
  +-------------------------------------------------------------------------+*/
void DuplicateUsers_Toggle(HWND hDlg, BOOL Toggle) {
   HWND hCtrl;
   BOOL MainToggle = Toggle;

   hCtrl = GetDlgItem(hDlg, IDC_CHKUSERS);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 0)
      MainToggle = FALSE;

#ifdef togmap
   hCtrl = GetDlgItem(hDlg, IDC_CHKMAPPING);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      MainToggle = FALSE;
#endif

   hCtrl = GetDlgItem(hDlg, IDC_STATDUP);
   ShowWindow(hCtrl, Toggle);

   hCtrl = GetDlgItem(hDlg, IDC_RADIO4);
   ShowWindow(hCtrl, Toggle);
   EnableWindow(hCtrl, MainToggle);

   hCtrl = GetDlgItem(hDlg, IDC_RADIO5);
   ShowWindow(hCtrl, Toggle);
   EnableWindow(hCtrl, MainToggle);

   hCtrl = GetDlgItem(hDlg, IDC_RADIO6);
   ShowWindow(hCtrl, Toggle);
   EnableWindow(hCtrl, MainToggle);

   hCtrl = GetDlgItem(hDlg, IDC_RADIO7);
   ShowWindow(hCtrl, Toggle);
   EnableWindow(hCtrl, MainToggle);

   hCtrl = GetDlgItem(hDlg, IDC_USERCONST);
   ShowWindow(hCtrl, Toggle);
   EnableWindow(hCtrl, MainToggle);

} // DuplicateUsers_Toggle


/*+-------------------------------------------------------------------------+
  | DuplicateGroups_Toggle()
  |
  +-------------------------------------------------------------------------+*/
void DuplicateGroups_Toggle(HWND hDlg, BOOL Toggle) {
   HWND hCtrl;
   BOOL MainToggle = Toggle;

   hCtrl = GetDlgItem(hDlg, IDC_CHKUSERS);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 0)
      MainToggle = FALSE;

#ifdef togmap
   hCtrl = GetDlgItem(hDlg, IDC_CHKMAPPING);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      MainToggle = FALSE;
#endif

   hCtrl = GetDlgItem(hDlg, IDC_STATDUP);
   ShowWindow(hCtrl, Toggle);

   hCtrl = GetDlgItem(hDlg, IDC_RADIO8);
   ShowWindow(hCtrl, Toggle);
   EnableWindow(hCtrl, MainToggle);

   hCtrl = GetDlgItem(hDlg, IDC_RADIO9);
   ShowWindow(hCtrl, Toggle);
   EnableWindow(hCtrl, MainToggle);

   hCtrl = GetDlgItem(hDlg, IDC_RADIO10);
   ShowWindow(hCtrl, Toggle);
   EnableWindow(hCtrl, MainToggle);

   hCtrl = GetDlgItem(hDlg, IDC_GROUPCONST);
   ShowWindow(hCtrl, Toggle);
   EnableWindow(hCtrl, MainToggle);

} // DuplicateGroups_Toggle


/*+-------------------------------------------------------------------------+
  | Defaults_Toggle()
  |
  +-------------------------------------------------------------------------+*/
void Defaults_Toggle(HWND hDlg, BOOL Toggle) {
   HWND hCtrl;
   BOOL MainToggle = Toggle;

   hCtrl = GetDlgItem(hDlg, IDC_CHKUSERS);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 0)
      MainToggle = FALSE;

   hCtrl = GetDlgItem(hDlg, IDC_CHKSUPER);
   EnableWindow(hCtrl, MainToggle);
   ShowWindow(hCtrl, Toggle);

   hCtrl = GetDlgItem(hDlg, IDC_CHKADMIN);
   EnableWindow(hCtrl, MainToggle);
   ShowWindow(hCtrl, Toggle);

   hCtrl = GetDlgItem(hDlg, IDC_CHKFPNW);
   if (FPNWChk)
      EnableWindow(hCtrl, MainToggle);
   else
      EnableWindow(hCtrl, FALSE);

   ShowWindow(hCtrl, Toggle);
} // Defaults_Toggle


/*+-------------------------------------------------------------------------+
  | Mapping_Toggle()
  |
  +-------------------------------------------------------------------------+*/
void Mapping_Toggle(HWND hDlg, BOOL Toggle) {
   HWND hCtrl;

   // These two are the reverse of the others...
   hCtrl = GetDlgItem(hDlg, IDC_MAPPINGFILE);
   EnableWindow(hCtrl, !Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_BTNMAPPINGFILE);
   EnableWindow(hCtrl, !Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_BTNMAPPINGEDIT);
   EnableWindow(hCtrl, !Toggle);

#ifdef togmap
   hCtrl = GetDlgItem(hDlg, IDC_RADIO1);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_RADIO2);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_RADIO3);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_RADIO4);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_RADIO5);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_RADIO6);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_RADIO7);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_RADIO8);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_RADIO9);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_RADIO10);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_CHKPWFORCE);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_PWCONST);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_USERCONST);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_GROUPCONST);
   EnableWindow(hCtrl, Toggle);
#endif

} // Mapping_Toggle


/*+-------------------------------------------------------------------------+
  | UserDialogToggle()
  |
  +-------------------------------------------------------------------------+*/
void UserDialogToggle(HWND hDlg, BOOL Toggle) {
   HWND hCtrl;

   hCtrl = GetDlgItem(hDlg, IDC_CHKMAPPING);
   EnableWindow(hCtrl, Toggle);

   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1) 
      Mapping_Toggle(hDlg, FALSE);
   else
      Mapping_Toggle(hDlg, Toggle);

   if (!Toggle) {
      hCtrl = GetDlgItem(hDlg, IDC_MAPPINGFILE);
      EnableWindow(hCtrl, Toggle);
      hCtrl = GetDlgItem(hDlg, IDC_BTNMAPPINGFILE);
      EnableWindow(hCtrl, Toggle);
      hCtrl = GetDlgItem(hDlg, IDC_BTNMAPPINGEDIT);
      EnableWindow(hCtrl, Toggle);
   }

   hCtrl = GetDlgItem(hDlg, IDC_CHKSUPER);
   EnableWindow(hCtrl, Toggle);
   hCtrl = GetDlgItem(hDlg, IDC_CHKADMIN);
   EnableWindow(hCtrl, Toggle);

   hCtrl = GetDlgItem(hDlg, IDC_CHKFPNW);
   if (FPNWChk)
      EnableWindow(hCtrl, Toggle);
   else
      EnableWindow(hCtrl, FALSE);

   // Check the Advanced Trusted domain check and toggle controls appropriatly
   hCtrl = GetDlgItem(hDlg, IDC_CHKTRUSTED);

   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1) {
      hCtrl = GetDlgItem(hDlg, IDC_TRUSTED);
      EnableWindow(hCtrl, Toggle);

   } else {
      hCtrl = GetDlgItem(hDlg, IDC_TRUSTED);
      EnableWindow(hCtrl, FALSE);

   }

   // Now toggle the checkbox itself
   hCtrl = GetDlgItem(hDlg, IDC_CHKTRUSTED);
   EnableWindow(hCtrl, Toggle);

} // UserDialogToggle


/*+-------------------------------------------------------------------------+
  | UserDialogSave()
  |
  +-------------------------------------------------------------------------+*/
void UserDialogSave(HWND hDlg) {
   HWND hCtrl;
   DWORD_PTR dwIndex;
   TCHAR TrustedDomain[MAX_PATH + 1];

   hCtrl = GetDlgItem(hDlg, IDC_CHKUSERS);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      CurrentConvertOptions->TransferUserInfo = TRUE;
   else
      CurrentConvertOptions->TransferUserInfo = FALSE;

   hCtrl = GetDlgItem(hDlg, IDC_CHKMAPPING);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      CurrentConvertOptions->UseMappingFile = TRUE;
   else
      CurrentConvertOptions->UseMappingFile = FALSE;

   // Mapping file is handled in Verify

   // Password stuff--------------------------------------------------------
   hCtrl = GetDlgItem(hDlg, IDC_RADIO1);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      CurrentConvertOptions->PasswordOption = 0;

   hCtrl = GetDlgItem(hDlg, IDC_RADIO2);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      CurrentConvertOptions->PasswordOption = 1;

   hCtrl = GetDlgItem(hDlg, IDC_RADIO3);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      CurrentConvertOptions->PasswordOption = 2;

   hCtrl = GetDlgItem(hDlg, IDC_PWCONST);
   * (WORD *)CurrentConvertOptions->PasswordConstant = sizeof(CurrentConvertOptions->PasswordConstant);
   SendMessage(hCtrl, EM_GETLINE, 0, (LPARAM) CurrentConvertOptions->PasswordConstant);

   hCtrl = GetDlgItem(hDlg, IDC_CHKPWFORCE);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      CurrentConvertOptions->ForcePasswordChange = TRUE;
   else
      CurrentConvertOptions->ForcePasswordChange = FALSE;

   // Username stuff--------------------------------------------------------
   hCtrl = GetDlgItem(hDlg, IDC_RADIO4);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      CurrentConvertOptions->UserNameOption = 0;

   hCtrl = GetDlgItem(hDlg, IDC_RADIO5);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      CurrentConvertOptions->UserNameOption = 1;

   hCtrl = GetDlgItem(hDlg, IDC_RADIO6);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      CurrentConvertOptions->UserNameOption = 2;

   hCtrl = GetDlgItem(hDlg, IDC_RADIO7);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      CurrentConvertOptions->UserNameOption = 3;

   hCtrl = GetDlgItem(hDlg, IDC_USERCONST);
   * (WORD *)CurrentConvertOptions->UserConstant = sizeof(CurrentConvertOptions->UserConstant);
   SendMessage(hCtrl, EM_GETLINE, 0, (LPARAM) CurrentConvertOptions->UserConstant);

   // Group-name stuff--------------------------------------------------------
   hCtrl = GetDlgItem(hDlg, IDC_RADIO8);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      CurrentConvertOptions->GroupNameOption = 0;

   hCtrl = GetDlgItem(hDlg, IDC_RADIO9);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      CurrentConvertOptions->GroupNameOption = 1;

   hCtrl = GetDlgItem(hDlg, IDC_RADIO10);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      CurrentConvertOptions->GroupNameOption = 2;

   hCtrl = GetDlgItem(hDlg, IDC_GROUPCONST);
   * (WORD *)CurrentConvertOptions->GroupConstant = sizeof(CurrentConvertOptions->GroupConstant);
   SendMessage(hCtrl, EM_GETLINE, 0, (LPARAM) CurrentConvertOptions->GroupConstant);


   // Defaults page stuff------------------------------------------------------
   hCtrl = GetDlgItem(hDlg, IDC_CHKSUPER);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      CurrentConvertOptions->SupervisorDefaults = TRUE;
   else
      CurrentConvertOptions->SupervisorDefaults = FALSE;

   hCtrl = GetDlgItem(hDlg, IDC_CHKADMIN);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
      CurrentConvertOptions->AdminAccounts = TRUE;
   else
      CurrentConvertOptions->AdminAccounts = FALSE;

   if (FPNWChk) {
      hCtrl = GetDlgItem(hDlg, IDC_CHKFPNW);
      if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
         CurrentConvertOptions->NetWareInfo = TRUE;
      else
         CurrentConvertOptions->NetWareInfo = FALSE;
   } else
      CurrentConvertOptions->NetWareInfo = FALSE;


   // Advanced >> button stuff-------------------------------------------------
   hCtrl = GetDlgItem(hDlg, IDC_CHKTRUSTED);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1) {
      CurrentConvertOptions->UseTrustedDomain = TRUE;

      // if there is already a trusted domain selected - clear it out
      if (CurrentConvertOptions->TrustedDomain != NULL) {
         DomainListDelete(CurrentConvertOptions->TrustedDomain);
         CurrentConvertOptions->TrustedDomain = NULL;
      }

      hCtrl = GetDlgItem(hDlg, IDC_TRUSTED);
      dwIndex = SendMessage(hCtrl, CB_GETCURSEL, 0, 0);

      if (dwIndex != CB_ERR) {
         // Get the domain name and then try to add it to our lists
         SendMessage(hCtrl, CB_GETLBTEXT, (WPARAM) dwIndex, (LPARAM) TrustedDomain);
         CurrentConvertOptions->TrustedDomain = NTTrustedDomainSet(hDlg, DestServ, TrustedDomain);
      }

   } else
      CurrentConvertOptions->UseTrustedDomain = FALSE;

   // Set default values to new selections
   UserOptionsDefaultsSet(CurrentConvertOptions);

} // UserDialogSave


/*+-------------------------------------------------------------------------+
  | UserDialogVerify()
  |
  +-------------------------------------------------------------------------+*/
BOOL UserDialogVerify(HWND hDlg) {
   HWND hCtrl;
   static TCHAR MappingFile[MAX_PATH + 1];
   static char FileNameA[MAX_PATH + 1];
   static char CmdLine[MAX_PATH + 1 + 12];    // Editor + file
   TCHAR drive[MAX_DRIVE + 1];
   TCHAR dir[MAX_PATH + 1];
   TCHAR fname[MAX_PATH + 1];
   TCHAR ext[_MAX_EXT + 1];
   HANDLE hFile;

   // Check trusted domain...

   // Check mapping file
   hCtrl = GetDlgItem(hDlg, IDC_CHKUSERS);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1) {
      hCtrl = GetDlgItem(hDlg, IDC_CHKMAPPING);
      if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1) {
         hCtrl = GetDlgItem(hDlg, IDC_MAPPINGFILE);
         * (WORD *)MappingFile = sizeof(MappingFile);
         SendMessage(hCtrl, EM_GETLINE, 0, (LPARAM) MappingFile);
         lsplitpath(MappingFile, drive, dir, fname, ext);

         // Make sure a file name is specified
         if (lstrlen(fname) == 0) {
            MessageBox(hDlg, Lids(IDS_NOREADMAP), Lids(IDS_TXTWARNING), MB_OK | MB_ICONEXCLAMATION);
            hCtrl = GetDlgItem(hDlg, IDC_MAPPINGFILE);
            SetFocus(hCtrl);
            return FALSE;
         }

         if ((drive[0] == TEXT('\0')) && (dir[0] == TEXT('\0')))
            lstrcpy(dir, ProgPath);

         if (ext[0] == TEXT('\0'))
            lstrcpy(ext, Lids(IDS_S_36));

         lmakepath(MappingFile, drive, dir, fname, ext);

         lstrcpy(CurrentConvertOptions->MappingFile, MappingFile);

         WideCharToMultiByte(CP_ACP, 0, MappingFile, -1, FileNameA, sizeof(FileNameA), NULL, NULL);
         hFile = CreateFileA( FileNameA, GENERIC_READ, 0,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

         if (hFile == INVALID_HANDLE_VALUE) {
            MessageBox(hDlg, Lids(IDS_NOREADMAP), Lids(IDS_TXTWARNING), MB_OK | MB_ICONEXCLAMATION);
            hCtrl = GetDlgItem(hDlg, IDC_MAPPINGFILE);
            SetFocus(hCtrl);
            return FALSE;
         } else
            CloseHandle(hFile);

      }
   } // mapping file

   return TRUE;

} // UserDialogVerify


/*+-------------------------------------------------------------------------+
  | UserDialogSetup()
  |
  +-------------------------------------------------------------------------+*/
void UserDialogSetup(HWND hDlg) {
   HWND hCtrl;

   // Main TransferUserCheckbox
   hCtrl = GetDlgItem(hDlg, IDC_CHKUSERS);
   if (CurrentConvertOptions->TransferUserInfo)
      SendMessage(hCtrl, BM_SETCHECK, 1, 0);
   else
      SendMessage(hCtrl, BM_SETCHECK, 0, 0);

   // Mapping file checkbox
   hCtrl = GetDlgItem(hDlg, IDC_CHKMAPPING);
   if (CurrentConvertOptions->UseMappingFile)
      SendMessage(hCtrl, BM_SETCHECK, 1, 0);
   else
      SendMessage(hCtrl, BM_SETCHECK, 0, 0);


   hCtrl = GetDlgItem(hDlg, IDC_MAPPINGFILE);
   PostMessage(hCtrl, EM_LIMITTEXT, (WPARAM) MAX_PATH, 0);
   SendMessage(hCtrl, WM_SETTEXT, 0, (LPARAM) CurrentConvertOptions->MappingFile);

   // Force Password checkbox
   hCtrl = GetDlgItem(hDlg, IDC_CHKPWFORCE);
   if (CurrentConvertOptions->ForcePasswordChange)
      SendMessage(hCtrl, BM_SETCHECK, 1, 0);
   else
      SendMessage(hCtrl, BM_SETCHECK, 0, 0);

   // Set the text and limit the lengths of the edit fields...
   hCtrl = GetDlgItem(hDlg, IDC_PWCONST);
   PostMessage(hCtrl, EM_LIMITTEXT, (WPARAM) MAX_PW_LEN, 0);
   SendMessage(hCtrl, WM_SETTEXT, 0, (LPARAM) CurrentConvertOptions->PasswordConstant);

   hCtrl = GetDlgItem(hDlg, IDC_USERCONST);
   PostMessage(hCtrl, EM_LIMITTEXT, (WPARAM) MAX_UCONST_LEN, 0);
   SendMessage(hCtrl, WM_SETTEXT, 0, (LPARAM) CurrentConvertOptions->UserConstant);

   hCtrl = GetDlgItem(hDlg, IDC_GROUPCONST);
   PostMessage(hCtrl, EM_LIMITTEXT, (WPARAM) MAX_UCONST_LEN, 0);
   SendMessage(hCtrl, WM_SETTEXT, 0, (LPARAM) CurrentConvertOptions->GroupConstant);

   // Now init the radio buttons correctly
   CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO3, IDC_RADIO1 + CurrentConvertOptions->PasswordOption);
   CheckRadioButton(hDlg, IDC_RADIO4, IDC_RADIO7, IDC_RADIO4 + CurrentConvertOptions->UserNameOption);
   CheckRadioButton(hDlg, IDC_RADIO8, IDC_RADIO10, IDC_RADIO8 + CurrentConvertOptions->GroupNameOption);

   // Do the controls in the defaults section
   hCtrl = GetDlgItem(hDlg, IDC_CHKSUPER);
   if (CurrentConvertOptions->SupervisorDefaults)
      SendMessage(hCtrl, BM_SETCHECK, 1, 0);
   else
      SendMessage(hCtrl, BM_SETCHECK, 0, 0);

   hCtrl = GetDlgItem(hDlg, IDC_CHKADMIN);
   if (CurrentConvertOptions->AdminAccounts)
      SendMessage(hCtrl, BM_SETCHECK, 1, 0);
   else
      SendMessage(hCtrl, BM_SETCHECK, 0, 0);

   if (FPNWChk) {
      hCtrl = GetDlgItem(hDlg, IDC_CHKFPNW);
      if (CurrentConvertOptions->NetWareInfo)
         SendMessage(hCtrl, BM_SETCHECK, 1, 0);
      else
         SendMessage(hCtrl, BM_SETCHECK, 0, 0);
   } else
      SendMessage(hCtrl, BM_SETCHECK, 0, 0);

   // Now for the Advanced >> area..
   hCtrl = GetDlgItem(hDlg, IDC_CHKTRUSTED);
   if (CurrentConvertOptions->UseTrustedDomain)
      SendMessage(hCtrl, BM_SETCHECK, 1, 0);
   else
      SendMessage(hCtrl, BM_SETCHECK, 0, 0);

} // UserDialogSetup



/*+-------------------------------------------------------------------------+
  | ShowArea()
  |
  +-------------------------------------------------------------------------+*/
void ShowArea(BOOL fShowDefAreaOnly, HWND hDlg, HWND hWndDefArea) {
   RECT rcDlg, rcDefArea;
   TCHAR szDlgDims[25];
   char szaDlgDims[25];
   HWND hWndChild;
   RECT rc;

   // Save original width and height of dialog box
   GetWindowRect(hDlg, &rcDlg);

   // Retrieve coordinates for default area window.
   GetWindowRect(hWndDefArea, &rcDefArea);

   hWndChild = GetFirstChild(hDlg);

   for (; hWndChild != NULL; hWndChild = GetNextSibling(hWndChild)) {
      // Calculate rectangle occupied by child window in sreen coordinates
      GetWindowRect(hWndChild, &rc);

      // Enable/Disable child if its:
      // right edge is >= the right edge of hWndDefArea.
      // bottom edge is >= the bottom edge of hWndDefArea.
      if ((rc.right >= rcDefArea.right) || (rc.bottom >= rcDefArea.bottom))
         EnableWindow(hWndChild, !fShowDefAreaOnly);
   }

   if (fShowDefAreaOnly) {
      wsprintf(szDlgDims, TEXT("%05u %05u"), rcDlg.right - rcDlg.left, rcDlg.bottom - rcDlg.top);

      SetStyleOff(hWndDefArea, SS_BLACKRECT);
      SetStyleOn(hWndDefArea, SS_LEFT);
      SetWindowText(hWndDefArea, szDlgDims);

      // Resize dialog box to fit only default area.
      SetWindowPos(hDlg, NULL, 0, 0, rcDefArea.right - rcDlg.left,
               rcDefArea.bottom - rcDlg.top, SWP_NOZORDER | SWP_NOMOVE);

      // Make sure that the Default area box is hidden.
      ShowWindow(hWndDefArea, SW_HIDE);
   } else {
      GetWindowText(hWndDefArea, szDlgDims, sizeof(szDlgDims));

      WideCharToMultiByte( CP_ACP, 0, szDlgDims, -1, szaDlgDims, sizeof(szDlgDims), NULL, NULL );

      // Restore dialog box to its original size.
      SetWindowPos(hDlg, NULL, 0, 0, atoi(szaDlgDims), atoi(szaDlgDims + 6),
               SWP_NOZORDER | SWP_NOMOVE);
   }


} // ShowArea


/*+-------------------------------------------------------------------------+
  | UserFileGet()
  |
  +-------------------------------------------------------------------------+*/
DWORD UserFileGet(HWND hwnd, LPTSTR FilePath) {
   OPENFILENAME ofn;
   TCHAR szDirName[MAX_PATH + 1];
   TCHAR szFile[MAX_PATH + 1], szFileTitle[MAX_PATH + 1];
   UINT i, cbString;
   TCHAR chReplace;
   TCHAR szFilter[256];
   BOOL Found = FALSE;
   LPTSTR szExt;
   
   szExt = Lids(IDS_S_37);

   lstrcpy(szDirName, ProgPath);
   lstrcpy(szFile, TEXT(""));

   if ((cbString = LoadString(hInst, IDS_USERFILTERSTRING, szFilter, sizeof(szFilter))) == 0) {
      // Error occured
      return 1L;
   }

   chReplace = szFilter[cbString - 1];    // Retrieve wild character

   for (i = 0; szFilter[i] != TEXT('\0'); i++) {
      if (szFilter[i] == chReplace)
         szFilter[i] = TEXT('\0');
   }

   // Set all structure members to zero
   memset(&ofn, 0, sizeof(OPENFILENAME));

   ofn.lStructSize = sizeof(OPENFILENAME);
   ofn.hwndOwner = hwnd;
   ofn.lpstrFilter = szFilter;
   ofn.nFilterIndex = 1;
   ofn.lpstrFile = szFile;
   ofn.nMaxFile = sizeof(szFile);
   ofn.lpstrFileTitle = szFileTitle;
   ofn.nMaxFileTitle = sizeof(szFileTitle);
   ofn.lpstrInitialDir = szDirName;
   ofn.lpstrDefExt = szExt;
   ofn.Flags = OFN_HIDEREADONLY | OFN_NOCHANGEDIR | OFN_PATHMUSTEXIST;

   if (GetOpenFileName(&ofn)) {
      // Don't really need to open it yet - just copy the data

      // If no path then append .
      i = 0;
      while (!Found && (ofn.lpstrFile[i] != TEXT('\0'))) {
         if ((ofn.lpstrFile[i] == TEXT(':')) || (ofn.lpstrFile[i] == TEXT('\\')))
            Found = TRUE;
         i++;
      }

      lstrcpy(FilePath, TEXT(""));

      if (!Found)
         lstrcpy(FilePath, TEXT(".\\"));

      lstrcat(FilePath, ofn.lpstrFile);
      return 0L;
   } else {
      // Couldn't open the dang file
      return 1L;
   }

} // UserFileGet


/*+-------------------------------------------------------------------------+
  | DlgUsers_TrustedSetup()
  |
  +-------------------------------------------------------------------------+*/
void DlgUsers_TrustedSetup(HWND hDlg) {
   HWND hCtrl;
   ULONG i;
   static TRUSTED_DOMAIN_LIST *TList = NULL;

   NTTrustedDomainsEnum(DestServ, &TList);

   if (TList != NULL) {
      hCtrl = GetDlgItem(hDlg, IDC_TRUSTED);

      for (i = 0; i < TList->Count; i++)
         SendMessage(hCtrl, CB_ADDSTRING, (WPARAM) 0, (LPARAM) TList->Name[i]);

   }

   EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED), FALSE);
   ShowArea(FALSE, hDlg, GetDlgItem(hDlg, IDC_DEFAULTBOX));

   // Toggle the advanced controls based on the main user toggle
   hCtrl = GetDlgItem(hDlg, IDC_CHKUSERS);
   if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1) {
      hCtrl = GetDlgItem(hDlg, IDC_CHKTRUSTED);
      EnableWindow(hCtrl, TRUE);

      hCtrl = GetDlgItem(hDlg, IDC_TRUSTED);
      EnableWindow(hCtrl, TRUE);
      SetFocus(GetDlgItem(hDlg, IDC_CHKTRUSTED));
   } else {
      hCtrl = GetDlgItem(hDlg, IDC_CHKTRUSTED);
      EnableWindow(hCtrl, FALSE);

      hCtrl = GetDlgItem(hDlg, IDC_TRUSTED);
      EnableWindow(hCtrl, FALSE);
      SetFocus(GetDlgItem(hDlg, IDHELP));
   }


   if ((TList == NULL) || (TList->Count = 0)) {
      EnableWindow(GetDlgItem(hDlg, IDC_CHKTRUSTED), FALSE);
      EnableWindow(GetDlgItem(hDlg, IDC_TRUSTED), FALSE);
      SetFocus(GetDlgItem(hDlg, IDHELP));
   } else {
      // Select the trusted domain (or first one if none currently selected)
      if (CurrentConvertOptions->TrustedDomain != NULL)
         SendMessage(GetDlgItem(hDlg, IDC_TRUSTED), CB_SELECTSTRING, (WPARAM) -1, (LPARAM) CurrentConvertOptions->TrustedDomain->Name);
      else
         SendMessage(GetDlgItem(hDlg, IDC_TRUSTED), CB_SETCURSEL, 0, 0);

      // if the checkbox is set then enable the edit field
      if (!CurrentConvertOptions->UseTrustedDomain)
         EnableWindow(GetDlgItem(hDlg, IDC_TRUSTED), FALSE);

   }

   // Free up the list as we don't need it anymore (it is in the combo-box)
   if (TList) {
      FreeMemory(TList);
      TList = NULL;
   }

} // DlgUsers_TrustedSetup


/*+-------------------------------------------------------------------------+
  | MappingFileEdit()
  |
  +-------------------------------------------------------------------------+*/
BOOL MappingFileEdit(HWND hDlg) {
   HWND hCtrl;
   static TCHAR MappingFile[MAX_PATH + 1];
   static char FileNameA[MAX_PATH + 1];
   static char CmdLine[MAX_PATH + 1 + 12];    // Editor + file
   TCHAR drive[MAX_DRIVE + 1];
   TCHAR dir[MAX_PATH + 1];
   TCHAR fname[MAX_PATH + 1];
   TCHAR ext[_MAX_EXT + 1];
   HANDLE hFile;
   UINT uReturn;
   BOOL ret = TRUE;
   BOOL Browse = FALSE;

   do {
      // First check filename
      hCtrl = GetDlgItem(hDlg, IDC_MAPPINGFILE);
      * (WORD *)MappingFile = sizeof(MappingFile);
      SendMessage(hCtrl, EM_GETLINE, 0, (LPARAM) MappingFile);
      lsplitpath(MappingFile, drive, dir, fname, ext);

      // Make sure a file name is specified
      if (Browse || (lstrlen(fname) == 0)) {
         // No name was specified, so let the user browse for a file
         if (!UserFileGet(hDlg, MappingFile)) {
            hCtrl = GetDlgItem(hDlg, IDC_MAPPINGFILE);
            SendMessage(hCtrl, WM_SETTEXT, 0, (LPARAM) MappingFile);
            SetFocus(hCtrl);
            lsplitpath(MappingFile, drive, dir, fname, ext);
         } else
            return FALSE;
      }

      Browse = FALSE;

      // remake path so it is fully qualified
      if ((drive[0] == TEXT('\0')) && (dir[0] == TEXT('\0')))
         lstrcpy(dir, ProgPath);

      if (ext[0] == TEXT('\0'))
         lstrcpy(ext, Lids(IDS_S_36));

      lmakepath(MappingFile, drive, dir, fname, ext);

      // Now make sure the file exists and is accessible

      WideCharToMultiByte(CP_ACP, 0, MappingFile, -1, FileNameA, sizeof(FileNameA), NULL, NULL);

      hFile = CreateFileA( FileNameA, GENERIC_READ, 0,
                     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

      if (hFile == INVALID_HANDLE_VALUE) {
         // Couldn't open the file, report to user
         if (MessageBox(hDlg, Lids(IDS_NOEDITMAP), Lids(IDS_TXTWARNING), MB_YESNO | MB_ICONQUESTION) == IDYES)
            Browse = TRUE;
         else {
            // get out of loop as nothing more to do
            hCtrl = GetDlgItem(hDlg, IDC_MAPPINGFILE);
            SetFocus(hCtrl);
            ret = FALSE;
         }
      } else {
         // Could create a new file so make the mapping file...
         CloseHandle(hFile);
         CursorHourGlass();
         wsprintfA(CmdLine, "Notepad %s", FileNameA);
         uReturn = WinExec(CmdLine, SW_SHOW);
         CursorNormal();
      }

   } while (Browse);

   // Check mapping file check-box, if it's not check'd then do so
   if (ret) {
      hCtrl = GetDlgItem(hDlg, IDC_CHKMAPPING);
      if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) != 1)
         SendMessage(hCtrl, BM_SETCHECK, 1, 0);
   }

   return ret;

} // MappingFileEdit


/*+-------------------------------------------------------------------------+
  | DlgUsers()
  |
  +-------------------------------------------------------------------------+*/
LRESULT CALLBACK DlgUsers(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
   HWND hCtrl;
   int wmId, wmEvent;
   static short UserNameTab, GroupNameTab, PasswordsTab, DefaultsTab;
   static BOOL TrustedEnabled;
   TCHAR TrustedDomain[MAX_PATH + 1];
   static TCHAR MappingFile[MAX_PATH + 1];
   DWORD_PTR dwIndex;

   switch (message) {

      case WM_INITDIALOG:
         // Center the dialog over the application window
         CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));

         // Setup for Advanced >> button
         ShowArea(TRUE, hDlg, GetDlgItem(hDlg, IDC_DEFAULTBOX));
         TrustedEnabled = FALSE;

         // Need to set the check and radio buttons to correct state...
         UserDialogSetup(hDlg);

         hCtrl = GetDlgItem( hDlg, IDC_TABUSERS );

         PasswordsTab = BookTab_AddItem( hCtrl, Lids(IDS_S_38) );
         BookTab_SetItemData( hCtrl, PasswordsTab, 1001 );

         UserNameTab = BookTab_AddItem( hCtrl, Lids(IDS_S_39) );
         BookTab_SetItemData( hCtrl, UserNameTab, 1002 );

         GroupNameTab = BookTab_AddItem( hCtrl, Lids(IDS_S_40) );
         BookTab_SetItemData( hCtrl, GroupNameTab, 1003 );

         DefaultsTab = BookTab_AddItem( hCtrl, Lids(IDS_S_41) );
         BookTab_SetItemData( hCtrl, DefaultsTab, 1004 );

         BookTab_SetCurSel(hCtrl, PasswordsTab);

         // now need to reset the Advanced button to the correct state and also the
         // Advanced display area...
         if (CurrentConvertOptions->UseTrustedDomain) {
            TrustedEnabled = TRUE;
            DlgUsers_TrustedSetup(hDlg);
         }

         // Weirdness to initially enable controls on the tab control -
         // looks like a bug in the tab control.
         SetFocus(hCtrl);
         hCtrl = GetDlgItem( hDlg, IDOK );
         SetFocus(hCtrl);
         PostMessage(hDlg, BTN_SELCHANGE, 0, 0);

         return (TRUE);

      case BTN_SELCHANGE:

         hCtrl = GetDlgItem( hDlg, IDC_TABUSERS );
         TabSelection = BookTab_GetCurSel(hCtrl);

         if (TabSelection == UserNameTab) {
            Passwords_Toggle(hDlg, FALSE);
            Defaults_Toggle(hDlg, FALSE);
            DuplicateGroups_Toggle(hDlg, FALSE);
            DuplicateUsers_Toggle(hDlg, TRUE);
         }

         if (TabSelection == GroupNameTab) {
            Passwords_Toggle(hDlg, FALSE);
            Defaults_Toggle(hDlg, FALSE);
            DuplicateUsers_Toggle(hDlg, FALSE);
            DuplicateGroups_Toggle(hDlg, TRUE);
         }

         if (TabSelection == PasswordsTab) {
            DuplicateUsers_Toggle(hDlg, FALSE);
            Defaults_Toggle(hDlg, FALSE);
            DuplicateGroups_Toggle(hDlg, FALSE);
            Passwords_Toggle(hDlg, TRUE);
         }

         if (TabSelection == DefaultsTab) {
            Passwords_Toggle(hDlg, FALSE);
            DuplicateUsers_Toggle(hDlg, FALSE);
            DuplicateGroups_Toggle(hDlg, FALSE);
            Defaults_Toggle(hDlg, TRUE);
         }

         return (TRUE);

      case WM_COMMAND:
         wmId    = LOWORD(wParam);
         wmEvent = HIWORD(wParam);

      switch (wmId) {
         case IDOK:
            if (UserDialogVerify(hDlg)) {
               UserDialogSave(hDlg);
               EndDialog(hDlg, 0);
            }

            return (TRUE);
            break;

         case IDCANCEL:
            EndDialog(hDlg, 0);
            return (TRUE);
            break;

         case IDHELP:
            if (TrustedEnabled)
               WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDC_HELP_USERADV);
            else
               WinHelp(hDlg, HELP_FILE, HELP_CONTEXT, (DWORD) IDC_HELP_USER);

            return (TRUE);
            break;

         case IDC_ADVANCED:
            TrustedEnabled = TRUE;
            DlgUsers_TrustedSetup(hDlg);
            return (TRUE);
            break;

         case IDC_CHKUSERS:
            hCtrl = GetDlgItem(hDlg, IDC_CHKUSERS);
            if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1)
               UserDialogToggle(hDlg, TRUE);
            else
               UserDialogToggle(hDlg, FALSE);

            PostMessage(hDlg, BTN_SELCHANGE, 0, 0);
            return (TRUE);
            break;

         case IDC_CHKMAPPING:
            hCtrl = GetDlgItem(hDlg, IDC_CHKMAPPING);
            if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1) 
               Mapping_Toggle(hDlg, FALSE);
            else
               Mapping_Toggle(hDlg, TRUE);

            return (TRUE);
            break;

         case IDC_CHKTRUSTED:
            hCtrl = GetDlgItem(hDlg, IDC_CHKTRUSTED);
            if (SendMessage(hCtrl, BM_GETCHECK, 0, 0) == 1) {
               hCtrl = GetDlgItem(hDlg, IDC_TRUSTED);
               EnableWindow(hCtrl, TRUE);

               // Get trusted domain
               dwIndex = SendMessage(hCtrl, CB_GETCURSEL, 0, 0);
               if (dwIndex != CB_ERR) {
                  // Get the domain name and then try to add it to our lists
                  SendMessage(hCtrl, CB_GETLBTEXT, (WPARAM) dwIndex, (LPARAM) TrustedDomain);
                  CurrentConvertOptions->TrustedDomain = NTTrustedDomainSet(hDlg, DestServ, TrustedDomain);
                  CurrentConvertOptions->UseTrustedDomain = TRUE;
               } else
                  CurrentConvertOptions->UseTrustedDomain = FALSE;

            } else {
               hCtrl = GetDlgItem(hDlg, IDC_TRUSTED);
               EnableWindow(hCtrl, FALSE);
               CurrentConvertOptions->UseTrustedDomain = FALSE;
            }

            // Toggled trust relationship so setup FPNW info accordingly
            FPNWChk = IsFPNW(UserServerNameGet(DServ, CurrentConvertOptions));
            if (TabSelection == DefaultsTab)
               Defaults_Toggle(hDlg, TRUE);

            return (TRUE);
            break;

         case IDC_TRUSTED:
            if (wmEvent == CBN_SELCHANGE) {
               // A new trusted domain was selected, update FPNW flag
               hCtrl = GetDlgItem(hDlg, IDC_TRUSTED);
               EnableWindow(hCtrl, TRUE);

               // Get trusted domain
               dwIndex = SendMessage(hCtrl, CB_GETCURSEL, 0, 0);
               if (dwIndex != CB_ERR) {
                  // Get the domain name and then try to add it to our lists
                  SendMessage(hCtrl, CB_GETLBTEXT, (WPARAM) dwIndex, (LPARAM) TrustedDomain);
                  CurrentConvertOptions->TrustedDomain = NTTrustedDomainSet(hDlg, DestServ, TrustedDomain);
                  CurrentConvertOptions->UseTrustedDomain = TRUE;
               } else
                  CurrentConvertOptions->UseTrustedDomain = FALSE;

               FPNWChk = IsFPNW(UserServerNameGet(DServ, CurrentConvertOptions));
               CurrentConvertOptions->NetWareInfo = FPNWChk;

               if (TabSelection == DefaultsTab)
                  Defaults_Toggle(hDlg, TRUE);

            }
            break;

         case IDC_BTNMAPPINGFILE:
            // Get anything in the text box
            hCtrl = GetDlgItem(hDlg, IDC_MAPPINGFILE);
            * (WORD *)MappingFile = sizeof(MappingFile);
            SendMessage(hCtrl, EM_GETLINE, 0, (LPARAM) MappingFile);

            // invoke the creation routine
            MapFileCreate(hDlg, MappingFile, SourceServ);

            // reset edit-box to whatever the returned filename is
            SendMessage(hCtrl, WM_SETTEXT, 0, (LPARAM) MappingFile);
   
            if (SendMessage(hCtrl, EM_LINELENGTH, 0, 0)) {
               hCtrl = GetDlgItem(hDlg, IDC_CHKMAPPING);
               SendMessage(hCtrl, BM_SETCHECK, 1, 0);
            } else {
               hCtrl = GetDlgItem(hDlg, IDC_CHKMAPPING);
               SendMessage(hCtrl, BM_SETCHECK, 0, 0);
            }

            return (TRUE);
            break;

         case IDC_BTNMAPPINGEDIT:
            MappingFileEdit(hDlg);
            return (TRUE);
            break;

         case IDC_PWCONST:

            if (wmEvent == EN_CHANGE)
               CheckRadioButton(hDlg, IDC_RADIO1, IDC_RADIO3, IDC_RADIO3);

            break;

         case IDC_USERCONST:

            if (wmEvent == EN_CHANGE)
               CheckRadioButton(hDlg, IDC_RADIO4, IDC_RADIO7, IDC_RADIO7);

            break;

         case IDC_GROUPCONST:

            if (wmEvent == EN_CHANGE)
               CheckRadioButton(hDlg, IDC_RADIO8, IDC_RADIO10, IDC_RADIO10);

            break;

      }
      break;
   }

   return (FALSE); // Didn't process the message

   lParam;
} // DlgUsers



/*+-------------------------------------------------------------------------+
  | UserOptions_Do()
  |
  +-------------------------------------------------------------------------+*/
void UserOptions_Do(HWND hDlg, void *ConvOptions, SOURCE_SERVER_BUFFER *SourceServer, DEST_SERVER_BUFFER *DestServer) {
   DLGPROC lpfnDlg;

   SServ = SourceServer;
   DServ = DestServer;
   SourceServ = SourceServer->Name;
   DestServ = DestServer->Name;

   FPNWChk = DServ->IsFPNW;
   CurrentConvertOptions = (CONVERT_OPTIONS *) ConvOptions;
   lpfnDlg = MakeProcInstance((DLGPROC)DlgUsers, hInst);
   DialogBox(hInst, TEXT("DlgNewUsers"), hDlg, lpfnDlg) ;
   FreeProcInstance(lpfnDlg);
} // UserOptions_Do
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\usrprop.c ===
/*++

Copyright (c) 1993-1993  Microsoft Corporation

Module Name:

    usrprop.c

Abstract:

    This module implements QueryUserProperty() and SetUserProperty()
    which read and write NetWare Properties to the UserParms field.

Author:

    Andy Herron (andyhe)    24-May-1993
    Congpa You  (CongpaY)   28-Oct-1993   Seperated SetUserProperty() and
                                          QueryUserProperty() out from usrprop.c
                                          in ncpsrv\svcdlls\ncpsvc\libbind,
                                          modified the code and  fixed a few
                                          existing problems.

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntioapi.h"
#include "windef.h"
#include "winbase.h"
#include "stdio.h"
#include "stdlib.h"
#include "winuser.h"

#include "usrprop.h"

#define NCP_SET             0x02    /* Series of Object ID numbers, each 4
                                       bytes long */

//
//   All internal (opaque) structures are listed here since no one else
//   needs to reference them.
//

//
// The user's Parameter field is mapped out to a structure that contains
// the backlevel 48 WCHARs for Mac/Ras compatibility plus a new structure
// that is basically an array of chars that make up a property name plus
// a property value.
//

//
//  This is the structure for an individual property.  Note that there are
//  no null terminators in this.
//
typedef struct _USER_PROPERTY {
    WCHAR   PropertyLength;     // length of property name
    WCHAR   ValueLength;        // length of property value
    WCHAR   PropertyFlag;       // type of property (1 = set, 2 = item)
    WCHAR   Property[1];        // start of property name, followed by value
} USER_PROPERTY, *PUSER_PROPERTY;

//
//  This is the structure that maps the beginning of the user's Parameters
//  field.  It is only separate so that we can do a sizeof() without including
//  the first property, which may or may not be there.
//

typedef struct _USER_PROPERTIES_HDR {
    WCHAR   BacklevelParms[48];     // RAS & Mac data stored here.
    WCHAR   PropertySignature;      // signature that we can look for.
    WCHAR   PropertyCount;          // number of properties present.
} USER_PROPERTIES_HDR, *PUSER_PROPERTIES_HDR;

//
//  This structure maps out the whole of the user's Parameters field when
//  the user properties structure is present and at least one property is
//  defined.
//

typedef struct _USER_PROPERTIES {
    USER_PROPERTIES_HDR Header;
    USER_PROPERTY   FirstProperty;
} USER_PROPERTIES, *PUSER_PROPERTIES;

//
// forward references
//

NTSTATUS
UserPropertyAllocBlock (
    IN PUNICODE_STRING Existing,
    IN ULONG DesiredLength,
    IN OUT PUNICODE_STRING New
    );

BOOL
FindUserProperty (
    PUSER_PROPERTIES UserProperties,
    LPWSTR           Property,
    PUSER_PROPERTY  *pUserProperty,
    USHORT          *pCount
    );

VOID
RemoveUserProperty (
    UNICODE_STRING *puniUserParms,
    PUSER_PROPERTY  UserProperty,
    USHORT          Count,
    BOOL           *Update
    );

NTSTATUS
SetUserProperty (
    IN LPWSTR          UserParms,
    IN LPWSTR          Property,
    IN UNICODE_STRING  PropertyValue,
    IN WCHAR           PropertyFlag,
    OUT LPWSTR        *pNewUserParms,   // memory has to be freed afer use.
    OUT BOOL          *Update
    )
/*
    This function sets a property field in the user's Parameters field.
*/
{
    NTSTATUS status;
    UNICODE_STRING uniUserParms;
    UNICODE_STRING uniNewUserParms;
    USHORT Count = 0;
    USHORT PropertyLength;
    USHORT ValueLength;
    PUSER_PROPERTIES UserProperties;
    PUSER_PROPERTY   UserProperty;
    LPWSTR PropertyValueString = NULL;
    INT i;
    UCHAR *pchValue = NULL;

    // Check if parameters are correct.
    if (Property == NULL)
    {
        return( STATUS_INVALID_PARAMETER );
    }

    // Initialize output variables.
    *Update = FALSE;
    *pNewUserParms = NULL;

    // Converty UserParms to unicode string.
    uniUserParms.Buffer = UserParms;
    uniUserParms.Length = UserParms? (lstrlenW(UserParms) + 1)* sizeof (WCHAR)
                                   : 0;
    uniUserParms.MaximumLength = uniUserParms.Length;

    /** Get the length of the property name **/

    PropertyLength = (USHORT)(lstrlenW( Property ) * sizeof(WCHAR));

    /** Get the length of the property value **/
    ValueLength = PropertyValue.Length;

    if (ValueLength != 0)
    {
        // Converty property value to asci string so that
        // if property value is 0, it can be stored correctly.

        PropertyValueString = (LPWSTR) LocalAlloc (LPTR, (ValueLength+1)*sizeof (WCHAR));

        pchValue = (UCHAR *) PropertyValue.Buffer;

        // BUGBUG. Since wsprint converts 0x00 to 20 30 (20 is
        // space and 30 is 0), sscanf converts 20 30 to 0. If the
        // value is uncode string, this convertsion would not
        // convert back to original value. So if we want to store
        // some value in the UserParms, we have to pass in ansi
        // string.

        for (i = 0; i < ValueLength; i++)
        {
            wsprintfA ((PCHAR)(PropertyValueString+i), "%02x", *(pchValue+i));
        }

        *(PropertyValueString+ValueLength) = 0;
        ValueLength = ValueLength * sizeof (WCHAR);
    }

    //
    // check that user has valid property structure , if not, create one
    //

    if (UserParms != NULL)
    {
        Count = (USHORT)((lstrlenW (UserParms) + 1)* sizeof(WCHAR));
    }

    if (Count < sizeof( USER_PROPERTIES))
    {
        Count = sizeof( USER_PROPERTIES_HDR ) + sizeof(WCHAR);
    }

    if (ValueLength > 0)
    {
        Count += sizeof( USER_PROPERTY ) + PropertyLength + ValueLength;
    }

    if (Count > 0x7FFF)
    {
        // can't be bigger than 32K of user parms.
        return (STATUS_BUFFER_OVERFLOW);
    }

    status = UserPropertyAllocBlock( &uniUserParms,
                                     Count,
                                     &uniNewUserParms );

    if ( !NT_SUCCESS(status) )
    {
        return status;
    }

    // Make the output pNewUserParms point to uniNewUserPams's buffer
    // which is the new UserParms string.

    *pNewUserParms = uniNewUserParms.Buffer;

    UserProperties = (PUSER_PROPERTIES) uniNewUserParms.Buffer;

    if (FindUserProperty (UserProperties,
                          Property,
                          &UserProperty,
                          &Count))
    {
        RemoveUserProperty ( &uniNewUserParms,
                             UserProperty,
                             Count,
                             Update);
    }

    //
    //  If the new value of the property is not null, add it.
    //

    if (ValueLength > 0) {

        // find the end of the parameters list

        UserProperty = &(UserProperties->FirstProperty);

        for (Count = 1; Count <= UserProperties->Header.PropertyCount; Count++)
        {
            UserProperty = (PUSER_PROPERTY)
                               ((LPSTR)((LPSTR) UserProperty +
                                     sizeof(USER_PROPERTY) + // length of entry
                                     UserProperty->PropertyLength +
                                     UserProperty->ValueLength -
                                     sizeof(WCHAR)));  // for Property[0]
        }

        //
        // append it to the end and update length of string
        //

        UserProperty->PropertyFlag   = (PropertyFlag & NCP_SET) ?
                                        USER_PROPERTY_TYPE_SET :
                                        USER_PROPERTY_TYPE_ITEM;

        UserProperty->PropertyLength = PropertyLength;
        UserProperty->ValueLength    = ValueLength;

        RtlCopyMemory(  &(UserProperty->Property[0]),
                        Property,
                        PropertyLength );

        RtlCopyMemory(  &(UserProperty->Property[PropertyLength / sizeof(WCHAR)]),
                        PropertyValueString,
                        ValueLength );

        uniNewUserParms.Length +=
                        sizeof(USER_PROPERTY) + // length of entry
                        PropertyLength +    // length of property name string
                        ValueLength -       // length of value string
                        sizeof(WCHAR);      // account for WCHAR Property[1]

        UserProperties->Header.PropertyCount++;

        *Update = TRUE;
    }

    // UserParms is already null terminated. We don't need to set the
    // end of UserParms to be NULL since we zero init the buffer already.

    return( status );
} // SetUserProperty

#define MAPHEXTODIGIT(x) ( x >= '0' && x <= '9' ? (x-'0') :        \
                           x >= 'A' && x <= 'F' ? (x-'A'+10) :     \
                           x >= 'a' && x <= 'f' ? (x-'a'+10) : 0 )


NTSTATUS
QueryUserProperty (
    IN  LPWSTR          UserParms,
    IN  LPWSTR          PropertyName,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    )
/*
    This routine returns a user definable property value as it is stored
    in the user's Parameters field.  Note that the RAS/MAC fields are
    stripped before we start processing user properties.
*/
{
    USHORT          PropertyNameLength;
    USHORT          Count;
    PUSER_PROPERTY  UserProperty;
    WCHAR          *Value;
    UINT            i;
    CHAR           *PropertyValueString;
    CHAR           *pchValue;

    // Set PropertyValue->Length to 0 initially. If the property is not found
    // it will still be 0 on exit.

    PropertyValue->Length = 0;
    PropertyValue->Buffer = NULL;

    PropertyNameLength = (USHORT)(lstrlenW(PropertyName) * sizeof(WCHAR));

    // Check if UserParms have the right structure.

    if (FindUserProperty ((PUSER_PROPERTIES) UserParms,
                          PropertyName,
                          &UserProperty,
                          &Count) )
    {

        Value = (LPWSTR)(LPSTR)((LPSTR) &(UserProperty->Property[0]) +
                                          PropertyNameLength);

        //
        //  Found the requested property
        //

        //
        //  Copy the property flag.
        //

        if (PropertyFlag)
            *PropertyFlag = UserProperty->PropertyFlag;

        // Allocate memory for PropertyValue->Buffer

        PropertyValueString = LocalAlloc ( LPTR, UserProperty->ValueLength+1);
        PropertyValue->Buffer = LocalAlloc ( LPTR, UserProperty->ValueLength/sizeof(WCHAR));

        //
        //  Make sure the property value length is valid.
        //
        if ((PropertyValue->Buffer == NULL) || (PropertyValueString == NULL))
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Copy the property value to the buffer.
        //

        RtlCopyMemory( PropertyValueString,
                       Value,
                       UserProperty->ValueLength );

        pchValue = (CHAR *) PropertyValue->Buffer;

        // Convert from value unicode string to value.
        for (i = 0; i < UserProperty->ValueLength/sizeof(WCHAR) ; i++)
        {
             // sscanf will trash memory.
             // sscanf( PropertyValueString+2*i, "%2x", pchValue+i);

             pchValue[i] = MAPHEXTODIGIT( PropertyValueString[2*i]) * 16 +
                           MAPHEXTODIGIT( PropertyValueString[2*i+1]);
        }

        PropertyValue->Length = UserProperty->ValueLength/sizeof(WCHAR);
        PropertyValue->MaximumLength = UserProperty->ValueLength/sizeof(WCHAR);

        LocalFree( PropertyValueString);
    }

    return STATUS_SUCCESS;
} // QueryUserProperty


// Common routine used by QueryUserProperty() and SetUserProperty().

BOOL
FindUserProperty (
    PUSER_PROPERTIES UserProperties,
    LPWSTR           Property,
    PUSER_PROPERTY  *pUserProperty,
    USHORT          *pCount
    )
{
    BOOL   fFound = FALSE;
    USHORT PropertyLength;

    //
    // Check if user has valid property structure attached,
    // pointed to by UserProperties.
    //

    if (  ( UserProperties != NULL )
       && ( lstrlenW( (LPWSTR) UserProperties) * sizeof(WCHAR) >
            sizeof(UserProperties->Header.BacklevelParms))
       && ( UserProperties->Header.PropertySignature == USER_PROPERTY_SIGNATURE)
       )
    {
        //
        // user has valid property structure.
        //

        *pUserProperty = &(UserProperties->FirstProperty);

        PropertyLength = (USHORT)(lstrlenW( Property ) * sizeof(WCHAR));

        for ( *pCount = 1; *pCount <= UserProperties->Header.PropertyCount;
              (*pCount)++ )
        {
            if (  ( PropertyLength == (*pUserProperty)->PropertyLength )
               && ( RtlCompareMemory( &((*pUserProperty)->Property[0]),
                                      Property,
                                      PropertyLength ) == PropertyLength )
               )
            {
                fFound = TRUE;
                break;
            }

            *pUserProperty = (PUSER_PROPERTY)
                                     ((LPSTR) (*pUserProperty)
                                     + sizeof( USER_PROPERTY )
                                     + (*pUserProperty)->PropertyLength
                                     + (*pUserProperty)->ValueLength
                                     - sizeof(WCHAR));  // for Property[0]
        }
    }

    return( fFound );
} // FindUserProperty


// Remove a property field from the User Parms.

VOID
RemoveUserProperty (
    UNICODE_STRING *puniUserParms,
    PUSER_PROPERTY  UserProperty,
    USHORT          Count,
    BOOL           *Update
    )
{
    PUSER_PROPERTIES    UserProperties;
    PUSER_PROPERTY      NextProperty;
    USHORT              OldParmLength;

    UserProperties = (PUSER_PROPERTIES) puniUserParms->Buffer;

    OldParmLength = sizeof( USER_PROPERTY ) +
                    UserProperty->PropertyLength +
                    UserProperty->ValueLength -
                    sizeof(WCHAR);  // for Property[0]


    NextProperty = (PUSER_PROPERTY)(LPSTR)((LPSTR) UserProperty + OldParmLength);

    //
    // if we're not on the last one, copy the remaining buffer up
    //

    if (Count < UserProperties->Header.PropertyCount) {

        RtlMoveMemory(  UserProperty,
                        NextProperty,
                        puniUserParms->Length -
                        ((LPSTR) NextProperty -
                         (LPSTR) puniUserParms->Buffer ));
    }

    //
    //  Now reduce the length of the buffer by the amount we pulled out
    //

    puniUserParms->Length -= OldParmLength;

    UserProperties->Header.PropertyCount--;

    *Update = TRUE;
} // RemoveUserProperty


NTSTATUS
UserPropertyAllocBlock (
    IN PUNICODE_STRING     Existing,
    IN ULONG               DesiredLength,
    IN OUT PUNICODE_STRING New
    )
/*
    This allocates a larger block for user's parameters and copies the old
    block in.
*/
{
    PUSER_PROPERTIES    UserProperties;
    CLONG               Count;
    WCHAR               *pNewBuff;


    //
    //  We will allocate a new buffer to store the new parameters
    //  and copy the existing parameters into it.
    //

    New->Buffer = LocalAlloc (LPTR, DesiredLength);

    if ( New->Buffer == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    New->MaximumLength = (USHORT) DesiredLength;

    if (Existing != NULL)
    {

        New->Length = Existing->Length;

        RtlCopyMemory(  New->Buffer,
                        Existing->Buffer,
                        Existing->Length );
    }
    else
    {
        New->Length = 0;
    }

    //
    //  Ensure that we don't have any nulls in our string.
    //

    for ( Count = 0;
          Count < New->Length / sizeof(WCHAR);
          Count++ )
    {
        if (*(New->Buffer + Count) == L'\0')
        {
            New->Length = (USHORT) Count * sizeof(WCHAR);
            break;
        }
    }

    //
    //  now pad it out with spaces until reached Mac+Ras reserved length
    //

    pNewBuff = (WCHAR *) New->Buffer + ( New->Length / sizeof(WCHAR) );

    while ( New->Length < sizeof(UserProperties->Header.BacklevelParms))
    {
        *( pNewBuff++ ) = L' ';
        New->Length += sizeof(WCHAR);
    }

    //
    //  If the signature isn't there, stick it in and set prop count to 0
    //

    UserProperties = (PUSER_PROPERTIES) New->Buffer;

    if (New->Length < sizeof(USER_PROPERTIES_HDR) ||
        UserProperties->Header.PropertySignature != USER_PROPERTY_SIGNATURE)
    {

        UserProperties->Header.PropertySignature = USER_PROPERTY_SIGNATURE;
        UserProperties->Header.PropertyCount = 0;

        New->Length = sizeof(USER_PROPERTIES_HDR);
    }

    return STATUS_SUCCESS;
} // UserPropertyAllocBlock

// usrprop.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\usrprop.h ===
/*++

Copyright (c) 1993  Micro Computer Systems, Inc.

Module Name:

    usrprop.h

Abstract:

    This is the public include file for some of the functions used by
    User Manager and Server Manager.

Author:

    Congpa You 02-Dec-1993  Created.

Revision History:

--*/

#ifndef _USRPROP_H_
#define _USRPROP_H_

#define USER_PROPERTY_SIGNATURE L'P'

#define NWPASSWORD           L"NWPassword"
#define OLDNWPASSWORD        L"OldNWPassword"
#define MAXCONNECTIONS       L"MaxConnections"
#define NWTIMEPASSWORDSET    L"NWPasswordSet"
#define SZTRUE               L"TRUE"
#define GRACELOGINALLOWED    L"GraceLoginAllowed"
#define GRACELOGINREMAINING  L"GraceLoginRemaining"
#define NWLOGONFROM          L"NWLogonFrom"
#define NWHOMEDIR            L"NWHomeDir"
#define NW_PRINT_SERVER_REF_COUNT L"PSRefCount"

#define NWENCRYPTEDPASSWORDLENGTH 8

#define NO_LIMIT  0xffff

#define DEFAULT_MAXCONNECTIONS      NO_LIMIT
#define DEFAULT_NWPASSWORDEXPIRED   FALSE
#define DEFAULT_GRACELOGINALLOWED   6
#define DEFAULT_GRACELOGINREMAINING 6
#define DEFAULT_NWLOGONFROM         NULL
#define DEFAULT_NWHOMEDIR           NULL

#define USER_PROPERTY_TYPE_ITEM 1
#define USER_PROPERTY_TYPE_SET  2

//Encryption function
NTSTATUS ReturnNetwareForm (const char * pszSecretValue,
                            DWORD dwUserId,
                            const WCHAR * pchNWPassword,
                            UCHAR * pchEncryptedNWPassword);

NTSTATUS
SetUserProperty(
    IN LPWSTR             UserParms,
    IN LPWSTR             Property,
    IN UNICODE_STRING     PropertyValue,
    IN WCHAR              PropertyFlag,
    OUT LPWSTR *          pNewUserParms,  // memory has to be freed after use.
    OUT BOOL *            Update
    );

NTSTATUS
QueryUserProperty (
    IN     LPWSTR       UserParms,
    IN     LPWSTR       Property,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    );

#endif // _USRPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\version.h ===
/*
** Template for version resources.  Place this in your .rc file,
** editing the values for VER_FILETYPE, VER_FILESUBTYPE,
** VER_FILEDESCRIPTION_STR and VER_INTERNALNAME_STR as needed.
** See winver.h for possible values.
**
** Ntverp.h defines several global values that don't need to be
** changed except for official releases such as betas, sdk updates, etc.
**
** Common.ver has the actual version resource structure that all these
** #defines eventually initialize.
*/

/* #include <windows.h> needed if this will be the .rc file */

#include <ntverp.h>

/*-----------------------------------------------*/
/* the following lines are specific to this file */
/*-----------------------------------------------*/

/* VER_FILETYPE, VER_FILESUBTYPE, VER_FILEDESCRIPTION_STR
 * and VER_INTERNALNAME_STR must be defined before including COMMON.VER
 * The strings don't need a '\0', since common.ver has them.
 */
#define   VER_FILETYPE   VFT_APP
/* possible values:      VFT_UNKNOWN
            VFT_APP
            VFT_DLL
            VFT_DRV
            VFT_FONT
            VFT_VXD
            VFT_STATIC_LIB
*/
#define   VER_FILESUBTYPE   VFT2_UNKNOWN
/* possible values      VFT2_UNKNOWN
            VFT2_DRV_PRINTER
            VFT2_DRV_KEYBOARD
            VFT2_DRV_LANGUAGE
            VFT2_DRV_DISPLAY
            VFT2_DRV_MOUSE
            VFT2_DRV_NETWORK
            VFT2_DRV_SYSTEM
            VFT2_DRV_INSTALLABLE
            VFT2_DRV_SOUND
            VFT2_DRV_COMM
*/
#define VER_FILEDESCRIPTION_STR     "Migration Tool for NetWare"
#define VER_INTERNALNAME_STR        "NWConv"
#define VER_ORIGINALFILENAME_STR    "NWCONV.EXE"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\utils.h ===
/*+-------------------------------------------------------------------------+
  | Copyright 1993-1994 (C) Microsoft Corporation - All rights reserved.    |
  +-------------------------------------------------------------------------+*/

#ifndef _UTILS_
#define _UTILS_

#ifdef __cplusplus
extern "C"{
#endif

#define MAX_DRIVE 30

LPTSTR Lids(WORD idsStr);
void StringTableDestroy();
void CursorHourGlass();
void CursorNormal();
BOOL BitTest(int Bit, BYTE *Bits);
BOOL CenterWindow( HWND hwndChild, HWND hwndParent );
TCHAR *lstrchr(LPTSTR String, TCHAR c);
BOOL IsPath(LPTSTR Path);
LPTSTR lToStr(ULONG Number);
LPTSTR TimeToStr(ULONG TotTime);
void EscapeFormattingChars(LPTSTR String, ULONG BufferLength) ;

void  lsplitpath(const TCHAR *path, TCHAR *drive, TCHAR *dir, TCHAR *fname, TCHAR *ext);
void  lmakepath(TCHAR *path, const TCHAR *drive, const TCHAR *dir, const TCHAR *fname, const TCHAR *ext);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\event\dummy.c ===
void
DummyEntryPoint(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\vlistint.h ===
#include "windows.h"
#include "windowsx.h"
#include "vlist.h"

typedef struct tagVLISTBox
   {
      HWND      hwnd;             // hwnd of this VLIST box
      int       nId;              // Id of Control
      HINSTANCE hInstance;        // Instance of parent
      HWND      hwndParent;       // hwnd of parent of VLIST box
      HWND      hwndList;         // hwnd of List box
      WNDPROC   lpfnLBWndProc;    // Window procedure of list box
      int       nchHeight;        // Height of text line
      int       nLines;           // Number of lines in listbox
      LONG      styleSave;        // Save the Style Bits
      WORD      VLBoxStyle;       // List Box Style
      HANDLE    hFont;            // Font for List box
      LONG      lToplIndex;       // Top logical record number;
      int       nCountInBox;      // Number of Items in box.
      LONG      lNumLogicalRecs;  // Number of logical records
      VLBSTRUCT vlbStruct;        // Buffer to communicate to app
      WORD      wFlags;           // Various flags fot the VLB
                                  //
                                  // 0x01 - HasStrings
                                  // 0x02 - Use Data Values
                                  // 0x04 - Multiple Selections
                                  // 0x08 - Ok for parent to have focus
                                  // 0x10 - Control has focus

      LONG      lSelItem;         // List of selected items
      int       nvlbRedrawState;  // Redraw State
      BOOL      bHScrollBar;      // Does it have a H Scroll
} VLBOX;

typedef VLBOX NEAR *PVLBOX;
typedef VLBOX FAR  *LPVLBOX;


#define IDS_VLBOXNAME  1
#define VLBLBOXID      100
#define VLBEDITID      101

#define HASSTRINGS     0x01       // List box stores strings
#define USEDATAVALUES  0x02       // Use Data Values to talk to parent
#define MULTIPLESEL    0x04       // VLB has extended or multiple selection
#define PARENTFOCUS    0x08       // Ok for parent to have focus
#define HASFOCUS       0x10       // 0x10 - Control has focus

LRESULT CALLBACK VListBoxWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK LBSubclassProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

LONG VLBMessageItemHandler( PVLBOX pVLBox,  UINT message, LPTSTR lpfoo);
LONG VLBParentMessageHandler( PVLBOX pVLBox, UINT message, WPARAM wParam, LPARAM lParam);
LONG VLBNcCreateHandler( HWND hwnd, LPCREATESTRUCT lpcreateStruct);
LONG VLBCreateHandler( PVLBOX pVListBox, HWND hwnd, LPCREATESTRUCT lpcreateStruct);
void VLBNcDestroyHandler(HWND hwnd,  PVLBOX pVListBox, WPARAM wParam, LPARAM lParam);
void VLBDestroyHandler(HWND hwnd,  PVLBOX pVLBox, WPARAM wParam, LPARAM lParam);
void VLBSetFontHandler( PVLBOX pVListBox, HANDLE hFont, BOOL fRedraw);
int  VLBScrollDownLine( PVLBOX pVLBox);
int  VLBScrollUpLine( PVLBOX pVLBox);
int  VLBScrollDownPage( PVLBOX pVLBox, int nAdjustment);
int  VLBScrollUpPage( PVLBOX pVLBox, int nAdjustment);
void UpdateVLBWindow( PVLBOX pVLBox, LPRECT lpRect);
int  VLBFindPos( PVLBOX pVLBox, int nPos);
int  VLBFindPage( PVLBOX pVLBox, LONG lFindRecNum, BOOL bUpdateTop);
int  VLBFirstPage( PVLBOX pVLBox);
int  VLBLastPage( PVLBOX pVLBox);
LONG vlbSetCurSel( PVLBOX pVLBox, int nOption, LONG lParam);
int  vlbFindData( PVLBOX pVLBox, LONG lData);
void VLBSizeHandler( PVLBOX pVLBox, int nItemHeight);
int  vlbInVLB( PVLBOX pVLBox, LONG lData);
void VLBCountLines( PVLBOX pVLBox);

void vlbRedrawOff(PVLBOX pVLBox);
void vlbRedrawOn(PVLBOX pVLBox);

BOOL TestSelectedItem(PVLBOX pVLBox, VLBSTRUCT vlbStruct);
void SetSelectedItem(PVLBOX pVLBox);

void vlbPGDN(PVLBOX pVLBox);
void vlbPGUP(PVLBOX pVLBox);

void vlbLineDn(PVLBOX pVLBox);
void vlbLineUp(PVLBOX pVLBox);

void VLBFreeItem(PVLBOX pVLBox, long lFreeItem);
void VLBFreePage(PVLBOX pVLBox);

extern HANDLE  hInstance;              // Global instance handle for  DLL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\utils.c ===
/*++

Copyright (c) 1993-1995  Microsoft Corporation

Module Name:

   nwconv.c

Abstract:


Author:

    Arthur Hanson (arth) 27-Jul-1994

Revision History:

--*/


#include "globals.h"

LPTSTR alpsz[TOTAL_STRINGS];       // String resource array cache.
static UINT cswitch = 0;
static HCURSOR hCursor;


/////////////////////////////////////////////////////////////////////////
LPTSTR 
Lids(
   WORD idsStr
   )

/*++

Routine Description:

    Returns the requested string from the string table.  Caches the
    strings in an internal buffer.  Will return a NULL string if  the
    string can't be loaded.

Arguments:


Return Value:


--*/

{
   WORD idsString;
    static TCHAR  szEmpty[] = TEXT("");
    TCHAR Buffer[MAX_STRING_SIZE];

    WORD  nLen;
    LPTSTR lpsz;

   idsString = idsStr - IDS_STRINGBASE;
    if ((idsString == 0) ||( idsString > TOTAL_STRINGS))
        return(szEmpty);

   // -1 index as table is 0 based and 0 is not a valid string ID.
    if (alpsz[idsString-1])
        return((LPTSTR)alpsz[idsString-1]);

    if (!(nLen = (WORD) LoadString(hInst, idsStr, (LPTSTR) Buffer, MAX_STRING_SIZE)))
        return(szEmpty);

    if (!(lpsz = AllocMemory((nLen+1) * sizeof(TCHAR))))
        return(szEmpty);

    lstrcpy((LPTSTR)lpsz, (LPTSTR) Buffer);

    return (alpsz[idsString-1] = lpsz);
} // Lids


/////////////////////////////////////////////////////////////////////////
VOID 
StringTableDestroy()

/*++

Routine Description:

   Frees up all the memory allocated in the string table.

Arguments:


Return Value:


--*/

{
    int i;

    for (i=0; i < TOTAL_STRINGS ; i++ ) {
        if (alpsz[i]) {
            FreeMemory(alpsz[i]);
            alpsz[i]=NULL;
        }
    }
} // StringTableDestroy


/////////////////////////////////////////////////////////////////////////
VOID
CursorHourGlass()

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   if (!cswitch) {
      hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
      ShowCursor(TRUE);
   }

   cswitch++;

} // CursorHourGlass


/////////////////////////////////////////////////////////////////////////
VOID
CursorNormal()

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

   if (cswitch == 0)
      return;

   cswitch--;

   if (!cswitch) {
      ShowCursor(FALSE);
      SetCursor(hCursor);
   }

} // Cursor Normal


/////////////////////////////////////////////////////////////////////////
BOOL
BitTest(
   int Bit, 
   BYTE *Bits
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   int i, j;

   i = Bit / 8;
   j = Bit % 8;

   if ((Bits[i] >> j) & 0x01)
      return TRUE;
   else
      return FALSE;

} // BitTest


/////////////////////////////////////////////////////////////////////////
BOOL 
CenterWindow( 
   HWND hwndChild, 
   HWND hwndParent
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   RECT    rChild, rParent;
   int     wChild, hChild, wParent, hParent;
   int     wScreen, hScreen, xNew, yNew;
   HDC     hdc;

   // Get the Height and Width of the child window
   GetWindowRect (hwndChild, &rChild);
   wChild = rChild.right - rChild.left;
   hChild = rChild.bottom - rChild.top;

   // Get the Height and Width of the parent window
   GetWindowRect (hwndParent, &rParent);
   wParent = rParent.right - rParent.left;
   hParent = rParent.bottom - rParent.top;

   // Get the display limits
   hdc = GetDC (hwndChild);
   wScreen = GetDeviceCaps (hdc, HORZRES);
   hScreen = GetDeviceCaps (hdc, VERTRES);
   ReleaseDC (hwndChild, hdc);

   // Calculate new X position, then adjust for screen
   xNew = rParent.left + ((wParent - wChild) /2);
   if (xNew < 0)
      xNew = 0;
   else if ((xNew+wChild) > wScreen)
      xNew = wScreen - wChild;

   // Calculate new Y position, then adjust for screen
   yNew = rParent.top  + ((hParent - hChild) /2);
   if (yNew < 0)
      yNew = 0;
   else if ((yNew+hChild) > hScreen)
      yNew = hScreen - hChild;

   // Set it, and return
   return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);

} // CenterWindow


/////////////////////////////////////////////////////////////////////////
TCHAR *
lstrchr(
   LPTSTR String, 
   TCHAR c
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   TCHAR *ptrChar = String;
   BOOL Found = FALSE;

   while(*ptrChar && !Found) {
      if (*ptrChar == c)
         Found = TRUE;
      else
         ptrChar++;
   }

   if (Found)
      return ptrChar;
   else
      return NULL;

} // lstrchr


/////////////////////////////////////////////////////////////////////////
BOOL
IsPath(
   LPTSTR Path
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   ULONG len;
   LPTSTR ptr;

   len = lstrlen(Path);
   if (len < 2)   // must have a slash and character
      return FALSE;

   // now know path is at least 2 characters long
   ptr = Path;

   // if slash anywhere then it has to be a path
   while (*ptr)
      if (*ptr == TEXT('\\'))
         return TRUE;
      else
         ptr++;

   // no slash - unless this is a drive then it aint no path.
   if (Path[1] == TEXT(':'))
      return TRUE;

   return FALSE;

} // IsPath


/////////////////////////////////////////////////////////////////////////
LPTSTR 
lToStr(
   ULONG Number
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR String[15];
   TCHAR tString[15];
   LPTSTR sptr, dptr;
   ULONG Count;

   sptr = String;
   dptr = tString;
   wsprintf(tString, TEXT("%lu"), Number);
   Count = lstrlen(tString);

   *sptr++ = *dptr++;
   Count--;

   while (*dptr) {
      if (!(Count % 3))
         *sptr++ = TEXT(',');

      *sptr++ = *dptr++;
      Count--;
   }
   *sptr = TEXT('\0');

   return String;
} // lToStr;


/////////////////////////////////////////////////////////////////////////
LPTSTR 
TimeToStr(
   ULONG TotTime
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR String[10];
   ULONG Hours, Minutes, Seconds;

   Hours = TotTime / 3600;
   TotTime -= (Hours * 3600);
   Minutes = TotTime / 60;
   Seconds = TotTime - (Minutes * 60);

   wsprintf(String, TEXT("%3lu:%2lu:%2lu"), Hours, Minutes, Seconds);

   return String;
} // TimeToStr;


/////////////////////////////////////////////////////////////////////////
LPTSTR 
DateToStr(
   ULONG TotTime
   )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   static TCHAR String[10];
   ULONG Hours, Minutes, Seconds;

   Hours = TotTime / 3600;
   TotTime -= (Hours * 3600);
   Minutes = TotTime / 60;
   Seconds = TotTime - (Minutes * 60);

   wsprintf(String, TEXT("%3lu:%2lu:%2lu"), Hours, Minutes, Seconds);

   return String;
} // DateToStr;


/*+-----------------------------------------------------------------------+
  |   Took the _splitpath and _makepath routines and converted them to    |
  |   be NT (long file name) and Unicode friendly.                        |
  +-----------------------------------------------------------------------+*/


/////////////////////////////////////////////////////////////////////////
VOID
lsplitpath(
   const TCHAR *path, 
   TCHAR *drive, 
   TCHAR *dir, 
   TCHAR *fname, 
   TCHAR *ext
   )

/*++

Routine Description:

   Splits a path name into its individual components

Arguments:

   path  - pointer to path name to be parsed
   drive - pointer to buffer for drive component, if any
   dir   - pointer to buffer for subdirectory component, if any
   fname - pointer to buffer for file base name component, if any
   ext   - pointer to buffer for file name extension component, if any

Return Value:

   drive - pointer to drive string.  Includes ':' if a drive was given.
   dir   - pointer to subdirectory string.  Includes leading and
           trailing '/' or '\', if any.
   fname - pointer to file base name
   ext   - pointer to file extension, if any.  Includes leading '.'.

--*/

{
    TCHAR *p;
    TCHAR *last_slash = NULL, *dot = NULL;
    unsigned len;

    // init these so we don't exit with bogus values
    drive[0] = TEXT('\0');
    dir[0] = TEXT('\0');
    fname[0] = TEXT('\0');
    ext[0] = TEXT('\0');

    if (path[0] == TEXT('\0'))
      return;

    /*+---------------------------------------------------------------------+
      | Assume that the path argument has the following form, where any or  |
      | all of the components may be missing.                               |
      |                                                                     |
      |  <drive><dir><fname><ext>                                           |
      |                                                                     |
      |  drive:                                                             |
      |     0 to MAX_DRIVE-1 characters, the last of which, if any, is a    |
      |     ':' or a '\' in the case of a UNC path.                         |
      |  dir:                                                               |
      |     0 to _MAX_DIR-1 characters in the form of an absolute path      |
      |     (leading '/' or '\') or relative path, the last of which, if    |
      |     any, must be a '/' or '\'.  E.g -                               |
      |                                                                     |
      |     absolute path:                                                  |
      |        \top\next\last\     ; or                                     |
      |        /top/next/last/                                              |
      |     relative path:                                                  |
      |        top\next\last\  ; or                                         |
      |        top/next/last/                                               |
      |     Mixed use of '/' and '\' within a path is also tolerated        |
      |  fname:                                                             |
      |     0 to _MAX_FNAME-1 characters not including the '.' character    |
      |  ext:                                                               |
      |     0 to _MAX_EXT-1 characters where, if any, the first must be a   |
      |     '.'                                                             |
      +---------------------------------------------------------------------+*/

    // extract drive letter and :, if any
    if ( path[0] && (path[1] == TEXT(':')) ) {
        if (drive) {
            drive[0] = path[0];
            drive[1] = path[1];
            drive[2] = TEXT('\0');
        }
        path += 2;
    }

    // if no drive then check for UNC pathname
    if (drive[0] == TEXT('\0'))
      if ((path[0] == TEXT('\\')) && (path[1] == TEXT('\\'))) {
         // got a UNC path so put server-sharename into drive
         drive[0] = path[0];
         drive[1] = path[1];
         path += 2;

         p = &drive[2];
         while ((*path != TEXT('\0')) && (*path != TEXT('\\')))
            *p++ = *path++;

         if (*path == TEXT('\0'))
            return;

         // now sitting at the share - copy this as well (copy slash first)
         *p++ = *path++;
         while ((*path != TEXT('\0')) && (*path != TEXT('\\')))
            *p++ = *path++;

         // tack on terminating NULL
         *p = TEXT('\0');
      }

    /*+---------------------------------------------------------------------+
      | extract path string, if any.  Path now points to the first character|
      | of the path, if any, or the filename or extension, if no path was   |
      | specified.  Scan ahead for the last occurence, if any, of a '/' or  |
      | '\' path separator character.  If none is found, there is no path.  |
      | We will also note the last '.' character found, if any, to aid in   |
      | handling the extension.                                             |
      +---------------------------------------------------------------------+*/

    for (last_slash = NULL, p = (TCHAR *)path; *p; p++) {
        if (*p == TEXT('/') || *p == TEXT('\\'))
            // point to one beyond for later copy
            last_slash = p + 1;
        else if (*p == TEXT('.'))
            dot = p;
    }

    if (last_slash) {

        // found a path - copy up through last_slash or max. characters allowed,
        //  whichever is smaller
        if (dir) {
            len = (USHORT) __min((last_slash - path), (_MAX_DIR - 1));
            lstrcpyn(dir, path, len + 1);
            dir[len] = TEXT('\0');
        }
        path = last_slash;
    }

    /*+---------------------------------------------------------------------+
      | extract file name and extension, if any.  Path now points to the    |
      | first character of the file name, if any, or the extension if no    |
      | file name was given.  Dot points to the '.' beginning the extension,|
      | if any.                                                             |
      +---------------------------------------------------------------------+*/

    if (dot && (dot >= path)) {
        // found the marker for an extension - copy the file name up to the
        //  '.'.
        if (fname) {
            len = (USHORT) __min((dot - path), (_MAX_FNAME - 1));
            lstrcpyn(fname, path, len + 1);
            *(fname + len) = TEXT('\0');
        }

        // now we can get the extension - remember that p still points to the
        // terminating nul character of path.
        if (ext) {
            len = (USHORT) __min((p - dot), (_MAX_EXT - 1));
            lstrcpyn(ext, dot, len + 1);
            ext[len] = TEXT('\0');
        }
    }
    else {
        // found no extension, give empty extension and copy rest of string
        // into fname.
        if (fname) {
            len = (USHORT) __min((p - path), (_MAX_FNAME - 1));
            lstrcpyn(fname, path, len + 1);
            fname[len] = TEXT('\0');
        }
        if (ext) {
            *ext = TEXT('\0');
        }
    }

} // lsplitpath


/////////////////////////////////////////////////////////////////////////
VOID
lmakepath(
   TCHAR *path, 
   const TCHAR *drive, 
   const TCHAR *dir, 
   const TCHAR *fname, 
   const TCHAR *ext
   )

/*++

Routine Description:

   create a path name from its individual components.

Arguments:

   char *path - pointer to buffer for constructed path
   char *drive - pointer to drive component, may or may not contain
       trailing ':'
   char *dir - pointer to subdirectory component, may or may not include
       leading and/or trailing '/' or '\' characters
   char *fname - pointer to file base name component
   char *ext - pointer to extension component, may or may not contain
       a leading '.'.

Return Value:

   path - pointer to constructed path name

--*/

{
    const TCHAR *p;

    /*+---------------------------------------------------------------------+
      | we assume that the arguments are in the following form (although we |
      | do not diagnose invalid arguments or illegal filenames (such as     |
      | names longer than 8.3 or with illegal characters in them)           |
      |                                                                     |
      |  drive:                                                             |
      |     A  or  A:                                                       |
      |  dir:                                                               |
      |     \top\next\last\     ; or                                        |
      |     /top/next/last/     ; or                                        |
      |                                                                     |
      |     either of the above forms with either/both the leading and      |
      |     trailing / or \ removed.  Mixed use of '/' and '\' is also      |
      |      tolerated                                                      |
      |  fname:                                                             |
      |     any valid file name                                             |
      |  ext:                                                               |
      |     any valid extension (none if empty or null )                    |
      +---------------------------------------------------------------------+*/

    // copy drive
    if (drive && *drive)
        while (*drive)
           *path++ = *drive++;

    // copy dir
    if ((p = dir) && *p) {
        do {
            *path++ = *p++;
        }
        while (*p);
        if ((*(p-1) != TEXT('/')) && (*(p-1) != TEXT('\\'))) {
            *path++ = TEXT('\\');
        }
    }

    // copy fname
    if (p = fname) {
        while (*p) {
            *path++ = *p++;
        }
    }

    // copy ext, including 0-terminator - check to see if a '.' needs to be
    // inserted.
    if (p = ext) {
        if (*p && *p != TEXT('.')) {
            *path++ = TEXT('.');
        }
        while (*path++ = *p++)
            ;
    }
    else {
        // better add the 0-terminator
        *path = TEXT('\0');
    }

} // lmakepath


#ifndef _UNICODE
#error "Function below not DBCS safe"
#endif

VOID
EscapeFormattingChars(
    LPTSTR String,
    ULONG BufferLength
    )

/*++

Routine Description:

    Escapes any formatting chars (ie. % chars) in the string so 
    if you sprintf it, you dont trap out as a result of trying to
    access bogus stack data.

Arguments:

    String - String to fix up. Escaping is done IN PLACE.
    BufferLength - Size of the buffer the string is in. We need to know
        this since we are inserting characters. BufferLength is in 
        characters, not bytes.

Return Value:

    None

--*/
{


    ULONG Length; LONG Avail ;
    LPTSTR End, Tmp = String ;

    if (!Tmp)
        return ;

    Length = lstrlen(String) ;

    //
    // Point past end of string. We use this to figure out
    // via pointer substraction how much needs to be shifted
    // down as we insert chars.
    //
    End = Tmp + Length + 1 ;     

    //
    // How much is avail for escape chars
    //
    Avail = BufferLength - (Length+1) ;  

    while (*Tmp) {

        if (*Tmp == TEXT('%')) {

            //
            // If no more space, just change to '_'.
            //
            if (Avail <= 0) {

                *Tmp = TEXT('_') ;
            }
            else {

                //
                // Move string over and add escape character.
                // This is not very efficient but we assume
                // that this is not common.
                //
                --Avail ;
                memmove(Tmp+1,
                        Tmp,
                        (UINT) (End - Tmp)) ;
                *Tmp = TEXT('%') ;
                Tmp++ ;
            }


        }

        ++Tmp ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\convert\nwconv\vlist.h ===
#define VLB_OK            0
#define VLB_ERR           -1
#define VLB_ENDOFFILE     -1

#define VLBS_USEDATAVALUES     0x8000L  
#define VLBS_3DFRAME           0x4000L
#define VLBS_NOTIFY            0x0001L
#define VLBS_NOREDRAW          0x0004L
#define VLBS_OWNERDRAWFIXED    0x0010L
#define VLBS_HASSTRINGS        0x0040L
#define VLBS_USETABSTOPS       0x0080L
#define VLBS_NOINTEGRALHEIGHT  0x0100L
#define VLBS_WANTKEYBOARDINPUT 0x0400L
#define VLBS_DISABLENOSCROLL   0x1000L

// Application->VLIST messages               
// Corresponding to LB_ messages
#define VLB_RESETCONTENT        (WM_USER+500)
#define VLB_SETCURSEL           (WM_USER+501)
#define VLB_GETCURSEL           (WM_USER+502)
#define VLB_GETTEXT             (WM_USER+503)
#define VLB_GETTEXTLEN          (WM_USER+504)
#define VLB_GETCOUNT            (WM_USER+505)
#define VLB_SELECTSTRING        (WM_USER+506)
#define VLB_FINDSTRING          (WM_USER+507)
#define VLB_GETITEMRECT         (WM_USER+508)
#define VLB_GETITEMDATA         (WM_USER+509)
#define VLB_SETITEMDATA         (WM_USER+510)
#define VLB_SETITEMHEIGHT       (WM_USER+511)
#define VLB_GETITEMHEIGHT       (WM_USER+512)
#define VLB_FINDSTRINGEXACT     (WM_USER+513)
#define VLB_INITIALIZE          (WM_USER+514)
#define VLB_SETTABSTOPS         (WM_USER+515)
#define VLB_GETTOPINDEX         (WM_USER+516)
#define VLB_SETTOPINDEX         (WM_USER+517)
#define VLB_GETHORIZONTALEXTENT (WM_USER+518)
#define VLB_SETHORIZONTALEXTENT (WM_USER+519)

// Unique to VLIST
#define VLB_UPDATEPAGE          (WM_USER+520)
#define VLB_GETLINES            (WM_USER+521)
#define VLB_GETSCROLLPOS        (WM_USER+522)
#define VLB_HSCROLL             (WM_USER+523)
#define VLB_PAGEDOWN            (WM_USER+524)
#define VLB_PAGEUP              (WM_USER+525)
#define VLB_GETLISTBOXSTYLE     (WM_USER+526)
#define VLB_GETFOCUSHWND        (WM_USER+527)
#define VLB_GETVLISTSTYLE       (WM_USER+528)

#define VLB_TOVLIST_MSGMIN      VLB_RESETCONTENT
#define VLB_TOVLIST_MSGMAX      VLB_GETVLISTSTYLE 

// VLIST->Application messages  
// Conflicts with VLB_
#define VLBR_FINDSTRING         (WM_USER+600) 
#define VLBR_FINDSTRINGEXACT    (WM_USER+601) 
#define VLBR_SELECTSTRING       (WM_USER+602) 
#define VLBR_GETITEMDATA        (WM_USER+603)
#define VLBR_GETTEXT            (WM_USER+604)
#define VLBR_GETTEXTLEN         (WM_USER+605)

// Unique Messages
//
#define VLB_FIRST               (WM_USER+606)
#define VLB_PREV                (WM_USER+607)
#define VLB_NEXT                (WM_USER+608)
#define VLB_LAST                (WM_USER+609)
#define VLB_FINDITEM            (WM_USER+610)
#define VLB_RANGE               (WM_USER+611)
#define VLB_FINDPOS             (WM_USER+612)
#define VLB_DONE                (WM_USER+613)

// VLIST->Application Notifications
#define VLBN_FREEITEM           (WM_USER+700)
#define VLBN_FREEALL            (WM_USER+701)

#define VLB_TOAPP_MSGMIN        VLB_FINDSTRING
#define VLB_TOAPP_MSGMAX        VLBN_FREEALL

#define IDS_VLBOXNAME         1

typedef struct _VLBStruct {
   int   nCtlID;
   int   nStatus;
   LONG  lData;             // current data value 
   LONG  lIndex;            // current index
   LONG  lSelItem;          // current selection (if data value)
   LPTSTR lpTextPointer;
   LPTSTR lpFindString;
} VLBSTRUCT;

typedef VLBSTRUCT FAR*  LPVLBSTRUCT;

#define VLIST_CLASSNAME "VList"                    
extern BOOL WINAPI RegisterVListBox(HINSTANCE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\fpnw\client\logon.c ===
/*++

Copyright (c) 1993  Microsoft Corporation


Module Name:

    logon.c

Abstract:

    This module contains the routines called by MSV1_0 authentication package.

Author:

    Yi-Hsin Sung (yihsins)
    Andy Herron (andyhe) 06-Jun-1994 Added support for MSV1_0 subauthority

Revision History:

    Andy Herron (andyhe) 15-Aug-1994 Pulled out (older) unused MSV1_0
                                     subauthority routines.
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <windows.h>
#include <ntmsv1_0.h>
#include <crypt.h>
#include <fpnwcomm.h>
#include <usrprop.h>
#include <samrpc.h>
#include <samisrv.h>
#include <ntlsa.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <lmcons.h>
#include <logonmsv.h>

#define RESPONSE_SIZE       8
#define WKSTA_ADDRESS_SIZE  20
#define NET_ADDRESS_SIZE    8
#define NODE_ADDRESS_SIZE   12

#define MSV1_0_PASSTHRU     0x01
#define MSV1_0_GUEST_LOGON  0x02

#ifndef LOGON_SUBAUTH_SESSION_KEY
#define LOGON_SUBAUTH_SESSION_KEY 0x40
#endif

typedef NTSTATUS (*PF_SamIConnect)(
    IN PSAMPR_SERVER_NAME ServerName,
    OUT SAMPR_HANDLE *ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN TrustedClient
    );
typedef NTSTATUS (*PF_SamrOpenUser)(
     SAMPR_HANDLE DomainHandle,
     ACCESS_MASK DesiredAccess,
     ULONG UserId,
     SAMPR_HANDLE __RPC_FAR *UserHandle);

typedef NTSTATUS (*PF_SamrCloseHandle)(
     SAMPR_HANDLE __RPC_FAR *SamHandle);

typedef NTSTATUS (*PF_SamrQueryInformationDomain)(
     SAMPR_HANDLE DomainHandle,
     DOMAIN_INFORMATION_CLASS DomainInformationClass,
     PSAMPR_DOMAIN_INFO_BUFFER __RPC_FAR *Buffer);

typedef NTSTATUS (*PF_SamrOpenDomain)(
     SAMPR_HANDLE ServerHandle,
     ACCESS_MASK DesiredAccess,
     PRPC_SID DomainId,
     SAMPR_HANDLE __RPC_FAR *DomainHandle);

typedef NTSTATUS (*PF_SamIAccountRestrictions)(
    IN SAM_HANDLE UserHandle,
    IN PUNICODE_STRING LogonWorkstation,
    IN PUNICODE_STRING Workstations,
    IN PLOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    );

typedef VOID (*PF_SamIFree_SAMPR_DOMAIN_INFO_BUFFER )(
    PSAMPR_DOMAIN_INFO_BUFFER Source,
    DOMAIN_INFORMATION_CLASS Branch
    );

typedef NTSTATUS (NTAPI *PF_LsaIQueryInformationPolicyTrusted)(
    IN POLICY_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_POLICY_INFORMATION *Buffer
    );

typedef VOID (NTAPI *PF_LsaIFree_LSAPR_POLICY_INFORMATION )(
    IN POLICY_INFORMATION_CLASS InformationClass,
    IN PLSAPR_POLICY_INFORMATION PolicyInformation
    );

typedef NTSTATUS (NTAPI *PF_LsaIOpenPolicyTrusted)(
    OUT PLSAPR_HANDLE PolicyHandle
    );

typedef NTSTATUS (*PF_LsarQueryInformationPolicy)(
     LSAPR_HANDLE PolicyHandle,
     POLICY_INFORMATION_CLASS InformationClass,
     PLSAPR_POLICY_INFORMATION __RPC_FAR *PolicyInformation);

PF_SamIConnect pfSamIConnect = NULL;
PF_SamrOpenUser pfSamrOpenUser = NULL; 
PF_SamrCloseHandle pfSamrCloseHandle = NULL;
PF_SamrQueryInformationDomain pfSamrQueryInformationDomain = NULL;
PF_SamrOpenDomain pfSamrOpenDomain = NULL;
PF_SamIAccountRestrictions pfSamIAccountRestrictions = NULL;
PF_SamIFree_SAMPR_DOMAIN_INFO_BUFFER pfSamIFree_SAMPR_DOMAIN_INFO_BUFFER = NULL;
PF_LsaIQueryInformationPolicyTrusted pfLsaIQueryInformationPolicyTrusted = NULL;
PF_LsaIFree_LSAPR_POLICY_INFORMATION pfLsaIFree_LSAPR_POLICY_INFORMATION = NULL;
PF_LsaIOpenPolicyTrusted pfLsaIOpenPolicyTrusted = NULL;
PF_LsarQueryInformationPolicy pfLsarQueryInformationPolicy = NULL;

NTSTATUS LoadSamAndLsa(
    VOID
    ) ; 

NTSTATUS LoadSamAndLsa(
    VOID
    ) 
/*++

Routine Description:

    This routine loads the SAM/LSA dlls and resolves the entry points we
    need, to avoid staticly linking to those DLLs which do not expect to
    be loaded by proceses other than LSA. 


Arguments:

    None


Return Value:

    STATUS_SUCCESS: if there was no error.
    STATUS_DLL_NOT_FOUND: cannot load either DLL
    STATUS_ENTRYPOINT_NOT_FOUND: cannot get proc address for any of entry points

--*/
{
    static HMODULE hDllSam = NULL ;
    static HMODULE hDllLsa = NULL ;
    static NTSTATUS lastStatus = STATUS_SUCCESS ;

    if (hDllLsa && hDllSam) {

        return lastStatus ;
    }

    if (!(hDllSam = LoadLibrary(L"SAMSRV"))) {

        return  STATUS_DLL_NOT_FOUND ;
    }

    if (!(hDllLsa = LoadLibrary(L"LSASRV"))) {

        (void) FreeLibrary(hDllSam) ; 
        hDllSam = NULL ;

        return  STATUS_DLL_NOT_FOUND ;
    }

    pfSamIConnect = (PF_SamIConnect)
        GetProcAddress(hDllSam,"SamIConnect");
    pfSamrOpenUser = (PF_SamrOpenUser)
        GetProcAddress(hDllSam,"SamrOpenUser");
    pfSamrCloseHandle = (PF_SamrCloseHandle)
        GetProcAddress(hDllSam,"SamrCloseHandle");
    pfSamrQueryInformationDomain = (PF_SamrQueryInformationDomain)
        GetProcAddress(hDllSam,"SamrQueryInformationDomain") ;
    pfSamrOpenDomain = (PF_SamrOpenDomain)
        GetProcAddress(hDllSam,"SamrOpenDomain");
    pfSamIAccountRestrictions = (PF_SamIAccountRestrictions)
        GetProcAddress(hDllSam,"SamIAccountRestrictions");
    pfSamIFree_SAMPR_DOMAIN_INFO_BUFFER = (PF_SamIFree_SAMPR_DOMAIN_INFO_BUFFER)
        GetProcAddress(hDllSam,"SamIFree_SAMPR_DOMAIN_INFO_BUFFER");

    pfLsaIQueryInformationPolicyTrusted = (PF_LsaIQueryInformationPolicyTrusted)
        GetProcAddress(hDllLsa,"LsaIQueryInformationPolicyTrusted");
    pfLsaIFree_LSAPR_POLICY_INFORMATION = (PF_LsaIFree_LSAPR_POLICY_INFORMATION)
        GetProcAddress(hDllLsa,"LsaIFree_LSAPR_POLICY_INFORMATION");
    pfLsaIOpenPolicyTrusted = (PF_LsaIOpenPolicyTrusted)
        GetProcAddress(hDllLsa,"LsaIOpenPolicyTrusted");
    pfLsarQueryInformationPolicy = (PF_LsarQueryInformationPolicy)
        GetProcAddress(hDllLsa,"LsarQueryInformationPolicy");


    if (!( pfSamIConnect &&
           pfSamrOpenUser &&
           pfSamrCloseHandle &&
           pfSamrQueryInformationDomain &&
           pfSamrOpenDomain &&
           pfSamIAccountRestrictions &&
           pfSamIFree_SAMPR_DOMAIN_INFO_BUFFER &&
           pfLsaIQueryInformationPolicyTrusted &&
           pfLsaIFree_LSAPR_POLICY_INFORMATION &&
           pfLsaIOpenPolicyTrusted &&
           pfLsarQueryInformationPolicy) ) {
    
        //
        // cannot find at least one 
        //
        lastStatus = STATUS_ENTRYPOINT_NOT_FOUND ;

        (void) FreeLibrary(hDllSam) ; 
        hDllSam = NULL ;

        (void) FreeLibrary(hDllLsa) ; 
        hDllLsa = NULL ;
    }
    else {

        lastStatus = STATUS_SUCCESS ;
    }

    return lastStatus ;
}


///////////////////////////////////////////////////////////////////////////////

ULONG
MapRidToObjectId(
    DWORD dwRid,
    LPWSTR pszUserName,
    BOOL fNTAS,
    BOOL fBuiltin );

//
//  These are never closed once they're opened.  This is similar to how
//  msv1_0 does it.  Since there's no callback at shutdown time, we have no
//  way of knowing when to close them.
//

HANDLE SamDomainHandle = NULL;
SAMPR_HANDLE SamConnectHandle = NULL;
LSA_HANDLE LsaPolicyHandle = NULL;

//
//  This is where we store out LSA Secret
//

BOOLEAN GotSecret = FALSE;
UCHAR LsaSecretBuffer[USER_SESSION_KEY_LENGTH + 1];

//
// forward declare
//

BOOLEAN
MNSWorkstationValidate (
    IN PUNICODE_STRING Workstation,
    IN PUNICODE_STRING UserParameters
    );

BOOL
GetPasswordExpired(
    IN LARGE_INTEGER PasswordLastSet,
    IN LARGE_INTEGER MaxPasswordAge
    );

NTSTATUS
QueryDomainPasswordInfo (
    PSAMPR_DOMAIN_INFO_BUFFER *DomainInfo
    );

VOID
Shuffle(
    UCHAR *achObjectId,
    UCHAR *szUpperPassword,
    int   iPasswordLen,
    UCHAR *achOutputBuffer
    );

NTSTATUS GetNcpSecretKey( CHAR *pchNWSecretKey );


NTSTATUS
Msv1_0SubAuthenticationRoutine2 (
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime,
    OUT PUSER_SESSION_KEY UserSessionKey OPTIONAL
)
/*++

Routine Description:

    The subauthentication routine does cient/server specific authentication
    of a user.  The credentials of the user are passed in addition to all the
    information from SAM defining the user.  This routine decides whether to
    let the user logon.


Arguments:

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.

    Flags - Flags describing the circumstances of the logon.

        MSV1_0_PASSTHRU -- This is a PassThru authenication.  (i.e., the
            user isn't connecting to this machine.)
        MSV1_0_GUEST_LOGON -- This is a retry of the logon using the GUEST
            user account.

    UserAll -- The description of the user as returned from SAM.

    WhichFields -- Returns which fields from UserAllInfo are to be written
        back to SAM.  The fields will only be written if MSV returns success
        to it's caller.  Only the following bits are valid.

        USER_ALL_PARAMETERS - Write UserAllInfo->Parameters back to SAM.  If
            the size of the buffer is changed, Msv1_0SubAuthenticationRoutine
            must delete the old buffer using MIDL_user_free() and reallocate the
            buffer using MIDL_user_allocate().

    UserFlags -- Returns UserFlags to be returned from LsaLogonUser in the
        LogonProfile.  The following bits are currently defined:


            LOGON_GUEST -- This was a guest logon
            LOGON_NOENCRYPTION -- The caller didn't specify encrypted credentials
            LOGON_GRACE_LOGON -- The caller's password has expired but logon
                was allowed during a grace period following the expiration.
            LOGON_SUBAUTH_SESSION_KEY - a session key was returned from this
                logon

        SubAuthentication packages should restrict themselves to returning
        bits in the high order byte of UserFlags.  However, this convention
        isn't enforced giving the SubAuthentication package more flexibility.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    LogoffTime - Receives the time at which the user should logoff the
        system.  This time is specified as a GMT relative NT system time.

    KickoffTime - Receives the time at which the user should be kicked
        off the system. This time is specified as a GMT relative NT system
        time.  Specify, a full scale positive number if the user isn't to
        be kicked off.

    UserSessionKey - If non-null, recives a session key for this logon
        session.


Return Value:

    STATUS_SUCCESS: if there was no error.

    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    STATUS_INVALID_INFO_CLASS: LogonLevel is invalid.
    STATUS_ACCOUNT_LOCKED_OUT: The account is locked out
    STATUS_ACCOUNT_DISABLED: The account is disabled
    STATUS_ACCOUNT_EXPIRED: The account has expired.
    STATUS_PASSWORD_MUST_CHANGE: Account is marked as Password must change
        on next logon.
    STATUS_PASSWORD_EXPIRED: The Password is expired.
    STATUS_INVALID_LOGON_HOURS - The user is not authorized to logon at
        this time.
    STATUS_INVALID_WORKSTATION - The user is not authorized to logon to
        the specified workstation.

--*/
{
    NTSTATUS status;
    ULONG UserAccountControl;
    LARGE_INTEGER LogonTime;
    WCHAR    PropertyFlag;
    NT_OWF_PASSWORD DecryptedPassword;
    UCHAR    Response[RESPONSE_SIZE];
    UNICODE_STRING EncryptedPassword;
    UNICODE_STRING PasswordDateSet;
    UNICODE_STRING GraceLoginRemaining;
    SAMPR_HANDLE UserHandle;
    LARGE_INTEGER pwSetTime;
    PSAMPR_DOMAIN_INFO_BUFFER DomainInfo;
    PSAMPR_USER_INFO_BUFFER userControlInfo;
    LPWSTR pNewUserParams;
    int      index;
    UCHAR    achK[32];
    PNETLOGON_NETWORK_INFO LogonNetworkInfo;
    PCHAR challenge;
    BOOLEAN authoritative = TRUE;           // important default!
    ULONG   userFlags = 0;                  // important default!
    ULONG   whichFields = 0;                // important default!
    LARGE_INTEGER logoffTime;
    LARGE_INTEGER kickoffTime;

    pNewUserParams = NULL;
    DomainInfo = NULL;
    GraceLoginRemaining.Buffer = NULL;
    PasswordDateSet.Buffer = NULL;
    EncryptedPassword.Buffer = NULL;
    userControlInfo = NULL;

    logoffTime.HighPart  = 0x7FFFFFFF;      // default to no kickoff and
    logoffTime.LowPart   = 0xFFFFFFFF;      // no forced logoff
    kickoffTime.HighPart = 0x7FFFFFFF;
    kickoffTime.LowPart  = 0xFFFFFFFF;

    status = LoadSamAndLsa() ;
    if ( !NT_SUCCESS( status )) {
        
        return status ;
    }

    (VOID) NtQuerySystemTime( &LogonTime );

    //
    // Check whether the SubAuthentication package supports this type
    //  of logon.
    //

    if ( LogonLevel != NetlogonNetworkInformation ) {

        //
        // This SubAuthentication package only supports network logons.
        //

        status = STATUS_INVALID_INFO_CLASS;
        goto CleanUp;
    }

    //
    // This SubAuthentication package doesn't support access via machine
    // accounts.
    //

    UserAccountControl = USER_NORMAL_ACCOUNT;

    //
    // Local user (Temp Duplicate) accounts are only used on the machine
    // being directly logged onto.
    // (Nor are interactive or service logons allowed to them.)
    //

    if ( (Flags & MSV1_0_PASSTHRU) == 0 ) {
        UserAccountControl |= USER_TEMP_DUPLICATE_ACCOUNT;
    }

    LogonNetworkInfo = (PNETLOGON_NETWORK_INFO) LogonInformation;

    //
    //  If the account type isn't allowed,
    //  Treat this as though the User Account doesn't exist.
    //
    // This SubAuthentication package doesn't allow guest logons.
    //

    if ( ( (UserAccountControl & UserAll->UserAccountControl) == 0 ) ||
         ( Flags & MSV1_0_GUEST_LOGON ) ) {

        authoritative = FALSE;
        status = STATUS_NO_SUCH_USER;
        goto CleanUp;
    }

    //
    // Ensure the account isn't locked out.
    //

    if ( UserAll->UserId != DOMAIN_USER_RID_ADMIN &&
         (UserAll->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED) ) {

        //
        // Since the UI strongly encourages admins to disable user
        // accounts rather than delete them.  Treat disabled acccount as
        // non-authoritative allowing the search to continue for other
        // accounts by the same name.
        //
        if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
            authoritative = FALSE;
        }
        status = STATUS_ACCOUNT_LOCKED_OUT;
        goto CleanUp;
    }

    //
    // Get the encrypted password from the user parms field
    //

    status = NetpParmsQueryUserPropertyWithLength(   &UserAll->Parameters,
                                            NWPASSWORD,
                                            &PropertyFlag,
                                            &EncryptedPassword );

    if ( !NT_SUCCESS( status )) {

        goto CleanUp;
    }

    //
    // If the user does not have a netware password, fail the login
    //

    if ( EncryptedPassword.Length == 0 ) {

        status = STATUS_NO_SUCH_USER;
        goto CleanUp;
    }

    //
    //  Read our LSA secret if we haven't already
    //

    if (! GotSecret) {

        status = GetNcpSecretKey( &LsaSecretBuffer[0] );

        if (! NT_SUCCESS(status)) {

            goto CleanUp;
        }

        GotSecret = TRUE;
    }

    //
    // Decrypt the password with NetwareLsaSecret to get the one way form
    //

    status = RtlDecryptNtOwfPwdWithUserKey(
                 (PENCRYPTED_NT_OWF_PASSWORD) EncryptedPassword.Buffer,
                 (PUSER_SESSION_KEY) &LsaSecretBuffer[0],
                 &DecryptedPassword );

    if ( !NT_SUCCESS( status )) {

        goto CleanUp;
    }

    //
    //  Get the response to challenge.  We do this by finishing off the
    //  password encryption algorithm here.
    //

    challenge = (PCHAR) &(LogonNetworkInfo->LmChallenge);

    Shuffle( challenge, (UCHAR *) &(DecryptedPassword.data), 16, &achK[0] );
    Shuffle( challenge+4, (UCHAR *) &(DecryptedPassword.data), 16, &achK[16] );

    for (index = 0; index < 16; index++) {
        achK[index] ^= achK[31-index];
    }

    for (index = 0; index < RESPONSE_SIZE; index++) {
        Response[index] = achK[index] ^ achK[15-index];
    }

    if ( memcmp(    Response,
                    (PCHAR) (LogonNetworkInfo->LmChallengeResponse.Buffer),
                    RESPONSE_SIZE ) != 0 ) {

        //
        // Since the UI strongly encourages admins to disable user
        // accounts rather than delete them.  Treat disabled acccount as
        // non-authoritative allowing the search to continue for other
        // accounts by the same name.
        //

        if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
            authoritative = FALSE;
        }

        //
        //  if the user tried to use a NULL password, don't note this as
        //  a bad password attempt since LOGON.EXE does this by default.
        //  Instead, map it to STATUS_LOGON_FAILURE.
        //

        {
            UCHAR  pszShuffledNWPassword[NT_OWF_PASSWORD_LENGTH * 2];
            DWORD  chObjectId;
            NT_PRODUCT_TYPE ProductType;
            DWORD dwUserId;

            //
            //  first we calculate what the user's Object ID is...
            //

            RtlGetNtProductType( &ProductType );
            dwUserId = MapRidToObjectId(
                           UserAll->UserId,
                           UserAll->UserName.Buffer,
                           ProductType == NtProductLanManNt,
                           FALSE );
            chObjectId = SWAP_OBJECT_ID (dwUserId);

            //
            //  then we calculate the user's password residue with a null
            //  password
            //

            RtlZeroMemory( &pszShuffledNWPassword, NT_OWF_PASSWORD_LENGTH * 2 );

            Shuffle( (UCHAR *) &chObjectId, NULL, 0, pszShuffledNWPassword );

            //
            //  we then finish off the encryption as we did above for the
            //  password in the user's record.
            //

            challenge = (PCHAR) &(LogonNetworkInfo->LmChallenge);

            Shuffle( challenge, pszShuffledNWPassword, 16, &achK[0] );
            Shuffle( challenge+4, pszShuffledNWPassword, 16, &achK[16] );

            for (index = 0; index < 16; index++) {
                achK[index] ^= achK[31-index];
            }

            for (index = 0; index < RESPONSE_SIZE; index++) {
                Response[index] = achK[index] ^ achK[15-index];
            }

            //
            //  now if the password that the user sent in matches the encrypted
            //  form of the null password, we exit with a generic return code
            //  that won't cause the user's record to be updated.  This will
            //  also cause LSA to not wait for 3 seconds to return the error
            //  (which is a good thing in this case).
            //

            if ( memcmp(    Response,
                            (PCHAR) (LogonNetworkInfo->LmChallengeResponse.Buffer),
                            RESPONSE_SIZE ) == 0 ) {

                status = STATUS_LOGON_FAILURE;

            } else {

                status = STATUS_WRONG_PASSWORD;
            }
        }
        goto CleanUp;
    }

    //
    // Prevent rest of things from effecting the Administrator user
    //

    if (UserAll->UserId == DOMAIN_USER_RID_ADMIN) {

        status = STATUS_SUCCESS;
        goto CleanUp;
    }

    //
    // Check if the account is disabled.
    //

    if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {

        //
        // Since the UI strongly encourages admins to disable user
        // accounts rather than delete them.  Treat disabled acccount as
        // non-authoritative allowing the search to continue for other
        // accounts by the same name.
        //

        authoritative = FALSE;
        status = STATUS_ACCOUNT_DISABLED;
        goto CleanUp;
    }

    //
    // Check if the account has expired.
    //

    if (UserAll->AccountExpires.QuadPart > 0 &&
        LogonTime.QuadPart >= UserAll->AccountExpires.QuadPart ) {

        status = STATUS_ACCOUNT_EXPIRED;
        goto CleanUp;
    }

    status = QueryDomainPasswordInfo( &DomainInfo );

    if ( !NT_SUCCESS( status )) {

        goto CleanUp;
    }

    //
    // Response is correct. So, check if the password has expired or not
    //

    if (! (UserAll->UserAccountControl & USER_DONT_EXPIRE_PASSWORD)) {

        status = NetpParmsQueryUserPropertyWithLength(   &UserAll->Parameters,
                                                NWTIMEPASSWORDSET,
                                                &PropertyFlag,
                                                &PasswordDateSet );
        if ( !NT_SUCCESS( status ) ||
                    PasswordDateSet.Length < sizeof(LARGE_INTEGER) ) {

            // date last password was set was not present.... hmmm.
            // we won't update anything here but let someone know all
            // is not kosher by making this a grace login.

            userFlags = LOGON_GRACE_LOGON;

        } else {

            pwSetTime = *((PLARGE_INTEGER)(PasswordDateSet.Buffer));

            if ( (pwSetTime.HighPart == 0xFFFF &&
                  pwSetTime.LowPart == 0xFFFF ) ||
                  GetPasswordExpired( pwSetTime,
                        DomainInfo->Password.MaxPasswordAge )) {

                //
                //  if we're on a bdc, just exit with invalid password, then
                //  we'll go try it on the PDC.
                //

                POLICY_LSA_SERVER_ROLE_INFO *LsaServerRole;
                PLSAPR_POLICY_INFORMATION LsaPolicyBuffer = NULL;

                status = (*pfLsaIQueryInformationPolicyTrusted)(
                                PolicyLsaServerRoleInformation,
                                &LsaPolicyBuffer );

                if ( NT_SUCCESS( status ) && (LsaPolicyBuffer != NULL)) {

                    LsaServerRole = (POLICY_LSA_SERVER_ROLE_INFO *) LsaPolicyBuffer;

                    if (LsaServerRole->LsaServerRole == PolicyServerRoleBackup) {

                        LsaFreeMemory( LsaServerRole );

                        status = STATUS_PASSWORD_EXPIRED;
                        goto CleanUp;
                    }

                    LsaFreeMemory( LsaServerRole );
                }

                //
                // Password has expired, so check if grace login is still allowed
                //

                userFlags = LOGON_GRACE_LOGON;

                //
                //  if this is a password validate rather than an
                //  actual login, don't update/check grace logins.
                //

                if ( LogonNetworkInfo->Identity.Workstation.Length > 0 ) {

                    status = NetpParmsQueryUserPropertyWithLength(   &UserAll->Parameters,
                                                            GRACELOGINREMAINING,
                                                            &PropertyFlag,
                                                            &GraceLoginRemaining );

                    if ( ! NT_SUCCESS( status ) ) {

                        //
                        //  The grace login value cannot be determined.
                        //

                        goto CleanUp;

                    } else if (  ( GraceLoginRemaining.Length != 0 ) &&
                              ( *(GraceLoginRemaining.Buffer) > 0 ) ) {

                        //
                        // Password has expired and grace login is available.
                        // So, return success and decrease the grace login remaining
                        // in the user parms field.
                        //

                        BOOL fUpdate;

                        (*(GraceLoginRemaining.Buffer))--;

                        status = NetpParmsSetUserProperty( UserAll->Parameters.Buffer,
                                                  GRACELOGINREMAINING,
                                                  GraceLoginRemaining,
                                                  USER_PROPERTY_TYPE_ITEM,
                                                  &pNewUserParams,
                                                  &fUpdate );

                        if ( NT_SUCCESS( status) &&
                             fUpdate ) {

                            //
                            //  if we actually updated the parms, mark as such.
                            //

                            whichFields = USER_ALL_PARAMETERS;

                            //
                            //  The length of the parameters didn't grow... we
                            //  know that because we started with a value and
                            //  ended with the same value - 1 ( same length )
                            //

                            memcpy( UserAll->Parameters.Buffer,
                                    pNewUserParams,
                                    UserAll->Parameters.Length );
                        }
                        status = STATUS_SUCCESS;

                    } else {

                        status = STATUS_PASSWORD_EXPIRED;
                        goto CleanUp;
                    }
                }
            }
        }
    }

    //
    //  To validate the user's logon hours, we must have a handle to the user.
    //  We'll open the user here.
    //

    UserHandle = NULL;

    status = (*pfSamrOpenUser)(  SamDomainHandle,
                            USER_READ_ACCOUNT,
                            UserAll->UserId,
                            &UserHandle );

    if ( !NT_SUCCESS(status) ) {

        KdPrint(( "FPNWCLNT: Cannot SamrOpenUser %lX\n", status));
        goto CleanUp;
    }

    //
    // Validate the user's logon hours.
    //

    status = (*pfSamIAccountRestrictions)(   UserHandle,
                                        NULL,       // workstation id
                                        NULL,       // workstation list
                                        &UserAll->LogonHours,
                                        &logoffTime,
                                        &kickoffTime
                                        );
    (*pfSamrCloseHandle)( &UserHandle );

    if ( ! NT_SUCCESS( status )) {
        goto CleanUp;
    }

    //
    // Validate if the user can logon from this workstation.
    //  (Supply subauthentication package specific code here.)

    if ( ! MNSWorkstationValidate( &LogonNetworkInfo->Identity.Workstation,
                                   &UserAll->Parameters ) ) {

        status = STATUS_INVALID_WORKSTATION;
        goto CleanUp;
    }

    //
    //  The user is valid.  CleanUp up before returning.
    //

CleanUp:

    //
    // If we succeeded, create a session key.  The session key is created
    // by taking the decrypted password (a hash of the object id and
    // cleartext password) and adding the index of each byte to each byte
    // modulo 255, and using that to create a new challenge response from
    // the old challenge response.
    //

    if (NT_SUCCESS(status) && (UserSessionKey != NULL)) {
        UCHAR ChallengeResponse[NT_CHALLENGE_LENGTH];
        PUCHAR Password = (PUCHAR) &DecryptedPassword.data;
        PUCHAR SessionKey = (PUCHAR) UserSessionKey;

        ASSERT(RESPONSE_SIZE >= NT_CHALLENGE_LENGTH);

        RtlZeroMemory( UserSessionKey, sizeof(*UserSessionKey) );

        RtlCopyMemory(
            ChallengeResponse,
            Response,
            NT_CHALLENGE_LENGTH );

        //
        // Create the new password
        //

        for (index = 0; index < sizeof(DecryptedPassword) ; index++ ) {
            Password[index] = Password[index] + (UCHAR) index;
        }

        //
        // Use it to make a normal challenge response using the old challenge
        // response
        //

        Shuffle( ChallengeResponse, (UCHAR *) &(DecryptedPassword.data), 16, &achK[0] );
        Shuffle( ChallengeResponse+4, (UCHAR *) &(DecryptedPassword.data), 16, &achK[16] );

        for (index = 0; index < 16; index++) {
            achK[index] ^= achK[31-index];
        }

        for (index = 0; index < RESPONSE_SIZE; index++) {
            SessionKey[index] = achK[index] ^ achK[15-index];
        }
        userFlags |= LOGON_SUBAUTH_SESSION_KEY;

    }

    if (DomainInfo != NULL) {
        (*pfSamIFree_SAMPR_DOMAIN_INFO_BUFFER)( DomainInfo, DomainPasswordInformation );
    }
    if (EncryptedPassword.Buffer == NULL) {
        LocalFree( EncryptedPassword.Buffer );
    }
    if (PasswordDateSet.Buffer != NULL) {
        LocalFree( PasswordDateSet.Buffer );
    }
    if (GraceLoginRemaining.Buffer != NULL) {
        LocalFree( GraceLoginRemaining.Buffer );
    }
    if (pNewUserParams != NULL) {
        NetpParmsUserPropertyFree( pNewUserParams );
    }

    *Authoritative = authoritative;
    *UserFlags = userFlags;
    *WhichFields = whichFields;

    LogoffTime->HighPart  = logoffTime.HighPart;
    LogoffTime->LowPart   = logoffTime.LowPart;
    KickoffTime->HighPart = kickoffTime.HighPart;
    KickoffTime->LowPart  = kickoffTime.LowPart;

    return status;

} // Msv1_0SubAuthenticationRoutine



NTSTATUS
Msv1_0SubAuthenticationRoutine (
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
)
/*++

Routine Description:

    Compatibility wrapper for Msv1_0SubAuthenticationRoutine2.


Arguments:

    Same as Msv1_0SubAuthenticationRoutine2

Return Value:

    Same as Msv1_0SubAuthenticationRoutine2

--*/
{
    return(Msv1_0SubAuthenticationRoutine2(
            LogonLevel,
            LogonInformation,
            Flags,
            UserAll,
            WhichFields,
            UserFlags,
            Authoritative,
            LogoffTime,
            KickoffTime,
            NULL            // session key
            ) );
}

BOOLEAN
MNSWorkstationValidate (
    IN PUNICODE_STRING Workstation,
    IN PUNICODE_STRING UserParameters
)
{
    NTSTATUS status;
    WCHAR    PropertyFlag;
    UNICODE_STRING LogonWorkstations;
    INT      cbRequired;
    INT      cb;
    LPWSTR   pszTmp;

    if ( Workstation->Length < (NET_ADDRESS_SIZE * sizeof(WCHAR)) ) {

        //
        //  Zero is used when simply verifying a password.
        //
        //  We also check that the length is enough so we dont
        //  blow up later. If for some reason a bad string is
        //  supplied, we pass it. This should never happen. Not a
        //  security hole as the user has no control over the string.
        //

        return(TRUE);
    }

    status = NetpParmsQueryUserPropertyWithLength(   UserParameters,
                                            NWLOGONFROM,
                                            &PropertyFlag,
                                            &LogonWorkstations );

    if ( !NT_SUCCESS( status) || LogonWorkstations.Length == 0 ) {
        return TRUE;
    }

    cbRequired = (LogonWorkstations.Length + 1) * sizeof(WCHAR);
    pszTmp = LocalAlloc( LMEM_ZEROINIT, cbRequired);

    if ( pszTmp == NULL ) {

        //
        // Not enough memory to allocate the buffer. Just
        // let the user logon.
        //

        LocalFree( LogonWorkstations.Buffer );
        return TRUE;
    }

    cb = MultiByteToWideChar( CP_ACP,
                              MB_PRECOMPOSED,
                              (const CHAR *) LogonWorkstations.Buffer,
                              LogonWorkstations.Length,
                              pszTmp,
                              cbRequired );

    LocalFree( LogonWorkstations.Buffer ); // Don't need it any more

    if ( cb > 1 )
    {
        USHORT  TotalEntries = LogonWorkstations.Length/WKSTA_ADDRESS_SIZE;
        WCHAR   *pszEntry    = pszTmp;
        WCHAR   *pszWksta    = Workstation->Buffer ;

        _wcsupr(pszEntry) ;
        _wcsupr(pszWksta) ;

        while ( TotalEntries > 0 )
        {

            //
            // if net # is not wildcard, check for match
            //
            if (wcsncmp(L"FFFFFFFF", pszEntry, NET_ADDRESS_SIZE)!=0)
            {
                if (wcsncmp(pszWksta, pszEntry, NET_ADDRESS_SIZE)!=0)
                {
                    //
                    // if no match, goto next entry
                    //
                    pszEntry += WKSTA_ADDRESS_SIZE;
                    TotalEntries--;
                    continue ;
                }
            }

            //
            // from above, net number passes. check node number.
            // again, look for wildcard first.
            //
            if (wcsncmp(L"FFFFFFFFFFFF", pszEntry+NET_ADDRESS_SIZE,
                        NODE_ADDRESS_SIZE)!=0)
            {
                if (wcsncmp(pszEntry+NET_ADDRESS_SIZE,
                            pszWksta+NET_ADDRESS_SIZE,
                            NODE_ADDRESS_SIZE)!=0)
                {
                    //
                    // if no match, goto next entry
                    //
                    pszEntry += WKSTA_ADDRESS_SIZE;
                    TotalEntries--;
                    continue ;
                }
            }

            //
            // found a match. return it.
            //
            LocalFree( pszTmp );
            return TRUE;
        }
    } else {

        //
        // MultiByteToWideChar failed or empty string (ie. 1 char).
        // Just let the user logon
        //
        LocalFree( pszTmp );
        return TRUE;
    }

    LocalFree( pszTmp );
    return FALSE;
}

BOOL
GetPasswordExpired(
    IN LARGE_INTEGER PasswordLastSet,
    IN LARGE_INTEGER MaxPasswordAge
    )

/*++

Routine Description:

    This routine returns true if the password is expired, false otherwise.

Arguments:

    PasswordLastSet - Time when the password was last set for this user.

    MaxPasswordAge - Maximum password age for any password in the domain.

Return Value:

    Returns true if password is expired.  False if not expired.

--*/
{
    LARGE_INTEGER PasswordMustChange;
    NTSTATUS status;
    BOOLEAN rc;
    LARGE_INTEGER TimeNow;

    //
    // Compute the expiration time as the time the password was
    // last set plus the maximum age.
    //

    if (PasswordLastSet.QuadPart < 0 ||
        MaxPasswordAge.QuadPart > 0 ) {

        rc = TRUE;      // default for invalid times is that it is expired.

    } else {

        try {

            PasswordMustChange.QuadPart = PasswordLastSet.QuadPart -
                                          MaxPasswordAge.QuadPart;
            //
            // Limit the resultant time to the maximum valid absolute time
            //

            if ( PasswordMustChange.QuadPart < 0 ) {

                rc = FALSE;

            } else {

                status = NtQuerySystemTime( &TimeNow );
                if (NT_SUCCESS(status)) {

                    if ( TimeNow.QuadPart >= PasswordMustChange.QuadPart ) {
                        rc = TRUE;

                    } else {

                        rc = FALSE;
                    }
                } else {
                    rc = FALSE;     // won't fail if NtQuerySystemTime failed.
                }
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {

            rc = TRUE;
        }
    }

    return rc;
}

NTSTATUS
QueryDomainPasswordInfo (
    PSAMPR_DOMAIN_INFO_BUFFER *DomainInfo
    )
/*++

  This routine opens a handle to sam so that we can get the max password
  age.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES PolicyObjectAttributes;
    PLSAPR_POLICY_INFORMATION PolicyAccountDomainInfo = NULL;

    //
    //  if we don't yet have a domain handle, open domain handle so that
    //  we can query the domain's password expiration time.
    //

    status = LoadSamAndLsa() ;
    if ( !NT_SUCCESS( status )) {
        
        return status ;
    }

    if (SamDomainHandle == NULL) {

        //
        // Determine the DomainName and DomainId of the Account Database
        //

        if (LsaPolicyHandle == NULL) {

            InitializeObjectAttributes( &PolicyObjectAttributes,
                                          NULL,             // Name
                                          0,                // Attributes
                                          NULL,             // Root
                                          NULL );           // Security Descriptor

            status = (*pfLsaIOpenPolicyTrusted)(&LsaPolicyHandle);

            if ( !NT_SUCCESS(status) ) {

                LsaPolicyHandle = NULL;
                KdPrint(( "FPNWCLNT: Cannot LsaIOpenPolicyTrusted 0x%x\n", status));
                goto CleanUp;
            }
        }

        status = (*pfLsarQueryInformationPolicy)( LsaPolicyHandle,
                                             PolicyAccountDomainInformation,
                                             &PolicyAccountDomainInfo );

        if ( !NT_SUCCESS(status) ) {

            KdPrint(( "FPNWCLNT: Cannot LsarQueryInformationPolicy 0x%x\n", status));
            goto CleanUp;
        }

        if ( PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainSid == NULL ) {

            status = STATUS_NO_SUCH_DOMAIN;

            KdPrint(( "FPNWCLNT: Domain Sid is null 0x%x\n", status));
            goto CleanUp;
        }

        //
        // Open our connection with SAM
        //

        if (SamConnectHandle == NULL) {

            status = (*pfSamIConnect)( NULL,     // No server name
                                  &SamConnectHandle,
                                  SAM_SERVER_CONNECT,
                                  (BOOLEAN) TRUE );   // Indicate we are privileged

            if ( !NT_SUCCESS(status) ) {

                SamConnectHandle = NULL;

                KdPrint(( "FPNWCLNT: Cannot SamIConnect 0x%x\n", status));
                goto CleanUp;
            }
        }

        //
        // Open the domain.
        //

        status = (*pfSamrOpenDomain)( SamConnectHandle,
                                 DOMAIN_READ_OTHER_PARAMETERS,
                                 (RPC_SID *) PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainSid,
                                 &SamDomainHandle );

        if ( !NT_SUCCESS(status) ) {

            SamDomainHandle = NULL;
            KdPrint(( "FPNWCLNT: Cannot SamrOpenDomain 0x%x\n", status));
            goto CleanUp;
        }
    }

    status = (*pfSamrQueryInformationDomain)( SamDomainHandle,
                                         DomainPasswordInformation,
                                         DomainInfo );
    if ( !NT_SUCCESS(status) ) {

        KdPrint(( "FPNWCLNT: Cannot SamrQueryInformationDomain %lX\n", status));
        goto CleanUp;
    }

CleanUp:

    if (PolicyAccountDomainInfo != NULL) {
        (*pfLsaIFree_LSAPR_POLICY_INFORMATION)( PolicyAccountDomainInformation,
                                           PolicyAccountDomainInfo );
    }
    return(status);

} // QueryDomainPasswordInfo


// logon.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\fpnw\client\ncpbind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ncpbind.c

Abstract:

    Contains the RPC bind and un-bind routines for the NcpServer
    Service.

Author:

    Dan Lafferty (danl)     01-Mar-1991

Environment:

    User Mode -Win32

Revision History:

    01-Mar-1991 danl
        created
    07-Jun-1991 JohnRo
        Allowed debug output of failures.
    15-Nov-1993 Yi-Hsin
        Modify for NcpServer.

--*/

//
// INCLUDES
//
#include <nt.h>          // DbgPrint prototype
#include <rpc.h>         // DataTypes and runtime APIs
#include <ncpsvc.h>      // generated by the MIDL complier
#include <ntrpcp.h>      // Rpc utils
#include <srvnames.h>    // SERVER_INTERFACE_NAME



handle_t
NCPSVC_HANDLE_bind (
    NCPSVC_HANDLE   ServerName
    )

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the ncpserver service client stubs when
    it is necessary to bind to a server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    handle_t    bindingHandle = NULL;
    RPC_STATUS  status;

    status = RpcpBindRpc( ServerName,
                          SERVER_INTERFACE_NAME,
    //                      TEXT("Security=Impersonation Static True"),
                          TEXT("Security=Impersonation Dynamic False"),
                          &bindingHandle );

#if DBG
    if ( status != RPC_S_OK )
        KdPrint(("NCPSVC_HANDLE_bind: RpcpBindRpc failed status=%lC\n",status));
#endif

    return( bindingHandle );
}



void
NCPSVC_HANDLE_unbind (
    NCPSVC_HANDLE   ServerName,
    handle_t        BindingHandle
    )
/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.
    This routine is called from the ncpserver service client stubs when
    it is necessary to unbind to a server.


Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    UNREFERENCED_PARAMETER( ServerName );     // This parameter is not used

    RpcpUnbindRpc ( BindingHandle );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\fpnw\client\ncpsvc_c_stub.c ===
#include "ncpsvc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\fpnw\client\encrypt.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    encrypt.c

Abstract:

    This module implements the routines for the NetWare
    redirector to mangle an objectid, challenge key and
    password such that a NetWare server will accept the
    password as valid.

    This program uses information published in Byte Magazine.

Author:

    Colin Watson    [ColinW]    15-Mar-1993
    Andy Herron     [AndyHe]

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <nwsutil.h>
#include <fpnwcomm.h>
#include <usrprop.h>
#include <crypt.h>

UCHAR Table[] =
{0x7,0x8,0x0,0x8,0x6,0x4,0xE,0x4,0x5,0xC,0x1,0x7,0xB,0xF,0xA,0x8,
 0xF,0x8,0xC,0xC,0x9,0x4,0x1,0xE,0x4,0x6,0x2,0x4,0x0,0xA,0xB,0x9,
 0x2,0xF,0xB,0x1,0xD,0x2,0x1,0x9,0x5,0xE,0x7,0x0,0x0,0x2,0x6,0x6,
 0x0,0x7,0x3,0x8,0x2,0x9,0x3,0xF,0x7,0xF,0xC,0xF,0x6,0x4,0xA,0x0,
 0x2,0x3,0xA,0xB,0xD,0x8,0x3,0xA,0x1,0x7,0xC,0xF,0x1,0x8,0x9,0xD,
 0x9,0x1,0x9,0x4,0xE,0x4,0xC,0x5,0x5,0xC,0x8,0xB,0x2,0x3,0x9,0xE,
 0x7,0x7,0x6,0x9,0xE,0xF,0xC,0x8,0xD,0x1,0xA,0x6,0xE,0xD,0x0,0x7,
 0x7,0xA,0x0,0x1,0xF,0x5,0x4,0xB,0x7,0xB,0xE,0xC,0x9,0x5,0xD,0x1,
 0xB,0xD,0x1,0x3,0x5,0xD,0xE,0x6,0x3,0x0,0xB,0xB,0xF,0x3,0x6,0x4,
 0x9,0xD,0xA,0x3,0x1,0x4,0x9,0x4,0x8,0x3,0xB,0xE,0x5,0x0,0x5,0x2,
 0xC,0xB,0xD,0x5,0xD,0x5,0xD,0x2,0xD,0x9,0xA,0xC,0xA,0x0,0xB,0x3,
 0x5,0x3,0x6,0x9,0x5,0x1,0xE,0xE,0x0,0xE,0x8,0x2,0xD,0x2,0x2,0x0,
 0x4,0xF,0x8,0x5,0x9,0x6,0x8,0x6,0xB,0xA,0xB,0xF,0x0,0x7,0x2,0x8,
 0xC,0x7,0x3,0xA,0x1,0x4,0x2,0x5,0xF,0x7,0xA,0xC,0xE,0x5,0x9,0x3,
 0xE,0x7,0x1,0x2,0xE,0x1,0xF,0x4,0xA,0x6,0xC,0x6,0xF,0x4,0x3,0x0,
 0xC,0x0,0x3,0x6,0xF,0x8,0x7,0xB,0x2,0xD,0xC,0x6,0xA,0xA,0x8,0xD};

UCHAR Keys[32] =
{0x48,0x93,0x46,0x67,0x98,0x3D,0xE6,0x8D,
 0xB7,0x10,0x7A,0x26,0x5A,0xB9,0xB1,0x35,
 0x6B,0x0F,0xD5,0x70,0xAE,0xFB,0xAD,0x11,
 0xF4,0x47,0xDC,0xA7,0xEC,0xCF,0x50,0xC0};

#define XorArray( DEST, SRC ) {                             \
    PULONG D = (PULONG)DEST;                                \
    PULONG S = (PULONG)SRC;                                 \
    int i;                                                  \
    for ( i = 0; i <= 7 ; i++ ) {                           \
        D[i] ^= S[i];                                       \
    }                                                       \
}

int
Scramble(
    int   iSeed,
    UCHAR achBuffer[32]
    );

VOID
Shuffle(
    UCHAR *achObjectId,
    UCHAR *szUpperPassword,
    int   iPasswordLen,
    UCHAR *achOutputBuffer
    )

/*++

Routine Description:

    This routine shuffles around the object ID with the password

Arguments:

    IN achObjectId - Supplies the 4 byte user's bindery object id

    IN szUpperPassword - Supplies the user's uppercased password on the
        first call to process the password. On the second and third calls
        this parameter contains the OutputBuffer from the first call

    IN iPasswordLen - length of uppercased password

    OUT achOutputBuffer - Returns the 8 byte sub-calculation

Return Value:

    none.

--*/

{
    int     iTempIndex;
    int     iOutputIndex;
    UCHAR   achTemp[32];

    //
    //  Truncate all trailing zeros from the password.
    //

    while (iPasswordLen > 0 && szUpperPassword[iPasswordLen-1] == 0 ) {
        iPasswordLen--;
    }

    //
    //  Initialize the achTemp buffer. Initialization consists of taking
    //  the password and dividing it up into chunks of 32. Any bytes left
    //  over are the remainder and do not go into the initialization.
    //
    //  achTemp[0] = szUpperPassword[0] ^ szUpperPassword[32] ^ szUpper...
    //  achTemp[1] = szUpperPassword[1] ^ szUpperPassword[33] ^ szUpper...
    //  etc.
    //

    if ( iPasswordLen > 32) {

        //  At least one chunk of 32. Set the buffer to the first chunk.

        RtlCopyMemory( achTemp, szUpperPassword, 32 );

        szUpperPassword +=32;   //  Remove the first chunk
        iPasswordLen -=32;

        while ( iPasswordLen >= 32 ) {
            //
            //  Xor this chunk with the characters already loaded into
            //  achTemp.
            //

            XorArray( achTemp, szUpperPassword);

            szUpperPassword +=32;   //  Remove this chunk
            iPasswordLen -=32;
        }

    } else {

        //  No chunks of 32 so set the buffer to zero's

        RtlZeroMemory( achTemp, sizeof(achTemp));

    }

    //
    //  achTemp is now initialized. Load the remainder into achTemp.
    //  The remainder is repeated to fill achTemp.
    //
    //  The corresponding character from Keys is taken to seperate
    //  each repitition.
    //
    //  As an example, take the remainder "ABCDEFG". The remainder is expanded
    //  to "ABCDEFGwABCDEFGxABCDEFGyABCDEFGz" where w is Keys[7],
    //  x is Keys[15], y is Keys[23] and z is Keys[31].
    //
    //

    if (iPasswordLen > 0) {
        int iPasswordOffset = 0;
        for (iTempIndex = 0; iTempIndex < 32; iTempIndex++) {

            if (iPasswordLen == iPasswordOffset) {
                iPasswordOffset = 0;
                achTemp[iTempIndex] ^= Keys[iTempIndex];
            } else {
                achTemp[iTempIndex] ^= szUpperPassword[iPasswordOffset++];
            }
        }
    }

    //
    //  achTemp has been loaded with the users password packed into 32
    //  bytes. Now take the objectid that came from the server and use
    //  that to munge every byte in achTemp.
    //

    for (iTempIndex = 0; iTempIndex < 32; iTempIndex++)
        achTemp[iTempIndex] ^= achObjectId[ iTempIndex & 3];

    Scramble( Scramble( 0, achTemp ), achTemp );

    //
    //  Finally take pairs of bytes in achTemp and return the two
    //  nibbles obtained from Table. The pairs of bytes used
    //  are achTemp[n] and achTemp[n+16].
    //

    for (iOutputIndex = 0; iOutputIndex < 16; iOutputIndex++) {

        achOutputBuffer[iOutputIndex] =
            Table[achTemp[iOutputIndex << 1]] |
            (Table[achTemp[(iOutputIndex << 1) + 1]] << 4);
    }

    return;
}

int
Scramble(
    int   iSeed,
    UCHAR   achBuffer[32]
    )

/*++

Routine Description:

    This routine scrambles around the contents of the buffer. Each buffer
    position is updated to include the contents of at least two character
    positions plus an EncryptKey value. The buffer is processed left to right
    and so if a character position chooses to merge with a buffer position
    to its left then this buffer position will include bits derived from at
    least 3 bytes of the original buffer contents.

Arguments:

    IN iSeed
    IN OUT achBuffer[32]

Return Value:

    none.

--*/

{
    int iBufferIndex;

    for (iBufferIndex = 0; iBufferIndex < 32; iBufferIndex++) {
        achBuffer[iBufferIndex] =
            (UCHAR)(
                ((UCHAR)(achBuffer[iBufferIndex] + iSeed)) ^
                ((UCHAR)(   achBuffer[(iBufferIndex+iSeed) & 31] -
                    Keys[iBufferIndex] )));

        iSeed += achBuffer[iBufferIndex];
    }
    return iSeed;
}

NTSTATUS
ReturnNetwareForm(
    const char * pszSecretValue,
    DWORD dwUserId,
    const WCHAR * pchNWPassword,
    UCHAR * pchEncryptedNWPassword
    )

/*++

Routine Description:

    This routine takes the ObjectId and encrypts it with the user
    supplied password to develop a credential for the intermediate form.

Arguments:
    DWORD dwUserId - Supplies the 4 byte user's object id
    const WCHAR * pchNWPassword - Supplies the user's password

    UCHAR * pchEncryptedNWPassword - 16 characters where the result goes.

Return Value:

    none.

--*/

{
    DWORD          dwStatus;
    DWORD          chObjectId = SWAP_OBJECT_ID (dwUserId);
    UNICODE_STRING uniNWPassword;
    OEM_STRING     oemNWPassword;

    //
    //  shuffle actually uses 32 bytes, not just 16.  It only returns 16 though.
    //

    UCHAR          pszShuffledNWPassword[NT_OWF_PASSWORD_LENGTH * 2];

    uniNWPassword.Buffer = (WCHAR *) pchNWPassword;
    uniNWPassword.Length = (USHORT)(lstrlenW (pchNWPassword)*sizeof(WCHAR));
    uniNWPassword.MaximumLength = uniNWPassword.Length;

    if ((dwStatus = RtlUpcaseUnicodeStringToOemString (&oemNWPassword,
                                           &uniNWPassword,
                                           TRUE)) == STATUS_SUCCESS)
    {
        Shuffle((UCHAR *) &chObjectId, oemNWPassword.Buffer, oemNWPassword.Length, pszShuffledNWPassword);

        // Encrypt with LSA secret.
        dwStatus = RtlEncryptNtOwfPwdWithUserKey(
                       (PNT_OWF_PASSWORD) pszShuffledNWPassword,
                       (PUSER_SESSION_KEY) pszSecretValue,
                       (PENCRYPTED_NT_OWF_PASSWORD) pchEncryptedNWPassword);
    }

    return (dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\nw\fpnw\client\ncpstub.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    ncpstub.c

Abstract:

    Contains NCP Server APIs.

Author:

    Yi-Hsin Sung (yihsins)  11-Sept-1993
    Andy Herron  (andyhe)

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <rpc.h>
#include <ncpsvc.h>
#include <nwstruct.h>

DWORD NwpMapRpcError(
    IN DWORD RpcError
);


DWORD
FpnwApiBufferFree(
    IN LPVOID pBuffer
)
/*++

Routine Description:

    This API frees the memory allocated by all enumeration and getinfo APIs.

Arguments:

    pBuffer - A pointer to an API information buffer previously returned
              on an API call.

Return Value:

    Error.

--*/
{
    if ( pBuffer == NULL )
        return NO_ERROR;

    MIDL_user_free( pBuffer );
    return NO_ERROR;
}

DWORD
NwApiBufferFree(
    IN LPVOID pBuffer
)
{   return(FpnwApiBufferFree( pBuffer ));
}



DWORD
FpnwServerGetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT LPBYTE *ppServerInfo
)
/*++

Routine Description:

    This API returns the information about the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwLevel - Reserved for the level of the server structure requested, use
        1 for now.

    ppServerInfo - Place to store a pointer pointing to the returned
        NWSERVERINFO structure.

Return Value:

    Error.

--*/
{
    DWORD err;

    if ( dwLevel != 1 )
        return ERROR_INVALID_LEVEL;

    if ( ppServerInfo == NULL )
        return ERROR_INVALID_PARAMETER;

    RpcTryExcept
    {
        err = NwrServerGetInfo( pServerName,
                                dwLevel,
                                (PFPNWSERVERINFO *) ppServerInfo );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;

}
DWORD
NwServerGetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT PNWSERVERINFO *ppServerInfo
)
{   return(FpnwServerGetInfo(   pServerName,
                                dwLevel,
                                (LPBYTE *) ppServerInfo));
}



DWORD
FpnwServerSetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  LPBYTE pServerInfo
)
/*++

Routine Description:

    This API sets the information about the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwLevel - Reserved for the level of the server structure contained in
        pServerInfo, use 1 for now.

    pServerInfo - Points to a NWSERVERINFO structure which contains the server
        properties to set to.

Return Value:

    Error.

--*/
{
    DWORD err;

    if ( dwLevel != 1 )
        return ERROR_INVALID_LEVEL;

    if ( pServerInfo == NULL )
        return ERROR_INVALID_PARAMETER;

    RpcTryExcept
    {
        err = NwrServerSetInfo( pServerName,
                                dwLevel,
                                (PNWSERVERINFO) pServerInfo );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwServerSetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  PNWSERVERINFO pServerInfo
)
{   return( FpnwServerSetInfo( pServerName,
                               dwLevel,
                               (LPBYTE) pServerInfo ));
}



DWORD
FpnwVolumeAdd(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  LPBYTE pVolumeInfo
)
/*++

Routine Description:

    This API adds a volume to the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwLevel - Reserved for the level of the volume structure contained in
        pVolumeInfo, use 1 & 2 for now.

    pVolumeInfo - Points to a NWVOLUMEINFO structure which contains the
        information about the volume to be added, i.e. the volume name, path,
        type, user limit and description. dwCurrentUses will be ignored.

Return Value:

    Error.

--*/
{
    DWORD err;
    ULONG                       SDLength = 0;
    ULONG                       oldSDLength;
    PSECURITY_DESCRIPTOR        fileSecurityDescriptor = NULL;
    PSECURITY_DESCRIPTOR        oldFileSecurityDescriptor = NULL;
    PFPNWVOLUMEINFO_2 volInfo = (PFPNWVOLUMEINFO_2) pVolumeInfo;

    if ( dwLevel != 1 && dwLevel != 2 )
        return ERROR_INVALID_LEVEL;

    if ( pVolumeInfo == NULL )
        return ERROR_INVALID_PARAMETER;

    RpcTryExcept
    {
        if ( dwLevel == 2 ) {

            //
            // Save this. We need to restore this later.
            //

            oldFileSecurityDescriptor = volInfo->FileSecurityDescriptor;
            oldSDLength = volInfo->dwFileSecurityDescriptorLength;

            if ( oldFileSecurityDescriptor != NULL ) {

                if ( !RtlValidSecurityDescriptor( oldFileSecurityDescriptor ) ) {

                    return ERROR_INVALID_PARAMETER;
                }

                //
                // Make a self relative security descriptor for use in the
                // RPC call..
                //

                err = RtlMakeSelfRelativeSD(
                               oldFileSecurityDescriptor,
                               NULL,
                               &SDLength
                               );

                if (err != STATUS_BUFFER_TOO_SMALL) {

                    return(ERROR_INVALID_PARAMETER);

                } else {

                    fileSecurityDescriptor = MIDL_user_allocate( SDLength );

                    if ( fileSecurityDescriptor == NULL) {

                        return ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        //
                        // make an appropriate self-relative security descriptor
                        //

                        err = RtlMakeSelfRelativeSD(
                                       oldFileSecurityDescriptor,
                                       (PSECURITY_DESCRIPTOR) fileSecurityDescriptor,
                                       &SDLength
                                       );

                        if ( !NT_SUCCESS(err) ) {
                            MIDL_user_free( fileSecurityDescriptor );
                            return(ERROR_INVALID_PARAMETER);
                        }

                        volInfo->FileSecurityDescriptor = fileSecurityDescriptor;
                        volInfo->dwFileSecurityDescriptorLength = SDLength;
                    }
                }

            } else {

                volInfo->dwFileSecurityDescriptorLength = 0;
            }
        }

        err = NwrVolumeAdd( pServerName,
                            dwLevel,
                            (LPVOLUME_INFO) pVolumeInfo );

        if ( fileSecurityDescriptor != NULL ) {

            //
            // restore old values
            //

            volInfo->dwFileSecurityDescriptorLength = oldSDLength;
            volInfo->FileSecurityDescriptor = oldFileSecurityDescriptor;
            MIDL_user_free( fileSecurityDescriptor );
        }

    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwVolumeAdd(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  PNWVOLUMEINFO pVolumeInfo
)
{   return( FpnwVolumeAdd( pServerName, dwLevel, (LPBYTE) pVolumeInfo ));
}



DWORD
FpnwVolumeDel(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName
)
/*++

Routine Description:

    This API deletes a volume from the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    pVolumeName - Specifies teh volume name that is to be deleted.

Return Value:

    Error.

--*/
{
    DWORD err;

    if ( (pVolumeName == NULL) || (pVolumeName[0] == 0 ))
        return ERROR_INVALID_PARAMETER;

    RpcTryExcept
    {
        err = NwrVolumeDel( pServerName,
                            pVolumeName );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwVolumeDel(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName
)
{   return( FpnwVolumeDel( pServerName, pVolumeName ));
}



DWORD
FpnwVolumeEnum(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT LPBYTE *ppVolumeInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
/*++

Routine Description:

    This enumerates all volumes on the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwLevel - Reserved for the level of the volume structure contained in
        *ppVolumeInfo, use 1 for now.

    ppVolumeInfo - On return, this will point to an array of NWVOLUMEINFO
        structures, one for each volume on the server.

    pEntriesRead - On return, this will specify the number of volumes returned

    resumeHandle - On return, a resume handle is stored in the DWORD pointed
        to by resumeHandle, and is used to continue an existing server search.
        The handle should be zero on the first call and left unchanged for
        subsequent calls. If the resumeHandle is NULL, then no resume
        handle is stored.

Return Value:

    Error.

--*/
{
    DWORD err;

    FPNWVOLUMEINFO_CONTAINER NwVolumeInfoContainer;

    if ( dwLevel != 1 )
        return ERROR_INVALID_LEVEL;

    if ( ppVolumeInfo == NULL || pEntriesRead == NULL )
        return ERROR_INVALID_PARAMETER;

    NwVolumeInfoContainer.Buffer = NULL;

    RpcTryExcept
    {
        err = NwrVolumeEnum( pServerName,
                             dwLevel,
                             &NwVolumeInfoContainer,
                             resumeHandle );

        *ppVolumeInfo = (LPBYTE) NwVolumeInfoContainer.Buffer;

        if ( NwVolumeInfoContainer.Buffer != NULL ) {

            *pEntriesRead = NwVolumeInfoContainer.EntriesRead;

        } else {

            *pEntriesRead = 0;
        }
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwVolumeEnum(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT PNWVOLUMEINFO *ppVolumeInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
{   return(FpnwVolumeEnum(  pServerName,
                            dwLevel,
                            (LPBYTE *)ppVolumeInfo,
                            pEntriesRead,
                            resumeHandle ));
}



DWORD
FpnwVolumeGetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    OUT LPBYTE *ppVolumeInfo
)
/*++

Routine Description:

    This querys the information about the given volume on the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    pVolumeName - A pointer to a UNICODE string containing the name of the
        volume we want to get information on.

    dwLevel - Reserved for the level of the volume structure contained in
        *ppVolumeInfo, use 1 for now.

    ppVolumeInfo - On return, this will point to a NWVOLUMEINFO structure
        which contains information on the given volume on the given server.

Return Value:

    Error.

--*/
{
    DWORD err;

    if ( dwLevel != 1 && dwLevel != 2 ) {
        return ERROR_INVALID_LEVEL;
    }

    if ((pVolumeName == NULL) ||
        (pVolumeName[0] == 0 ) ||
        (ppVolumeInfo == NULL) ) {

        return ERROR_INVALID_PARAMETER;
    }

    *ppVolumeInfo = NULL ;

    RpcTryExcept
    {
        err = NwrVolumeGetInfo( pServerName,
                                pVolumeName,
                                dwLevel,
                                (LPVOLUME_INFO *) ppVolumeInfo );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwVolumeGetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    OUT PNWVOLUMEINFO *ppVolumeInfo
)
{   return(FpnwVolumeGetInfo(   pServerName,
                                pVolumeName,
                                dwLevel,
                                (LPBYTE *)ppVolumeInfo ));
}



DWORD
FpnwVolumeSetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    IN  LPBYTE pVolumeInfo
)
/*++

Routine Description:

    This sets the information about the given volume on the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    pVolumeName - A pointer to a UNICODE string containing the name of the
        volume we want to set information on.

    dwLevel - Reserved for the level of the volume structure contained in
        pVolumeInfo, use 1 for now.

    pVolumeInfo - Points to a NWVOLUMEINFO structure which contains
        information on the given volume to set to. Only dwMaxUses can be
        set. All the other fields in this structure will be ignored.

Return Value:

    Error.

--*/
{
    DWORD err;
    ULONG SDLength = 0;
    ULONG oldSDLength;
    PFPNWVOLUMEINFO_2 volInfo = (PFPNWVOLUMEINFO_2) pVolumeInfo;

    PSECURITY_DESCRIPTOR        fileSecurityDescriptor = NULL;
    PSECURITY_DESCRIPTOR        oldFileSecurityDescriptor = NULL;

    if ( dwLevel != 1 && dwLevel != 2 )
        return ERROR_INVALID_LEVEL;

    if (  ((pVolumeName == NULL) ||
          ( pVolumeName[0] == 0 )) ||
          ( pVolumeInfo == NULL )
       ) {
        return ERROR_INVALID_PARAMETER;
    }

    RpcTryExcept
    {
        if ( dwLevel == 2 ) {

            //
            // Save this. We need to restore this later.
            //

            oldFileSecurityDescriptor = volInfo->FileSecurityDescriptor;
            oldSDLength = volInfo->dwFileSecurityDescriptorLength;

            if ( oldFileSecurityDescriptor != NULL ) {

                if ( !RtlValidSecurityDescriptor( oldFileSecurityDescriptor ) ) {

                    return ERROR_INVALID_PARAMETER;
                }

                //
                // Make a self relative security descriptor for use in the
                // RPC call..
                //

                err = RtlMakeSelfRelativeSD(
                               oldFileSecurityDescriptor,
                               NULL,
                               &SDLength
                               );

                if (err != STATUS_BUFFER_TOO_SMALL) {

                    return(ERROR_INVALID_PARAMETER);

                } else {

                    fileSecurityDescriptor = MIDL_user_allocate( SDLength );

                    if ( fileSecurityDescriptor == NULL) {

                        return ERROR_NOT_ENOUGH_MEMORY;

                    } else {

                        //
                        // make an appropriate self-relative security descriptor
                        //

                        err = RtlMakeSelfRelativeSD(
                                       oldFileSecurityDescriptor,
                                       (PSECURITY_DESCRIPTOR) fileSecurityDescriptor,
                                       &SDLength
                                       );

                        if ( !NT_SUCCESS(err) ) {
                            MIDL_user_free( fileSecurityDescriptor );
                            return(ERROR_INVALID_PARAMETER);
                        }

                        volInfo->FileSecurityDescriptor = fileSecurityDescriptor;
                        volInfo->dwFileSecurityDescriptorLength = SDLength;
                    }
                }

            } else {

                volInfo->dwFileSecurityDescriptorLength = 0;
            }
        }

        err = NwrVolumeSetInfo( pServerName,
                                pVolumeName,
                                dwLevel,
                                (LPVOLUME_INFO) pVolumeInfo );

        if ( fileSecurityDescriptor != NULL ) {

            //
            // restore old values
            //

            volInfo->dwFileSecurityDescriptorLength = oldSDLength;
            volInfo->FileSecurityDescriptor = oldFileSecurityDescriptor;
            MIDL_user_free( fileSecurityDescriptor );
        }

    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwVolumeSetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    IN  PNWVOLUMEINFO pVolumeInfo
)
{   return( FpnwVolumeSetInfo(  pServerName,
                                pVolumeName,
                                dwLevel,
                                (LPBYTE) pVolumeInfo ));
}



DWORD
FpnwConnectionEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    OUT LPBYTE *ppConnectionInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
/*++

Routine Description:

    This enumerates all connections on the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwLevel - Reserved for the level of the volume structure contained in
        *ppConnectionInfo, use 1 for now.

    ppConnectionInfo - On return, this will point to an array of
        NWCONNECTIONINFO structures, one for each volume on the server.

    pEntriesRead - On return, this will specify the number of current
        connecitons.

    resumeHandle - On return, a resume handle is stored in the DWORD pointed
        to by resumeHandle, and is used to continue an existing server search.
        The handle should be zero on the first call and left unchanged for
        subsequent calls. If the resumeHandle is NULL, then no resume
        handle is stored.

Return Value:

    Error.

--*/
{
    DWORD err;

    FPNWCONNECTIONINFO_CONTAINER NwConnectionInfoContainer;

    if ( dwLevel != 1 )
        return ERROR_INVALID_LEVEL;

    if (( ppConnectionInfo == NULL ) || ( pEntriesRead == NULL ))
        return ERROR_INVALID_PARAMETER;

    NwConnectionInfoContainer.Buffer = NULL;

    RpcTryExcept
    {
        err = NwrConnectionEnum( pServerName,
                                 dwLevel,
                                 &NwConnectionInfoContainer,
                                 resumeHandle );

        *ppConnectionInfo = (LPBYTE) NwConnectionInfoContainer.Buffer;

        if ( NwConnectionInfoContainer.Buffer != NULL ) {

            *pEntriesRead = NwConnectionInfoContainer.EntriesRead;

        } else {

            *pEntriesRead = 0;
        }
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwConnectionEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    OUT PNWCONNECTIONINFO *ppConnectionInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
{   return(FpnwConnectionEnum(  pServerName,
                                dwLevel,
                                (LPBYTE *) ppConnectionInfo,
                                pEntriesRead,
                                resumeHandle ));
}



DWORD
FpnwConnectionDel(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId
)
/*++

Routine Description:

    This delete the connection with the given connection id on the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwConnectionId - The identification number of the connection to tear down.

Return Value:

    Error.

--*/
{
    DWORD err;

    RpcTryExcept
    {
        err = NwrConnectionDel( pServerName,
                                dwConnectionId );
    }
    RpcExcept(1)
    {
        err = NwpMapRpcError( RpcExceptionCode() );
    }
    RpcEndExcept

    return err;
}
DWORD
NwConnectionDel(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId
)
{   return( FpnwConnectionDel( pServerName, dwConnectionId ));
}



DWORD
FpnwVolumeConnEnum(
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD dwLevel,
    IN LPWSTR pVolumeName OPTIONAL,
    IN DWORD  dwConnectionId,
    OUT LPBYTE *ppVolumeConnInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
/*++

Routine Description:

    This enumerates all connections to a volume or list all volumes used by
    a particular connection on the given server.

Arguments:

    pServerName - A pointer to a UNICODE string containing the name of the
        remote server on which the function is to execute. A NULL pointer
        or string specifies the local machine.

    dwLevel - Reserved for the level of the volume structure contained in
        *ppVolumeConnInfo, use 1 for now.

    pVolumeName - Specifies the volume name which we want to get all opened
        resources. This must be NULL if dwConnectionId is not 0.

    dwConnectionId - Specifies the connection id on which we want to get all
        opened resources. This must be 0 if pVolumeName is not NULL.

    ppVolumeConnInfo - On return, this will point to an array of
        NWVOLUMECONNINFO structures.

    pEntriesRead - On return, this will specify the number of NWVOLUMECONNINFO
        returned.

    resumeHandle - On return, a resume handle is stored in the DWORD pointed
        to by resumeHandle, and is used to continue an existing server search.
        The handle should be zero on the first call and left unchanged for
        subsequent calls. If the resumeHandle is NULL, then no resume
        handle is stored.

Return Value:

    Error.

--*/
{
    DWORD err;

    FPNWVOLUMECONNINFO_CONTAINER NwVolumeConnInfoContainer;

    if ( dwLevel != 1 )
        return ERROR_INVALID_LEVEL;

    if (  ( dwConnectionId == 0 )
       && (( pVolumeName == NULL ) || ( *pVolumeName == 0 ))
       )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (  ( dwConnectionId != 0 )
       && (( pVolumeName != NULL) && ( *pVolumeName != 0 ))
       )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (( ppVolumeConnInfo == NULL ) || ( pEntriesRead == NULL ))
        return ERROR_INVALID_PARAMETER;

    NwVolumeConnInfoContainer.Buffer = NULL;

    RpcTryExcept
    {
        err = NwrVolumeConnEnum( pServerName,
                                 dwLevel,
                                 pVolumeName,
     