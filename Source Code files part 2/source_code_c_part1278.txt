ll->WhichFields & USER_ALL_USERACCOUNTCONTROL)!=0);
                        if (AccountControlChange)
                        {
                            MachineAccount = ((All->UserAccountControl & USER_SERVER_TRUST_ACCOUNT)
                                                || (All->UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT));
                            MachineOrTrustAccount =
                                ((All->UserAccountControl & USER_MACHINE_ACCOUNT_MASK)!=0);
                            NoPasswordRequiredForAccount =
                                ((All->UserAccountControl & USER_PASSWORD_NOT_REQUIRED)!=0);
                        }
                        else
                        {
                            NoPasswordRequiredForAccount =
                                    ((V1aFixed.UserAccountControl & USER_PASSWORD_NOT_REQUIRED)!=0);
                            MachineAccount = (V1aFixed.UserAccountControl & USER_SERVER_TRUST_ACCOUNT)
                                          || (V1aFixed.UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT);
                            MachineOrTrustAccount = ((V1aFixed.UserAccountControl & USER_SERVER_TRUST_ACCOUNT)!=0);
                        }




                        if ((UserInformationClass == UserInternal4Information) ||
                            (UserInformationClass == UserInternal4InformationNew)) {

                            //
                            // The clear text password was sent, so use that.
                            //

                            NtStatus = SampDecryptPasswordWithSessionKey(
                                            UserHandle,
                                            UserInformationClass,
                                            Buffer,
                                            &ClearTextPassword
                                            );
                            if (!NT_SUCCESS(NtStatus)) {
                                break;
                            }

                        } else {

                            //
                            // Only trusted callers should be able to do this.
                            // DaveStr - 7/15/97 - Also add this capability for
                            // the loopback client who has the password in
                            // clear text and is passing it to SAM within the
                            // the process boundary - i.e. clear text is not
                            // going on the wire.  DS mandated that *it* got
                            // the password on a secure/encrypted connection.
                            //
                            //

                            if (    !AccountContext->TrustedClient
                                 && !AccountContext->LoopbackClient ) {
                                NtStatus = STATUS_ACCESS_DENIED;
                                break;
                            }
                            ASSERT(UserInformationClass == UserAllInformation);

                            //
                            // In this case the password is in the NtPassword
                            // field
                            //

                            NtStatus = SampDuplicateUnicodeString(
                                            &ClearTextPassword,
                                            &All->NtPassword
                                            );
                            if (!NT_SUCCESS(NtStatus)) {
                                break;
                            }

                        }

                        //
                        // The caller might be simultaneously setting
                        // the password and changing the account to be
                        // a machine or trust account.  In this case,
                        // we don't validate the password (e.g., length).
                        //

                        //
                        // Same logic also applies if PASSWORD_NOT_REQUIRED is set,
                        // or is being set
                        //


                        if (!MachineOrTrustAccount && !(NoPasswordRequiredForAccount
                                                        && (0==ClearTextPassword.Length))) {

                            UNICODE_STRING FullName;
                            

                            NtStatus = SampCheckPasswordRestrictions(
                                            UserHandle,
                                            &DomainPasswordInfo,
                                            &ClearTextPassword,
                                            NULL
                                            );

                            if (!NT_SUCCESS(NtStatus)) {
                                break;
                            }

                            //
                            // Get the account name and full name to pass
                            // to the password filter.
                            //

                            NtStatus = SampGetUnicodeStringAttribute(
                                            AccountContext,           // Context
                                            SAMP_USER_FULL_NAME,          // AttributeIndex
                                            FALSE,                   // MakeCopy
                                            &FullName             // UnicodeAttribute
                                            );

                            if (NT_SUCCESS(NtStatus)) {

                                NtStatus = SampPasswordChangeFilter(
                                                &AccountName,
                                                &FullName,
                                                &ClearTextPassword,
                                                NULL,
                                                TRUE                // set operation
                                                );

                            }


                            if (!NT_SUCCESS(NtStatus)) {
                                break;
                            }

                        }

                        //
                        // Check to see if we need to enforce the default password for
                        // machine accounts
                        //


                        if (MachineAccount)
                        {

                            NtStatus = SampEnforceDefaultMachinePassword(
                                                AccountContext,
                                                &ClearTextPassword,
                                                &DomainPasswordInfo
                                                );
                        }

                        if (!NT_SUCCESS(NtStatus)) {
                            break;
                        }


                        //
                        // Compute the hashed passwords.
                        //

                        NtStatus = SampCalculateLmAndNtOwfPasswords(
                                        &ClearTextPassword,
                                        &TmpLmPresent,
                                        &LmOwfBuffer,
                                        &NtOwfBuffer
                                        );
                        if (!NT_SUCCESS(NtStatus)) {
                            break;
                        }


                        TmpNtPresent = TRUE;
                        TmpLmBuffer = &LmOwfBuffer;
                        TmpNtBuffer = &NtOwfBuffer;

                        ClearTextPasswordPresent = TRUE;
                    }

                    //
                    // Block password resets on krbtgt excepting
                    // trusted clients for OWF passwords. If clear
                    // passwords are passed in then compute a new
                    // random password to be set on the krbtgt account
                    //

                    if ((DOMAIN_USER_RID_KRBTGT
                            ==AccountContext->TypeBody.User.Rid) &&
                        (!AccountContext->TrustedClient) &&
                        (!ClearTextPasswordPresent))
                    {
                        NtStatus = STATUS_ACCESS_DENIED;
                        break;
                    }
                    else if (ClearTextPasswordPresent)
                    {
                        BOOLEAN FreeRandomizedPassword;

                        NtStatus = SampRandomizeKrbtgtPassword(
                                        AccountContext,
                                        &ClearTextPassword,
                                        TRUE, //FreeOldPassword
                                        &FreeRandomizedPassword
                                        );

                        if (!NT_SUCCESS(NtStatus))
                        {
                            break;
                        }
                    }

                    //
                    // Set the password data
                    //

                    fSetUserPassword = TRUE;
                    NtStatus = SampStoreUserPasswords(
                                    AccountContext,
                                    TmpLmBuffer,
                                    TmpLmPresent,
                                    TmpNtBuffer,
                                    TmpNtPresent,
                                    FALSE,
                                    PasswordSet,
                                    &DomainPasswordInfo,
                                    ClearTextPasswordPresent?&ClearTextPassword:NULL
                                    );

                    //
                    // If we set the password,
                    //  set the PasswordLastSet time to now.
                    //

                    if ( NT_SUCCESS( NtStatus ) ) {
                        NtStatus = SampComputePasswordExpired(
                                    FALSE,  // Password doesn't expire now
                                    &V1aFixed.PasswordLastSet
                                    );
                    }


                    //
                    // Replicate immediately if this is a machine account
                    //

                    if ( (V1aFixed.UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT ) ||
                         ((All->WhichFields & USER_ALL_USERACCOUNTCONTROL ) &&
                          (All->UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) )) {
                        ReplicateImmediately = TRUE;
                    }
                    DeltaType = SecurityDbChangePassword;

                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_PASSWORDEXPIRED ) ) {

                    //
                    // If the PasswordExpired field is passed in,
                    //  Only update PasswordLastSet if the password is being
                    //  forced to expire or if the password is currently forced
                    //  to expire.
                    //
                    // Avoid setting the PasswordLastSet field to the current
                    // time if it is already non-zero.  Otherwise, the field
                    // will slowly creep forward each time this function is
                    // called and the password will never expire.
                    //
                    if ( All->PasswordExpired ||
                         (SampHasNeverTime.QuadPart == V1aFixed.PasswordLastSet.QuadPart) ) {

                        NtStatus = SampComputePasswordExpired(
                                        All->PasswordExpired,
                                        &V1aFixed.PasswordLastSet
                                        );
                    }

                    PasswordExpired = All->PasswordExpired;
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_PRIVATEDATA ) ) {

                    //
                    // Set the private data
                    //

                    NtStatus = SampSetPrivateUserData(
                                   AccountContext,
                                   All->PrivateData.Length,
                                   All->PrivateData.Buffer
                                   );
                }

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_SECURITYDESCRIPTOR ) ) {

                    //
                    // Should validate SD first, for both
                    // DS and Registry cases
                    //

                    NtStatus = SampValidatePassedSD(
                                    All->SecurityDescriptor.Length,
                                    (PISECURITY_DESCRIPTOR_RELATIVE) (All->SecurityDescriptor.SecurityDescriptor)
                                    );


                    if ( NT_SUCCESS(NtStatus) )
                    {
                        if (IsDsObject(AccountContext))
                        {
                            PSECURITY_DESCRIPTOR Nt4SD =
                               All->SecurityDescriptor.SecurityDescriptor;

                            PSECURITY_DESCRIPTOR Nt5SD = NULL;
                            ULONG                Nt5SDLength = 0;


                            //
                            // Upgrade the security descriptor to NT5 and set it
                            // on the object for trusted clients. For non trusted
                            // clients. Fail the call for non trusted clients. They
                            // should come in through SamrSetSecurityObject
                            //

                            if (AccountContext->TrustedClient)
                            {
                                NtStatus = SampConvertNt4SdToNt5Sd(
                                            Nt4SD,
                                            AccountContext->ObjectType,
                                            AccountContext,
                                            &(Nt5SD)
                                            );
                            }
                            else
                            {
                                NtStatus = STATUS_ACCESS_DENIED;
                            }


                            if (NT_SUCCESS(NtStatus))
                            {

                               ASSERT(Nt5SD!=NULL);

                               //
                               // Get the length
                               //

                               Nt5SDLength = GetSecurityDescriptorLength(Nt5SD);

                               //
                               // Set the security descriptor
                               //

                               NtStatus = SampSetAccessAttribute(
                                           AccountContext,
                                           SAMP_USER_SECURITY_DESCRIPTOR,
                                           Nt5SD,
                                           Nt5SDLength
                                           );

                               //
                               // Free the NT5 Security descriptor
                               //

                               MIDL_user_free(Nt5SD);


                            }
                        }
                        else
                        {
                            //
                            // Set the security descriptor
                            //

                            NtStatus = SampSetAccessAttribute(
                                           AccountContext,
                                           SAMP_USER_SECURITY_DESCRIPTOR,
                                           All->SecurityDescriptor.SecurityDescriptor,
                                           All->SecurityDescriptor.Length
                                           );
                        }
                    }
                }

                //
                // Set the fixed data
                //
                // Note that PasswordCanChange and PasswordMustChange
                // aren't stored; they're calculated when needed.
                //

                if ( ( NT_SUCCESS( NtStatus ) ) &&
                    ( All->WhichFields & USER_ALL_USERACCOUNTCONTROL ) ) {


                    if (!(All->WhichFields & USER_ALL_PRIMARYGROUPID))
                    {
                        //
                        // If caller is not specifying primary group id also, then
                        // change the primary group to the new defaults if necessary
                        //

                        SystemChangesPrimaryGroupId = TRUE;
                    }

                    NtStatus = SampSetUserAccountControl(
                                    AccountContext,
                                    All->UserAccountControl,
                                    &V1aFixed,
                                    SystemChangesPrimaryGroupId,
                                    &AccountUnlocked,
                                    &AccountGettingMorphed,
                                    &KeepOldPrimaryGroupMembership
                                    );

                    if (AccountGettingMorphed &&
                        (V1aFixed.UserAccountControl & USER_SERVER_TRUST_ACCOUNT)
                       )
                    {
                        //
                        // in this case, system automatically changes the primary
                        // group id. Patch this case.
                        //
                        SystemChangesPrimaryGroupId = TRUE;
                    }

                    if (( NT_SUCCESS( NtStatus ) ) && AccountGettingMorphed) {

                            //
                            // One or more of the machine account bits has
                            // changed; we'll notify netlogon below.
                            //

                            UserAccountControlChanged = TRUE;

                            IgnoreStatus = SampGetUnicodeStringAttribute(
                                               AccountContext,
                                               SAMP_USER_ACCOUNT_NAME,
                                               TRUE, // Make copy
                                               &OldAccountName
                                               );

                    }
                }

                if ( NT_SUCCESS( NtStatus ) ) {

                    if ( All->WhichFields & USER_ALL_LASTLOGON ) {

                        //
                        // Only trusted client can modify this field
                        // 
                        if (AccountContext->TrustedClient)
                        {
                            V1aFixed.LastLogon = All->LastLogon;

                            //
                            // update Last Logon TimeStamp (Only in DS Mode)
                            // 

                            NtStatus = SampDsUpdateLastLogonTimeStamp(
                                                AccountContext,
                                                V1aFixed.LastLogon,
                                                LocalLastLogonTimeStampSyncInterval
                                                );

                            if (!NT_SUCCESS(NtStatus))
                            {
                                break;
                            }
                        }
                        else
                        {
                            NtStatus = STATUS_ACCESS_DENIED; 
                            break;
                        }
                    }

                    if ( All->WhichFields & USER_ALL_LASTLOGOFF ) {

                        if (AccountContext->TrustedClient)
                        {
                            V1aFixed.LastLogoff = All->LastLogoff;
                        }
                        else
                        {
                            NtStatus = STATUS_ACCESS_DENIED; 
                            break;
                        }
                    }

                    if ( All->WhichFields & USER_ALL_PASSWORDLASTSET ) {

                        V1aFixed.PasswordLastSet = All->PasswordLastSet;
                    }

                    if ( All->WhichFields & USER_ALL_ACCOUNTEXPIRES ) {

                        V1aFixed.AccountExpires = All->AccountExpires;
                    }

                    if ( All->WhichFields & USER_ALL_PRIMARYGROUPID ) {

                        if (IsDsObject(AccountContext) &&
                            (V1aFixed.UserAccountControl & USER_SERVER_TRUST_ACCOUNT) &&
                            (V1aFixed.PrimaryGroupId == DOMAIN_GROUP_RID_CONTROLLERS)
                           )
                        {
                            //
                            // Domain Controller's Primary Group should ALWAYS be
                            // DOMAIN_GROUP_RID_CONTROLLERS
                            //
                            // For NT4 and earlier release, we do not enforce the above rule,
                            // therefore compensate here is change the error code to success.
                            //
                            // For all interim NT5 releases (until beta2), since their DC's
                            // primary group Id might have been changed, so by checking
                            // V1aFixed.PrimaryGroupId, we still allow them to change their
                            // DC's primary group id. But once it has been set back to
                            // RID_CONTROLLERS, we do not let them go any further.
                            //

                            if (!AccountContext->LoopbackClient &&
                                (DOMAIN_GROUP_RID_USERS==All->PrimaryGroupId))
                            {
                                // Come throught NT4
                                NtStatus = STATUS_SUCCESS;
                            }
                            else if (DOMAIN_GROUP_RID_CONTROLLERS == All->PrimaryGroupId)
                            {
                                NtStatus = STATUS_SUCCESS;
                            }
                            else
                            {
                                NtStatus = STATUS_DS_CANT_MOD_PRIMARYGROUPID;
                                break;
                            }
                        }
                        else
                        {
                            //
                            // Make sure the primary group is legitimate
                            // (it must be one the user is a member of)
                            //
                            NtStatus = SampAssignPrimaryGroup(
                                           AccountContext,
                                           All->PrimaryGroupId
                                           );
                            if (NT_SUCCESS(NtStatus)) {

                                KeepOldPrimaryGroupMembership = TRUE;
                                V1aFixed.PrimaryGroupId = All->PrimaryGroupId;

                            } else if ((DOMAIN_GROUP_RID_USERS==All->PrimaryGroupId)
                                      && (V1aFixed.UserAccountControl
                                            & USER_MACHINE_ACCOUNT_MASK)) {
                               //
                               // NT4 and earlier releases during machine join
                               // set the primary group id to domain users.
                               // however the account need not necessarily be part
                               // of domain users. Therefore compensate here
                               // by changing the error code to status success

                               NtStatus = STATUS_SUCCESS;

                            } else {
                                break;
                            }
                        }
                    }

                    if ( All->WhichFields & USER_ALL_COUNTRYCODE ) {

                        V1aFixed.CountryCode = All->CountryCode;
                    }

                    if ( All->WhichFields & USER_ALL_CODEPAGE ) {

                        V1aFixed.CodePage = All->CodePage;
                    }

                    if ( All->WhichFields & USER_ALL_BADPASSWORDCOUNT ) {

                        SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                                       (SAMP_LOG_ACCOUNT_LOCKOUT,
                                       "UserId: 0x%x BadPasswordCount set to %d\n", 
                                        V1aFixed.UserId,
                                        All->BadPasswordCount));

                        V1aFixed.BadPasswordCount = All->BadPasswordCount;

                        if (UserInformationClass == UserInternal3Information) {
                            //
                            // Also set LastBadPasswordTime;
                            //
                            V1aFixed.LastBadPasswordTime =
                                Buffer->Internal3.LastBadPasswordTime;

                            RtlTimeToTimeFields(
                                           &Buffer->Internal3.LastBadPasswordTime,
                                           &T1);

                            SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                                           (SAMP_LOG_ACCOUNT_LOCKOUT,
                                           "UserId: 0x%x LastBadPasswordTime set to: [0x%lx, 0x%lx]  %d:%d:%d\n",
                                           V1aFixed.UserId,
                                           Buffer->Internal3.LastBadPasswordTime.HighPart,
                                           Buffer->Internal3.LastBadPasswordTime.LowPart,
                                           T1.Hour, T1.Minute, T1.Second ));
                        }
                    }

                    if ( All->WhichFields & USER_ALL_LOGONCOUNT ) {

                        V1aFixed.LogonCount = All->LogonCount;
                    }

                    NtStatus = SampReplaceUserV1aFixed(
                               AccountContext,
                               &V1aFixed
                               );
                }

                break;

            case UserPreferencesInformation:

                V1aFixed.CountryCode = Buffer->Preferences.CountryCode;
                V1aFixed.CodePage    = Buffer->Preferences.CodePage;

                NtStatus = SampReplaceUserV1aFixed(
                           AccountContext,
                           &V1aFixed
                           );


                //
                // replace the user comment
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_USER_COMMENT,
                                   (PUNICODE_STRING)&(Buffer->Preferences.UserComment)
                                   );
                }


                break;


            case UserParametersInformation:


                //
                // replace the parameters
                //

                NtStatus = SampSetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_PARAMETERS,
                               (PUNICODE_STRING)&(Buffer->Parameters.Parameters)
                               );

                break;


            case UserLogonHoursInformation:

                NtStatus = SampReplaceUserLogonHours(
                               AccountContext,
                               (PLOGON_HOURS)&(Buffer->LogonHours.LogonHours)
                               );
                break;


            case UserNameInformation:

                //
                // first change the Full Name, then change the account name...
                //

                //
                // replace the full name - no value restrictions
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   (PUNICODE_STRING)&(Buffer->Name.FullName)
                                   );

                    //
                    // Change the account name
                    //

                    if (NT_SUCCESS(NtStatus)) {

                        NtStatus = SampChangeUserAccountName(
                                        AccountContext,
                                        (PUNICODE_STRING)&(Buffer->Name.UserName),
                                        V1aFixed.UserAccountControl,
                                        &OldAccountName
                                        );

                        //
                        // Get the Address of New Account Name
                        // 
                        NewAccountNameToRemove = 
                                (UNICODE_STRING *)&(Buffer->Name.UserName);

                        //
                        // RemoveAccountNameFromTable tells us whether
                        // the caller (this routine) is responsable 
                        // to remove the name from the table. 
                        // 
                        RemoveAccountNameFromTable = 
                            AccountContext->RemoveAccountNameFromTable;

                        //
                        // reset to FALSE
                        // 
                        AccountContext->RemoveAccountNameFromTable = FALSE;
                    }
                }


                //
                // Don't free the OldAccountName yet; we'll need it at the
                // very end.
                //

                break;


            case UserAccountNameInformation:

                NtStatus = SampChangeUserAccountName(
                                AccountContext,
                                (PUNICODE_STRING)&(Buffer->AccountName.UserName),
                                V1aFixed.UserAccountControl,
                                &OldAccountName
                                );

                //
                // Get the Address of New Account Name
                // 
                NewAccountNameToRemove = 
                            (UNICODE_STRING *)&(Buffer->AccountName.UserName);

                //
                // RemoveAccountNameFromTable tells us whether
                // the caller (this routine) is responsable 
                // to remove the name from the table. 
                // 
                RemoveAccountNameFromTable = 
                        AccountContext->RemoveAccountNameFromTable;

                //
                // reset to FALSE
                // 
                AccountContext->RemoveAccountNameFromTable = FALSE;

                //
                // Don't free the OldAccountName; we'll need it at the
                // very end.
                //

                break;


            case UserFullNameInformation:

                //
                // replace the full name - no value restrictions
                //

                NtStatus = SampSetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_FULL_NAME,
                               (PUNICODE_STRING)&(Buffer->FullName.FullName)
                               );
                break;



 
            case UserPrimaryGroupInformation:

                if (IsDsObject(AccountContext) &&
                    (V1aFixed.UserAccountControl & USER_SERVER_TRUST_ACCOUNT) &&
                    (V1aFixed.PrimaryGroupId == DOMAIN_GROUP_RID_CONTROLLERS)
                   )
                {
                    //
                    // Domain Controller's Primary Group should ALWAYS be
                    // DOMAIN_GROUP_RID_CONTROLLERS
                    //
                    // For NT4 and earlier release, we do not enforce the above rule,
                    // therefore compensate here is change the error code to success.
                    //
                    // For all interim NT5 releases (until beta2), since their DC's
                    // primary group Id might have been changed, so by checking
                    // V1aFixed.PrimaryGroupId, we still allow them to change their
                    // DC's primary group id. But once it has been set back to
                    // RID_CONTROLLERS, we do not let them go any further.
                    //

                    if (!AccountContext->LoopbackClient &&
                        (DOMAIN_GROUP_RID_USERS==Buffer->PrimaryGroup.PrimaryGroupId))
                    {
                        // Come throught NT4
                        NtStatus = STATUS_SUCCESS;
                    }
                    else if (DOMAIN_GROUP_RID_CONTROLLERS == Buffer->PrimaryGroup.PrimaryGroupId)
                    {
                        NtStatus = STATUS_SUCCESS;
                    }
                    else
                    {
                        NtStatus = STATUS_DS_CANT_MOD_PRIMARYGROUPID;
                    }
                }
                else
                {
                    //
                    // Make sure the primary group is legitimate
                    // (it must be one the user is a member of)
                    //
                    NtStatus = SampAssignPrimaryGroup(
                                   AccountContext,
                                   Buffer->PrimaryGroup.PrimaryGroupId
                                   );

                    //
                    // Update the V1_FIXED info.
                    //

                    if (NT_SUCCESS(NtStatus)) {

                        V1aFixed.PrimaryGroupId = Buffer->PrimaryGroup.PrimaryGroupId;
                        KeepOldPrimaryGroupMembership = TRUE;

                        NtStatus = SampReplaceUserV1aFixed(
                                   AccountContext,
                                   &V1aFixed
                                   );
                     } else if ((DOMAIN_GROUP_RID_USERS==Buffer->PrimaryGroup.PrimaryGroupId)
                                      && (V1aFixed.UserAccountControl
                                            & USER_MACHINE_ACCOUNT_MASK)) {
                           //
                           // NT4 and earlier releases during machine join
                           // set the primary group id to domain users.
                           // however the account need not necessarily be part
                           // of domain users. Therefore compensate here
                           // by changing the error code to status success

                        NtStatus = STATUS_SUCCESS;
                    }
                }

                break;

 
            case UserHomeInformation:

                //
                // replace the home directory
                //

                NtStatus = SampSetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_HOME_DIRECTORY,
                               (PUNICODE_STRING)&(Buffer->Home.HomeDirectory)
                               );

                //
                // replace the home directory drive
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_HOME_DIRECTORY_DRIVE,
                                   (PUNICODE_STRING)&(Buffer->Home.HomeDirectoryDrive)
                                   );
                }

                break;
 
            case UserScriptInformation:

                //
                // replace the script
                //

                NtStatus = SampSetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_USER_SCRIPT_PATH,
                               (PUNICODE_STRING)&(Buffer->Script.ScriptPath)
                               );

                break;

 
            case UserProfileInformation:

                //
                // replace the Profile
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_PROFILE_PATH,
                                   (PUNICODE_STRING)&(Buffer->Profile.ProfilePath)
                                   );
                }

                break;

 
            case UserAdminCommentInformation:

                //
                // replace the admin  comment
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_ADMIN_COMMENT,
                                   (PUNICODE_STRING)&(Buffer->AdminComment.AdminComment)
                                   );
                }

                break;

 
            case UserWorkStationsInformation:

                //
                // Convert the workstation list, which is given to us in
                // UI/Service format, to API list format before storing
                // it.
                //
                if ( (Buffer->WorkStations.WorkStations.Length > 0)
                  && (Buffer->WorkStations.WorkStations.Buffer == NULL) ) {

                    NtStatus = STATUS_INVALID_PARAMETER;
                    
                } else {

                    NtStatus = SampConvertUiListToApiList(
                                   (PUNICODE_STRING)&(Buffer->WorkStations.WorkStations),
                                   &ApiList,
                                   FALSE );
                }


                //
                // replace the admin workstations
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_WORKSTATIONS,
                                   &ApiList
                                   );

                    RtlFreeHeap( RtlProcessHeap(), 0, ApiList.Buffer );
                }

                break;

 
            case UserControlInformation:

                 SystemChangesPrimaryGroupId = TRUE;

                 NtStatus = SampSetUserAccountControl(
                                    AccountContext,
                                    Buffer->Control.UserAccountControl,
                                    &V1aFixed,
                                    TRUE,
                                    &AccountUnlocked,
                                    &AccountGettingMorphed,
                                    &KeepOldPrimaryGroupMembership
                                    );




                if ( NT_SUCCESS( NtStatus ) ) {

                    if ( AccountGettingMorphed ) {

                        //
                        // One or more of the machine account bits has
                        // changed; we'll notify netlogon below.
                        //

                        UserAccountControlChanged = TRUE;

                        IgnoreStatus = SampGetUnicodeStringAttribute(
                                           AccountContext,
                                           SAMP_USER_ACCOUNT_NAME,
                                           TRUE, // Make copy
                                           &OldAccountName
                                           );
                    }

                    NtStatus = SampReplaceUserV1aFixed(
                               AccountContext,
                               &V1aFixed
                               );

                }



                break;

 
            case UserExpiresInformation:

                //
                // If the user is the special account Administrator, return an
                // error if trying to set the expiry information, except to the
                // value that means that the account never expires.
                //

                if ((!AccountContext->TrustedClient) &&
                    ( AccountContext->TypeBody.User.Rid == DOMAIN_USER_RID_ADMIN )) {

                    LARGE_INTEGER AccountNeverExpires, Temp;

                    AccountNeverExpires = RtlConvertUlongToLargeInteger(
                                              SAMP_ACCOUNT_NEVER_EXPIRES
                                              );

                    OLD_TO_NEW_LARGE_INTEGER(All->AccountExpires, Temp);

                    if (!( Temp.QuadPart == AccountNeverExpires.QuadPart)) {

                        NtStatus = STATUS_SPECIAL_ACCOUNT;
                        break;
                    }
                }

                V1aFixed.AccountExpires = Buffer->Expires.AccountExpires;

                NtStatus = SampReplaceUserV1aFixed(
                               AccountContext,
                               &V1aFixed
                               );

                break;

 
            case UserSetPasswordInformation:

                ASSERT(FALSE); // Should have been mapped to INTERNAL1 on client side
                NtStatus = STATUS_INVALID_INFO_CLASS;
                break;

 
            case UserInternal1Information:
            case UserInternal5Information:
            case UserInternal5InformationNew:

                //
                // Get the effective domain policy
                //

                NtStatus = SampObtainEffectivePasswordPolicy(
                                &DomainPasswordInfo,
                                AccountContext,
                                TRUE
                                );

                if (!NT_SUCCESS(NtStatus))
                {
                    break;
                }
                //
                // Get copy of the account name to pass to
                // notification packages.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                                AccountContext,
                                SAMP_USER_ACCOUNT_NAME,
                                TRUE,    // Make copy
                                &AccountName
                                );

                if (!NT_SUCCESS(NtStatus)) {
                    break;
                }



                if (UserInformationClass == UserInternal1Information) {

                    LmPresent = Buffer->Internal1.LmPasswordPresent;
                    NtPresent = Buffer->Internal1.NtPasswordPresent;
                    PasswordExpired = Buffer->Internal1.PasswordExpired;

                    //
                    // If our client is trusted, they are on the server side
                    // and data from them will not have been encrypted with the
                    // user session key - so don't decrypt them
                    //

                    if ( AccountContext->TrustedClient ) {

                        //
                        // Copy the (not) encrypted owfs into the owf buffers
                        //

                        ASSERT(ENCRYPTED_LM_OWF_PASSWORD_LENGTH == LM_OWF_PASSWORD_LENGTH);
                        ASSERT(ENCRYPTED_NT_OWF_PASSWORD_LENGTH == NT_OWF_PASSWORD_LENGTH);

                        RtlCopyMemory(&LmOwfPassword,
                                      &Buffer->Internal1.EncryptedLmOwfPassword,
                                      LM_OWF_PASSWORD_LENGTH
                                      );

                        RtlCopyMemory(&NtOwfPassword,
                                      &Buffer->Internal1.EncryptedNtOwfPassword,
                                      NT_OWF_PASSWORD_LENGTH
                                      );

                    } else {


                        //
                        // This call came from the client-side. The
                        // The OWFs will have been encrypted with the session
                        // key across the RPC link.
                        //
                        // Get the session key and decrypt both OWFs
                        //

                        NtStatus = RtlGetUserSessionKeyServer(
                                       (RPC_BINDING_HANDLE)UserHandle,
                                       &UserSessionKey
                                       );

                        if ( !NT_SUCCESS( NtStatus ) ) {
                            break; // out of switch
                        }


                        //
                        // Decrypt the LM OWF Password with the session key
                        //

                        if ( Buffer->Internal1.LmPasswordPresent) {

                            NtStatus = RtlDecryptLmOwfPwdWithUserKey(
                                           &Buffer->Internal1.EncryptedLmOwfPassword,
                                           &UserSessionKey,
                                           &LmOwfPassword
                                           );
                            if ( !NT_SUCCESS( NtStatus ) ) {
                                break; // out of switch
                            }
                        }


                        //
                        // Decrypt the NT OWF Password with the session key
                        //

                        if ( Buffer->Internal1.NtPasswordPresent) {

                            NtStatus = RtlDecryptNtOwfPwdWithUserKey(
                                           &Buffer->Internal1.EncryptedNtOwfPassword,
                                           &UserSessionKey,
                                           &NtOwfPassword
                                           );

                            if ( !NT_SUCCESS( NtStatus ) ) {
                                break; // out of switch
                            }
                        }
                    }
                } else {

                     UNICODE_STRING FullName;

                    //
                    // Password was sent cleartext.
                    //

                    NtStatus = SampDecryptPasswordWithSessionKey(
                                    UserHandle,
                                    UserInformationClass,
                                    Buffer,
                                    &ClearTextPassword
                                    );
                    if (!NT_SUCCESS(NtStatus)) {
                        break;
                    }


                    //
                    // Compute the hashed passwords.
                    //

                    NtStatus = SampCalculateLmAndNtOwfPasswords(
                                    &ClearTextPassword,
                                    &LmPresent,
                                    &LmOwfPassword,
                                    &NtOwfPassword
                                    );
                    if (!NT_SUCCESS(NtStatus)) {
                        break;
                    }

                    NtStatus = SampObtainEffectivePasswordPolicy(
                                   &DomainPasswordInfo,
                                   AccountContext,
                                   TRUE
                                   );

                    if (!NT_SUCCESS(NtStatus))
                    {
                        break;
                    }

                    NtPresent = TRUE;
                    if (UserInternal5Information == UserInformationClass)
                    {
                        PasswordExpired = Buffer->Internal5.PasswordExpired;
                    }
                    else
                    {
                        ASSERT(UserInternal5InformationNew == UserInformationClass);

                        PasswordExpired = Buffer->Internal5New.PasswordExpired;
                    }

                    //
                    // If the account is not a workstation & server trust account
                    // and it not a service account like krbtgt.
                    // Get the full name to pass
                    // to the password filter.
                    //

                    if (( (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)== 0)
                        && (DOMAIN_USER_RID_KRBTGT!=AccountContext->TypeBody.User.Rid)) {

                        //
                        // Check the clear password against any password restrictions
                        //

                        NtStatus = SampCheckPasswordRestrictions(
                                        UserHandle,
                                        &DomainPasswordInfo,
                                        &ClearTextPassword,
                                        NULL
                                        );

                        if (!NT_SUCCESS(NtStatus)) {
                            break;
                        }

                        NtStatus = SampGetUnicodeStringAttribute(
                                        AccountContext,           // Context
                                        SAMP_USER_FULL_NAME,          // AttributeIndex
                                        FALSE,                   // MakeCopy
                                        &FullName             // UnicodeAttribute
                                        );

                        if (NT_SUCCESS(NtStatus)) {

                            NtStatus = SampPasswordChangeFilter(
                                            &AccountName,
                                            &FullName,
                                            &ClearTextPassword,
                                            NULL,
                                            TRUE                // set operation
                                            );

                        }

                    }
                    else if ((V1aFixed.UserAccountControl & USER_SERVER_TRUST_ACCOUNT)
                        || (V1aFixed.UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT))
                    {

                        NtStatus = SampEnforceDefaultMachinePassword(
                                        AccountContext,
                                        &ClearTextPassword,
                                        &DomainPasswordInfo
                                        );
                    }

                    if (!NT_SUCCESS(NtStatus)) {
                        break;
                    }

                    ClearTextPasswordPresent = TRUE;


                }
                //
                // Store away the new OWF passwords
                //

                fSetUserPassword = TRUE;
                NtStatus = SampStoreUserPasswords(
                                AccountContext,
                                &LmOwfPassword,
                                LmPresent,
                                &NtOwfPassword,
                                NtPresent,
                                FALSE,
                                PasswordSet,
                                &DomainPasswordInfo,
                                ClearTextPasswordPresent?&ClearTextPassword:NULL
                                );

                if ( NT_SUCCESS( NtStatus ) ) {

                    NtStatus = SampStorePasswordExpired(
                                   AccountContext,
                                   PasswordExpired
                                   );
                }

                //
                // Replicate immediately if this is a machine account
                //

                if ( V1aFixed.UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT ) {
                    ReplicateImmediately = TRUE;
                }


                break;



 
            case UserInternal2Information:

                if ( AccountContext->TrustedClient ) {

                    TellNetlogon = FALSE;

                    //
                    // There are two ways to set logon/logoff statistics:
                    //
                    //      1) Directly, specifying each one being set,
                    //      2) Implicitly, specifying the action to
                    //         represent
                    //
                    // These two forms are mutually exclusive.  That is,
                    // you can't specify both a direct action and an
                    // implicit action.  In fact, you can't specify two
                    // implicit actions either.
                    //

                    if (Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_INTER_SUCCESS_LOGON) {

                        RemainingFlags = Buffer->Internal2.StatisticsToApply
                                         & ~USER_LOGON_INTER_SUCCESS_LOGON;

                        //
                        // We allow the remaining flags to be 0,
                        // USER_LOGON_TYPE_KERBEROS, or USER_LOGON_TYPE_NTLM
                        //

                        if ( ( 0 == RemainingFlags ) ||
                             ( USER_LOGON_TYPE_KERBEROS == RemainingFlags ) ||
                             ( USER_LOGON_TYPE_NTLM == RemainingFlags ) ) {


                            //
                            // Set BadPasswordCount = 0
                            // Increment LogonCount
                            // Set LastLogon = NOW
                            // Reset the locked out time
                            //
                            //

                            if (V1aFixed.BadPasswordCount != 0) {
                
                                SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                                               (SAMP_LOG_ACCOUNT_LOCKOUT,
                                                "UserId: 0x%x Successful interactive logon, clearing badPwdCount\n",
                                                V1aFixed.UserId));
                            }

                            V1aFixed.BadPasswordCount = 0;
                            if (V1aFixed.LogonCount != 0xFFFF) {
                                V1aFixed.LogonCount += 1;
                            }
                            NtQuerySystemTime( &V1aFixed.LastLogon );

                            if ( IsDsObject( AccountContext ) )
                            {
                                if ( SAMP_LOCKOUT_TIME_SET( AccountContext ) )
                                {
                                    RtlZeroMemory( &AccountContext->TypeBody.User.LockoutTime, sizeof( LARGE_INTEGER ) );

                                    NtStatus = SampDsUpdateLockoutTime( AccountContext );
                                    if ( !NT_SUCCESS( NtStatus ) )
                                    {
                                        break;
                                    }

                                    SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                                                   (SAMP_LOG_ACCOUNT_LOCKOUT,
                                                   "UserId: 0x%x Successful interactive logon, unlocking account\n",
                                                    V1aFixed.UserId));

                                }
                            }

                            FlushOnlyLogonProperties=TRUE;

                        } else {
                            NtStatus = STATUS_INVALID_PARAMETER;
                            break;
                        }
                    }

                    if (Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_INTER_SUCCESS_LOGOFF) {
                        if ( (Buffer->Internal2.StatisticsToApply
                                 & ~USER_LOGON_INTER_SUCCESS_LOGOFF)  != 0 ) {

                            NtStatus = STATUS_INVALID_PARAMETER;
                            break;
                        } else {

                            //
                            // Set LastLogoff time
                            // Decrement LogonCount (don't let it become negative)
                            //

                            if (V1aFixed.LogonCount != 0) {
                                V1aFixed.LogonCount -= 1;
                            }
                            NtQuerySystemTime( &V1aFixed.LastLogoff );
                            FlushOnlyLogonProperties=TRUE;
                        }
                    }

                    if (Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_NET_SUCCESS_LOGON) {

                        RemainingFlags = Buffer->Internal2.StatisticsToApply
                                         & ~USER_LOGON_NET_SUCCESS_LOGON;

                        //
                        // We allow the remaining flags to be 0,
                        // USER_LOGON_TYPE_KERBEROS, or USER_LOGON_TYPE_NTLM
                        //

                        if ( ( 0 == RemainingFlags ) ||
                             ( USER_LOGON_TYPE_KERBEROS == RemainingFlags ) ||
                             ( USER_LOGON_TYPE_NTLM == RemainingFlags ) ) {


                            //
                            // Set BadPasswordCount = 0
                            // Set LastLogon = NOW
                            // Clear the locked time
                            //
                            //
                            //

                            if (V1aFixed.BadPasswordCount != 0) {
                
                                SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                                               (SAMP_LOG_ACCOUNT_LOCKOUT,
                                               "UserId: 0x%x Successful network logon, clearing badPwdCount\n",
                                                V1aFixed.UserId));
                            }

                            V1aFixed.BadPasswordCount = 0;
                            NtQuerySystemTime( &V1aFixed.LastLogon );

                            if ( IsDsObject( AccountContext ) )
                            {
                                if ( SAMP_LOCKOUT_TIME_SET( AccountContext ) )
                                {
                                    RtlZeroMemory( &AccountContext->TypeBody.User.LockoutTime, sizeof( LARGE_INTEGER ) );
                                    NtStatus = SampDsUpdateLockoutTime( AccountContext );
                                    if ( !NT_SUCCESS( NtStatus ) )
                                    {
                                        break;
                                    }

                                    SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                                                   (SAMP_LOG_ACCOUNT_LOCKOUT,
                                                   "UserId: 0x%x Successful network logon, unlocking account\n",
                                                    V1aFixed.UserId));
                                }
                            }

                             FlushOnlyLogonProperties=TRUE;
                        } else {
                            NtStatus = STATUS_INVALID_PARAMETER;
                            break;
                        }
                    }

                    if (Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_NET_SUCCESS_LOGOFF) {
                        if ( (Buffer->Internal2.StatisticsToApply
                                 & ~USER_LOGON_NET_SUCCESS_LOGOFF)  != 0 ) {

                            NtStatus = STATUS_INVALID_PARAMETER;
                            break;
                        } else {

                            //
                            // Set LastLogoff time
                            //

                            NtQuerySystemTime( &V1aFixed.LastLogoff );
                            FlushOnlyLogonProperties=TRUE;
                        }
                    }

                    if (Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_BAD_PASSWORD) {

                        PUNICODE_STRING TempMachineName = NULL;

                        RemainingFlags = Buffer->Internal2.StatisticsToApply
                                            & ~(USER_LOGON_BAD_PASSWORD|USER_LOGON_BAD_PASSWORD_WKSTA);

                        //
                        // We allow the remaining flags to be 0,
                        // USER_LOGON_TYPE_KERBEROS, or USER_LOGON_TYPE_NTLM
                        //

                        if ( ( 0 == RemainingFlags ) ||
                             ( USER_LOGON_TYPE_KERBEROS == RemainingFlags ) ||
                             ( USER_LOGON_TYPE_NTLM == RemainingFlags ) ) {


                            //
                            // Increment BadPasswordCount
                            // (might lockout account)
                            //

                            //
                            // Get the wksta name if provided
                            //
                            if ((Buffer->Internal2.StatisticsToApply & USER_LOGON_BAD_PASSWORD_WKSTA) != 0) {
                                TempMachineName = &(((PUSER_INTERNAL2A_INFORMATION) &Buffer->Internal2)->Workstation);
                            }

                            AccountLockedOut =
                                SampIncrementBadPasswordCount(
                                    AccountContext,
                                    &V1aFixed,
                                    TempMachineName
                                    );

                            //
                            // If the account has been locked out,
                            //  ensure the BDCs in the domain are told.
                            //

                            if ( AccountLockedOut ) {
                                TellNetlogon = TRUE;
                                ReplicateImmediately = TRUE;
                            }
                        } else {
                            NtStatus = STATUS_INVALID_PARAMETER;
                            break;
                        }
                    }

                    if (  Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_STAT_LAST_LOGON ) {

                        OLD_TO_NEW_LARGE_INTEGER(
                            Buffer->Internal2.LastLogon,
                            V1aFixed.LastLogon );
                    }

                    if (  Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_STAT_LAST_LOGOFF ) {

                        OLD_TO_NEW_LARGE_INTEGER(
                            Buffer->Internal2.LastLogoff,
                            V1aFixed.LastLogoff );
                    }

                    if (  Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_STAT_BAD_PWD_COUNT ) {


                        SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                                       (SAMP_LOG_ACCOUNT_LOCKOUT,
                                       "UserId: 0x%x Setting BadPasswordCount to %d\n",
                                        V1aFixed.UserId, Buffer->Internal2.BadPasswordCount));

                        V1aFixed.BadPasswordCount =
                            Buffer->Internal2.BadPasswordCount;
                    }

                    if (  Buffer->Internal2.StatisticsToApply
                        & USER_LOGON_STAT_LOGON_COUNT ) {

                        V1aFixed.LogonCount = Buffer->Internal2.LogonCount;
                    }

                    if ((FlushOnlyLogonProperties)
                            && (IsDsObject(AccountContext)))
                    {
                        //
                        // If it is the DS case and we are only doing a successful
                        // logon or logoff, just flush the last logon, last logoff,
                        // logon count and bad password count properties. Note the
                        // value in the on disk structure in AccountContext will now
                        // be stale, but SetInformationUser is the last operation
                        // during a logon. Therefore it should not matter.
                        //
                        NtStatus = SampDsSuccessfulLogonSet(
                                        AccountContext,
                                        Buffer->Internal2.StatisticsToApply,
                                        LocalLastLogonTimeStampSyncInterval,
                                        &V1aFixed
                                        );
                    }
                    else if (IsDsObject(AccountContext))
                    {
                        //
                        // Set the bad password count and bad password time. Note the
                        // value in the on disk structure in AccountContext will now
                        // be stale, but SetInformationUser is the last operation
                        // during a logon. Therefore it should not matter.
                        //

                        //
                        // This path also updates the site affinity if no GC
                        // is present.
                        //
                        NtStatus = SampDsFailedLogonSet(
                                        AccountContext,
                                        Buffer->Internal2.StatisticsToApply,
                                        &V1aFixed
                                        );
                    }
                    else
                    {
                        //
                        // Registry Mode, set the entire V1aFixed Structure
                        //

                        NtStatus = SampReplaceUserV1aFixed(
                                        AccountContext,
                                        &V1aFixed
                                        );
                    }

                } else {

                    //
                    // This information is only settable by trusted
                    // clients.
                    //

                    NtStatus = STATUS_INVALID_INFO_CLASS;
                }

                break;


            } // end_switch



        } // end_if




        //
        // Go fetch any data we'll need to update the display cache
        // Do this before we dereference the context
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // Account Name if always retrieved
            // 

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_USER_ACCOUNT_NAME,
                           TRUE,    // Make copy
                           &NewAccountName
                           );
            //
            // If the account name has changed, then OldAccountName
            // is already filled in. If the account name hasn't changed
            // then the OldAccountName is the same as the new!
            //

            if (NT_SUCCESS(NtStatus) && (OldAccountName.Buffer == NULL)) {

                NtStatus = SampDuplicateUnicodeString(
                               &OldAccountName,
                               &NewAccountName);
            }

            if ( MustUpdateAccountDisplay ) {

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   TRUE, // Make copy
                                   &NewFullName
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        NtStatus = SampGetUnicodeStringAttribute(
                                       AccountContext,
                                       SAMP_USER_ADMIN_COMMENT,
                                       TRUE, // Make copy
                                       &NewAdminComment
                                       );
                    }
                }
            }
        }

        //
        //                ONLY IN DS CASE:
        //
        // If the primary group Id has been changed then explicitly modify the
        // user's membership to include the old primary group as a member. This
        // is because in the DS case the membership in the primary group is not
        // stored explicitly, but is rather implicit in the primary group-id property.
        //
        // We will do two things:
        // 1. Always remove user from the New Primary Group. Thus eliminate duplicate
        //    membership in all scenarios.
        //    Case 1: client explicity changes the PrimaryGroupId, then the
        //            user must a member of the New Primary Group
        //    Case 2: System changes PrimaryGroupId when the account morphed,
        //            then the user may or may be a member of the New Primary Group.
        //
        // 2. When KeepOldPrimaryGroupMembership == TRUE, then add the user as a
        //    member in the Old Primary Group.
        //    KeepOldPrimaryGroupMembership will be set to TRUE whenever:
        //          a) PrimaryGroupId explicitly changed    OR
        //          b) PrimaryGroupId has been changed due to Domain Controller's
        //             PrimaryGroudId enforcement and the old Primary Group ID is
        //             not the default one.
        //


        if ((NT_SUCCESS(NtStatus)) 
            && (V1aFixed.PrimaryGroupId!=OldPrimaryGroupId)
            && (IsDsObject(AccountContext)))
        {

            //
            // Assert OldPrimaryGroupId has been init'ed. 0 is not a valid Rid
            // 
            ASSERT(0 != OldPrimaryGroupId);

            //
            // STATUS_MEMBER_NOT_IN_GROUP is an expected error, that
            // is because the user is not necessary to be a member of the
            // new Primary Group in the case of the account getting morphed,
            // which triggers the PrimaryGroupId change.
            //
            IgnoreStatus = SampRemoveUserFromGroup(
                                AccountContext,
                                V1aFixed.PrimaryGroupId,
                                V1aFixed.UserId
                                );

            if (KeepOldPrimaryGroupMembership)
            {
                NtStatus =  SampAddUserToGroup(
                                    AccountContext,
                                    OldPrimaryGroupId,
                                    V1aFixed.UserId
                                    );

                if (STATUS_NO_SUCH_GROUP==NtStatus)
                {
                    //
                    // Could be because the group has been deleted using
                    // the tree delete mechanism. Reset status code to success
                    //
                    NtStatus = STATUS_SUCCESS;
                }
            }
        }



        //
        // Generate an audit if necessary. We don't account statistic
        // updates, which we also don't notify Netlogon of.
        //

        if (NT_SUCCESS(NtStatus) &&
            SampDoAccountAuditing(DomainIndex) &&
            TellNetlogon) {
                
                ULONG   UserAccountControlOld; 
                BOOLEAN AccountNameChanged;

                if (MustQueryV1aFixed || MustUpdateAccountDisplay)
                {
                    UserAccountControlOld = OldUserAccountControl;
                }
                else
                {
                    //
                    // if OldUserAccountControl is not available, 
                    // then there is not change
                    // 
                    UserAccountControlOld = V1aFixed.UserAccountControl;
                }

                AccountNameChanged = (RtlCompareUnicodeString(&OldAccountName, 
                                                              &NewAccountName, 
                                                              TRUE )  == 1) ? TRUE:FALSE;

                // audit account name change
                if (AccountNameChanged)
                {
                    SampAuditAccountNameChange(AccountContext,
                                               &NewAccountName,
                                               &OldAccountName
                                               );
                }

                // account been disabled or enabled
                if ((UserAccountControlOld & USER_ACCOUNT_DISABLED) != 
                    (V1aFixed.UserAccountControl & USER_ACCOUNT_DISABLED))
                {
                    SampAuditUserAccountControlChange(AccountContext,
                                                      V1aFixed.UserAccountControl,
                                                      UserAccountControlOld,
                                                      &NewAccountName
                                                      );
                } 
                    
                //
                // If any other control bits are different then audit them
                //

                if ((UserAccountControlOld & (~USER_ACCOUNT_DISABLED)) != 
                    (V1aFixed.UserAccountControl & (~USER_ACCOUNT_DISABLED)))
                {
                    // 
                    // Audit Generic Account Change
                    // 

                    SampAuditUserChange(AccountContext->DomainIndex,
                                        &NewAccountName,
                                        &(AccountContext->TypeBody.User.Rid),
                                        V1aFixed.UserAccountControl
                                        );
                }
        }

        if ((fSetUserPassword) && SampDoSuccessOrFailureAccountAuditing(DomainIndex, NtStatus))
        {
            SampAuditAnyEvent(
                AccountContext,
                NtStatus,
                SE_AUDITID_USER_PWD_SET, // AuditId
                SampDefinedDomains[AccountContext->DomainIndex].Sid, // Domain SID
                NULL,                        // Additional Info
                NULL,                        // Member Rid (not used)
                NULL,                        // Member Sid (not used)
                &NewAccountName,             // Account Name
                &(SampDefinedDomains[AccountContext->DomainIndex].ExternalName), // Domain
                &(AccountContext->TypeBody.User.Rid),   // Account Rid
                NULL                         // Privileges used
                );
        }


        //
        // Finally, if the following changes have occurred, replicate them 
        // urgently.
        //
        if (NT_SUCCESS(NtStatus)
        &&  IsDsObject(AccountContext)
        && (!(V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK))
        &&  (PasswordExpired
          || AccountUnlocked)  ) {

            //
            // N.B. The context's ReplicateUrgently refers to DS replication
            // The stack based ReplicateUrgently refers to NT4 BDC replication
            // which we don't want here.
            //
            AccountContext->ReplicateUrgently = TRUE;
        }

        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // De-reference the object, write out any change to current xaction.
            //


            NtStatus = SampDeReferenceContext( AccountContext, TRUE );


        } else {

            //
            // De-reference the object, ignore changes
            //

            IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

    } // end_if





    //
    // Commit the transaction and, if successful,
    // notify netlogon of the changes.  Also generate any necessary audits.
    // Note that the code path for commits is significantly different for the
    // case of the thread safe context and the non thread safe context
    //


    if (fLockAcquired)
    {
        if (NT_SUCCESS(NtStatus)) {


            if (( !TellNetlogon ) && (!IsDsObject(AccountContext))) {

                 //
                 // For logon statistics, we don't notify netlogon about changes
                 // to the database.  Which means that we don't want the
                 // domain's modified count to increase.  The commit routine
                 // will increase it automatically if this isn't a BDC, so we'll
                 // decrement it here.
                 //

                 if (SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ServerRole != DomainServerRoleBackup) {

                     SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ModifiedCount.QuadPart =
                         SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ModifiedCount.QuadPart-1;
                     SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber.QuadPart =
                         SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber.QuadPart-1;
                 }
            }


            NtStatus = SampCommitAndRetainWriteLock();


            if ( NT_SUCCESS(NtStatus) ) {



                //
                // Update the display information if the cache may be affected
                //

                if ( MustUpdateAccountDisplay && (!IsDsObject(AccountContext)) ) {

                    SAMP_ACCOUNT_DISPLAY_INFO OldAccountInfo;
                    SAMP_ACCOUNT_DISPLAY_INFO NewAccountInfo;

                    OldAccountInfo.Name = OldAccountName;
                    OldAccountInfo.Rid = ObjectRid;
                    OldAccountInfo.AccountControl = OldUserAccountControl;
                    RtlInitUnicodeString(&OldAccountInfo.Comment, NULL);
                    RtlInitUnicodeString(&OldAccountInfo.FullName, NULL);

                    NewAccountInfo.Name = NewAccountName;
                    NewAccountInfo.Rid = ObjectRid;
                    NewAccountInfo.AccountControl = V1aFixed.UserAccountControl;
                    NewAccountInfo.Comment = NewAdminComment;
                    NewAccountInfo.FullName = NewFullName;

                    IgnoreStatus = SampUpdateDisplayInformation(&OldAccountInfo,
                                                                &NewAccountInfo,
                                                                SampUserObjectType);
                    ASSERT(NT_SUCCESS(IgnoreStatus));
                }



                //
                // Notify netlogon of any user account changes
                //

                if ( ( UserInformationClass == UserNameInformation ) ||
                    ( UserInformationClass == UserAccountNameInformation ) ||
                    ( ( UserInformationClass == UserAllInformation ) &&
                    ( All->WhichFields & USER_ALL_USERNAME ) ) ) {

                    //
                    // The account was renamed; let Netlogon know.
                    //

                    SampNotifyNetlogonOfDelta(
                        SecurityDbRename,
                        SecurityDbObjectSamUser,
                        ObjectRid,
                        &OldAccountName,
                        (DWORD) ReplicateImmediately,
                        NULL            // Delta data
                        );

                } else {

                    //
                    // Something in the account was changed.  Notify netlogon about
                    // everything except logon statistics changes.
                    //

                    if ( TellNetlogon ) {

                        SAM_DELTA_DATA DeltaData;

                        DeltaData.AccountControl = V1aFixed.UserAccountControl;

                        SampNotifyNetlogonOfDelta(
                            DeltaType,
                            SecurityDbObjectSamUser,
                            ObjectRid,
                            (PUNICODE_STRING) NULL,
                            (DWORD) ReplicateImmediately,
                            &DeltaData // Delta data
                            );
                    }
                }
            }
        }

        //
        // Remove the New Account Name from the Global
        // SAM Account Name Table
        // 
        if (RemoveAccountNameFromTable)
        {
            IgnoreStatus = SampDeleteElementFromAccountNameTable(
                                (PUNICODE_STRING)NewAccountNameToRemove,
                                SampUserObjectType
                                );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

         //
         // Release the lock
         //

         IgnoreStatus = SampReleaseWriteLock( FALSE );
         ASSERT(NT_SUCCESS(IgnoreStatus));
         fLockAcquired=FALSE;
     }
     else
     {
         //
         // Commit for the thread safe context case
         //

         ASSERT(IsDsObject(AccountContext));
         if (NT_SUCCESS(NtStatus))
         {
            SampMaybeEndDsTransaction(TransactionCommit);
         }
         else
         {
            SampMaybeEndDsTransaction(TransactionAbort);
         }
     }

    ASSERT(fLockAcquired == FALSE);

    //
    // Notify any packages that a password was changed.
    //

    if (NT_SUCCESS(NtStatus)) {

        ULONG                   NotifyFlags = 0;

        if (PasswordExpired) {
            NotifyFlags |= SAMP_PWD_NOTIFY_MANUAL_EXPIRE;
        }
        if (AccountUnlocked) {
            NotifyFlags |= SAMP_PWD_NOTIFY_UNLOCKED;
        }
        if ((DeltaType == SecurityDbChangePassword)
         && !(V1aFixed.UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT)) {
            NotifyFlags |= SAMP_PWD_NOTIFY_PWD_CHANGE;
        }
        if (NotifyFlags != 0) {

            if (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK) {
                NotifyFlags |= SAMP_PWD_NOTIFY_MACHINE_ACCOUNT;
            }

            //
            // If the account name was changed, use the new account name.
            //
            if (NewAccountName.Buffer != NULL) {
                (void) SampPasswordChangeNotify(
                            NotifyFlags,
                            &NewAccountName,
                            UserRid,
                            &ClearTextPassword,
                            FALSE  // Not loopback
                            );
            } else {
                (void) SampPasswordChangeNotify(
                            NotifyFlags,
                            &AccountName,
                            UserRid,
                            &ClearTextPassword,
                            FALSE  // Not loopback
                            );
    
            }
        }
    }


    //
    // Clean up strings
    //

    SampFreeUnicodeString( &OldAccountName );
    SampFreeUnicodeString( &NewAccountName );
    SampFreeUnicodeString( &NewFullName );
    SampFreeUnicodeString( &NewAdminComment );
    SampFreeUnicodeString( &AccountName );

    if (ClearTextPassword.Buffer != NULL) {

        RtlZeroMemory(
            ClearTextPassword.Buffer,
            ClearTextPassword.Length
            );

        RtlFreeUnicodeString( &ClearTextPassword );

    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidSetInformationUser
                   );

    return(NtStatus);
}



NTSTATUS
SamrChangePasswordUser(
    IN SAMPR_HANDLE UserHandle,
    IN BOOLEAN LmPresent,
    IN PENCRYPTED_LM_OWF_PASSWORD OldLmEncryptedWithNewLm,
    IN PENCRYPTED_LM_OWF_PASSWORD NewLmEncryptedWithOldLm,
    IN BOOLEAN NtPresent,
    IN PENCRYPTED_NT_OWF_PASSWORD OldNtEncryptedWithNewNt,
    IN PENCRYPTED_NT_OWF_PASSWORD NewNtEncryptedWithOldNt,
    IN BOOLEAN NtCrossEncryptionPresent,
    IN PENCRYPTED_NT_OWF_PASSWORD NewNtEncryptedWithNewLm,
    IN BOOLEAN LmCrossEncryptionPresent,
    IN PENCRYPTED_LM_OWF_PASSWORD NewLmEncryptedWithNewNt
    )


/*++

Routine Description:

    This service sets the password to NewPassword only if OldPassword
    matches the current user password for this user and the NewPassword
    is not the same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    LMPresent - TRUE if the LM parameters (below) are valid.

    LmOldEncryptedWithLmNew - the old LM OWF encrypted with the new LM OWF

    LmNewEncryptedWithLmOld - the new LM OWF encrypted with the old LM OWF


    NtPresent - TRUE if the NT parameters (below) are valid

    NtOldEncryptedWithNtNew - the old NT OWF encrypted with the new NT OWF

    NtNewEncryptedWithNtOld - the new NT OWF encrypted with the old NT OWF


    NtCrossEncryptionPresent - TRUE if NtNewEncryptedWithLmNew is valid.

    NtNewEncryptedWithLmNew - the new NT OWF encrypted with the new LM OWF


    LmCrossEncryptionPresent - TRUE if LmNewEncryptedWithNtNew is valid.

    LmNewEncryptedWithNtNew - the new LM OWF encrypted with the new NT OWF


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

    STATUS_CROSS_ENCRYPTION_REQUIRED - No NT password is stored, so the caller
        must provide the OldNtEncryptedWithOldLm parameter.

--*/
{
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    PSAMP_OBJECT            AccountContext;
    PSAMP_DEFINED_DOMAINS   Domain;
    SAMP_OBJECT_TYPE        FoundType;
    LARGE_INTEGER           TimeNow;
    LM_OWF_PASSWORD         StoredLmOwfPassword;
    NT_OWF_PASSWORD         StoredNtOwfPassword;
    NT_OWF_PASSWORD         NewNtOwfPassword, OldNtOwfPassword;
    LM_OWF_PASSWORD         NewLmOwfPassword, OldLmOwfPassword;
    BOOLEAN                 StoredLmPasswordNonNull;
    BOOLEAN                 StoredNtPasswordPresent;
    BOOLEAN                 StoredNtPasswordNonNull;
    BOOLEAN                 AccountLockedOut;
    BOOLEAN                 V1aFixedRetrieved = FALSE;
    BOOLEAN                 V1aFixedModified = FALSE;
    BOOLEAN                 MachineAccount = FALSE;
    ULONG                   ObjectRid;
    UNICODE_STRING          AccountName;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    DOMAIN_PASSWORD_INFORMATION  DomainPasswordInfo;
    DECLARE_CLIENT_REVISION(UserHandle);

    SAMTRACE_EX("SamrChangePasswordUser");

    //
    // Update DS performance statistics
    //

    SampUpdatePerformanceCounters(
        DSSTAT_PASSWORDCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );


    RtlInitUnicodeString(
        &AccountName,
        NULL
        );

    //
    // Parameter check
    //
    if (LmPresent) {
        if (  (NewLmEncryptedWithOldLm == NULL)
           || (OldLmEncryptedWithNewLm == NULL)) {
            return STATUS_INVALID_PARAMETER;
        }
    }
    if (NtPresent) {
        if (  (OldNtEncryptedWithNewNt == NULL)
           || (NewNtEncryptedWithOldNt == NULL)) {
            return STATUS_INVALID_PARAMETER;
        }
    }
    if (NtCrossEncryptionPresent) {
        if (NewNtEncryptedWithNewLm == NULL) {
            return STATUS_INVALID_PARAMETER;
        }
    }
    if (LmCrossEncryptionPresent) {
        if (NewLmEncryptedWithNewNt == NULL) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    if (!NtPresent
     && !LmPresent   ) {
        return STATUS_INVALID_PARAMETER_MIX;
    }

    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        return(NtStatus);
    }


    //
    // Get the current time
    //

    NtStatus = NtQuerySystemTime( &TimeNow );
    if (!NT_SUCCESS(NtStatus)) {
        IgnoreStatus = SampReleaseWriteLock( FALSE );
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        return(NtStatus);
    }


    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)UserHandle;

    NtStatus = SampLookupContext(
                   AccountContext,
                   USER_CHANGE_PASSWORD,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );
    if (!NT_SUCCESS(NtStatus)) {
        IgnoreStatus = SampReleaseWriteLock( FALSE );
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        return(NtStatus);
    }

    //
    // Extract the client's IP address if any
    //
    (VOID) SampExtractClientIpAddr(NULL,
                                   UserHandle,
                                   AccountContext);


    ObjectRid = AccountContext->TypeBody.User.Rid;

    //
    // Get a pointer to the domain object
    //

    Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

    

    //
    // Get the account name for Auditing information
    //
    memset(&AccountName, 0, sizeof(UNICODE_STRING));
    NtStatus = SampGetUnicodeStringAttribute( 
                        AccountContext,
                        SAMP_USER_ACCOUNT_NAME,
                        TRUE,           // make a copy
                        &AccountName
                        );


    if (NT_SUCCESS(NtStatus))
    {
        //
        // Get the fixed attributes and check for account lockout
        //

        NtStatus = SampCheckForAccountLockout(
                            AccountContext,
                            &V1aFixed,
                            FALSE       // V1aFixed is not retrieved yet
                            );

        if (NT_SUCCESS(NtStatus))
        {
            MachineAccount = ((V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)!=0);

            V1aFixedRetrieved = TRUE;
        }

    }

    //
    // Block password Change for KRBTGT account
    //

    if ((NT_SUCCESS(NtStatus)) &&
       (DOMAIN_USER_RID_KRBTGT==AccountContext->TypeBody.User.Rid))
    {
        NtStatus = STATUS_ACCESS_DENIED;
    }

    if (NT_SUCCESS(NtStatus))
    {

        //
        // Get the effective domain policy
        //

        NtStatus = SampObtainEffectivePasswordPolicy(
                        &DomainPasswordInfo,
                        AccountContext,
                        TRUE                        
                        );
    }

    if ((NT_SUCCESS(NtStatus)) &&
       (!NtPresent)            &&
       (DomainPasswordInfo.PasswordProperties & DOMAIN_NO_LM_OWF_CHANGE ))
    {
        NtStatus = STATUS_PASSWORD_RESTRICTION;
    }

    if (NT_SUCCESS(NtStatus)) {


        //
        // Read the old OWF passwords from disk
        //

        NtStatus = SampRetrieveUserPasswords(
                        AccountContext,
                        &StoredLmOwfPassword,
                        &StoredLmPasswordNonNull,
                        &StoredNtOwfPassword,
                        &StoredNtPasswordPresent,
                        &StoredNtPasswordNonNull
                        );

        //
        // Check the password can be changed at this time
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // Only do the check if one of the passwords is non-null.
            // A Null password can always be changed.
            //

            if (StoredNtPasswordNonNull || StoredLmPasswordNonNull) {




                if (NT_SUCCESS(NtStatus) && (!MachineAccount)) {
                    //
                    // If the min password age is non zero, check it here
                    //
                    if (DomainPasswordInfo.MinPasswordAge.QuadPart != SampHasNeverTime.QuadPart) {

                        LARGE_INTEGER PasswordCanChange = SampAddDeltaTime(
                                         V1aFixed.PasswordLastSet,
                                         DomainPasswordInfo.MinPasswordAge);

                        if (TimeNow.QuadPart < PasswordCanChange.QuadPart) {
                            NtStatus = STATUS_ACCOUNT_RESTRICTION;
                        }
                    }

                }
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // Check to make sure the old passwords passed in are sufficient
            // to validate what is stored.  There are reasons why an LM password
            // would not be stored: SampNoLMHash, too complex, etc. 
            //
            NtStatus = SampValidatePresentAndStoredCombination(NtPresent,
                                                               LmPresent,
                                                               StoredNtPasswordPresent,
                                                               StoredNtPasswordNonNull,
                                                               StoredLmPasswordNonNull);

        }

        if (NT_SUCCESS(NtStatus)) {

            if (LmPresent) {

                //
                // Decrypt the doubly-encrypted LM passwords sent to us
                //

                NtStatus = RtlDecryptLmOwfPwdWithLmOwfPwd(
                                NewLmEncryptedWithOldLm,
                                &StoredLmOwfPassword,
                                &NewLmOwfPassword
                           );

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = RtlDecryptLmOwfPwdWithLmOwfPwd(
                                    OldLmEncryptedWithNewLm,
                                    &NewLmOwfPassword,
                                    &OldLmOwfPassword
                               );
                }
            }
        }

        //
        // Decrypt the doubly-encrypted NT passwords sent to us
        //

        if (NT_SUCCESS(NtStatus)) {

            if (NtPresent) {

                NtStatus = RtlDecryptNtOwfPwdWithNtOwfPwd(
                                NewNtEncryptedWithOldNt,
                                &StoredNtOwfPassword,
                                &NewNtOwfPassword
                           );

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = RtlDecryptNtOwfPwdWithNtOwfPwd(
                                    OldNtEncryptedWithNewNt,
                                    &NewNtOwfPassword,
                                    &OldNtOwfPassword
                               );
                }
            }
        }

        //
        // Authenticate the password change operation based on what
        // we have stored and what was passed.
        //

        if (NT_SUCCESS(NtStatus)) {

            if (!NtPresent) {

                //
                // Called from a down-level machine (no NT password passed)
                //
                ASSERT(LmPresent);

                //
                // LM data only passed. Use LM data for authentication
                //

                if (!RtlEqualLmOwfPassword(&OldLmOwfPassword, &StoredLmOwfPassword)) {

                    //
                    // Old LM passwords didn't match
                    //

                    NtStatus = STATUS_WRONG_PASSWORD;

                } else {

                    //
                    // The operation was authenticated based on the LM data
                    //
                    // We have NtPresent = FALSE, LM Present = TRUE
                    //
                    // NewLmOwfPassword will be stored.
                    // No NT password will be stored.
                    //
                }

            } else {

                //
                // NtPresent = TRUE, we were passed an NT password
                // The client is an NT-level machine (or higher !)
                //

                if (!LmPresent) {

                    //
                    // No LM version of old password - the old password is complex
                    //
                    // Use NT data for authentication
                    //

                    if (!RtlEqualNtOwfPassword(&OldNtOwfPassword, &StoredNtOwfPassword)) {

                        //
                        // Old NT passwords didn't match
                        //

                        NtStatus = STATUS_WRONG_PASSWORD;

                    } else {

                        //
                        // Authentication was successful.
                        // We need cross encrypted version of the new LM password
                        //

                        if (!LmCrossEncryptionPresent) {

                            NtStatus = STATUS_LM_CROSS_ENCRYPTION_REQUIRED;

                        } else {

                            //
                            // Calculate the new LM Owf Password
                            //

                            ASSERT(NT_OWF_PASSWORD_LENGTH == LM_OWF_PASSWORD_LENGTH);

                            NtStatus = RtlDecryptLmOwfPwdWithLmOwfPwd(
                                            NewLmEncryptedWithNewNt,
                                            (PLM_OWF_PASSWORD)&NewNtOwfPassword,
                                            &NewLmOwfPassword
                                       );
                        }

                        if (NT_SUCCESS(NtStatus)) {

                            LmPresent = TRUE;

                            //
                            // The operation was authenticated based on NT data
                            // The new LM Password was requested and
                            // successfully obtained using cross-encryption.
                            //
                            // We have NtPresent = TRUE, LM Present = TRUE
                            //
                            // NewLmOwfPassword will be stored.
                            // NewNtOwfPassword will be stored.
                            //
                        }

                    }

                } else {

                    //
                    // NtPresent == TRUE, LmPresent == TRUE
                    //
                    // The old password passed is simple (both LM and NT versions)
                    //
                    // Authenticate using both LM and NT data
                    //

                    //
                    // N.B. Only check the LM OWF if non-null. We have the NT
                    // OWF so we will perform the authentication in the else
                    // clause.
                    //
                    if ( StoredLmPasswordNonNull
                      && !RtlEqualLmOwfPassword(&OldLmOwfPassword, &StoredLmOwfPassword)) {

                        //
                        // Old LM passwords didn't match
                        //

                        NtStatus = STATUS_WRONG_PASSWORD;

                    } else {

                        //
                        // Old LM passwords matched, in the non NULL case
                        //
                        // Do NT authentication if we have a stored NT password
                        // or the stored LM password is NULL.
                        //
                        // (NO stored NT and Stored LM = NULL -> stored pwd=NULL
                        // We must compare passed old NT Owf against
                        // NULL NT Owf to ensure user didn't specify complex
                        // old NT password instead of NULL password)
                        //
                        // (StoredNtOwfPassword is already initialized to
                        // the NullNtOwf if no NT password stored)
                        //

                        if (StoredNtPasswordPresent || !StoredLmPasswordNonNull) {

                            if (!RtlEqualNtOwfPassword(&OldNtOwfPassword,
                                                       &StoredNtOwfPassword)) {
                                //
                                // Old NT passwords didn't match
                                //

                                NtStatus = STATUS_WRONG_PASSWORD;

                            } else {

                                //
                                // The operation was authenticated based on
                                // both LM and NT data.
                                //
                                // We have NtPresent = TRUE, LM Present = TRUE
                                //
                                // NewLmOwfPassword will be stored.
                                // NewNtOwfPassword will be stored.
                                //

                            }

                        } else {

                            //
                            // The LM authentication was sufficient since
                            // we have no stored NT password
                            //
                            // Go get the new NT password using cross encryption
                            //

                            if (!NtCrossEncryptionPresent) {

                                NtStatus = STATUS_NT_CROSS_ENCRYPTION_REQUIRED;

                            } else {

                                //
                                // Calculate the new NT Owf Password
                                //

                                ASSERT(NT_OWF_PASSWORD_LENGTH == LM_OWF_PASSWORD_LENGTH);

                                NtStatus = RtlDecryptNtOwfPwdWithNtOwfPwd(
                                                NewNtEncryptedWithNewLm,
                                                (PNT_OWF_PASSWORD)&NewLmOwfPassword,
                                                &NewNtOwfPassword
                                           );
                            }

                            if (NT_SUCCESS(NtStatus)) {

                                //
                                // The operation was authenticated based on LM data
                                // The new NT Password was requested and
                                // successfully obtained using cross-encryption.
                                //
                                // We have NtPresent = TRUE, LM Present = TRUE
                                //
                                // NewLmOwfPassword will be stored.
                                // NewNtOwfPassword will be stored.
                                //
                            }
                        }
                    }
                }
            }
        }


        //
        // We now have a NewLmOwfPassword.
        // If NtPresent = TRUE, we also have a NewNtOwfPassword
        //

        //
        // Write the new passwords to disk
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // We should always have a LM password to store.
            //

            ASSERT(LmPresent);

            NtStatus = SampStoreUserPasswords(
                           AccountContext,
                           &NewLmOwfPassword,
                           TRUE,
                           &NewNtOwfPassword,
                           NtPresent,
                           !MachineAccount,
                           PasswordChange,
                           &DomainPasswordInfo,
                           NULL // No clear text password available
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // We know the password is not expired.
                //

                NtStatus = SampStorePasswordExpired(
                               AccountContext,
                               FALSE
                               );
            }
        }



        //
        // if we have a bad password, then increment the bad password
        // count and check to see if the account should be locked.
        //

        if (NtStatus == STATUS_WRONG_PASSWORD) {

            //
            // Get the V1aFixed so we can update the bad password count
            //


            TmpStatus = STATUS_SUCCESS;
            if (!V1aFixedRetrieved) {
                TmpStatus = SampRetrieveUserV1aFixed(
                                AccountContext,
                                &V1aFixed
                                );
            }

            if (!NT_SUCCESS(TmpStatus)) {

                //
                // If we can't update the V1aFixed, then return this
                // error so that the user doesn't find out the password
                // was not correct.
                //

                NtStatus = TmpStatus;

            } else {


                //
                // Increment BadPasswordCount (might lockout account)
                //


                AccountLockedOut = SampIncrementBadPasswordCount(
                                       AccountContext,
                                       &V1aFixed,
                                       NULL
                                       );

                V1aFixedModified = TRUE;


            }
        }

        if (V1aFixedModified) {
            TmpStatus = SampReplaceUserV1aFixed(
                            AccountContext,
                            &V1aFixed
                            );
            if (!NT_SUCCESS(TmpStatus)) {
                NtStatus = TmpStatus;
            }
        }

        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus) || (NtStatus == STATUS_WRONG_PASSWORD)) {



            //
            // De-reference the object, write out any change to current xaction.
            //

            TmpStatus = SampDeReferenceContext( AccountContext, TRUE );

            //
            // retain previous error/success value unless we have
            // an over-riding error from our dereference.
            //

            if (!NT_SUCCESS(TmpStatus)) {
                NtStatus = TmpStatus;
            }

        } else {

            //
            // De-reference the object, ignore changes
            //

            IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

    }
    else
    {
        //
        // De-reference the object, ignore changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }


    //
    // Commit changes to disk.
    //

    if ( NT_SUCCESS(NtStatus) || NtStatus == STATUS_WRONG_PASSWORD) {

        TmpStatus = SampCommitAndRetainWriteLock();

        //
        // retain previous error/success value unless we have
        // an over-riding error from our dereference.
        //

        if (!NT_SUCCESS(TmpStatus)) {
            NtStatus = TmpStatus;
        }

        if ( NT_SUCCESS(TmpStatus) ) {

            SampNotifyNetlogonOfDelta(
                SecurityDbChangePassword,
                SecurityDbObjectSamUser,
                ObjectRid,
                (PUNICODE_STRING) NULL,
                (DWORD) FALSE,      // Don't Replicate immediately
                NULL                // Delta data
                );
        }
    }

    if (SampDoSuccessOrFailureAccountAuditing(AccountContext->DomainIndex, NtStatus)) {

        SampAuditAnyEvent(
                AccountContext,
                NtStatus,
                SE_AUDITID_USER_PWD_CHANGED, // AuditId
                Domain->Sid,                 // Domain SID
                NULL,                        // Additional Info
                NULL,                        // Member Rid (not used)
                NULL,                        // Member Sid (not used)
                &AccountName,                // Account Name
                &Domain->ExternalName,       // Domain
                &ObjectRid,                    // Account Rid
                NULL                         // Privileges used
                );

    }


    //
    // Release the write lock
    //

    TmpStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(TmpStatus));

    if (NT_SUCCESS(NtStatus)) {

        ULONG NotifyFlags = SAMP_PWD_NOTIFY_PWD_CHANGE;
        if (MachineAccount) {
            NotifyFlags |= SAMP_PWD_NOTIFY_MACHINE_ACCOUNT;                
        }

        (void) SampPasswordChangeNotify(
                    NotifyFlags,
                    &AccountName,
                    ObjectRid,
                    NULL,
                    FALSE           // not loopback
                    );

    }

    SampFreeUnicodeString( &AccountName );
    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);
}





NTSTATUS
SampDecryptPasswordWithLmOwfPassword(
    IN PSAMPR_ENCRYPTED_USER_PASSWORD EncryptedPassword,
    IN PLM_OWF_PASSWORD StoredPassword,
    IN BOOLEAN UnicodePasswords,
    OUT PUNICODE_STRING ClearNtPassword
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    return( SampDecryptPasswordWithKey(
                EncryptedPassword,
                (PUCHAR) StoredPassword,
                LM_OWF_PASSWORD_LENGTH,
                UnicodePasswords,
                ClearNtPassword
                ) );
}


NTSTATUS
SampDecryptPasswordWithNtOwfPassword(
    IN PSAMPR_ENCRYPTED_USER_PASSWORD EncryptedPassword,
    IN PNT_OWF_PASSWORD StoredPassword,
    IN BOOLEAN UnicodePasswords,
    OUT PUNICODE_STRING ClearNtPassword
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    //
    // The code is the same as for LM owf password.
    //

    return(SampDecryptPasswordWithKey(
                EncryptedPassword,
                (PUCHAR) StoredPassword,
                NT_OWF_PASSWORD_LENGTH,
                UnicodePasswords,
                ClearNtPassword
                ) );
}

NTSTATUS
SampOpenUserInServer(
    PUNICODE_STRING UserName,
    BOOLEAN Unicode,
    IN BOOLEAN TrustedClient,
    SAMPR_HANDLE * UserHandle
    )
/*++

Routine Description:

    Opens a user in the account domain.

Arguments:

    UserName - an OEM or Unicode string of the user's name

    Unicode - Indicates whether UserName is OEM or Unicode

    UserHandle - Receives handle to the user, opened with SamOpenUser for
        USER_CHANGE_PASSWORD access


Return Value:

--*/

{
    NTSTATUS NtStatus;
    SAM_HANDLE ServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAMPR_ULONG_ARRAY UserId;
    SAMPR_ULONG_ARRAY SidUse;
    UNICODE_STRING UnicodeUserName;
    ULONG DomainIndex;

    SAMTRACE("SampOpenUserInServer");


    UserId.Element = NULL;
    SidUse.Element = NULL;

    //
    // Get the unicode user name.
    //

    if (Unicode) {
        UnicodeUserName = *UserName;
    } else {
        NtStatus = RtlOemStringToUnicodeString(
                        &UnicodeUserName,
                        (POEM_STRING) UserName,
                        TRUE                    // allocate destination.
                        );

        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }



    //
    // Connect as a trusted client. This will bypass all the checks
    // related to the SAM server and Domain Objects. After all the
    // user is just interested in changing the Password and he does
    // not need access to the domain or SAM server objects in order
    // to change his own password. Detect the loopback case and use
    // the Loopback connect paradigm.
    //


    if ((SampUseDsData) && (SampIsWriteLockHeldByDs()))
    {
        //
        // Loopback case
        //

        NtStatus = SamILoopbackConnect(
                        NULL,
                        &ServerHandle,
                        SAM_SERVER_LOOKUP_DOMAIN,
                        TRUE
                        );
    }
    else
    {
        NtStatus = SamIConnect(
                    NULL,
                    &ServerHandle,
                    SAM_SERVER_LOOKUP_DOMAIN,
                    TRUE
                    );
    }

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = SamrOpenDomain(
                ServerHandle,
                DOMAIN_LOOKUP |
                    DOMAIN_LIST_ACCOUNTS |
                    DOMAIN_READ_PASSWORD_PARAMETERS,
                SampDefinedDomains[1].Sid,
                &DomainHandle
                );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // If cleartext password change is not allowed, we return the error code
    // indicating that the rpc client should try using the old interfaces.
    //

    DomainIndex = ((PSAMP_OBJECT) DomainHandle)->DomainIndex;
    if (SampDefinedDomains[DomainIndex].UnmodifiedFixed.PasswordProperties &
        DOMAIN_PASSWORD_NO_CLEAR_CHANGE) {

       NtStatus = RPC_NT_UNKNOWN_IF;
       goto Cleanup;
    }

    NtStatus = SamrLookupNamesInDomain(
                DomainHandle,
                1,
                (PRPC_UNICODE_STRING) &UnicodeUserName,
                &UserId,
                &SidUse
                );

    if (!NT_SUCCESS(NtStatus)) {
        if (NtStatus == STATUS_NONE_MAPPED) {
            NtStatus = STATUS_NO_SUCH_USER;
        }
        goto Cleanup;
    }

    //
    // We need to access ck, whether the user has change password rights.
    // Therefore reset the trusted client bit in the handle and do the Open
    // user. This will verify wether the user does have change password rights
    //

    ((PSAMP_OBJECT)(DomainHandle))->TrustedClient = TrustedClient;

    //
    // Make it such that the new context is marked "opened by system"
    //

    ((PSAMP_OBJECT)(DomainHandle))->OpenedBySystem = TRUE;

    //
    // Now open the user object, performing the access ck.
    //

    NtStatus = SamrOpenUser(
                DomainHandle,
                USER_CHANGE_PASSWORD,
                UserId.Element[0],
                UserHandle
                );


    //
    // Reset the Trusted Client on the domain object. This is needed so, that
    // we will correctly decrement the SampActiveContextCount Variable when
    // we perform a close handle
    //

    ((PSAMP_OBJECT)(DomainHandle))->TrustedClient = TRUE;

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Also reset the buffer writes bit on the user handle. This is set to 
    // true in the loopback case, but loopback does not posess this handle,
    // so does not force a flush on this handle. This causes the data written
    // to be not written to disk.
    //
 
    ((PSAMP_OBJECT)((*UserHandle)))->BufferWrites = FALSE;



Cleanup:
    if (DomainHandle != NULL) {
        SamrCloseHandle(&DomainHandle);
    }
    if (ServerHandle != NULL) {
        SamrCloseHandle(&ServerHandle);
    }
    if (UserId.Element != NULL) {
        MIDL_user_free(UserId.Element);
    }
    if (SidUse.Element != NULL) {
        MIDL_user_free(SidUse.Element);
    }
    if (!Unicode && UnicodeUserName.Buffer != NULL) {
        RtlFreeUnicodeString( &UnicodeUserName );
    }

    return(NtStatus);
}

NTSTATUS
SampObtainEffectivePasswordPolicy(
   OUT PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo,
   IN PSAMP_OBJECT AccountContext,
   IN BOOLEAN      WriteLockAcquired
   )
{
    
    PSAMP_DEFINED_DOMAINS   Domain;

    if (!WriteLockAcquired)
    {
        SampAcquireSamLockExclusive();
    }
    
    Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

    DomainPasswordInfo->MinPasswordLength = Domain->CurrentFixed.MinPasswordLength;
    DomainPasswordInfo->PasswordHistoryLength = Domain->CurrentFixed.PasswordHistoryLength;
    DomainPasswordInfo->PasswordProperties = Domain->CurrentFixed.PasswordProperties;
    DomainPasswordInfo->MaxPasswordAge = Domain->CurrentFixed.MaxPasswordAge;
    DomainPasswordInfo->MinPasswordAge = Domain->CurrentFixed.MinPasswordAge;


    if (!WriteLockAcquired)
    {
        SampReleaseSamLockExclusive();
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
SampDecryptForPasswordChange(
    IN PSAMP_OBJECT AccountContext,
    IN BOOLEAN Unicode,
    IN BOOLEAN NtPresent,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldNt,
    IN PENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt,
    IN BOOLEAN LmPresent,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    IN BOOLEAN NtKeyUsed,
    IN PENCRYPTED_LM_OWF_PASSWORD OldLmOwfEncryptedWithNewLmOrNt,
    OUT PUNICODE_STRING  NewClearPassword,
    OUT NT_OWF_PASSWORD *OldNtOwfPassword,
    OUT BOOLEAN         *OldNtPresent,
    OUT LM_OWF_PASSWORD *OldLmOwfPassword,
    OUT BOOLEAN         *OldLmPresent
    )

/*++

  Routine Description

  This routine does the decryption for a password change. 


  Parameters

  Unicode                       -- Specifies strings passed in are unicode or OEM
                                   strings. Applies when the encrypted passwords
                                   are used.

  NtPresent                       -- Indicates that the NT OWF is present
        
  LmPresent                       -- Indicates that the LM OWF is present
        
  NewEncryptedWithOldNt,          -- Encrypted OWF passwords
  OldNtOwfEncryptedWithNewNt,
  NewEncryptedWithOldLm,
  OldLmOwfEncryptedWithNewLmOrNt


  NewClearPassword                -- The decrypted clear password

  OldNtOwfPassword                -- Old passwords in OWF form
  OldLmOwfPassword 

  OldNtPresent                    -- tells if the old LM or  old NT password in OWF
  OldLmPresent                       form could be obtained.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS, TmpStatus = STATUS_SUCCESS;
    NT_OWF_PASSWORD StoredNtOwfPassword, NewNtOwfPassword;
    LM_OWF_PASSWORD StoredLmOwfPassword, NewLmOwfPassword;
    BOOLEAN         StoredNtPasswordPresent;
    BOOLEAN         StoredLmPasswordNonNull;
    BOOLEAN         StoredNtPasswordNonNull;
    BOOLEAN         LmPasswordPresent;
    BOOLEAN         AccountLockedOut;
    SAMP_V1_0A_FIXED_LENGTH_USER    V1aFixed;

    //
    // Should ONLY be called by Non-Loopback Client
    // 
    ASSERT(!AccountContext->LoopbackClient);


    *OldNtPresent = FALSE;
    *OldLmPresent = FALSE;
       
    //
    // Read the old OWF passwords from disk
    //

    NtStatus = SampRetrieveUserPasswords(
                    AccountContext,
                    &StoredLmOwfPassword,
                    &StoredLmPasswordNonNull,
                    &StoredNtOwfPassword,
                    &StoredNtPasswordPresent,
                    &StoredNtPasswordNonNull
                    );

    //
    // If we have old NtOwf passwords, use them
    // Decrypt the doubly-encrypted NT passwords sent to us
    //

    if (NT_SUCCESS(NtStatus)) {

        if (StoredNtPasswordPresent && NtPresent) {

            NtStatus = SampDecryptPasswordWithNtOwfPassword(
                            NewEncryptedWithOldNt,
                            &StoredNtOwfPassword,
                            Unicode,
                            NewClearPassword
                       );

        } else if (LmPresent) {

            //
            // There was no stored NT password and NT passed, so our only
            // hope now is that the stored LM password works.
            //

            //
            // Decrypt the new password encrypted with the old LM password
            //

            NtStatus = SampDecryptPasswordWithLmOwfPassword(
                            NewEncryptedWithOldLm,
                            &StoredLmOwfPassword,
                            Unicode,
                            NewClearPassword
                       );


        } else {

            NtStatus = STATUS_NT_CROSS_ENCRYPTION_REQUIRED;

        }
    }


    //
    // We now have the cleartext new password.
    // Compute the new LmOwf and NtOwf password
    //



    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampCalculateLmAndNtOwfPasswords(
                        NewClearPassword,
                        &LmPasswordPresent,
                        &NewLmOwfPassword,
                        &NewNtOwfPassword
                   );

    }

    //
    // If we have both NT passwords, compute the old NT password,
    // otherwise compute the old LM password
    //

    if (NT_SUCCESS(NtStatus)) {

        if (StoredNtPasswordPresent && NtPresent) {
            NtStatus = RtlDecryptNtOwfPwdWithNtOwfPwd(
                            OldNtOwfEncryptedWithNewNt,
                            &NewNtOwfPassword,
                            OldNtOwfPassword
                       );

            *OldNtPresent = TRUE;
        }

        if (LmPresent) {


            //
            // If the NT key was used to encrypt this, use the NT key
            // to decrypt it.
            //


            if (NtKeyUsed) {

                ASSERT(LM_OWF_PASSWORD_LENGTH == NT_OWF_PASSWORD_LENGTH);

                NtStatus = RtlDecryptLmOwfPwdWithLmOwfPwd(
                                OldLmOwfEncryptedWithNewLmOrNt,
                                (PLM_OWF_PASSWORD) &NewNtOwfPassword,
                                OldLmOwfPassword
                           );

                *OldLmPresent = TRUE;


            } else if (LmPasswordPresent) {

                NtStatus = RtlDecryptLmOwfPwdWithLmOwfPwd(
                                OldLmOwfEncryptedWithNewLmOrNt,
                                &NewLmOwfPassword,
                                OldLmOwfPassword
                           );
                *OldLmPresent = TRUE;


            } else {
                NtStatus = STATUS_NT_CROSS_ENCRYPTION_REQUIRED;
            }

        }

    }

    //
    // if we have a bad password, then increment the bad password
    // count and check to see if the account should be locked.
    //

    if (STATUS_WRONG_PASSWORD == NtStatus)
    {
        //
        // Get the V1aFixed so we can update the bad password count
        //

        TmpStatus = SampRetrieveUserV1aFixed(
                            AccountContext,
                            &V1aFixed
                            );

        if (!NT_SUCCESS(TmpStatus))
        {
            //
            // If we can't update the V1aFixed, then return this
            // error so that the user doesn't find out the password
            // was not correct.
            //

            NtStatus = TmpStatus;
        }
        else
        {

            //
            // Increment BadPasswordCount (might lockout account)
            //

            AccountLockedOut = SampIncrementBadPasswordCount(
                                    AccountContext,
                                    &V1aFixed,
                                    NULL
                                    );

            TmpStatus = SampReplaceUserV1aFixed(
                                    AccountContext,
                                    &V1aFixed
                                    );

            if (!NT_SUCCESS(TmpStatus))
                NtStatus = TmpStatus;
        }
    }


    return(NtStatus);
        
}

   
NTSTATUS
SampValidateAndChangePassword(
    IN PSAMP_OBJECT AccountContext,
    IN BOOLEAN      WriteLockAcquired,
    IN BOOLEAN      ValidatePassword,
    IN NT_OWF_PASSWORD * OldNtOwfPassword,
    IN BOOLEAN         NtPresent,
    IN LM_OWF_PASSWORD * OldLmOwfPassword,
    IN BOOLEAN         LmPresent,
    IN PUNICODE_STRING  NewClearPassword,
    OUT PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo,
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo
    )
/*++

  Routine Description

  This routine authenticates a password change, enforces policy and 
  stores the new password, updating history.

  Parameters

        User Handle -- Handle to the user object
        
        WriteLockAcquired -- Indicates that the write lock has already been
                             acquired

        ValidatePassword  -- Indicates that actualvalidation of the password
                             is required


        OldNtOwfPassword  -- OWF forms of the old password
        OldLmOwfPassword 

        NtPresent         -- Indicates which of the 2 OWF forms of the old
        LmPresent            password is present. Nt is used if both are
                             present.

        DomainPasswordInfo -- Indicates the effective password policy
                              that was applied.

--*/

{
    LM_OWF_PASSWORD         StoredLmOwfPassword;
    NT_OWF_PASSWORD         StoredNtOwfPassword;
    NT_OWF_PASSWORD         NewNtOwfPassword;
    LM_OWF_PASSWORD         NewLmOwfPassword;
    BOOLEAN                 LmPasswordPresent;
    BOOLEAN                 StoredLmPasswordNonNull;
    BOOLEAN                 StoredNtPasswordPresent;
    BOOLEAN                 StoredNtPasswordNonNull;
    BOOLEAN                 AccountLockedOut;
    BOOLEAN                 V1aFixedRetrieved = FALSE;
    BOOLEAN                 V1aFixedModified = FALSE;
    ULONG                   ObjectRid;
    UNICODE_STRING          AccountName;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    BOOLEAN                 LoopbackClient = FALSE;
    LARGE_INTEGER           TimeNow;
    NTSTATUS                NtStatus = STATUS_SUCCESS,
                            IgnoreStatus = STATUS_SUCCESS,
                            TmpStatus = STATUS_SUCCESS;
    UNICODE_STRING          NewPassword;
    BOOLEAN                 MachineAccount = FALSE;

    
    //
    // Initialize variables
    //

    NtStatus = STATUS_SUCCESS;
    AccountName.Buffer = NULL;
    RtlZeroMemory(&AccountName, sizeof(UNICODE_STRING));

    //
    // Get the current time
    //

    NtStatus = NtQuerySystemTime( &TimeNow );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Block password Change for KRBTGT account;except for trusted
    // clients
    //

    if ((DOMAIN_USER_RID_KRBTGT==AccountContext->TypeBody.User.Rid) &&
        (!AccountContext->TrustedClient))
    {
        NtStatus = STATUS_PASSWORD_RESTRICTION;
        return(NtStatus);
    }
    
    //
    //  Get some state information.
    //

    LoopbackClient = AccountContext->LoopbackClient;

    ObjectRid = AccountContext->TypeBody.User.Rid;

    //
    // Get the effective domain policy
    //

    NtStatus = SampObtainEffectivePasswordPolicy(
                    DomainPasswordInfo,
                    AccountContext,
                    WriteLockAcquired
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        return(NtStatus);
    }


    //
    // Enforce Domain Password No Clear Change
    //

    if (DomainPasswordInfo->PasswordProperties & DOMAIN_PASSWORD_NO_CLEAR_CHANGE)
    {
        NtStatus = STATUS_PASSWORD_RESTRICTION;
        return(NtStatus);
    }

    //
    // Get Account Name
    // 

    NtStatus = SampGetUnicodeStringAttribute(
                    AccountContext, 
                    SAMP_USER_ACCOUNT_NAME,
                    TRUE,           // make a copy
                    &AccountName
                    );

    if (NT_SUCCESS(NtStatus))
    {
        //
        // Get fixed attributes and check for account lockout
        // 

        NtStatus = SampCheckForAccountLockout(
                        AccountContext,
                        &V1aFixed,
                        FALSE   // V1aFixed is not retrieved yet
                        );

        if (NT_SUCCESS(NtStatus))
        {

            MachineAccount = ((V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)!=0);

            V1aFixedRetrieved = TRUE;
            
        }

    }

    if (NT_SUCCESS(NtStatus)) {
       
        //
        // Read the old OWF passwords from disk
        //

        NtStatus = SampRetrieveUserPasswords(
                        AccountContext,
                        &StoredLmOwfPassword,
                        &StoredLmPasswordNonNull,
                        &StoredNtOwfPassword,
                        &StoredNtPasswordPresent,
                        &StoredNtPasswordNonNull
                        );
        
        //
        // Check the password can be changed at this time
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // Only do the check if one of the passwords is non-null.
            // A Null password can always be changed.
            //

            if (StoredNtPasswordNonNull || StoredLmPasswordNonNull) {



                if (NT_SUCCESS(NtStatus)) {

                    //
                    // If the min password age is non zero, check it here
                    //

                    if ((DomainPasswordInfo->MinPasswordAge.QuadPart != SampHasNeverTime.QuadPart) &&
                        (!MachineAccount))
                    {

                        LARGE_INTEGER PasswordCanChange = SampAddDeltaTime(
                                         V1aFixed.PasswordLastSet,
                                         DomainPasswordInfo->MinPasswordAge);


                        if (TimeNow.QuadPart < PasswordCanChange.QuadPart) {
                            NtStatus = STATUS_ACCOUNT_RESTRICTION;
                        }
                    }
                }
            }
        }

        //
        // Verify the passed in passwords with respect to what is stored
        // locally.
        //
        if (NT_SUCCESS(NtStatus) && (ValidatePassword)) {

            NtStatus = SampValidatePresentAndStoredCombination(NtPresent,
                                                               LmPresent,
                                                               StoredNtPasswordPresent,
                                                               StoredNtPasswordNonNull,
                                                               StoredLmPasswordNonNull);
        }

        //
        // We now have the cleartext new password.
        // Compute the new LmOwf and NtOwf password
        //

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampCalculateLmAndNtOwfPasswords(
                            NewClearPassword,
                            &LmPasswordPresent,
                            &NewLmOwfPassword,
                            &NewNtOwfPassword
                       );

        }

        //
        // Authenticate the password change operation based on what
        // we have stored and what was passed.  We authenticate whatever
        // passwords were sent .
        //

        if ((NT_SUCCESS(NtStatus)) && (ValidatePassword)) {

            if (NtPresent && StoredNtPasswordPresent) {

                //
                // NtPresent = TRUE, we were passed an NT password
                //

                if (!RtlEqualNtOwfPassword(OldNtOwfPassword, &StoredNtOwfPassword)) {

                    //
                    // Old NT passwords didn't match
                    //

                    NtStatus = STATUS_WRONG_PASSWORD;

                }
            } else if (LmPresent) {

                //
                // LM data passed. Use LM data for authentication
                //

                if (!RtlEqualLmOwfPassword(OldLmOwfPassword, &StoredLmOwfPassword)) {

                    //
                    // Old LM passwords didn't match
                    //

                    NtStatus = STATUS_WRONG_PASSWORD;

                }

            } else {
                NtStatus = STATUS_NT_CROSS_ENCRYPTION_REQUIRED;
            }

        }

        //
        // Now we should check password restrictions.
        // except for machine account and Krbtgt account
        //

        if ((NT_SUCCESS(NtStatus)) && 
            (!MachineAccount) && 
            (DOMAIN_USER_RID_KRBTGT != AccountContext->TypeBody.User.Rid)) {

            NtStatus = SampCheckPasswordRestrictions(
                            (SAMPR_HANDLE) AccountContext,
                            DomainPasswordInfo,
                            NewClearPassword,
                            PasswordChangeFailureInfo
                            );

        }

        //
        // Now check our password filter if the account is not a workstation
        // or server trust account or this is not a service account like krbtgt.
        //

        if ((NT_SUCCESS(NtStatus )) &&
            ( !MachineAccount ) &&
            (DOMAIN_USER_RID_KRBTGT != AccountContext->TypeBody.User.Rid)){


            UNICODE_STRING    FullName;


            NtStatus = SampGetUnicodeStringAttribute(
                            AccountContext,
                            SAMP_USER_FULL_NAME,
                            FALSE,    // Make copy
                            &FullName
                            );

            if (NT_SUCCESS(NtStatus)) {

                //
                // now see what the filter dll thinks of this password
                //

                NtStatus = SampPasswordChangeFilter(
                                &AccountName,
                                &FullName,
                                NewClearPassword,
                                PasswordChangeFailureInfo,
                                FALSE                   // change operation
                                );

            }
        }

        //
        // For Machine accounts if the special Domain flag for refuse password change is set,
        // then disallow any account creation except the default
        //

        if (NT_SUCCESS(NtStatus) &&
            (MachineAccount) &&
            ((V1aFixed.UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT)==0)
            )
        {
            NtStatus = SampEnforceDefaultMachinePassword(
                            AccountContext,
                            NewClearPassword,
                            DomainPasswordInfo
                            );

            //
            // If this failed with password restriction it means that refuse password change
            // is set for machine acounts
            //

            if ((STATUS_PASSWORD_RESTRICTION==NtStatus) 
                    && (ARGUMENT_PRESENT(PasswordChangeFailureInfo)))
            {
                PasswordChangeFailureInfo->ExtendedFailureReason = 
                        SAM_PWD_CHANGE_MACHINE_PASSWORD_NOT_DEFAULT;
            }
        }




        //
        // We now have a NewLmOwfPassword and a NewNtOwfPassword.
        //

        //
        // Write the new passwords to disk
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // We should always have an LM and an NT password to store.
            //


            NtStatus = SampStoreUserPasswords(
                           AccountContext,
                           &NewLmOwfPassword,
                           LmPasswordPresent,
                           &NewNtOwfPassword,
                           TRUE,
                           !MachineAccount,
                           PasswordChange,
                           DomainPasswordInfo,
                           NewClearPassword
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // We know the password is not expired.
                //

                NtStatus = SampStorePasswordExpired(
                               AccountContext,
                               FALSE
                               );
            }
            else if ((STATUS_PASSWORD_RESTRICTION==NtStatus)
                  && (ARGUMENT_PRESENT(PasswordChangeFailureInfo)))
            {
                PasswordChangeFailureInfo->ExtendedFailureReason
                        = SAM_PWD_CHANGE_PWD_IN_HISTORY;
            }

        }



        //
        // if we have a bad password, then increment the bad password
        // count and check to see if the account should be locked.
        //

        if (NtStatus == STATUS_WRONG_PASSWORD) {

            //
            // Get the V1aFixed so we can update the bad password count
            //


            TmpStatus = STATUS_SUCCESS;
            if (!V1aFixedRetrieved) {
                TmpStatus = SampRetrieveUserV1aFixed(
                                AccountContext,
                                &V1aFixed
                                );
            }

            if (!NT_SUCCESS(TmpStatus)) {

                //
                // If we can't update the V1aFixed, then return this
                // error so that the user doesn't find out the password
                // was not correct.
                //

                NtStatus = TmpStatus;

            } else  if (!LoopbackClient) {


                //
                // Increment BadPasswordCount (might lockout account)
                //


                AccountLockedOut = SampIncrementBadPasswordCount(
                                       AccountContext,
                                       &V1aFixed,
                                       NULL
                                       );

                V1aFixedModified = TRUE;


            }
            else
            {
                //
                // Called from loopback, increment bad password count,
                // after current transaction is rolled back by the DS
                // This transaction needs to be rolled back because
                // there could be other things that the client is modifying
                // at the same time
                //

                SampAddLoopbackTaskForBadPasswordCount(&AccountName);
            }

        }

        if (V1aFixedModified) {
            TmpStatus = SampReplaceUserV1aFixed(
                            AccountContext,
                            &V1aFixed
                            );
            if (!NT_SUCCESS(TmpStatus)) {
                NtStatus = TmpStatus;
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // Password change was successful; check if site affinity
            // needs updating when the context is dereferenced
            //
            ASSERT(AccountContext->ObjectType == SampUserObjectType);
            AccountContext->TypeBody.User.fCheckForSiteAffinityUpdate = TRUE;
        }
    }

    SampFreeUnicodeString( &AccountName );

    return(NtStatus);
        
}

NTSTATUS
SampChangePasswordUser2(
    IN handle_t        BindingHandle,
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING UserName,
    IN BOOLEAN Unicode,
    IN BOOLEAN NtPresent,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldNt,
    IN PENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt,
    IN BOOLEAN LmPresent,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    IN BOOLEAN NtKeyUsed,
    IN PENCRYPTED_LM_OWF_PASSWORD OldLmOwfEncryptedWithNewLmOrNt,
    OUT PDOMAIN_PASSWORD_INFORMATION    DomainPasswordInfo,
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo
    )


/*++

Routine Description:

    This service sets the password to NewPassword only if OldPassword
    matches the current user password for this user and the NewPassword
    is not the same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    BindingHandle -- the RPC binding handle that generated the call

    ServerName - Name of the machine this SAM resides on. Ignored by this
        routine, may be UNICODE or OEM string depending on Unicode parameter.

    UserName - User Name of account to change password on, may be UNICODE or
        OEM depending on Unicode parameter.

    Unicode - Indicated whether the strings passed in are Unicode or OEM
        strings.

    NtPresent - Are the Nt encrypted passwords present.

    NewEncryptedWithOldNt - The new cleartext password encrypted with the old
        NT OWF password. Dependinf on the Unicode parameter, the clear text
        password may be Unicode or OEM.

    OldNtOwfEncryptedWithNewNt - Old NT OWF password encrypted with the new
        NT OWF password.

    LmPresent - are the Lm encrypted passwords present.

    NewEncryptedWithOldLm - Contains new cleartext password (OEM or Unicode)
        encrypted with the old LM OWF password

    NtKeyUsed - Indicates whether the LM or NT OWF key was used to encrypt
        the OldLmOwfEncryptedWithNewlmOrNt parameter.

    OldLmOwfEncryptedWithNewlmOrNt - The old LM OWF password encrypted
        with either the new LM OWF password or NT OWF password, depending
        on the NtKeyUsed parameter.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

    STATUS_CROSS_ENCRYPTION_REQUIRED - No NT password is stored, so the caller
        must provide the OldNtEncryptedWithOldLm parameter.

--*/
{
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    SAMPR_HANDLE            UserHandle=NULL;
    ULONG                   ObjectRid;
    PSAMP_OBJECT            AccountContext;
    UNICODE_STRING          NewClearPassword;
    UNICODE_STRING          UnicodeUserName;
    SAMP_OBJECT_TYPE        FoundType;
    SAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed;
    
    

    SAMTRACE("SampChangePasswordUser2");

    //
    // Firewall against NULL pointers
    //
    if (NtPresent) {
        if ((NewEncryptedWithOldNt == NULL)
         || (OldNtOwfEncryptedWithNewNt == NULL)) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    if (LmPresent) {
        if ((NewEncryptedWithOldLm == NULL)
         || (OldLmOwfEncryptedWithNewLmOrNt == NULL)) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Note: UserName is not [unique] so can't be NULL
    //
    if (NULL==UserName->Buffer)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Update DS performance statistics
    //

    SampUpdatePerformanceCounters(
        DSSTAT_PASSWORDCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );

    //
    // Init return variables
    //

    RtlZeroMemory(&UnicodeUserName,sizeof(UNICODE_STRING));


    //
    // Validate some parameters.  We require that one of the two passwords
    // be present.
    //

    if (!NtPresent && !LmPresent) {

        return(STATUS_INVALID_PARAMETER_MIX);
    }

    RtlZeroMemory(&NewClearPassword,sizeof(UNICODE_STRING));

    //
    // Open the user (UserName may or may not be unicode string)
    //

    NtStatus = SampOpenUserInServer(
                    (PUNICODE_STRING) UserName,
                    Unicode,
                    FALSE, // TrustedClient
                    &UserHandle
                    );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SamrCloseHandle(&UserHandle);
        return(NtStatus);
    }


    AccountContext = (PSAMP_OBJECT)UserHandle;
    ObjectRid = AccountContext->TypeBody.User.Rid;



    //
    // Lookup the context, perform an access check
    //

    NtStatus = SampLookupContext(
                   AccountContext,
                   USER_CHANGE_PASSWORD,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        NT_OWF_PASSWORD OldNtOwfPassword;
        BOOLEAN         OldNtPresent = FALSE;
        LM_OWF_PASSWORD OldLmOwfPassword;
        BOOLEAN         OldLmPresent = FALSE;

        //
        // Retrieve Unicode SAM User Account Name
        // 

        NtStatus = SampGetUnicodeStringAttribute(
                        AccountContext,
                        SAMP_USER_ACCOUNT_NAME,
                        TRUE,      // make a copy
                        &UnicodeUserName
                        );

        if (NT_SUCCESS(NtStatus))
        {
            //
            // Extract the IP Address, if any
            //
            (VOID) SampExtractClientIpAddr(BindingHandle,
                                           NULL,
                                           AccountContext);

            //
            // Get fixed attributes and check for account lockout
            // 
            NtStatus = SampCheckForAccountLockout(
                            AccountContext,
                            &V1aFixed,
                            FALSE   // V1aFixed is not retrieved yet
                            );

            if (NT_SUCCESS(NtStatus))
            {

                //
                // Decrypt the cross encrypted hashes.
                //

                NtStatus = SampDecryptForPasswordChange(
                                AccountContext,
                                Unicode,
                                NtPresent,
                                NewEncryptedWithOldNt,
                                OldNtOwfEncryptedWithNewNt,
                                LmPresent,
                                NewEncryptedWithOldLm,
                                NtKeyUsed,
                                OldLmOwfEncryptedWithNewLmOrNt,
                                &NewClearPassword,
                                &OldNtOwfPassword,
                                &OldNtPresent,
                                &OldLmOwfPassword,
                                &OldLmPresent
                                );

                if (NT_SUCCESS(NtStatus))
                {

                    //
                    // Authenticate the password change operation
                    // and change the password.
                    //

                NtStatus = SampValidateAndChangePassword(
                                UserHandle,
                                TRUE,
                                TRUE,
                                &OldNtOwfPassword,
                                OldNtPresent,
                                &OldLmOwfPassword,
                                OldLmPresent,
                                &NewClearPassword,
                                DomainPasswordInfo,
                                PasswordChangeFailureInfo
                                );
                }
                //
                // Dereference the account context
                //

                if (NT_SUCCESS(NtStatus) || (NtStatus == STATUS_WRONG_PASSWORD)) {


                    //
                    // De-reference the object, write out any change to current xaction.
                    //

                    TmpStatus = SampDeReferenceContext( AccountContext, TRUE );

                    //
                    // retain previous error/success value unless we have
                    // an over-riding error from our dereference.
                    //

                    if (!NT_SUCCESS(TmpStatus)) {
                        NtStatus = TmpStatus;
                    }
        
                } else {

                    //
                    // De-reference the object, ignore changes
                    //

                    IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
                    ASSERT(NT_SUCCESS(IgnoreStatus));
                }
            }
        }
    }

    //
    // Commit changes to disk.
    //

    if ( NT_SUCCESS(NtStatus) || NtStatus == STATUS_WRONG_PASSWORD) {

        TmpStatus = SampCommitAndRetainWriteLock();

        //
        // retain previous error/success value unless we have
        // an over-riding error from our dereference.
        //

        if (!NT_SUCCESS(TmpStatus)) {
            NtStatus = TmpStatus;
        }

        if ( NT_SUCCESS(TmpStatus) ) {

            SampNotifyNetlogonOfDelta(
                SecurityDbChangePassword,
                SecurityDbObjectSamUser,
                ObjectRid,
                (PUNICODE_STRING) NULL,
                (DWORD) FALSE,      // Don't Replicate immediately
                NULL                // Delta data
                );
        }
    }

    if (SampDoSuccessOrFailureAccountAuditing(AccountContext->DomainIndex, NtStatus)) {

        SampAuditAnyEvent(
            AccountContext,
            NtStatus,
            SE_AUDITID_USER_PWD_CHANGED, // AuditId
            DomainSidFromAccountContext(AccountContext),// Domain SID
            NULL,                        // Additional Info
            NULL,                        // Member Rid (not used)
            NULL,                        // Member Sid (not used)
            &UnicodeUserName,            // Account Name
            &SampDefinedDomains[AccountContext->DomainIndex].ExternalName,// Domain
            &ObjectRid,                  // Account Rid
            NULL                         // Privileges used
            );

    }



    //
    // Release the write lock
    //

    TmpStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(TmpStatus));


    //
    // Notify any notification packages that a password has changed.
    //

    if (NT_SUCCESS(NtStatus)) {

        ULONG NotifyFlags = SAMP_PWD_NOTIFY_PWD_CHANGE;
        if (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK) {
            NotifyFlags |= SAMP_PWD_NOTIFY_MACHINE_ACCOUNT;                
        }

        IgnoreStatus = SampPasswordChangeNotify(
                        NotifyFlags,                                                    
                        &UnicodeUserName,
                        ObjectRid,
                        &NewClearPassword,
                        FALSE    // not loopback
                        );
    }

    SamrCloseHandle(&UserHandle);

    if (NewClearPassword.Buffer != NULL) {

        RtlZeroMemory(
            NewClearPassword.Buffer,
            NewClearPassword.Length
            );

    }

     if ( Unicode ) {

        SampFreeUnicodeString( &NewClearPassword );
    } else {

        RtlFreeUnicodeString( &NewClearPassword );
    }

    if (UnicodeUserName.Buffer)
    {
        MIDL_user_free(UnicodeUserName.Buffer);
    }
   

    return(NtStatus);
}


NTSTATUS
SampDsSetPasswordUser(
    IN PSAMP_OBJECT UserHandle,
    IN PUNICODE_STRING PassedInPassword
    )


/*++

Routine Description:

   This is a set password routine, intended to be called
   by the DS.


Parameters:

    UserHandle -- Handle to the user object

    OldClearPassword  -- The old password in the clear

    NewClearPassword  -- The new password in the clear


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    ULONG                   ObjectRid;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    UNICODE_STRING          AccountName;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    BOOLEAN                 MachineAccount = FALSE;
    BOOLEAN                 NoPasswordRequiredForAccount = FALSE;
    BOOLEAN                 fContextReferenced = FALSE;
    NT_OWF_PASSWORD         NtOwfBuffer;
    LM_OWF_PASSWORD         LmOwfBuffer;
    BOOLEAN                 LmPresent;
    BOOLEAN                 FreeRandomizedPassword = FALSE;
    UNICODE_STRING          TmpPassword = *PassedInPassword;
    PUNICODE_STRING         NewClearPassword = &TmpPassword;
    

    SAMTRACE("SampDsSetPasswordUser");

    //
    // Init some variables
    //
    
    RtlZeroMemory(&AccountName,sizeof(AccountName));
       

    AccountContext = (PSAMP_OBJECT)UserHandle;
    ObjectRid = AccountContext->TypeBody.User.Rid;


    //
    // Validate the passed in context and see if the user handle
    // was opened with password set access
    //

    NtStatus = SampLookupContext(
                   AccountContext,
                   USER_FORCE_PASSWORD_CHANGE,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );

    if (!NT_SUCCESS(NtStatus)) 
    {
        goto Cleanup;
    }

    fContextReferenced = TRUE;


    //
    // Randomize the krbtgt password
    //

    NtStatus = SampRandomizeKrbtgtPassword(
                    AccountContext,
                    NewClearPassword,
                    FALSE, //FreeOldPassword
                    &FreeRandomizedPassword
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // Retrieve the account name for Auditing
    //

    NtStatus = SampGetUnicodeStringAttribute(
                AccountContext, 
                SAMP_USER_ACCOUNT_NAME,
                TRUE,           // make a copy
                &AccountName
                );
    if (!NT_SUCCESS(NtStatus)) 
    {
        goto Cleanup;
    }

    //
    // Get the effective domain policy
    //

    NtStatus = SampObtainEffectivePasswordPolicy(
                &DomainPasswordInfo,
                AccountContext,
                FALSE
                );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // Enforce Domain Password No Clear Change
    //

    if (DomainPasswordInfo.PasswordProperties & DOMAIN_PASSWORD_NO_CLEAR_CHANGE)
    {
        NtStatus = STATUS_PASSWORD_RESTRICTION;
        goto Cleanup;
    }



    //
    // Get the user fixed attributes
    //

    NtStatus = SampRetrieveUserV1aFixed(
                   AccountContext,
                   &V1aFixed
                   );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    MachineAccount = ((V1aFixed.UserAccountControl 
                              & USER_MACHINE_ACCOUNT_MASK)!=0);
    NoPasswordRequiredForAccount = ((V1aFixed.UserAccountControl 
                               & USER_PASSWORD_NOT_REQUIRED)!=0);
                    


    if (!MachineAccount && !(NoPasswordRequiredForAccount
                             && (0==NewClearPassword->Length))) {

        UNICODE_STRING FullNameLocal;


        NtStatus = SampCheckPasswordRestrictions(
                       AccountContext,
                       &DomainPasswordInfo,
                       NewClearPassword,
                       NULL
                       );

        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }
        
        //
        // Get the account name and full name to pass
        // to the password filter.
        //

        NtStatus = SampGetUnicodeStringAttribute(
                        AccountContext,          // Context
                        SAMP_USER_FULL_NAME,     // AttributeIndex
                        FALSE,                   // MakeCopy
                        &FullNameLocal           // UnicodeAttribute
                        );
        if (!NT_SUCCESS(NtStatus))
        {
            goto Cleanup;
        }

        //
        // Pass the password through the password filter
        //

        NtStatus = SampPasswordChangeFilter(
                        &AccountName,
                        &FullNameLocal,
                        NewClearPassword,
                        NULL,
                        TRUE                // set operation
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Cleanup;
        }
    }
    else if ((MachineAccount)
              && ((V1aFixed.UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT)==0))
    {
        //
        // Machine Account and not trust account
        // check to see if refuse password change is set
        //

         NtStatus = SampEnforceDefaultMachinePassword(
                                        AccountContext,
                                        NewClearPassword,
                                        &DomainPasswordInfo
                                        );

         if (!NT_SUCCESS(NtStatus))
         {
             goto Cleanup;
         }
    }

    NtStatus = SampCalculateLmAndNtOwfPasswords(
                    NewClearPassword,
                    &LmPresent,
                    &LmOwfBuffer,
                    &NtOwfBuffer
                    ); 
    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // Set the password data
    //
    NtStatus = SampStoreUserPasswords(
                    AccountContext,
                    &LmOwfBuffer,
                    LmPresent,
                    &NtOwfBuffer,
                    TRUE,
                    FALSE,
                    PasswordSet,
                    &DomainPasswordInfo,
                    NewClearPassword
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // Set the password last set time
    //

    NtStatus = SampComputePasswordExpired(
                    FALSE,  // Password doesn't expire now
                    &V1aFixed.PasswordLastSet
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    NtStatus = SampReplaceUserV1aFixed(
                        AccountContext,
                        &V1aFixed
                        );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // Note the caller in loopback is responsible for notifying the packages
    // that the password changed.
    //

Cleanup:


      if (fContextReferenced)
      {

        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // De-reference the object, write out any change to current xaction.
            //

            TmpStatus = SampDeReferenceContext( AccountContext, TRUE );

            //
            // retain previous error/success value unless we have
            // an over-riding error from our dereference.
            //

            if (!NT_SUCCESS(TmpStatus)) {
                NtStatus = TmpStatus;
            }

        } else {

            //
            // De-reference the object, ignore changes
            //

            IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }
            
    }

    if (SampDoSuccessOrFailureAccountAuditing(AccountContext->DomainIndex, NtStatus))
    {

        PSAMP_DEFINED_DOMAINS   Domain = NULL;

        Domain = &SampDefinedDomains[AccountContext->DomainIndex];

        SampAuditAnyEvent(
            AccountContext,
            NtStatus,
            SE_AUDITID_USER_PWD_SET,    // AuditID
            Domain->Sid,    // Domain Sid
            NULL,           // Additional Info
            NULL,           // Member Rid
            NULL,           // Member Sid
            &AccountName,   // AccountName
            &Domain->ExternalName,  // Domain Name
            &ObjectRid,     // Account Rid
            NULL            // Privileges used
            );
    }

    if (NULL!=AccountName.Buffer)
    {
        MIDL_user_free(AccountName.Buffer);
    }

    if ((FreeRandomizedPassword ) && (NULL!=NewClearPassword->Buffer))
    {
        MIDL_user_free(NewClearPassword->Buffer);
    }


    return(NtStatus);
            
}

NTSTATUS
SampDsChangePasswordUser(
    IN PSAMP_OBJECT UserHandle,
    IN PUNICODE_STRING OldClearPassword,
    IN PUNICODE_STRING NewClearPassword
    )


/*++

Routine Description:

    This service sets the password to NewPassword only if OldPassword
    matches the current user password for this user and the NewPassword
    is not the same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply. This is the change password entry point when password change
    is called by the DS ( to satisfy an ldap request )


Parameters:

    UserHandle -- Handle to the user object

    OldClearPassword  -- The old password in the clear

    NewClearPassword  -- The new password in the clear


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

    STATUS_CROSS_ENCRYPTION_REQUIRED - No NT password is stored, so the caller
        must provide the OldNtEncryptedWithOldLm parameter.

--*/
{
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    ULONG                   ObjectRid;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    UNICODE_STRING          AccountName;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;
    BOOLEAN                 MachineAccount;
  
    

    SAMTRACE("SampDsChangePasswordUser");

    

    //
    // Update DS performance statistics
    //

    SampUpdatePerformanceCounters(
        DSSTAT_PASSWORDCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );


    
    RtlZeroMemory(&AccountName,sizeof(AccountName));
       

    AccountContext = (PSAMP_OBJECT)UserHandle;
    ObjectRid = AccountContext->TypeBody.User.Rid;

    NtStatus = SampLookupContext(
                   AccountContext,
                   USER_CHANGE_PASSWORD,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {
 

        //
        // Retrieve the account name for Auditing
        //


        NtStatus = SampGetUnicodeStringAttribute(
                    AccountContext, 
                    SAMP_USER_ACCOUNT_NAME,
                    TRUE,           // make a copy
                    &AccountName
                    );

        if (NT_SUCCESS(NtStatus)) {

            SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
            NtStatus = SampRetrieveUserV1aFixed(AccountContext,
                                                &V1aFixed
                                                );

            if (NT_SUCCESS(NtStatus)) {
                MachineAccount =  (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK) ? TRUE : FALSE;
            }
        }


        if (NT_SUCCESS(NtStatus))
        {
            NT_OWF_PASSWORD OldNtOwfPassword;
            LM_OWF_PASSWORD OldLmOwfPassword;
            BOOLEAN         LmPresent;


            //
            // Calculate the OWF passwords
            //

            NtStatus = SampCalculateLmAndNtOwfPasswords(
                            OldClearPassword,
                            &LmPresent,
                            &OldLmOwfPassword,
                            &OldNtOwfPassword
                            );

            if (NT_SUCCESS(NtStatus))
            {


                NtStatus = SampValidateAndChangePassword(
                                UserHandle,
                                FALSE, // write lock is acquired
                                TRUE, //validate old password
                                &OldNtOwfPassword,
                                TRUE, //NtPresent,
                                &OldLmOwfPassword,
                                LmPresent,
                                NewClearPassword,
                                &DomainPasswordInfo,
                                NULL
                                );
            }
        }

        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus)) {



            //
            // De-reference the object, write out any change to current xaction.
            //

            TmpStatus = SampDeReferenceContext( AccountContext, TRUE );

            //
            // retain previous error/success value unless we have
            // an over-riding error from our dereference.
            //

            if (!NT_SUCCESS(TmpStatus)) {
                NtStatus = TmpStatus;
            }

        } else {

            //
            // De-reference the object, ignore changes
            //

            IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }
    }

    if (SampDoSuccessOrFailureAccountAuditing(AccountContext->DomainIndex, NtStatus)) {

        SampAuditAnyEvent(
            AccountContext,
            NtStatus,
            SE_AUDITID_USER_PWD_CHANGED, // AuditId
            DomainSidFromAccountContext(AccountContext),// Domain SID
            NULL,                        // Additional Info
            NULL,                        // Member Rid (not used)
            NULL,                        // Member Sid (not used)
            &AccountName,                    // Account Name
            &SampDefinedDomains[AccountContext->DomainIndex].ExternalName,// Domain
            &ObjectRid,                  // Account Rid
            NULL                         // Privileges used
            );

    }



    //
    // Notify any notification packages that a password has changed.
    //

    if (NT_SUCCESS(NtStatus)) {

        ULONG NotifyFlags = SAMP_PWD_NOTIFY_PWD_CHANGE;
        if (MachineAccount) {
            NotifyFlags |= SAMP_PWD_NOTIFY_MACHINE_ACCOUNT;                
        }
        IgnoreStatus = SampPasswordChangeNotify(
                        NotifyFlags,
                        &AccountName,
                        ObjectRid,
                        NewClearPassword,
                        TRUE            // loopback
                        );
    }

    //
    // Zero out old and new clear passwords
    //

    if (NewClearPassword->Buffer != NULL) {

        RtlZeroMemory(
            NewClearPassword->Buffer,
            NewClearPassword->Length
            );

    }

    if (OldClearPassword->Buffer != NULL) {

        RtlZeroMemory(
            OldClearPassword->Buffer,
            OldClearPassword->Length
            );

    }

  

    return(NtStatus);
}

NTSTATUS
SamrOemChangePasswordUser2(
    IN handle_t BindingHandle,
    IN PRPC_STRING ServerName,
    IN PRPC_STRING UserName,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    IN PENCRYPTED_LM_OWF_PASSWORD OldLmOwfEncryptedWithNewLm
    )
/*++

Routine Description:

    Server side stub for Unicode password change.
    See SampChangePasswordUser2 for details

Arguments:


Return Value:

--*/
{
    NTSTATUS    NtStatus;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;
    

    SAMTRACE_EX("SamrOemChangePasswordUser2");

    NtStatus = SampChangePasswordUser2(
                BindingHandle,
                (PUNICODE_STRING) ServerName,
                (PUNICODE_STRING) UserName,
                FALSE,                          // not unicode
                FALSE,                          // NT not present
                NULL,                           // new NT password
                NULL,                           // old NT password
                TRUE,                           // LM present
                NewEncryptedWithOldLm,
                FALSE,                          // NT key not used
                OldLmOwfEncryptedWithNewLm,
                &DomainPasswordInfo,
                NULL
                );

    if (NtStatus == STATUS_NT_CROSS_ENCRYPTION_REQUIRED) {

        //
        // Downlevel clients don't understand
        // STATUS_NT_CROSS_ENCRYPTION_REQUIRED
        //
        NtStatus = STATUS_WRONG_PASSWORD;
    }

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return (NtStatus);



}





NTSTATUS
SamrUnicodeChangePasswordUser2(
    IN handle_t BindingHandle,
    IN PRPC_UNICODE_STRING ServerName,
    IN PRPC_UNICODE_STRING UserName,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldNt,
    IN PENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt,
    IN BOOLEAN LmPresent,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    IN PENCRYPTED_LM_OWF_PASSWORD OldLmOwfEncryptedWithNewNt
    )
/*++

Routine Description:

    Server side stub for Unicode password change.
    See SampChangePasswordUser2 for details

Arguments:


Return Value:

--*/

{
    NTSTATUS    NtStatus;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;

    SAMTRACE_EX("SamrUnicodeChangePasswordUser2");

    NtStatus = SampChangePasswordUser2(
                BindingHandle,
                (PUNICODE_STRING) ServerName,
                (PUNICODE_STRING) UserName,
                TRUE,                           // unicode
                TRUE,                           // NT present
                NewEncryptedWithOldNt,
                OldNtOwfEncryptedWithNewNt,
                LmPresent,
                NewEncryptedWithOldLm,
                TRUE,                           // NT key used
                OldLmOwfEncryptedWithNewNt,
                &DomainPasswordInfo,
                NULL
                );

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return (NtStatus);
}


NTSTATUS
SamrUnicodeChangePasswordUser3(
    IN handle_t BindingHandle,
    IN PRPC_UNICODE_STRING ServerName,
    IN PRPC_UNICODE_STRING UserName,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldNt,
    IN PENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt,
    IN BOOLEAN LmPresent,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewEncryptedWithOldLm,
    IN PENCRYPTED_LM_OWF_PASSWORD OldLmOwfEncryptedWithNewNt,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD  AdditionalData,
    OUT PDOMAIN_PASSWORD_INFORMATION * EffectivePasswordPolicy, 
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION *PasswordChangeFailureInfo 
    )
/*++

Routine Description:

    Server side stub for Unicode password change.
    See SampChangePasswordUser2 for details

Arguments:


Return Value:

--*/

{
    NTSTATUS    NtStatus;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;
    USER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfoLocal;

    SAMTRACE_EX("SamrUnicodeChangePasswordUser3");

   
    if ((NULL==EffectivePasswordPolicy) || (NULL!=*EffectivePasswordPolicy))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    if ((NULL==PasswordChangeFailureInfo) || (NULL!=*PasswordChangeFailureInfo))
    {
        return(STATUS_INVALID_PARAMETER);
    }


    //
    // Pre-allocate memory for holding the effective policy and failure
    // information
    //

    *EffectivePasswordPolicy = MIDL_user_allocate(
                                            sizeof(DOMAIN_PASSWORD_INFORMATION));
    if (NULL==*EffectivePasswordPolicy)
    {
        return(STATUS_NO_MEMORY);
    }

    *PasswordChangeFailureInfo = MIDL_user_allocate(
                                            sizeof(USER_PWD_CHANGE_FAILURE_INFORMATION));
    
    if (NULL==*PasswordChangeFailureInfo)
    {
        MIDL_user_free(*EffectivePasswordPolicy);
        *EffectivePasswordPolicy = NULL;
        return(STATUS_NO_MEMORY);
    }

    //
    // Zero out  out parameters
    //

    RtlZeroMemory(*EffectivePasswordPolicy, sizeof(DOMAIN_PASSWORD_INFORMATION));
    RtlZeroMemory(*PasswordChangeFailureInfo, 
                           sizeof(USER_PWD_CHANGE_FAILURE_INFORMATION));

    RtlZeroMemory(&DomainPasswordInfo,sizeof(DOMAIN_PASSWORD_INFORMATION));
    RtlZeroMemory(&PasswordChangeFailureInfoLocal,
                           sizeof(USER_PWD_CHANGE_FAILURE_INFORMATION));

    NtStatus = SampChangePasswordUser2(
                BindingHandle,
                (PUNICODE_STRING) ServerName,
                (PUNICODE_STRING) UserName,
                TRUE,                           // unicode
                TRUE,                           // NT present
                NewEncryptedWithOldNt,
                OldNtOwfEncryptedWithNewNt,
                LmPresent,
                NewEncryptedWithOldLm,
                TRUE,                           // NT key used
                OldLmOwfEncryptedWithNewNt,
                &DomainPasswordInfo,
                &PasswordChangeFailureInfoLocal
                );

    

        if (STATUS_PASSWORD_RESTRICTION==NtStatus)
        {
            //
            // If the password change was failed with a password restriction
            // return additional info regarding the failure
            //

            RtlCopyMemory(*EffectivePasswordPolicy,
                          &DomainPasswordInfo,
                          sizeof(DOMAIN_PASSWORD_INFORMATION));
            

            RtlCopyMemory(*PasswordChangeFailureInfo,
                          &PasswordChangeFailureInfoLocal,
                          sizeof(USER_PWD_CHANGE_FAILURE_INFORMATION));
                 
        }
        else
        {
            MIDL_user_free(*EffectivePasswordPolicy);
            *EffectivePasswordPolicy = NULL;

            MIDL_user_free(*PasswordChangeFailureInfo);
            *PasswordChangeFailureInfo = NULL;
        }




    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return (NtStatus);
}


NTSTATUS
SamIChangePasswordForeignUser(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NewPassword,
    IN OPTIONAL HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess
    )
//
// See SamIChangePasswordForeignUser2
//
{
    return SamIChangePasswordForeignUser2(NULL,
                                          UserName,
                                          NewPassword,
                                          ClientToken,
                                          DesiredAccess);
}

NTSTATUS
SamIChangePasswordForeignUser2(
    IN PSAM_CLIENT_INFO ClientInfo,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NewPassword,
    IN OPTIONAL HANDLE ClientToken,
    IN ACCESS_MASK DesiredAccess
    )
/*++

Routine Description:

    This service sets the password for user UserName to NewPassword only
    if NewPassword matches policy constraints and the calling user has
    USER_CHANGE_PASSWORD access to the account.


Parameters:

    ClientInfo - Information about the client's location (eg IP address)
    
    UserName - User Name of account to change password on

    NewPassword - The new cleartext password.

    ClientToken - Token of client to impersonate, optional.

    DesiredAccess - Access to verify for this request.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

    STATUS_CROSS_ENCRYPTION_REQUIRED - No NT password is stored, so the caller
        must provide the OldNtEncryptedWithOldLm parameter.

--*/
{
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    PSAMP_DEFINED_DOMAINS   Domain;
    ULONG                   ObjectRid;
    UNICODE_STRING          AccountName;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    SAMPR_HANDLE            UserHandle = NULL;
    BOOLEAN                 MachineAccount = FALSE;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;
    USER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo;

    SAMTRACE("SamIChangePasswordForeignUser");

    
    //
    // Update DS performance statistics
    //

    SampUpdatePerformanceCounters(
        DSSTAT_PASSWORDCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );

    //
    // Initialize variables
    //

    NtStatus = STATUS_SUCCESS;
    RtlInitUnicodeString(&AccountName, 
                         NULL
                         );
    //
    // Open the user
    //

    NtStatus = SampOpenUserInServer(
                    (PUNICODE_STRING) UserName,
                    TRUE,
                    TRUE, // TrustedClient
                    &UserHandle
                    );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SamrCloseHandle(&UserHandle);
        return(NtStatus);
    }

    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)UserHandle;

    NtStatus = SampLookupContext(
                   AccountContext,
                   0,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );
    if (!NT_SUCCESS(NtStatus)) {
        IgnoreStatus = SampReleaseWriteLock( FALSE );
        SamrCloseHandle(&UserHandle);
        return(NtStatus);
    }

    ObjectRid = AccountContext->TypeBody.User.Rid;

    //
    // Set the client info, if any
    //
    if (ClientInfo) {
        AccountContext->TypeBody.User.ClientInfo = *ClientInfo;
    }

    //
    // Get a pointer to the domain object
    //

    Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

    if (ARGUMENT_PRESENT(ClientToken))
    {

        //
        // If a client token was passed in then access ck
        // for change password access.
        //

        ASSERT(USER_CHANGE_PASSWORD == DesiredAccess);
        AccountContext->TrustedClient = FALSE;

        NtStatus = SampValidateObjectAccess2(
                        AccountContext,
                        USER_CHANGE_PASSWORD,
                        ClientToken,
                        FALSE,
                        TRUE, // Change Password
                        FALSE // Set Password
                        );
    }

    //
    // Auditing information
    //

    if (NT_SUCCESS(NtStatus))
    {

        NtStatus = SampGetUnicodeStringAttribute( AccountContext,
                                              SAMP_USER_ACCOUNT_NAME,
                                              TRUE,           // make a copy
                                              &AccountName
                                              );
    }

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampRetrieveUserV1aFixed(AccountContext,
                                            &V1aFixed
                                            );

        if (NT_SUCCESS(NtStatus)) {
            MachineAccount =  (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK) ? TRUE : FALSE;
        }
    }

    //
    // Perform the actual change password operation
    //

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SampValidateAndChangePassword(
                            UserHandle,
                            TRUE,
                            FALSE,
                            NULL,
                            FALSE,
                            NULL,
                            FALSE,
                            NewPassword,
                            &DomainPasswordInfo,
                            &PasswordChangeFailureInfo
                            );
    }

    //
    // Dereference the account context
    //

    if (NT_SUCCESS(NtStatus) || (NtStatus == STATUS_WRONG_PASSWORD)) {



        //
        // De-reference the object, write out any change to current xaction.
        //

        TmpStatus = SampDeReferenceContext( AccountContext, TRUE );

        //
        // retain previous error/success value unless we have
        // an over-riding error from our dereference.
        //

        if (!NT_SUCCESS(TmpStatus)) {
            NtStatus = TmpStatus;
        }

    } else {

        //
        // De-reference the object, ignore changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

   
    //
    // Commit changes to disk.
    //

    if ( NT_SUCCESS(NtStatus) || NtStatus == STATUS_WRONG_PASSWORD) {

        TmpStatus = SampCommitAndRetainWriteLock();

        //
        // retain previous error/success value unless we have
        // an over-riding error from our dereference.
        //

        if (!NT_SUCCESS(TmpStatus)) {
            NtStatus = TmpStatus;
        }

        if ( NT_SUCCESS(TmpStatus) ) {

            SampNotifyNetlogonOfDelta(
                SecurityDbChangePassword,
                SecurityDbObjectSamUser,
                ObjectRid,
                (PUNICODE_STRING) NULL,
                (DWORD) FALSE,      // Don't Replicate immediately
                NULL                // Delta data
                );
        }
    }

    if (  SampDoSuccessOrFailureAccountAuditing(AccountContext->DomainIndex, NtStatus)
       && ARGUMENT_PRESENT(ClientToken) ) {

        BOOL fImpersonate;

        //
        // Only audit if a token is passed in. NETLOGON uses this
        // function to reset machine account passwords over the
        // secure channel hence there is no token present.  Without
        // a token, we could audit the event as SYSTEM or ANONYMOUS
        // but that is misleading. Also, it is confusing for admin's
        // to password changes by "ANONYMOUS" -- it looks like
        // the system is being hacked.
        //

        //
        // We impersonate here so the audit correctly log the user
        // that is changing the password.
        //
        fImpersonate = ImpersonateLoggedOnUser( ClientToken );

        SampAuditAnyEvent(
            AccountContext,
            NtStatus,
            SE_AUDITID_USER_PWD_CHANGED, // AuditId
            Domain->Sid,                 // Domain SID
            NULL,                        // Additional Info
            NULL,                        // Member Rid (not used)
            NULL,                        // Member Sid (not used)
            &AccountName,                // Account Name
            &Domain->ExternalName,       // Domain
            &ObjectRid,                  // Account Rid
            NULL                         // Privileges used
            );

        if ( fImpersonate ) {

            RevertToSelf();
            
        }

    }

    //
    // Release the write lock
    //

    TmpStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(TmpStatus));


    //
    // Notify any notification packages that a password has changed.
    //

    if (NT_SUCCESS(NtStatus)) {

        ULONG NotifyFlags = SAMP_PWD_NOTIFY_PWD_CHANGE;
        if (MachineAccount) {
            NotifyFlags |= SAMP_PWD_NOTIFY_MACHINE_ACCOUNT;                
        }

        IgnoreStatus = SampPasswordChangeNotify(
                        NotifyFlags,
                        &AccountName,
                        ObjectRid,
                        NewPassword,
                        FALSE  // not loopback
                        );
    }

    //
    // Reset the trusted client bit
    //

    AccountContext->TrustedClient = TRUE;
    SamrCloseHandle(&UserHandle);


    SampFreeUnicodeString( &AccountName );

    return(NtStatus);
}

NTSTATUS
SamISetPasswordForeignUser(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING NewPassword,
    IN HANDLE ClientToken
    )
//
// See SamISetPasswordForeignUser2
//
{
    return SamISetPasswordForeignUser2(NULL,
                                       UserName,
                                       NewPassword,
                                       ClientToken);
}

NTSTATUS
SamISetPasswordForeignUser2(
    IN PSAM_CLIENT_INFO ClientInfo, OPTIONAL                                
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING PassedInPassword,
    IN HANDLE ClientToken
    )
/*++

Routine Description:

    This service sets the password for user UserName to NewPassword, 
    w/ access based on "Set Password" permissions

Parameters:

    ClientInfo - information about the client's location (eg. IP address)
    
    UserName - User Name of account to change password on

    NewPassword - The new cleartext password.

    ClientToken - Token of client to impersonate, optional.

    
Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

    STATUS_CROSS_ENCRYPTION_REQUIRED - No NT password is stored, so the caller
        must provide the OldNtEncryptedWithOldLm parameter.

--*/
{
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    PSAMP_DEFINED_DOMAINS   Domain;
    ULONG                   ObjectRid;
    UNICODE_STRING          AccountName, FullName;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    SAMPR_HANDLE            UserHandle = NULL;
    BOOLEAN                 MachineAccount = FALSE;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;
    USER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInfo;
    SAMPR_USER_INFO_BUFFER UserInfo = {0};

    NT_OWF_PASSWORD     NtOwfBuffer;
    LM_OWF_PASSWORD     LmOwfBuffer;
    BOOLEAN             LmPresent;
    BOOLEAN             FreeRandomizedPassword = FALSE;
    UNICODE_STRING      TmpPassword = *PassedInPassword;
    PUNICODE_STRING     NewPassword = &TmpPassword;


    SAMTRACE("SamISetPasswordForeignUser");

    //
    // Update DS performance statistics
    //

    SampUpdatePerformanceCounters(
        DSSTAT_PASSWORDCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );

    //
    // Initialize variables
    //

    NtStatus = STATUS_SUCCESS;
    RtlInitUnicodeString(&AccountName, 
                         NULL
                         );


    //
    // Open the user
    //

    NtStatus = SampOpenUserInServer(
                    (PUNICODE_STRING) UserName,
                    TRUE,
                    TRUE, // TrustedClient
                    &UserHandle
                    );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SamrCloseHandle(&UserHandle);
        return(NtStatus);
    }

    //
    // Validate type of, and access to object.
    //
    AccountContext = (PSAMP_OBJECT)UserHandle;

    NtStatus = SampLookupContext(
                   AccountContext,
                   USER_FORCE_PASSWORD_CHANGE,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );

    if (!NT_SUCCESS(NtStatus)) {
        IgnoreStatus = SampReleaseWriteLock( FALSE );
        SamrCloseHandle(&UserHandle);
        return(NtStatus);
    }

    ObjectRid = AccountContext->TypeBody.User.Rid;

    //
    // Set the client info, if any
    //
    if (ClientInfo) {
        AccountContext->TypeBody.User.ClientInfo = *ClientInfo;
    }

    //
    // Get a pointer to the domain object
    //

    Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

    //
    // If a client token was passed in then access ck
    // for change password access.
    //

    AccountContext->TrustedClient = FALSE;
    
    NtStatus = SampValidateObjectAccess2(
                              AccountContext,
                              USER_FORCE_PASSWORD_CHANGE,
                              ClientToken,
                              FALSE,
                              FALSE, // Change password
                              TRUE // Set Password
                              );

    //
    // Randomize the password if it is on the krbtgt account
    //

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SampRandomizeKrbtgtPassword(
                        AccountContext,
                        NewPassword,
                        FALSE, //FreeOldPassword
                        &FreeRandomizedPassword
                        );
    }
          
    //
    // Auditing information
    //
    if (NT_SUCCESS(NtStatus))
    {

        NtStatus = SampGetUnicodeStringAttribute( 
                             AccountContext,
                             SAMP_USER_ACCOUNT_NAME,
                             TRUE,           // make a copy
                             &AccountName
                             );
    }
    
    // 
    //   GetV1a info
    //
    if (NT_SUCCESS(NtStatus))
    {
    
       NtStatus = SampRetrieveUserV1aFixed(
                            AccountContext,
                            &V1aFixed
                            );
    }

    //
    // Get the effective domain policy
    //
    if (NT_SUCCESS(NtStatus))
    {
    
       NtStatus = SampObtainEffectivePasswordPolicy(
                            &DomainPasswordInfo,
                            AccountContext,
                            TRUE
                            );
    }
                              
    //
    // Perform the actual change password operation
    //
    if (NT_SUCCESS(NtStatus))
    {

       NtStatus = SampCalculateLmAndNtOwfPasswords(
                            NewPassword,
                            &LmPresent,
                            &LmOwfBuffer,
                            &NtOwfBuffer
                            );
    }


    //
    // If the account is not a workstation & server trust account
    // and it not a service account like krbtgt.
    // Get the full name to pass
    // to the password filter.
    //
    if (NT_SUCCESS(NtStatus))
       {
       if (( (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)== 0)
           && (DOMAIN_USER_RID_KRBTGT!=AccountContext->TypeBody.User.Rid)) {


           NtStatus =  SampCheckPasswordRestrictions(
                           AccountContext,
                           &DomainPasswordInfo,
                           NewPassword,
                           NULL
                           );
           if (NT_SUCCESS(NtStatus)) {

               NtStatus = SampGetUnicodeStringAttribute(
                                 AccountContext,           // Context
                                 SAMP_USER_FULL_NAME,          // AttributeIndex
                                 FALSE,                   // MakeCopy
                                 &FullName             // UnicodeAttribute
                                 );
               
               if (NT_SUCCESS(NtStatus)) {

                   NtStatus = SampPasswordChangeFilter(
                                 &AccountName,
                                 &FullName,
                                 NewPassword,
                                 NULL,
                                 TRUE                // set operation
                                 );
                }

           }

       }
       else if ((V1aFixed.UserAccountControl & USER_SERVER_TRUST_ACCOUNT)
                || (V1aFixed.UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT))
          {

          NtStatus = SampEnforceDefaultMachinePassword(
                            AccountContext,
                            NewPassword,
                            &DomainPasswordInfo
                            );
       }
    }


    if (NT_SUCCESS(NtStatus))
    {
       NtStatus = SampStoreUserPasswords(
                            AccountContext,
                            &LmOwfBuffer,
                            LmPresent,
                            &NtOwfBuffer,
                            TRUE, // NTOWF always there?
                            FALSE, // check history
                            PasswordSet,
                            &DomainPasswordInfo,
                            NewPassword
                            );
    }


    //
    //   Update the password expire field
    //
    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SampStorePasswordExpired(
                           AccountContext,
                           FALSE
                           );  

    }                          

    AccountContext->TrustedClient = TRUE;

    //
    // Dereference the account context
    //

    if (NT_SUCCESS(NtStatus)) {
    

        //
        // De-reference the object, write out any change to current xaction.
        //

        TmpStatus = SampDeReferenceContext( AccountContext, TRUE );

        //
        // retain previous error/success value unless we have
        // an over-riding error from our dereference.
        //

        if (!NT_SUCCESS(TmpStatus)) {
            NtStatus = TmpStatus;
        }

    } else {

        //
        // De-reference the object, ignore changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }
    

    //
    // Commit changes to disk.
    //

    if ( NT_SUCCESS(NtStatus)) {

        TmpStatus = SampCommitAndRetainWriteLock();

        //
        // retain previous error/success value unless we have
        // an over-riding error from our dereference.
        //

        if (!NT_SUCCESS(TmpStatus)) {
            NtStatus = TmpStatus;
        }

        if ( NT_SUCCESS(TmpStatus) ) {

            SampNotifyNetlogonOfDelta(
                SecurityDbChangePassword,
                SecurityDbObjectSamUser,
                ObjectRid,
                (PUNICODE_STRING) NULL,
                (DWORD) FALSE,      // Don't Replicate immediately
                NULL                // Delta data
                );
        }
    }

    if (  SampDoSuccessOrFailureAccountAuditing(AccountContext->DomainIndex, NtStatus) )
    {
        BOOL fImpersonate;

        //
        // Only audit if a token is passed in. NETLOGON uses this
        // function to reset machine account passwords over the
        // secure channel hence there is no token present.  Without
        // a token, we could audit the event as SYSTEM or ANONYMOUS
        // but that is misleading. Also, it is confusing for admin's
        // to password changes by "ANONYMOUS" -- it looks like
        // the system is being hacked.
        //

        //
        // We impersonate here so the audit correctly log the user
        // that is changing the password.
        //
        fImpersonate = ImpersonateLoggedOnUser( ClientToken );

        SampAuditAnyEvent(
            AccountContext,
            NtStatus,
            SE_AUDITID_USER_PWD_SET, // AuditId
            Domain->Sid,                 // Domain SID
            NULL,                        // Additional Info
            NULL,                        // Member Rid (not used)
            NULL,                        // Member Sid (not used)
            &AccountName,                // Account Name
            &Domain->ExternalName,       // Domain
            &ObjectRid,                  // Account Rid
            NULL                         // Privileges used
            );

        if ( fImpersonate ) {

            RevertToSelf();
            
        }

    }



    //
    // Release the write lock
    //

    TmpStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(TmpStatus));


    //
    // Notify any notification packages that a password has changed.
    //
    if (NT_SUCCESS(NtStatus)) {

        ULONG NotifyFlags = SAMP_PWD_NOTIFY_PWD_CHANGE;
        if (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK) {
            NotifyFlags |= SAMP_PWD_NOTIFY_MACHINE_ACCOUNT;                
        }

        IgnoreStatus = SampPasswordChangeNotify(
                        NotifyFlags,
                        &AccountName,
                        ObjectRid,
                        NewPassword,
                        FALSE  // not loopback
                        );



    } 

    SamrCloseHandle(&UserHandle);
    
    SampFreeUnicodeString( &AccountName );

    return(NtStatus);
}


NTSTATUS
SamrGetGroupsForUser(
    IN SAMPR_HANDLE UserHandle,
    OUT PSAMPR_GET_GROUPS_BUFFER *Groups
    )


/*++

Routine Description:

    This service returns the list of groups that a user is a member of.
    It returns a structure for each group that includes the relative ID
    of the group, and the attributes of the group that are assigned to
    the user.

    This service requires USER_LIST_GROUPS access to the user account
    object.




Parameters:

    UserHandle - The handle of an opened user to operate on.

    Groups - Receives a pointer to a buffer containing a count of members
        and a pointer to a second buffer containing an array of
        GROUP_MEMBERSHIPs data structures.  When this information is
        no longer needed, these buffers must be freed using
        SamFreeMemory().


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.



--*/
{

    NTSTATUS                    NtStatus;
    NTSTATUS                    IgnoreStatus;
    PSAMP_OBJECT                AccountContext;
    SAMP_OBJECT_TYPE            FoundType;
    BOOLEAN                     fReadLockAcquired = FALSE;
    DECLARE_CLIENT_REVISION(UserHandle);

    SAMTRACE_EX("SamrGetGroupsForUser");
    
    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidGetGroupsForUser
                   );

    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (Groups != NULL);

    if ((*Groups) != NULL) {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto SamrGetGroupsForUserError;
    }



    //
    // Allocate the first of the return buffers
    //

    (*Groups) = MIDL_user_allocate( sizeof(SAMPR_GET_GROUPS_BUFFER) );

    if ( (*Groups) == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto SamrGetGroupsForUserError;
    }




    SampMaybeAcquireReadLock((PSAMP_OBJECT) UserHandle,
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fReadLockAcquired);


    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)UserHandle;
    NtStatus = SampLookupContext(
                   AccountContext,
                   USER_LIST_GROUPS,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampRetrieveUserMembership(
                       AccountContext,
                       TRUE, // Make copy
                       &(*Groups)->MembershipCount,
                       &(*Groups)->Groups
                       );

        //
        // De-reference the object, discarding changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock(fReadLockAcquired);


    if (!NT_SUCCESS(NtStatus)) {

        (*Groups)->MembershipCount = 0;

        MIDL_user_free( (*Groups) );
        (*Groups) = NULL;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

SamrGetGroupsForUserError:

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidGetGroupsForUser
                   );

    return( NtStatus );
}



NTSTATUS
SamrGetUserDomainPasswordInformation(
    IN SAMPR_HANDLE UserHandle,
    OUT PUSER_DOMAIN_PASSWORD_INFORMATION PasswordInformation
    )


/*++

Routine Description:

    Takes a user handle, finds the domain for that user, and returns
    password information for the domain.  This is so the client\wrappers.c
    can get the information to verify the user's password before it is
    OWF'd.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    PasswordInformation - Receives information about password restrictions
        for the user's domain.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    Other errors may be returned from SampLookupContext() if the handle
    is invalid or does not indicate proper access to the domain's password
    inforamtion.

--*/
{
    SAMP_OBJECT_TYPE            FoundType;
    NTSTATUS                    NtStatus;
    NTSTATUS                    IgnoreStatus;
    PSAMP_OBJECT                AccountContext;
    PSAMP_DEFINED_DOMAINS       Domain;
    SAMP_V1_0A_FIXED_LENGTH_USER   V1aFixed;
    DECLARE_CLIENT_REVISION(UserHandle);

    SAMTRACE_EX("SamrGetUserDomainPasswordInformation");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidGetUserDomainPasswordInformation
                   );

    SampAcquireReadLock();

    AccountContext = (PSAMP_OBJECT)UserHandle;

    NtStatus = SampLookupContext(
                   AccountContext,
                   0,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        //
        // When the user was opened, we checked to see if the domain handle
        // allowed access to the domain password information.  Check that here.
        //

        if ( !( AccountContext->TypeBody.User.DomainPasswordInformationAccessible ) ) {

            NtStatus = STATUS_ACCESS_DENIED;

        } else {

            Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

            //
            // If the user account is a machine account,
            // or a service account such as krbtgt
            // then restrictions are generally not enforced.
            // This is so that simple initial passwords can be
            // established.  IT IS EXPECTED THAT COMPLEX PASSWORDS,
            // WHICH MEET THE MOST STRINGENT RESTRICTIONS, WILL BE
            // AUTOMATICALLY ESTABLISHED AND MAINTAINED ONCE THE MACHINE
            // JOINS THE DOMAIN.  It is the UI's responsibility to
            // maintain this level of complexity.
            //


            NtStatus = SampRetrieveUserV1aFixed(
                           AccountContext,
                           &V1aFixed
                           );

            if (NT_SUCCESS(NtStatus)) {
                if ( ((V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)!= 0 )
                    || (DOMAIN_USER_RID_KRBTGT==V1aFixed.UserId)){

                    PasswordInformation->MinPasswordLength = 0;
                    PasswordInformation->PasswordProperties = 0;
                } else {

                    PasswordInformation->MinPasswordLength = Domain->UnmodifiedFixed.MinPasswordLength;
                    PasswordInformation->PasswordProperties = Domain->UnmodifiedFixed.PasswordProperties;
                }
            }
        }

        //
        // De-reference the object, discarding changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    SampReleaseReadLock();

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidGetUserDomainPasswordInformation
                   );

    return( NtStatus );
}



NTSTATUS
SamrGetDomainPasswordInformation(
    IN handle_t BindingHandle,
    IN OPTIONAL PRPC_UNICODE_STRING ServerName,
    OUT PUSER_DOMAIN_PASSWORD_INFORMATION PasswordInformation
    )


/*++

Routine Description:

    Takes a user handle, finds the domain for that user, and returns
    password information for the domain.  This is so the client\wrappers.c
    can get the information to verify the user's password before it is
    OWF'd.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    PasswordInformation - Receives information about password restrictions
        for the user's domain.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    Other errors may be returned from SampLookupContext() if the handle
    is invalid or does not indicate proper access to the domain's password
    inforamtion.

--*/
{
    SAMP_OBJECT_TYPE            FoundType;
    NTSTATUS                    NtStatus;
    NTSTATUS                    IgnoreStatus;
    PSAMP_OBJECT                AccountContext;
    PSAMP_DEFINED_DOMAINS       Domain;
    SAMP_V1_0A_FIXED_LENGTH_USER   V1aFixed;
    SAMPR_HANDLE                ServerHandle = NULL;
    SAMPR_HANDLE                DomainHandle = NULL;

    SAMTRACE_EX("SamrGetDomainPasswordInformation");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidGetDomainPasswordInformation
                   );

    //
    // Connect to the server and open the account domain for
    // DOMAIN_READ_PASSWORD_PARAMETERS access. Connect as a
        // trusted client. We really do not wish to enforce access
        // checks on SamrGetDomainPasswordInformation.
    //

    NtStatus = SamrConnect4(
                NULL,
                &ServerHandle,
                SAM_CLIENT_LATEST,
                0  // Ask for No accesses, as this way we will
                   // access check for any access on the Sam server
                   // object
                );

    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    //
    // If we opened the Sam Server object. Grant the LOOKUP_DOMAIN
    // access, so that we may have rights to open the domain and
    // provided we have READ access on the domain object can read the
    // properties
    //

    ((PSAMP_OBJECT)ServerHandle)->GrantedAccess = SAM_SERVER_LOOKUP_DOMAIN;

    NtStatus = SamrOpenDomain(
                ServerHandle,
                DOMAIN_READ_PASSWORD_PARAMETERS,
                SampDefinedDomains[1].Sid,
                &DomainHandle
                );

    if (!NT_SUCCESS(NtStatus)) {
        SamrCloseHandle(&ServerHandle);
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }


    SampAcquireReadLock();


    //
    // We want to look at the account domain, which is domains[1].
    //

    Domain = &SampDefinedDomains[1];

    //
    // Copy the password properites into the returned structure.
    //

    PasswordInformation->MinPasswordLength = Domain->UnmodifiedFixed.MinPasswordLength;
    PasswordInformation->PasswordProperties = Domain->UnmodifiedFixed.PasswordProperties;


    SampReleaseReadLock();

    SamrCloseHandle(&DomainHandle);
    SamrCloseHandle(&ServerHandle);

    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidGetDomainPasswordInformation
                   );

    return( NtStatus );
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Services Private to this process                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SamIAccountRestrictions(
    IN SAM_HANDLE UserHandle,
    IN PUNICODE_STRING LogonWorkStation,
    IN PUNICODE_STRING WorkStations,
    IN PLOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    )

/*++

Routine Description:

    Validate a user's ability to logon at this time and at the workstation
    being logged onto.


Arguments:

    UserHandle - The handle of an opened user to operate on.

    LogonWorkStation - The name of the workstation the logon is being
        attempted at.

    WorkStations - The list of workstations the user may logon to.  This
        information comes from the user's account information.  It must
        be in API list format.

    LogonHours - The times the user may logon.  This information comes
        from the user's account information.

    LogoffTime - Receives the time at which the user should logoff the
        system.

    KickoffTime - Receives the time at which the user should be kicked
        off the system.


Return Value:


    STATUS_SUCCESS - Logon is permitted.

    STATUS_INVALID_LOGON_HOURS - The user is not authorized to logon at
        this time.

    STATUS_INVALID_WORKSTATION - The user is not authorized to logon to
        the specified workstation.


--*/
{

#define MILLISECONDS_PER_WEEK 7 * 24 * 60 * 60 * 1000

    TIME_FIELDS             CurrentTimeFields;
    LARGE_INTEGER           CurrentTime, CurrentUTCTime;
    LARGE_INTEGER           MillisecondsIntoWeekXUnitsPerWeek;
    LARGE_INTEGER           LargeUnitsIntoWeek;
    LARGE_INTEGER           Delta100Ns;
    PSAMP_OBJECT            AccountContext;
    PSAMP_DEFINED_DOMAINS   Domain;
    SAMP_OBJECT_TYPE        FoundType;
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    NTSTATUS                IgnoreStatus;
    ULONG                   CurrentMsIntoWeek;
    ULONG                   LogoffMsIntoWeek;
    ULONG                   DeltaMs;
    ULONG                   MillisecondsPerUnit;
    ULONG                   CurrentUnitsIntoWeek;
    ULONG                   LogoffUnitsIntoWeek;
    USHORT                  i;
    TIME_ZONE_INFORMATION   TimeZoneInformation;
    DWORD TimeZoneId;
    LARGE_INTEGER           BiasIn100NsUnits = {0, 0};
    LONG                    BiasInMinutes = 0;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    BOOLEAN                 fLockAcquired = FALSE;

    SAMTRACE_EX("SamIAccountRestrictions");


    AccountContext = (PSAMP_OBJECT)UserHandle;


    //
    // Acquire the Read lock if necessary
    //

    SampMaybeAcquireReadLock(AccountContext,
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fLockAcquired);


    //
    // Validate type of, and access to object.
    //



    NtStatus = SampLookupContext(
                   AccountContext,
                   0L,
                   SampUserObjectType,           // ExpectedType
                   &FoundType
                   );


    if ( NT_SUCCESS( NtStatus ) ) {

        NtStatus = SampRetrieveUserV1aFixed(
                       AccountContext,
                       &V1aFixed
                       );
        if (NT_SUCCESS(NtStatus)) {

            //
            // Only check for users other than the builtin ADMIN
            //

            if (V1aFixed.UserId != DOMAIN_USER_RID_ADMIN) {

                //
                // Check to see if no GC was available during group expansion
                //
                if (AccountContext->TypeBody.User.fNoGcAvailable) {

                    NtStatus = STATUS_NO_LOGON_SERVERS;

                }

                if ( NT_SUCCESS( NtStatus ) ) {

                    //
                    // Scan to make sure the workstation being logged into is in the
                    // list of valid workstations - or if the list of valid workstations
                    // is null, which means that all are valid.
                    //
    
                    NtStatus = SampMatchworkstation( LogonWorkStation, WorkStations );

                }

                if ( NT_SUCCESS( NtStatus ) ) {

                    //
                    // Check to make sure that the current time is a valid time to logon
                    // in the LogonHours.
                    //
                    // We need to validate the time taking into account whether we are
                    // in daylight savings time or standard time.  Thus, if the logon
                    // hours specify that we are able to logon between 9am and 5pm,
                    // this means 9am to 5pm standard time during the standard time
                    // period, and 9am to 5pm daylight savings time when in the
                    // daylight savings time.  Since the logon hours stored by SAM are
                    // independent of daylight savings time, we need to add in the
                    // difference between standard time and daylight savings time to
                    // the current time before checking whether this time is a valid
                    // time to logon.  Since this difference (or bias as it is called)
                    // is actually held in the form
                    //
                    // Standard time = Daylight savings time + Bias
                    //
                    // the Bias is a negative number.  Thus we actually subtract the
                    // signed Bias from the Current Time.

                    //
                    // First, get the Time Zone Information.
                    //

                    TimeZoneId = GetTimeZoneInformation(
                                     (LPTIME_ZONE_INFORMATION) &TimeZoneInformation
                                     );

                    //
                    // Next, get the appropriate bias (signed integer in minutes) to subtract from
                    // the Universal Time Convention (UTC) time returned by NtQuerySystemTime
                    // to get the local time.  The bias to be used depends whether we're
                    // in Daylight Savings time or Standard Time as indicated by the
                    // TimeZoneId parameter.
                    //
                    // local time  = UTC time - bias in 100Ns units
                    //

                    switch (TimeZoneId) {

                    case TIME_ZONE_ID_UNKNOWN:

                        //
                        // There is no differentiation between standard and
                        // daylight savings time.  Proceed as for Standard Time
                        //

                        BiasInMinutes = TimeZoneInformation.StandardBias;
                        break;

                    case TIME_ZONE_ID_STANDARD:

                        BiasInMinutes = TimeZoneInformation.StandardBias;
                        break;

                    case TIME_ZONE_ID_DAYLIGHT:

                        BiasInMinutes = TimeZoneInformation.DaylightBias;
                        break;

                    default:

                        //
                        // Something is wrong with the time zone information.  Fail
                        // the logon request.
                        //

                        NtStatus = STATUS_INVALID_LOGON_HOURS;
                        break;
                    }

                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // Convert the Bias from minutes to 100ns units
                        //

                        BiasIn100NsUnits.QuadPart = ((LONGLONG)BiasInMinutes)
                                                    * 60 * 10000000;

                        //
                        // Get the UTC time in 100Ns units used by Windows Nt.  This
                        // time is GMT.
                        //

                        NtStatus = NtQuerySystemTime( &CurrentUTCTime );
                    }

                    if ( NT_SUCCESS( NtStatus ) ) {

                        CurrentTime.QuadPart = CurrentUTCTime.QuadPart -
                                      BiasIn100NsUnits.QuadPart;

                        RtlTimeToTimeFields( &CurrentTime, &CurrentTimeFields );

                        CurrentMsIntoWeek = (((( CurrentTimeFields.Weekday * 24 ) +
                                               CurrentTimeFields.Hour ) * 60 +
                                               CurrentTimeFields.Minute ) * 60 +
                                               CurrentTimeFields.Second ) * 1000 +
                                               CurrentTimeFields.Milliseconds;

                        MillisecondsIntoWeekXUnitsPerWeek.QuadPart =
                            ((LONGLONG)CurrentMsIntoWeek) *
                            ((LONGLONG)LogonHours->UnitsPerWeek);

                        LargeUnitsIntoWeek = RtlExtendedLargeIntegerDivide(
                                                 MillisecondsIntoWeekXUnitsPerWeek,
                                                 MILLISECONDS_PER_WEEK,
                                                 (PULONG)NULL );

                        CurrentUnitsIntoWeek = LargeUnitsIntoWeek.LowPart;

                        if ( !( LogonHours->LogonHours[ CurrentUnitsIntoWeek / 8] &
                            ( 0x01 << ( CurrentUnitsIntoWeek % 8 ) ) ) ) {

                            NtStatus = STATUS_INVALID_LOGON_HOURS;

                        } else {

                            //
                            // Determine the next time that the user is NOT supposed to be logged
                            // in, and return that as LogoffTime.
                            //

                            i = 0;
                            LogoffUnitsIntoWeek = CurrentUnitsIntoWeek;

                            do {

                                i++;

                                LogoffUnitsIntoWeek = ( LogoffUnitsIntoWeek + 1 ) % LogonHours->UnitsPerWeek;

                            } while ( ( i <= LogonHours->UnitsPerWeek ) &&
                                ( LogonHours->LogonHours[ LogoffUnitsIntoWeek / 8 ] &
                                ( 0x01 << ( LogoffUnitsIntoWeek % 8 ) ) ) );

                            if ( i > LogonHours->UnitsPerWeek ) {

                                //
                                // All times are allowed, so there's no logoff
                                // time.  Return forever for both logofftime and
                                // kickofftime.
                                //

                                LogoffTime->HighPart = 0x7FFFFFFF;
                                LogoffTime->LowPart = 0xFFFFFFFF;

                                KickoffTime->HighPart = 0x7FFFFFFF;
                                KickoffTime->LowPart = 0xFFFFFFFF;

                            } else {

                                //
                                // LogoffUnitsIntoWeek points at which time unit the
                                // user is to log off.  Calculate actual time from
                                // the unit, and return it.
                                //
                                // CurrentTimeFields already holds the current
                                // time for some time during this week; just adjust
                                // to the logoff time during this week and convert
                                // to time format.
                                //

                                MillisecondsPerUnit = MILLISECONDS_PER_WEEK / LogonHours->UnitsPerWeek;

                                LogoffMsIntoWeek = MillisecondsPerUnit * LogoffUnitsIntoWeek;

                                if ( LogoffMsIntoWeek < CurrentMsIntoWeek ) {

                                    DeltaMs = MILLISECONDS_PER_WEEK - ( CurrentMsIntoWeek - LogoffMsIntoWeek );

                                } else {

                                    DeltaMs = LogoffMsIntoWeek - CurrentMsIntoWeek;
                                }

                                Delta100Ns = RtlExtendedIntegerMultiply(
                                                 RtlConvertUlongToLargeInteger( DeltaMs ),
                                                 10000
                                                 );

                                LogoffTime->QuadPart = CurrentUTCTime.QuadPart +
                                              Delta100Ns.QuadPart;

                                //
                                // Subtract Domain->ForceLogoff from LogoffTime, and return
                                // that as KickoffTime.  Note that Domain->ForceLogoff is a
                                // negative delta.  If its magnitude is sufficiently large
                                // (in fact, larger than the difference between LogoffTime
                                // and the largest positive large integer), we'll get overflow
                                // resulting in a KickOffTime that is negative.  In this
                                // case, reset the KickOffTime to this largest positive
                                // large integer (i.e. "never") value.
                                //

                                Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

                                KickoffTime->QuadPart = LogoffTime->QuadPart -
                                               Domain->UnmodifiedFixed.ForceLogoff.QuadPart;

                                if (KickoffTime->QuadPart < 0) {

                                    KickoffTime->HighPart = 0x7FFFFFFF;
                                    KickoffTime->LowPart = 0xFFFFFFFF;
                                }
                            }
                        }
                    }
                }

            } else {

                //
                // Never kick administrators off
                //

                LogoffTime->HighPart  = 0x7FFFFFFF;
                LogoffTime->LowPart   = 0xFFFFFFFF;
                KickoffTime->HighPart = 0x7FFFFFFF;
                KickoffTime->LowPart  = 0xFFFFFFFF;
            }

        }

        //
        // De-reference the object, discarding changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // If the read lock was acquired release it.
    //


    SampMaybeReleaseReadLock(fLockAcquired);


    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return( NtStatus );
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Services Private to this file                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SampReplaceUserV1aFixed(
    IN PSAMP_OBJECT Context,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER V1aFixed
    )

/*++

Routine Description:

    This service replaces the current V1 fixed length information related to
    a specified User.

    The change is made to the in-memory object data only.


Arguments:

    Context - Points to the account context whose V1_FIXED information is
        to be replaced.

    V1aFixed - Is a buffer containing the new V1_FIXED information.



Return Value:


    STATUS_SUCCESS - The information has been replaced.

    Other status values that may be returned are those returned
    by:

            SampSetFixedAttributes()



--*/
{
    NTSTATUS    NtStatus;
    SAMP_V1_0A_FIXED_LENGTH_USER LocalV1aFixed;

    SAMTRACE("SampReplaceUserV1aFixed");

    //
    // Minimize the passed in structure to not include computed user
    // account control flags
    //

    RtlCopyMemory(&LocalV1aFixed,V1aFixed,sizeof(SAMP_V1_0A_FIXED_LENGTH_USER));

    LocalV1aFixed.UserAccountControl &=  ~((ULONG) USER_PASSWORD_EXPIRED);
    LocalV1aFixed.UserAccountControl &=  ~((ULONG) USER_ACCOUNT_AUTO_LOCKED);

    NtStatus = SampSetFixedAttributes(
                   Context,
                   (PVOID)&LocalV1aFixed
                   );

    return( NtStatus );
}



LARGE_INTEGER
SampGetPasswordMustChange(
    IN ULONG UserAccountControl,
    IN LARGE_INTEGER PasswordLastSet,
    IN LARGE_INTEGER MaxPasswordAge
    )

/*++

Routine Description:

    This routine returns the correct value to set the PasswordMustChange time
    to depending on the time the password was last set, whether the password
    expires on the account, and the maximum password age on the domain.

Arguments:

    UserAccountControl - The UserAccountControl for the user.  The
        USER_DONT_EXPIRE_PASSWORD bit is set if the password doesn't expire
        for this user.

    PasswordLastSet - Time when the password was last set for this user.

    MaxPasswordAge - Maximum password age for any password in the domain.


Return Value:

    Returns the time when the password for this user must change.

--*/
{
    LARGE_INTEGER PasswordMustChange;

    SAMTRACE("SampGetPasswordMustChange");

    // 
    // Here is the rules: 
    // 1. password never expires for this user (flags explicitly)
    // 2. password does not expire for smartcard
    // 3. password don't expire for machine. reliability issues, 
    //    otherwise machines are programmed to change pwd periodically
    // 
    //  return an infinitely large time.
    // 
    

    if (( UserAccountControl & USER_DONT_EXPIRE_PASSWORD ) ||
       ( UserAccountControl & USER_SMARTCARD_REQUIRED) ||
       ( UserAccountControl & USER_MACHINE_ACCOUNT_MASK ) ) 
    {

        PasswordMustChange = SampWillNeverTime;

    //
    // If the password for this account is flagged to expire immediately,
    // return a zero time time.
    //
    // Don't return the current time here.  The callers clock might be a
    // little off from ours.
    //

    } else if ( PasswordLastSet.QuadPart == SampHasNeverTime.QuadPart ) {

        PasswordMustChange = SampHasNeverTime;

    //
    // If the no password aging according to domain password policy, 
    // return an infinitely large time, so that password won't expire
    // 

    } else if (MaxPasswordAge.QuadPart == SampHasNeverTime.QuadPart) {

        PasswordMustChange = SampWillNeverTime;

    //
    // Otherwise compute the expiration time as the time the password was
    // last set plus the maximum age.
    //

    } else {

        PasswordMustChange = SampAddDeltaTime(
                                  PasswordLastSet,
                                  MaxPasswordAge);
    }

    return PasswordMustChange;
}



NTSTATUS
SampComputePasswordExpired(
    IN BOOLEAN PasswordExpired,
    OUT PLARGE_INTEGER PasswordLastSet
    )

/*++

Routine Description:

    This routine returns the correct value to set the PasswordLastSet time
    to depending on whether the caller has requested the password to expire.
    It does this by setting the PasswordLastSet time to be now (if it's
    not expired) or to SampHasNeverTime (if it is expired).

Arguments:

    PasswordExpired - TRUE if the password should be marked as expired.



Return Value:

    STATUS_SUCCESS - the PasswordLastSet time has been set to indicate
        whether or not the password is expired.

    Errors as returned by NtQuerySystemTime.

--*/
{
    NTSTATUS                  NtStatus;

    SAMTRACE("SampComputePasswordExpired");

    //
    // If immediate expiry is required - set this timestamp to the
    // beginning of time. This will work if the domain enforces a
    // maximum password age. We may have to add a separate flag to
    // the database later if immediate expiry is required on a domain
    // that doesn't enforce a maximum password age.
    //

    if (PasswordExpired) {

        //
        // Set password last changed at dawn of time
        //

        *PasswordLastSet = SampHasNeverTime;
        NtStatus = STATUS_SUCCESS;

    } else {

        //
        // Set password last changed 'now'
        //

        NtStatus = NtQuerySystemTime( PasswordLastSet );
    }

    return( NtStatus );
}



NTSTATUS
SampStorePasswordExpired(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN PasswordExpired
    )

/*++

Routine Description:

    This routine marks the current password as expired, or not expired.
    It does this by setting the PasswordLastSet time to be now (if it's
    not expired) or to SampHasNeverTime (if it is expired).

Arguments:

    Context - Points to the user account context.

    PasswordExpired - TRUE if the password should be marked as expired.

Return Value:

    STATUS_SUCCESS - the PasswordLastSet time has been set to indicate
        whether or not the password is expired.

    Errors as returned by Samp{Retrieve|Replace}V1Fixed()

--*/
{
    NTSTATUS                  NtStatus;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;

    SAMTRACE("SampStorePasswordExpired");

    //
    // Get the V1aFixed info for the user
    //

    NtStatus = SampRetrieveUserV1aFixed(
                   Context,
                   &V1aFixed
                   );

    //
    // Update the password-last-changed timestamp for the account
    //

    if (NT_SUCCESS(NtStatus ) ) {

        NtStatus = SampComputePasswordExpired(
                        PasswordExpired,
                        &V1aFixed.PasswordLastSet );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampReplaceUserV1aFixed(
                       Context,
                       &V1aFixed
                       );
        }
    }

    return( NtStatus );
}



NTSTATUS
SampStoreUserPasswords(
    IN PSAMP_OBJECT Context,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN BOOLEAN LmPasswordPresent,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN BOOLEAN NtPasswordPresent,
    IN BOOLEAN CheckHistory,
    IN SAMP_STORE_PASSWORD_CALLER_TYPE CallerType,
    IN PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo OPTIONAL,
    IN PUNICODE_STRING ClearPassword OPTIONAL
    )

/*++

Routine Description:

    This service updates the password for the specified user.

    This involves encrypting the one-way-functions of both LM and NT
    passwords with a suitable index and writing them into the registry.

    This service checks the new password for legality including history
    and UAS compatibilty checks - returns STATUS_PASSWORD_RESTRICTION if
    any of these checks fail.

    The password-last-changed time is updated.

        THE CHANGE WILL BE ADDED TO THE CURRENT RXACT TRANSACTION.


Arguments:

    Context - Points to the user account context.

    LmOwfPassword - The one-way-function of the LM password.

    LmPasswordPresent - TRUE if the LmOwfPassword contains valid information.

    NtOwfPassword - The one-way-function of the NT password.

    NtPasswordPresent - TRUE if the NtOwfPassword contains valid information.

    CallerType - Indicate why this API is been called.
                 Valid values are:
                    PasswordChange
                    PasswordSet
                    PasswordPushPdc


Return Value:


    STATUS_SUCCESS - The passwords have been updated.

    STATUS_PASSWORD_RESTRICTION - The new password is not valid for
                                  for this account at this time.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            RtlAddActionToRXact()



--*/
{
    NTSTATUS                NtStatus;
    ULONG                   ObjectRid = Context->TypeBody.User.Rid;
    CRYPT_INDEX             CryptIndex;
    UNICODE_STRING          StringBuffer;
    UNICODE_STRING          NtOwfHistoryBuffer;
    UNICODE_STRING          LmOwfHistoryBuffer;
    ENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword;
    ENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    BOOLEAN                 NtPasswordNull = FALSE, LmPasswordNull = FALSE;
    UNICODE_STRING          StoredBuffer;
    USHORT                  PasswordHistoryLength=0;
    USHORT                  MinPasswordLength;

    SAMTRACE("SampStoreUserPasswords");


    //
    // Get the V1aFixed info for the user
    //

    NtStatus = SampRetrieveUserV1aFixed(
                   Context,
                   &V1aFixed
                   );
    if ( !NT_SUCCESS( NtStatus ) ) {
        return (NtStatus);
    }


    //
    // do a start type WMI event trace
    // use CallerType to distinguish different events
    //

    switch (CallerType) {

    case PasswordChange:

        if (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)
        {
            SampTraceEvent(EVENT_TRACE_TYPE_START,
                           SampGuidChangePasswordComputer
                           );
        }
        else
        {
            SampTraceEvent(EVENT_TRACE_TYPE_START,
                           SampGuidChangePasswordUser
                           );
        }
        break;

    case PasswordSet:

        if (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)
        {
            SampTraceEvent(EVENT_TRACE_TYPE_START,
                           SampGuidSetPasswordComputer
                           );

        }
        else
        {
            SampTraceEvent(EVENT_TRACE_TYPE_START,
                           SampGuidSetPasswordUser
                           );
        }

        break;

    case PasswordPushPdc:

        SampTraceEvent(EVENT_TRACE_TYPE_START,
                       SampGuidPasswordPushPdc
                       );
        break;

    default:

        ASSERT(FALSE && "Invalid caller type");
        NtStatus = STATUS_INVALID_PARAMETER;
        return (NtStatus);

    }

    //
    // Get the domain policies to enforce
    //

    if (ARGUMENT_PRESENT(DomainPasswordInfo))
    {
        PasswordHistoryLength = DomainPasswordInfo->PasswordHistoryLength;
        MinPasswordLength = DomainPasswordInfo->MinPasswordLength;
    }


    //
    // If the registry key for No LM passwords is set then change
    // the LmPasswordPresent bit to False. This ensures that  the
    // LM password is not saved. Do so if NtPassword is present
    //

    if ((NtPasswordPresent) && (SampNoLmHash)) {
         LmPasswordPresent = FALSE;
    }

    //
    // If the No LM password setting is enabled and the NtPassword
    // is not present then fail the call with STATUS_PASSWORD_RESTRICTION
    //

    if ((!NtPasswordPresent) && (SampNoLmHash)) {
         return (STATUS_PASSWORD_RESTRICTION);
    }



    //
    // Check for a LM Owf of a NULL password.
    //

    if (LmPasswordPresent) {
        LmPasswordNull = RtlEqualNtOwfPassword(LmOwfPassword, &SampNullLmOwfPassword);
    }

    //
    // Check for a NT Owf of a NULL password
    //

    if (NtPasswordPresent) {
        NtPasswordNull = RtlEqualNtOwfPassword(NtOwfPassword, &SampNullNtOwfPassword);
    }



    //
    // Check password against restrictions if this isn't a trusted client
    //

    if (NT_SUCCESS(NtStatus) && !Context->TrustedClient) {

        //
        // If we have neither an NT or LM password, check it's allowed
        //

        if ( ((!LmPasswordPresent) || LmPasswordNull) &&
            ((!NtPasswordPresent) || NtPasswordNull) ) {

            if ( (!(V1aFixed.UserAccountControl & USER_PASSWORD_NOT_REQUIRED))
                 && (MinPasswordLength > 0) ) {

                NtStatus = STATUS_PASSWORD_RESTRICTION;
            }
        }


        //
        // If we have a complex NT password (no LM equivalent), check it's allowed
        //

        if (NT_SUCCESS(NtStatus)) {

            if ((!LmPasswordPresent || LmPasswordNull) &&
                (NtPasswordPresent && !NtPasswordNull) ) {
            }
        }

        //
        // If this is a not a trusted client and is an interdomain
        // trust account then fail the call
        //

        if (0!=(V1aFixed.UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT))
        {
           NtStatus = STATUS_ACCESS_DENIED;
        }
    }


    //
    // If NT Password is present then try to update the password
    // for interdomain trust accounts in the LSA
    //

    if (NT_SUCCESS(NtStatus) && (NtOwfPassword))
    {
        UNICODE_STRING Password;
        UNICODE_STRING OldPassword;

        Password.Length = sizeof(NT_OWF_PASSWORD);
        Password.MaximumLength = sizeof(NT_OWF_PASSWORD);
        Password.Buffer = (USHORT*) NtOwfPassword;

        NtStatus = SampSyncLsaInterdomainTrustPassword(
                        Context,
                        &Password
                        );
    }
    //
    // Reencrypt both OWFs with the key for this user
    // so they can be stored on disk
    //
    // Note we encrypt the NULL OWF if we do not have a
    // a particular OWF. This is so we always have something
    // to add to the password history.
    //

    //
    // We'll use the account rid as the encryption index
    //

    ASSERT(sizeof(ObjectRid) == sizeof(CryptIndex));
    CryptIndex = ObjectRid;

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = RtlEncryptLmOwfPwdWithIndex(
                       LmPasswordPresent ? LmOwfPassword :
                                           &SampNullLmOwfPassword,
                       &CryptIndex,
                       &EncryptedLmOwfPassword
                       );
    }

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = RtlEncryptNtOwfPwdWithIndex(
                       NtPasswordPresent ? NtOwfPassword :
                                           &SampNullNtOwfPassword,
                       &CryptIndex,
                       &EncryptedNtOwfPassword
                       );
    }



    //
    // Check password against password history IF client isn't trusted.
    // If client is trusted, then do not check against history. The
    // password is always added to the history
    //
    // Note we don't check NULL passwords against history
    //

    NtOwfHistoryBuffer.Buffer = NULL;
    NtOwfHistoryBuffer.MaximumLength = NtOwfHistoryBuffer.Length = 0;

    LmOwfHistoryBuffer.Buffer = NULL;
    LmOwfHistoryBuffer.MaximumLength = LmOwfHistoryBuffer.Length = 0;


    if (NT_SUCCESS(NtStatus) ) {

        //
        // Always go get the existing password history.
        // We'll use these history buffers when we save the new history
        //

        NtStatus = SampGetUnicodeStringAttribute(
                       Context,
                       SAMP_USER_LM_PWD_HISTORY,
                       FALSE, // Don't make copy
                       &StringBuffer
                       );

        //
        // Decrypt the data if necessary
        //

        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampDecryptSecretData(
                            &LmOwfHistoryBuffer,
                            LmPasswordHistory,
                            &StringBuffer,
                            ObjectRid
                            );

        }

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampGetUnicodeStringAttribute(
                           Context,
                           SAMP_USER_NT_PWD_HISTORY,
                           FALSE, // Don't make copy
                           &StringBuffer
                           );

            //
            // Decrypt the data if necessary
            //

            if (NT_SUCCESS(NtStatus)) {
                NtStatus = SampDecryptSecretData(
                                &NtOwfHistoryBuffer,
                                NtPasswordHistory,
                                &StringBuffer,
                                ObjectRid
                                );

            }




        if (NT_SUCCESS(NtStatus) && LmPasswordPresent && !LmPasswordNull) {

            NtStatus = SampCheckPasswordHistory(
                           &EncryptedLmOwfPassword,
                           ENCRYPTED_LM_OWF_PASSWORD_LENGTH,
                           PasswordHistoryLength,
                           SAMP_USER_LM_PWD_HISTORY,
                           Context,
                           CheckHistory,
                           &LmOwfHistoryBuffer
                           );
            }


        if (NT_SUCCESS(NtStatus) && NtPasswordPresent && !NtPasswordNull) {

                NtStatus = SampCheckPasswordHistory(
                            &EncryptedNtOwfPassword,
                            ENCRYPTED_NT_OWF_PASSWORD_LENGTH,
                            PasswordHistoryLength,
                            SAMP_USER_NT_PWD_HISTORY,
                            Context,
                            CheckHistory,
                            &NtOwfHistoryBuffer
                            );
            }


        }

    }




    if (NT_SUCCESS(NtStatus ) ) {

        //
        // Write the encrypted LM OWF password into the database
        //

        if (!LmPasswordPresent || LmPasswordNull) {
            StringBuffer.Buffer = NULL;
            StringBuffer.Length = 0;
        } else {
            StringBuffer.Buffer = (PWCHAR)&EncryptedLmOwfPassword;
            StringBuffer.Length = ENCRYPTED_LM_OWF_PASSWORD_LENGTH;
        }
        StringBuffer.MaximumLength = StringBuffer.Length;


        //
        // Write the encrypted LM OWF password into the registry
        //

        NtStatus = SampEncryptSecretData(
                        &StoredBuffer,
                        SampGetEncryptionKeyType(),
                        LmPassword,
                        &StringBuffer,
                        ObjectRid
                        );

        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampSetUnicodeStringAttribute(
                            Context,
                            SAMP_USER_DBCS_PWD,
                            &StoredBuffer
                            );
            SampFreeUnicodeString(&StoredBuffer);
        }

    }




    if (NT_SUCCESS(NtStatus ) ) {
        //
        // Write the encrypted NT OWF password into the database
        //

        if (!NtPasswordPresent) {
            StringBuffer.Buffer = NULL;
            StringBuffer.Length = 0;
        } else {
            StringBuffer.Buffer = (PWCHAR)&EncryptedNtOwfPassword;
            StringBuffer.Length = ENCRYPTED_NT_OWF_PASSWORD_LENGTH;
        }
        StringBuffer.MaximumLength = StringBuffer.Length;


        //
        // Write the encrypted NT OWF password into the registry
        //

        NtStatus = SampEncryptSecretData(
                        &StoredBuffer,
                        SampGetEncryptionKeyType(),
                        NtPassword,
                        &StringBuffer,
                        ObjectRid
                        );

        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampSetUnicodeStringAttribute(
                           Context,
                           SAMP_USER_UNICODE_PWD,
                           &StoredBuffer
                           );
            SampFreeUnicodeString(&StoredBuffer);
        }

    }

    //
    // Update the password history for this account.
    //
    // If both passwords are NULL then don't bother adding
    // them to the history. Note that if either is non-NULL
    // we add both. This is to avoid the weird case where a user
    // changes password many times from a LM machine, then tries
    // to change password from an NT machine and is told they
    // cannot use the password they last set from NT (possibly
    // many years ago.)
    //
    // Also, don't bother with the password history if the client is
    // trusted.  Trusted clients will set the history via SetPrivateData().
    // Besides, we didn't get the old history buffer in the trusted
    // client case above.
    //


    if ( NT_SUCCESS(NtStatus) )  {

        USHORT PasswordHistoryLengthToUse=PasswordHistoryLength;

        //
        // We always want to store the password history for the krbtgt
        // account
        //

        if ((ObjectRid == DOMAIN_USER_RID_KRBTGT) &&
            (PasswordHistoryLength < SAMP_KRBTGT_PASSWORD_HISTORY_LENGTH))
        {
            PasswordHistoryLengthToUse = SAMP_KRBTGT_PASSWORD_HISTORY_LENGTH;
        }
        if ((LmPasswordPresent && !LmPasswordNull) ||
            (NtPasswordPresent && !NtPasswordNull)) {

            NtStatus = SampAddPasswordHistory(
                               Context,
                               SAMP_USER_LM_PWD_HISTORY,
                               &LmOwfHistoryBuffer,
                               &EncryptedLmOwfPassword,
                               ENCRYPTED_LM_OWF_PASSWORD_LENGTH,
                               PasswordHistoryLengthToUse
                               );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampAddPasswordHistory(
                               Context,
                               SAMP_USER_NT_PWD_HISTORY,
                               &NtOwfHistoryBuffer,
                               &EncryptedNtOwfPassword,
                               ENCRYPTED_NT_OWF_PASSWORD_LENGTH,
                               PasswordHistoryLengthToUse
                               );
            }
        }
    }


    //
    // Update supplemental credentials field and any other derived supplemental
    // credentials such as kerberos credential types
    //

    if ((NT_SUCCESS(NtStatus)) && (PasswordPushPdc!=CallerType))
    {
        NtStatus = SampStoreAdditionalDerivedCredentials(
                        DomainPasswordInfo,
                        Context,
                        ClearPassword
                        );
    }

    //
    // If the password was successfully stored, quickly replicate the change
    // if configured to do so.
    //
    if ((SampReplicatePasswordsUrgently || (CallerType == PasswordSet))
      && !(V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)
      && NT_SUCCESS(NtStatus)) {

       Context->ReplicateUrgently = TRUE;
    }

    //
    // Clean up our history buffers
    //

    if (NtOwfHistoryBuffer.Buffer != NULL ) {
        MIDL_user_free(NtOwfHistoryBuffer.Buffer );
    }
    if (LmOwfHistoryBuffer.Buffer != NULL ) {
        MIDL_user_free(LmOwfHistoryBuffer.Buffer );
    }

    //
    // do a end type WMI event trace
    // use CallerType to distinguish different events
    //

    switch (CallerType) {

    case PasswordChange:

        if (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)
        {
            SampTraceEvent(EVENT_TRACE_TYPE_END,
                           SampGuidChangePasswordComputer
                           );

        }
        else
        {
            SampTraceEvent(EVENT_TRACE_TYPE_END,
                           SampGuidChangePasswordUser
                           );
        }

        break;

    case PasswordSet:

        if (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)
        {
            SampTraceEvent(EVENT_TRACE_TYPE_END,
                           SampGuidSetPasswordComputer
                           );

        }
        else
        {
            SampTraceEvent(EVENT_TRACE_TYPE_END,
                           SampGuidSetPasswordUser
                           );
        }

        break;

    case PasswordPushPdc:

        SampTraceEvent(EVENT_TRACE_TYPE_END,
                       SampGuidPasswordPushPdc
                       );
        break;

    default:

        ASSERT(FALSE && "Invalid caller type");
        break;
    }

    return(NtStatus );
}



NTSTATUS
SampRetrieveUserPasswords(
    IN PSAMP_OBJECT Context,
    OUT PLM_OWF_PASSWORD LmOwfPassword,
    OUT PBOOLEAN LmPasswordNonNull,
    OUT PNT_OWF_PASSWORD NtOwfPassword,
    OUT PBOOLEAN NtPasswordPresent,
    OUT PBOOLEAN NtPasswordNonNull
    )

/*++

Routine Description:

    This service retrieves the stored OWF passwords for a user.


Arguments:

    Context - Points to the user account context.

    LmOwfPassword - The one-way-function of the LM password is returned here.

    LmPasswordNonNull - TRUE if the LmOwfPassword is not the well-known
                        OWF of a NULL password

    NtOwfPassword - The one-way-function of the NT password is returned here.

    NtPasswordPresent - TRUE if the NtOwfPassword contains valid information.


Return Value:


    STATUS_SUCCESS - The passwords were retrieved successfully.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            RtlAddActionToRXact()



--*/
{
    NTSTATUS                NtStatus;
    ULONG                   ObjectRid = Context->TypeBody.User.Rid;
    UNICODE_STRING          StringBuffer;
    UNICODE_STRING          StoredBuffer;
    CRYPT_INDEX             CryptIndex;

    SAMTRACE("SampRetrieveUserPasswords");

    //
    // The OWF passwords are encrypted with the account index in the registry
    // Setup the key we'll use for decryption.
    //

    ASSERT(sizeof(ObjectRid) == sizeof(CryptIndex));
    CryptIndex = ObjectRid;


    //
    // Read the encrypted LM OWF password from the database
    //

    NtStatus = SampGetUnicodeStringAttribute(
                   Context,
                   SAMP_USER_DBCS_PWD,
                   FALSE, // Don't make copy
                   &StoredBuffer
                   );

    if ( !NT_SUCCESS( NtStatus ) ) {
        return (NtStatus);
    }

    //
    // If the data was encrypted, decrypt it now. Otherwise just duplicate
    // it so we have an alloated copy.
    //

    NtStatus = SampDecryptSecretData(
                &StringBuffer,
                LmPassword,
                &StoredBuffer,
                ObjectRid
                );

    if ( !NT_SUCCESS( NtStatus ) ) {
        return (NtStatus);
    }

    //
    // Check it is in the expected form
    //

    ASSERT( (StringBuffer.Length == 0) ||
            (StringBuffer.Length == ENCRYPTED_LM_OWF_PASSWORD_LENGTH));

    //
    // Determine if there is an LM password.
    //

    *LmPasswordNonNull = (BOOLEAN)(StringBuffer.Length != 0);

    //
    // Decrypt the encrypted LM Owf Password
    //

    if (*LmPasswordNonNull) {

        SampDiagPrint(LOGON,("[SAMSS] Decrypting Lm Owf Password\n"));

        NtStatus = RtlDecryptLmOwfPwdWithIndex(
                       (PENCRYPTED_LM_OWF_PASSWORD)StringBuffer.Buffer,
                       &CryptIndex,
                       LmOwfPassword
                       );
    } else {

        //
        // Fill in the NULL password for caller convenience
        //

        SampDiagPrint(LOGON,("[SAMSS] Null LM OWF Password\n"));
        *LmOwfPassword = SampNullLmOwfPassword;
    }


    //
    // Free up the returned string buffer
    //

    SampFreeUnicodeString(&StringBuffer);


    //
    // Check if the decryption failed
    //

    if ( !NT_SUCCESS( NtStatus ) ) {
        return (NtStatus);
    }




    //
    // Read the encrypted NT OWF password from the database
    //

    NtStatus = SampGetUnicodeStringAttribute(
                   Context,
                   SAMP_USER_UNICODE_PWD,
                   FALSE, // Don't make copy
                   &StoredBuffer
                   );

    if ( !NT_SUCCESS( NtStatus ) ) {
        return (NtStatus);
    }


    //
    // If the data was encrypted, decrypt it now. Otherwise just duplicate
    // it so we have an alloated copy.
    //

    NtStatus = SampDecryptSecretData(
                    &StringBuffer,
                    NtPassword,
                    &StoredBuffer,
                    ObjectRid
                    );

    if ( !NT_SUCCESS( NtStatus ) ) {
        return (NtStatus);
    }

    //
    // Check it is in the expected form
    //

    ASSERT( (StringBuffer.Length == 0) ||
            (StringBuffer.Length == ENCRYPTED_NT_OWF_PASSWORD_LENGTH));

    //
    // Determine if there is an Nt password.
    //

    *NtPasswordPresent = (BOOLEAN)(StringBuffer.Length != 0);

    //
    // Decrypt the encrypted NT Owf Password
    //

    if (*NtPasswordPresent) {

        SampDiagPrint(LOGON,("[SAMSS] Decrypting Nt Owf Password\n"));

        NtStatus = RtlDecryptNtOwfPwdWithIndex(
                       (PENCRYPTED_NT_OWF_PASSWORD)StringBuffer.Buffer,
                       &CryptIndex,
                       NtOwfPassword
                       );

        if ( NT_SUCCESS( NtStatus ) ) {

            *NtPasswordNonNull = (BOOLEAN)!RtlEqualNtOwfPassword(
                                     NtOwfPassword,
                                     &SampNullNtOwfPassword
                                     );
        }

    } else {

        //
        // Fill in the NULL password for caller convenience
        //

        SampDiagPrint(LOGON,("[SAMSS] NULL NT Owf Password\n"));

        *NtOwfPassword = SampNullNtOwfPassword;
        *NtPasswordNonNull = FALSE;
    }

    //
    // Free up the returned string buffer
    //

    SampFreeUnicodeString(&StringBuffer);


    return( NtStatus );
}



NTSTATUS
SampRetrieveUserMembership(
    IN PSAMP_OBJECT UserContext,
    IN BOOLEAN MakeCopy,
    OUT PULONG MembershipCount,
    OUT PGROUP_MEMBERSHIP *Membership OPTIONAL
    )

/*++
Routine Description:

    This service retrieves the number of groups a user is a member of.
    If desired, it will also retrieve an array of RIDs and attributes
    of the groups the user is a member of.


Arguments:

    UserContext - User context block

    MakeCopy - If FALSE, the Membership pointer returned refers to the
        in-memory data for the user. This is only valid as long
        as the user context is valid.
        If TRUE, memory is allocated and the membership list copied
         into it. This buffer should be freed using MIDL_user_free.

    MembershipCount - Receives the number of groups the user is a member of.

    Membership - (Otional) Receives a pointer to a buffer containing an array
        of group Relative IDs.  If this value is NULL, then this information
        is not returned.  The returned buffer is allocated using
        MIDL_user_allocate() and must be freed using MIDL_user_free() when
        no longer needed.

        If MakeCopy = TRUE, the membership buffer returned has extra space
        allocated at the end of it for one more membership entry.


Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated for the
        information to be returned in.

    Other status values that may be returned are those returned
    by:

            SampGetLargeIntArrayAttribute()



--*/
{

    NTSTATUS           NtStatus;
    PGROUP_MEMBERSHIP  MemberArray;
    ULONG              MemberCount;

    SAMTRACE("SampRetrieveUserMembership");


    if (IsDsObject(UserContext))
    {

        //
        // DS Case
        //
         SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;

        //
        // We should always ask for copy, as this path will only be called
        // in from SamrGetGroupsForUser.
        //

        ASSERT(MakeCopy == TRUE);

        //
        // Get the V1aFixed info for the user in order to retrieve the primary
        // group Id property of the user
        //

        NtStatus = SampRetrieveUserV1aFixed(
                       UserContext,
                       &V1aFixed
                       );

        if (NT_SUCCESS(NtStatus))
        {

            //
            // Retrieve the membership from the DS
            //

            NtStatus = SampDsGetGroupMembershipOfAccount(
                        DomainObjectFromAccountContext(UserContext),
                        UserContext->ObjectNameInDs,
                        MembershipCount,
                        Membership
                        );
        }


    }
    else
    {

        NtStatus = SampGetLargeIntArrayAttribute(
                            UserContext,
                            SAMP_USER_GROUPS,
                            FALSE, //Reference data directly.
                            (PLARGE_INTEGER *)&MemberArray,
                            &MemberCount
                            );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Fill in return info
            //

            *MembershipCount = MemberCount;

            if (Membership != NULL) {

                if (MakeCopy) {

                    //
                    // Allocate a buffer large enough to hold the existing
                    // membership data and one more and copy data into it.
                    //

                    ULONG BytesNow = (*MembershipCount) * sizeof(GROUP_MEMBERSHIP);
                    ULONG BytesRequired = BytesNow + sizeof(GROUP_MEMBERSHIP);

                    *Membership = MIDL_user_allocate(BytesRequired);

                    if (*Membership == NULL) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    } else {
                        RtlCopyMemory(*Membership, MemberArray, BytesNow);
                    }

                } else {

                    //
                    // Reference the data directly
                    //

                    *Membership = (PGROUP_MEMBERSHIP)MemberArray;
                }
            }
        }
    }


    return( NtStatus );

}



NTSTATUS
SampReplaceUserMembership(
    IN PSAMP_OBJECT UserContext,
    IN ULONG MembershipCount,
    IN PGROUP_MEMBERSHIP Membership
    )

/*++
Routine Description:

    This service sets the groups a user is a member of.

    The information is updated in the in-memory copy of the user's data only.
    The data is not written out by this routine.


Arguments:

    UserContext - User context block

    MembershipCount - The number of groups the user is a member of.

    Membership - A pointer to a buffer containing an array of group
        membership structures. May be NULL if membership count is zero.

Return Value:


    STATUS_SUCCESS - The information has been set.

    Other status values that may be returned are those returned
    by:

            SampSetUlongArrayAttribute()



--*/
{

    NTSTATUS    NtStatus;

    SAMTRACE("SampReplaceUserMembership");

    NtStatus = SampSetLargeIntArrayAttribute(
                        UserContext,
                        SAMP_USER_GROUPS,
                        (PLARGE_INTEGER)Membership,
                        MembershipCount
                        );

    return( NtStatus );
}



NTSTATUS
SampRetrieveUserLogonHours(
    IN PSAMP_OBJECT Context,
    IN PLOGON_HOURS LogonHours
    )

/*++
Routine Description:

    This service retrieves a user's logon hours from the registry.


Arguments:

    Context - Points to the user account context whose logon hours are
        to be retrieved.

    LogonHours - Receives the logon hours information.  If necessary, a buffer
        containing the logon time restriction bitmap will be allocated using
        MIDL_user_allocate().

Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated for the
        information to be returned in.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()



--*/
{

    NTSTATUS    NtStatus;

    SAMTRACE("SampRetrieveUserLogonHours");

    NtStatus = SampGetLogonHoursAttribute(
                   Context,
                   SAMP_USER_LOGON_HOURS,
                   TRUE, // Make copy
                   LogonHours
                   );

    if (NT_SUCCESS(NtStatus)) {

        //////////////////////////////// TEMPORARY MIDL WORKAROUND ///////////
                                                                   ///////////
        if (LogonHours->LogonHours == NULL) {                      ///////////
                                                                   ///////////
            LogonHours->UnitsPerWeek = SAM_HOURS_PER_WEEK;         ///////////
            LogonHours->LogonHours = MIDL_user_allocate( 21 );     ///////////
            if (NULL!=LogonHours->LogonHours)                      ///////////
            {                                                      ///////////
                ULONG ijk;                                         ///////////
                for ( ijk=0; ijk<21; ijk++ ) {                     ///////////
                    LogonHours->LogonHours[ijk] = 0xff;            ///////////
                }                                                  ///////////
            }                                                      ///////////
            else                                                   ///////////
            {                                                      ///////////
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;          ///////////
            }                                                      ///////////
        }                                                          ///////////
                                                                   ///////////
        //////////////////////////////// TEMPORARY MIDL WORKAROUND ///////////
    }

    return( NtStatus );

}




NTSTATUS
SampReplaceUserLogonHours(
    IN PSAMP_OBJECT Context,
    IN PLOGON_HOURS LogonHours
    )

/*++
Routine Description:

    This service replaces  a user's logon hours in the registry.

    THIS IS DONE BY ADDING AN ACTION TO THE CURRENT RXACT TRANSACTION.


Arguments:

    Context - Points to the user account context whose logon hours are
        to be replaced.

    LogonHours - Provides the new logon hours.


Return Value:


    STATUS_SUCCESS - The information has been retrieved.


    Other status values that may be returned are those returned
    by:

            RtlAddActionToRXact()



--*/
{
    NTSTATUS                NtStatus;

    SAMTRACE("SampReplaceUserLogonHours");

    if ( LogonHours->UnitsPerWeek > SAM_MINUTES_PER_WEEK ) {
        return(STATUS_INVALID_PARAMETER);
    }


    NtStatus = SampSetLogonHoursAttribute(
                   Context,
                   SAMP_USER_LOGON_HOURS,
                   LogonHours
                   );

    return( NtStatus );


}




NTSTATUS
SampAssignPrimaryGroup(
    IN PSAMP_OBJECT Context,
    IN ULONG GroupRid
    )


/*++
Routine Description:

    This service ensures a user is a member of the specified group.


Arguments:

    Context - Points to the user account context whose primary group is
        being changed.

    GroupRid - The RID of the group being assigned as primary group.
        The user must be a member of this group.


Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to perform
        the operation.

    STATUS_MEMBER_NOT_IN_GROUP - The user is not a member of the specified
        group.

    Other status values that may be returned are those returned
    by:

            SampRetrieveUserMembership()



--*/
{

    NTSTATUS                    NtStatus = STATUS_SUCCESS;
    ULONG                       MembershipCount, i;
    PGROUP_MEMBERSHIP           Membership = NULL;
    BOOLEAN                     Member = FALSE;

    SAMTRACE("SampAssignPrimaryGroup");


    //
    // Don't allow primary group id changes in Extended Sid mode. Note
    // that for compatitiblity reasons, it is allowed to "set" the primary
    // group id if it is equal to the existing value.
    //
    if (SampIsContextFromExtendedSidDomain(Context)) {

        SAMP_V1_0A_FIXED_LENGTH_USER   V1aFixed;

        NtStatus = SampRetrieveUserV1aFixed(
                       Context,
                       &V1aFixed
                       );
        if (NT_SUCCESS(NtStatus)) {
            if (V1aFixed.PrimaryGroupId != GroupRid) {
                NtStatus = STATUS_NOT_SUPPORTED;
            }
        }
    }

    if ( NT_SUCCESS(NtStatus)) {

        NtStatus = SampRetrieveUserMembership(
                       Context,
                       TRUE, // Make copy
                       &MembershipCount,
                       &Membership
                       );
    
        if (NT_SUCCESS(NtStatus)) {
    
            NtStatus = STATUS_MEMBER_NOT_IN_GROUP;
            for ( i=0; i<MembershipCount; i++) {
                if (GroupRid == Membership[i].RelativeId) {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }
    
            MIDL_user_free(Membership);
        }
    }

    return( NtStatus );
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Services Provided for use by other SAM modules                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
SampSafeBoot(
    VOID
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    HKEY Key ;
    int err ;
    BOOLEAN     fIsSafeBoot = FALSE;
    DWORD       dwType, dwSize = sizeof(DWORD), dwValue = 0;

    //
    // For Safe mode boot (minimal, no networking)
    // return TRUE, otherwise return FALSE
    //

    err = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Control\\SafeBoot\\Option",
                0,
                KEY_READ,
                &Key );

    if ( err == ERROR_SUCCESS )
    {
        err = RegQueryValueExW(
                    Key,
                    L"OptionValue",
                    0,
                    &dwType,
                    (PUCHAR) &dwValue,
                    &dwSize );

        if ((err == ERROR_SUCCESS) && (REG_DWORD == dwType))
        {
            fIsSafeBoot = (dwValue == SAFEBOOT_MINIMAL || dwValue == SAFEBOOT_NETWORK);
        }

        RegCloseKey( Key );
    }

    return( fIsSafeBoot );
}


NTSTATUS
SampUpdateAccountDisabledFlag(
    PSAMP_OBJECT Context,
    PULONG  pUserAccountControl
    )
/*++
Routine Description:

    This routine updates the USER_ACCOUNT_DISABLED flag in UserAccountControl for 
    administrator only.
    The following rules applied:

    1) admin account can be disabled irrespective of anything

    2) admin account is considered enabled irrespective of anything if machine is booted to safe mode
    
Parameters:

    Context - User Account Context
    
    pUserAccountControl - Pointer to UserAccountControl flag
    
Return Value:

    NTSTATUS Code 
    
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       TmpUserAccountControl = (*pUserAccountControl);

    //
    // no update for non-administrator account or account not disabled
    // 

    if ((DOMAIN_USER_RID_ADMIN != Context->TypeBody.User.Rid) ||
        ((TmpUserAccountControl & USER_ACCOUNT_DISABLED) == 0)
        )
    {
        return( STATUS_SUCCESS );
    }


    if (SampSafeBoot())
    {
        //
        // Administrator in Safe Mode is enabled.
        // 
        TmpUserAccountControl &= ~(USER_ACCOUNT_DISABLED); 
     
    }

    *pUserAccountControl = TmpUserAccountControl;

    return( NtStatus );
}



NTSTATUS
SampRetrieveUserV1aFixed(
    IN PSAMP_OBJECT UserContext,
    OUT PSAMP_V1_0A_FIXED_LENGTH_USER V1aFixed
    )

/*++

Routine Description:

    This service retrieves the V1 fixed length information related to
    a specified User.

    It updates the ACCOUNT_AUTO_LOCKED flag in the AccountControl field
    as appropriate while retrieving the data.


Arguments:

    UserContext - User context handle

    V1aFixed - Points to a buffer into which V1_FIXED information is to be
        retrieved.



Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    V1aFixed - Is a buffer into which the information is to be returned.

    Other status values that may be returned are those returned
    by:

            SampGetFixedAttributes()



--*/
{
    NTSTATUS    NtStatus;
    PVOID       FixedData;
    BOOLEAN     WasLocked;

    SAMTRACE("SampRetrieveUserV1aFixed");


    NtStatus = SampGetFixedAttributes(
                   UserContext,
                   FALSE, // Don't copy
                   &FixedData
                   );

    if (NT_SUCCESS(NtStatus)) {


        //
        // Copy data into return buffer
        //

         RtlMoveMemory(
             V1aFixed,
             FixedData,
             sizeof(SAMP_V1_0A_FIXED_LENGTH_USER)
             );

        //
        // Update the account lockout flag (might need to be turned off)
        //

        SampUpdateAccountLockedOutFlag(
            UserContext,
            V1aFixed,
            &WasLocked );

    }



    return( NtStatus );

}


NTSTATUS
SampRetrieveUserGroupAttribute(
    IN ULONG UserRid,
    IN ULONG GroupRid,
    OUT PULONG Attribute
    )

/*++

Routine Description:

    This service retrieves the Attribute of the specified group as assigned
    to the specified user account. This routine is used by group apis that
    don't have a user context available.

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

Arguments:

    UserRid - The relative ID of the user the group is assigned to.

    GroupRid - The relative ID of the assigned group.

    Attribute - Receives the Attributes of the group as they are assigned
        to the user.



Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    STATUS_INTERNAL_DB_CORRUPTION - The user does not exist or the group
        was not in the user's list of memberships.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()



--*/
{
    NTSTATUS                NtStatus;
    PSAMP_OBJECT            UserContext;
    ULONG                   MembershipCount;
    PGROUP_MEMBERSHIP       Membership;
    ULONG                   i;
    BOOLEAN                 AttributeFound = FALSE;

    SAMTRACE("SampRetrieveUserGroupAttribute");


    //
    // Get a context handle for the user
    //

    NtStatus = SampCreateAccountContext(
                    SampUserObjectType,
                    UserRid,
                    TRUE, // We're trusted
                    FALSE,// Loopback client
                    TRUE, // Account exists
                    &UserContext
                    );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Now we have a user context, get the user's group/alias membership
        //

        if (IsDsObject(UserContext))
        {
            //
            // User is DS Object, then hardwire the attribute
            //

            *Attribute = SE_GROUP_MANDATORY| SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED;
            AttributeFound = TRUE;
        }
        else
        {
            NtStatus = SampRetrieveUserMembership(
                            UserContext,
                            FALSE, // Make copy
                            &MembershipCount,
                            &Membership
                            );

            //
            // Search the list of groups for a match and return
            // the corresponding attribute.
            //

            if (NT_SUCCESS(NtStatus)) {

                AttributeFound = FALSE;
                for ( i=0; (i<MembershipCount && !AttributeFound); i++) {
                    if (GroupRid == Membership[i].RelativeId) {
                        (*Attribute) = Membership[i].Attributes;
                        AttributeFound = TRUE;
                    }
                }
            }
        }

        //
        // Clean up the user context
        //

        SampDeleteContext(UserContext);
    }


    if (NT_SUCCESS(NtStatus) && !AttributeFound) {
        NtStatus = STATUS_INTERNAL_DB_CORRUPTION;
    }


    return( NtStatus );

}


NTSTATUS
SampAddGroupToUserMembership(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG GroupRid,
    IN ULONG Attributes,
    IN ULONG UserRid,
    IN SAMP_MEMBERSHIP_DELTA AdminGroup,
    IN SAMP_MEMBERSHIP_DELTA OperatorGroup,
    OUT PBOOLEAN UserActive,
    OUT PBOOLEAN PrimaryGroup
    )

/*++

Routine Description:

    This service adds the specified group to the user's membership
    list.  It is not assumed that the caller knows anything about
    the target user.  In particular, the caller doesn't know whether
    the user exists or not, nor whether the user is already a member
    of the group.

    If the GroupRid is DOMAIN_GROUP_RID_ADMINS, then this service
    will also indicate whether the user account is currently active.

Arguments:

    GroupRid - The relative ID of the group.

    Attributes - The group attributes as the group is assigned to the
        user.

    UserRid - The relative ID of the user.

    AdminGroup - Indicates whether the group the user is being
        added to is an administrator group (that is, directly
        or indirectly a member of the Administrators alias).

    OperatorGroup - Indicates whether the group the user is being
        added to is an operator group (that is, directly
        or indirectly a member of the Account Operators, Print
        Operators, Backup Operators, or Server Operators aliases)

    UserActive - is the address of a BOOLEAN to be set to indicate
        whether the user account is currently active.  TRUE indicates
        the account is active.  This value will only be set if the
        GroupRid is DOMAIN_GROUP_RID_ADMINS.

    PrimaryGroup - This is set to true if the Primary Group Id property
        of the user indicates the group specified by GroupRid as the the
        primary group.



Return Value:


    STATUS_SUCCESS - The information has been updated and added to the
        RXACT.

    STATUS_NO_SUCH_USER - The user does not exist.

    STATUS_MEMBER_IN_GROUP - The user is already a member of the
        specified group.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()
            RtlAddActionToRXact()



--*/
{

    NTSTATUS                NtStatus;
    PSAMP_OBJECT            UserContext;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    ULONG                   MembershipCount;
    PGROUP_MEMBERSHIP       Membership;
    ULONG                   i;

    SAMTRACE("SampAddGroupToUserMembership");


    *PrimaryGroup = FALSE;

    //
    // Get a context handle for the user
    //

    NtStatus = SampCreateAccountContext2(
                    GroupContext,       // Group Context
                    SampUserObjectType, // Object Type
                    UserRid,            // Account ID
                    NULL,               // UserAccountControl
                    (PUNICODE_STRING)NULL,  // AccountName
                    GroupContext->ClientRevision,   // Client Revision
                    TRUE,               // We're trusted
                    GroupContext->LoopbackClient,   // Loopback client
                    FALSE,              // Create by Privilege
                    TRUE,               // Account Exists
                    FALSE,              // OverrideLocalGroupCheck
                    NULL,               // Group Type
                    &UserContext
                    );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Get the V1aFixed Data
        //

        NtStatus = SampRetrieveUserV1aFixed(
                       UserContext,
                       &V1aFixed
                       );


        //
        // If necessary, return an indication as to whether this account
        // is enabled or not.
        //

        if (NT_SUCCESS(NtStatus)) {

            if ((GroupRid == DOMAIN_GROUP_RID_ADMINS)
                 && (!(IsDsObject(UserContext))))
            {

                ASSERT(AdminGroup == AddToAdmin);  // Make sure we retrieved the V1aFixed

                if ((V1aFixed.UserAccountControl & USER_ACCOUNT_DISABLED) == 0) {
                    (*UserActive) = TRUE;
                } else {
                    (*UserActive) = FALSE;
                }
            }

            if (GroupRid == V1aFixed.PrimaryGroupId)
            {
                *PrimaryGroup = TRUE;
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // If the user is being added to an ADMIN group, modify
            // the user's ACLs so that account operators can once again
            // alter the account.  This will only occur if the user
            // is no longer a member of any admin groups.
            //

            if ( ((AdminGroup == AddToAdmin) || (OperatorGroup == AddToAdmin))
                 && (!IsDsObject(UserContext)))
            {
                NtStatus = SampChangeOperatorAccessToUser2(
                               UserContext,
                               &V1aFixed,
                               AdminGroup,
                               OperatorGroup
                               );
            }
        }


        if ((NT_SUCCESS(NtStatus)) && (!IsDsObject(UserContext)))
        {

            //
            // Get the user membership
            // Note the returned buffer already includes space for
            // an extra member. For DS case we do not maintain reverse
            // membership
            //

            NtStatus = SampRetrieveUserMembership(
                            UserContext,
                            TRUE, // Make copy
                            &MembershipCount,
                            &Membership
                            );

            if (NT_SUCCESS(NtStatus)) {

                //
                // See if the user is already a member ...
                //

                for (i = 0; i<MembershipCount ; i++ ) {
                    if ( Membership[i].RelativeId == GroupRid )
                    {
                        NtStatus = STATUS_MEMBER_IN_GROUP;
                    }
                }

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // Add the groups's RID to the end.
                    //

                    Membership[MembershipCount].RelativeId = GroupRid;
                    Membership[MembershipCount].Attributes = Attributes;
                    MembershipCount += 1;

                    //
                    // Set the user's new membership
                    //

                    NtStatus = SampReplaceUserMembership(
                                    UserContext,
                                    MembershipCount,
                                    Membership
                                    );
                }

                //
                // Free up the membership array
                //

                MIDL_user_free( Membership );
            }
        }

        //
        // Write out any changes to the user account
        // Don't use the open key handle since we'll be deleting the context.
        //

        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampStoreObjectAttributes(UserContext, FALSE);
        }

        //
        // Clean up the user context
        //

        SampDeleteContext(UserContext);
    }

    return( NtStatus );

}



NTSTATUS
SampRemoveMembershipUser(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG GroupRid,
    IN ULONG UserRid,
    IN SAMP_MEMBERSHIP_DELTA AdminGroup,
    IN SAMP_MEMBERSHIP_DELTA OperatorGroup,
    OUT PBOOLEAN UserActive
    )

/*++

Routine Description:

    This service removes the specified group from the user's membership
    list.  It is not assumed that the caller knows anything about
    the target user.  In particular, the caller doesn't know whether
    the user exists or not, nor whether the user is really a member
    of the group.

    If the GroupRid is DOMAIN_GROUP_RID_ADMINS, then this service
    will also indicate whether the user account is currently active.

Arguments:

    GroupRid - The relative ID of the group.

    UserRid - The relative ID of the user.

    AdminGroup - Indicates whether the group the user is being
        removed from is an administrator group (that is, directly
        or indirectly a member of the Administrators alias).

    OperatorGroup - Indicates whether the group the user is being
        added to is an operator group (that is, directly
        or indirectly a member of the Account Operators, Print
        Operators, Backup Operators, or Server Operators aliases)

    UserActive - is the address of a BOOLEAN to be set to indicate
        whether the user account is currently active.  TRUE indicates
        the account is active.  This value will only be set if the
        GroupRid is DOMAIN_GROUP_RID_ADMINS.




Return Value:


    STATUS_SUCCESS - The information has been updated and added to the
        RXACT.

    STATUS_NO_SUCH_USER - The user does not exist.

    STATUS_MEMBER_NOT_IN_GROUP - The user is not a member of the
        specified group.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()
            RtlAddActionToRXact()



--*/
{

    NTSTATUS                NtStatus;
    ULONG                   MembershipCount, i;
    PGROUP_MEMBERSHIP       MembershipArray;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    PSAMP_OBJECT            UserContext;

    SAMTRACE("SampRemoveMembershipUser");

    //
    // Create a context for the user
    //

    NtStatus = SampCreateAccountContext2(
                    GroupContext,           // GroupContext
                    SampUserObjectType,     // Object Type
                    UserRid,                // Object ID
                    NULL,                   // User Account Control
                    (PUNICODE_STRING)NULL,  // Account Name
                    GroupContext->ClientRevision,   // Client Revision
                    TRUE,                   // We're trusted (Trusted client)
                    GroupContext->LoopbackClient,   // Loopback client
                    FALSE,                  // Created by Privilege
                    TRUE,                   // Account Exists
                    FALSE,                  // OverrideLocalGroupCheck
                    NULL,                   // Group Type
                    &UserContext            // Account Context
                    );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Get the v1 fixed information
    // (contains primary group value and control flags)
    //

    NtStatus = SampRetrieveUserV1aFixed( UserContext, &V1aFixed );



    if (NT_SUCCESS(NtStatus)) {

        //
        // If the user is being removed from an ADMIN group, modify
        // the user's ACLs so that account operators can once again
        // alter the account.  This will only occur if the user
        // is no longer a member of any admin groups.
        //

        if (((AdminGroup == RemoveFromAdmin) ||
            (OperatorGroup == RemoveFromAdmin))
            && (!IsDsObject(UserContext)))
        {
            NtStatus = SampChangeOperatorAccessToUser2(
                           UserContext,
                           &V1aFixed,
                           AdminGroup,
                           OperatorGroup
                           );
        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // If necessary, return an indication as to whether this account
            // is enabled or not.
            //

            if (GroupRid == DOMAIN_GROUP_RID_ADMINS) {

                if ((V1aFixed.UserAccountControl & USER_ACCOUNT_DISABLED) == 0) {
                    (*UserActive) = TRUE;
                } else {
                    (*UserActive) = FALSE;
                }
            }


            //
            // See if this is the user's primary group...
            //

            if (GroupRid == V1aFixed.PrimaryGroupId) {
                NtStatus = STATUS_MEMBERS_PRIMARY_GROUP;
            }



            if ((NT_SUCCESS(NtStatus)) && (!IsDsObject(UserContext)))
            {

                //
                // Get the user membership, No reverse membership is stored for
                // DS Objects
                //

                NtStatus = SampRetrieveUserMembership(
                               UserContext,
                               TRUE, // Make copy
                               &MembershipCount,
                               &MembershipArray
                               );

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // See if the user is a member ...
                    //

                    NtStatus = STATUS_MEMBER_NOT_IN_GROUP;
                    for (i = 0; i<MembershipCount ; i++ ) {
                        if ( MembershipArray[i].RelativeId == GroupRid )
                        {
                            NtStatus = STATUS_SUCCESS;
                            break;
                        }
                    }

                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // Replace the removed group information
                        // with the last entry's information.
                        //

                        MembershipCount -= 1;
                        if (MembershipCount > 0) {
                            MembershipArray[i].RelativeId =
                                MembershipArray[MembershipCount].RelativeId;
                            MembershipArray[i].Attributes =
                            MembershipArray[MembershipCount].Attributes;
                        }

                        //
                        // Update the object with the new information
                        //

                        NtStatus = SampReplaceUserMembership(
                                        UserContext,
                                        MembershipCount,
                                        MembershipArray
                                        );
                    }

                    //
                    // Free up the membership array
                    //

                    MIDL_user_free( MembershipArray );
                }
            }
        }
    }


    //
    // Write out any changes to the user account
    // Don't use the open key handle since we'll be deleting the context.
    //

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = SampStoreObjectAttributes(UserContext, FALSE);
    }


    //
    // Clean up the user context
    //

    SampDeleteContext(UserContext);


    return( NtStatus );

}



NTSTATUS
SampSetGroupAttributesOfUser(
    IN ULONG GroupRid,
    IN ULONG Attributes,
    IN ULONG UserRid
    )

/*++

Routine Description:

    This service replaces the attributes of a group assigned to a
    user.

    The caller does not have to know whether the group is currently
    assigned to the user.

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

Arguments:

    GroupRid - The relative ID of the group.

    Attributes - The group attributes as the group is assigned to the
        user.

    UserRid - The relative ID of the user.



Return Value:


    STATUS_SUCCESS - The information has been updated and added to the
        RXACT.

    STATUS_NO_SUCH_USER - The user does not exist.

    STATUS_MEMBER_NOT_IN_GROUP - The user is not in the specified group.


    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()
            RtlAddActionToRXact()



--*/
{

    NTSTATUS                NtStatus;
    PSAMP_OBJECT            UserContext;
    ULONG                   MembershipCount;
    PGROUP_MEMBERSHIP       Membership;
    ULONG                   i;

    SAMTRACE("SampSetGroupAttributesOfUser");


    //
    // Get a context handle for the user
    //

    NtStatus = SampCreateAccountContext(
                    SampUserObjectType,
                    UserRid,
                    TRUE, // We're trusted
                    FALSE,// Loopback Client
                    TRUE, // Account exists
                    &UserContext
                    );

    if ((NT_SUCCESS(NtStatus)) && (!IsDsObject(UserContext))) {

        //
        // Now we have a user context, get the user's group/alias membership
        // For DS case this is a No Op
        //

        NtStatus = SampRetrieveUserMembership(
                        UserContext,
                        TRUE, // Make copy
                        &MembershipCount,
                        &Membership
                        );

        if (NT_SUCCESS(NtStatus)) {

            //
            // See if the user is a member ...
            //

            NtStatus = STATUS_MEMBER_NOT_IN_GROUP;
            for (i = 0; i<MembershipCount; i++ ) {
                if ( Membership[i].RelativeId == GroupRid )
                {
                    NtStatus = STATUS_SUCCESS;
                    break;
                }
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Change the groups's attributes.
                //

                Membership[i].Attributes = Attributes;

                //
                // Update the user's membership
                //

                NtStatus = SampReplaceUserMembership(
                                UserContext,
                                MembershipCount,
                                Membership
                                );
            }

            //
            // Free up the membership array
            //

            MIDL_user_free(Membership);
        }

        //
        // Write out any changes to the user account
        // Don't use the open key handle since we'll be deleting the context.
        //

        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampStoreObjectAttributes(UserContext, FALSE);
        }

        //
        // Clean up the user context
        //

        SampDeleteContext(UserContext);
    }


    return( NtStatus );
}




NTSTATUS
SampDeleteUserKeys(
    IN PSAMP_OBJECT Context
    )

/*++
Routine Description:

    This service deletes all registry keys related to a User object.


Arguments:

    Context - Points to the User context whose registry keys are
        being deleted.


Return Value:


    STATUS_SUCCESS - The information has been retrieved.


    Other status values that may be returned by:

        RtlAddActionToRXact()



--*/
{

    NTSTATUS                NtStatus;
    ULONG                   Rid;
    UNICODE_STRING          AccountName, KeyName;

    SAMTRACE("SampDeleteUserKeys");


    Rid = Context->TypeBody.User.Rid;




    //
    // Decrement the User count
    //

    NtStatus = SampAdjustAccountCount(SampUserObjectType, FALSE );




    //
    // Delete the registry key that has the User's name to RID mapping.
    //

    if (NT_SUCCESS(NtStatus)) {

        //
        // Get the name
        //

        NtStatus = SampGetUnicodeStringAttribute(
                       Context,
                       SAMP_USER_ACCOUNT_NAME,
                       TRUE,    // Make copy
                       &AccountName
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampBuildAccountKeyName(
                           SampUserObjectType,
                           &KeyName,
                           &AccountName
                           );

            SampFreeUnicodeString( &AccountName );


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = RtlAddActionToRXact(
                               SampRXactContext,
                               RtlRXactOperationDelete,
                               &KeyName,
                               0,
                               NULL,
                               0
                               );
                SampFreeUnicodeString( &KeyName );
            }
        }
    }



    //
    // Delete the attribute keys
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampDeleteAttributeKeys(
                        Context
                        );
    }




    //
    // Delete the RID key
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampBuildAccountSubKeyName(
                       SampUserObjectType,
                       &KeyName,
                       Rid,
                       NULL
                       );

        if (NT_SUCCESS(NtStatus)) {


            NtStatus = RtlAddActionToRXact(
                           SampRXactContext,
                           RtlRXactOperationDelete,
                           &KeyName,
                           0,
                           NULL,
                           0
                           );

            SampFreeUnicodeString( &KeyName );
        }


    }



    return( NtStatus );

}



NTSTATUS
SampAddPasswordHistory(
    IN PSAMP_OBJECT Context,
    IN ULONG HistoryAttributeIndex,
    IN PUNICODE_STRING NtOwfHistoryBuffer,
    IN PVOID EncryptedPassword,
    IN ULONG EncryptedPasswordLength,
    IN USHORT PasswordHistoryLength
    )

/*++

Routine Description:

    This service adds a password to the given user's password history.
    It will work for either NT or Lanman password histories.

    This routine should only be called if the password is actually present.


Arguments:

    Context - a pointer to the user context to which changes will be made.

    HistoryAttributeIndex - the attribue index in the user context which
             contains the password history.

    NtOwfHistoryBuffer - A pointer to the current password history, as
        it was retrieved from the disk - it's encrypted, and pretending
        to be in the UNICODE_STRING format.

    EncryptedPasswordLength - ENCRYPTED_NT_OWF_LENGTH or
        ENCRYPTED_LM_OWF_LENGTH, depending on which type of password
        history is being worked on.

    PasswordHistoryLength - The PasswordHistoryLength for the user's
        domain.


Return Value:


    STATUS_SUCCESS - The given password was added to the password history.

    STATUS_INSUFFICIENT_RESOURCES - The user's password history needs to
        be expanded, but there isn't enough memory to do so.

    Other errors from building the account subkey name or writing the
    password history out to the registry.


--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PCHAR OldBuffer;
    UNICODE_STRING StoredBuffer;


    SAMTRACE("SampAddPasswordHistory");

    if ( ( NtOwfHistoryBuffer->Length / EncryptedPasswordLength ) <
        ( (ULONG)PasswordHistoryLength ) ) {

        //
        // Password history buffer can be expanded.
        // Allocate a larger buffer, copy the old buffer to the new one
        // while leaving room for the new password, and free the old
        // buffer.
        //

        OldBuffer = (PCHAR)(NtOwfHistoryBuffer->Buffer);

        NtOwfHistoryBuffer->Buffer = MIDL_user_allocate(
            NtOwfHistoryBuffer->Length + EncryptedPasswordLength );

        if ( NtOwfHistoryBuffer->Buffer == NULL ) {

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            NtOwfHistoryBuffer->Buffer = (PWSTR)OldBuffer;

        } else {

            RtlCopyMemory(
                (PVOID)( (PCHAR)(NtOwfHistoryBuffer->Buffer) + EncryptedPasswordLength ),
                (PVOID)OldBuffer,
                NtOwfHistoryBuffer->Length );

            MIDL_user_free( OldBuffer );

            NtOwfHistoryBuffer->Length = (USHORT)(NtOwfHistoryBuffer->Length +
                EncryptedPasswordLength);
        }

    } else {

        //
        // Password history buffer is at its maximum size, or larger (for
        // this domain).  If it's larger, cut it down to the current maximum.
        //

        if ( ( NtOwfHistoryBuffer->Length / EncryptedPasswordLength ) >
            ( (ULONG)PasswordHistoryLength ) ) {

            //
            // Password history is too large (the password history length must
            // have been shortened recently).
            // Set length to the proper value,
            //

            NtOwfHistoryBuffer->Length = (USHORT)(EncryptedPasswordLength *
                PasswordHistoryLength);
        }

        //
        // Password history buffer is full, at its maximum size.
        // Move buffer contents right 16 bytes, which will lose the oldest
        // password and make room for the new password at the beginning
        // (left).
        // Note that we CAN'T move anything if the password history size
        // is 0.  If it's 1, we could but no need since we'll overwrite
        // it below.
        //

        if ( PasswordHistoryLength > 1 ) {

            RtlMoveMemory(
                (PVOID)( (PCHAR)(NtOwfHistoryBuffer->Buffer) + EncryptedPasswordLength ),
                (PVOID)NtOwfHistoryBuffer->Buffer,
                NtOwfHistoryBuffer->Length - EncryptedPasswordLength );
        }
    }


    //
    // Put the new encrypted OWF at the beginning of the password history
    // buffer (unless, of course, the buffer size is 0), and write the password
    // history to disk.
    //

    if ( NT_SUCCESS( NtStatus ) ) {


        if ( PasswordHistoryLength > 0 ) {

            RtlCopyMemory(
                (PVOID)NtOwfHistoryBuffer->Buffer,
                (PVOID)EncryptedPassword,
                EncryptedPasswordLength );
        }

        NtStatus = SampEncryptSecretData(
                        &StoredBuffer,
                        SampGetEncryptionKeyType(),
                        (SAMP_USER_NT_PWD_HISTORY==HistoryAttributeIndex)?
                            NtPasswordHistory:LmPasswordHistory,
                        NtOwfHistoryBuffer,
                        Context->TypeBody.User.Rid
                        );
        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampSetUnicodeStringAttribute(
                           Context,
                           HistoryAttributeIndex,
                           &StoredBuffer
                           );
            SampFreeUnicodeString(&StoredBuffer);
        }
    }

    return( NtStatus );
}



NTSTATUS
SampCheckPasswordHistory(
    IN PVOID EncryptedPassword,
    IN ULONG EncryptedPasswordLength,
    IN USHORT PasswordHistoryLength,
    IN ULONG HistoryAttributeIndex,
    IN PSAMP_OBJECT Context,
    IN BOOLEAN CheckHistory,
    IN OUT PUNICODE_STRING OwfHistoryBuffer
    )

/*++

Routine Description:

    This service takes the given password, and optionally checks it against the
    password history on the disk.  It returns a pointer to the password
    history, which will later be passed to SampAddPasswordHistory().

    This routine should only be called if the password is actually present.


Arguments:

    EncryptedPassword - A pointer to the encrypted password that we're
        looking for.

    EncryptedPasswordLength - ENCRYPTED_NT_OWF_PASSWORD or
        ENCRYPTED_LM_OWF_PASSWORD, depending on the type of password
        history to be searched.

    PasswordHistoryLength - the length of the password history for this
        domain.

    SubKeyName -  a pointer to a unicode string that describes the name
        of the password history to be read from the disk.

    Context - a pointer to the user's context.

    CheckHistory - If TRUE, the password is to be checked against
        the history to see if it is already present and an error returned
        if it is found.  If FALSE, the password will not be checked, but a
        pointer to the appropriate history buffer will still be returned
        because the specified password will be added to the history via
        SampAddPasswordHistory.

        NOTE:  The purpose of this flag is to allow Administrator to change
        a user's password regardless of whether it is already in the history.

    OwfHistoryBuffer - a pointer to a UNICODE_STRING which will be
        used to point to the password history.

        NOTE:  The caller must free OwfHistoryBuffer.Buffer with
        MIDL_user_free().


Return Value:


    STATUS_SUCCESS - The given password was not found in the password
        history.

    STATUS_PASSWORD_RESTRICTION - The given password was found in the
        password history.

    Other errors from reading the password history from disk.


--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PVOID PasswordHistoryEntry;
    ULONG i = 0;
    BOOLEAN OldPasswordFound = FALSE;

    SAMTRACE("SampCheckPasswordHistory");


    if ( ( PasswordHistoryLength > 0 ) && ( OwfHistoryBuffer->Length == 0 ) ) {

        //
        // Perhaps the domain's PasswordHistoryLength was raised from 0
        // since the last time this user's password was changed.  Try to
        // put the current password (if non-null) in the password history.
        //

        UNICODE_STRING CurrentPassword;
        UNICODE_STRING TmpString;
        USHORT PasswordAttributeIndex;

        //
        // Initialize the CurrentPassword buffer pointer to NULL (and the
        // rest of the structure for consistency.  The called routine
        // SampGetUnicodeStringAttribute may perform a MIDL_user_allocate
        // on a zero buffer length and cannot safely be changed as there are
        // many callers.  The semantics of a zero-length allocate call are
        // not clear.  Currently a pointer to a heap block is returned,
        // but this might be changed to a NULL being returned.
        //

        CurrentPassword.Length = CurrentPassword.MaximumLength = 0;
        CurrentPassword.Buffer = NULL;


        if ( HistoryAttributeIndex == SAMP_USER_LM_PWD_HISTORY ) {

            PasswordAttributeIndex = SAMP_USER_DBCS_PWD;

        } else {

            ASSERT( HistoryAttributeIndex == SAMP_USER_NT_PWD_HISTORY );
            PasswordAttributeIndex = SAMP_USER_UNICODE_PWD;
        }

        //
        // Get the current password
        //

        NtStatus = SampGetUnicodeStringAttribute(
                       Context,
                       PasswordAttributeIndex,
                       FALSE, // Make copy
                       &TmpString
                       );
        //
        // Decrypt the Current Password
        //

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampDecryptSecretData(
                        &CurrentPassword,
                        (SAMP_USER_UNICODE_PWD==PasswordAttributeIndex)?
                           NtPassword:LmPassword,
                        &TmpString,
                        Context->TypeBody.User.Rid
                        );
        }

        if ( ( NT_SUCCESS( NtStatus ) ) && ( CurrentPassword.Length != 0 ) ) {

            ASSERT( (CurrentPassword.Length == ENCRYPTED_NT_OWF_PASSWORD_LENGTH) ||
                    (CurrentPassword.Length == ENCRYPTED_LM_OWF_PASSWORD_LENGTH) );

            NtStatus = SampAddPasswordHistory(
                           Context,
                           HistoryAttributeIndex,
                           OwfHistoryBuffer,
                           CurrentPassword.Buffer,
                           CurrentPassword.Length,
                           PasswordHistoryLength
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Free the old password history, and re-read the
                // altered password history from the disk.
                //

                MIDL_user_free( OwfHistoryBuffer->Buffer );
                RtlZeroMemory(OwfHistoryBuffer, sizeof(UNICODE_STRING));

                NtStatus = SampGetUnicodeStringAttribute(
                               Context,
                               HistoryAttributeIndex,
                               FALSE, // Make copy
                               &TmpString
                               );
                if (NT_SUCCESS(NtStatus)) {

                        NtStatus = SampDecryptSecretData(
                                        OwfHistoryBuffer,
                                        (HistoryAttributeIndex == SAMP_USER_NT_PWD_HISTORY)?
                                          NtPasswordHistory:LmPasswordHistory, 
                                        &TmpString,
                                        Context->TypeBody.User.Rid
                                        );
                }
            }
        }

        //
        // If memory was allocated, free it.
        //

        if (CurrentPassword.Buffer != NULL) {

            SampFreeUnicodeString( &CurrentPassword );
        }
    }

    if ( !NT_SUCCESS( NtStatus ) ) {

        return( NtStatus );
    }

    //
    // If requested, check the Password History to see if we can use this
    // password.  Compare the passed-in password to each of the entries in
    // the password history.
    //

    if ((CheckHistory) && (!Context->TrustedClient)) {

        PasswordHistoryEntry = (PVOID)(OwfHistoryBuffer->Buffer);

        while ( ( i < (ULONG)PasswordHistoryLength ) &&
            ( i < ( OwfHistoryBuffer->Length / EncryptedPasswordLength ) ) &&
            ( OldPasswordFound == FALSE ) ) {

            if ( RtlCompareMemory(
                     EncryptedPassword,
                     PasswordHistoryEntry,
                     EncryptedPasswordLength ) == EncryptedPasswordLength ) {

                OldPasswordFound = TRUE;

            } else {

                i++;

                PasswordHistoryEntry = (PVOID)((PCHAR)(PasswordHistoryEntry) +
                    EncryptedPasswordLength );
            }
        }

        if ( OldPasswordFound ) {

            //
            // We did find it in the password history, so return an appropriate
            // error.
            //

            NtStatus = STATUS_PASSWORD_RESTRICTION;
        }
    }

    return( NtStatus );
}



NTSTATUS
SampMatchworkstation(
    IN PUNICODE_STRING LogonWorkStation,
    IN PUNICODE_STRING WorkStations
    )

/*++

Routine Description:

    Check if the given workstation is a member of the list of workstations
    given.


Arguments:

    LogonWorkStations - UNICODE name of the workstation that the user is
        trying to log into.

    WorkStations - API list of workstations that the user is allowed to
        log into.


Return Value:


    STATUS_SUCCESS - The user is allowed to log into the workstation.



--*/
{
    PWCHAR          WorkStationName;
    UNICODE_STRING  Unicode;
    NTSTATUS        NtStatus;
    WCHAR           Buffer[256];
    USHORT          LocalBufferLength = 256;
    UNICODE_STRING  WorkStationsListCopy;
    UNICODE_STRING  NetBiosOfStored;
    UNICODE_STRING  NetBiosOfPassedIn;
    BOOLEAN         BufferAllocated = FALSE;
    PWCHAR          TmpBuffer;

    SAMTRACE("SampMatchWorkstation");

    //
    // Local workstation is always allowed
    // If WorkStations field is 0 everybody is allowed
    //

    if ( ( LogonWorkStation == NULL ) ||
        ( LogonWorkStation->Length == 0 ) ||
        ( WorkStations->Length == 0 ) ) {

        return( STATUS_SUCCESS );
    }

    RtlZeroMemory(&NetBiosOfPassedIn, sizeof(UNICODE_STRING));
    RtlZeroMemory(&NetBiosOfStored, sizeof(UNICODE_STRING));

    //
    // Get the Netbiosname of Passed in logon workstation, assuming it
    // is a DNS name
    //

    NtStatus = RtlDnsHostNameToComputerName(
                    &NetBiosOfPassedIn,
                    LogonWorkStation,
                    TRUE
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // Assume failure; change status only if we find the string.
    //

    NtStatus = STATUS_INVALID_WORKSTATION;

    //
    // WorkStationApiList points to our current location in the list of
    // WorkStations.
    //

    if ( WorkStations->Length > LocalBufferLength ) {

        WorkStationsListCopy.Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, WorkStations->Length );
        BufferAllocated = TRUE;

        if ( WorkStationsListCopy.Buffer == NULL ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            return( NtStatus );
        }

        WorkStationsListCopy.MaximumLength = WorkStations->Length;

    } else {

        WorkStationsListCopy.Buffer = Buffer;
        WorkStationsListCopy.MaximumLength = LocalBufferLength;
    }

    RtlCopyUnicodeString( &WorkStationsListCopy, WorkStations );
    ASSERT( WorkStationsListCopy.Length == WorkStations->Length );

    //
    // wcstok requires a string the first time it's called, and NULL
    // for all subsequent calls.  Use a temporary variable so we
    // can do this.
    //

    TmpBuffer = WorkStationsListCopy.Buffer;

    while( WorkStationName = wcstok(TmpBuffer, L",") ) {
        NTSTATUS TmpStatus;

        TmpBuffer = NULL;
        RtlInitUnicodeString( &Unicode, WorkStationName );

        TmpStatus = RtlDnsHostNameToComputerName(
                    &NetBiosOfStored,
                    &Unicode,
                    TRUE
                    );

        if (!NT_SUCCESS(TmpStatus))
        {
            NtStatus = TmpStatus;
            goto Cleanup;
        }

        if (RtlEqualComputerName( &Unicode, LogonWorkStation )) {
            NtStatus = STATUS_SUCCESS;
            break;
        }
        else if (RtlEqualComputerName(&Unicode, &NetBiosOfPassedIn))
        {
            NtStatus = STATUS_SUCCESS;
            break;
        }
        else if (RtlEqualComputerName(&NetBiosOfStored, LogonWorkStation))
        {
            NtStatus = STATUS_SUCCESS;
            break;
        }

        RtlFreeHeap(RtlProcessHeap(),0,NetBiosOfStored.Buffer);
        NetBiosOfStored.Buffer = NULL;
    }

Cleanup:

    if ( BufferAllocated ) {
        RtlFreeHeap( RtlProcessHeap(), 0,  WorkStationsListCopy.Buffer );
    }


    if (NULL!=NetBiosOfPassedIn.Buffer)
    {
        RtlFreeHeap( RtlProcessHeap(), 0, NetBiosOfPassedIn.Buffer);
    }

    if (NULL!=NetBiosOfStored.Buffer)
    {
        RtlFreeHeap( RtlProcessHeap(), 0, NetBiosOfStored.Buffer);
    }

    return( NtStatus );
}


LARGE_INTEGER
SampAddDeltaTime(
    IN LARGE_INTEGER Time,
    IN LARGE_INTEGER DeltaTime
    )

/*++
Routine Description:

    This service adds a delta time to a time and limits the result to
    the maximum legal absolute time value

Arguments:

    Time - An absolute time

    DeltaTime - A delta time

Return Value:

    The time modified by delta time.

--*/
{
    //
    // Check the time and delta time aren't switched
    //

    SAMTRACE("SampAddDeleteTime");

    ASSERT(!(Time.QuadPart < 0));
    ASSERT(!(DeltaTime.QuadPart > 0));

    try {

        Time.QuadPart = (Time.QuadPart - DeltaTime.QuadPart);

    } except(EXCEPTION_EXECUTE_HANDLER) {

        return( SampWillNeverTime );
    }

    //
    // Limit the resultant time to the maximum valid absolute time
    //

    if (Time.QuadPart < 0) {
        Time = SampWillNeverTime;
    }

    return(Time);
}




NTSTATUS
SampDsSyncServerObjectRDN(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName
    )
/*++
Routine Description:

    This routine changes the RDN of server object specified by 
    the serverReferenceBL attribute of the computer account.

Arguments:

    Context - Points to the User context whose name is to be changed.

    NewAccountName - New name to give this account

Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    Other status values that may be returned by:
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ENTINFSEL   EntInfSel;
    READARG     ReadArg;
    READRES     *pReadRes = NULL;
    ATTR        ReadAttr;
    ATTRBLOCK   ReadAttrBlock;
    COMMARG     *pCommArg = NULL;
    MODIFYDNARG ModDnArg;
    MODIFYDNRES *pModDnRes = NULL;
    ATTR        RDNAttr;
    ATTRVAL     RDNAttrVal;
    DSNAME      *pServerObjectDsName = NULL;
    ULONG       RetCode = 0;

    SAMTRACE("SampDsSyncServerObjectRDN");

    NtStatus = SampDoImplicitTransactionStart(TransactionWrite);


    //
    // Read the serverReferenceBL attribute of the machine account
    // 

    memset( &ReadArg, 0, sizeof(READARG) );
    memset( &EntInfSel, 0, sizeof(EntInfSel) );
    memset( &ReadAttr, 0, sizeof(ReadAttr) );

    ReadAttr.attrTyp = ATT_SERVER_REFERENCE_BL;
    ReadAttrBlock.attrCount = 1;
    ReadAttrBlock.pAttr = &ReadAttr;

    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInfSel.AttrTypBlock = ReadAttrBlock;

    ReadArg.pSel = &EntInfSel;
    ReadArg.pObject = Context->ObjectNameInDs;
    
    pCommArg = &(ReadArg.CommArg);
    BuildStdCommArg(pCommArg);

    RetCode = DirRead(&ReadArg, &pReadRes);

    if (NULL == pReadRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode, &pReadRes->CommRes); 
    }

    //
    // if no such attribute, fail silently
    // 

    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus)
    {
        NtStatus = STATUS_SUCCESS;
        goto CleanupAndReturn;
    }

    if ( !NT_SUCCESS(NtStatus) )
    {
        goto CleanupAndReturn;
    }

    pServerObjectDsName = (PDSNAME) pReadRes->entry.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal;



    //
    // modify the ServerObject RDN
    // 
    
    RDNAttr.attrTyp = ATT_COMMON_NAME;
    RDNAttr.AttrVal.valCount = 1;
    RDNAttr.AttrVal.pAVal = &RDNAttrVal;

    // Trim the dollar at the end of machine account name.
    if (L'$'==NewAccountName->Buffer[NewAccountName->Length/2-1])
    {
        RDNAttrVal.valLen = NewAccountName->Length - sizeof(WCHAR);
    }
    else
    {
        RDNAttrVal.valLen = NewAccountName->Length;
    }
    RDNAttrVal.pVal = (PUCHAR)NewAccountName->Buffer;

    memset( &ModDnArg, 0, sizeof(ModDnArg) );
    ModDnArg.pObject = pServerObjectDsName;
    ModDnArg.pNewRDN = &RDNAttr;
    pCommArg = &(ModDnArg.CommArg);
    BuildStdCommArg( pCommArg );

    RetCode = DirModifyDN( &ModDnArg, &pModDnRes );

    if (NULL == pModDnRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus( RetCode, &pModDnRes->CommRes);
    }


CleanupAndReturn:

    SampClearErrors();


    return( NtStatus );
}


NTSTATUS
SampChangeUserAccountName(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName,
    IN ULONG UserAccountControl,
    OUT PUNICODE_STRING OldAccountName
    )

/*++
Routine Description:

    This routine changes the account name of a user account.

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

Arguments:

    Context - Points to the User context whose name is to be changed.

    NewAccountName - New name to give this account

    UserAccountControl - The UserAccountControl for the user, used to exam
                         whether this account is a machine account or not.

    OldAccountName - old name is returned here. The buffer should be freed
                     by calling MIDL_user_free.

Return Value:


    STATUS_SUCCESS - The information has been retrieved.


    Other status values that may be returned by:

        SampGetUnicodeStringAttribute()
        SampSetUnicodeStringAttribute()
        SampValidateAccountNameChange()
        RtlAddActionToRXact()



--*/
{

    NTSTATUS        NtStatus;
    UNICODE_STRING  KeyName;

    SAMTRACE("SampChangeUserAccountName");


    //
    // The Krbtgt account is special. Cannot rename this account
    // as otherwise this is special
    //

    if (DOMAIN_USER_RID_KRBTGT==Context->TypeBody.User.Rid)
    {
        return (STATUS_SPECIAL_ACCOUNT);
    }

    /////////////////////////////////////////////////////////////
    // There are two copies of the name of each account.       //
    // one is under the DOMAIN\(domainName)\USER\NAMES key,    //
    // one is the value of the                                 //
    // DOMAIN\(DomainName)\USER\(rid)\NAME key                 //
    /////////////////////////////////////////////////////////////


    //
    // Get the current name so we can delete the old Name->Rid
    // mapping key.
    //

    NtStatus = SampGetUnicodeStringAttribute(
                   Context,
                   SAMP_USER_ACCOUNT_NAME,
                   TRUE, // Make copy
                   OldAccountName
                   );

    //
    // Make sure the name is valid and not already in use
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampValidateAccountNameChange(
                       Context,
                       NewAccountName,
                       OldAccountName,
                       SampUserObjectType
                       );

        if (!IsDsObject(Context))
        {

            //
            // Delete the old name key
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampBuildAccountKeyName(
                               SampUserObjectType,
                               &KeyName,
                               OldAccountName
                               );

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationDelete,
                                   &KeyName,
                                   0,
                                   NULL,
                                   0
                                   );
                    SampFreeUnicodeString( &KeyName );
                }

            }

            //
            //
            // Create the new Name->Rid mapping key
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampBuildAccountKeyName(
                               SampUserObjectType,
                               &KeyName,
                               NewAccountName
                               );

                if (NT_SUCCESS(NtStatus)) {

                    ULONG ObjectRid = Context->TypeBody.User.Rid;

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationSetValue,
                                   &KeyName,
                                   ObjectRid,
                                   (PVOID)NULL,
                                   0
                                   );

                    SampFreeUnicodeString( &KeyName );
                }
            }
        }
        else  // DS mode
        {
            //
            // If the user account is actually a machine account,
            // try to rename the RDN in DS
            //
            if (  (NT_SUCCESS(NtStatus)) &&
                  ((UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT) ||
                   (UserAccountControl & USER_SERVER_TRUST_ACCOUNT))  &&
                 !Context->LoopbackClient)
            {
                NtStatus = SampDsChangeAccountRDN(
                                                Context,
                                                NewAccountName
                                                );

                //
                // if the account is a Domain Controller, 
                // try to rename the RDN of the server object specified by 
                // the serverReferenceBL attribute of the machine account
                // 

                if (NT_SUCCESS(NtStatus) &&
                    (UserAccountControl & USER_SERVER_TRUST_ACCOUNT) &&
                    !Context->LoopbackClient)
                {
                    NtStatus = SampDsSyncServerObjectRDN(
                                                Context,
                                                NewAccountName
                                                );
                }
            }
        }

        //
        // replace the account's name
        //

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampSetUnicodeStringAttribute(
                           Context,
                           SAMP_USER_ACCOUNT_NAME,
                           NewAccountName
                           );
        }

        //
        // Free up the old account name if we failed
        //

        if (!NT_SUCCESS(NtStatus)) {

            SampFreeUnicodeString( OldAccountName );
            OldAccountName->Buffer = NULL;
        }

    }


    return(NtStatus);
}



USHORT
SampQueryBadPasswordCount(
    PSAMP_OBJECT UserContext,
    PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed
    )

/*++

Routine Description:

    This routine is used to retrieve the effective BadPasswordCount
    value of a user.

    When querying BadPasswordCount, some quick
    analysis has to be done.  If the last bad password
    was set more than LockoutObservationWindow time ago,
    then we re-set the BadPasswordCount.  Otherwise, we
    return the current value.


    NOTE: The V1aFixed data for the user object MUST be valid.
          This routine does not retrieve the data from disk.

Arguments:

    UserContext - Points to the object context block of the user whose
        bad password count is to be returned.

    V1aFixed - Points to a local copy of the user's V1aFixed data.


Return Value:


    The effective bad password count.


--*/
{

    SAMTRACE("SampQueryBadPasswordCount");

    if (SampStillInLockoutObservationWindow( UserContext, V1aFixed ) ) {
        return(V1aFixed->BadPasswordCount);
    }

    return(0);

}


BOOLEAN
SampStillInLockoutObservationWindow(
    PSAMP_OBJECT UserContext,
    PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed
    )
/*++

Routine Description:

    This routine returns a boolean indicating whether the provided user
    account context is within an account lockout window or not.

    An account lockout window is the time window starting at the
    last time a bad password was provided in a logon attempt
    (since the last valid logon) and extending for the duration of
    time specified in the LockoutObservationWindow field of the
    corresponding domain object.

    BY DEFINITION, a user account that has zero bad passwords, is
    NOT in an observation window.

    NOTE: The V1aFixed data for the both the user and corresponding
          domain objects MUST be valid.  This routine does NOT retrieve
          data from disk.

Arguments:

    UserContext - Points to the user object context block.

    V1aFixed - Points to a local copy of the user's V1aFixed data.


Return Value:


    TRUE - the user is in a lockout observation window.

    FALSE - the user is not in a lockout observation window.


--*/
{
    NTSTATUS
        NtStatus;

    LARGE_INTEGER
        WindowLength,
        LastBadPassword,
        CurrentTime,
        EndOfWindow;

    SAMTRACE("SampStillInLockoutObservationWindow");


    if (V1aFixed->BadPasswordCount == 0) {
        return(FALSE);
    }

    //
    // At least one bad password.
    // See if we are still in its observation window.
    //

    LastBadPassword = V1aFixed->LastBadPasswordTime;

    ASSERT( LastBadPassword.HighPart >= 0 );

    WindowLength =
        SampDefinedDomains[UserContext->DomainIndex].CurrentFixed.LockoutObservationWindow;
    ASSERT( WindowLength.HighPart <= 0 );  // Must be a delta time


    NtStatus = NtQuerySystemTime( &CurrentTime );
    ASSERT(NT_SUCCESS(NtStatus));

    //
    // See if current time is outside the observation window.
    // * you must subtract a delta time from an absolute time*
    // * to end up with a time in the future.                *
    //

    EndOfWindow = SampAddDeltaTime( LastBadPassword, WindowLength );

    return(CurrentTime.QuadPart <= EndOfWindow.QuadPart);

}


BOOLEAN
SampIncrementBadPasswordCount(
    IN PSAMP_OBJECT UserContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed,
    IN PUNICODE_STRING  MachineName  OPTIONAL
    )

/*++

Routine Description:

    This routine increments a user's bad password count.
    This may result in the account becoming locked out.
    It may also result in the BadPasswordCount being
    reduced (because we left one LockoutObservationWindow
    and had to start another).

    If (and only if) this call results in the user account
    transitioning from not locked out to locked out, a value
    of TRUE will be returned.  Otherwise, a value of FALSE is
    returned.


    NOTE: The V1aFixed data for the both the user and corresponding
          domain objects MUST be valid.  This routine does NOT retrieve
          data from disk.

Arguments:

    Context - Points to the user object context block.

    V1aFixed - Points to a local copy of the user's V1aFixed data.

    MachineName - a pointer to the client workstation making the call,
                  if available

Return Value:


    TRUE - the user became locked-out due to this call.

    FALSE - the user was either already locked-out, or did
        not become locked out due to this call.


--*/
{
    NTSTATUS
        NtStatus;


    BOOLEAN
        IsLocked,
        WasLocked;

    TIME_FIELDS
        T1;

    SAMTRACE("SampIncrementBadPasswordCount");


    //
    // Reset the locked out flag if necessary.
    // We might turn right around and set it again below,
    // but we need to know when we transition into a locked-out
    // state.  This is necessary to give us information we
    // need to do lockout auditing at some time.  Note that
    // the lockout flag itself is updated in a very lazy fashion,
    // and so its state may or may not be accurate at any point
    // in time.  You must call SampUpdateAccountLockoutFlag to
    // ensure it is up to date.
    //

    SampUpdateAccountLockedOutFlag( UserContext,
                                    V1aFixed,
                                    &WasLocked );

    //
    // If we are not in a lockout observation window, then
    // reset the bad password count.
    //

    if (!SampStillInLockoutObservationWindow( UserContext, V1aFixed )) {
        
        SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                       (SAMP_LOG_ACCOUNT_LOCKOUT,
                       "UserId: 0x%x IncrementBadPasswordCount: starting new observation window.\n", 
                       V1aFixed->UserId));
        V1aFixed->BadPasswordCount = 0; // Dirty flag will be set later
    }

    V1aFixed->BadPasswordCount++;

    SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                   (SAMP_LOG_ACCOUNT_LOCKOUT,
                   "UserId: 0x%x Incrementing bad password count to %d\n",
                   V1aFixed->UserId, V1aFixed->BadPasswordCount));

    NtStatus = NtQuerySystemTime( &V1aFixed->LastBadPasswordTime );
    ASSERT(NT_SUCCESS(NtStatus));

    RtlTimeToTimeFields(
                   &V1aFixed->LastBadPasswordTime,
                   &T1);

    if ( IsDsObject( UserContext ) )
    {
        USHORT Threshold;
        //
        // When we are a dc, we need to set the global LockoutTime when enough
        // bad passwords have been provided.
        //
        Threshold =
         SampDefinedDomains[UserContext->DomainIndex].CurrentFixed.LockoutThreshold;
                  
        //
        // Don't lockout machine accounts -- see Windows NT bug 434468
        //

        if (   (V1aFixed->BadPasswordCount >= Threshold)
            && (Threshold != 0)      // Zero is a special case threshold
            && !(V1aFixed->UserAccountControl & USER_MACHINE_ACCOUNT_MASK) )
        {
            //
            // account must be locked.
            //

            UserContext->TypeBody.User.LockoutTime = V1aFixed->LastBadPasswordTime;

            NtStatus = SampDsUpdateLockoutTime( UserContext );

            if ( !NT_SUCCESS( NtStatus ) )
            {
                UNICODE_STRING  StringDN;
                PUNICODE_STRING StringPointers = &StringDN;
                PSID            Sid = NULL;
                PWCHAR          Name = L"";

                //
                // Tell the admin we didn't lockout the account when we should
                // have
                //

                if (  UserContext->ObjectNameInDs->StringName )
                {
                    Name = UserContext->ObjectNameInDs->StringName;
                }
                RtlInitUnicodeString( &StringDN, Name );

                if ( UserContext->ObjectNameInDs->SidLen > 0 )
                {
                    Sid = &UserContext->ObjectNameInDs->Sid;
                }

                SampWriteEventLog(
                        EVENTLOG_ERROR_TYPE,
                        0,
                        SAMMSG_LOCKOUT_NOT_UPDATED,
                        Sid,
                        1,
                        sizeof( ULONG ),
                        &StringPointers,
                        &NtStatus
                        );

                NtStatus = STATUS_SUCCESS;

            }
        }
    }

    //
    // Update the state of the flag to reflect its new situation
    //


    SampUpdateAccountLockedOutFlag( UserContext,
                                    V1aFixed,
                                    &IsLocked );


    //
    // Now to return our completion value.
    // If the user was originally not locked, but now is locked
    // then we need to return TRUE to indicate a transition into
    // LOCKED occured.  Otherwise, return false to indicate we
    // did not transition into LOCKED (although we might have
    // transitioned out of LOCKED).
    //

    if (!WasLocked) {
        if (IsLocked) {
            //
            // Audit the event if necessary
            //
            {
                NTSTATUS       TempNtStatus;
                UNICODE_STRING TempMachineName, TempAccountName;

                if ( !SampDoAccountAuditing( UserContext->DomainIndex ) )
                {
                    goto AuditEnd;
                }

                TempNtStatus = SampGetUnicodeStringAttribute(
                                    UserContext,
                                    SAMP_USER_ACCOUNT_NAME,
                                    FALSE,    // Don't make copy
                                    &TempAccountName
                                    );

                if ( !NT_SUCCESS( TempNtStatus ) )
                {
                    goto AuditEnd;
                }


                if ( !MachineName )
                {
                    RtlInitUnicodeString( &TempMachineName, L"" );
                }
                else
                {
                    RtlCopyMemory( &TempMachineName,
                                   MachineName,
                                   sizeof(UNICODE_STRING) );
                }

                //
                // Finally, audit the event
                //
                SampAuditAnyEvent(
                    UserContext,
                    STATUS_SUCCESS,
                    SE_AUDITID_ACCOUNT_AUTO_LOCKED,     // AuditId
                    SampDefinedDomains[UserContext->DomainIndex].Sid,   // Domain SID
                    NULL,                               // Additional Info
                    NULL,                               // Member Rid (not used)
                    NULL,                               // Member Sid (not used)
                    &TempAccountName,                   // Account Name
                    &TempMachineName,                   // Machine name
                    &UserContext->TypeBody.User.Rid,    // Account Rid
                    NULL                                // Privileges used
                    );


            AuditEnd:

                NOTHING;

            }

            SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                           (SAMP_LOG_ACCOUNT_LOCKOUT,
                           "UserId: 0x%x Account locked out\n",
                            V1aFixed->UserId));

            return(TRUE);
        }
    }

    return(FALSE);
}




NTSTATUS
SampDsUpdateLockoutTime(
    IN PSAMP_OBJECT AccountContext
    )
{
    return SampDsUpdateLockoutTimeEx(AccountContext,
                                     TRUE
                                     );
}

NTSTATUS
SampDsUpdateLockoutTimeEx(
    IN PSAMP_OBJECT AccountContext,
    IN BOOLEAN      ReplicateUrgently
    )
/*++

Routine Description:

    This routine write the lockout time persistently.  If this dc is
    a primary, then the account control field is updated, too.

Arguments:

    Context - Points to the user object context block.

Return Value:

    A system service error

--*/
{
    NTSTATUS      NtStatus = STATUS_SUCCESS;
    ULONG         SamFlags = 0;
    LARGE_INTEGER LockoutTime = AccountContext->TypeBody.User.LockoutTime;

    ATTRTYP       LockoutAttrs[]={
                                    SAMP_FIXED_USER_LOCKOUT_TIME
                                 };

    ATTRVAL       LockoutValues[]={
                                    {sizeof(LockoutTime),(UCHAR *)&LockoutTime}
                                  };

    DEFINE_ATTRBLOCK1(LockoutAttrblock,LockoutAttrs,LockoutValues);

    SAMTRACE("SampDsUpdateLockoutTime");

    if (ReplicateUrgently) {
        SamFlags |= SAM_URGENT_REPLICATION;
    }


    //
    // Make the Ds call to directly set the attribute. Take into account,
    // lazy commit settings in the context
    //

    NtStatus = SampDsSetAttributes(
                    AccountContext->ObjectNameInDs,
                    SamFlags,
                    REPLACE_ATT,
                    SampUserObjectType,
                    &LockoutAttrblock
                    );

    return(NtStatus);
}


VOID
SampUpdateAccountLockedOutFlag(
    PSAMP_OBJECT Context,
    PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed,
    PBOOLEAN IsLocked
    )

/*++

Routine Description:

    This routine checks to see if a user's account should
    currently be locked out.  If it should, it turns on
    the AccountLockedOut flag.  If not, it turns the flag
    off.


Arguments:

    Context - Points to the user object context block.

    V1aFixed - Points to a local copy of the user's V1aFixed data.

    V1aFixedDirty - If any changes are made to V1aFixed, then
        V1aFixedDirty will be set to TRUE, otherwise V1aFixedDirty
        WILL NOT BE MODIFIED.

    IsState - Indicates whether the account is currently locked
        or unlocked.  A value of TRUE indicates the account is
        locked.  A value of false indicates the account is not
        locked.

Return Value:


    TRUE - the user's lockout status changed.

    FALSE - the user's lockout status did not change.


--*/
{
    NTSTATUS
        NtStatus = STATUS_SUCCESS;

    USHORT
        Threshold;

    LARGE_INTEGER
        CurrentTime,
        LastBadPassword,
        LockoutDuration,
        EndOfLockout,
        TimeZero,
        LockoutTime,
        PasswordMustChange,
        MaxPasswordAge;

    BOOLEAN
        BeyondLockoutDuration,
        WasLocked;

#if DBG

    LARGE_INTEGER
        TmpTime;

    TIME_FIELDS
        AT1, AT2, AT3, DT1;
#endif //DBG



    SAMTRACE("SampUpdateAccountLockedOutFlag");

    SampDiagPrint( DISPLAY_LOCKOUT,
                   ("SAM:  UpdateAccountLockedOutFlag:  \n"
                    "\tUser account 0x%lx\n",
                   V1aFixed->UserId));

    //
    // Init some well known quantities
    //
    GetSystemTimeAsFileTime( (FILETIME *)&CurrentTime );
    RtlZeroMemory( &TimeZero, sizeof( LARGE_INTEGER ) );

    Threshold =
     SampDefinedDomains[Context->DomainIndex].CurrentFixed.LockoutThreshold;

    LockoutDuration =
     SampDefinedDomains[Context->DomainIndex].CurrentFixed.LockoutDuration;

    MaxPasswordAge =
     SampDefinedDomains[Context->DomainIndex].CurrentFixed.MaxPasswordAge;

    WasLocked =
     V1aFixed->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED ? TRUE : FALSE;

    if ( IsDsObject(Context) )
    {
        //
        // In nt5, three situations can exist.
        //
        // 1) the LockoutTime is zero. To the best of our knowledge no
        //    other dc has determined that the account is locked.
        //
        // 2) the LockoutTime is non-zero and the delta between the current
        //    time and the LockoutTime is enough the user is not locked
        //    out any longer
        //
        // 3) else the LockoutTime is non-zero and the delta between the
        //    current time and the Lockout in NOT enough for the user
        //    to be free and the account remains locked.
        //

        //
        // Get some information
        //
        LockoutTime = Context->TypeBody.User.LockoutTime;

        EndOfLockout =
            SampAddDeltaTime( LockoutTime, LockoutDuration );

        BeyondLockoutDuration = CurrentTime.QuadPart > EndOfLockout.QuadPart;


        //
        // Now for some logic
        //

        if ( !SAMP_LOCKOUT_TIME_SET( Context ) )
        {

            SampDiagPrint( DISPLAY_LOCKOUT,
                           ("\tAccount is not locked out\n") );
            //
            // There is no lockout time
            //
            V1aFixed->UserAccountControl &= ~USER_ACCOUNT_AUTO_LOCKED;
            SampDiagPrint( DISPLAY_LOCKOUT,
                           ("\tLeaving account unlocked\n") );
        }
        else if ( BeyondLockoutDuration )
        {

            SampDiagPrint( DISPLAY_LOCKOUT,
                           ("\tAccount is locked out\n") );

            //
            // The user is now free
            //
            V1aFixed->UserAccountControl &= ~USER_ACCOUNT_AUTO_LOCKED;

            //
            // Don't reset the BadPasswordCount, LastBadPasswordTime
            // and Account LockedOutTime. Leave them as it is right now.
            // Let us change the value of BadPasswordCount (and so on) 
            // whenever client picks another BadPassword (either through
            // change password or logon).
            // 

        }
        else
        {
            //
            // Ok, we have a lockout time and we have not passed the duration
            // of the window
            //
            SampDiagPrint( DISPLAY_LOCKOUT,
                           ("\tAccount is locked out\n") );
            //
            // The account remains to be locked
            //
            V1aFixed->UserAccountControl |= USER_ACCOUNT_AUTO_LOCKED;

            SampDiagPrint( DISPLAY_LOCKOUT,
                           ("\tAccount still locked out\n") );

        }

    }
    else
    {
        //
        // Perform old style determination
        //
        if ((V1aFixed->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED) !=0) {

            //
            // Left locked out - do we need to unlock it?
            //

            LastBadPassword = V1aFixed->LastBadPasswordTime;
            LockoutDuration =
                SampDefinedDomains[Context->DomainIndex].CurrentFixed.LockoutDuration;

            EndOfLockout =
                SampAddDeltaTime( LastBadPassword, LockoutDuration );

            BeyondLockoutDuration = CurrentTime.QuadPart > EndOfLockout.QuadPart;

    #if DBG

            RtlTimeToTimeFields( &LastBadPassword,  &AT1);
            RtlTimeToTimeFields( &CurrentTime,      &AT2);
            RtlTimeToTimeFields( &EndOfLockout,     &AT3 );

            TmpTime.QuadPart = -LockoutDuration.QuadPart;
            RtlTimeToElapsedTimeFields( &TmpTime, &DT1 );

            SampDiagPrint( DISPLAY_LOCKOUT,
                           ("              Account previously locked.\n"
                            "              Current Time       : [0x%lx, 0x%lx] %d:%d:%d\n"
                            "              End of Lockout     : [0x%lx, 0x%lx] %d:%d:%d\n"
                            "              Lockout Duration   : [0x%lx, 0x%lx] %d:%d:%d\n"
                            "              LastBadPasswordTime: [0x%lx, 0x%lx] %d:%d:%d\n",
                            CurrentTime.HighPart, CurrentTime.LowPart, AT2.Hour, AT2.Minute, AT2.Second,
                            EndOfLockout.HighPart, EndOfLockout.LowPart, AT3.Hour, AT3.Minute, AT3.Second,
                            LockoutDuration.HighPart, LockoutDuration.LowPart, DT1.Hour, DT1.Minute, DT1.Second,
                            V1aFixed->LastBadPasswordTime.HighPart, V1aFixed->LastBadPasswordTime.LowPart,
                            AT1.Hour, AT1.Minute, AT1.Second)
                          );
    #endif //DBG

            if (BeyondLockoutDuration) {

                //
                // Unlock account
                //

                V1aFixed->UserAccountControl &= ~USER_ACCOUNT_AUTO_LOCKED;
                V1aFixed->BadPasswordCount = 0;


                SampDiagPrint( DISPLAY_LOCKOUT,
                               ("              ** unlocking account **\n") );
            } else {
                SampDiagPrint( DISPLAY_LOCKOUT,
                               ("              leaving account locked\n") );
            }

        } else {

            SampDiagPrint( DISPLAY_LOCKOUT,
                           ("              Account previously not locked.\n"
                            "              BadPasswordCount:  %ld\n",
                            V1aFixed->BadPasswordCount) );

            //
            // Left in a not locked state.  Do we need to lock it?
            //

            Threshold =
                SampDefinedDomains[Context->DomainIndex].CurrentFixed.LockoutThreshold;

            if (V1aFixed->BadPasswordCount >= Threshold &&
                Threshold != 0) {               // Zero is a special case threshold

                //
                // Left locked out - do we need to unlock it?
                //

                LastBadPassword = V1aFixed->LastBadPasswordTime;
                LockoutDuration =
                    SampDefinedDomains[Context->DomainIndex].CurrentFixed.LockoutDuration;

                EndOfLockout =
                    SampAddDeltaTime( LastBadPassword, LockoutDuration );

                BeyondLockoutDuration = CurrentTime.QuadPart > EndOfLockout.QuadPart;

                if (BeyondLockoutDuration) {

                    //
                    // account should not be locked out
                    //

                    V1aFixed->UserAccountControl &= ~USER_ACCOUNT_AUTO_LOCKED;
                    V1aFixed->BadPasswordCount = 0;

                    SampDiagPrint( DISPLAY_LOCKOUT,
                                   ("              ** leaving account unlocked **\n") );
                } else {

                    //
                    // account must be locked.
                    //

                    V1aFixed->UserAccountControl |= USER_ACCOUNT_AUTO_LOCKED;

                    SampDiagPrint( DISPLAY_LOCKOUT,
                                   ("              ** locking account **\n") );
                }


            } else {
                SampDiagPrint( DISPLAY_LOCKOUT,
                               ("              leaving account unlocked\n") );
            }
        }

    }

    //
    // Now return the state of the flag.
    //

    if ((V1aFixed->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED) !=0) {

        (*IsLocked) = TRUE;
    } else {
        (*IsLocked) = FALSE;
    }

    if (!*IsLocked && WasLocked && SampDoAccountAuditing(Context->DomainIndex))
    {
        NTSTATUS        TmpNtStatus = STATUS_SUCCESS;
        UNICODE_STRING  AccountName;
        PSAMP_DEFINED_DOMAINS   Domain = NULL;

        TmpNtStatus = SampGetUnicodeStringAttribute(
                            Context, 
                            SAMP_USER_ACCOUNT_NAME,
                            FALSE,      // Don't make copy
                            &AccountName
                            );

        if (NT_SUCCESS(TmpNtStatus))
        {
            Domain = &SampDefinedDomains[Context->DomainIndex];

            SampAuditAnyEvent(
                Context,
                STATUS_SUCCESS,                         
                SE_AUDITID_ACCOUNT_UNLOCKED,        // Audit ID
                Domain->Sid,                        // Domain SID
                NULL,                               // Additional Info
                NULL,                               // Member Rid (unused)
                NULL,                               // Member Sid (unused)
                &AccountName,                       // Account Name
                &Domain->ExternalName,              // Domain Name
                &Context->TypeBody.User.Rid,        // Account Rid
                NULL                                // Privilege
                );
        }

    }

    //
    // Password expired bit, is computed, cannot be set 
    // However, applications read and simply or in additional
    // user account control flags. Therefore silently mask out
    // that bit

    V1aFixed->UserAccountControl &= ~((ULONG) USER_PASSWORD_EXPIRED );
        
    //
    // Compute the Password expired bit
    //

    PasswordMustChange = SampGetPasswordMustChange(V1aFixed->UserAccountControl,
                                                   V1aFixed->PasswordLastSet,
                                                   MaxPasswordAge);    

    if (CurrentTime.QuadPart > PasswordMustChange.QuadPart)
    {
        V1aFixed->UserAccountControl |= USER_PASSWORD_EXPIRED;
    }

    return;
}


NTSTATUS
SampCheckForAccountLockout(
    IN PSAMP_OBJECT AccountContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed,
    IN BOOLEAN  V1aFixedRetrieved
    )
/*++
Routine Description:

    This routine checks whether this account is currently locked out or not. 
    
Paramenters:

    AccountContext - pointer to the object context
    
    V1aFixed - pointer to the Fixed Length attributes structure. 

    V1aFixedRetrieved - indicate whether V1aFixed is valid or not, if not
                        This routine should fill in the fixed attributes into
                        the passed in structure

Return Values:

    STATUS_ACCOUNT_LOCKED_OUT or STATUS_SUCCESS                            

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    //
    // Get fixed attributes if we are told to do so
    // 

    if (!V1aFixedRetrieved)
    {
        NtStatus = SampRetrieveUserV1aFixed(
                        AccountContext,
                        V1aFixed
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            return( NtStatus );
        }
    }

    //
    // Check for account lockout
    //

    if (V1aFixed->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED)
    {
        //
        // Account has been locked
        //

        NtStatus = STATUS_ACCOUNT_LOCKED_OUT;
    }

    return( NtStatus );
}



NTSTATUS
SampDsUpdateLastLogonTimeStamp(
    IN PSAMP_OBJECT AccountContext,
    IN LARGE_INTEGER LastLogon,
    IN ULONG SyncInterval
    )
/*++

Routine Description:

    This routine write the last logon time stamp persistently if necessary.

Arguments:

    Context - Points to the user object context block.

    LastLogon - New Last Logon Value

    SyncInterval - Update Interval (by days) for LastLogonTimeStamp attr

Return Value:

    A system service error

--*/
{
    NTSTATUS      NtStatus = STATUS_SUCCESS;
    LARGE_INTEGER LastLogonTimeStamp = LastLogon;
    LARGE_INTEGER EndOfLastLogonTimeStamp;
    ATTRTYP       LastLogonTimeStampAttrs[]={ SAMP_FIXED_USER_LAST_LOGON_TIMESTAMP };
    ATTRVAL       LastLogonTimeStampValues[]={ {sizeof(LastLogonTimeStamp),
                                                (UCHAR *)&LastLogonTimeStamp} };

    DEFINE_ATTRBLOCK1(LastLogonTimeStampAttrblock,LastLogonTimeStampAttrs,LastLogonTimeStampValues);

    SAMTRACE("SampDsUpdateLastLogonTimeStamp");


    //
    // no-op in registry mode
    // 

    if (!IsDsObject(AccountContext))
    {
        return( STATUS_SUCCESS );
    }

    //
    // Check whether LastLogonTimeStamp should be updated or not. 
    // 

    EndOfLastLogonTimeStamp = SampCalcEndOfLastLogonTimeStamp(
                                    AccountContext->TypeBody.User.LastLogonTimeStamp,
                                    SyncInterval
                                    );

    if (EndOfLastLogonTimeStamp.QuadPart > LastLogon.QuadPart)
    {
        return( STATUS_SUCCESS );
    }

    //
    // Make the Ds call to directly set the attribute. Take into account,
    // lazy commit settings in the context
    //

    NtStatus = SampDsSetAttributes(
                    AccountContext->ObjectNameInDs,
                    0,
                    REPLACE_ATT,
                    SampUserObjectType,
                    &LastLogonTimeStampAttrblock
                    );

    //
    // Update the in-memory copy
    // 
    if (NT_SUCCESS(NtStatus))
    {
        AccountContext->TypeBody.User.LastLogonTimeStamp = LastLogon;
    }

    return(NtStatus);
}


NTSTATUS
SampDsLookupObjectByAlternateId(
    IN PDSNAME DomainRoot,
    IN ULONG AttributeId,
    IN PUNICODE_STRING AlternateId,
    OUT PDSNAME *Object
    )

/*++

Routine Description:

    This routine assembles a DS attribute block based on the AlternateId
    value and searches the DS for a unique instance of the record, which
    is returned in the Object parameter.

    // BUG: Move this routine to dslayer.c after the technology preview.

Arguments:

    DomainRoot - Pointer, starting point (container) in the name space for
        the search.

    AlternateId - Pointer, unicode string containing the alternative user
        identifier.

    Object - Pointer, returned DS object matching the ID.

Return Value:

    STATUS_SUCCESS - Object was found, otherwise not found.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ATTR Attr;

    SAMTRACE("SampDsLookupObjectByAlternateId");

    RtlZeroMemory(&Attr, sizeof(ATTR));


    // Attr.attrTyp = SampDsAttrFromSamAttr(SampUnknownObjectType,
    //                                      ???);

    Attr.attrTyp = AttributeId;
    Attr.AttrVal.valCount = 1;

    // Perform lazy thread and transaction initialization.

    NtStatus = SampMaybeBeginDsTransaction(SampDsTransactionType);

    SampSetDsa(TRUE);

    Attr.AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));

    // BUG: Which release routine should be used for Attr.AttrVal.pAVal?

    if (NULL != Attr.AttrVal.pAVal)
    {

        //
        // Build a unicode string search attribute
        //

        Attr.AttrVal.pAVal->valLen = AlternateId->Length;
        Attr.AttrVal.pAVal->pVal = (PUCHAR)(AlternateId->Buffer);


        NtStatus = SampDsDoUniqueSearch(0, DomainRoot, &Attr, Object);

    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }

    // Turn the fDSA flag back on, as in loopback cases this can get reset
    // to FALSE.

    SampSetDsa(TRUE);

    return(NtStatus);
}

NTSTATUS
SamIOpenUserByAlternateId(
    IN SAMPR_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PUNICODE_STRING AlternateId,
    OUT SAMPR_HANDLE *UserHandle
    )

/*++

Routine Description:

    This routine returns a SAM handle to a user object based on its alter-
    nate security identifier.

Arguments:

    DomainHandle - Handle, open SAM domain context.

    DesiredAccess - Access level requested.

    AlternateId - Pointer, unicode string containing the alternative user
        identifier.

    UserHandle - Pointer, returned handle to an open SAM user object.

Return Value:

    STATUS_SUCCESS - Object was found and opened, otherwise it could not
        be found or opened. If failed, the UserHandle returned will have
        value zero (or what SamrOpenUser sets it to for failure).

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    PDSNAME DomainRoot = NULL;
    PDSNAME Object = NULL;
    ULONG UserRid = 0;

    SAMTRACE("SamIOpenUserByAlternateId");

    // Finds an account with AlternateId in the ALTERNATE_SECURITY_IDENTITIES,
    // returning a SAM handle good for calling SamrGetGroupsForUser()

    if ((NULL != DomainHandle) &&
        (NULL != AlternateId) &&
        (NULL != UserHandle))
    {
        PSAMP_OBJECT DomainContext = (PSAMP_OBJECT)DomainHandle;

        ASSERT(IsDsObject(DomainContext));

        DomainRoot = DomainContext->ObjectNameInDs;

        SampAcquireReadLock();

        if (NULL != DomainRoot)
        {
            NtStatus = SampDsLookupObjectByAlternateId(DomainRoot,
                                                       ATT_ALT_SECURITY_IDENTITIES,
                                                       AlternateId,
                                                       &Object);

            if (NT_SUCCESS(NtStatus))
            {
                ASSERT(NULL != Object);

                // Extract the user's Rid from the Sid.

                NtStatus = SampSplitSid(&(Object->Sid), NULL, &UserRid);

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = SamrOpenUser(DomainHandle,
                                            DesiredAccess,
                                            UserRid,
                                            UserHandle);
                }

                MIDL_user_free(Object);
            }
        }

        SampReleaseReadLock();
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}

NTSTATUS
SampFlagsToAccountControl(
    IN ULONG Flags,
    OUT PULONG UserAccountControl
    )
/*++

    Routine Description:

        Transalates from UF Values to User Account Control

    Parameters:

        Flags Specifies the UF Flags Value

        UserAccountControl - Specifies the User account control value

   Return Values:

        STATUS_SUCCESS
        STATUS_INVALID_PARAMETER
--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;

    *UserAccountControl=0;


    if (Flags & UF_ACCOUNTDISABLE) {
        (*UserAccountControl) |= USER_ACCOUNT_DISABLED;
    }

    if (Flags & UF_HOMEDIR_REQUIRED) {
        (*UserAccountControl) |= USER_HOME_DIRECTORY_REQUIRED;
    }

    if (Flags & UF_PASSWD_NOTREQD) {
        (*UserAccountControl) |= USER_PASSWORD_NOT_REQUIRED;
    }

    if (Flags & UF_DONT_EXPIRE_PASSWD) {
        (*UserAccountControl) |= USER_DONT_EXPIRE_PASSWORD;
    }

    if (Flags & UF_LOCKOUT) {
        (*UserAccountControl) |= USER_ACCOUNT_AUTO_LOCKED;
    }

    if (Flags & UF_MNS_LOGON_ACCOUNT) {
        (*UserAccountControl) |= USER_MNS_LOGON_ACCOUNT;
    }

     if (Flags & UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED) {
        (*UserAccountControl) |= USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED;
    }

    if (Flags & UF_SMARTCARD_REQUIRED) {
        (*UserAccountControl) |= USER_SMARTCARD_REQUIRED;
    }

    if (Flags & UF_TRUSTED_FOR_DELEGATION) {
        (*UserAccountControl) |= USER_TRUSTED_FOR_DELEGATION;
    }

    if (Flags & UF_NOT_DELEGATED) {
        (*UserAccountControl) |= USER_NOT_DELEGATED;
    }

    if (Flags & UF_USE_DES_KEY_ONLY) {
        (*UserAccountControl) |= USER_USE_DES_KEY_ONLY;
    }

    if (Flags & UF_DONT_REQUIRE_PREAUTH) {
        (*UserAccountControl) |= USER_DONT_REQUIRE_PREAUTH;
    }

    if (Flags & UF_PASSWORD_EXPIRED) {
        (*UserAccountControl) |= USER_PASSWORD_EXPIRED;
    }
    if (Flags & UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION) {
        (*UserAccountControl) |= USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION;
    }

    //
    // Set the account type bit.
    //
    // If no account type bit is set in user specified flag,
    //  then leave this bit as it is.
    //

    if( Flags & UF_ACCOUNT_TYPE_MASK )
    {
        ULONG NewSamAccountType;
        ULONG AccountMask;

        //
        // Check that exactly one bit is set
        //

        AccountMask = Flags & UF_ACCOUNT_TYPE_MASK;
        // Right Shift Till Account Mask's LSB is set
        while (0==(AccountMask & 0x1))
            AccountMask = AccountMask >>1;

        // If Exactly one bit is set then the value of
        // account mask is exactly one

        if (0x1!=AccountMask)
        {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Error;
        }

        //
        // Determine what the new account type should be.
        //

        if ( Flags & UF_TEMP_DUPLICATE_ACCOUNT ) {
            NewSamAccountType = USER_TEMP_DUPLICATE_ACCOUNT;

        } else if ( Flags & UF_NORMAL_ACCOUNT ) {
            NewSamAccountType = USER_NORMAL_ACCOUNT;

        } else if ( Flags & UF_INTERDOMAIN_TRUST_ACCOUNT){
            NewSamAccountType = USER_INTERDOMAIN_TRUST_ACCOUNT;

        } else if ( Flags & UF_WORKSTATION_TRUST_ACCOUNT){
            NewSamAccountType = USER_WORKSTATION_TRUST_ACCOUNT;

        } else if ( Flags & UF_SERVER_TRUST_ACCOUNT ) {
            NewSamAccountType = USER_SERVER_TRUST_ACCOUNT;

        } else {

            NtStatus = STATUS_INVALID_PARAMETER;
            goto Error;
        }

        //
        // Use the new Account Type.
        //

        (*UserAccountControl) |= NewSamAccountType;

    //
    //  If none of the bits are set,
    //      set USER_NORMAL_ACCOUNT.
    //
    }
    else
    {
        (*UserAccountControl) |= USER_NORMAL_ACCOUNT;
    }

Error:

    return NtStatus;

}

ULONG
SampAccountControlToFlags(
    IN ULONG UserAccountControl
    )
/*++

    Routine Description:

        Transalates from User Account control to UF Values

    Parameters:

        UserAccountControl Specifies the User account control value

   Return Values:

        UF Flags
--*/
{
    ULONG Flags=0;

    //
    // Set all other bits as a function of the SAM UserAccountControl
    //

    if ( UserAccountControl & USER_ACCOUNT_DISABLED ) {
        Flags |= UF_ACCOUNTDISABLE;
    }
    if ( UserAccountControl & USER_HOME_DIRECTORY_REQUIRED ){
        Flags |= UF_HOMEDIR_REQUIRED;
    }
    if ( UserAccountControl & USER_PASSWORD_NOT_REQUIRED ){
        Flags |= UF_PASSWD_NOTREQD;
    }
    if ( UserAccountControl & USER_DONT_EXPIRE_PASSWORD ){
        Flags |= UF_DONT_EXPIRE_PASSWD;
    }
    if ( UserAccountControl & USER_ACCOUNT_AUTO_LOCKED ){
        Flags |= UF_LOCKOUT;
    }
    if ( UserAccountControl & USER_MNS_LOGON_ACCOUNT ){
        Flags |= UF_MNS_LOGON_ACCOUNT;
    }
    if ( UserAccountControl & USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED ){
        Flags |= UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED;
    }
    if ( UserAccountControl & USER_SMARTCARD_REQUIRED ){
        Flags |= UF_SMARTCARD_REQUIRED;
    }
    if ( UserAccountControl & USER_TRUSTED_FOR_DELEGATION ){
        Flags |= UF_TRUSTED_FOR_DELEGATION;
    }
    if ( UserAccountControl & USER_NOT_DELEGATED ){
        Flags |= UF_NOT_DELEGATED;
    }
    if ( UserAccountControl & USER_USE_DES_KEY_ONLY ){
        Flags |= UF_USE_DES_KEY_ONLY;
    }
    if ( UserAccountControl & USER_DONT_REQUIRE_PREAUTH) {
        Flags |= UF_DONT_REQUIRE_PREAUTH;
    }
    if ( UserAccountControl & USER_PASSWORD_EXPIRED) {
        Flags |= UF_PASSWORD_EXPIRED;
    }
    if ( UserAccountControl & USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION) {
        Flags |= UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION;
    }

    //
    // set account type bit.
    //

    //
    // account type bit are exculsive and precisely only one
    // account type bit is set. So, as soon as an account type bit is set
    // in the following if sequence we can return.
    //


    if( UserAccountControl & USER_TEMP_DUPLICATE_ACCOUNT ) {
        Flags |= UF_TEMP_DUPLICATE_ACCOUNT;

    } else if( UserAccountControl & USER_NORMAL_ACCOUNT ) {
        Flags |= UF_NORMAL_ACCOUNT;

    } else if( UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT ) {
        Flags |= UF_INTERDOMAIN_TRUST_ACCOUNT;

    } else if( UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT ) {
        Flags |= UF_WORKSTATION_TRUST_ACCOUNT;

    } else if( UserAccountControl & USER_SERVER_TRUST_ACCOUNT ) {
        Flags |= UF_SERVER_TRUST_ACCOUNT;

    } else {
        //
        // There is no known account type bit set in UserAccountControl.
        // ?? Flags |= UF_NORMAL_ACCOUNT;

        ASSERT(FALSE && "No Account Type Flag set in User Account Control");
    }

    return Flags;
}

NTSTATUS
SampSyncLsaInterdomainTrustPassword(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING Password
    )
/*++

    This routine is a callout into SAM to interdomain trust account passwords, with TDO's maintained
    by the LSA. This architecture is not in use, therefore this callout has been stubbed

--*/
{

    return(STATUS_SUCCESS);

#if 0

    NTSTATUS NtStatus = STATUS_SUCCESS;
    PVOID   Fixed;
    SAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed;
    UNICODE_STRING OldPassword;
    UNICODE_STRING EncryptedOldPassword;

    //
    // Do not synchronize passwords in registry mode.
    //

    if (!IsDsObject(Context))
    {
        return (STATUS_SUCCESS);
    }

    NtStatus = SampGetFixedAttributes(Context,FALSE,&Fixed);
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    RtlMoveMemory(&V1aFixed,Fixed,sizeof(SAMP_V1_0A_FIXED_LENGTH_USER));

    if (USER_INTERDOMAIN_TRUST_ACCOUNT & V1aFixed.UserAccountControl)
    {
        UNICODE_STRING AccountName;

        //
        // Trust Account
        //

        NtStatus = SampGetUnicodeStringAttribute(
                        Context,
                        SAMP_USER_ACCOUNT_NAME,
                        FALSE, // Make Copy
                        &AccountName
                        );

        if (NT_SUCCESS(NtStatus))
        {
             NtStatus = SampGetUnicodeStringAttribute(
                            Context,
                            SAMP_USER_UNICODE_PWD,
                            FALSE, // Make Copy
                            &EncryptedOldPassword
                            );

             if (NT_SUCCESS(NtStatus))
             {
                 NtStatus = SampDecryptSecretData(
                                &OldPassword,
                                NtPassword,
                                &EncryptedOldPassword,
                                Context->TypeBody.User.Rid
                                );
             }
        }



        if (NT_SUCCESS(NtStatus))
        {
            SampMaybeBeginDsTransaction(TransactionWrite);

            NtStatus = LsaISamSetInterdomainTrustPassword(
                            &AccountName,
                            Password,
                            &OldPassword,
                            TRUST_AUTH_TYPE_NT4OWF,
                            LSAI_SAM_TRANSACTION_ACTIVE
                            );

            ASSERT(SampExistsDsTransaction());

            SampFreeUnicodeString(&OldPassword);
        }
    }

Error:
    return NtStatus;

#endif
}


NTSTATUS
SampEnforceDefaultMachinePassword(
    PSAMP_OBJECT AccountContext,
    PUNICODE_STRING NewPassword,
    PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo
    )
/*++

    This routine checks to see if the machine account's password
    is the same as the default machine account password. This routine
    references the current transaction domain.

    Parameters

        AccountContext -- Pointer to the SAM context
        NewPassword    -- points to the clear text password

    Return Values

        STATUS_SUCCESS
        STATUS_PASSWORD_RESTRICTION
--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    UNICODE_STRING AccountName;
    
    NtStatus = SampGetUnicodeStringAttribute(
                    AccountContext,
                    SAMP_USER_ACCOUNT_NAME,
                    FALSE, // Make Copy
                    &AccountName
                    );

    if (NT_SUCCESS(NtStatus))
    {
        //
        // The default machine password is same as the machine name minus the $ sign
        //

        AccountName.Length-=sizeof(WCHAR); // assume last char is the dollar sign

        if ((DomainPasswordInfo->PasswordProperties
                & DOMAIN_REFUSE_PASSWORD_CHANGE)
                && (!RtlEqualUnicodeString(&AccountName,NewPassword,TRUE)))
        {
            //
            // If refuse password change is set then disallow any machine
            // passwords other than default.
            //

            NtStatus = STATUS_PASSWORD_RESTRICTION;
        }
    }

    return NtStatus;
}




NTSTATUS
SamIGetInterdomainTrustAccountPasswordsForUpgrade(
   IN ULONG AccountRid,
   OUT PUCHAR NtOwfPassword,
   OUT BOOLEAN *NtPasswordPresent,
   OUT PUCHAR LmOwfPassword,
   OUT BOOLEAN *LmPasswordPresent
   )
/*++

    Routine Description

    This routine gets the NT and LM OWF passwords from the account
    with the specified RID during an NT4 upgrade. This routine can
    be called by inprocess clients only

    Parameters

    AccountRid  -- Specifies the RID of the account
    NtOwfPassword -- Buffer in which the NT owf password is returned
    NtPasswordPresent -- Boolean indicates that the NT password is present
    LmOwfPassword    -- Buffer in which the LM owf password is returned
    LmPasswordPresetn -- Indicates that the LM password is present

    Return Values

    STATUS_SUCCESS
    Other Error Codes

--*/
{
    NTSTATUS     NtStatus = STATUS_SUCCESS;
    PDSNAME      DomainDn=NULL;
    ULONG        Length = 0;
    PDSNAME      AccountDn= NULL;
    ATTRBLOCK    ResultAttrs;
    ATTRTYP      PasswdAttrs[]={
                                        SAMP_USER_UNICODE_PWD,
                                        SAMP_USER_DBCS_PWD
                                   };
    ATTRVAL      PasswdValues[]={ {0,NULL}, {0,NULL}};

    DEFINE_ATTRBLOCK2(PasswdAttrblock,PasswdAttrs,PasswdValues);
    ULONG        i;
    ULONG        CryptIndex = AccountRid;

    *NtPasswordPresent = FALSE;
    *LmPasswordPresent = FALSE;

    //
    // Get the root domain
    //

    NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                            &Length,
                            NULL
                            );


    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        SAMP_ALLOCA(DomainDn,Length );
        if (NULL!=DomainDn)
        {

            NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                            &Length,
                                            DomainDn
                                            );

            ASSERT(NT_SUCCESS(NtStatus));
        }
        else
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (!NT_SUCCESS(NtStatus))
        goto Error;



    //
    // Begin a transaction if required
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
        goto Error;



    //
    // Lookup the account by RID
    //

    NtStatus = SampDsLookupObjectByRid(
                    DomainDn,
                    AccountRid,
                    &AccountDn
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;


    //
    // Now read the account
    //

    NtStatus = SampDsRead(
                    AccountDn,
                    0,
                    SampUserObjectType,
                    &PasswdAttrblock,
                    &ResultAttrs
                    );

    if ( STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus ) {

        //
        // Neither passwords are present? Return, saying neither are
        // present
        //
        NtStatus = STATUS_SUCCESS;
        goto Error;
    }

    if (!NT_SUCCESS(NtStatus))
        goto Error;


    for (i=0;i<ResultAttrs.attrCount;i++)
    {
        if ((ResultAttrs.pAttr[i].attrTyp == SAMP_USER_UNICODE_PWD)
            && (1==ResultAttrs.pAttr[i].AttrVal.valCount)
            && (NT_OWF_PASSWORD_LENGTH==ResultAttrs.pAttr[i].AttrVal.pAVal[0].valLen))

        {
            *NtPasswordPresent = TRUE;
            NtStatus = RtlDecryptNtOwfPwdWithIndex(
                            (PENCRYPTED_NT_OWF_PASSWORD)ResultAttrs.pAttr[i].AttrVal.pAVal[0].pVal,
                             &CryptIndex,
                            (PNT_OWF_PASSWORD) NtOwfPassword
                            );
            if (!NT_SUCCESS(NtStatus))
                goto Error;
        }
        else  if ((ResultAttrs.pAttr[i].attrTyp == SAMP_USER_DBCS_PWD)
            && (1==ResultAttrs.pAttr[i].AttrVal.valCount)
            && (LM_OWF_PASSWORD_LENGTH==ResultAttrs.pAttr[i].AttrVal.pAVal[0].valLen))
        {
            *LmPasswordPresent = TRUE;
            NtStatus = RtlDecryptLmOwfPwdWithIndex(
                            (PENCRYPTED_LM_OWF_PASSWORD)ResultAttrs.pAttr[i].AttrVal.pAVal[0].pVal,
                             &CryptIndex,
                            (PLM_OWF_PASSWORD) LmOwfPassword
                            );
            if (!NT_SUCCESS(NtStatus))
                goto Error;


        }
    }


Error:

    //
    // Cleanup any existing transaction
    //

    if (NULL!=AccountDn)
        MIDL_user_free(AccountDn);

    SampMaybeEndDsTransaction(TransactionCommit);

    return(NtStatus);

}


NTSTATUS
SampStoreAdditionalDerivedCredentials(
    IN PDOMAIN_PASSWORD_INFORMATION DomainPasswordInfo,
    IN PSAMP_OBJECT UserContext,
    IN PUNICODE_STRING ClearPassword
    )
/*++

    Routine Description


    Given a pointer to the domain, the user context and the clear password,
    this routine saves the clear password in the supplemental credentials
    attribute and also compute the RFC1510 compliant DES key and store it
    into the supplemental credentials attribute. Any future additional credentials
    can be added to this routine in order to manage additional credential types


    Parameters

        Domain  -- Pointer to the domain to check policy etc
        UserContext -- Pointer to the user context
        ClearPassword -- Unicode string specifying the clear password


    Return Values

        STATUS_SUCCESS
        Other Error codes

--*/
{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    UNICODE_STRING          ClearTextPackageName;
    UNICODE_STRING          AccountName;
    SAMP_V1_0A_FIXED_LENGTH_USER   V1aFixed;

    PSAMP_NOTIFICATION_PACKAGE Package;
    UNICODE_STRING             CredentialName;
    
    RtlInitUnicodeString(&CredentialName, NULL);

    //
    // If we are in registry mode, simply return success
    //

    if (!IsDsObject(UserContext))
    {
        return(STATUS_SUCCESS);
    }


    //
    // Retrieve Fixed Attributes including user account control
    //

    NtStatus = SampRetrieveUserV1aFixed(
                    UserContext,
                    &V1aFixed
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Retrieve the account name
    //

    NtStatus = SampGetUnicodeStringAttribute(
                   UserContext,
                   SAMP_USER_ACCOUNT_NAME,
                   FALSE,    // Make copy
                   &AccountName
                   );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    //
    // Initialize package names for clear passwords and kerberos
    //
    RtlInitUnicodeString( &ClearTextPackageName,L"CLEARTEXT");

    //
    // If a clear password was passed in then add the clear password ( if required )
    // call out to packages so supplemental credentials can be updated.
    //

    if (ARGUMENT_PRESENT(ClearPassword))
    {

        //
        // Store the cleartext password, if required
        //

        if (((DomainPasswordInfo->PasswordProperties & DOMAIN_PASSWORD_STORE_CLEARTEXT) != 0)
            || (V1aFixed.UserAccountControl & USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED)){



            NtStatus = SampAddSupplementalCredentialsToList(
                            &UserContext->TypeBody.User.SupplementalCredentialsToWrite,
                            &ClearTextPackageName,
                            ClearPassword->Buffer,
                            ClearPassword->Length,
                            FALSE, // scan for conflict
                            FALSE // remove
                            );

            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }

        }

        //
        // Update packages external to SAM for supplemental credential updates
        //
        for (Package = SampNotificationPackages;
                Package != NULL;
                    Package = Package->Next )
        {

            PVOID NewCredentials = NULL;
            PVOID OldCredentials = NULL;
            ULONG NewCredentialSize = 0;
            ULONG OldCredentialSize = 0;

            //
            // If this package doesn't support credential update notifications,
            // goto the next package
            //
            if (NULL == Package->CredentialUpdateNotifyRoutine)
            {
                continue;
            }

            //
            // Prepare the credentials this package wants
            //
            CredentialName = Package->Parameters.CredentialUpdateNotify.CredentialName;

            ASSERT(CredentialName.Length > 0);
            ASSERT(CredentialName.Buffer != NULL);

            //
            // Get the credential value
            //
            NtStatus = SampRetrieveCredentials(
                            UserContext,
                            &CredentialName, // name of the package
                            TRUE, // Primary
                            &OldCredentials,
                            &OldCredentialSize
                            );

            if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
            {
                //
                // If the value were not present then simply ignore
                //
                NtStatus = STATUS_SUCCESS;
                OldCredentials = NULL;
                OldCredentialSize = 0;
            }

            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }

            //
            // Call the package
            //
            try
            {
                NtStatus = Package->CredentialUpdateNotifyRoutine(
                                    ClearPassword,
                                    OldCredentials,
                                    OldCredentialSize,
                                    V1aFixed.UserAccountControl,
                                    UserContext->TypeBody.User.UpnDefaulted?NULL:&UserContext->TypeBody.User.UPN,
                                    &AccountName,
                                    &(SampDefinedDomains[UserContext->DomainIndex].ExternalName ),
                                    &(SampDefinedDomains[UserContext->DomainIndex].DnsDomainName),
                                    &NewCredentials,
                                    &NewCredentialSize);

            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "Exception thrown in Credential UpdateRoutine: 0x%x (%d)\n",
                           GetExceptionCode(),
                           GetExceptionCode()));

                NtStatus = STATUS_ACCESS_VIOLATION;
            }

            //
            // Free the old credentials
            //
            if (OldCredentials) {
                RtlZeroMemory(OldCredentials, OldCredentialSize);
                MIDL_user_free(OldCredentials);
                OldCredentials = NULL;
            }

            //
            // Add the new values
            //
            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampAddSupplementalCredentialsToList(
                                &UserContext->TypeBody.User.SupplementalCredentialsToWrite,
                                &CredentialName,
                                NewCredentials,
                                NewCredentialSize,
                                FALSE, // scan for conflict
                                FALSE // remove
                                );

                //
                // Free the memory from the package, if necessary
                //
                if (NewCredentials) {
                    try {
                        Package->CredentialUpdateFreeRoutine(NewCredentials);
                    } except(EXCEPTION_EXECUTE_HANDLER) {
                        KdPrintEx((DPFLTR_SAMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "Exception thrown in Credential Free Routine: 0x%x (%d)\n",
                                   GetExceptionCode(),
                                   GetExceptionCode()));
                        ;
                    }
                    NewCredentials = NULL;
                }

                if (!NT_SUCCESS(NtStatus))
                {
                    goto Error;
                }

            } 
            else
            {
                PUNICODE_STRING StringPointers[2];
                //
                // Package should not have allocated anything
                //
                ASSERT(NULL == NewCredentials);

                StringPointers[0] = &Package->PackageName;
                StringPointers[1] = &AccountName;

                //
                // The package failed the update. Log a message and continue
                //
                // N.B. The old value will still be removed from the user
                //
                SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                                  0, // no category
                                  SAMMSG_CREDENTIAL_UPDATE_PKG_FAILED,
                                  NULL,  // no user id necessary
                                  sizeof(StringPointers)/sizeof(StringPointers[0]),
                                  sizeof(NTSTATUS),
                                  StringPointers,
                                  &NtStatus);

                NtStatus = STATUS_SUCCESS;
            }


        } // for all packages

    } // if clear text password

    //
    // Remove the existing clear text password, no op if password did not exist.
    // Note AddSupplementalCredential always adds to the front of the list. Therefore
    // the order of the add and remove are reversed.
    //
    NtStatus = SampAddSupplementalCredentialsToList(
                        &UserContext->TypeBody.User.SupplementalCredentialsToWrite,
                        &ClearTextPackageName,
                        NULL,
                        0,
                        FALSE,
                        TRUE
                        );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Remove the old values of all other supplemental credentials
    //
    for (Package = SampNotificationPackages;
            Package != NULL;
                Package = Package->Next )
    {
        //
        // If this package doesn't support credential update notifications,
        // goto the next package
        //
        if (NULL == Package->CredentialUpdateNotifyRoutine)
        {
            continue;
        }

        CredentialName = Package->Parameters.CredentialUpdateNotify.CredentialName;
        ASSERT(CredentialName.Length > 0);
        ASSERT(CredentialName.Buffer != NULL);
        NtStatus = SampAddSupplementalCredentialsToList(
                        &UserContext->TypeBody.User.SupplementalCredentialsToWrite,
                        &CredentialName,
                        NULL,
                        0,
                        FALSE, // scan for conflict
                        TRUE // remove
                        );
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }
    }

Error:
    
    return(NtStatus);
}



NTSTATUS
SamIUpdateLogonStatistics(
    IN SAM_HANDLE UserHandle,
    IN PSAM_LOGON_STATISTICS LogonStats
    )
/*++

Routine Description:

    This routine updates the logon statistics for a user after a logon request.
    The logon request could have either failed or succeeded.

Parameters:

    UserHandle - the handle of an opened user to operate on.
    
    LogonStats - the result of the logon attempt

Return Values:

    STATUS_SUCCESS, resource error otherwise

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT AccountContext = (PSAMP_OBJECT) UserHandle;
    SAMP_OBJECT_TYPE    FoundType;
    SAMP_V1_0A_FIXED_LENGTH_USER  V1aFixed;
    ULONG RemainingFlags;
    ULONG ObjectRid;
    BOOLEAN AccountLockedOut = FALSE;
    BOOLEAN ReplicateImmediately = FALSE;

    BOOLEAN fReferencedContext = FALSE;
    BOOLEAN fLockAcquired      = FALSE;
    BOOLEAN TellNetlogon       = FALSE;
    BOOLEAN FlushOnlyLogonProperties = FALSE;

#if DBG

    TIME_FIELDS
        T1;

#endif //DBG

    RtlZeroMemory(&V1aFixed, sizeof(V1aFixed));

    //
    // Parameter check
    //
    if ( (AccountContext == NULL) ||
         (LogonStats == NULL) ) {

        return STATUS_INVALID_PARAMETER;
    }
    ASSERT(AccountContext->TrustedClient);

    //
    // Acquire the lock, if necessary
    //
    if (   !AccountContext->NotSharedByMultiThreads 
        || !IsDsObject(AccountContext) ) {

        NtStatus = SampMaybeAcquireWriteLock(AccountContext, &fLockAcquired);
        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }

        //
        // Perform a lookup context, for non thread safe context's
        //
        NtStatus = SampLookupContext(
                        AccountContext,
                        0,                      // No access necessary
                        SampUserObjectType,     // ExpectedType
                        &FoundType
                        );
        if (!NT_SUCCESS(NtStatus)) {
            goto Cleanup;
        }
        ASSERT(FoundType == SampUserObjectType);
        fReferencedContext = TRUE;

    } else {

        //
        // For a thread safe context, writing just logon
        // statistics , just reference the context
        //
        SampReferenceContext(AccountContext);
        fReferencedContext = TRUE;
    }
    ASSERT(NT_SUCCESS(NtStatus));

    //
    // Extract the fixed attributes for analysis
    //
    NtStatus = SampRetrieveUserV1aFixed(
                   AccountContext,
                   &V1aFixed
                   );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Attach the client info, to the context
    //
    AccountContext->TypeBody.User.ClientInfo = LogonStats->ClientInfo;


    //
    // Extract the RID
    //
    ObjectRid = AccountContext->TypeBody.User.Rid;

    //
    // There are two ways to set logon/logoff statistics:
    //
    //      1) Directly, specifying each one being set,
    //      2) Implicitly, specifying the action to
    //         represent
    //
    // These two forms are mutually exclusive.  That is,
    // you can't specify both a direct action and an
    // implicit action.  In fact, you can't specify two
    // implicit actions either.
    //

    if (LogonStats->StatisticsToApply
        & USER_LOGON_INTER_SUCCESS_LOGON) {

        RemainingFlags = LogonStats->StatisticsToApply
                         & ~(USER_LOGON_INTER_SUCCESS_LOGON|USER_LOGON_NO_WRITE);

        //
        // We allow the remaining flags to be 0,
        // USER_LOGON_TYPE_KERBEROS, or USER_LOGON_TYPE_NTLM
        //

        if ( ( 0 == RemainingFlags ) ||
             ( USER_LOGON_TYPE_KERBEROS == RemainingFlags ) ||
             ( USER_LOGON_TYPE_NTLM == RemainingFlags ) ) {


            //
            // Set BadPasswordCount = 0
            // Increment LogonCount
            // Set LastLogon = NOW
            // Reset the locked out time
            //
            //

            if (V1aFixed.BadPasswordCount != 0) {

                SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                               (SAMP_LOG_ACCOUNT_LOCKOUT,
                               "UserId: 0x%x Successful interactive logon, clearing badPwdCount\n",
                                V1aFixed.UserId));
            }

            V1aFixed.BadPasswordCount = 0;
            if (V1aFixed.LogonCount != 0xFFFF) {
                V1aFixed.LogonCount += 1;
            }
            NtQuerySystemTime( &V1aFixed.LastLogon );

            if ( IsDsObject( AccountContext ) )
            {
                if ( SAMP_LOCKOUT_TIME_SET( AccountContext ) )
                {
                    RtlZeroMemory( &AccountContext->TypeBody.User.LockoutTime, sizeof( LARGE_INTEGER ) );

                    NtStatus = SampDsUpdateLockoutTime( AccountContext );
                    if ( !NT_SUCCESS( NtStatus ) )
                    {
                        goto Cleanup;
                    }

                    SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                                   (SAMP_LOG_ACCOUNT_LOCKOUT,
                                   "UserId: 0x%x Successful interactive logon, unlocking account\n",
                                    V1aFixed.UserId));
                }
            }

            FlushOnlyLogonProperties=TRUE;

        } else {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    if (LogonStats->StatisticsToApply
        & USER_LOGON_INTER_SUCCESS_LOGOFF) {
        if ( (LogonStats->StatisticsToApply
                 & ~USER_LOGON_INTER_SUCCESS_LOGOFF)  != 0 ) {

            NtStatus = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        } else {

            //
            // Set LastLogoff time
            // Decrement LogonCount (don't let it become negative)
            //

            if (V1aFixed.LogonCount != 0) {
                V1aFixed.LogonCount -= 1;
            }
            NtQuerySystemTime( &V1aFixed.LastLogoff );
            FlushOnlyLogonProperties=TRUE;
        }
    }

    if (LogonStats->StatisticsToApply
        & USER_LOGON_NET_SUCCESS_LOGON) {

        RemainingFlags = LogonStats->StatisticsToApply
                         & ~(USER_LOGON_NET_SUCCESS_LOGON|USER_LOGON_NO_WRITE);

        //
        // We allow the remaining flags to be 0,
        // USER_LOGON_TYPE_KERBEROS, or USER_LOGON_TYPE_NTLM
        //

        if ( ( 0 == RemainingFlags ) ||
             ( USER_LOGON_TYPE_KERBEROS == RemainingFlags ) ||
             ( USER_LOGON_TYPE_NTLM == RemainingFlags ) ) {


            //
            // Set BadPasswordCount = 0
            // Set LastLogon = NOW
            // Clear the locked time
            //
            //
            //
            if (V1aFixed.BadPasswordCount != 0) {

                SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                               (SAMP_LOG_ACCOUNT_LOCKOUT,
                               "UserId: 0x%x Successful network logon, clearing badPwdCount\n",
                                V1aFixed.UserId));
            }

            V1aFixed.BadPasswordCount = 0;
            NtQuerySystemTime( &V1aFixed.LastLogon );

            if ( IsDsObject( AccountContext ) )
            {
                if ( SAMP_LOCKOUT_TIME_SET( AccountContext ) )
                {
                    RtlZeroMemory( &AccountContext->TypeBody.User.LockoutTime, sizeof( LARGE_INTEGER ) );
                    NtStatus = SampDsUpdateLockoutTime( AccountContext );
                    if ( !NT_SUCCESS( NtStatus ) )
                    {
                        goto Cleanup;
                    }

                    SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                                   (SAMP_LOG_ACCOUNT_LOCKOUT,
                                    "UserId: 0x%x Successful network logon, unlocking account\n",
                                    V1aFixed.UserId));
                }
            }

             FlushOnlyLogonProperties=TRUE;
        } else {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    if (LogonStats->StatisticsToApply
        & USER_LOGON_NET_SUCCESS_LOGOFF) {
        if ( (LogonStats->StatisticsToApply
                 & ~USER_LOGON_NET_SUCCESS_LOGOFF)  != 0 ) {

            NtStatus = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        } else {

            //
            // Set LastLogoff time
            //

            NtQuerySystemTime( &V1aFixed.LastLogoff );
            FlushOnlyLogonProperties=TRUE;
        }
    }

    if (LogonStats->StatisticsToApply
        & USER_LOGON_BAD_PASSWORD) {

        PUNICODE_STRING TempMachineName = NULL;

        RemainingFlags = LogonStats->StatisticsToApply
                            & ~(USER_LOGON_BAD_PASSWORD|USER_LOGON_BAD_PASSWORD_WKSTA|USER_LOGON_NO_WRITE);

        //
        // We allow the remaining flags to be 0,
        // USER_LOGON_TYPE_KERBEROS, or USER_LOGON_TYPE_NTLM
        //

        if ( ( 0 == RemainingFlags ) ||
             ( USER_LOGON_TYPE_KERBEROS == RemainingFlags ) ||
             ( USER_LOGON_TYPE_NTLM == RemainingFlags ) ) {


            //
            // Increment BadPasswordCount
            // (might lockout account)
            //

            //
            // Get the wksta name if provided
            //
            if ((LogonStats->StatisticsToApply & USER_LOGON_BAD_PASSWORD_WKSTA) != 0) {
                TempMachineName = &LogonStats->Workstation;
            }

            AccountLockedOut =
                SampIncrementBadPasswordCount(
                    AccountContext,
                    &V1aFixed,
                    TempMachineName
                    );

            //
            // If the account has been locked out,
            //  ensure the BDCs in the domain are told.
            //

            if ( AccountLockedOut ) {
                TellNetlogon = TRUE;
                ReplicateImmediately = TRUE;
            }
        } else {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    if (  LogonStats->StatisticsToApply
        & USER_LOGON_STAT_LAST_LOGON ) {

        LogonStats->LastLogon = V1aFixed.LastLogon;
    }

    if (  LogonStats->StatisticsToApply
        & USER_LOGON_STAT_LAST_LOGOFF ) {

        LogonStats->LastLogoff = V1aFixed.LastLogoff;
    }

    if (  LogonStats->StatisticsToApply
        & USER_LOGON_STAT_BAD_PWD_COUNT ) {

        SAMP_PRINT_LOG( SAMP_LOG_ACCOUNT_LOCKOUT,
                       (SAMP_LOG_ACCOUNT_LOCKOUT,
                       "UserId: 0x%x Setting BadPasswordCount %d\n",
                        V1aFixed.UserId,
                        LogonStats->BadPasswordCount));

        V1aFixed.BadPasswordCount =
            LogonStats->BadPasswordCount;
    }

    if (  LogonStats->StatisticsToApply
        & USER_LOGON_STAT_LOGON_COUNT ) {

        V1aFixed.LogonCount = LogonStats->LogonCount;
    }


    //
    // Write the changes
    //

    if ((FlushOnlyLogonProperties)
            && (IsDsObject(AccountContext)))
    {
        //
        // If it is the DS case and we are only doing a successful
        // logon or logoff, just flush the last logon, last logoff,
        // logon count and bad password count properties. Note the
        // value in the on disk structure in AccountContext will now
        // be stale, but SetInformationUser is the last operation
        // during a logon. Therefore it should not matter.
        //
        NtStatus = SampDsSuccessfulLogonSet(
                        AccountContext,
                        LogonStats->StatisticsToApply,
                        SampDefinedDomains[AccountContext->DomainIndex].LastLogonTimeStampSyncInterval,
                        &V1aFixed
                        );
    }
    else if (IsDsObject(AccountContext))
    {
        //
        // Set the bad password count and bad password time. Note the
        // value in the on disk structure in AccountContext will now
        // be stale, but SetInformationUser is the last operation
        // during a logon. Therefore it should not matter.
        //

        //
        // This path also updates the site affinity if no GC
        // is present.
        //
        NtStatus = SampDsFailedLogonSet(
                        AccountContext,
                        LogonStats->StatisticsToApply,
                        &V1aFixed
                        );
    }
    else
    {
        //
        // Registry Mode, set the entire V1aFixed Structure
        //

        NtStatus = SampReplaceUserV1aFixed(
                        AccountContext,
                        &V1aFixed
                        );
    }

    //
    // That's it -- fall through the Cleanup
    //

Cleanup:

    //
    // Release the context
    //
    if (fReferencedContext) {

        NTSTATUS Status2;
        Status2 = SampDeReferenceContext( AccountContext, NT_SUCCESS(NtStatus) );
        if (!NT_SUCCESS(Status2) && NT_SUCCESS(NtStatus)) {
            NtStatus = Status2;
        }

    } else {

        ASSERT(!NT_SUCCESS(NtStatus) && "No context referenced");
    }

    //
    // Commit the changes 
    //
    if (fLockAcquired) {

        if (NT_SUCCESS(NtStatus)) {

            if (( !TellNetlogon ) && (!IsDsObject(AccountContext))) {

                 //
                 // For logon statistics, we don't notify netlogon about changes
                 // to the database.  Which means that we don't want the
                 // domain's modified count to increase.  The commit routine
                 // will increase it automatically if this isn't a BDC, so we'll
                 // decrement it here.
                 //

                 if (SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ServerRole != DomainServerRoleBackup) {

                     SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ModifiedCount.QuadPart =
                         SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ModifiedCount.QuadPart-1;
                     SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber.QuadPart =
                         SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber.QuadPart-1;
                 }
            }

            NtStatus = SampCommitAndRetainWriteLock();

            if ( NT_SUCCESS(NtStatus) ) {

                //
                // Something in the account was changed.  Notify netlogon about
                // everything except logon statistics changes.
                //

                if ( TellNetlogon ) {

                    SAM_DELTA_DATA DeltaData;
                    SECURITY_DB_DELTA_TYPE  DeltaType = SecurityDbChange;

                    DeltaData.AccountControl = V1aFixed.UserAccountControl;

                    SampNotifyNetlogonOfDelta(
                        DeltaType,
                        SecurityDbObjectSamUser,
                        ObjectRid,
                        (PUNICODE_STRING) NULL,
                        (DWORD) ReplicateImmediately,
                        &DeltaData // Delta data
                        );
                }
            }
        }

         //
         // Release the lock
         //

         IgnoreStatus = SampReleaseWriteLock( FALSE );
         ASSERT(NT_SUCCESS(IgnoreStatus));

     } else {

         //
         // Commit for the thread safe context case
         //
         ASSERT(IsDsObject(AccountContext));
         if (NT_SUCCESS(NtStatus)) {

            SampMaybeEndDsTransaction(TransactionCommit);
         } else {

            SampMaybeEndDsTransaction(TransactionAbort);
         }
     }

    return NtStatus;
}

VOID
SampGetRequestedAttributesForUser(
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN ULONG WhichFields,
    OUT PRTL_BITMAP AttributeAccessTable
    )
/*++

Routine Description:

    This routine sets in AttributeAccessTable the requested attributes 
    determined by both the UserInformationClass or the WhichFields, if any.

Parameters:

    UserInformationClass -- the information level
    
    WhichFields -- which fields of the UserAllInformation are requested
    
    AttributeAccessTable -- a bitmask of attributes

Return Values:

    None.

--*/
{
    ULONG LocalWhichFields = 0;

    switch (UserInformationClass) {

    case UserPreferencesInformation:

        LocalWhichFields |= USER_ALL_USERCOMMENT |
                            USER_ALL_COUNTRYCODE |
                            USER_ALL_CODEPAGE;
        break;

    case UserParametersInformation:

        LocalWhichFields |= USER_ALL_PARAMETERS;
        break;

    case UserLogonHoursInformation:

        LocalWhichFields |= USER_ALL_LOGONHOURS;
        break;

    case UserNameInformation:

        LocalWhichFields |= USER_ALL_USERNAME | USER_ALL_FULLNAME;
        break;

    case UserAccountNameInformation:

        LocalWhichFields |= USER_ALL_USERNAME;
        break;

    case UserFullNameInformation:

        LocalWhichFields |= USER_ALL_FULLNAME;
        break;

    case UserPrimaryGroupInformation:

        LocalWhichFields |= USER_ALL_PRIMARYGROUPID;
        break;

    case UserHomeInformation:

        LocalWhichFields |=  USER_ALL_HOMEDIRECTORY | USER_ALL_HOMEDIRECTORYDRIVE;
        break;

    case UserScriptInformation:

        LocalWhichFields |= USER_ALL_SCRIPTPATH;
        break;

    case UserProfileInformation:

        LocalWhichFields |= USER_ALL_PROFILEPATH;
        break;

    case UserAdminCommentInformation:

        LocalWhichFields |= USER_ALL_ADMINCOMMENT;
        break;

    case UserWorkStationsInformation:

        LocalWhichFields |= USER_ALL_WORKSTATIONS;
        break;
    case UserControlInformation:

        LocalWhichFields |= USER_ALL_USERACCOUNTCONTROL;
        break;

    case UserExpiresInformation:
        LocalWhichFields |= USER_ALL_ACCOUNTEXPIRES;
        break;
    
    default:
        //
        // Extract whatever fields were passed in
        //
        LocalWhichFields |= (WhichFields & USER_ALL_WRITE_ACCOUNT_MASK) |
                            (WhichFields & USER_ALL_WRITE_PREFERENCES_MASK);
    }

    SampSetAttributeAccessWithWhichFields(LocalWhichFields,
                                          AttributeAccessTable);

    return;
}


NTSTATUS
SampValidatePresentAndStoredCombination(
    IN BOOLEAN NtPresent,
    IN BOOLEAN LmPresent,
    IN BOOLEAN StoredNtPasswordPresent,
    IN BOOLEAN StoredNtPasswordNonNull,
    IN BOOLEAN StoredLmPasswordNonNull
    )
/*++

Routine Description:

    This routine determines if the combination of passed in values
    and stored values are allowed.
    
    Thoery:  There are 32 different combinations of the above variables.  The
    following aren't interesting:

        if (!NtPresent
         && !LmPresent  )
         // invalid parameters from client

        if (!StoredNtPasswordPresent
         && StoredNtPasswordNonNull  )
         // can't have a non-NULL password and not be present
        
        if ( StoredNtPasswordPresent
         && !StoredNtPasswordNonNull
         &&  StoredLmPasswordNonNull   )
         // can't have a non-NULL LM password, but a present NT NULL password

This leaves 15 remaining cases -- see implementation for details.
    
Parameters:

    NtPresent -- the caller presented an NT OWF of the password
    
    LmPresent -- the caller presented an LM OWF of the password
    
    StoredNtPasswordPresent -- the NT OWF of the password is stored
    
    StoredNtPasswordNonNull -- the account's password is non NULL
    
    StoredLmPasswordNonNull -- the account's password is non NULL or
                               the LM OWF is not stored.
                                          
Return Values:

    STATUS_SUCCESS
    
    STATUS_NT_CROSS_ENCRYPTION_REQUIRED -- the password necessary to validate
                                           the change is not sufficient.    
                             
--*/
{

    //
    // Assert for the uninteresting cases first
    //
    ASSERT(  NtPresent 
          || LmPresent);

    ASSERT(StoredNtPasswordPresent 
       || !StoredNtPasswordNonNull);

    ASSERT( !StoredNtPasswordPresent 
         ||  StoredNtPasswordNonNull 
         || !StoredLmPasswordNonNull);

    //
    // Now for the interesting cases
    //

    if (!NtPresent
     &&  LmPresent
     &&  StoredNtPasswordPresent
     && StoredNtPasswordNonNull   
     && !StoredLmPasswordNonNull  ) {

        // We have a non-NULL password, the LM password is NULL, and 
        // only the LM is given.  This is not enough information.
        return STATUS_NT_CROSS_ENCRYPTION_REQUIRED;
    }

    if ( NtPresent
     && !LmPresent
     && !StoredNtPasswordPresent
     && StoredLmPasswordNonNull ) {

        // We have a non-NULL LM password, but only the NT is provided.
        // This is not enough information.
        return STATUS_NT_CROSS_ENCRYPTION_REQUIRED;
    }

    return STATUS_SUCCESS;

}

NTSTATUS
SampCopyA2D2Attribute(
    IN PUSER_ALLOWED_TO_DELEGATE_TO_LIST Src,
    OUT PUSER_ALLOWED_TO_DELEGATE_TO_LIST *Dest
    )
{
    ULONG i;

    *Dest = MIDL_user_allocate(Src->Size);
    if (NULL==*Dest)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Copy the data
    //

    RtlCopyMemory(*Dest,Src,Src->Size);

  
    //
    // Fixup the pointers
    //

    for (i=0;i<(*Dest)->NumSPNs;i++)
    {
       ULONG_PTR Offset = (ULONG_PTR) Src->SPNList[i].Buffer - (ULONG_PTR)Src;

       (ULONG_PTR) (*Dest)->SPNList[i].Buffer = (ULONG_PTR) (*Dest)+Offset;
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
SampRandomizeKrbtgtPassword(
    IN PSAMP_OBJECT        AccountContext,
    IN OUT PUNICODE_STRING ClearTextPassword,
    IN BOOLEAN FreeOldPassword,
    OUT BOOLEAN *FreeRandomizedPassword
    )
/*++

   This routine checks if the account context describes 
   a user context for the krbtgt account and if so then
   computes a new random clear password

   Parameters:

    AccountContext -- Context to the account
    ClearTextPassword -- If it is the krbtgt account then 
                         the password is altered in here
    FreeOldPassword -- boolean out parameter .. indicates that
                       the old password needs to be freed.
    FreeRandomizedPassword -- Indicates that memory was alloc'd
                       for the randomized password that needs
                       to be freed.
*/
{

    *FreeRandomizedPassword = FALSE;

    if (AccountContext->TypeBody.User.Rid == DOMAIN_USER_RID_KRBTGT)
    {
        //
        // This is the krbtgt account
        //

        if ((FreeOldPassword) && (NULL!=ClearTextPassword->Buffer))
        {
            RtlZeroMemory(ClearTextPassword->Buffer,ClearTextPassword->Length);
            MIDL_user_free(ClearTextPassword->Buffer);
            RtlZeroMemory(ClearTextPassword,sizeof(UNICODE_STRING));
        }

        ClearTextPassword->Buffer = MIDL_user_allocate(
                    (SAMP_RANDOM_GENERATED_PASSWORD_LENGTH +1 )*sizeof(WCHAR));
        if (NULL==ClearTextPassword->Buffer)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        *FreeRandomizedPassword = TRUE;

        SampGenerateRandomPassword(
            ClearTextPassword->Buffer,
            SAMP_RANDOM_GENERATED_PASSWORD_LENGTH+1
            );
        ClearTextPassword->Length = SAMP_RANDOM_GENERATED_PASSWORD_LENGTH*sizeof(WCHAR);
        ClearTextPassword->MaximumLength = ClearTextPassword->Length+ sizeof(WCHAR);
    }

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\usrparms.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    usrparms.c

Abstract:

    This file contains services which convert SAM user object's UserParameters 
    Attribute to a DSATTRBLOCK structure. 
    The steps involved: 
        1. call each notification package to get client-specified SAM_USERPARMS_ATTRBLOCK,
        2. convert SAM_USERPARMS_ATTRBLOCK to DSATTRBLOCK

Author:

    Shaohua Yin      (ShaoYin)    15-August-1998

Environment:

    User Mode - Win32

Revision History:


--*/



#include <samsrvp.h>
#include <attids.h>
#include <nlrepl.h>
#include <dbgutilp.h>
#include <dsutilp.h>
#include <mappings.h>
#include "notify.h"



ULONG   InvalidDsAttributeTable[] =
{
    DS_ATTRIBUTE_UNKNOWN,
    ATT_SAM_ACCOUNT_NAME
};


// extern from credman.cxx
NTSTATUS
SampConvertCredentialsToAttr(
    IN PSAMP_OBJECT Context OPTIONAL,
    IN ULONG Flags,
    IN ULONG ObjectRid,
    IN PSAMP_SUPPLEMENTAL_CRED SupplementalCredentials,
    OUT ATTR * CredentialAttr 
    );
    
    
    
    
//////////////////////////////////////////////////////////////
//                                                          //
// Private service routines                                 // 
//                                                          //
//////////////////////////////////////////////////////////////

NTSTATUS 
SampUserParmsAttrBlockHealthCheck(
    IN PSAM_USERPARMS_ATTRBLOCK  AttrBlock
    )
    
/*++

Routine Dsscription:

    This routine will do the health check on AttrBlock, including: all Attribute is valid, 
    EncryptedAttribute's AttributeIdentifier is valid. 
    
Arguments:

    AttrBlock - pointer to SAM_USERPARMS_ATTRBLOCK structure
    
Return Values:

    STATUS_SUCCESS - AttrBlock is valid.
    
    STATUS_INVALID_PARAMETER - invalid AttrBlock.

--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       Index, i;
    ULONG       DsAttrId;
    
    
    SAMTRACE("SampUserParmsAttrBlockHealthCheck");
    
    ASSERT(AttrBlock);
    
    if (NULL == AttrBlock)
    {
        return NtStatus;
    }
    
    if (AttrBlock->attCount)
    {
        if (NULL == AttrBlock->UserParmsAttr)
        {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto HealthCheckError;
        }
    }
    
    for (Index = 0; Index < AttrBlock->attCount; Index++ )
    {
        if (Syntax_Attribute == AttrBlock->UserParmsAttr[Index].Syntax)
        {
            DsAttrId = SampGetDsAttrIdByName(AttrBlock->UserParmsAttr[Index].AttributeIdentifier);
        
            for (i = 0; i < ARRAY_COUNT(InvalidDsAttributeTable); i++)
            {
                if (DsAttrId == InvalidDsAttributeTable[i])
                {
                    NtStatus = STATUS_INVALID_PARAMETER;
                    goto HealthCheckError;
                }
            }
        }
        else 
        {
            ASSERT(Syntax_EncryptedAttribute == AttrBlock->UserParmsAttr[Index].Syntax);
            
            if (0 == AttrBlock->UserParmsAttr[Index].AttributeIdentifier.Length ||
                NULL == AttrBlock->UserParmsAttr[Index].AttributeIdentifier.Buffer ||
                1 < AttrBlock->UserParmsAttr[Index].CountOfValues)
            {
                NtStatus = STATUS_INVALID_PARAMETER;
                goto HealthCheckError;
            }
        }
    }
        
HealthCheckError:

    return NtStatus;
        
}



NTSTATUS
SampScanAttrBlockForConflict(
    IN PDSATTRBLOCK DsAttrBlock,
    IN PDSATTRBLOCK UserParmsAttrBlock
    )
    
/*++
    
Routine Description:

    This routine checks two DSATTRBLOCK structures, search for any conflict - duplicate set operation 

Arguments:
    
    DsAttrBlock - Pointer, to DSATTRBLOCK 
    
    UserParmsAttrBlock - Pointer, to DSATTRBLOCK

Return Values:

    NtStatus
    
--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG UserParmsIndex, DsIndex;
    
    
    SAMTRACE("SampScanAttrBlockForConflict");
    
    if ((NULL == DsAttrBlock) || (NULL == UserParmsAttrBlock))
    {
        return NtStatus;
    }

    for (UserParmsIndex = 0; UserParmsIndex < UserParmsAttrBlock->attrCount; UserParmsIndex++)
    {
        for (DsIndex = 0; DsIndex < DsAttrBlock->attrCount; DsIndex++)
        {
            if (UserParmsAttrBlock->pAttr[UserParmsIndex].attrTyp == DsAttrBlock->pAttr[DsIndex].attrTyp)
            {
                // conflict
                NtStatus = STATUS_INVALID_PARAMETER;
                return NtStatus;
            }
        }
    }
    
    return NtStatus;
}




VOID
SampFreeSupplementalCredentialList(
    IN PSAMP_SUPPLEMENTAL_CRED SupplementalCredentialList
    )
    
/*++

Routine Description:
    
    This routine releases the link-list which contains all supplemental credentials.

Arguments: 

    SupplementalCredentialsList - Pointer, to the link-list

Return Values: 

    None.

--*/

{
    ULONG     Index;   
    PSAMP_SUPPLEMENTAL_CRED TmpCredential = NULL;
    PSAMP_SUPPLEMENTAL_CRED NextCredential = NULL;
    
    SAMTRACE("SampFreeSupplementalCredentialList");
   
    TmpCredential = SupplementalCredentialList;
    
    while (TmpCredential)
    {
        NextCredential = TmpCredential->Next;    

        RtlFreeUnicodeString(&(TmpCredential->SupplementalCred.PackageName));
        
        if (TmpCredential->SupplementalCred.Credentials)
        {
            MIDL_user_free(TmpCredential->SupplementalCred.Credentials);
        }
        
        MIDL_user_free(TmpCredential);
        
        TmpCredential = NextCredential;
    }
    
    return;
}


NTSTATUS
SampAddSupplementalCredentialsToList(
    IN OUT PSAMP_SUPPLEMENTAL_CRED *SupplementalCredentialList,
    IN PUNICODE_STRING PackageName,
    IN PVOID           CredentialData,
    IN ULONG           CredentialLength,
    IN BOOLEAN         ScanForConflicts,
    IN BOOLEAN         Remove
    )
/*++

    Routine Description

    This routine adds a supplemental credential specified by package name and data
    to the list of supplemental credentials

    Arguments

    SupplementalCredentialList -- doubly linked list of supplemental credentials
    PackageName                -- Name of the package
    CredentialData             -- Pointer to the data in the supplemental credential
    CredentialLength           -- Length of the credential Data

    Return Values

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_SUPPLEMENTAL_CRED TmpList = *SupplementalCredentialList;
    PSAMP_SUPPLEMENTAL_CRED NewItem=NULL;

    //
    // First scan the list for conflicts
    //

    while ((NULL != TmpList) && (ScanForConflicts))
    {
        if ( RtlEqualUnicodeString(&(TmpList->SupplementalCred.PackageName),
                                   PackageName,
                                   TRUE   // Case Insensitive
                                   ))
        {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Error;
        }

        TmpList = TmpList->Next;
    }
        

    //
    // Allocate space for a new item in the list
    //

    NewItem = MIDL_user_allocate( sizeof(SAMP_SUPPLEMENTAL_CRED) );
    if ( NULL == NewItem )
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }
    
    RtlZeroMemory(NewItem, sizeof(SAMP_SUPPLEMENTAL_CRED));


    //
    // Copy the package name
    //
     
    if (!RtlCreateUnicodeString(&(NewItem->SupplementalCred.PackageName),
                           PackageName->Buffer)
       )
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }
    
    if (Remove)
    {
        NewItem->Remove = Remove;
    }
    else
    {

        //
        // Set the length
        //

        NewItem->SupplementalCred.CredentialSize = CredentialLength;
    

        //
        // Allocate space and copy over the credentials if the length is non zero.
        //

        if (CredentialLength)
        {
            NewItem->SupplementalCred.Credentials = MIDL_user_allocate( CredentialLength ); 
   
            if (NULL == NewItem->SupplementalCred.Credentials)
            {
                NtStatus = STATUS_NO_MEMORY;
                goto Error;
            }
        
            RtlZeroMemory(NewItem->SupplementalCred.Credentials, CredentialLength);
                     
            RtlCopyMemory(NewItem->SupplementalCred.Credentials, 
                          CredentialData,
                          CredentialLength
                          );
        }
    }
                        
    //
    // Insert in front of the list
    //

    NewItem->Next = *SupplementalCredentialList;
    (*SupplementalCredentialList) = NewItem;

Error:

    if ((!NT_SUCCESS(NtStatus)) && (NULL!=NewItem))
    {
        //
        // Error'd out in the middle, ensure that new item is completely freed
        //

        SampFreeSupplementalCredentialList(NewItem);
    }

    return(NtStatus);
}

NTSTATUS
SampMergeDsAttrBlocks(
    IN PDSATTRBLOCK FirstAttrBlock,
    IN PDSATTRBLOCK SecondAttrBlock,
    OUT PDSATTRBLOCK * AttrBlock
    )
    
/*++

Routine Description:
    
    This routine will concatenate FirstAttrBlock and SecondAttrBlock.  
    return AttrBlock as concatenated result.

Arguments: 

    FirstAttrBlock - Pointer, the DSATTRBLOCK containing partial attributes.
    
    SecondAttrBlock - Pointer, the DSATTRBLOCK containing partial attributes.
    
    AttrBlock - Pointer, the DSATTRBLOCK containing all attributes from FirstAttrBlock and 
                SecondAttrBlock, 
                if routine success, AttrBlock will hold the concatenated attributes block.
                and release memory which is occupied by FirstAttrBlock and SecondAttrBlock.
                if routine Failure, nothing changed.
                  
Return Values: 

    STATUS_SUCCESS - AttrBlock hold the concatenated result, FirstAttrBlock and SecondAttrBlock
                     have been freed. 
                     
    STATUS_NO_MEMORY - the only error case, AttrBlock = NULL, nothing changed.

--*/

{
    NTSTATUS     NtStatus = STATUS_SUCCESS;
    ULONG        firstIndex, secIndex, Index;
    ULONG        AttrCount;
    
    
    SAMTRACE("SampMergeDsAttrBlocks");
    
    // 
    // caller must pass us at least one attribute block
    // 
    ASSERT(NULL != FirstAttrBlock || NULL != SecondAttrBlock);
    
    if (NULL == FirstAttrBlock)
    {
        *AttrBlock = SecondAttrBlock;
        return NtStatus;
    }
    
    if (NULL == SecondAttrBlock)
    {
        *AttrBlock = FirstAttrBlock;
        return NtStatus;
    }
    
    *AttrBlock = MIDL_user_allocate( sizeof(DSATTRBLOCK) );
                                   
    if (NULL == *AttrBlock)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto MergeAttrBlockError;
    }
    
    RtlZeroMemory(*AttrBlock, sizeof(DSATTRBLOCK));
    
    AttrCount = FirstAttrBlock->attrCount + SecondAttrBlock->attrCount;    
    
    (*AttrBlock)->attrCount = AttrCount;
    (*AttrBlock)->pAttr = MIDL_user_allocate( AttrCount * sizeof(DSATTR) );
                                          
    if (NULL == (*AttrBlock)->pAttr)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto MergeAttrBlockError;
    }
                 
    RtlZeroMemory((*AttrBlock)->pAttr, (AttrCount * sizeof(DSATTR)));                 
    
    Index = 0;
     
    for (firstIndex = 0; firstIndex < FirstAttrBlock->attrCount; firstIndex++)
    {
        (*AttrBlock)->pAttr[Index].attrTyp = 
                        FirstAttrBlock->pAttr[firstIndex].attrTyp;
                        
        (*AttrBlock)->pAttr[Index].AttrVal.valCount =
                        FirstAttrBlock->pAttr[firstIndex].AttrVal.valCount;
                        
        (*AttrBlock)->pAttr[Index].AttrVal.pAVal = 
                        FirstAttrBlock->pAttr[firstIndex].AttrVal.pAVal;
                        
        Index++;
    }
    
    for (secIndex = 0; secIndex < SecondAttrBlock->attrCount; secIndex++)
    {
        (*AttrBlock)->pAttr[Index].attrTyp = 
                        SecondAttrBlock->pAttr[secIndex].attrTyp;
                        
        (*AttrBlock)->pAttr[Index].AttrVal.valCount =
                        SecondAttrBlock->pAttr[secIndex].AttrVal.valCount;
                        
        (*AttrBlock)->pAttr[Index].AttrVal.pAVal = 
                        SecondAttrBlock->pAttr[secIndex].AttrVal.pAVal;
                        
        Index++;
    }
    
    ASSERT(Index == AttrCount);
    
    if (FirstAttrBlock->pAttr)
    {
        MIDL_user_free(FirstAttrBlock->pAttr);
    }
    if (SecondAttrBlock->pAttr)
    {
        MIDL_user_free(SecondAttrBlock->pAttr);
    }
    MIDL_user_free(FirstAttrBlock);
    MIDL_user_free(SecondAttrBlock);
    
    
    return NtStatus;
    
    
MergeAttrBlockError:

    
    if (*AttrBlock)
    {
        if ((*AttrBlock)->pAttr)
        {
            MIDL_user_free((*AttrBlock)->pAttr);
            (*AttrBlock)->pAttr = NULL;
        }
        
        MIDL_user_free(*AttrBlock);
        *AttrBlock = NULL;
    }
    
    return NtStatus;
    
}




NTSTATUS
SampAppendAttrToAttrBlock(
    IN ATTR CredentialAttr,
    IN OUT PDSATTRBLOCK * DsAttrBlock
    )

/*++

Routine Description:

    This routine will append the CredentialAttr at the end of DsAttrBlock. 
    Actually, what we do is: create a new DsAttrBlock, copy the old attribute block and 
    add the CredentialAttr.

Arguments:

    CredentialAttr - hold the credential attribute to set.
    
    DsAttrBlock - pointer to the old DS attribute block which need to be appended. 
                  also used to return the new DS attribute block.
                  
                  it could point to NULL when passed in.

Return Values:

    STATUS_SUCCESS
    
    STATUS_NO_MEMORY

--*/

{
    NTSTATUS     NtStatus = STATUS_SUCCESS;
    PDSATTRBLOCK TmpAttrBlock = NULL;
    ULONG        AttrCount;
    
    SAMTRACE("SampAppendAttrToAttrBlock");
    
    TmpAttrBlock = MIDL_user_allocate( sizeof(DSATTRBLOCK) );
                                   
    if (NULL == TmpAttrBlock)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto AppendError;
    }
    
    RtlZeroMemory(TmpAttrBlock, sizeof(DSATTRBLOCK));
    
    AttrCount = 1;          // for the append attribute
    
    if (*DsAttrBlock)
    {
        AttrCount += (*DsAttrBlock)->attrCount;
    }
    
    TmpAttrBlock->attrCount = AttrCount;
    TmpAttrBlock->pAttr = MIDL_user_allocate( AttrCount * sizeof(DSATTR) );
                                          
    if (NULL == TmpAttrBlock->pAttr)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto AppendError;
    }
    
    RtlZeroMemory(TmpAttrBlock->pAttr, AttrCount * sizeof(DSATTR));
    
    if (*DsAttrBlock)
    {
        RtlCopyMemory(TmpAttrBlock->pAttr, 
                      (*DsAttrBlock)->pAttr, 
                      (*DsAttrBlock)->attrCount * sizeof(DSATTR)
                      );
    }
                  
    TmpAttrBlock->pAttr[AttrCount - 1].attrTyp = CredentialAttr.attrTyp;
    TmpAttrBlock->pAttr[AttrCount - 1].AttrVal.valCount = CredentialAttr.AttrVal.valCount;
    TmpAttrBlock->pAttr[AttrCount - 1].AttrVal.pAVal = CredentialAttr.AttrVal.pAVal;
    
    if (*DsAttrBlock)
    {
        if ((*DsAttrBlock)->pAttr)
        {
            MIDL_user_free((*DsAttrBlock)->pAttr);
            (*DsAttrBlock)->pAttr = NULL;
        }
        
        MIDL_user_free(*DsAttrBlock);
    }
    
    *DsAttrBlock = TmpAttrBlock;
    
    
AppendFinish:

    return NtStatus;    


AppendError:

    if (TmpAttrBlock)
    {
        if (TmpAttrBlock->pAttr)
        {
            MIDL_user_free(TmpAttrBlock->pAttr);
        }
        
        MIDL_user_free(TmpAttrBlock);
    }
    
    goto AppendFinish;
}





NTSTATUS
SampConvertUserParmsAttrBlockToDsAttrBlock(
    IN PSAM_USERPARMS_ATTRBLOCK UserParmsAttrBlock,
    OUT PDSATTRBLOCK * DsAttrBlock,
    IN OUT PSAMP_SUPPLEMENTAL_CRED * SupplementalCredentials
    )

/*++

Routine Description:
    
    This routine will scan a SAM_USERPARMS_ATTRBLOCK, converts that structure to 
    DSATTRBLOCK structure, and put and EncrypedAttribute in SAM_USERPARMS_ATTRBLOCK
    into the SupplementalCredentials link-list

Arguments:
    
    UserParmsAttrBlock - pointer to a PSAM_USERPARMS_ATTRBLOCK structure.
    
    DsAttrBlock - return a DSATTRBLOCK, which is converted from UserParmsAttrBlock
    
    SupplementalCredentials - link list, hold all EncrypedAttributes

Return Values:

    STATUS_SUCCESS - this routine finished successfully, 
    
    STATUS_NO_MEMROY - no resoures.
    
    STATUS_INVALID_PARAMETERS - duplicate credential identifier, means duplicate
                                supplemental credential tag (package name) 

--*/

{
    
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PDSATTR  Attributes = NULL;
    ULONG    AttrCount;
    ULONG    Index, valIndex, dsAttrIndex;
    ULONG    size; 
    ULONG    CredSize;
    
    
    SAMTRACE("SampConvertUserParmsAttrBlockToDsAttrBlock");
    
    
    ASSERT(UserParmsAttrBlock);
    
     
    //
    // calculate the Attribute Count exclude Encrypted Attributes;
    //
    AttrCount = UserParmsAttrBlock->attCount;
    
    for (Index = 0; Index < UserParmsAttrBlock->attCount; Index++)
    {
        if (Syntax_EncryptedAttribute == UserParmsAttrBlock->UserParmsAttr[Index].Syntax)
        {
            AttrCount--;
        }
    }
    
    //
    // Allocate Memory for DSATTRBLOCK structure; if AttrCount > 0
    //    
    if (0 < AttrCount)
    {
        *DsAttrBlock = MIDL_user_allocate( sizeof(DSATTRBLOCK) ); 
    
        if (NULL == *DsAttrBlock)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto ConvertUserParmsAttrBlockError;
        }
    
        RtlZeroMemory(*DsAttrBlock, sizeof(DSATTRBLOCK));
    
        Attributes = MIDL_user_allocate( AttrCount * sizeof(DSATTR) );
    
        if (NULL == Attributes)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto ConvertUserParmsAttrBlockError;
        }
        
        RtlZeroMemory(Attributes, AttrCount * sizeof(DSATTR));
    
        (*DsAttrBlock)->attrCount = AttrCount;
        (*DsAttrBlock)->pAttr = Attributes; 
    }
    
    // 
    // Fill the DSATTRBLOCK structure or add an Encrypted Attribute to the beginning of 
    // the Supplemental Credential List.
    //
    dsAttrIndex = 0;
    
    for ( Index = 0; Index < UserParmsAttrBlock->attCount; Index++)
    {
        ULONG   valCount = UserParmsAttrBlock->UserParmsAttr[Index].CountOfValues;

        if (Syntax_Attribute == UserParmsAttrBlock->UserParmsAttr[Index].Syntax)
        {
            // 
            // fill a new attribute to DsAttrBlock
            //
            
            // get the DS Attribute type (ID)
            Attributes[dsAttrIndex].attrTyp = 
                        SampGetDsAttrIdByName(UserParmsAttrBlock->UserParmsAttr[Index].AttributeIdentifier);
                                                   
            if ((1 == valCount) &&
                (0 == UserParmsAttrBlock->UserParmsAttr[Index].Values[0].length) &&
                (NULL == UserParmsAttrBlock->UserParmsAttr[Index].Values[0].value))
            {
                valCount = 0;
            }
                                                   
            Attributes[dsAttrIndex].AttrVal.valCount = valCount;

            if (0 == valCount)
            {
                Attributes[dsAttrIndex].AttrVal.pAVal = NULL;
            }
            else
            {
                Attributes[dsAttrIndex].AttrVal.pAVal = MIDL_user_allocate(
                                                            valCount * sizeof (DSATTRVAL)
                                                            );

                if (NULL == Attributes[dsAttrIndex].AttrVal.pAVal)
                {
                    NtStatus = STATUS_NO_MEMORY;
                    goto ConvertUserParmsAttrBlockError;
                }
            
                RtlZeroMemory(Attributes[dsAttrIndex].AttrVal.pAVal, 
                              valCount * sizeof(DSATTRVAL)
                              );
            }
            
            for (valIndex = 0; valIndex < valCount; valIndex++)
            {
                Attributes[dsAttrIndex].AttrVal.pAVal[valIndex].valLen =
                        UserParmsAttrBlock->UserParmsAttr[Index].Values[valIndex].length;
                        
                if (Attributes[dsAttrIndex].AttrVal.pAVal[valIndex].valLen) 
                {
                    Attributes[dsAttrIndex].AttrVal.pAVal[valIndex].pVal = MIDL_user_allocate( 
                                                                                 Attributes[dsAttrIndex].AttrVal.pAVal[valIndex].valLen
                                                                                 );
                                                                     
                    if (NULL == Attributes[dsAttrIndex].AttrVal.pAVal[valIndex].pVal)
                    {
                        NtStatus = STATUS_NO_MEMORY;
                        goto ConvertUserParmsAttrBlockError;
                    }
                
                    RtlZeroMemory(Attributes[dsAttrIndex].AttrVal.pAVal[valIndex].pVal,
                                  Attributes[dsAttrIndex].AttrVal.pAVal[valIndex].valLen
                                  );
                              
                    RtlCopyMemory(Attributes[dsAttrIndex].AttrVal.pAVal[valIndex].pVal,
                                  UserParmsAttrBlock->UserParmsAttr[Index].Values[valIndex].value,
                                  UserParmsAttrBlock->UserParmsAttr[Index].Values[valIndex].length
                                  );
                }
            }
            dsAttrIndex++;
        }
        else 
        {
            ASSERT(Syntax_EncryptedAttribute == UserParmsAttrBlock->UserParmsAttr[Index].Syntax);
            
            //
            // Create a linked list of supplemental credentials
            //
            
            if (1 == valCount)
            {
                NtStatus = SampAddSupplementalCredentialsToList(
                                SupplementalCredentials,
                                &(UserParmsAttrBlock->UserParmsAttr[Index].AttributeIdentifier),
                                UserParmsAttrBlock->UserParmsAttr[Index].Values[0].value,
                                UserParmsAttrBlock->UserParmsAttr[Index].Values[0].length,
                                TRUE, // scan for conflicts
                                FALSE // remove
                                );
            }
            else if (0 == valCount)
            {
                // this is a deletion

                NtStatus = SampAddSupplementalCredentialsToList(
                                SupplementalCredentials,
                                &(UserParmsAttrBlock->UserParmsAttr[Index].AttributeIdentifier),
                                NULL,       // value
                                0,          // value length
                                TRUE,       // scan for conflicts
                                FALSE       // remove
                                );
            }
            else
            {
                ASSERT(FALSE && "invalid parameter");
                NtStatus = STATUS_INVALID_PARAMETER;
            }

            if (!NT_SUCCESS(NtStatus))
            {
                 goto ConvertUserParmsAttrBlockError;
            }            
        }
             
    }
    
    ASSERT(dsAttrIndex == AttrCount);
    
ConvertUserParmsAttrBlockFinish:
    
    return NtStatus;
        
    
ConvertUserParmsAttrBlockError:

    if (*DsAttrBlock)
    {
        SampFreeAttributeBlock(*DsAttrBlock);
        *DsAttrBlock = NULL;
    }
    
    goto ConvertUserParmsAttrBlockFinish;

}



NTSTATUS
SampConvertUserParmsToDsAttrBlock(
    IN PSAMP_OBJECT Context OPTIONAL,
    IN ULONG Flags,
    IN PSID  DomainSid,
    IN ULONG ObjectRid,
    IN ULONG UserParmsLengthOrig,
    IN PVOID UserParmsOrig,
    IN ULONG UserParmsLengthNew, 
    IN PVOID UserParmsNew, 
    IN PDSATTRBLOCK InAttrBlock,
    OUT PDSATTRBLOCK * OutAttrBlock
    )

/*++

Routine Description:

    This routine passes the User Parameters to Notification Package, convert the 
    User Parms to Attributes Block.
    
Arguments: 
    
    Context   - Pointer to SAM user object's context block.
    
    Flags     - Indicate we are in Upgrade process or down-lever SAM API.
                by setting SAM_USERPARMS_DURING_UPGRADE bit.
                
    DomainSid - Pointer, the user object's parent Domain SID
    
    ObjectRid - this user object's RID
    
    UserParmsLengthOrig - Length of the original User Parameters, 
    
    UserParmsOrig - Pointer to the original User Parmameters, 
    
    UserParmsLengthNew - Lenghth of the new User Parameters, 
    
    UserParmsNew - Pointer to the new User Parameters,
    
    AttrBlock - Pointer, the returned DS attribute structure.
    
Return Value:

    STATUS_SUCCESS - complete successfully.
    
    STATUS_NO_MEMORY - no resources
    
    STATUS_INVALID_PARAMETER - Notification Package trying to set invalid attribute 
    
--*/
 
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSAMP_NOTIFICATION_PACKAGE Package = NULL;
    PDSATTRBLOCK DsAttrBlock = NULL;
    PDSATTRBLOCK PartialDsAttrBlock = NULL;
    PDSATTRBLOCK TmpDsAttrBlock = NULL;
    PSAM_USERPARMS_ATTRBLOCK UserParmsAttrBlock = NULL;
    PSAMP_SUPPLEMENTAL_CRED SupplementalCredentials = NULL;
    ATTR         CredentialAttr;
    
    
    SAMTRACE("SampConvertUserParmsToDsAttrBlock");
    
    // 
    // initialize
    //
    memset((PVOID) &CredentialAttr, 0, sizeof(ATTR));
    
    Package = SampNotificationPackages;

    if (ARGUMENT_PRESENT(Context))
    {
        SupplementalCredentials = Context->TypeBody.User.SupplementalCredentialsToWrite;
    }

    while (Package != NULL) 
    {
        if ( Package->UserParmsConvertNotificationRoutine != NULL &&
             Package->UserParmsAttrBlockFreeRoutine != NULL) 
        {
            __try 
            {
                NtStatus = Package->UserParmsConvertNotificationRoutine(
                                                                Flags,
                                                                DomainSid,
                                                                ObjectRid,
                                                                UserParmsLengthOrig,
                                                                UserParmsOrig,
                                                                UserParmsLengthNew,
                                                                UserParmsNew,
                                                                &UserParmsAttrBlock 
                                                                );
            
                if (NT_SUCCESS(NtStatus) && NULL != UserParmsAttrBlock) 
                {
                    //
                    // Validate the passed-in UserParmsAttrBlock is well-constructed.
                    //
                    NtStatus = SampUserParmsAttrBlockHealthCheck(UserParmsAttrBlock);
                    
                    if (NT_SUCCESS(NtStatus))
                    {
                        // 
                        // Convert SAM_USERPARMS_ATTRBLOCK to DSATTRBLOCK and get 
                        // Supplemental Credential Data if any.
                        // 
                        NtStatus = SampConvertUserParmsAttrBlockToDsAttrBlock(
                                                                        UserParmsAttrBlock,
                                                                        &PartialDsAttrBlock,
                                                                        &SupplementalCredentials
                                                                        );                                       
                                                                    
                        if (NT_SUCCESS(NtStatus) && NULL != PartialDsAttrBlock)
                        {
                            // if (!SampDsAttrBlockIsValid(PartialDsAttrBlock))
                            // {
                            //     NtStatus = STATUS_INVALID_PARAMETER;
                            //     __leave;
                            //  }
                            // 
                            // Check for any conflict between the converted UserParmsAttrBlock and 
                            // user's attributes block
                            //  
                            NtStatus = SampScanAttrBlockForConflict(DsAttrBlock, PartialDsAttrBlock);
                        
                            if (NT_SUCCESS(NtStatus))
                            {
                                NtStatus = SampScanAttrBlockForConflict(InAttrBlock, PartialDsAttrBlock);
                                    
                                if (NT_SUCCESS(NtStatus))
                                {
                                    NtStatus = SampMergeDsAttrBlocks(DsAttrBlock,
                                                                     PartialDsAttrBlock,
                                                                     &TmpDsAttrBlock
                                                                     );               
                                    if (NT_SUCCESS(NtStatus))
                                    {
                                        DsAttrBlock = TmpDsAttrBlock;
                                        TmpDsAttrBlock = NULL;
                                        PartialDsAttrBlock = NULL;
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (UserParmsAttrBlock != NULL) 
                {
                    Package->UserParmsAttrBlockFreeRoutine( UserParmsAttrBlock );
                    UserParmsAttrBlock = NULL;
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                NtStatus = STATUS_UNSUCCESSFUL;
            }
            
        }
        
        if (!NT_SUCCESS(NtStatus))
        {
            goto ConvertUserParmsError;
        }

        Package = Package->Next;
    }
    
    
    if ((NULL != SupplementalCredentials) && (!ARGUMENT_PRESENT(Context)))
    {
        NtStatus = SampConvertCredentialsToAttr(Context,
                                            Flags,
                                            ObjectRid,
                                            SupplementalCredentials,
                                            &CredentialAttr
                                            );
        
        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampAppendAttrToAttrBlock(CredentialAttr,
                                             &DsAttrBlock
                                             );
        }
    }
        
   
    
    if (!NT_SUCCESS(NtStatus))
    {
        goto ConvertUserParmsError;
    }
    
    *OutAttrBlock = DsAttrBlock;
    

ConvertUserParmsFinish:

    if ((SupplementalCredentials) && (!ARGUMENT_PRESENT(Context)))
    {
        SampFreeSupplementalCredentialList(SupplementalCredentials);
    }

    return NtStatus;



ConvertUserParmsError:


    if (NULL != Package)
    {
        PUNICODE_STRING EventString[1];
        
        EventString[0] = &Package->PackageName;
    
        SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                          0,
                          SAMMSG_ERROR_UPGRADE_USERPARMS,
                          NULL,  // Object SID 
                          1,
                          sizeof(NTSTATUS),
                          EventString,
                          (PVOID) &NtStatus 
                          );
    }                          

    
    if (PartialDsAttrBlock)
    {
        SampFreeAttributeBlock(PartialDsAttrBlock);
    }
       
    if (DsAttrBlock)
    {
        SampFreeAttributeBlock(DsAttrBlock);
    }

    if (CredentialAttr.AttrVal.pAVal)
    {
        if (CredentialAttr.AttrVal.pAVal[0].pVal)
        {
            MIDL_user_free(CredentialAttr.AttrVal.pAVal[0].pVal);
        }
        MIDL_user_free(CredentialAttr.AttrVal.pAVal); 
    }

        
    *OutAttrBlock = NULL;
        
    goto ConvertUserParmsFinish;        
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\upgrade.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    tconnect.c

Abstract:

    This is the file for a simple connection test to SAM.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <msaudite.h>





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global data structures                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
ULONG AdministrativeRids[] = {
    DOMAIN_ALIAS_RID_ADMINS,
    DOMAIN_ALIAS_RID_SYSTEM_OPS,
    DOMAIN_ALIAS_RID_PRINT_OPS,
    DOMAIN_ALIAS_RID_BACKUP_OPS,
    DOMAIN_ALIAS_RID_ACCOUNT_OPS
    };

#define ADMINISTRATIVE_ALIAS_COUNT (sizeof(AdministrativeRids)/sizeof(ULONG))

#define RTLP_RXACT_KEY_NAME L"RXACT"
#define RTLP_RXACT_KEY_NAME_SIZE (sizeof(RTLP_RXACT_KEY_NAME) - sizeof(WCHAR))

#define SAMP_FIX_18471_KEY_NAME L"\\Registry\\Machine\\Security\\SAM\\Fix18471"
#define SAMP_FIX_18471_SHORT_KEY_NAME L"Fix18471"
#define SAMP_LSA_KEY_NAME L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




BOOLEAN
SampMatchDomainPrefix(
    IN PSID AccountSid,
    IN PSID DomainSid
    )

/*++

Routine Description:

    This function compares the domain sid to the domain prefix of an
    account sid.

Arguments:

    AccountSid - Specifies the account Sid to be compared. The Sid is assumed to be
        syntactically valid.

    DomainSid - Specifies the domain Sid to compare against.


Return Value:

    TRUE - The account Sid is from the Domain specified by the domain Sid

    FALSE - The domain prefix of the account Sid did not match the domain.

--*/

{
    //
    // Check if the account Sid has one more subauthority than the
    // domain Sid.
    //

    if (*RtlSubAuthorityCountSid(DomainSid) + 1 !=
        *RtlSubAuthorityCountSid(AccountSid)) {
        return(FALSE);
    }

    if (memcmp(
            RtlIdentifierAuthoritySid(DomainSid),
            RtlIdentifierAuthoritySid(AccountSid),
            sizeof(SID_IDENTIFIER_AUTHORITY) ) ) {

        return(FALSE);
    }

    //
    // Compare the sub authorities
    //

    if (memcmp(
            RtlSubAuthoritySid(DomainSid, 0) ,
            RtlSubAuthoritySid(AccountSid, 0) ,
            *RtlSubAuthorityCountSid(DomainSid)
            ))
    {
        return(FALSE);
    }

    return(TRUE);

}



NTSTATUS
SampCreate18471Key(
    )
/*++

Routine Description:

    This routine creates the 18471 key used to transaction this fix.

Arguments:


Return Value:

    Codes from the NT registry APIs

--*/
{
    NTSTATUS Status;
    UNICODE_STRING KeyName;


    //
    // Open the 18471 key in the registry to see if an upgrade is in
    // progress
    //


    //
    // Start a transaction with to  create this key.
    //

    Status = SampAcquireWriteLock();

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    SampSetTransactionDomain(0);
    SampSetTransactionWithinDomain(FALSE);

    //
    // Create the fix18471 key in the registry
    //

    RtlInitUnicodeString(
        &KeyName,
        SAMP_FIX_18471_SHORT_KEY_NAME
        );

    Status = RtlAddActionToRXact(
                SampRXactContext,
                RtlRXactOperationSetValue,
                &KeyName,
                0,          // no value type
                NULL,       // no value
                0           // no value length
                );

    //
    // Commit this change
    //

    if (NT_SUCCESS(Status)) {
        Status = SampReleaseWriteLock( TRUE );
    } else {
        (void) SampReleaseWriteLock( FALSE );
    }

    return(Status);
}

NTSTATUS
SampAddAliasTo18471Key(
    IN ULONG AliasRid
    )
/*++

Routine Description:

    This routine creates the 18471 key used to transaction this fix.

Arguments:


Return Value:

    Codes from the NT registry APIs

--*/
{
    NTSTATUS Status;
    WCHAR KeyName[100];
    WCHAR AliasName[15]; // big enough for 4 billion
    UNICODE_STRING KeyNameString;
    UNICODE_STRING AliasString;

    //
    // Build the key name.  It will be "fix18471\rid_in_hex"
    //

    wcscpy(
        KeyName,
        SAMP_FIX_18471_SHORT_KEY_NAME L"\\"
        );

    AliasString.Buffer = AliasName;
    AliasString.MaximumLength = sizeof(AliasName);
    Status = RtlIntegerToUnicodeString(
                AliasRid,
                16,
                &AliasString
                );
    ASSERT(NT_SUCCESS(Status));

    wcscat(
        KeyName,
        AliasString.Buffer
        );

    RtlInitUnicodeString(
        &KeyNameString,
        KeyName
        );


    Status = SampAcquireWriteLock();

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    SampSetTransactionDomain(0);
    SampSetTransactionWithinDomain(FALSE);

    //
    // Open the Lsa key in the registry
    //

    Status = RtlAddActionToRXact(
                SampRXactContext,
                RtlRXactOperationSetValue,
                &KeyNameString,
                0,          // no value type
                NULL,       // no value
                0           // no value length
                );

    //
    // Commit this change
    //

    if (NT_SUCCESS(Status)) {
        Status = SampReleaseWriteLock( TRUE );

    } else {
        (void) SampReleaseWriteLock( FALSE );
    }

    return(Status);
}



NTSTATUS
SampAddMemberRidTo18471Key(
    IN ULONG AliasRid,
    IN ULONG MemberRid
    )
/*++

Routine Description:

    This routine adds a key for this member under the key for this alias
    to the current registry transaction.

Arguments:

    AliasRid - the rid of the alias

    MemberRid - The rid of the member of the alias

Returns:

    Errors from the RtlRXact APIs

--*/
{
    NTSTATUS Status;
    WCHAR KeyName[100];
    WCHAR AliasName[15]; // big enough for 4 billion
    UNICODE_STRING KeyNameString;
    UNICODE_STRING AliasString;


    //
    // Build the full key name.  It is of the form:
    // "fix18471\alias_rid\member_rid"
    //

    wcscpy(
        KeyName,
        SAMP_FIX_18471_SHORT_KEY_NAME L"\\"
        );

    AliasString.Buffer = AliasName;
    AliasString.MaximumLength = sizeof(AliasName);
    Status = RtlIntegerToUnicodeString(
                AliasRid,
                16,
                &AliasString
                );
    ASSERT(NT_SUCCESS(Status));

    wcscat(
        KeyName,
        AliasString.Buffer
        );

    wcscat(
        KeyName,
        L"\\"
        );

    AliasString.MaximumLength = sizeof(AliasName);
    Status = RtlIntegerToUnicodeString(
                MemberRid,
                16,
                &AliasString
                );
    ASSERT(NT_SUCCESS(Status));

    wcscat(
        KeyName,
        AliasString.Buffer
        );

    RtlInitUnicodeString(
        &KeyNameString,
        KeyName
        );

    //
    // Add this action to the RXact
    //

    Status = RtlAddActionToRXact(
                SampRXactContext,
                RtlRXactOperationSetValue,
                &KeyNameString,
                0,          // no value type
                NULL,       // no value
                0           // no value length
                );

    return(Status);

}

NTSTATUS
SampCheckMemberUpgradedFor18471(
    IN ULONG AliasRid,
    IN ULONG MemberRid
    )
/*++

Routine Description:

    This routine checks if the SAM upgrade flag is set. The upgrade
    flag is:

    HKEY_LOCAL_MACHINE\System\CurrentControlSet\control\lsa
        UpgradeSam = REG_DWORD 1


Arguments:


Return Value:

    TRUE - The flag was set

    FALSE - The flag was not set or the value was not present

--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    NTSTATUS Status;
    WCHAR KeyName[100];
    WCHAR AliasName[15]; // big enough for 4 billion
    UNICODE_STRING KeyNameString;
    UNICODE_STRING AliasString;


    //
    // Build the full key name.  It is of the form:
    // "fix18471\alias_rid\member_rid"
    //

    wcscpy(
        KeyName,
        SAMP_FIX_18471_KEY_NAME L"\\"
        );

    AliasString.Buffer = AliasName;
    AliasString.MaximumLength = sizeof(AliasName);
    Status = RtlIntegerToUnicodeString(
                AliasRid,
                16,
                &AliasString
                );
    ASSERT(NT_SUCCESS(Status));

    wcscat(
        KeyName,
        AliasString.Buffer
        );

    wcscat(
        KeyName,
        L"\\"
        );

    AliasString.MaximumLength = sizeof(AliasName);
    Status = RtlIntegerToUnicodeString(
                MemberRid,
                16,
                &AliasString
                );
    ASSERT(NT_SUCCESS(Status));

    wcscat(
        KeyName,
        AliasString.Buffer
        );

    RtlInitUnicodeString(
        &KeyNameString,
        KeyName
        );


    //
    // Open the member  key in the registry
    //


    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyNameString,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

    Status = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );

    NtClose(KeyHandle);
    return(Status);

}

VOID
SampBuild18471CleanupKey(
    OUT PUNICODE_STRING KeyName,
    IN PWCHAR AliasName,
    IN ULONG AliasNameLength,
    IN PWCHAR MemberName,
    IN ULONG MemberNameLength
    )
/*++

Routine Description:

    Builds the key "Fix18471\alias_rid\member_rid"

Arguments:


Return Value:

    None

--*/
{
    PUCHAR Where = (PUCHAR) KeyName->Buffer;

    RtlCopyMemory(
        Where,
        SAMP_FIX_18471_SHORT_KEY_NAME L"\\",
        sizeof(SAMP_FIX_18471_SHORT_KEY_NAME)   // terminating NULL used for '\'
        );

    Where  += sizeof(SAMP_FIX_18471_SHORT_KEY_NAME);

    RtlCopyMemory(
        Where,
        AliasName,
        AliasNameLength
        );
    Where += AliasNameLength;

    //
    // If there is a member name to this alias, add it now.
    //

    if (MemberName != NULL) {
        RtlCopyMemory(
            Where,
            L"\\",
            sizeof(WCHAR)
            );
        Where += sizeof(WCHAR);

        RtlCopyMemory(
            Where,
            MemberName,
            MemberNameLength
            );
        Where += MemberNameLength;

    }

    KeyName->Length = (USHORT) (Where - (PUCHAR) KeyName->Buffer);
    ASSERT(KeyName->Length <= KeyName->MaximumLength);
}


NTSTATUS
SampCleanup18471(
    )
/*++

Routine Description:

    Cleans up the transaction log left by fixing bug 18471.  This routine
    builds a transaction with all the keys in the log and then commits
    the transaction

Arguments:

    None.

Return Value:

    Status codes from the NT registry APIs and NT RXact APIs

--*/
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    HANDLE RootKey = NULL;
    HANDLE AliasKey = NULL;
    UCHAR Buffer[sizeof(KEY_BASIC_INFORMATION) + 15 * sizeof(WCHAR)];
    UCHAR Buffer2[sizeof(KEY_BASIC_INFORMATION) + 15 * sizeof(WCHAR)];
    UNICODE_STRING KeyName;
    WCHAR KeyBuffer[100];
    PKEY_BASIC_INFORMATION BasicInfo = (PKEY_BASIC_INFORMATION) Buffer;
    PKEY_BASIC_INFORMATION BasicInfo2 = (PKEY_BASIC_INFORMATION) Buffer2;
    ULONG BasicInfoLength;
    ULONG Index, Index2;

    //
    // Open the 18471 key in the registry
    //

    RtlInitUnicodeString(
        &KeyName,
        SAMP_FIX_18471_KEY_NAME
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    SampDumpNtOpenKey((KEY_READ | DELETE), &ObjectAttributes, 0);

    Status = NtOpenKey(
                &RootKey,
                KEY_READ | DELETE,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(Status)) {

        //
        // If the error was that the key did not exist, then there
        // is nothing to cleanup, so return success.
        //

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            return(STATUS_SUCCESS);
        }
        return(Status);
    }

    //
    // Create a transaction to add all the keys to delete to
    //

    Status = SampAcquireWriteLock();
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    SampSetTransactionDomain(0);
    SampSetTransactionWithinDomain(FALSE);

    //
    // Now enumerate all the subkeys of the root 18471 key
    //

    Index = 0;
    do
    {

        Status = NtEnumerateKey(
                    RootKey,
                    Index,
                    KeyBasicInformation,
                    BasicInfo,
                    sizeof(Buffer),
                    &BasicInfoLength
                    );

        SampDumpNtEnumerateKey(Index,
                               KeyBasicInformation,
                               BasicInfo,
                               sizeof(Buffer),
                               &BasicInfoLength);

        //
        //
        // Check if this is the RXACT key. If it is, we don't want
        // to add it to the delete log.
        //
        // Otherwise open this key and enumerate all the subkeys of it.
        //

        if (NT_SUCCESS(Status) &&
            ((BasicInfo->NameLength != RTLP_RXACT_KEY_NAME_SIZE) ||
                memcmp(
                    BasicInfo->Name,
                    RTLP_RXACT_KEY_NAME,
                    RTLP_RXACT_KEY_NAME_SIZE
                    ) ) ) {

            KeyName.Buffer = BasicInfo->Name;
            KeyName.Length = (USHORT) BasicInfo->NameLength;
            KeyName.MaximumLength = KeyName.Length;

            InitializeObjectAttributes(
                &ObjectAttributes,
                &KeyName,
                OBJ_CASE_INSENSITIVE,
                RootKey,
                NULL
                );

            //
            // Open the key for the alias rid.  This really should
            // succeed
            //

            SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

            Status = NtOpenKey(
                        &AliasKey,
                        KEY_READ,
                        &ObjectAttributes
                        );
            if (!NT_SUCCESS(Status)) {
                break;
            }

            //
            // Enumerate all the subkeys (the alias members) and add them
            // to the transaction
            //

            Index2 = 0;
            do
            {
                Status = NtEnumerateKey(
                            AliasKey,
                            Index2,
                            KeyBasicInformation,
                            BasicInfo2,
                            sizeof(Buffer2),
                            &BasicInfoLength
                            );

                SampDumpNtEnumerateKey(Index2,
                                       KeyBasicInformation,
                                       BasicInfo2,
                                       sizeof(Buffer2),
                                       &BasicInfoLength);

                if (NT_SUCCESS(Status)) {

                    //
                    // Build the name of this key from the alias rid and the
                    // member rid
                    //

                    KeyName.Buffer = KeyBuffer;
                    KeyName.MaximumLength = sizeof(KeyBuffer);

                    SampBuild18471CleanupKey(
                        &KeyName,
                        BasicInfo->Name,
                        BasicInfo->NameLength,
                        BasicInfo2->Name,
                        BasicInfo2->NameLength
                        );

                    Status = RtlAddActionToRXact(
                                SampRXactContext,
                                RtlRXactOperationDelete,
                                &KeyName,
                                0,
                                NULL,
                                0
                                );


                }
                Index2++;

            } while (NT_SUCCESS(Status));

            NtClose(AliasKey);
            AliasKey = NULL;

            //
            // If we suffered a serious error, get out of here now
            //

            if (!NT_SUCCESS(Status)) {
                if (Status != STATUS_NO_MORE_ENTRIES) {
                    break;
                } else {
                    Status = STATUS_SUCCESS;
                }
            }

            //
            // Add the alias RID key to the RXact now - we need to add it
            // after deleting all the children
            //

            KeyName.Buffer = KeyBuffer;
            KeyName.MaximumLength = sizeof(KeyBuffer);
            SampBuild18471CleanupKey(
                &KeyName,
                BasicInfo->Name,
                BasicInfo->NameLength,
                NULL,
                0
                );


            Status = RtlAddActionToRXact(
                        SampRXactContext,
                        RtlRXactOperationDelete,
                        &KeyName,
                        0,
                        NULL,
                        0
                        );

        }

        Index++;
    } while (NT_SUCCESS(Status));

    if (Status == STATUS_NO_MORE_ENTRIES) {
        Status = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    RtlInitUnicodeString(
        &KeyName,
        SAMP_FIX_18471_SHORT_KEY_NAME
        );

    Status = RtlAddActionToRXact(
                SampRXactContext,
                RtlRXactOperationDelete,
                &KeyName,
                0,
                NULL,
                0
                );

    if (NT_SUCCESS(Status)) {

        //
        // Write the new server revision to indicate that this
        // upgrade has been performed
        //

        SAMP_V1_FIXED_LENGTH_SERVER ServerFixedAttributes;
        PSAMP_OBJECT ServerContext;

        //
        // We need to read the fixed attributes of the server objects.
        // Create a context to do that.
        //
        // Server Object doesn't care about DomainIndex, use 0 is fine. (10/12/2000 ShaoYin)

        ServerContext = SampCreateContext( SampServerObjectType, 0, TRUE );

        if ( ServerContext != NULL ) {

            ServerContext->RootKey = SampKey;

            ServerFixedAttributes.RevisionLevel = SAMP_NT4_SERVER_REVISION;

            Status = SampSetFixedAttributes(
                        ServerContext,
                        &ServerFixedAttributes
                        );
            if (NT_SUCCESS(Status)) {
                Status = SampStoreObjectAttributes(
                            ServerContext,
                            TRUE
                            );
            }

            SampDeleteContext( ServerContext );
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }


    //
    // Apply the RXACT and delete the remaining keys.
    //

Cleanup:

    //
    // Cleanup any floating bits from above.
    //

    if (NT_SUCCESS(Status)) {
        Status = SampReleaseWriteLock( TRUE );
    } else {
        (VOID) SampReleaseWriteLock( FALSE );
    }

    if (RootKey != NULL) {
        NtClose(RootKey);
    }

    ASSERT(AliasKey == NULL);


    return(Status);

}

NTSTATUS
SampFixBug18471 (
    IN ULONG Revision
    )
/*++

Routine Description:

    This routine fixes bug 18471, that SAM does not adjust the protection
    on groups that are members of administrative aliases in the builtin
    domain. It fixes this by opening a fixed set of known aliases
    (Administrators, Account Operators, Backup Operators, Print Operators,
    and Server Operators), and enumerating their members.  To fix this,
    we will remove all the members of these aliases (except the
    Administrator user account) and re-add them.

Arguments:

    Revision - Revision of the Sam server.

Return Value:


    Note:


--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    ULONG               Index, Index2;
    PSID                BuiltinDomainSid = NULL;
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;
    PSID                AccountDomainSid;
    ULONG               AccountDomainIndex = 0xffffffff;
    ULONG               BuiltinDomainIndex = 0xffffffff;
    SAMPR_PSID_ARRAY    AliasMembership;
    ULONG               MemberRid;
    ULONG               SdRevision;
    PSECURITY_DESCRIPTOR OldDescriptor;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    ULONG               SecurityDescriptorLength;
    SAMP_OBJECT_TYPE    MemberType;
    PSAMP_OBJECT        MemberContext;
    PSAMP_OBJECT        AliasContext;
    SAMP_V1_0A_FIXED_LENGTH_GROUP GroupV1Fixed;
    SAMP_V1_0A_FIXED_LENGTH_USER UserV1Fixed;

    //
    // Check the revision on the server to see if this upgrade has
    // already been performed.
    //


    if (Revision >= 0x10003) {

        //
        // This upgrade has already been performed.
        //

        goto Cleanup;
    }


    //
    // Build a the BuiltIn domain SID.
    //

    BuiltinDomainSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 1 ));

    if ( BuiltinDomainSid == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlInitializeSid( BuiltinDomainSid,   &BuiltinAuthority, 1 );
    *(RtlSubAuthoritySid( BuiltinDomainSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;


    //
    // Lookup the index of the account domain
    //

    for (Index = 0;
         Index < SampDefinedDomainsCount ;
         Index++ ) {

        if (RtlEqualSid( BuiltinDomainSid, SampDefinedDomains[Index].Sid)) {
            BuiltinDomainIndex = Index;
        } else {
            AccountDomainIndex = Index;
        }
    }

    ASSERT(AccountDomainIndex < SampDefinedDomainsCount);
    ASSERT(BuiltinDomainIndex < SampDefinedDomainsCount);

    AccountDomainSid = SampDefinedDomains[AccountDomainIndex].Sid;

    //
    // Create out transaction log
    //

    Status = SampCreate18471Key();
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }




    //
    // Now loop through and open the aliases we are intersted in
    //

    for (Index = 0;
         Index < ADMINISTRATIVE_ALIAS_COUNT ;
         Index++ )
    {

        SampSetTransactionDomain( BuiltinDomainIndex );

        SampAcquireReadLock();

        Status = SampCreateAccountContext(
                    SampAliasObjectType,
                    AdministrativeRids[Index],
                    TRUE,                       // Trusted client
                    FALSE,
                    TRUE,                       // Account exists
                    &AliasContext
                    );

        if ( !NT_SUCCESS(Status) ) {

            SampReleaseReadLock();
            if (Status == STATUS_NO_SUCH_ALIAS) {
                Status = STATUS_SUCCESS;
                continue;
            } else {

                goto Cleanup;
            }
        }


        //
        // Get the members in the alias so we can remove and re-add them
        //

        Status = SampRetrieveAliasMembers(
                    AliasContext,
                    &(AliasMembership.Count),
                    (PSID **)&(AliasMembership.Sids)
                    );

        SampDeleteContext(AliasContext);
        SampReleaseReadLock();
        if (!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Write that we are opening this alias to the log.  We don't need
        // to do this for administrators, since for them we the update is
        // idempotent.
        //

        if (AdministrativeRids[Index] != DOMAIN_ALIAS_RID_ADMINS) {
            Status = SampAddAliasTo18471Key(
                        AdministrativeRids[Index]
                        );
            if (!NT_SUCCESS(Status)) {
                break;
            }
        }


        //
        // Loop through the members and split each sid.  For every
        // member in the account domain , remove it and re-add it from
        // this alias.
        //




        for (Index2 = 0; Index2 < AliasMembership.Count ; Index2++ )
        {
            //
            // Check to see if this account is in the account domain
            //

            if ( SampMatchDomainPrefix(
                    (PSID) AliasMembership.Sids[Index2].SidPointer,
                    AccountDomainSid
                    ) )
            {

                //
                // Get the RID for this member
                //

                MemberRid = *RtlSubAuthoritySid(
                                AliasMembership.Sids[Index2].SidPointer,
                                *RtlSubAuthorityCountSid(
                                    AliasMembership.Sids[Index2].SidPointer
                                ) - 1
                                );

                //
                // Now remove and re-add the administratie nature of this
                // membership
                //

                if (AdministrativeRids[Index] == DOMAIN_ALIAS_RID_ADMINS) {

                    Status = SampAcquireWriteLock();
                    if (!NT_SUCCESS(Status)) {
                        break;
                    }

                    SampSetTransactionDomain( AccountDomainIndex );

                    //
                    // Try to create a context for the account as a group.
                    //

                    Status = SampCreateAccountContext(
                                     SampGroupObjectType,
                                     MemberRid,
                                     TRUE, // Trusted client
                                     FALSE,
                                     TRUE, // Account exists
                                     &MemberContext
                                     );

                    if (!NT_SUCCESS( Status ) ) {

                        //
                        // If this ID does not exist as a group, that's fine -
                        // it might be a user or might have been deleted.
                        //

                        SampReleaseWriteLock( FALSE );
                        if (Status == STATUS_NO_SUCH_GROUP) {
                            Status = STATUS_SUCCESS;
                            continue;
                        }
                        break;
                    }

                    //
                    // Now set a flag in the group itself,
                    // so that when users are added and removed
                    // in the future it is known whether this
                    // group is in an ADMIN alias or not.
                    //

                    Status = SampRetrieveGroupV1Fixed(
                                   MemberContext,
                                   &GroupV1Fixed
                                   );

                    if ( NT_SUCCESS(Status)) {

                        GroupV1Fixed.AdminCount = 1;

                        Status = SampReplaceGroupV1Fixed(
                                    MemberContext,
                                    &GroupV1Fixed
                                    );
                        //
                        // Modify the security descriptor to
                        // prevent account operators from adding
                        // anybody to this group
                        //

                        if ( NT_SUCCESS( Status ) ) {

                            Status = SampGetAccessAttribute(
                                        MemberContext,
                                        SAMP_GROUP_SECURITY_DESCRIPTOR,
                                        FALSE, // don't make copy
                                        &SdRevision,
                                        &OldDescriptor
                                        );

                            if (NT_SUCCESS(Status)) {

                                Status = SampModifyAccountSecurity(
                                            MemberContext,
                                            SampGroupObjectType,
                                            TRUE, // this is an admin
                                            OldDescriptor,
                                            &SecurityDescriptor,
                                            &SecurityDescriptorLength
                                            );
                            }

                            if ( NT_SUCCESS( Status ) ) {

                                //
                                // Write the new security descriptor into the object
                                //

                                Status = SampSetAccessAttribute(
                                               MemberContext,
                                               SAMP_USER_SECURITY_DESCRIPTOR,
                                               SecurityDescriptor,
                                               SecurityDescriptorLength
                                               );

                                MIDL_user_free( SecurityDescriptor );
                            }



                        }
                        if (NT_SUCCESS(Status)) {

                            //
                            // Add the modified group to the current transaction
                            // Don't use the open key handle since we'll be deleting the context.
                            //

                            Status = SampStoreObjectAttributes(MemberContext, FALSE);

                        }

                    }

                    //
                    // Clean up the group context
                    //

                    SampDeleteContext(MemberContext);

                    //
                    // we don't want the modified count to change
                    //

                    SampSetTransactionWithinDomain(FALSE);

                    if (NT_SUCCESS(Status)) {
                        Status = SampReleaseWriteLock( TRUE );
                    } else {
                        (VOID) SampReleaseWriteLock( FALSE );
                    }

                }
                else
                {


                    //
                    // Check to see if we've already upgraded this member
                    //

                    Status = SampCheckMemberUpgradedFor18471(
                                AdministrativeRids[Index],
                                MemberRid);

                    if (NT_SUCCESS(Status)) {

                        //
                        // This member already was upgraded.
                        //

                        continue;
                    } else {

                        //
                        // We continue on with the upgrade
                        //

                        Status = STATUS_SUCCESS;
                    }

                    //
                    // Change the operator account for the other
                    // aliases.
                    //

                    if (NT_SUCCESS(Status)) {

                        Status = SampAcquireWriteLock();
                        if (!NT_SUCCESS(Status)) {
                            break;
                        }

                        SampSetTransactionDomain( AccountDomainIndex );

                        Status = SampChangeAccountOperatorAccessToMember(
                                    AliasMembership.Sids[Index2].SidPointer,
                                    NoChange,
                                    AddToAdmin
                                    );

                        //
                        // If that succeeded, add this member to the log
                        // as one that was upgraded.
                        //

                        if (NT_SUCCESS(Status)) {
                            Status = SampAddMemberRidTo18471Key(
                                        AdministrativeRids[Index],
                                        MemberRid
                                        );

                        }

                        //
                        // We don't want the modified count to be updated so
                        // make this not a domain transaction
                        //

                        SampSetTransactionWithinDomain(FALSE);
                                                if (NT_SUCCESS(Status)) {
                            Status = SampReleaseWriteLock( TRUE );
                        } else {
                            (VOID) SampReleaseWriteLock( FALSE );
                        }

                    }

                    if (!NT_SUCCESS(Status)) {
                        break;
                    }

                }
            }
        }

        SamIFree_SAMPR_PSID_ARRAY(
            &AliasMembership
            );
        AliasMembership.Sids = NULL;


        //
        // If something up above failed or the upgrade was already done,
        // exit now.
        //

        if (!NT_SUCCESS(Status)) {
            break;
        }
    }

Cleanup:

    if (BuiltinDomainSid != NULL) {
        RtlFreeHeap(
            RtlProcessHeap(),
            0,
            BuiltinDomainSid
            );
    }

    if (NT_SUCCESS(Status)) {
        Status = SampCleanup18471();
    }
    return(Status);
}


NTSTATUS
SampUpdateEncryption(
    IN SAMPR_HANDLE ServerHandle OPTIONAL
    )
/*++

    This routine walks the set of users and groups and updates the 
    encryption on them to reflect being syskey'd or a change of the
    password encryption key


    Parameter:

        ServerContext

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SAMPR_HANDLE DomainHandle = NULL;
    PSAMP_OBJECT UserObject = NULL;
    PSAMP_OBJECT ServerContext = NULL;
    SAMPR_HANDLE LocalServerHandle = NULL;
    SAM_ENUMERATE_HANDLE EnumerationContext = 0;
    PSAMPR_ENUMERATION_BUFFER EnumBuffer = NULL;
    ULONG CountReturned;
    BOOLEAN EnumerationDone = FALSE;
    ULONG PrivateDataLength;
    PVOID PrivateData = NULL;
    BOOLEAN LockHeld = FALSE;
    ULONG   DomainIndex,Index;

#define MAX_SAM_PREF_LENGTH 0xFFFF


    if (!ARGUMENT_PRESENT(ServerHandle))
    {
        Status = SamIConnect(
                    NULL,
                    &LocalServerHandle,
                    SAM_SERVER_ALL_ACCESS,
                    TRUE
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        ServerContext = (PSAMP_OBJECT) LocalServerHandle;
    }
    else
    {
        ServerContext = (PSAMP_OBJECT) ServerHandle;
    }

    Status = SamrOpenDomain(
                ServerContext,
                DOMAIN_LOOKUP |
                    DOMAIN_LIST_ACCOUNTS |
                    DOMAIN_READ_PASSWORD_PARAMETERS,
                SampDefinedDomains[SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX].Sid,
                &DomainHandle
                );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // If we aren't supposed to super-encrypt the passwords than just return
    // success now before encrypting everything.
    //

    DomainIndex = ((PSAMP_OBJECT) DomainHandle)->DomainIndex;
    if ((SampDefinedDomains[DomainIndex].UnmodifiedFixed.DomainKeyFlags &
        SAMP_DOMAIN_SECRET_ENCRYPTION_ENABLED) == 0) {

       Status = STATUS_SUCCESS;
       goto Cleanup;
    }

    //
    // Now enumerate through all users and get/set their private data
    //

    while (!EnumerationDone) {

        Status = SamrEnumerateUsersInDomain(
                    DomainHandle,
                    &EnumerationContext,
                    0,                          // no UserAccountControl,
                    &EnumBuffer,
                    MAX_SAM_PREF_LENGTH,
                    &CountReturned
                    );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }
        if (Status != STATUS_MORE_ENTRIES) {

            EnumerationDone = TRUE;
        } else {
            ASSERT(CountReturned != 0);
        }
        ASSERT(CountReturned == EnumBuffer->EntriesRead);

        for (Index = 0; Index < CountReturned ; Index++ ) {

            //
            // Create an account context for each user to read the user off
            // the disk
            //

            Status = SampAcquireWriteLock();
            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }
            LockHeld = TRUE;

            SampSetTransactionDomain( DomainIndex );

            Status = SampCreateAccountContext(
                        SampUserObjectType,
                        EnumBuffer->Buffer[Index].RelativeId,
                        TRUE, // Trusted client
                        FALSE,
                        TRUE, // Account exists
                        &UserObject
                        );
            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            Status = SampGetPrivateUserData(
                        UserObject,
                        &PrivateDataLength,
                        &PrivateData
                        );

            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            Status = SampSetPrivateUserData(
                        UserObject,
                        PrivateDataLength,
                        PrivateData
                        );


            MIDL_user_free(PrivateData);
            PrivateData = NULL;

            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            Status = SampStoreObjectAttributes(
                        UserObject,
                        FALSE
                        );

            SampDeleteContext(UserObject);
            UserObject = NULL;
            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            //
            // we don't want the modified count to change
            //

            SampSetTransactionWithinDomain(FALSE);

            Status = SampReleaseWriteLock( TRUE );
            LockHeld = FALSE;
            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

        }

        SamIFree_SAMPR_ENUMERATION_BUFFER( EnumBuffer );
        EnumBuffer = NULL;
    }

Cleanup:

    //
    // If the lock is still held at this point, we must have failed so
    // release the lock and rollback the transaction
    //

    if (LockHeld) {
        ASSERT(!NT_SUCCESS(Status));
        SampReleaseWriteLock( FALSE );
        LockHeld = FALSE;
    }

    if (UserObject != NULL) {
        SampDeleteContext(UserObject);
    }

    if (DomainHandle != NULL) {
        SamrCloseHandle(&DomainHandle);
    }

    if (LocalServerHandle!=NULL ) {
        SamrCloseHandle(&LocalServerHandle);
    }
    
    if (EnumBuffer != NULL) {
        SamIFree_SAMPR_ENUMERATION_BUFFER( EnumBuffer );

    }

    return(Status);
        
}
        



NTSTATUS
SampPerformSyskeyUpgrade(
    IN ULONG Revision,
    IN BOOLEAN UpdateEncryption
    )
/*++

Routine Description:

    If the revision is less than SAMP_WIN2k_REVISION this routine 
    will enumerate through
    all users and read their private data and then restored their private
    data. This will guarantee that it has been re-encrypted using a stronger
    encryption mechanism than just the RID.


Arguments:

    Revision - The revision stored in the Server fixed length attributes

Return Value:


    Note:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG DomainIndex;
    ULONG Index;
    BOOLEAN LockHeld = FALSE;
    ULONG NewRevision = SAMP_WHISTLER_OR_W2K_SYSPREP_FIX_REVISION;
    PSAMP_OBJECT ServerContext = NULL;
    ULONG        i;
    SAMP_V1_FIXED_LENGTH_SERVER ServerFixedAttributes;


   
    //
    // If the change corresponding to the NT4 Sp3 Upgrade's
    // reencrypting secret data was made then don't need to 
    // upgrade again.
    //

    if (Revision >= NewRevision) {
        return(STATUS_SUCCESS);
    }

    //
    // w2k was syskey'd but did not contain space for the previous
    // key. So on upgrade from win2k just force a write to the
    // domain object to get the appropriate update
    //

    if (Revision==SAMP_WIN2K_REVISION) {
        UpdateEncryption = FALSE;
    }

    //
    // Force an upgrade to the domain object to the current revision
    // level by reading and writing back the fixed data. SAM normally
    // has logic to read multiple revisions, but the DS upgrader code only
    // has the capability to manipulate the latest revision, because it
    // bypasses the normal Sam attribute handling functions. Further we
    // know that only the domain object has changed from NT4 SP1 to NT4 SP3
    // and reading and flushing the domain object by hand again will cause
    // it to be in the latest revision format. Also note that all revisions
    // to other classes of objects ( groups, users etc) were made on or before
    // NT version 3.5. Since we need to support backward compatibility only
    // with 3.5.1 it is not necessary to modify the DS upgrader code. 
    //
   
    
    for (i=0;i<SampDefinedDomainsCount;i++)
    {
        PSAMP_V1_0A_FIXED_LENGTH_DOMAIN
            V1aFixed;

        Status = SampAcquireWriteLock();
        if (!NT_SUCCESS(Status))
            goto Cleanup;

         LockHeld = TRUE;

        //
        // If the domain is hosted in the registry then 
        // perform the write. This is not applicable to DS domains
        // in DS mode, the safeboot hives will undergo this upgrade
        //

        if (!IsDsObject(SampDefinedDomains[i].Context))
        {
            SampSetTransactionWithinDomain(FALSE);
            SampSetTransactionDomain(i);

            Status = SampGetFixedAttributes(
                        SampDefinedDomains[i].Context,
                        FALSE, // make copy
                        &V1aFixed);

            if (!NT_SUCCESS(Status))
                goto Cleanup;

            Status = SampSetFixedAttributes(
                        SampDefinedDomains[i].Context,
                        V1aFixed);

            if (!NT_SUCCESS(Status))
                goto Cleanup;

          
            Status = SampStoreObjectAttributes(
                        SampDefinedDomains[i].Context,
                        TRUE
                        );
            if (!NT_SUCCESS(Status))
                goto Cleanup;

            //
            // Decrement the serial number by 1 to compensate for
            // the increment in the commit
            //
       
            SampDefinedDomains[i].NetLogonChangeLogSerialNumber.QuadPart-=1;
        }

        Status = SampReleaseWriteLock(TRUE);
        LockHeld = FALSE;
        if (!NT_SUCCESS(Status))
            goto Cleanup;
           
    }

    //
    // We can't use the normal connect API because SAM is still
    // initializing.
    //

    SampAcquireReadLock();

    // Server Object doesn't care about DomainIndex, use 0 is fine. (10/12/2000 ShaoYin)

    ServerContext = SampCreateContext(
                        SampServerObjectType,
                        0,
                        TRUE                   // TrustedClient
                        );

    if (ServerContext != NULL) {

        //
        // The RootKey for a SERVER object is the root of the SAM database.
        // This key should not be closed when the context is deleted.
        //

        ServerContext->RootKey = SampKey;
    } else {
        SampReleaseReadLock();
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    
    SampReleaseReadLock();


    if (UpdateEncryption)
    {        
        Status = SampUpdateEncryption(
                        (SAMPR_HANDLE) ServerContext
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Now update the server object to indicate that the revision has
    // been updated.
    //

    Status = SampAcquireWriteLock();
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }
    LockHeld = TRUE;


    //
    // We need to read the fixed attributes of the server objects.
    // Create a context to do that.
    //


    ServerFixedAttributes.RevisionLevel = NewRevision;

    Status = SampSetFixedAttributes(
                ServerContext,
                &ServerFixedAttributes
                );

    if (NT_SUCCESS(Status)) {
        Status = SampStoreObjectAttributes(
                    ServerContext,
                    FALSE
                    );
    }

    SampDeleteContext( ServerContext );
    ServerContext = NULL;


    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    Status = SampReleaseWriteLock( TRUE );
    LockHeld = FALSE;

Cleanup:


    //
    // We need to hold the lock while deleting this
    //

    if (ServerContext != NULL) {
        if (!LockHeld) {
            SampAcquireReadLock();
        }
        SampDeleteContext( ServerContext );
        if (!LockHeld) {
            SampReleaseReadLock();
        }
    }

    //
    // If the lock is still held at this point, we must have failed so
    // release the lock and rollback the transaction
    //

    if (LockHeld) {
        ASSERT(!NT_SUCCESS(Status));
        SampReleaseWriteLock( FALSE );
    }

    return(Status);
}

NTSTATUS
SampUpdateRevision(IN ULONG Revision )
{
    PSAMP_OBJECT ServerContext = NULL;
    BOOLEAN      fWriteLockAcquired = FALSE;
    NTSTATUS     Status = STATUS_SUCCESS;
    SAMP_V1_FIXED_LENGTH_SERVER ServerFixedAttributes;

 
    //
    // Acquire the write lock
    //

    Status = SampAcquireWriteLock();
    if (!NT_SUCCESS(Status))
    {
       goto Cleanup;
    }

    fWriteLockAcquired = TRUE;

    // Server Object doesn't care about DomainIndex, use 0 is fine. (10/12/2000 ShaoYin)

    ServerContext = SampCreateContext(
                        SampServerObjectType,
                        0,
                        TRUE                   // TrustedClient
                        );

    if (ServerContext != NULL) {

        //
        // The RootKey for a SERVER object is the root of the SAM database.
        // This key should not be closed when the context is deleted.
        //

        ServerContext->RootKey = SampKey;
    } else {
        
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    ServerFixedAttributes.RevisionLevel = Revision;
    Status = SampSetFixedAttributes(
                ServerContext,
                &ServerFixedAttributes
                );

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    Status = SampStoreObjectAttributes(
                ServerContext,
                FALSE
                );


Cleanup:

    if (NULL!=ServerContext)
    {
        SampDeleteContext( ServerContext );
        ServerContext = NULL;
    }


    if (fWriteLockAcquired)
    {
        Status = SampReleaseWriteLock( NT_SUCCESS(Status)?TRUE:FALSE );
    }


    return(Status);

}

NTSTATUS
SampUpgradeSamDatabase(
    IN ULONG Revision
    )
/*++

Routine Description:

    Upgrades the SAM database. This is the registry mode upgrade routine.

Arguments:

    Revision - The revision stored in the Server fixed length attributes

Return Value:


    Note:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN  fUpgrade = FALSE;
    BOOLEAN  SampUseDsDataTmp;

    

    //
    // Set the upgrade flag so we can access SAM objects
    //

    SampUpgradeInProcess = TRUE;

    if (!SampUseDsData)
    {
        Status = SampFixBug18471(Revision);
    }

    if (NT_SUCCESS(Status)) 
    {

        
        BOOLEAN UpdateEncryption=TRUE;

        //
        // The following upgrade is performed for 2 reasons
        // 1. To create a field in the registry structure for the
        //    password encryption key if necessary
        //
        // 2. To update all accounts with new syskey encryption. In
        //    DS mode we perform this for the safe boot hives.
        //    Since a significant fraction of the SAM code forks off
        //    into DS path, based on the boolean SampUseDsData, therefore
        //    reset the global to false and then restore it to original value
        //    before and after the operation. This way we are assured of
        //    always accessing the registry.
        //
        // 3. The encryption is not updated in case this is a domain controller 
        //    as do not want the performance penalty of the walking 
        //    through all user accounts. Skipping the update occurs only if
        //    this is a domain controller going through GUI setup. The other
        //    case is a freshly DcPromo'd machine, in which case we update the
        //    encryption for the safeboot hives.
        //

        if ((SampProductType==NtProductLanManNt) && 
                 (SampIsSetupInProgress(&fUpgrade)) && fUpgrade)
        {
             UpdateEncryption = FALSE;
        }
        SampUseDsDataTmp = SampUseDsData;
        SampUseDsData = FALSE;
        Status = SampPerformSyskeyUpgrade(Revision,UpdateEncryption);
        SampUseDsData = SampUseDsDataTmp;
    }

    if (NT_SUCCESS(Status))
    {
        //
        // Upgrade the default user and group information if necessary.
        // This upgrade is done during GUI setup or on reboot after a
        // dcpromo. On domain controllers this
        // upgrade happens on the safeboot hives.
        //

        ULONG PromoteData;


        if ((SampIsRebootAfterPromotion(&PromoteData)) || (SampIsSetupInProgress(NULL))) {


            SampUseDsDataTmp = SampUseDsData;
            SampUseDsData = FALSE;

            //
            // Disable netlogon notifications if we are upgrading the safe boot hive
            //

            if (TRUE==SampUseDsDataTmp)
            {
               SampDisableNetlogonNotification = TRUE;
            }

            //
            // The database revision has been updated, so run through all the
            // groups for a possible upgrade
            //

            Status = SampPerformPromotePhase2(SAMP_PROMOTE_INTERNAL_UPGRADE);

            if (!NT_SUCCESS(Status)) {

                ASSERT( NT_SUCCESS(Status) );
                KdPrintEx((DPFLTR_SAMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "SAMSS: New account creation failed with: 0x%x\n",
                           Status));

                //
                // Don't fail the install because of this
                //

                Status = STATUS_SUCCESS;
            }
            


            SampUseDsData = SampUseDsDataTmp;
            SampDisableNetlogonNotification = FALSE;

        }
    }

   

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\usrprop.c ===
/*++

Copyright (c) 1993-1993  Microsoft Corporation

Module Name:

    usrprop.c

Abstract:

    This module implements QueryUserProperty() and SetUserProperty()
    which read and write NetWare Properties to the UserParms field.

Author:

    Andy Herron (andyhe)    24-May-1993
    Congpa You  (CongpaY)   28-Oct-1993   Seperated SetUserProperty() and
                                          QueryUserProperty() out from usrprop.c
                                          in ncpsrv\svcdlls\ncpsvc\libbind,
                                          modified the code and  fixed a few
                                          existing problems.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#ifdef notdef
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntioapi.h"
#include "windef.h"
#include "winbase.h"
#include "stdio.h"
#include "stdlib.h"
#include "winuser.h"
#endif // notdef

#include <usrprop.h>

//
//   All internal (opaque) structures are listed here since no one else
//   needs to reference them.
//

//
// The user's Parameter field is mapped out to a structure that contains
// the backlevel 48 WCHARs for Mac/Ras compatibility plus a new structure
// that is basically an array of chars that make up a property name plus
// a property value.
//

//
//  This is the structure for an individual property.  Note that there are
//  no null terminators in this.
//
typedef struct _USER_PROPERTY {
    WCHAR   PropertyLength;     // length of property name
    WCHAR   ValueLength;        // length of property value
    WCHAR   PropertyFlag;       // type of property (1 = set, 2 = item)
    WCHAR   Property[1];        // start of property name, followed by value
} USER_PROPERTY, *PUSER_PROPERTY;

//
//  This is the structure that maps the beginning of the user's Parameters
//  field.  It is only separate so that we can do a sizeof() without including
//  the first property, which may or may not be there.
//

typedef struct _USER_PROPERTIES_HDR {
    WCHAR   BacklevelParms[48];     // RAS & Mac data stored here.
    WCHAR   PropertySignature;      // signature that we can look for.
    WCHAR   PropertyCount;          // number of properties present.
} USER_PROPERTIES_HDR, *PUSER_PROPERTIES_HDR;

//
//  This structure maps out the whole of the user's Parameters field when
//  the user properties structure is present and at least one property is
//  defined.
//

typedef struct _USER_PROPERTIES {
    USER_PROPERTIES_HDR Header;
    USER_PROPERTY   FirstProperty;
} USER_PROPERTIES, *PUSER_PROPERTIES;

//
// forward references
//

NTSTATUS
UserPropertyAllocBlock (
    IN PUNICODE_STRING Existing,
    IN ULONG DesiredLength,
    IN OUT PUNICODE_STRING New
    );

BOOL
FindUserProperty (
    PUSER_PROPERTIES UserProperties,
    LPWSTR           Property,
    PUSER_PROPERTY  *pUserProperty,
    USHORT          *pCount
    );

VOID
RemoveUserProperty (
    UNICODE_STRING *puniUserParms,
    PUSER_PROPERTY  UserProperty,
    USHORT          Count,
    BOOL           *Update
    );

NTSTATUS
SetUserProperty (
    IN LPWSTR          UserParms,
    IN LPWSTR          Property,
    IN PUNICODE_STRING PropertyValue,
    IN WCHAR           PropertyFlag,
    OUT LPWSTR        *pNewUserParms,   // memory has to be freed afer use.
    OUT BOOL          *Update
    )
/*
    This function sets a property field in the user's Parameters field.
    It is the Callers Responsibility to initialize the Update Field prior
    to calling this routine
*/
{
    NTSTATUS status = STATUS_SUCCESS;
    UNICODE_STRING uniUserParms;
    UNICODE_STRING uniNewUserParms;
    USHORT Count = 0;
    USHORT PropertyLength;
    USHORT ValueLength;
    PUSER_PROPERTIES UserProperties;
    PUSER_PROPERTY   UserProperty;
    LPWSTR PropertyValueString = NULL;
    USHORT  oldUserParmsLength = 0;
    INT i;
    UCHAR *pchValue = NULL;

    // Check if parameters are correct.
    if ((Property == NULL) || (PropertyFlag == 0))
    {
        return( STATUS_INVALID_PARAMETER );
    }

    // Initialize output variables.


    *pNewUserParms = NULL;

    try {

        oldUserParmsLength = (USHORT)((lstrlenW(UserParms) + 1) * sizeof(WCHAR));

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  if we can't get the length of the current UserParameters, we loose
        //  the whole thing.
        //

        UserParms = NULL;
    }

    // Convert UserParms to unicode string.
    uniUserParms.Buffer = UserParms;
    uniUserParms.Length = UserParms ? oldUserParmsLength : 0;
    uniUserParms.MaximumLength = uniUserParms.Length;

    /** Get the length of the property name **/

    PropertyLength = (USHORT)(lstrlenW( Property ) * sizeof(WCHAR));

    /** Get the length of the property value **/
    ValueLength = PropertyValue->Length;

    if (ValueLength != 0)
    {
        // Convert property value to asci string so that
        // if property value is 0, it can be stored correctly.

        PropertyValueString = (LPWSTR) LocalAlloc (LPTR, (ValueLength+1)*sizeof (WCHAR));
        if (!PropertyValueString)
        {
            return(STATUS_NO_MEMORY) ;
        }

        pchValue = (UCHAR *) PropertyValue->Buffer;

        // BUGBUG. Since wsprint converts 0x00 to 20 30 (20 is
        // space and 30 is 0), sscanf converts 20 30 to 0. If the
        // value is uncode string, this convertsion would not
        // convert back to original value. So if we want to store
        // some value in the UserParms, we have to pass in ansi
        // string.

        for (i = 0; i < ValueLength; i++)
        {
            wsprintfA ((PCHAR)(PropertyValueString+i), "%02x", *(pchValue+i));
        }

        *(PropertyValueString+ValueLength) = 0;
        ValueLength = ValueLength * sizeof (WCHAR);
    }

    //
    // check that user has valid property structure , if not, create one
    //

    if (UserParms != NULL)
    {
        Count = oldUserParmsLength;
    }

    if (Count < sizeof( USER_PROPERTIES))
    {
        Count = sizeof( USER_PROPERTIES_HDR ) + sizeof(WCHAR);
    }

    if (ValueLength > 0)
    {
        Count += sizeof( USER_PROPERTY ) + PropertyLength + ValueLength;
    }

    if (Count > 0x7FFF)
    {
        // can't be bigger than 32K of user parms.
        status = STATUS_BUFFER_OVERFLOW;
        goto Error;
    }

    try {

        status = UserPropertyAllocBlock( &uniUserParms,
                                         Count,
                                         &uniNewUserParms );
    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  if we can't copy the current UserParameters, we loose the whole thing.
        //

        UserParms = NULL;
        uniUserParms.Buffer = UserParms;
        uniUserParms.Length = 0;
        uniUserParms.MaximumLength = uniUserParms.Length;

        Count = sizeof( USER_PROPERTIES_HDR ) + sizeof(WCHAR);
        if (ValueLength > 0) {
            Count += sizeof( USER_PROPERTY ) + PropertyLength + ValueLength;
        }

        status = UserPropertyAllocBlock( &uniUserParms,
                                         Count,
                                         &uniNewUserParms );
    }

    if ( !NT_SUCCESS(status) ) {
        goto Error;
    }

    // Make the output pNewUserParms point to uniNewUserPams's buffer
    // which is the new UserParms string.

    *pNewUserParms = uniNewUserParms.Buffer;

    UserProperties = (PUSER_PROPERTIES) uniNewUserParms.Buffer;

    try {

        if (FindUserProperty (UserProperties,
                              Property,
                              &UserProperty,
                              &Count))
        {
            RemoveUserProperty ( &uniNewUserParms,
                                 UserProperty,
                                 Count,
                                 Update);
        }
    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  we have corrupted user parms here... get rid of them.
        //

        *Update = TRUE;

        if (*pNewUserParms != NULL) {
            LocalFree( *pNewUserParms );
        }
        *pNewUserParms = NULL;
        status = STATUS_INVALID_PARAMETER;
    }

    if ( !NT_SUCCESS(status) ) {
        goto Error;
    }

    //
    //  If the new value of the property is not null, add it.
    //

    if (ValueLength > 0) {

        try {

            // find the end of the parameters list

            UserProperty = &(UserProperties->FirstProperty);

            for (Count = 1; Count <= UserProperties->Header.PropertyCount; Count++)
            {
                UserProperty = (PUSER_PROPERTY)
                                   ((LPSTR)((LPSTR) UserProperty +
                                         sizeof(USER_PROPERTY) + // length of entry
                                         UserProperty->PropertyLength +
                                         UserProperty->ValueLength -
                                         sizeof(WCHAR)));  // for Property[0]
            }

            //
            // append it to the end and update length of string
            //

            UserProperty->PropertyFlag   = PropertyFlag;

            UserProperty->PropertyLength = PropertyLength;
            UserProperty->ValueLength    = ValueLength;

            RtlCopyMemory(  &(UserProperty->Property[0]),
                            Property,
                            PropertyLength );

            RtlCopyMemory(  &(UserProperty->Property[PropertyLength / sizeof(WCHAR)]),
                            PropertyValueString,
                            ValueLength );

            uniNewUserParms.Length +=
                            sizeof(USER_PROPERTY) + // length of entry
                            PropertyLength +    // length of property name string
                            ValueLength -       // length of value string
                            sizeof(WCHAR);      // account for WCHAR Property[1]

            UserProperties->Header.PropertyCount++;

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            //
            //  we have corrupted user parms here... get rid of them.
            //

            if (*pNewUserParms != NULL) {
                LocalFree( *pNewUserParms );
            }
            *pNewUserParms = NULL;
            status = STATUS_INVALID_PARAMETER;
        }
        *Update = TRUE;
    }
    
Error:

    if (NULL != PropertyValueString)
    {
        LocalFree(PropertyValueString);
    }

    // UserParms is already null terminated. We don't need to set the
    // end of UserParms to be NULL since we zero init the buffer already.

    return( status );
}

NTSTATUS
SetUserPropertyWithLength (
    IN PUNICODE_STRING UserParms,
    IN LPWSTR          Property,
    IN PUNICODE_STRING PropertyValue,
    IN WCHAR           PropertyFlag,
    OUT LPWSTR        *pNewUserParms,   // memory has to be freed afer use.
    OUT BOOL          *Update
    )
/*
    This function sets a property field in the user's Parameters field.
*/
{
    NTSTATUS status;
    UNICODE_STRING newUserParms;
    ULONG length;
    PWCHAR ptr;

    length = UserParms->Length;

    if (UserParms->MaximumLength < length + sizeof(WCHAR)) {

        //
        //  have to realloc
        //
        
        newUserParms.Buffer = UserParms->Buffer;
        newUserParms.Length =
                    newUserParms.MaximumLength =
                    (USHORT) ( length + sizeof(WCHAR) );

        newUserParms.Buffer = LocalAlloc (LPTR, newUserParms.Length);

        if (newUserParms.Buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(  newUserParms.Buffer,
                        UserParms->Buffer,
                        length );

    } else {

        newUserParms.Buffer = UserParms->Buffer;
        newUserParms.Length = (USHORT) length;
        newUserParms.MaximumLength = UserParms->MaximumLength;
    }

    //
    //  Slap in null terminator
    //

    ptr = newUserParms.Buffer + ( length / sizeof(WCHAR) );
    *ptr = L'\0';

    status = SetUserProperty(   newUserParms.Buffer,
                                Property,
                                PropertyValue,
                                PropertyFlag,
                                pNewUserParms,
                                Update );

    if (newUserParms.Buffer != UserParms->Buffer) {

        LocalFree( newUserParms.Buffer );
    }

    return(status);
}

#define MAPHEXTODIGIT(x) ( x >= '0' && x <= '9' ? (x-'0') :        \
                           x >= 'A' && x <= 'F' ? (x-'A'+10) :     \
                           x >= 'a' && x <= 'f' ? (x-'a'+10) : 0 )


NTSTATUS
QueryUserProperty (
    IN  LPWSTR          UserParms,
    IN  LPWSTR          PropertyName,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    )
/*
    This routine returns a user definable property value as it is stored
    in the user's Parameters field.  Note that the RAS/MAC fields are
    stripped before we start processing user properties.
*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    USHORT          PropertyNameLength;
    USHORT          Count;
    PUSER_PROPERTY  UserProperty;
    WCHAR          *Value;
    UINT            i;
    CHAR           *PropertyValueString = NULL;
    CHAR           *pchValue;

    // Set PropertyValue->Length to 0 initially. If the property is not found
    // it will still be 0 on exit.

    PropertyValue->Length = 0;
    PropertyValue->Buffer = NULL;

    try {

        PropertyNameLength = (USHORT)(lstrlenW(PropertyName) * sizeof(WCHAR));

        // Check if UserParms have the right structure.

        if (FindUserProperty ((PUSER_PROPERTIES) UserParms,
                              PropertyName,
                              &UserProperty,
                              &Count) ) {

            Value = (LPWSTR)(LPSTR)((LPSTR) &(UserProperty->Property[0]) +
                                              PropertyNameLength);

            //
            //  Found the requested property
            //

            //
            //  Copy the property flag.
            //

            if (PropertyFlag) {
                *PropertyFlag = UserProperty->PropertyFlag;
            }

            // Allocate memory for PropertyValue->Buffer

            PropertyValueString = LocalAlloc ( LPTR, UserProperty->ValueLength+1);
            PropertyValue->Buffer = LocalAlloc ( LPTR, UserProperty->ValueLength/sizeof(WCHAR));

            //
            //  Make sure the property value length is valid.
            //
            if ((PropertyValue->Buffer == NULL) || (PropertyValueString == NULL)) {

                status = STATUS_INSUFFICIENT_RESOURCES;

                if (PropertyValue->Buffer != NULL) {
                    LocalFree( PropertyValue->Buffer );
                    PropertyValue->Buffer = NULL;
                }

            } else {

                //
                //  Copy the property value to the buffer.
                //

                RtlCopyMemory( PropertyValueString,
                               Value,
                               UserProperty->ValueLength );

                pchValue = (CHAR *) PropertyValue->Buffer;

                // Convert from value unicode string to value.
                for (i = 0; i < UserProperty->ValueLength/sizeof(WCHAR) ; i++)
                {
                     // sscanf will trash memory.
                     // sscanf( PropertyValueString+2*i, "%2x", pchValue+i);

                     pchValue[i] = MAPHEXTODIGIT( PropertyValueString[2*i]) * 16 +
                                   MAPHEXTODIGIT( PropertyValueString[2*i+1]);
                }

                PropertyValue->Length = UserProperty->ValueLength/sizeof(WCHAR);
                PropertyValue->MaximumLength = UserProperty->ValueLength/sizeof(WCHAR);
            }
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  we have corrupted user parms here... can't return a decent value
        //

        if (PropertyValue->Buffer != NULL) {
            LocalFree( PropertyValue->Buffer );
            PropertyValue->Buffer = NULL;
        }

        PropertyValue->Length = 0;
        status = STATUS_INVALID_PARAMETER;
    }

    if ( PropertyValueString != NULL ) {
        LocalFree( PropertyValueString);
    }

    return status;
}

NTSTATUS
QueryUserPropertyWithLength (
    IN  PUNICODE_STRING UserParms,
    IN  LPWSTR          PropertyName,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    )
/*
    This routine returns a user definable property value as it is stored
    in the user's Parameters field.  Note that the RAS/MAC fields are
    stripped before we start processing user properties.
*/
{
    NTSTATUS status;
    UNICODE_STRING newUserParms;
    ULONG length;
    PWCHAR ptr;

    length = UserParms->Length;

    if (UserParms->MaximumLength < length + sizeof(WCHAR)) {

        //
        //  have to realloc
        //

        newUserParms.Buffer = UserParms->Buffer;
        newUserParms.Length =
                    newUserParms.MaximumLength =
                    (USHORT) (length + sizeof(WCHAR) );

        newUserParms.Buffer = LocalAlloc (LPTR, newUserParms.Length);

        if (newUserParms.Buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(  newUserParms.Buffer,
                        UserParms->Buffer,
                        length );

    } else {

        newUserParms.Buffer = UserParms->Buffer;
        newUserParms.Length = (USHORT) length;
        newUserParms.MaximumLength = UserParms->MaximumLength;
    }

    //
    //  Slap in null terminator
    //

    ptr = newUserParms.Buffer + ( length / sizeof(WCHAR) );
    *ptr = L'\0';

    status = QueryUserProperty( newUserParms.Buffer,
                                PropertyName,
                                PropertyFlag,
                                PropertyValue );

    if (newUserParms.Buffer != UserParms->Buffer) {

        LocalFree( newUserParms.Buffer );
    }

    return(status);
}

// Common routine used by QueryUserProperty() and SetUserProperty().

BOOL
FindUserProperty (
    PUSER_PROPERTIES UserProperties,
    LPWSTR           Property,
    PUSER_PROPERTY  *pUserProperty,
    USHORT          *pCount
    )
{
    BOOL   fFound = FALSE;
    USHORT PropertyLength;

    //
    // Check if user has valid property structure attached,
    // pointed to by UserProperties.
    //

    if (  ( UserProperties != NULL )
       && ( lstrlenW( (LPWSTR) UserProperties) * sizeof(WCHAR) >
            sizeof(UserProperties->Header.BacklevelParms))
       && ( UserProperties->Header.PropertySignature == USER_PROPERTY_SIGNATURE)
       )
    {
        //
        // user has valid property structure.
        //

        *pUserProperty = &(UserProperties->FirstProperty);

        PropertyLength = (USHORT)(lstrlenW( Property ) * sizeof(WCHAR));

        for ( *pCount = 1; *pCount <= UserProperties->Header.PropertyCount;
              (*pCount)++ )
        {
            if (  ( PropertyLength == (*pUserProperty)->PropertyLength )
               && ( RtlCompareMemory( &((*pUserProperty)->Property[0]),
                                      Property,
                                      PropertyLength ) == PropertyLength )
               )
            {
                fFound = TRUE;
                break;
            }

            *pUserProperty = (PUSER_PROPERTY)
                                     ((LPSTR) (*pUserProperty)
                                     + sizeof( USER_PROPERTY )
                                     + (*pUserProperty)->PropertyLength
                                     + (*pUserProperty)->ValueLength
                                     - sizeof(WCHAR));  // for Property[0]
        }
    }

    return( fFound );
}


// Remove a property field from the User Parms.

VOID
RemoveUserProperty (
    UNICODE_STRING *puniUserParms,
    PUSER_PROPERTY  UserProperty,
    USHORT          Count,
    BOOL           *Update
    )
{
    PUSER_PROPERTIES    UserProperties;
    PUSER_PROPERTY      NextProperty;
    USHORT              OldParmLength;
    USHORT              LengthToMove = 0;

    UserProperties = (PUSER_PROPERTIES) puniUserParms->Buffer;

    OldParmLength = sizeof( USER_PROPERTY ) +
                    UserProperty->PropertyLength +
                    UserProperty->ValueLength -
                    sizeof(WCHAR);  // for Property[0]


    NextProperty = (PUSER_PROPERTY)(LPSTR)((LPSTR) UserProperty + OldParmLength);

    //
    // if we're not on the last one, copy the remaining buffer up
    //

    if (Count < UserProperties->Header.PropertyCount) {


        LengthToMove = puniUserParms->Length - 
                       (USHORT) ((LPSTR)NextProperty - (LPSTR)puniUserParms->Buffer);

        RtlMoveMemory(  UserProperty,
                        NextProperty,
                        LengthToMove );
    }

    //
    // Zero the space occurpaied by the removed property. 
    // Otherwise, we will always carry these memory and save them into permenent 
    // storage.
    // 
    ASSERT(((LPSTR)UserProperty + LengthToMove + OldParmLength) == ((LPSTR)puniUserParms->Buffer + puniUserParms->Length)); 
    RtlZeroMemory((LPSTR)UserProperty + LengthToMove,  OldParmLength);

    //
    //  Now reduce the length of the buffer by the amount we pulled out
    //

    puniUserParms->Length -= OldParmLength;

    UserProperties->Header.PropertyCount--;

    *Update = TRUE;
}


NTSTATUS
UserPropertyAllocBlock (
    IN PUNICODE_STRING     Existing,
    IN ULONG               DesiredLength,
    IN OUT PUNICODE_STRING New
    )
/*
    This allocates a larger block for user's parameters and copies the old
    block in.
*/
{
    PUSER_PROPERTIES    UserProperties;
    CLONG               Count;
    WCHAR               *pNewBuff;


    //
    //  We will allocate a new buffer to store the new parameters
    //  and copy the existing parameters into it.
    //

    New->Buffer = LocalAlloc (LPTR, DesiredLength);

    if ( New->Buffer == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    New->MaximumLength = (USHORT) DesiredLength;

    if (Existing != NULL)
    {

        New->Length = Existing->Length;

        RtlCopyMemory(  New->Buffer,
                        Existing->Buffer,
                        Existing->Length );
    }
    else
    {
        New->Length = 0;
    }

    //
    //  Ensure that we don't have any nulls in our string.
    //

    for ( Count = 0;
          Count < New->Length / sizeof(WCHAR);
          Count++ )
    {
        if (*(New->Buffer + Count) == L'\0')
        {
            New->Length = (USHORT) Count * sizeof(WCHAR);
            break;
        }
    }

    //
    //  now pad it out with spaces until reached Mac+Ras reserved length
    //

    pNewBuff = (WCHAR *) New->Buffer + ( New->Length / sizeof(WCHAR) );

    while ( New->Length < sizeof(UserProperties->Header.BacklevelParms))
    {
        *( pNewBuff++ ) = L' ';
        New->Length += sizeof(WCHAR);
    }

    //
    //  If the signature isn't there, stick it in and set prop count to 0
    //

    UserProperties = (PUSER_PROPERTIES) New->Buffer;

    if (New->Length < sizeof(USER_PROPERTIES_HDR) ||
        UserProperties->Header.PropertySignature != USER_PROPERTY_SIGNATURE)
    {

        UserProperties->Header.PropertySignature = USER_PROPERTY_SIGNATURE;
        UserProperties->Header.PropertyCount = 0;

        New->Length = sizeof(USER_PROPERTIES_HDR);
    }

    return STATUS_SUCCESS;
}

// usrprop.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\usrprop.h ===
/*++

Copyright (c) 1993-1995, Microsoft Corp. All rights reserved.

Module Name:

    usrprop.h

Abstract:

    This is the public include file for some of the functions used by
    User Manager and Server Manager.

Author:

    Congpa You 02-Dec-1993  Created.

Revision History:

--*/

#ifndef _USRPROP_H_
#define _USRPROP_H_


NTSTATUS
SetUserProperty (
    IN LPWSTR             UserParms,
    IN LPWSTR             Property,
    IN PUNICODE_STRING    PropertyValue,
    IN WCHAR              PropertyFlag,
    OUT LPWSTR *          pNewUserParms,       // memory has to be freed afer use.
    OUT BOOL *            Update
    );

NTSTATUS
SetUserPropertyWithLength (
    IN PUNICODE_STRING    UserParms,
    IN LPWSTR             Property,
    IN PUNICODE_STRING    PropertyValue,
    IN WCHAR              PropertyFlag,
    OUT LPWSTR *          pNewUserParms,       // memory has to be freed afer use.
    OUT BOOL *            Update
    );

NTSTATUS
QueryUserProperty (
    IN  LPWSTR          UserParms,
    IN  LPWSTR          Property,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    );

NTSTATUS
QueryUserPropertyWithLength (
    IN  PUNICODE_STRING UserParms,
    IN  LPWSTR          Property,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    );

#define USER_PROPERTY_SIGNATURE     L'P'
#define USER_PROPERTY_TYPE_ITEM     1
#define USER_PROPERTY_TYPE_SET      2

#endif // _USRPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\utility.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    utility.c

Abstract:

    This file contains utility services used by several other SAM files.

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:

  6-11-96: MURLIS  Added logic to branch between registry/ DS cases
  6-16-96: MURLIS  Added  Logic to Open Account/ Adjust Account counts
    16-Aug-96   ChrisMay
        Changed SampShutdownNotify to shutdown the DS.
    08-Oct-1996 ChrisMay
        Added crash-recovery code.
    31-Jan-1997 ChrisMay
        Added RID manager termination code to SampShutdownNotification.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dsutilp.h>
#include <dslayer.h>
#include <dsmember.h>
#include <attids.h>
#include <mappings.h>
#include <ntlsa.h>
#include <nlrepl.h>
#include <dsevent.h>             // (Un)ImpersonateAnyClient()
#include <sdconvrt.h>
#include <ridmgr.h>
#include <malloc.h>
#include <setupapi.h>
#include <crypt.h>
#include <wxlpc.h>
#include <rc4.h>
#include <md5.h>
#include <enckey.h>
#include <rng.h>
#include <dnsapi.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Globals                                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// SampShutdownNotification is called during system shutdown. If this is a DC
// and Shutdown has not been set, the DsUninitialize routine will be executed
// and resets Shutdown to TRUE to prevent multiple calls to SampShutdownNot-
// ification from calling DsUninitialize more than once.

BOOLEAN SampDatabaseHasAlreadyShutdown = FALSE;

//
// Table for Events which should not be written to setup log.
//

ULONG   EventsNotInSetupTable[] =
{
    SAMMSG_RID_MANAGER_INITIALIZATION,
    SAMMSG_RID_POOL_UPDATE_FAILED,
    SAMMSG_GET_NEXT_RID_ERROR,
    SAMMSG_NO_RIDS_ASSIGNED,
    SAMMSG_MAX_DOMAIN_RID,
    SAMMSG_MAX_DC_RID,
    SAMMSG_INVALID_RID,
    SAMMSG_REQUESTING_NEW_RID_POOL,
    SAMMSG_RID_REQUEST_STATUS_SUCCESS,
    SAMMSG_RID_REQUEST_STATUS_FAILURE,
    SAMMSG_RID_MANAGER_CREATION,
    SAMMSG_RID_INIT_FAILURE
};

//
// The list of Invalid Down Level Chars for SAM account Names
//

WCHAR InvalidDownLevelChars[] = TEXT("\"/\\[]:|<>+=;?,*")
                                TEXT("\001\002\003\004\005\006\007")
                                TEXT("\010\011\012\013\014\015\016\017")
                                TEXT("\020\021\022\023\024\025\026\027")
                                TEXT("\030\031\032\033\034\035\036\037");

//
// The maximum length of account names for NT4 Compatibility
//

const ULONG MAX_DOWN_LEVEL_NAME_LENGTH = SAMP_MAX_DOWN_LEVEL_NAME_LENGTH;




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Imports                                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SampDsMakeAttrBlock(
    IN INT ObjectType,
    IN ULONG AttributeGroup,
    IN ULONG WhichFields,
    OUT PDSATTRBLOCK AttrBlock
    );

PVOID
DSAlloc(
    IN ULONG Length
    );

NTSTATUS
SampDsConvertReadAttrBlock(
    IN INT ObjectType,
    IN ULONG AttributeGroup,
    IN PDSATTRBLOCK AttrBlock,
    OUT PVOID *SamAttributes,
    OUT PULONG FixedLength,
    OUT PULONG VariableLength
    );

NTSTATUS
SampDsUpdateContextAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup,
    IN PVOID SamAttributes,
    IN ULONG FixedLength,
    IN ULONG VariableLength
    );

NTSTATUS
SampDsCheckObjectTypeAndFillContext(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PSAMP_OBJECT NewContext,
    IN ULONG        WhichFields,
    IN ULONG        ExtendedFields,
    IN  BOOLEAN  OverrideLocalGroupCheck
    );

//
// This function is defined in kdcexp.h. However including this requires
// a security header cleanup ( kdcexp.h is in security\kerberos\inc and
// also drags in a bunch of kerberos headers, so define the function in
// here
//

NTSTATUS
KdcAccountChangeNotification (
    IN PSID DomainSid,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN OPTIONAL PUNICODE_STRING ObjectName,
    IN PLARGE_INTEGER ModifiedCount,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampRefreshRegistry(
    VOID
    );

NTSTATUS
SampRetrieveAccountCountsRegistry(
    OUT PULONG UserCount,
    OUT PULONG GroupCount,
    OUT PULONG AliasCount
    );


NTSTATUS
SampAdjustAccountCountRegistry(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Increment
    );



NTSTATUS
SampEnforceDownlevelNameRestrictions(
    PUNICODE_STRING NewAccountName,
    SAMP_OBJECT_TYPE ObjectType
    );


VOID
SampFlushNetlogonChangeNumbers();

BOOLEAN
SampEventIsInSetup(
    IN  ULONG   EventID
    );

VOID
SampWriteToSetupLog(
    IN     USHORT      EventType,
    IN     USHORT      EventCategory   OPTIONAL,
    IN     ULONG       EventID,
    IN     PSID        UserSid         OPTIONAL,
    IN     USHORT      NumStrings,
    IN     ULONG       DataSize,
    IN     PUNICODE_STRING *Strings    OPTIONAL,
    IN     PVOID       Data            OPTIONAL
    );


NTSTATUS
SampSetMachineAccountOwner(
    IN PSAMP_OBJECT UserContext,
    IN PSID NewOwner
    );

NTSTATUS
SampCheckQuotaForPrivilegeMachineAccountCreation(
    VOID
    );

#define IS_DELIMITER(c,_BlankOk) \
    (((c) == L' ' && (_BlankOk)) || \
    ((c) == L'\t') || ((c) == L',') || ((c) == L';'))



ULONG
SampNextElementInUIList(
    IN OUT PWSTR* InputBuffer,
    IN OUT PULONG InputBufferLength,
    OUT PWSTR OutputBuffer,
    IN ULONG OutputBufferLength,
    IN BOOLEAN BlankIsDelimiter
    );



///////////////////////////////////////////////////////////////////////
//                                                                   //
//          Comments on the useage of SampTransactionWithinDomain    // 
//                                                                   //
///////////////////////////////////////////////////////////////////////

/*++


    SampTransactionWithinDomain and SampTransactionDomainIndex are 
    used by clients to access SAM data structure and backing store.   
    It also sets the scope of the SAM transaction. SampSetTransactionDomain()
    must be called if any domain-specific information is to be modified
    during a transaction. Clients need to hold SAM lock to set 
    TransactionDomain and use SampTransactionDomainIndex. 
    

    For loopback clients, no domain-specific information will be 
    modified, so no need to set Transaction Domain and 
    SampTransactionDomainIndex, plus loopback client doesn't hold 
    SAM lock, so can't use SampTransactionDomainIndex either. 
    However loopback client can use AccountContext->DomainIndex 
    to access (read) domain related info.

    
    For all the other clients, they need to acquire SAM lock before 
    setting TransactionDomain. Once TransactionDomain is set, clients
    can free to modify domain-specific information. 

    There are two sets of APIs, one to set TransactionDomainIndex, the
    other is used to set TransactionWithinDomain Flag. 

    1. SampSetTransactionDomain() is used to set SampTransactionDomainIndex. 
       Also it will turn on SampTransactionWithinDomainGlobal flag. If any 
       thread sets a domain for a transaction and modifies the domain info
       during the transaction, the domain modification count will be updated
       upon commit. In memory copy of domain info will also be updated. 

       SampTransactionDomainIndexFn() is used to return the domain index 
       of the current transaction. 
       
    2. SampSetTransactionWithinDomain() and SampTransactionWithinDomainFn()
       are used to set and retrieve the value of 
       SampTransactionWithinDomainGlobal.

    
    Correct calling sequence
        
        SampAcquireReadLock()  or SampAcquireWriteLock()
        Begin a transaction
        ASSERT(SampTransactionWithinDomain == FALSE) or
                SampSetTransactionWithinDomain(FALSE) 
        SampSetTransactionDomain()
        Access SAM data structure and backing store
        Commit or Abort this transaction        
        SampReleaseReadLock() or SampReleaseWriteLock()
          
--*/

VOID
SampSetTransactionDomain(
    IN ULONG DomainIndex
    )

/*++

Routine Description:

    This routine sets a domain for a transaction.  This must be done
    if any domain-specific information is to be modified during a transaction.
    In this case, the domain modification count will be updated upon commit.

    This causes the UnmodifiedFixed information for the specified domain to
    be copied to the CurrentFixed field for the in-memory representation of
    that domain.


Arguments:

    DomainIndex - Index of the domain within which this transaction
        will occur.


Return Value:

    STATUS_SUCCESS - Indicates the write lock was acquired and the transaction
        was successfully started.

    Other values may be returned as a result of failure to initiate the
    transaction.  These include any values returned by RtlStartRXact().



--*/
{

    SAMTRACE("SampSetTransactionDomain");


    ASSERT((SampCurrentThreadOwnsLock())||(SampServiceState==SampServiceInitializing));
    ASSERT(SampTransactionWithinDomain == FALSE);

    SampSetTransactionWithinDomain(TRUE);
    SampTransactionDomainIndexGlobal =  DomainIndex;

    //
    //  The data in the defined domains structure better be valid at this time
    //

    ASSERT(SampDefinedDomains[SampTransactionDomainIndex].FixedValid == TRUE);

    SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed =
    SampDefinedDomains[SampTransactionDomainIndex].UnmodifiedFixed;


    return;

}

ULONG
SampTransactionDomainIndexFn()
/*++

Routine Description:

    this routine returns the domain index of the current transaction.

    The caller must hold SAM lock to reference this global variable.

Return Value:

    domain index of current transcation.

--*/
{
    ASSERT((SampCurrentThreadOwnsLock())||(SampServiceState==SampServiceInitializing));
    return(SampTransactionDomainIndexGlobal);
}

BOOLEAN
SampTransactionWithinDomainFn()
/*++

Routine Description:

    This routine reports whehter TransactionDomain is set or not.

    Only threads holding SAM lock can check the exact state. Clients
    without lock will always get FALSE.   

--*/
{
    if (SampCurrentThreadOwnsLock())
        return(SampTransactionWithinDomainGlobal);
    else
        return(FALSE);
}

VOID
SampSetTransactionWithinDomain(
    IN BOOLEAN  WithinDomain
    )
/*++

Routine Description:

    This routine set/reset the global flag SampTransactionWithinDomainGlobal
    to indicate whether any domain-specific information can be retrieved 
    or modified during a transaction. 
    
    Only clients with SAM lock can set / reset this global.

--*/
{
    if (SampCurrentThreadOwnsLock())
    {
        SampTransactionWithinDomainGlobal = WithinDomain;
    }
#ifdef DBG
    else
    {
        if (WithinDomain)
        {
            ASSERT(FALSE && "SAM Lock is not held");
        }
        else
        {
            ASSERT(FALSE && "SAM Lock is not held");
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAM: Should Not Set it to FALSE\n"));
        }
    }
#endif  // DBG
}



NTSTATUS
SampFlushThread(
    IN PVOID ThreadParameter
    )

/*++

Routine Description:

    This thread is created when SAM's registry tree is changed.
    It will sleep for a while, and if no other changes occur,
    flush the changes to disk.  If other changes keep occurring,
    it will wait for a certain amount of time and then flush
    anyway.

    After flushing, the thread will wait a while longer.  If no
    other changes occur, it will exit.

    Note that if any errors occur, this thread will simply exit
    without flushing.  The mainline code should create another thread,
    and hopefully it will be luckier.  Unfortunately, the error is lost
    since there's nobody to give it to that will be able to do anything
    about it.

Arguments:

    ThreadParameter - not used.

Return Value:

    None.

--*/

{
    TIME minDelayTime, maxDelayTime, exitDelayTime;
    LARGE_INTEGER startedWaitLoop;
    LARGE_INTEGER currentTime;
    NTSTATUS NtStatus;
    BOOLEAN Finished = FALSE;

    UNREFERENCED_PARAMETER( ThreadParameter );

    SAMTRACE("SampFlushThread");

    NtQuerySystemTime( &startedWaitLoop );

    //
    // It would be more efficient to use constants here, but for now
    // we'll recalculate the times each time we start the thread
    // so that somebody playing with us can change the global
    // time variables to affect performance.
    //

    minDelayTime.QuadPart = -1000 * 1000 * 10 *
                   ((LONGLONG)SampFlushThreadMinWaitSeconds);

    maxDelayTime.QuadPart = -1000 * 1000 * 10 *
                   ((LONGLONG)SampFlushThreadMaxWaitSeconds);

    exitDelayTime.QuadPart = -1000 * 1000 * 10 *
                    ((LONGLONG)SampFlushThreadExitDelaySeconds);

    do {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Flush thread sleeping\n"));

        NtDelayExecution( FALSE, &minDelayTime );

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Flush thread woke up\n"));

        NtStatus = SampAcquireWriteLock();

        if ( NT_SUCCESS( NtStatus ) ) {

#ifdef SAMP_DBG_CONTEXT_TRACKING
            SampDumpContexts();
#endif

            NtQuerySystemTime( &currentTime );

            if ( LastUnflushedChange.QuadPart == SampHasNeverTime.QuadPart ) {

                LARGE_INTEGER exitBecauseNoWorkRecentlyTime;

                //
                // No changes to flush.  See if we should stick around.
                //

                exitBecauseNoWorkRecentlyTime = SampAddDeltaTime(
                                                    startedWaitLoop,
                                                    exitDelayTime
                                                    );

                if ( exitBecauseNoWorkRecentlyTime.QuadPart < currentTime.QuadPart ) {

                    //
                    // We've waited for changes long enough; note that
                    // the thread is exiting.
                    //

                    FlushThreadCreated = FALSE;
                    Finished = TRUE;
                }

            } else {

                LARGE_INTEGER noRecentChangesTime;
                LARGE_INTEGER tooLongSinceFlushTime;

                //
                // There are changes to flush.  See if it's time to do so.
                //

                noRecentChangesTime = SampAddDeltaTime(
                                          LastUnflushedChange,
                                          minDelayTime
                                          );

                tooLongSinceFlushTime = SampAddDeltaTime(
                                            startedWaitLoop,
                                            maxDelayTime
                                            );

                if ( (noRecentChangesTime.QuadPart < currentTime.QuadPart) ||
                     (tooLongSinceFlushTime.QuadPart < currentTime.QuadPart) ) {

                    //
                    // Min time has passed since last change, or Max time
                    // has passed since last flush.  Let's flush.
                    //

                    NtStatus = NtFlushKey( SampKey );

#if SAMP_DIAGNOSTICS
                    if (!NT_SUCCESS(NtStatus)) {
                        SampDiagPrint( DISPLAY_STORAGE_FAIL,
                                       ("SAM: Failed to flush RXact (0x%lx)\n",
                                        NtStatus) );
                        IF_SAMP_GLOBAL( BREAK_ON_STORAGE_FAIL ) {
                            ASSERT(NT_SUCCESS(NtStatus));  // See following comment
                        }
                    }
#endif //SAMP_DIAGNOSTICS

                    //
                    // Under normal conditions, we would have an
                    // ASSERT(NT_SUCCESS(NtStatus)) here.  However,
                    // Because system shutdown can occur while we
                    // are waiting to flush, we have a race condition.
                    // When shutdown is made, another thread will  be
                    // notified and perform a flush.  That leaves this
                    // flush to potentially occur after the registry
                    // has been notified of system shutdown - which
                    // causes and error to be returned.  Unfortunately,
                    // the error is REGISTRY_IO_FAILED - a great help.
                    //
                    // Despite this, we will only exit this loop only
                    // if we have success.  This may cause us to enter
                    // into another wait and attempt another hive flush
                    // during shutdown, but the wait should never finish
                    // (unless shutdown takes more than 30 seconds).  In
                    // other error situations though, we want to keep
                    // trying the flush until we succeed.   Jim Kelly
                    //


                    if ( NT_SUCCESS(NtStatus) ) {

                        LastUnflushedChange = SampHasNeverTime;
                        NtQuerySystemTime( &startedWaitLoop );

                        FlushThreadCreated = FALSE;
                        Finished = TRUE;
                    }
                }
            }

            SampReleaseWriteLock( FALSE );

        } else {

            DbgPrint("SAM: Thread failed to get write lock, status = 0x%lx\n", NtStatus);
            ASSERT( NT_SUCCESS(NtStatus) || (STATUS_NO_MEMORY == NtStatus) );

            FlushThreadCreated = FALSE;
            Finished = TRUE;
        }

    } while ( !Finished );

    return( STATUS_SUCCESS );
}

VOID
SampInvalidateDomainCache()
/*++

    Routine Description

        This Invalidates the Domain Cache


            WARNING:

            This routine must be called with the Lock held for
            exclusive access


 --*/
{
    ULONG DomainIndex;

    ASSERT(SampCurrentThreadOwnsLock());

    for (DomainIndex=SampDsGetPrimaryDomainStart();DomainIndex<SampDefinedDomainsCount;DomainIndex++)
    {
        if (SampDefinedDomains[DomainIndex].Context->OnDisk!=NULL)
            SampFreeAttributeBuffer(SampDefinedDomains[DomainIndex].Context);
        SampDefinedDomains[DomainIndex].FixedValid = FALSE;
    }
}


NTSTATUS
SampValidateDomainCache()
/*++

    Routine Description

        This Validates the Domain Cache  for all the domains


            WARNING:

            This routine must be called with the Lock held for
            exclusive access


 --*/

{

    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN FixedAttributes = NULL;
    ULONG DomainIndex;
    BOOLEAN MixedDomain = TRUE;
    ULONG   BehaviorVersion = 0;
    ULONG   LastLogonTimeStampSyncInterval;
    BOOLEAN fObtainedDomainSettings = FALSE;

    ASSERT(SampCurrentThreadOwnsLock());

    
    for (DomainIndex=0;DomainIndex<SampDefinedDomainsCount;DomainIndex++)
    {
        if (
            (IsDsObject(SampDefinedDomains[DomainIndex].Context))
            && (!(SampDefinedDomains[DomainIndex].FixedValid))
            )
        {
            //
            // In DS Mode read the mixed domain/behavior version information
            //

            if ((SampUseDsData) &&(!fObtainedDomainSettings))
            {
                NtStatus = SampGetDsDomainSettings(
                                    &MixedDomain,
                                    &BehaviorVersion, 
                                    &LastLogonTimeStampSyncInterval
                                    );
                if (!NT_SUCCESS(NtStatus))
                {
                    return(NtStatus);
                }

                fObtainedDomainSettings = TRUE;
            }

            //
            // For Ds case if Domain Cache is invalid then read the data back
            //
            //

            NtStatus = SampGetFixedAttributes(SampDefinedDomains[DomainIndex].Context,
                                FALSE,
                                (PVOID *)&FixedAttributes
                                );

            //
            // The validate call has to succeed, or if we cannot access the domain object
            // then we are in dire straights anyway. After TP this routine should be made
            // to return a return code and references to this will need to be patched up.
            //

            if (NT_SUCCESS(NtStatus))
            {

                //
                // Update the current fixed and unmodified fixed fields from
                // the data just read from disk
                //

                RtlCopyMemory(
                    &(SampDefinedDomains[DomainIndex].CurrentFixed),
                    FixedAttributes,
                    sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN)
                    );

                RtlCopyMemory(
                    &(SampDefinedDomains[DomainIndex].UnmodifiedFixed),
                    FixedAttributes,
                    sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN)
                    );

                SampDefinedDomains[DomainIndex].CurrentFixed.ServerRole =
                        SampDefinedDomains[DomainIndex].ServerRole;

                SampDefinedDomains[DomainIndex].UnmodifiedFixed.ServerRole =
                        SampDefinedDomains[DomainIndex].ServerRole;

                SampDefinedDomains[DomainIndex].FixedValid = TRUE;

                SampDefinedDomains[DomainIndex].IsMixedDomain = MixedDomain;

                SampDefinedDomains[DomainIndex].BehaviorVersion = BehaviorVersion;

                SampDefinedDomains[DomainIndex].LastLogonTimeStampSyncInterval =
                                                    LastLogonTimeStampSyncInterval;
            }
            else
            {
                break;
            }
        }
    }

    return NtStatus;

}

NTSTATUS
SampValidateDomainCacheCallback(PVOID UnReferencedParameter)
{
  NTSTATUS Status = STATUS_SUCCESS;


  SampAcquireSamLockExclusive();

  Status = SampMaybeBeginDsTransaction(TransactionRead);

  if (NT_SUCCESS(Status))
  {
      Status = SampValidateDomainCache();
  }

  SampMaybeEndDsTransaction(TransactionCommit);
  
  SampReleaseSamLockExclusive();

  if (!NT_SUCCESS(Status))
  {
      LsaIRegisterNotification(
                         SampValidateDomainCacheCallback,
                         NULL,
                         NOTIFIER_TYPE_INTERVAL,
                         0,            // no class
                         NOTIFIER_FLAG_ONE_SHOT,
                         600,        // wait for 10 mins
                         NULL        // no handle
                         );
  }

  return(Status);

}





NTSTATUS
SampCommitChangesToRegistry(
                            BOOLEAN * AbortDone
                            )
/*++
    Description:

      Commits the changes to the Registry.

    Parameters

          AbortDone -- Indicates that an error ocurred and in
                       the process of error handling aborted the
                       transaction
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    NTSTATUS    IgnoreStatus = STATUS_SUCCESS;


    if ( ( !FlushImmediately ) && ( !FlushThreadCreated ) )
    {

        HANDLE Thread;
        DWORD Ignore;

        //
        // If we can't create the flush thread, ignore error and
        // just flush by hand below.
        //

        Thread = CreateThread(
                     NULL,
                     0L,
                     (LPTHREAD_START_ROUTINE)SampFlushThread,
                     NULL,
                     0L,
                     &Ignore
                     );

        if ( Thread != NULL )
        {

            FlushThreadCreated = TRUE;
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "Flush thread created, handle = 0x%lx\n",
                       Thread));

            CloseHandle(Thread);
        }
    }

    NtStatus = RtlApplyRXactNoFlush( SampRXactContext );

#if SAMP_DIAGNOSTICS
    if (!NT_SUCCESS(NtStatus))
    {
        SampDiagPrint( DISPLAY_STORAGE_FAIL,
                       ("SAM: Failed to apply RXact without flush (0x%lx)\n",
                       NtStatus) );
        IF_SAMP_GLOBAL( BREAK_ON_STORAGE_FAIL )
        {
            ASSERT(NT_SUCCESS(NtStatus));

        }
    }
#endif //SAMP_DIAGNOSTICS


    if ( NT_SUCCESS(NtStatus) )
    {

        if ( ( FlushImmediately ) || ( !FlushThreadCreated ) )
        {

            NtStatus = NtFlushKey( SampKey );

#if SAMP_DIAGNOSTICS
            if (!NT_SUCCESS(NtStatus))
            {
                SampDiagPrint( DISPLAY_STORAGE_FAIL,
                               ("SAM: Failed to flush RXact (0x%lx)\n",
                               NtStatus) );
                IF_SAMP_GLOBAL( BREAK_ON_STORAGE_FAIL )
                {
                    ASSERT(NT_SUCCESS(NtStatus));
                }
             }
#endif //SAMP_DIAGNOSTICS

             if ( NT_SUCCESS( NtStatus ) )
             {
                FlushImmediately = FALSE;
                LastUnflushedChange = SampHasNeverTime;
             }

        }
        else
        {
            NtQuerySystemTime( &LastUnflushedChange );
        }


        //
        // Commit successful, set our unmodified to now be the current...
        //

        if (NT_SUCCESS(NtStatus))
        {
            if (SampTransactionWithinDomain == TRUE)
            {
                SampDefinedDomains[SampTransactionDomainIndex].UnmodifiedFixed =
                    SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed;
            }
        }

    }
    else
    {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Failed to commit changes to registry, status = 0x%lx\n",
                   NtStatus));

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Restoring database to earlier consistent state\n"));

            //
            // Add an entry to the event log
            //

        SampWriteEventLog(
                    EVENTLOG_ERROR_TYPE,
                    0,  // Category
                    SAMMSG_COMMIT_FAILED,
                    NULL, // User Sid
                    0, // Num strings
                    sizeof(NTSTATUS), // Data size
                    NULL, // String array
                    (PVOID)&NtStatus // Data
                    );

            //
            // The Rxact commital failed. We don't know how many registry
            // writes were done for this transaction. We can't guarantee
            // to successfully back them out anyway so all we can do is
            // back out all changes since the last flush. When this is done
            // we'll be back to a consistent database state although recent
            // apis that were reported as succeeding will be 'undone'.
            //

        IgnoreStatus = SampRefreshRegistry();

        if (!NT_SUCCESS(IgnoreStatus))
        {

            //
            // This is very serious. We failed to revert to a previous
            // database state and we can't proceed.
            // Shutdown SAM operations.
            //

            SampServiceState = SampServiceTerminating;

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAM: Failed to refresh registry, SAM has shutdown\n"));

            //
            // Add an entry to the event log
            //

            SampWriteEventLog(
                        EVENTLOG_ERROR_TYPE,
                        0,  // Category
                        SAMMSG_REFRESH_FAILED,
                        NULL, // User Sid
                        0, // Num strings
                        sizeof(NTSTATUS), // Data size
                        NULL, // String array
                        (PVOID)&IgnoreStatus // Data
                        );

        }


        //
        // Now all open contexts are invalid (contain invalid registry
        // handles). The in memory registry handles have been
        // re-opened so any new contexts should work ok.
        //


        //
        // All unflushed changes have just been erased.
        // There is nothing to flush
        //
        // If the refresh failed it is important to prevent any further
        // registry flushes until the system is rebooted
        //

        FlushImmediately = FALSE;
        LastUnflushedChange = SampHasNeverTime;

        //
        // The refresh effectively aborted the transaction
        //
        *AbortDone = TRUE;

    }

    return NtStatus;
}



NTSTATUS
SampRefreshRegistry(
    VOID
    )

/*++

Routine Description:

    This routine backs out all unflushed changes in the registry.
    This operation invalidates any open handles to the SAM hive.
    Global handles that we keep around are closed and re-opened by
    this routine. The net result of this call will be that the database
    is taken back to a previous consistent state. All open SAM contexts
    are invalidated since they have invalid registry handles in them.

Arguments:

    STATUS_SUCCESS : Operation completed successfully

    Failure returns: We are in deep trouble. Normal operations can
                     not be resumed. SAM should be shutdown.

Return Value:

    None

--*/
{
    NTSTATUS        NtStatus;
    NTSTATUS        IgnoreStatus;
    HANDLE          HiveKey;
    BOOLEAN         WasEnabled;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING  String;
    ULONG           i;

    SAMTRACE("SampRefreshRegistry");

    //
    // Get a key handle to the root of the SAM hive
    //


    RtlInitUnicodeString( &String, L"\\Registry\\Machine\\SAM" );


    InitializeObjectAttributes(
        &ObjectAttributes,
        &String,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    SampDumpNtOpenKey((KEY_QUERY_VALUE), &ObjectAttributes, 0);

    NtStatus = RtlpNtOpenKey(
                   &HiveKey,
                   KEY_QUERY_VALUE,
                   &ObjectAttributes,
                   0
                   );

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Failed to open SAM hive root key for refresh, status = 0x%lx\n",
                   NtStatus));

        return(NtStatus);
    }


    //
    // Enable restore privilege in preparation for the refresh
    //

    NtStatus = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Failed to enable restore privilege to refresh registry, status = 0x%lx\n",
                   NtStatus));

        IgnoreStatus = NtClose(HiveKey);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        return(NtStatus);
    }


    //
    // Refresh the SAM hive
    // This should not fail unless there is volatile storage in the
    // hive or we don't have TCB privilege
    //


    NtStatus = NtRestoreKey(HiveKey, NULL, REG_REFRESH_HIVE);


    IgnoreStatus = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    IgnoreStatus = NtClose(HiveKey);
    ASSERT(NT_SUCCESS(IgnoreStatus));


    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Failed to refresh registry, status = 0x%lx\n",
                   NtStatus));

        return(NtStatus);
    }




    //
    // Now close the registry handles we keep in memory at all times
    // This effectively closes all server and domain context keys
    // since they are shared.
    //

    NtStatus = NtClose(SampKey);
    ASSERT(NT_SUCCESS(NtStatus));
    SampKey = INVALID_HANDLE_VALUE;

    for (i = 0; i<SampDefinedDomainsCount; i++ ) {
        NtStatus = NtClose(SampDefinedDomains[i].Context->RootKey);
        ASSERT(NT_SUCCESS(NtStatus));
        SampDefinedDomains[i].Context->RootKey = INVALID_HANDLE_VALUE;
    }

    //
    // Mark all domain and server context handles as invalid since they've
    // now been closed
    //

    SampInvalidateContextListKeysByObjectType(SampServerObjectType, FALSE);
    SampInvalidateContextListKeysByObjectType(SampDomainObjectType, FALSE);

    //
    // Close all account context registry handles for existing
    // open contexts
    //

    SampInvalidateContextListKeysByObjectType(SampUserObjectType, TRUE);
    SampInvalidateContextListKeysByObjectType(SampGroupObjectType, TRUE);
    SampInvalidateContextListKeysByObjectType(SampAliasObjectType, TRUE);


    //
    // Re-open the SAM root key
    //

    RtlInitUnicodeString( &String, L"\\Registry\\Machine\\Security\\SAM" );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &String,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &ObjectAttributes, 0);

    NtStatus = RtlpNtOpenKey(
                   &SampKey,
                   (KEY_READ | KEY_WRITE),
                   &ObjectAttributes,
                   0
                   );

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Failed to re-open SAM root key after registry refresh, status = 0x%lx\n",
                   NtStatus));

        ASSERT(FALSE);
        return(NtStatus);
    }

    //
    // Re-initialize the in-memory domain contexts
    // Each domain will re-initialize it's open user/group/alias contexts
    //

    for (i = 0; i<SampDefinedDomainsCount; i++ ) {

        NtStatus = SampReInitializeSingleDomain(i);

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAM: Failed to re-initialize domain %d context after registry refresh, status = 0x%lx\n",
                       i,
                       NtStatus));

            return(NtStatus);
        }
    }

    //
    // Cleanup the current transcation context
    // (It would be nice if there were a RtlDeleteRXactContext())
    //
    // Note we don't have to close the rootregistrykey in the
    // xact context since it was SampKey which we've already closed.
    //

    NtStatus = RtlAbortRXact( SampRXactContext );
    ASSERT(NT_SUCCESS(NtStatus));

    NtStatus = NtClose(SampRXactContext->RXactKey);
    ASSERT(NT_SUCCESS(NtStatus));

    //
    // Re-initialize the transaction context.
    // We don't expect there to be a partially commited transaction
    // since we're reverting to a previously consistent and committed
    // database.
    //

    NtStatus = RtlInitializeRXact( SampKey, FALSE, &SampRXactContext );
    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM: Failed to re-initialize rxact context registry refresh, status = 0x%lx\n",
                   NtStatus));

        return(NtStatus);
    }

    ASSERT(NtStatus != STATUS_UNKNOWN_REVISION);
    ASSERT(NtStatus != STATUS_RXACT_STATE_CREATED);
    ASSERT(NtStatus != STATUS_RXACT_COMMIT_NECESSARY);
    ASSERT(NtStatus != STATUS_RXACT_INVALID_STATE);

    return(STATUS_SUCCESS);
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Unicode registry key manipulation services                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SampRetrieveStringFromRegistry(
    IN HANDLE ParentKey,
    IN PUNICODE_STRING SubKeyName,
    OUT PUNICODE_STRING Body
    )

/*++

Routine Description:

    This routine retrieves a unicode string buffer from the specified registry
    sub-key and sets the output parameter "Body" to be that unicode string.

    If the specified sub-key does not exist, then a null string will be
    returned.

    The string buffer is returned in a block of memory which the caller is
    responsible for deallocating (using MIDL_user_free).



Arguments:

    ParentKey - Key to the parent registry key of the registry key
        containing the unicode string.  For example, to retrieve
        the unicode string for a key called ALPHA\BETA\GAMMA, this
        is the key to ALPHA\BETA.

    SubKeyName - The name of the sub-key whose value contains
        a unicode string to retrieve.  This field should not begin with
        a back-slash (\).  For example, to retrieve the unicode string
        for a key called ALPHA\BETA\GAMMA, the name specified by this
        field would be "BETA".

    Body - The address of a UNICODE_STRING whose fields are to be filled
        in with the information retrieved from the sub-key.  The Buffer
        field of this argument will be set to point to an allocated buffer
        containing the unicode string characters.


Return Value:


    STATUS_SUCCESS - The string was retrieved successfully.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated for the
        string to be returned in.

    Other errors as may be returned by:

            NtOpenKey()
            NtQueryInformationKey()



--*/
{

    NTSTATUS NtStatus, IgnoreStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE SubKeyHandle;
    ULONG IgnoreKeyType, KeyValueLength;
    LARGE_INTEGER IgnoreLastWriteTime;

    SAMTRACE("SampRetrieveStringFromRegistry");


    ASSERT(Body != NULL);

    //
    // Get a handle to the sub-key ...
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        SubKeyName,
        OBJ_CASE_INSENSITIVE,
        ParentKey,
        NULL
        );

    SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

    NtStatus = RtlpNtOpenKey(
                   &SubKeyHandle,
                   (KEY_READ),
                   &ObjectAttributes,
                   0
                   );

    if (!NT_SUCCESS(NtStatus)) {

        //
        // Couldn't open the sub-key
        // If it is OBJECT_NAME_NOT_FOUND, then build a null string
        // to return.  Otherwise, return nothing.
        //

        if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

            Body->Buffer = MIDL_user_allocate( sizeof(UNICODE_NULL) );
            if (Body->Buffer == NULL) {
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
            Body->Length = 0;
            Body->MaximumLength = sizeof(UNICODE_NULL);
            Body->Buffer[0] = 0;

            return( STATUS_SUCCESS );

        } else {
            return(NtStatus);
        }

    }



    //
    // Get the length of the unicode string
    // We expect one of two things to come back here:
    //
    //      1) STATUS_BUFFER_OVERFLOW - In which case the KeyValueLength
    //         contains the length of the string.
    //
    //      2) STATUS_SUCCESS - In which case there is no string out there
    //         and we need to build an empty string for return.
    //

    KeyValueLength = 0;
    NtStatus = RtlpNtQueryValueKey(
                   SubKeyHandle,
                   &IgnoreKeyType,
                   NULL,
                   &KeyValueLength,
                   &IgnoreLastWriteTime
                   );

    SampDumpRtlpNtQueryValueKey(&IgnoreKeyType,
                                NULL,
                                &KeyValueLength,
                                &IgnoreLastWriteTime);

    if (NT_SUCCESS(NtStatus)) {

        KeyValueLength = 0;
        Body->Buffer = MIDL_user_allocate( KeyValueLength + sizeof(WCHAR) ); // Length of null string
        if (Body->Buffer == NULL) {
            IgnoreStatus = NtClose( SubKeyHandle );
            ASSERT(NT_SUCCESS(IgnoreStatus));
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        Body->Buffer[0] = 0;

    } else {

        if (NtStatus == STATUS_BUFFER_OVERFLOW) {
            Body->Buffer = MIDL_user_allocate(  KeyValueLength + sizeof(WCHAR) );
            if (Body->Buffer == NULL) {
                IgnoreStatus = NtClose( SubKeyHandle );
                ASSERT(NT_SUCCESS(IgnoreStatus));
                return(STATUS_INSUFFICIENT_RESOURCES);
            }
            NtStatus = RtlpNtQueryValueKey(
                           SubKeyHandle,
                           &IgnoreKeyType,
                           Body->Buffer,
                           &KeyValueLength,
                           &IgnoreLastWriteTime
                           );

            SampDumpRtlpNtQueryValueKey(&IgnoreKeyType,
                                        Body->Buffer,
                                        &KeyValueLength,
                                        &IgnoreLastWriteTime);

        } else {
            IgnoreStatus = NtClose( SubKeyHandle );
            ASSERT(NT_SUCCESS(IgnoreStatus));
            return(NtStatus);
        }
    }

    if (!NT_SUCCESS(NtStatus)) {
        MIDL_user_free( Body->Buffer );
        IgnoreStatus = NtClose( SubKeyHandle );
        ASSERT(NT_SUCCESS(IgnoreStatus));
        return(NtStatus);
    }

    Body->Length = (USHORT)(KeyValueLength);
    Body->MaximumLength = (USHORT)(KeyValueLength) + (USHORT)sizeof(WCHAR);
    UnicodeTerminate(Body);


    IgnoreStatus = NtClose( SubKeyHandle );
    ASSERT(NT_SUCCESS(IgnoreStatus));
    return( STATUS_SUCCESS );


}


NTSTATUS
SampPutStringToRegistry(
    IN BOOLEAN RelativeToDomain,
    IN PUNICODE_STRING SubKeyName,
    IN PUNICODE_STRING Body
    )

/*++

Routine Description:

    This routine puts a unicode string into the specified registry
    sub-key.

    If the specified sub-key does not exist, then it is created.

    NOTE: The string is assigned via the RXACT mechanism.  Therefore,
          it won't actually reside in the registry key until a commit
          is performed.




Arguments:

    RelativeToDomain - This boolean indicates whether or not the name
        of the sub-key provide via the SubKeyName parameter is relative
        to the current domain or to the top of the SAM registry tree.
        If the name is relative to the current domain, then this value
        is set to TRUE.  Otherwise this value is set to FALSE.

    SubKeyName - The name of the sub-key to be assigned the unicode string.
        This field should not begin with a back-slash (\).  For example,
        to put a unicode string into a key called ALPHA\BETA\GAMMA, the
        name specified by this field would be "BETA".

    Body - The address of a UNICODE_STRING to be placed in the registry.


Return Value:


    STATUS_SUCCESS - The string was added to the RXACT transaction
        successfully.

    STATUS_INSUFFICIENT_RESOURCES - There was not enough heap memory
        or other limited resource available to fullfil the request.

    Other errors as may be returned by:

            RtlAddActionToRXact()



--*/
{

    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;

    SAMTRACE("SampPutStringToRegsitry");


    //
    // Need to build up the name of the key from the root of the RXACT
    // registry key.  That is the root of the SAM registry database
    // in our case.  If RelativeToDomain is FALSE, then the name passed
    // is already relative to the SAM registry database root.
    //

    if (RelativeToDomain == TRUE) {


        NtStatus = SampBuildDomainSubKeyName(
                       &KeyName,
                       SubKeyName
                       );
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }


    } else {
        KeyName = (*SubKeyName);
    }


    NtStatus = RtlAddActionToRXact(
                   SampRXactContext,
                   RtlRXactOperationSetValue,
                   &KeyName,
                   0,                   // No KeyValueType
                   Body->Buffer,
                   Body->Length
                   );



    //
    // free the KeyName buffer if necessary
    //

    if (RelativeToDomain) {
        SampFreeUnicodeString( &KeyName );
    }


    return( STATUS_SUCCESS );


}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Unicode String related services - These use MIDL_user_allocate and        //
// MIDL_user_free so that the resultant strings can be given to the          //
// RPC runtime.                                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampInitUnicodeString(
    IN OUT PUNICODE_STRING String,
    IN USHORT MaximumLength
    )

/*++

Routine Description:

    This routine initializes a unicode string to have zero length and
    no initial buffer.


    All allocation for this string will be done using MIDL_user_allocate.

Arguments:

    String - The address of a unicode string to initialize.

    MaximumLength - The maximum length (in bytes) the string will need
        to grow to. The buffer associated with the string is allocated
        to be this size.  Don't forget to allow 2 bytes for null termination.


Return Value:


    STATUS_SUCCESS - Successful completion.

--*/

{
    SAMTRACE("SampInitUnicodeString");

    String->Length = 0;
    String->MaximumLength = MaximumLength;

    String->Buffer = MIDL_user_allocate(MaximumLength);

    if (String->Buffer != NULL) {
        String->Buffer[0] = 0;

        return(STATUS_SUCCESS);
    } else {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
}



NTSTATUS
SampAppendUnicodeString(
    IN OUT PUNICODE_STRING Target,
    IN PUNICODE_STRING StringToAdd
    )

/*++

Routine Description:

    This routine appends the string pointed to by StringToAdd to the
    string pointed to by Target.  The contents of Target are replaced
    by the result.


    All allocation for this string will be done using MIDL_user_allocate.
    Any deallocations will be done using MIDL_user_free.

Arguments:

    Target - The address of a unicode string to initialize to be appended to.

    StringToAdd - The address of a unicode string to be added to the
        end of Target.


Return Value:


    STATUS_SUCCESS - Successful completion.

    STATUS_INSUFFICIENT_RESOURCES - There was not sufficient heap to fullfil
        the requested operation.


--*/
{

    ULONG TotalLength;
    PWSTR NewBuffer;

    SAMTRACE("SampAppendUnicodeString");


    TotalLength = Target->Length + StringToAdd->Length + (USHORT)(sizeof(UNICODE_NULL));

    //
    // Perform a quick overflow test
    //

    if (TotalLength>MAXUSHORT)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }


    //
    // If there isn't room in the target to append the new string,
    // allocate a buffer that is large enough and move the current
    // target into it.
    //

    if (TotalLength > Target->MaximumLength) {

        NewBuffer = MIDL_user_allocate( (ULONG)TotalLength );
        if (NewBuffer == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlCopyMemory( NewBuffer, Target->Buffer, (ULONG)(Target->Length) );

        MIDL_user_free( Target->Buffer );
        Target->Buffer = NewBuffer;
        Target->MaximumLength = (USHORT) TotalLength;

    } else {
        NewBuffer = Target->Buffer;
    }


    //
    // There's now room in the target to append the string.
    //

    (PCHAR)NewBuffer += Target->Length;

    RtlCopyMemory( NewBuffer, StringToAdd->Buffer, (ULONG)(StringToAdd->Length) );


    Target->Length = (USHORT) (TotalLength - (sizeof(UNICODE_NULL)));


    //
    // Null terminate the resultant string
    //

    UnicodeTerminate(Target);

    return(STATUS_SUCCESS);

}



VOID
SampFreeUnicodeString(
    IN PUNICODE_STRING String
    )

/*++

Routine Description:

    This routine frees the buffer associated with a unicode string
    (using MIDL_user_free()).


Arguments:

    Target - The address of a unicode string to free.


Return Value:

    None.

--*/
{

    SAMTRACE("SampFreeUnicodeString");

    if (String->Buffer != NULL) {
        MIDL_user_free( String->Buffer );
        String->Buffer = NULL;
    }

    return;
}


VOID
SampFreeOemString(
    IN POEM_STRING String
    )

/*++

Routine Description:

    This routine frees the buffer associated with an OEM string
    (using MIDL_user_free()).



Arguments:

    Target - The address of an OEM string to free.


Return Value:

    None.

--*/
{

    SAMTRACE("SampFreeOemString");

    if (String->Buffer != NULL) {
        MIDL_user_free( String->Buffer );
    }

    return;
}


NTSTATUS
SampBuildDomainSubKeyName(
    OUT PUNICODE_STRING KeyName,
    IN PUNICODE_STRING SubKeyName OPTIONAL
    )

/*++

Routine Description:

    This routine builds a unicode string name of the string passed
    via the SubKeyName argument.  The resultant name is relative to
    the root of the SAM root registry key.

    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().


    The name built up is comprized of three components:

        1) The constant named domain parent key name ("DOMAINS").

        2) A backslash

        3) The name of the current transaction domain.

      (optionally)

        4) A backslash

        5) The name of the domain's sub-key (specified by the SubKeyName
           argument).


    For example, if the current domain is called "MY_DOMAIN", then
    the relative name of the sub-key named "FRAMITZ" is :

                "DOMAINS\MY_DOMAIN\FRAMITZ"


    All allocation for this string will be done using MIDL_user_allocate.
    Any deallocations will be done using MIDL_user_free.



Arguments:

    KeyName - The address of a unicode string whose buffer is to be filled
        in with the full name of the registry key.  If successfully created,
        this string must be released with SampFreeUnicodeString() when no
        longer needed.


    SubKeyName - (optional) The name of the domain sub-key.  If this parameter
        is not provided, then only the domain's name is produced.
        This string is not modified.




Return Value:





--*/
{
    NTSTATUS NtStatus;
    ULONG    TotalLength;
    USHORT   SubKeyNameLength;

    SAMTRACE("SampBuildDomainSubKeyName");


    ASSERT(SampTransactionWithinDomain == TRUE);


        //
        // Initialize a string large enough to hold the name
        //

        if (ARGUMENT_PRESENT(SubKeyName)) {
            SubKeyNameLength = SampBackSlash.Length + SubKeyName->Length;
        } else {
            SubKeyNameLength = 0;
        }

        TotalLength =   SampNameDomains.Length  +
                        SampBackSlash.Length    +
                        SampDefinedDomains[SampTransactionDomainIndex].InternalName.Length +
                        SubKeyNameLength        +
                        (USHORT)(sizeof(UNICODE_NULL)); // for null terminator

        if (TotalLength>MAXUSHORT)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        NtStatus = SampInitUnicodeString( KeyName, (USHORT) TotalLength );
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }


        //
        // "DOMAINS"
        //

        NtStatus = SampAppendUnicodeString( KeyName, &SampNameDomains);
        if (!NT_SUCCESS(NtStatus)) {
            SampFreeUnicodeString( KeyName );
            return(NtStatus);
        }

        //
        // "DOMAINS\"
        //

        NtStatus = SampAppendUnicodeString( KeyName, &SampBackSlash );
        if (!NT_SUCCESS(NtStatus)) {
            SampFreeUnicodeString( KeyName );
            return(NtStatus);
        }


        //
        // "DOMAINS\(domain name)"
        //

        NtStatus = SampAppendUnicodeString(
                       KeyName,
                       &SampDefinedDomains[SampTransactionDomainIndex].InternalName
                       );
        if (!NT_SUCCESS(NtStatus)) {
            SampFreeUnicodeString( KeyName );
            return(NtStatus);
        }


        if (ARGUMENT_PRESENT(SubKeyName)) {

            //
            // "DOMAINS\(domain name)\"
            //



            NtStatus = SampAppendUnicodeString( KeyName, &SampBackSlash );
            if (!NT_SUCCESS(NtStatus)) {
                SampFreeUnicodeString( KeyName );
                return(NtStatus);
            }


            //
            // "DOMAINS\(domain name)\(sub key name)"
            //

            NtStatus = SampAppendUnicodeString( KeyName, SubKeyName );
            if (!NT_SUCCESS(NtStatus)) {
                SampFreeUnicodeString( KeyName );
                return(NtStatus);
            }

        }
    return(NtStatus);

}


NTSTATUS
SampBuildAccountKeyName(
    IN SAMP_OBJECT_TYPE ObjectType,
    OUT PUNICODE_STRING AccountKeyName,
    IN PUNICODE_STRING AccountName OPTIONAL
    )

/*++

Routine Description:

    This routine builds the name of either a group or user registry key.
    The name produced is relative to the SAM root and will be the name of
    key whose name is the name of the account.


    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().


    The name built up is comprized of the following components:

        1) The constant named domain parent key name ("DOMAINS").

        2) A backslash

        3) The name of the current transaction domain.

        4) A backslash

        5) The constant name of the group or user registry key
           ("GROUPS" or "USERS").

        6) A backslash

        7) The constant name of the registry key containing the
           account names ("NAMES").

    and, if the AccountName is specified,

        8) A backslash

        9) The account name specified by the AccountName argument.


    For example, given a AccountName of "XYZ_GROUP" and the current domain
    is "ALPHA_DOMAIN", this would yield a resultant AccountKeyName of
    "DOMAINS\ALPHA_DOMAIN\GROUPS\NAMES\XYZ_GROUP".



    All allocation for this string will be done using MIDL_user_allocate.
    Any deallocations will be done using MIDL_user_free.



Arguments:

    ObjectType - Indicates whether the account is a user or group account.

    AccountKeyName - The address of a unicode string whose buffer is to be
        filled in with the full name of the registry key.  If successfully
        created, this string must be released with SampFreeUnicodeString()
        when no longer needed.


    AccountName - The name of the account.  This string is not
        modified.




Return Value:


    STATUS_SUCCESS - The name has been built.

    STATUS_INVALID_ACCOUNT_NAME - The name specified is not legitimate.




--*/
{
    NTSTATUS NtStatus;
    ULONG    TotalLength;
    USHORT   AccountNameLength;
    PUNICODE_STRING AccountTypeKeyName = NULL;
    PUNICODE_STRING NamesSubKeyName = NULL;

    SAMTRACE("SampBuildAccountKeyName");


    ASSERT(SampTransactionWithinDomain == TRUE);
    ASSERT( (ObjectType == SampGroupObjectType) ||
            (ObjectType == SampAliasObjectType) ||
            (ObjectType == SampUserObjectType)    );

    RtlZeroMemory(AccountKeyName, sizeof(UNICODE_STRING));


    //
    // If an account name was provided, then it must meet certain
    // criteria.
    //

    if (ARGUMENT_PRESENT(AccountName)) {
        if (
            //
            // Length must be legitimate
            //

            (AccountName->Length == 0)                          ||
            (AccountName->Length > AccountName->MaximumLength)  ||

            //
            // Buffer pointer is available
            //

            (AccountName->Buffer == NULL)


            ) {
            return(STATUS_INVALID_ACCOUNT_NAME);
        }
    }




    switch (ObjectType) {
    case SampGroupObjectType:
        AccountTypeKeyName = &SampNameDomainGroups;
        NamesSubKeyName    = &SampNameDomainGroupsNames;
        break;
    case SampAliasObjectType:
        AccountTypeKeyName = &SampNameDomainAliases;
        NamesSubKeyName    = &SampNameDomainAliasesNames;
        break;
    case SampUserObjectType:
        AccountTypeKeyName = &SampNameDomainUsers;
        NamesSubKeyName    = &SampNameDomainUsersNames;
        break;
    }




    //
    // Allocate a buffer large enough to hold the entire name.
    // Only count the account name if it is passed.
    //

    AccountNameLength = 0;
    if (ARGUMENT_PRESENT(AccountName)) {
        AccountNameLength = AccountName->Length + SampBackSlash.Length;
    }

    TotalLength =   SampNameDomains.Length          +
                    SampBackSlash.Length            +
                    SampDefinedDomains[SampTransactionDomainIndex].InternalName.Length +
                    SampBackSlash.Length            +
                    AccountTypeKeyName->Length      +
                    SampBackSlash.Length            +
                    NamesSubKeyName->Length         +
                    AccountNameLength               +
                    (USHORT)(sizeof(UNICODE_NULL)); // for null terminator

    if (TotalLength>MAXUSHORT)
    {
         return(STATUS_INSUFFICIENT_RESOURCES);
    }

    NtStatus = SampInitUnicodeString( AccountKeyName, (USHORT) TotalLength );
    if (NT_SUCCESS(NtStatus)) {

        //
        // "DOMAINS"
        //

        NtStatus = SampAppendUnicodeString( AccountKeyName, &SampNameDomains);
        if (NT_SUCCESS(NtStatus)) {

            //
            // "DOMAINS\"
            //

            NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
            if (NT_SUCCESS(NtStatus)) {

                //
                // "DOMAINS\(domain name)"
                //


                NtStatus = SampAppendUnicodeString(
                               AccountKeyName,
                               &SampDefinedDomains[SampTransactionDomainIndex].InternalName
                               );
                if (NT_SUCCESS(NtStatus)) {

                    //
                    // "DOMAINS\(domain name)\"
                    //

                    NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // "DOMAINS\(domain name)\GROUPS"
                        //  or
                        // "DOMAINS\(domain name)\USERS"
                        //

                        NtStatus = SampAppendUnicodeString( AccountKeyName, AccountTypeKeyName );
                        if (NT_SUCCESS(NtStatus)) {

                            //
                            // "DOMAINS\(domain name)\GROUPS\"
                            //  or
                            // "DOMAINS\(domain name)\USERS\"
                            //

                            NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
                            if (NT_SUCCESS(NtStatus)) {

                                //
                                // "DOMAINS\(domain name)\GROUPS\NAMES"
                                //  or
                                // "DOMAINS\(domain name)\USERS\NAMES"
                                //

                                NtStatus = SampAppendUnicodeString( AccountKeyName, NamesSubKeyName );
                                if (NT_SUCCESS(NtStatus) && ARGUMENT_PRESENT(AccountName)) {
                                    //
                                    // "DOMAINS\(domain name)\GROUPS\NAMES\"
                                    //  or
                                    // "DOMAINS\(domain name)\USERS\NAMES\"
                                    //

                                    NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
                                    if (NT_SUCCESS(NtStatus)) {

                                        //
                                        // "DOMAINS\(domain name)\GROUPS\(account name)"
                                        //  or
                                        // "DOMAINS\(domain name)\USERS\(account name)"
                                        //

                                        NtStatus = SampAppendUnicodeString( AccountKeyName, AccountName );

                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

    }


        //
    // Cleanup on error
    //

    if (!NT_SUCCESS(NtStatus))
    {
        if ((AccountKeyName)&&(AccountKeyName->Buffer))
        {
            MIDL_user_free(AccountKeyName->Buffer);
            AccountKeyName->Buffer = NULL;
            AccountKeyName->Length = 0;
        }
    }

    return(NtStatus);

}



NTSTATUS
SampBuildAccountSubKeyName(
    IN SAMP_OBJECT_TYPE ObjectType,
    OUT PUNICODE_STRING AccountKeyName,
    IN ULONG AccountRid,
    IN PUNICODE_STRING SubKeyName OPTIONAL
    )

/*++

Routine Description:

    This routine builds the name of a key for one of the fields of either
    a user or a group.

    The name produced is relative to the SAM root.


    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().


    The name built up is comprized of the following components:

        1) The constant named domain parent key name ("DOMAINS").

        2) A backslash

        3) The name of the current transaction domain.

        4) A backslash

        5) The constant name of the group or user registry key
           ("Groups" or "Users").

        6) A unicode representation of the reltive ID of the account

   and if the optional SubKeyName is provided:

        7) A backslash

        8) the sub key's name.
        4) The account name specified by the AccountName argument.


    For example, given a AccountRid of 3187, a SubKeyName of "AdminComment"
    and the current domain is "ALPHA_DOMAIN", this would yield a resultant
    AccountKeyName of:

            "DOMAINS\ALPHA_DOMAIN\GROUPS\00003187\AdminComment".



    All allocation for this string will be done using MIDL_user_allocate.
    Any deallocations will be done using MIDL_user_free.



Arguments:

    ObjectType - Indicates whether the account is a user or group account.

    AccountKeyName - The address of a unicode string whose buffer is to be
        filled in with the full name of the registry key.  If successfully
        created, this string must be released with SampFreeUnicodeString()
        when no longer needed.


    AccountName - The name of the account.  This string is not
        modified.

Return Value:

--*/

{
    NTSTATUS NtStatus;
    ULONG  TotalLength;
    USHORT SubKeyNameLength;
    PUNICODE_STRING AccountTypeKeyName = NULL;
    UNICODE_STRING RidNameU;

    SAMTRACE("SampBuildAccountSubKeyName");

    ASSERT(SampTransactionWithinDomain == TRUE);
    ASSERT( (ObjectType == SampGroupObjectType) ||
            (ObjectType == SampAliasObjectType) ||
            (ObjectType == SampUserObjectType)    );


    RtlZeroMemory(AccountKeyName, sizeof(UNICODE_STRING));

    switch (ObjectType) {
    case SampGroupObjectType:
        AccountTypeKeyName = &SampNameDomainGroups;
        break;
    case SampAliasObjectType:
        AccountTypeKeyName = &SampNameDomainAliases;
        break;
    case SampUserObjectType:
        AccountTypeKeyName = &SampNameDomainUsers;
        break;
    }

    //
    // Determine how much space will be needed in the resultant name
    // buffer to allow for the sub-key-name.
    //

    if (ARGUMENT_PRESENT(SubKeyName)) {
        SubKeyNameLength = SubKeyName->Length + SampBackSlash.Length;
    } else {
        SubKeyNameLength = 0;
    }

    //
    // Convert the account Rid to Unicode.
    //

    NtStatus = SampRtlConvertUlongToUnicodeString(
                   AccountRid,
                   16,
                   8,
                   TRUE,
                   &RidNameU
                   );

    if (NT_SUCCESS(NtStatus)) {

        //
        // allocate a buffer large enough to hold the entire name
        //

        TotalLength =   SampNameDomains.Length          +
                        SampBackSlash.Length            +
                        SampDefinedDomains[SampTransactionDomainIndex].InternalName.Length +
                        SampBackSlash.Length            +
                        AccountTypeKeyName->Length      +
                        RidNameU.Length                  +
                        SubKeyNameLength                +
                        7*(USHORT)(sizeof(UNICODE_NULL)); // for null terminator, 1 for each term above

        if (TotalLength>MAXUSHORT)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        NtStatus = SampInitUnicodeString( AccountKeyName, (USHORT)TotalLength );
        if (NT_SUCCESS(NtStatus)) {


            //
            // "DOMAINS"
            //

            NtStatus = SampAppendUnicodeString( AccountKeyName, &SampNameDomains);
            if (NT_SUCCESS(NtStatus)) {

                //
                // "DOMAINS\"
                //

                NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
                if (NT_SUCCESS(NtStatus)) {

                    //
                    // "DOMAINS\(domain name)"
                    //


                    NtStatus = SampAppendUnicodeString(
                                   AccountKeyName,
                                   &SampDefinedDomains[SampTransactionDomainIndex].InternalName
                                   );
                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // "DOMAINS\(domain name)\"
                        //

                        NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
                        if (NT_SUCCESS(NtStatus)) {

                            //
                            // "DOMAINS\(domain name)\GROUPS"
                            //  or
                            // "DOMAINS\(domain name)\USERS"
                            //

                            NtStatus = SampAppendUnicodeString( AccountKeyName, AccountTypeKeyName );
                            if (NT_SUCCESS(NtStatus)) {

                                //
                                // "DOMAINS\(domain name)\GROUPS\"
                                //  or
                                // "DOMAINS\(domain name)\USERS\"
                                //

                                NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
                                if (NT_SUCCESS(NtStatus)) {

                                    //
                                    // "DOMAINS\(domain name)\GROUPS\(rid)"
                                    //  or
                                    // "DOMAINS\(domain name)\USERS\(rid)"
                                    //

                                    NtStatus = SampAppendUnicodeString( AccountKeyName, &RidNameU );

                                    if (NT_SUCCESS(NtStatus) && ARGUMENT_PRESENT(SubKeyName)) {

                                        //
                                        // "DOMAINS\(domain name)\GROUPS\(rid)\"
                                        //  or
                                        // "DOMAINS\(domain name)\USERS\(rid)\"
                                        //

                                        NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
                                        if (NT_SUCCESS(NtStatus)) {

                                            //
                                            // "DOMAINS\(domain name)\GROUPS\(rid)\(sub-key-name)"
                                            //  or
                                            // "DOMAINS\(domain name)\USERS\(rid)\(sub-key-name)"
                                            //

                                            NtStatus = SampAppendUnicodeString( AccountKeyName, SubKeyName );
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

        }

        MIDL_user_free(RidNameU.Buffer);
    }

    //
    // Cleanup on error
    //

    if (!NT_SUCCESS(NtStatus))
    {
        if ((AccountKeyName)&&(AccountKeyName->Buffer))
        {
            MIDL_user_free(AccountKeyName->Buffer);
            AccountKeyName->Buffer = NULL;
            AccountKeyName->Length = 0;
        }
    }

    return(NtStatus);
}



NTSTATUS
SampBuildAliasMembersKeyName(
    IN PSID AccountSid,
    OUT PUNICODE_STRING DomainKeyName,
    OUT PUNICODE_STRING AccountKeyName
    )

/*++

Routine Description:

    This routine builds the name of a key for the alias membership for an
    arbitrary account sid. Also produced is the name of the key for the
    domain of the account. This is the account key name without the last
    account rid component.

    The names produced is relative to the SAM root.


    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().


    The names built up are comprised of the following components:

        1) The constant named domain parent key name ("DOMAINS").

        2) A backslash

        3) The name of the current transaction domain.

        4) A backslash

        5) The constant name of the alias registry key ("Aliases").

        6) A backslash

        7) The constant name of the alias members registry key ("Members").

        8) A backslash

        9) A unicode representation of the SID of the account domain

    and for the AccountKeyName only

        10) A backslash

        11) A unicode representation of the RID of the account


    For example, given a Account Sid of 1-2-3-3187
    and the current domain is "ALPHA_DOMAIN",
    this would yield a resultant AcccountKeyName of:

            "DOMAINS\ALPHA_DOMAIN\ALIASES\MEMBERS\1-2-3\00003187".

    and a DomainKeyName of:

            "DOMAINS\ALPHA_DOMAIN\ALIASES\MEMBERS\1-2-3".



    All allocation for these strings will be done using MIDL_user_allocate.
    Any deallocations will be done using MIDL_user_free.



Arguments:

    AccountSid - The account whose alias membership in the current domain
    is to be determined.

    DomainKeyName - The address of a unicode string whose
        buffer is to be filled in with the full name of the domain registry key.
        If successfully created, this string must be released with
        SampFreeUnicodeString() when no longer needed.

    AccountKeyName - The address of a unicode string whose
        buffer is to be filled in with the full name of the account registry key.
        If successfully created, this string must be released with
        SampFreeUnicodeString() when no longer needed.




Return Value:

    STATUS_SUCCESS - the domain and account key names are valid.

    STATUS_INVALID_SID - the AccountSid is not valid. AccountSids must have
                         a sub-authority count > 0

--*/

{
    NTSTATUS NtStatus;
    USHORT  DomainTotalLength;
    USHORT  AccountTotalLength;
    UNICODE_STRING DomainNameU, TempStringU;
    UNICODE_STRING RidNameU;
    PSID    DomainSid = NULL;
    ULONG   AccountRid;
    ULONG   AccountSubAuthorities;

    SAMTRACE("SampBuildAliasMembersKeyName");

    DomainNameU.Buffer = TempStringU.Buffer = RidNameU.Buffer = NULL;

    ASSERT(SampTransactionWithinDomain == TRUE);

    ASSERT(AccountSid != NULL);
    ASSERT(DomainKeyName != NULL);
    ASSERT(AccountKeyName != NULL);

    //
    // Initialize Return Values
    //

    RtlZeroMemory(DomainKeyName,sizeof(UNICODE_STRING));
    RtlZeroMemory(AccountKeyName,sizeof(UNICODE_STRING));

    //
    // Split the account sid into domain sid and account rid
    //

    AccountSubAuthorities = (ULONG)*RtlSubAuthorityCountSid(AccountSid);

    //
    // Check for at least one sub-authority
    //

    if (AccountSubAuthorities < 1) {

        return (STATUS_INVALID_SID);
    }

    //
    // Allocate space for the domain sid
    //

    DomainSid = MIDL_user_allocate(RtlLengthSid(AccountSid));

    NtStatus = STATUS_INSUFFICIENT_RESOURCES;

    if (DomainSid == NULL) {

        return(NtStatus);
    }

    //
    // Initialize the domain sid
    //

    NtStatus = RtlCopySid(RtlLengthSid(AccountSid), DomainSid, AccountSid);
    ASSERT(NT_SUCCESS(NtStatus));

    *RtlSubAuthorityCountSid(DomainSid) = (UCHAR)(AccountSubAuthorities - 1);

    //
    // Initialize the account rid
    //

    AccountRid = *RtlSubAuthoritySid(AccountSid, AccountSubAuthorities - 1);

    //
    // Convert the domain sid into a registry key name string
    //

    NtStatus = RtlConvertSidToUnicodeString( &DomainNameU, DomainSid, TRUE);

    if (!NT_SUCCESS(NtStatus)) {
        DomainNameU.Buffer = NULL;
        goto BuildAliasMembersKeyNameError;
    }

    //
    // Convert the account rid into a registry key name string with
    // leading zeros.
    //

    NtStatus = SampRtlConvertUlongToUnicodeString(
                   AccountRid,
                   16,
                   8,
                   TRUE,
                   &RidNameU
                   );

    if (!NT_SUCCESS(NtStatus)) {

        goto BuildAliasMembersKeyNameError;
    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // allocate a buffer large enough to hold the entire name
        //

        DomainTotalLength =
                        SampNameDomains.Length          +
                        SampBackSlash.Length            +
                        SampDefinedDomains[SampTransactionDomainIndex].InternalName.Length +
                        SampBackSlash.Length            +
                        SampNameDomainAliases.Length    +
                        SampBackSlash.Length            +
                        SampNameDomainAliasesMembers.Length +
                        SampBackSlash.Length            +
                        DomainNameU.Length               +
                        9*(USHORT)(sizeof(UNICODE_NULL)); // for null terminator, 1 for each term above



        AccountTotalLength = DomainTotalLength +
                        SampBackSlash.Length            +
                        RidNameU.Length +
                                                3*(USHORT)(sizeof(UNICODE_NULL)); // for null terminator, 1 for each term above;

        //
        // First build the domain key name
        //


        NtStatus = SampInitUnicodeString( DomainKeyName, DomainTotalLength );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampInitUnicodeString( AccountKeyName, AccountTotalLength );

            if (!NT_SUCCESS(NtStatus)) {

                SampFreeUnicodeString(DomainKeyName);

            } else {

                //
                // "DOMAINS"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &SampNameDomains);
                ASSERT(NT_SUCCESS(NtStatus));


                //
                // "DOMAINS\"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &SampBackSlash );
                ASSERT(NT_SUCCESS(NtStatus));


                //
                // "DOMAINS\(domain name)"
                //

                NtStatus = SampAppendUnicodeString(
                               DomainKeyName,
                               &SampDefinedDomains[SampTransactionDomainIndex].InternalName
                               );
                ASSERT(NT_SUCCESS(NtStatus));


                //
                // "DOMAINS\(domain name)\"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &SampBackSlash );
                ASSERT(NT_SUCCESS(NtStatus));


                //
                // "DOMAINS\(domain name)\ALIASES"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &SampNameDomainAliases);
                ASSERT(NT_SUCCESS(NtStatus));


                //
                // "DOMAINS\(domain name)\ALIASES\"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &SampBackSlash );
                ASSERT(NT_SUCCESS(NtStatus));


                //
                // "DOMAINS\(domain name)\ALIASES\MEMBERS"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &SampNameDomainAliasesMembers);
                ASSERT(NT_SUCCESS(NtStatus));


                //
                // "DOMAINS\(domain name)\ALIASES\MEMBERS\"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &SampBackSlash );
                ASSERT(NT_SUCCESS(NtStatus));

                //
                // "DOMAINS\(domain name)\ALIASES\MEMBERS\(DomainSid)"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &DomainNameU );
                ASSERT(NT_SUCCESS(NtStatus));

                //
                // Now build the account name by copying the domain name
                // and suffixing the account Rid
                //

                RtlCopyUnicodeString(AccountKeyName, DomainKeyName);
                ASSERT(AccountKeyName->Length == DomainKeyName->Length);

                //
                // "DOMAINS\(domain name)\ALIASES\MEMBERS\(DomainSid)\"
                //

                NtStatus = SampAppendUnicodeString( AccountKeyName, &SampBackSlash );
                ASSERT(NT_SUCCESS(NtStatus));

                //
                // "DOMAINS\(domain name)\ALIASES\MEMBERS\(DomainSid)\(AccountRid)"
                //

                NtStatus = SampAppendUnicodeString( AccountKeyName, &RidNameU );
                ASSERT(NT_SUCCESS(NtStatus));
            }
        }

        MIDL_user_free(RidNameU.Buffer);
    }

BuildAliasMembersKeyNameFinish:

    //
    // If necessary, free memory allocated for the DomainSid.
    //

    if (DomainSid != NULL) {

        MIDL_user_free(DomainSid);
        DomainSid = NULL;
    }
    if ( DomainNameU.Buffer != NULL ) {
        RtlFreeUnicodeString( &DomainNameU );
    }

    return(NtStatus);

BuildAliasMembersKeyNameError:

    if (AccountKeyName->Buffer)
    {
        MIDL_user_free(AccountKeyName->Buffer);
        AccountKeyName->Buffer = NULL;
    }

    if (DomainKeyName->Buffer)
    {
        MIDL_user_free(DomainKeyName->Buffer);
        DomainKeyName->Buffer = NULL;
    }

    goto BuildAliasMembersKeyNameFinish;
}


NTSTATUS
SampValidateSamAccountName(
    PUNICODE_STRING NewAccountName
    )
/*++
Routine Description:

    This routine checks whether the NewAccountName has been used any
    exist account or not by searching the SamAccountName attr over DS.
    
    Note: it is used by DS code ONLY.

Parameter:

    NewAccountName - NewAccountName to use
    
Return Value:

    NtStatus - STATUS_SUCCESS: no conflict
               other: can't use this NewAccountName, either found conflict, or error
    
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ATTRVAL     NameVal;
    ATTR        NameAttr;
    DSNAME      *ExistingObject=NULL;

    NameVal.valLen = (NewAccountName->Length);
    NameVal.pVal = (UCHAR *) NewAccountName->Buffer;
    NameAttr.AttrVal.valCount = 1;
    NameAttr.AttrVal.pAVal = & NameVal;
    NameAttr.attrTyp =
        SampDsAttrFromSamAttr(SampUnknownObjectType,SAMP_UNKNOWN_OBJECTNAME);


    NtStatus = SampDsDoUniqueSearch(
                    SAM_UNICODE_STRING_MANUAL_COMPARISON,
                    ROOT_OBJECT,
                    &NameAttr,
                    &ExistingObject
                    );

    if (STATUS_NOT_FOUND == NtStatus)
    {
        //
        // We did not find the object with the same SamAccountName. 
        // The given name is valid.
        //
        ASSERT(NULL==ExistingObject);
        NtStatus = STATUS_SUCCESS;
    }
    else if (NT_SUCCESS(NtStatus))
    {
        NtStatus = STATUS_USER_EXISTS;
    }

    if (NULL!=ExistingObject)
    {
        MIDL_user_free(ExistingObject);
    }


    return( NtStatus );
}


NTSTATUS
SampValidateAdditionalSamAccountName(
    PSAMP_OBJECT    Context,
    PUNICODE_STRING NewAccountName
    )
/*++
Routine Description:

    This routine validates the NewAccountName by searching
    AdditionalSamAccountName attribute over DS. Make sure NewAccountName
    is not been used by any account in its AdditionalSamAccountName field.
    
Parameter:

    Context - pointer to object context
    
    NewAccountName - new account name
    
Return Value:

    STATUS_SUCCESS  - no conflict
    
    Other   - this account name has been used by others in AdditionalSamAccountName
              attribute, or error. 

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ATTRVAL     AdditionalNameVal;
    ATTR        AdditionalNameAttr;
    DSNAME      *ExistingObject=NULL;

    // 
    // check ms-DS-Additional-SAM-Account-Name
    // 
    AdditionalNameVal.valLen = (NewAccountName->Length);
    AdditionalNameVal.pVal = (UCHAR *) NewAccountName->Buffer;
    AdditionalNameAttr.AttrVal.valCount = 1;
    AdditionalNameAttr.AttrVal.pAVal = & AdditionalNameVal;
    AdditionalNameAttr.attrTyp = ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME;

    NtStatus = SampDsDoUniqueSearch(
                        SAM_UNICODE_STRING_MANUAL_COMPARISON,
                        ROOT_OBJECT,
                        &AdditionalNameAttr,
                        &ExistingObject
                        );

    if (STATUS_NOT_FOUND == NtStatus)
    {
        // 
        // we did not find the object with the same name in 
        // AdditionalSamAccountName attribute. The given name is valid.
        // 
        ASSERT(NULL == ExistingObject);
        NtStatus = STATUS_SUCCESS;
    }
    else if (STATUS_SUCCESS == NtStatus)
    {
        //
        // two functions will call this API. 1) Create new account 2) existing
        // account rename. For 1), SidLen is 0. For 2) Object Sid should be 
        // valid, also we allow client to rename the account to any
        // value in ms-DS-Additional-SAM-Account-Name attribute.
        // 
        NtStatus = STATUS_USER_EXISTS;

        if ((NULL != ExistingObject) && 
            Context->ObjectNameInDs->SidLen && 
            RtlEqualSid(&Context->ObjectNameInDs->Sid, &ExistingObject->Sid)
            )
        {        
            NtStatus = STATUS_SUCCESS;
        }
    }

    if (NULL != ExistingObject)
    {
        MIDL_user_free(ExistingObject);
    }


    return( NtStatus );
}


NTSTATUS
SampValidateNewAccountName(
    PSAMP_OBJECT    Context,
    PUNICODE_STRING NewAccountName,
    SAMP_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    This routine validates a new user, alias or group account name.
    This routine:

        1) Validates that the name is properly constructed.

        2) Is not already in use as a user, alias or group account name
           in any of the local SAM domains.


Arguments:

    Context - Domain Context (during account creation) or Account Context
              (during account name change).

    Name - The address of a unicode string containing the name to be
        looked for.

    TrustedClient -- Informs the Routine wether the caller is a trusted
    client. Names created through trusted clients are not restricted in the
    same fashion as non-trusted clients.

    ObjectType   -- Informs the routine of the type of Sam object that the
                    caller wants the name validated for. This is used to
                    enforce different restrictions on the name depending
                    upon different object types

Return Value:

    STATUS_SUCCESS - The new account name is valid, and not yet in use.

    STATUS_ALIAS_EXISTS - The account name is already in use as a
        alias account name.

    STATUS_GROUP_EXISTS - The account name is already in use as a
        group account name.

    STATUS_USER_EXISTS - The account name is already in use as a user
        account name.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    SID_NAME_USE Use;
    ULONG Rid;
    ULONG DomainIndex, CurrentTransactionDomainIndex;
    ULONG DomainStart;

    SAMTRACE("SampValidateNewAccountName");


    if (!Context->TrustedClient)
    {
        ULONG   i;
        BOOLEAN BlankAccountName = TRUE;

        //
        // Account Name should not be all blank
        //

        for (i = 0; i < NewAccountName->Length/sizeof(WCHAR); i++)
        {
            if (NewAccountName->Buffer[i] != L' ')
            {
                BlankAccountName = FALSE;
            }
        }

        if (BlankAccountName)
        {
            return(STATUS_INVALID_ACCOUNT_NAME);
        }

        //
        // For Non Trusted Clients enforce the same restrictions
        // as user manager.
        //

        NtStatus = SampEnforceDownlevelNameRestrictions(NewAccountName, ObjectType);
        if (!NT_SUCCESS(NtStatus))
        {
            return NtStatus;
        }

       //
       // Enforce that the trailing character is not a '.'
       //

       if (L'.'==NewAccountName->Buffer[NewAccountName->Length/sizeof(WCHAR)-1])
       {
           return(STATUS_INVALID_ACCOUNT_NAME);
       }
    }

    //
    // check if the NewAccountName is a well known name.
    //
    if (LsaILookupWellKnownName(NewAccountName))
    {
        return STATUS_USER_EXISTS;
    }

    //
    // Comment this check out as even though this was a reasonable thing to do
    // NT4 allowed it and PM believes for now that we should not enforce it
    //
#if 0
    //
    // The new account name should not be the name of the domain
    //

    for (DomainIndex=SampDsGetPrimaryDomainStart();DomainIndex<SampDefinedDomainsCount;DomainIndex++)
    {
        if (RtlEqualUnicodeString(NewAccountName,&SampDefinedDomains[DomainIndex].ExternalName,TRUE))
        {
            return(STATUS_DOMAIN_EXISTS);
        }
    }
#endif

    //
    // In DS mode make a pre-emptive pass on the name, validating
    // whether the object exists. If the object does indeed exist then
    // fall through the loop below to check for correct type of object
    // and get correct error code.
    //

    if (IsDsObject(Context))
    {
        NTSTATUS    SearchStatus;

        //
        // For DS object, we need to check SAM Account Name Table 
        // 
        SearchStatus = SampCheckAccountNameTable(
                            Context,
                            NewAccountName,
                            ObjectType
                            );

        if (!NT_SUCCESS(SearchStatus))
        {
            return( SearchStatus );
        }

        //
        // Validate NewAccountName is not used as SamAccountName by any account.
        // 
        SearchStatus = SampValidateSamAccountName(NewAccountName);

        if (NT_SUCCESS(SearchStatus))
        {

            //
            // Validate NewAccountName is not used in AdditionalSamAccountName
            // by any account
            // 
            SearchStatus = SampValidateAdditionalSamAccountName(
                                Context,
                                NewAccountName
                                );

            return( SearchStatus );

        }
    }


    //
    // Save the current transaction domain indicator
    //

    if (SampTransactionWithinDomain)
    {
        CurrentTransactionDomainIndex = SampTransactionDomainIndex;
    }

    // Initialize the starting index into SampDefinedDomains.

    DomainStart = SampDsGetPrimaryDomainStart();

    //
    // Lookup the account in each of the local SAM domains
    //

    for (DomainIndex = DomainStart;
         ((DomainIndex < (DomainStart + 2)) && NT_SUCCESS(NtStatus));
         DomainIndex++) {

        PSAMP_OBJECT    DomainContext = NULL;

        DomainContext = SampDefinedDomains[ DomainIndex ].Context;

        //
        // Set TransactionWithinDomain ONLY in registy mode
        // 

        if (!IsDsObject(DomainContext))
        {
            SampSetTransactionWithinDomain(FALSE);
            SampSetTransactionDomain( DomainIndex );
        }

        NtStatus = SampLookupAccountRid(
                       DomainContext,
                       SampUnknownObjectType,
                       NewAccountName,
                       STATUS_NO_SUCH_USER,
                       &Rid,
                       &Use
                       );

        if (!NT_SUCCESS(NtStatus)) {

            //
            // The only error allowed is that the account was not found.
            // Convert this to success, and continue searching SAM domains.
            // Propagate any other error.
            //

            if (NtStatus != STATUS_NO_SUCH_USER) {

                break;
            }

            NtStatus = STATUS_SUCCESS;

        } else {

            //
            // An account with the given Rid already exists.  Return status
            // indicating the type of the conflicting account.
            //

            switch (Use) {

            case SidTypeUser:

                NtStatus = STATUS_USER_EXISTS;
                break;

            case SidTypeGroup:

                NtStatus = STATUS_GROUP_EXISTS;
                break;

            case SidTypeDomain:

                NtStatus = STATUS_DOMAIN_EXISTS;
                break;

            case SidTypeAlias:

                NtStatus = STATUS_ALIAS_EXISTS;
                break;

            case SidTypeWellKnownGroup:

                NtStatus = STATUS_GROUP_EXISTS;
                break;

            case SidTypeDeletedAccount:

                NtStatus = STATUS_INVALID_PARAMETER;
                break;

            case SidTypeInvalid:

                NtStatus = STATUS_INVALID_PARAMETER;
                break;

            default:

                NtStatus = STATUS_INTERNAL_DB_CORRUPTION;
                break;
            }
        }
    }

    //
    // Restore the Current Transaction Domain
    //

    if (SampTransactionWithinDomain)
    {
        SampSetTransactionWithinDomain(FALSE);
        SampSetTransactionDomain( CurrentTransactionDomainIndex );
    }

    return(NtStatus);
}


NTSTATUS
SampValidateAccountNameChange(
    IN PSAMP_OBJECT    AccountContext,
    IN PUNICODE_STRING NewAccountName,
    IN PUNICODE_STRING OldAccountName,
    SAMP_OBJECT_TYPE   ObjectType
    )

/*++

Routine Description:

    This routine validates a user, group or alias account name that is
    to be set on an account.  This routine:

        1) Returns success if the name is the same as the existing name,
           except with a different case

        1) Otherwise calls SampValidateNewAccountName to verify that the
           name is properly constructed and is not already in use as a
           user, alias or group account name.

Arguments:

    NewAccountName - The address of a unicode string containing the new
        name.

    OldAccountName - The address of a unicode string containing the old
        name.

    TrustedClient  - Indicates that the caller is a trusted client


    ObjectType     - Indicates the type of object that we are changing the name of

Return Value:

    STATUS_SUCCESS - The account's name may be changed to the new
        account name

    STATUS_ALIAS_EXISTS - The account name is already in use as a
        alias account name.

    STATUS_GROUP_EXISTS - The account name is already in use as a
        group account name.

    STATUS_USER_EXISTS - The account name is already in use as a user
        account name.

    STATUS_INVALID_PARAMETER - If garbage was passed in as the new account
    Name



--*/

{

     SAMTRACE("SampValidateAccountNameChange");


    //
    // Verify that the new unicode string is valid
    //

    if (!((NULL!=NewAccountName->Buffer) && (NewAccountName->Length >0)))
    {
        return (STATUS_INVALID_PARAMETER);
    }

    //
    // Compare the old and new names without regard for case.  If they
    // are the same, return success because the name was checked when we
    // first added it; we don't care about case changes.
    //


    if ( 0 == RtlCompareUnicodeString(
                  NewAccountName,
                  OldAccountName,
                  TRUE ) ) {

        return( STATUS_SUCCESS );
    }

    //
    // Not just a case change; this is a different name.  Validate it as
    // any new name.
    //

    return( SampValidateNewAccountName( AccountContext,
                                        NewAccountName, 
                                        ObjectType ) 
          );
}



NTSTATUS
SampRetrieveAccountCounts(
    OUT PULONG UserCount,
    OUT PULONG GroupCount,
    OUT PULONG AliasCount
    )


/*++

Routine Description:

    This routine retrieve the number of user and group accounts in a domain.



    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseReadLock().



Arguments:

    UserCount - Receives the number of user accounts in the domain.

    GroupCount - Receives the number of group accounts in the domain.

    AliasCount - Receives the number of alias accounts in the domain.


Return Value:

    STATUS_SUCCESS - The values have been retrieved.

    STATUS_INSUFFICIENT_RESOURCES - Not enough memory could be allocated
        to perform the requested operation.

    Other values are unexpected errors.  These may originate from
    internal calls to:
     SampRetrieveAccountsRegistry
     SampRetrieveAcountsDs



--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;


    SAMTRACE("SampRetrieveAccountCount");


    ASSERT(SampTransactionWithinDomain == TRUE);

    // Check if a Ds Object
    if (IsDsObject(SampDefinedDomains[SampTransactionDomainIndex].Context))
        NtStatus = SampRetrieveAccountCountsDs(
                        SampDefinedDomains[SampTransactionDomainIndex].Context,
                        FALSE,          // Get more accurate count
                        UserCount,
                        GroupCount,
                        AliasCount
                        );
     else
        NtStatus = SampRetrieveAccountCountsRegistry(
                        UserCount,
                        GroupCount,
                        AliasCount
                        );
     return NtStatus;

}



NTSTATUS
SampRetrieveAccountCountsDs(
                        IN PSAMP_OBJECT DomainContext,
                        IN BOOLEAN  GetApproximateCount, 
                        OUT PULONG UserCount,
                        OUT PULONG GroupCount,
                        OUT PULONG AliasCount
                        )
/*++

  Retrieve Account Counts from the DS. For the Account Domain we will get approximate numbers from
  the Jet indices. For the builtin domain we will special case to return constant fixed numbers.

  Account counts were originally incorporated in NT3.x and NT4, to support backward compatibilty
  with LanMan 2.0. Accordingly its use can be debated at this juncture. However the published and
  exported Net API return this, and we may be breaking applications by not supporting this feature.
  Hence we must atleast give back approximate account counts.

  It is possible to use Jet escrow columns instead to maintain the account counts. However, Jet has
  the requirement currently ( Jet 600) that every escrow column must be a fixed column. This means that
  either account counts be maintained in a seperate table in Jet or that we sacrifice 12 bytes for every
  object in the DS, neither of which are acceptable solutions at this point.

  Parameters:

    DomainContext Pointer to Open Domain Context
    GetApproximateCount -- Indicate we don't need the exact value, so don't
                           make the expensive DBGetIndexSize()
    UserCount       The count of users is returned in here
    GroupCount      The count of groups is returned in here
    AliasCount      The count of aliases is returned in here

  Return Values

        STATUS_SUCCESS
        Other Return Values from other


--*/

{

    NTSTATUS    NtStatus = STATUS_SUCCESS;

    if (IsBuiltinDomain(DomainContext->DomainIndex))
    {
        *UserCount = 0;
        *GroupCount =0;
        *AliasCount = 8;
    }
    else
    {
        //
        // Account Domain, Query these values from the
        // DS, by looking at the Jet indices.
        //

        NtStatus = SampMaybeBeginDsTransaction(SampDsTransactionType);

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampGetAccountCounts(
                                DomainContext->ObjectNameInDs,
                                GetApproximateCount, 
                                UserCount,
                                GroupCount,
                                AliasCount
                                );
        }
    }

    return NtStatus;
}




NTSTATUS
SampRetrieveAccountCountsRegistry(
    OUT PULONG UserCount,
    OUT PULONG GroupCount,
    OUT PULONG AliasCount
    )
/*++

Routine Description:

    This routine retrieve the number of user and group accounts in a domain
    in the registry.Called in by SampRetrieveAccountCounts if its the Registry
    case



    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseReadLock().



Arguments:

    UserCount - Receives the number of user accounts in the domain.

    GroupCount - Receives the number of group accounts in the domain.

    AliasCount - Receives the number of alias accounts in the domain.


Return Value:

    STATUS_SUCCESS - The values have been retrieved.

    STATUS_INSUFFICIENT_RESOURCES - Not enough memory could be allocated
        to perform the requested operation.

    Other values are unexpected errors.  These may originate from
    internal calls to:

            NtOpenKey()
            NtQueryInformationKey()


--*/

{
    NTSTATUS NtStatus, IgnoreStatus;
    UNICODE_STRING KeyName;
    PUNICODE_STRING AccountTypeKeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE AccountHandle;
    ULONG KeyValueLength;
    LARGE_INTEGER IgnoreLastWriteTime;



    SAMTRACE("SampRetrieveAccountCountsRegistry");

    //
    // Get the user count first
    //

    AccountTypeKeyName = &SampNameDomainUsers;
    NtStatus = SampBuildDomainSubKeyName( &KeyName, AccountTypeKeyName );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Open this key and get its current value
        //

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            SampKey,
            NULL
            );

        SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &AccountHandle,
                       (KEY_READ),
                       &ObjectAttributes,
                       0
                       );

        if (NT_SUCCESS(NtStatus)) {

            //
            // The count is stored as the KeyValueType
            //

            KeyValueLength = 0;
            NtStatus = RtlpNtQueryValueKey(
                         AccountHandle,
                         UserCount,
                         NULL,
                         &KeyValueLength,
                         &IgnoreLastWriteTime
                         );

            SampDumpRtlpNtQueryValueKey(UserCount,
                                        NULL,
                                        &KeyValueLength,
                                        &IgnoreLastWriteTime);



            IgnoreStatus = NtClose( AccountHandle );
            ASSERT( NT_SUCCESS(IgnoreStatus) );
        }

        SampFreeUnicodeString( &KeyName );

        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }

    //
    // Now get the group count
    //

    AccountTypeKeyName = &SampNameDomainGroups;
    NtStatus = SampBuildDomainSubKeyName( &KeyName, AccountTypeKeyName );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Open this key and get its current value
        //

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            SampKey,
            NULL
            );

        SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &AccountHandle,
                       (KEY_READ),
                       &ObjectAttributes,
                       0
                       );

        if (NT_SUCCESS(NtStatus)) {

            //
            // The count is stored as the KeyValueType
            //

            KeyValueLength = 0;
            NtStatus = RtlpNtQueryValueKey(
                         AccountHandle,
                         GroupCount,
                         NULL,
                         &KeyValueLength,
                         &IgnoreLastWriteTime
                         );

            SampDumpRtlpNtQueryValueKey(GroupCount,
                                        NULL,
                                        &KeyValueLength,
                                        &IgnoreLastWriteTime);



            IgnoreStatus = NtClose( AccountHandle );
            ASSERT( NT_SUCCESS(IgnoreStatus) );
        }

        SampFreeUnicodeString( &KeyName );

        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }

    //
    // Now get the alias count
    //

    AccountTypeKeyName = &SampNameDomainAliases;
    NtStatus = SampBuildDomainSubKeyName( &KeyName, AccountTypeKeyName );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Open this key and get its current value
        //

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            SampKey,
            NULL
            );

        SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &AccountHandle,
                       (KEY_READ),
                       &ObjectAttributes,
                       0
                       );

        if (NT_SUCCESS(NtStatus)) {

            //
            // The count is stored as the KeyValueType
            //

            KeyValueLength = 0;
            NtStatus = RtlpNtQueryValueKey(
                         AccountHandle,
                         AliasCount,
                         NULL,
                         &KeyValueLength,
                         &IgnoreLastWriteTime
                         );

            SampDumpRtlpNtQueryValueKey(AliasCount,
                                        NULL,
                                        &KeyValueLength,
                                        &IgnoreLastWriteTime);



            IgnoreStatus = NtClose( AccountHandle );
            ASSERT( NT_SUCCESS(IgnoreStatus) );
        }

        SampFreeUnicodeString( &KeyName );
    }

    return( NtStatus);

}



NTSTATUS
SampAdjustAccountCount(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Increment
    )

/*++

Routine Description:

    This is the main wrapper routine for Adjusting account counts
    This routine figures out wether the object is in the Ds or the
    registry and then calls one of the two routines

     Note: THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().
           Arguments:

    ObjectType - Indicates whether the account is a user or group account.

    Increment - a BOOLEAN value indicating whether the user or group
        count is to be incremented or decremented.  A value of TRUE
        will cause the count to be incremented.  A value of FALSE will
        cause the value to be decremented.


Return Value:

    STATUS_SUCCESS - The value has been adjusted and the new value added
        to the current RXACT transaction.

    Other values are unexpected errors.  These may originate from
    internal calls to sampAdjustAccountCountInRegistry, SampAdjustAccountCount
    inDs

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;


    SAMTRACE("SampAdjustAccountCount");


    ASSERT( (ObjectType == SampGroupObjectType) ||
            (ObjectType == SampAliasObjectType) ||
            (ObjectType == SampUserObjectType)    );

    //
    // Should be called in registry case ONLY
    // 
    ASSERT( !SampUseDsData );

    NtStatus = SampAdjustAccountCountRegistry(
                        ObjectType,
                        Increment
                        );
     return NtStatus;

}






NTSTATUS
SampAdjustAccountCountRegistry(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN Increment
    )

/*++

Routine Description:

    This routine increments or decrements the count of either
    users or groups in a domain.



    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().



Arguments:

    ObjectType - Indicates whether the account is a user or group account.

    Increment - a BOOLEAN value indicating whether the user or group
        count is to be incremented or decremented.  A value of TRUE
        will cause the count to be incremented.  A value of FALSE will
        cause the value to be decremented.


Return Value:

    STATUS_SUCCESS - The value has been adjusted and the new value added
        to the current RXACT transaction.

    STATUS_INSUFFICIENT_RESOURCES - Not enough memory could be allocated
        to perform the requested operation.

    Other values are unexpected errors.  These may originate from
    internal calls to:

            NtOpenKey()
            NtQueryInformationKey()
            RtlAddActionToRXact()


--*/
{
    NTSTATUS NtStatus, IgnoreStatus;
    UNICODE_STRING KeyName;
    PUNICODE_STRING AccountTypeKeyName = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE AccountHandle;
    ULONG Count, KeyValueLength;
    LARGE_INTEGER IgnoreLastWriteTime;

    SAMTRACE("SampAdjustAccountCount");


    ASSERT(SampTransactionWithinDomain == TRUE);
    ASSERT( (ObjectType == SampGroupObjectType) ||
            (ObjectType == SampAliasObjectType) ||
            (ObjectType == SampUserObjectType)    );


    //
    // Build the name of the key whose count is to be incremented or
    // decremented.
    //

    switch (ObjectType) {
    case SampGroupObjectType:
        AccountTypeKeyName = &SampNameDomainGroups;
        break;
    case SampAliasObjectType:
        AccountTypeKeyName = &SampNameDomainAliases;
        break;
    case SampUserObjectType:
        AccountTypeKeyName = &SampNameDomainUsers;
        break;
    }

    NtStatus = SampBuildDomainSubKeyName( &KeyName, AccountTypeKeyName );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Open this key and get its current value
        //

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            SampKey,
            NULL
            );

        SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &AccountHandle,
                       (KEY_READ),
                       &ObjectAttributes,
                       0
                       );

        if (NT_SUCCESS(NtStatus)) {

            //
            // The count is stored as the KeyValueType
            //

            KeyValueLength = 0;
            NtStatus = RtlpNtQueryValueKey(
                         AccountHandle,
                         &Count,
                         NULL,
                         &KeyValueLength,
                         &IgnoreLastWriteTime
                         );

            SampDumpRtlpNtQueryValueKey(&Count,
                                        NULL,
                                        &KeyValueLength,
                                        &IgnoreLastWriteTime);

            if (NT_SUCCESS(NtStatus)) {

                if (Increment == TRUE) {
                    Count += 1;
                } else {
                    ASSERT( Count != 0 );
                    Count -= 1;
                }

                NtStatus = RtlAddActionToRXact(
                               SampRXactContext,
                               RtlRXactOperationSetValue,
                               &KeyName,
                               Count,
                               NULL,
                               0
                               );
            }


            IgnoreStatus = NtClose( AccountHandle );
            ASSERT( NT_SUCCESS(IgnoreStatus) );
        }

        SampFreeUnicodeString( &KeyName );
    }


    return( STATUS_SUCCESS );


}




NTSTATUS
SampLookupAccountRid(
    IN PSAMP_OBJECT     DomainContext,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PUNICODE_STRING  Name,
    IN NTSTATUS         NotFoundStatus,
    OUT PULONG          Rid,
    OUT PSID_NAME_USE   Use
    )

/*++

Routine Description:


    This routine attempts to find the RID of the account with the SAM 
    account name Name.
    
    N.B.  The first attempt of resolving the name is to perform a lookup
    in a global cache.  When modifying the behavoir of this function, be sure
    to make sure the cache is modified, if necessary.

Arguments:

    DomainContext - Indicates the domain in which the account lookup is being done

    ObjectType - Indicates whether the name is a user, group or unknown
        type of object.

    Name - The name of the account being looked up.

    NotFoundStatus - Receives a status value to be returned if no name is
        found.

    Rid - Receives the relative ID of account with the specified name.

    Use - Receives an indication of the type of account.


Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    (NotFoundStatus) - No name by the specified name and type could be
        found.  This value is passed to this routine.

    Other values that may be returned by:

                    SampBuildAccountKeyName()
                    NtOpenKey()
                    NtQueryValueKey()
                    DsLayer

--*/
{

    NTSTATUS    NtStatus = STATUS_SUCCESS;
    DSNAME * ObjectName = NULL;
    PSAMP_ACCOUNT_NAME_CACHE AccountNameCache;
    ULONG DomainIndex = DomainContext->DomainIndex;

    ASSERT(DomainContext);


    //
    // Check the cache first
    //
    AccountNameCache = SampDefinedDomains[DomainIndex].AccountNameCache;
    if (AccountNameCache) {

        ULONG i;
        ASSERT(IsBuiltinDomain(DomainIndex));
        ASSERT(IsDsObject(SampDefinedDomains[DomainIndex].Context));

        // Assume there is no match
        NtStatus = NotFoundStatus;
        for ( i = 0; i < AccountNameCache->Count; i++ ) {

            PUNICODE_STRING CachedName = &AccountNameCache->Entries[i].Name;
            if (0==RtlCompareUnicodeString(Name,CachedName,TRUE)) {
                // Match!  Note the dependence here on the fact this
                // account is an alias.
                *Use = SidTypeAlias;
                *Rid = AccountNameCache->Entries[i].Rid;
                NtStatus = STATUS_SUCCESS;
                break;
            }
        }

        return NtStatus;
    }

    if (IsDsObject(DomainContext))
    {



        // Do the DS Thing
        NtStatus = SampDsLookupObjectByName(
                        DomainContext->ObjectNameInDs,
                        ObjectType,
                        Name,
                        &ObjectName
                        );
        if NT_SUCCESS(NtStatus)
        {
            ULONG ObjectClass;

            // We found the object, lookup its class and its Rid

            // Define an Attrblock structure to do so. Fill in values
            // field as NULL. DS will fill them out correctly for us upon
            // a Read

            ATTRVAL ValuesDesired[] =
            {
                { sizeof(ULONG), NULL },
                { sizeof(ULONG), NULL },
                { sizeof(ULONG), NULL }
            };

            ATTRTYP TypesDesired[]=
            {
                SAMP_UNKNOWN_OBJECTSID,
                SAMP_UNKNOWN_OBJECTCLASS,
                SAMP_UNKNOWN_GROUP_TYPE
            };
            ATTRBLOCK AttrsRead;
            DEFINE_ATTRBLOCK3(AttrsDesired,TypesDesired,ValuesDesired);

            NtStatus = SampDsRead(
                            ObjectName,
                            0,
                            SampUnknownObjectType,
                            &AttrsDesired,
                            &AttrsRead
                            );


            if NT_SUCCESS(NtStatus)
            {

                 PSID   Sid;
                 NTSTATUS   IgnoreStatus;
                 SAMP_OBJECT_TYPE FoundObjectType;


                 ASSERT(AttrsRead.attrCount>=2);

                 //
                 // Get the Sid
                 //

                 Sid  = AttrsRead.pAttr[0].AttrVal.pAVal[0].pVal;
                 ASSERT(Sid!=NULL);

                 //
                 // Split the Sid
                 //

                 IgnoreStatus = SampSplitSid(Sid,NULL,Rid);
                 ASSERT(NT_SUCCESS(IgnoreStatus));

                 //
                 // Get the Object Class
                 //

                 ObjectClass = *((UNALIGNED ULONG *) AttrsRead.pAttr[1].AttrVal.pAVal[0].pVal);

                 // Map derived class to more basic class which SAM
                 // understands.

                 ObjectClass = SampDeriveMostBasicDsClass(ObjectClass);

                 //
                 // Get the object type from the database
                 //

                 FoundObjectType = SampSamObjectTypeFromDsClass(ObjectClass);

                 if (SampGroupObjectType==FoundObjectType)
                 {
                    ULONG GroupType;

                    ASSERT(3==AttrsRead.attrCount);

                    GroupType = *((UNALIGNED ULONG *) AttrsRead.pAttr[2].AttrVal.pAVal[0].pVal);

                    //
                    // Check the group type for local group ness
                    //

                    if (GroupType & GROUP_TYPE_RESOURCE_GROUP)
                    {
                        FoundObjectType = SampAliasObjectType;
                    }
                 }

                 switch(FoundObjectType)
                 {
                 case SampDomainObjectType:
                     *Use=SidTypeDomain;
                     break;
                 case SampGroupObjectType:
                     *Use=SidTypeGroup;
                     break;
                 case SampAliasObjectType:
                     *Use=SidTypeAlias;
                     break;
                 case SampUserObjectType:
                     *Use=SidTypeUser;
                     break;
                 case SampUnknownObjectType:
                     *Use=SidTypeUnknown;
                     break;
                 default:
                     *Use=SidTypeInvalid;
                     break;
                 }
            }

            //
            // Free Memory
            //

            MIDL_user_free(ObjectName);
        }
        else
        {
            //
            // We count not find the object
            //

            NtStatus = NotFoundStatus;
        }

    }
    else
    {
        NtStatus = SampLookupAccountRidRegistry(
            ObjectType,
            Name,
            NotFoundStatus,
            Rid,
            Use
            );
    }

    return NtStatus;
}


NTSTATUS
SampLookupAccountRidRegistry(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PUNICODE_STRING  Name,
    IN NTSTATUS         NotFoundStatus,
    OUT PULONG          Rid,
    OUT PSID_NAME_USE   Use
    )

/*++

Routine Description:




Arguments:

    ObjectType - Indicates whether the name is a user, group or unknown
        type of object.

    Name - The name of the account being looked up.

    NotFoundStatus - Receives a status value to be returned if no name is
        found.

    Rid - Receives the relative ID of account with the specified name.

    Use - Receives an indication of the type of account.


Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    (NotFoundStatus) - No name by the specified name and type could be
        found.  This value is passed to this routine.

    Other values that may be returned by:

                    SampBuildAccountKeyName()
                    NtOpenKey()
                    NtQueryValueKey()

--*/


{
    NTSTATUS            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND, TmpStatus;
    UNICODE_STRING      KeyName;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              TempHandle;
    ULONG               KeyValueLength;
    LARGE_INTEGER                IgnoreLastWriteTime;


    SAMTRACE("SampLookupAccountRidRegistry");


    if (  (ObjectType == SampGroupObjectType  )  ||
          (ObjectType == SampUnknownObjectType)     ) {

        //
        // Search the groups for a match
        //

        NtStatus = SampBuildAccountKeyName(
                       SampGroupObjectType,
                       &KeyName,
                       Name
                       );
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            SampKey,
            NULL
            );

        SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &TempHandle,
                       (KEY_READ),
                       &ObjectAttributes,
                       0
                       );
        SampFreeUnicodeString( &KeyName );

        if (NT_SUCCESS(NtStatus)) {

            (*Use) = SidTypeGroup;

            KeyValueLength = 0;
            NtStatus = RtlpNtQueryValueKey(
                           TempHandle,
                           Rid,
                           NULL,
                           &KeyValueLength,
                           &IgnoreLastWriteTime
                           );

            SampDumpRtlpNtQueryValueKey(Rid,
                                        NULL,
                                        &KeyValueLength,
                                        &IgnoreLastWriteTime);

            TmpStatus = NtClose( TempHandle );
            ASSERT( NT_SUCCESS(TmpStatus) );

            return( NtStatus );
        }


    }

    //
    // No group (or not group type)
    // Try an alias if appropriate
    //

    if (  (ObjectType == SampAliasObjectType  )  ||
          (ObjectType == SampUnknownObjectType)     ) {

        //
        // Search the aliases for a match
        //

        NtStatus = SampBuildAccountKeyName(
                       SampAliasObjectType,
                       &KeyName,
                       Name
                       );
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            SampKey,
            NULL
            );

        SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &TempHandle,
                       (KEY_READ),
                       &ObjectAttributes,
                       0
                       );
        SampFreeUnicodeString( &KeyName );

        if (NT_SUCCESS(NtStatus)) {

            (*Use) = SidTypeAlias;

            KeyValueLength = 0;
            NtStatus = RtlpNtQueryValueKey(
                           TempHandle,
                           Rid,
                           NULL,
                           &KeyValueLength,
                           &IgnoreLastWriteTime
                           );

            SampDumpRtlpNtQueryValueKey(Rid,
                                        NULL,
                                        &KeyValueLength,
                                        &IgnoreLastWriteTime);

            TmpStatus = NtClose( TempHandle );
            ASSERT( NT_SUCCESS(TmpStatus) );

            return( NtStatus );
        }


    }


    //
    // No group (or not group type) nor alias (or not alias type)
    // Try a user if appropriate
    //


    if (  (ObjectType == SampUserObjectType   )  ||
          (ObjectType == SampUnknownObjectType)     ) {

        //
        // Search the Users for a match
        //

        NtStatus = SampBuildAccountKeyName(
                       SampUserObjectType,
                       &KeyName,
                       Name
                       );
        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            SampKey,
            NULL
            );

        SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &TempHandle,
                       (KEY_READ),
                       &ObjectAttributes,
                       0
                       );
        SampFreeUnicodeString( &KeyName );

        if (NT_SUCCESS(NtStatus)) {

            (*Use) = SidTypeUser;

            KeyValueLength = 0;
            NtStatus = RtlpNtQueryValueKey(
                           TempHandle,
                           Rid,
                           NULL,
                           &KeyValueLength,
                           &IgnoreLastWriteTime
                           );

            SampDumpRtlpNtQueryValueKey(Rid,
                                        NULL,
                                        &KeyValueLength,
                                        &IgnoreLastWriteTime);


            TmpStatus = NtClose( TempHandle );
            ASSERT( NT_SUCCESS(TmpStatus) );

            return( NtStatus );
        }


    }

    if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
        NtStatus = NotFoundStatus;
    }

    return(NtStatus);
}



NTSTATUS
SampLookupAccountNameDs(
    IN PSID                 DomainSid,
    IN ULONG                Rid,
    OUT PUNICODE_STRING     Name OPTIONAL,
    OUT PSAMP_OBJECT_TYPE   ObjectType,
    OUT PULONG              AccountType OPTIONAL
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSID     AccountSid = NULL;
    DSNAME   AccountDsName;
    ATTRTYP  SamAccountTypAttrTyp[] = {SAMP_UNKNOWN_ACCOUNT_TYPE,SAMP_UNKNOWN_OBJECTNAME};
    ATTRVAL  SamAccountTypAttrVal[] = {{0,NULL},{0,NULL}};
    ATTRBLOCK AttrsRead;
    DEFINE_ATTRBLOCK2(SamAccountTypAttrs,SamAccountTypAttrTyp,SamAccountTypAttrVal);

    //
    // Initialize Return Values
    //

    *ObjectType = SampUnknownObjectType;

    //
    // Build the Full SID
    //

    NtStatus = SampCreateFullSid(
                    DomainSid,
                    Rid,
                    &AccountSid
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    // Build the DS name from the SID
    //

    BuildDsNameFromSid(AccountSid,&AccountDsName);

    //
    // Read the SAM account type attribute
    //

    NtStatus = SampDsRead(
                    &AccountDsName,
                    0,
                    SampUnknownObjectType,
                    &SamAccountTypAttrs,
                    &AttrsRead
                    );

     if (  (NT_SUCCESS(NtStatus))
        && (2==AttrsRead.attrCount)
        && (SAMP_UNKNOWN_ACCOUNT_TYPE==AttrsRead.pAttr[0].attrTyp)
        && (SAMP_UNKNOWN_OBJECTNAME==AttrsRead.pAttr[1].attrTyp)
        && (1==AttrsRead.pAttr[0].AttrVal.valCount)
        && (1==AttrsRead.pAttr[1].AttrVal.valCount)
        && (NULL!=AttrsRead.pAttr[0].AttrVal.pAVal[0].pVal)
        && (NULL!=AttrsRead.pAttr[1].AttrVal.pAVal[0].pVal)
        && (0!=AttrsRead.pAttr[1].AttrVal.pAVal[0].valLen)
        && (sizeof(ULONG)==AttrsRead.pAttr[0].AttrVal.pAVal[0].valLen))
    {
       ULONG SamAccountType =*((PULONG) (AttrsRead.pAttr[0].AttrVal.pAVal[0].pVal));

        if (ARGUMENT_PRESENT(AccountType))
        {
            *AccountType = SamAccountType;
        }

        //
        // Successfully read the sam accounttype . Mask bottom bits and switch on it
        //

        SamAccountType &=0xF0000000;


        switch(SamAccountType)
        {
        case SAM_USER_OBJECT:
             *ObjectType = SampUserObjectType;
             break;

        case SAM_GROUP_OBJECT:
            *ObjectType = SampGroupObjectType;
            break;

        case SAM_ALIAS_OBJECT:
            *ObjectType = SampAliasObjectType;
            break;

        default:
            *ObjectType = SampUnknownObjectType;
        }

    }
    else if (STATUS_OBJECT_NAME_NOT_FOUND==NtStatus)
    {
        //
        // Its OK if we did not seek to the object with the
        // given SID. The object type value of SampUnknownObjectype
        // is used to indicate this situation.
        //

        NtStatus = STATUS_SUCCESS;
    }

   if ((ARGUMENT_PRESENT(Name))
       && (*ObjectType!=SampUnknownObjectType))
   {
       //
       // We found the object and we want the name
       //

      Name->Buffer = MIDL_user_allocate(AttrsRead.pAttr[1].AttrVal.pAVal[0].valLen);
      if (NULL==Name->Buffer)
      {
          NtStatus = STATUS_NO_MEMORY;
          goto Error;
      }

      RtlCopyMemory(
          Name->Buffer,
          AttrsRead.pAttr[1].AttrVal.pAVal[0].pVal,
          AttrsRead.pAttr[1].AttrVal.pAVal[0].valLen
          );

      Name->Length = (USHORT)AttrsRead.pAttr[1].AttrVal.pAVal[0].valLen;
      Name->MaximumLength = (USHORT)AttrsRead.pAttr[1].AttrVal.pAVal[0].valLen;

   }

Error:

   if (NULL!=AccountSid)
   {
       MIDL_user_free(AccountSid);
       AccountSid = NULL;
   }

   return(NtStatus);
}

NTSTATUS
SampLookupAccountName(
    IN ULONG                DomainIndex,
    IN ULONG                Rid,
    OUT PUNICODE_STRING     Name OPTIONAL,
    OUT PSAMP_OBJECT_TYPE   ObjectType
    )
/*++

Routine Description:

    Looks up the specified rid in the current transaction domain.
    Returns its name and account type.


    N.B.  The first attempt of resolving the RID is to perform a lookup
    in a global cache.  When modifying the behavoir of this function, be sure
    to make sure the cache is modified, if necessary.
    
Arguments:

    Rid - The relative ID of account

    Name - Receives the name of the account if ObjectType !=  UnknownObjectType
           The name buffer can be freed using MIDL_user_free

    ObjectType - Receives the type of account this rid represents

                        SampUnknownObjectType - the account doesn't exist
                        SampUserObjectType
                        SampGroupObjectType
                        SampAliasObjectType

Return Value:

    STATUS_SUCCESS - The Service completed successfully, object type contains
                     the type of object this rid represents.

    Other values that may be returned by:

                    SampBuildAccountKeyName()
                    NtOpenKey()
                    NtQueryValueKey()

--*/
{
    NTSTATUS            NtStatus;
    PSAMP_OBJECT        AccountContext;
    PSAMP_ACCOUNT_NAME_CACHE AccountNameCache;

    SAMTRACE("SampLookupAccountName");

    //
    // Check the cache first
    //
    AccountNameCache = SampDefinedDomains[DomainIndex].AccountNameCache;
    if (AccountNameCache) {

        ULONG i;

        ASSERT(IsBuiltinDomain(DomainIndex));
        ASSERT(IsDsObject(SampDefinedDomains[DomainIndex].Context));

        // Assume there is no match
        NtStatus = STATUS_SUCCESS;
        *ObjectType = SampUnknownObjectType;
        for ( i = 0; i < AccountNameCache->Count; i++ ) {
            if (AccountNameCache->Entries[i].Rid == Rid) {
                // Match!  Note the dependence here on the fact this
                // account is an alias.
                *ObjectType = SampAliasObjectType;
                if (Name) {
                    PUNICODE_STRING CachedName = &AccountNameCache->Entries[i].Name;
                    Name->Length = 0;
                    Name->Buffer = MIDL_user_allocate(CachedName->MaximumLength);
                    if (Name->Buffer) {
                        Name->MaximumLength = CachedName->MaximumLength;
                        RtlCopyUnicodeString(Name, CachedName);
                    } else {
                        NtStatus = STATUS_NO_MEMORY;
                    }
                }
                break;
            }
        }

        return NtStatus;
    }

    //
    // If we are in DS mode, use the faster and thread safe DS mode 
    // routine 
    //

    if (IsDsObject(SampDefinedDomains[DomainIndex].Context))
    {
        //
        // Ds Mode call the DS routine
        //

        return(SampLookupAccountNameDs(
                        SampDefinedDomains[DomainIndex].Sid,
                        Rid,
                        Name,
                        ObjectType,
                        NULL
                        ));
    }

    //
    // Lock should be held and transaction domain should be set
    // if we are in registry mode.
    //

    ASSERT(SampCurrentThreadOwnsLock());
    ASSERT(SampTransactionWithinDomain);

    //
    // Search the groups for a match
    //

    NtStatus = SampCreateAccountContext(
                    SampGroupObjectType,
                    Rid,
                    TRUE, // Trusted client
                    FALSE,// Loopback
                    TRUE, // Account exists
                    &AccountContext
                    );


    if (NT_SUCCESS(NtStatus)) {

        *ObjectType = SampGroupObjectType;

        if (ARGUMENT_PRESENT(Name)) {

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_GROUP_NAME,
                           TRUE, // Make copy
                           Name
                           );
        }

        SampDeleteContext(AccountContext);

        return (NtStatus);

    }

    //
    // Search the aliases for a match
    //

    NtStatus = SampCreateAccountContext(
                    SampAliasObjectType,
                    Rid,
                    TRUE, // Trusted client
                    FALSE,// Loopback
                    TRUE, // Account exists
                    &AccountContext
                    );


    if (NT_SUCCESS(NtStatus)) {

        *ObjectType = SampAliasObjectType;

        if (ARGUMENT_PRESENT(Name)) {

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_ALIAS_NAME,
                           TRUE, // Make copy
                           Name
                           );
        }

        SampDeleteContext(AccountContext);

        return (NtStatus);

    }


    //
    // Search the users for a match
    //

    NtStatus = SampCreateAccountContext(
                    SampUserObjectType,
                    Rid,
                    TRUE, // Trusted client
                    FALSE,// Loopback
                    TRUE, // Account exists
                    &AccountContext
                    );


    if (NT_SUCCESS(NtStatus)) {

        *ObjectType = SampUserObjectType;

        if (ARGUMENT_PRESENT(Name)) {

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_USER_ACCOUNT_NAME,
                           TRUE, // Make copy
                           Name
                           );
        }

        SampDeleteContext(AccountContext);

        return (NtStatus);

    }

    //
    // This account doesn't exist
    //

    *ObjectType = SampUnknownObjectType;

    return(STATUS_SUCCESS);
}



NTSTATUS
SampOpenAccount(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN SAMPR_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG AccountId,
    IN BOOLEAN WriteLockHeld,
    OUT SAMPR_HANDLE *AccountHandle
    )

/*++

Routine Description:

    This API opens an existing user, group or alias account in the account database.
    The account is specified by a ID value that is relative to the SID of the
    domain.  The operations that will be performed on the group must be
    declared at this time.

    This call returns a handle to the newly opened account that may be
    used for successive operations on the account.  This handle may be
    closed with the SamCloseHandle API.



Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the account.  These access types are reconciled
        with the Discretionary Access Control list of the account to
        determine whether the accesses will be granted or denied.

    GroupId - Specifies the relative ID value of the user or group to be
        opened.

    GroupHandle - Receives a handle referencing the newly opened
        user or group.  This handle will be required in successive calls to
        operate on the account.

    WriteLockHeld - if TRUE, the caller holds SAM's SampLock for WRITE
        access, so this routine does not have to obtain it.

Return Values:

    STATUS_SUCCESS - The account was successfully opened.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_NO_SUCH_GROUP - The specified group does not exist.

    STATUS_NO_SUCH_USER - The specified user does not exist.

    STATUS_NO_SUCH_ALIAS - The specified alias does not exist.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

--*/
{

    NTSTATUS            NtStatus;
    NTSTATUS            IgnoreStatus;
    PSAMP_OBJECT        NewContext, DomainContext = (PSAMP_OBJECT)DomainHandle;
    SAMP_OBJECT_TYPE    FoundType;
    BOOLEAN             fLockAcquired = FALSE;

    SAMTRACE("SampOpenAccount");


    //
    // Grab a read lock, if a lock isn't already held.
    //

    if ( !WriteLockHeld )
    {
        SampMaybeAcquireReadLock(DomainContext, 
                                 DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                                 &fLockAcquired );
    }


    //
    // Validate type of, and access to domain object.
    //

    NtStatus = SampLookupContext(
                   DomainContext,
                   DOMAIN_LOOKUP,                   // DesiredAccess
                   SampDomainObjectType,            // ExpectedType
                   &FoundType
                   );



    if (NT_SUCCESS(NtStatus)) {

        //
        // Try to create a context for the account.
        //

        NtStatus = SampCreateAccountContext2(
                        DomainContext,                  // Domain Context
                        ObjectType,                     // Object Type
                        AccountId,                      // Relative ID
                        NULL,                           // UserAccountCtrl
                        (PUNICODE_STRING) NULL,         // Account Name
                        DomainContext->ClientRevision,  // Client Revision
                        DomainContext->TrustedClient,   // Trusted Client
                        DomainContext->LoopbackClient,  // Loopback Client
                        FALSE,                          // CreatebByPrivilege
                        TRUE,                           // Account Exists 
                        FALSE,                          // OverrideLocalGroupCheck 
                        NULL,                           // Group Type
                        &NewContext                     // Acount Context (return)
                        );



        if (NT_SUCCESS(NtStatus)) {

            //
            // Reference the object for the validation
            //

            //
            // Do not reference and dereference the context for Ds case for trusted
            // trusted clients. This preserves the buffer that was cached in the context
            // Since we know that trusted clients immediately use the data for account
            // object, this strategy saves us some additional DS calls. For non trusted
            // clients security is a bigger issue and therefore we cannot ever let them
            // deal with possible stale data, so do not do this caching
            //

            if (!(IsDsObject(NewContext) && NewContext->TrustedClient))
                SampReferenceContext(NewContext);

            //
            // Validate the caller's access.
            //

            NtStatus = SampValidateObjectAccess(
                           NewContext,                   //Context
                           DesiredAccess,                //DesiredAccess
                           FALSE                         //ObjectCreation
                           );

            //
            // Dereference object, discarding any changes
            //

            if (!(IsDsObject(NewContext) && NewContext->TrustedClient))
            {
                IgnoreStatus = SampDeReferenceContext(NewContext, FALSE);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            //
            // Clean up the new context if we didn't succeed.
            //

            if (!NT_SUCCESS(NtStatus)) {
                SampDeleteContext( NewContext );
            }

        }


        //
        // De-reference the object, discarding changes
        // 

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }


    //
    // Return the account handle
    //

    if (!NT_SUCCESS(NtStatus)) {
        (*AccountHandle) = 0;
    } else {
        (*AccountHandle) = NewContext;
    }


    //
    // Free the lock, if we obtained it.
    //

    if ( !WriteLockHeld ) {
        SampMaybeReleaseReadLock( fLockAcquired );
    }

    return(NtStatus);
}


NTSTATUS
SampCreateAccountContext(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG AccountId,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN LoopbackClient,
    IN BOOLEAN AccountExists,
    OUT PSAMP_OBJECT *AccountContext
    )

/*++

Routine Description:

    This is a wrapper for SampCreateAccountContext2.  This function is
    called by SAM code that doesn't not require that the AccountName of
    the object be passed in.

    For parameters and return values see SampCreateAccountContext2

--*/

{
    return SampCreateAccountContext2(NULL,                  // ObjectContext
                                     ObjectType,
                                     AccountId,
                                     NULL,                  // user account control
                                     (PUNICODE_STRING) NULL,// Account name
                                     SAM_CLIENT_PRE_NT5,
                                     TrustedClient,
                                     LoopbackClient,
                                     FALSE,                 // CreateByPrivilege
                                     AccountExists,
                                     FALSE,                 // Override LocalGroupCheck
                                     NULL,                  // Group Type parameter
                                     AccountContext
                                     );
}


NTSTATUS
SampCreateAccountContext2(
    IN PSAMP_OBJECT PassedInContext OPTIONAL,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG AccountId,
    IN OPTIONAL PULONG  UserAccountControl,
    IN OPTIONAL PUNICODE_STRING AccountName,
    IN ULONG   ClientRevision,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN LoopbackClient,
    IN BOOLEAN CreateByPrivilege,
    IN BOOLEAN AccountExists,
    IN BOOLEAN OverrideLocalGroupCheck,
    IN PULONG  GroupType OPTIONAL,
    OUT PSAMP_OBJECT *AccountContext
    )

/*++

Routine Description:

    This API creates a context for an account object. (User group or alias).
    If the account exists flag is specified, an attempt is made to open
    the object in the database and this api fails if it doesn't exist.
    If AccountExists = FALSE, this routine setups up the context such that
    data can be written into the context and the object will be created
    when they are committed.

    The account is specified by a ID value that is relative to the SID of the
    current transaction domain.

    This call returns a context handle for the newly opened account.
    This handle may be closed with the SampDeleteContext API.

    No access check is performed by this function.

    In Loopback Case, PassedInContext will be provided by caller, so 
    SamTransactionWithinDomain is not a requirment any more, so as long
    as PassedInContext is passed in by caller, SAM lock is NOT required.           

    For all the other case, if PassedInContext is NULL, the below statement
    is still true.

    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseReadLock().



Parameters:

    ObjectType - the type of object to open

    AccountId - the id of the account in the current transaction domain

    UserAccountControl --- If this passed, in then this information is passed
                           down to lower layers, for determining correct objectclass
                           during user account creation.

        AccountName -- the SAM account name of the account

    TrustedClient - TRUE if client is trusted - i.e. server side process.

    LoopbackClient - TRUE if the Client is the DS itself as part of Loopback

    AccountExists - specifies whether the account already exists.

    CreateByPrivilege -  specifies that the account creation has been authorized,
                     because the client holds a privilege that can allows it to
                     create the specified account. Setting this disables all
                     security descriptor controlled access checks.

    OverrideLocalGroupCheck -- Normally only a group with a group type marked as local group
                     is allowed to be opened as an alias object. Setting this flag
                     overrides that option

    GroupType       -- For group creation the group type is specified in here

    AccountContext - Receives context pointer referencing the newly opened account.


Return Values:

    STATUS_SUCCESS - The account was successfully opened.

    STATUS_NO_SUCH_GROUP - The specified group does not exist.

    STATUS_NO_SUCH_USER - The specified user does not exist.

    STATUS_NO_SUCH_ALIAS - The specified alias does not exist.

--*/
{

    NTSTATUS            NtStatus = STATUS_SUCCESS;
    NTSTATUS            NotFoundStatus = STATUS_NO_SUCH_USER;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    PSAMP_OBJECT        NewContext;
    PSAMP_OBJECT        DomainContext;
    DSNAME              *LoopbackName = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    ULONG                SecurityDescriptorLength = 0;
    ULONG               DomainIndex;
    BOOLEAN             OpenedBySystem = FALSE;

    SAMTRACE("SampCreateAccountContext");

    //
    // Establish type-specific information
    //

    ASSERT( (ObjectType == SampGroupObjectType) ||
            (ObjectType == SampAliasObjectType) ||
            (ObjectType == SampUserObjectType)    );

    switch (ObjectType) {
    case SampGroupObjectType:
        NotFoundStatus = STATUS_NO_SUCH_GROUP;
        ASSERT(!SampUseDsData || AccountExists || ARGUMENT_PRESENT(GroupType));
        break;
    case SampAliasObjectType:
        NotFoundStatus = STATUS_NO_SUCH_ALIAS;
        ASSERT(!SampUseDsData || AccountExists || ARGUMENT_PRESENT(GroupType));
        break;
    case SampUserObjectType:
        NotFoundStatus = STATUS_NO_SUCH_USER;
        break;
    }

    //
    // Get the Domain Context through the domain index, either 
    // get it from SampTransactionDomainIndex or from passedin context
    //

    if (ARGUMENT_PRESENT(PassedInContext))
    {
        DomainIndex = PassedInContext->DomainIndex;
        OpenedBySystem = PassedInContext->OpenedBySystem;
    }
    else
    {
        ASSERT(SampCurrentThreadOwnsLock());
        ASSERT(SampTransactionWithinDomain);
        DomainIndex = SampTransactionDomainIndex;
    }

    DomainContext = SampDefinedDomains[DomainIndex].Context;

    //
    // Try to create a context for the account.
    //

    if (LoopbackClient)
    {
        //
        // For DS loopback create a special context
        //

        NewContext = SampCreateContextEx(
                        ObjectType,
                        TrustedClient,
                        TRUE, // DsMode,
                        TRUE, // NotSharedByMultiThreads, - Loopback Client doesn't share context
                        TRUE, // Loopback Client
                        TRUE, // LazyCommit,
                        TRUE, // PersistAcrossCalls,
                        TRUE, // BufferWrites,
                        FALSE,// Opened By DCPromo
                        DomainIndex
                        );

    }
    else
    {

        NewContext = SampCreateContext(
                        ObjectType,
                        DomainIndex,
                        TrustedClient
                        );
    }



    if (NewContext != NULL) {

        //
        // Mark the context as a loopback client if necessary
        //

        NewContext->LoopbackClient = LoopbackClient;

        //
        // Set the client revision in the context
        //

        NewContext->ClientRevision = ClientRevision;

        //
        // Propagate the opened by system flag
        //
     
        NewContext->OpenedBySystem = OpenedBySystem;


        //
        // Set the account's rid
        //

        switch (ObjectType) {
        case SampGroupObjectType:
            NewContext->TypeBody.Group.Rid = AccountId;
            break;
        case SampAliasObjectType:
            NewContext->TypeBody.Alias.Rid = AccountId;
            break;
        case SampUserObjectType:
            NewContext->TypeBody.User.Rid = AccountId;
            break;
        }

        //
        // Also stash away information, if we used the privilege
        // to create accounts
        //
        if ((SampUserObjectType == ObjectType) &&
            (!AccountExists) )
        {
            NewContext->TypeBody.User.PrivilegedMachineAccountCreate = CreateByPrivilege;
        }


        // Check if registry or DS. We have  to do different things depending
        // upon Registry or Ds.

        if (IsDsObject(DomainContext))
        {
            //
            // Domain to which the object belongs ( supposedly) Exists in the DS
            //

            if (AccountExists)
            {
                //
                // If Fast Opens are specified then do not search based on Rid.
                // Contruct a DS Name with the appropriate Sid. This assumes support in the
                // DS to position by such DSNames. The DS then postions based on just the
                // Sid specified in the DS Name and will use the Nc DNT of the primary
                // domain. If Multiple domain support is desired then this logic will then
                // need to be revisited.
                //

                DSNAME * NewDsName=NULL;

                NewDsName = MIDL_user_allocate(sizeof(DSNAME));
                if (NULL!=NewDsName)
                {
                    PSID  AccountSid;
                    PSID    DomainSid;

                    //
                    // Create the Account Sid
                    //

                    DomainSid =  SampDefinedDomains[DomainIndex].Sid;
                    NtStatus = SampCreateFullSid(DomainSid, AccountId,&AccountSid);
                    if (NT_SUCCESS(NtStatus))
                    {
                        // Build the Sid only DSName and free the account sid
                        // generated by SampCreateFullSid
                        BuildDsNameFromSid(AccountSid,NewDsName);
                        MIDL_user_free(AccountSid);

                        NtStatus = SampMaybeBeginDsTransaction(SampDsTransactionType);
                        if (NT_SUCCESS(NtStatus))
                        {
                            // Set the DSName in the Context
                            NewContext->ObjectNameInDs = NewDsName;

                            // Prefetch Sam Properties
                            NtStatus = SampDsCheckObjectTypeAndFillContext(
                                            ObjectType,
                                            NewContext,
                                            0,
                                            0,
                                            OverrideLocalGroupCheck
                                            );

                            // If We got a name error then reset the failure
                            // status to object not found
                            if ((STATUS_OBJECT_NAME_INVALID==NtStatus)
                                 || (STATUS_OBJECT_NAME_NOT_FOUND==NtStatus))
                                NtStatus = NotFoundStatus;
                        }
                    }
                }
                else
                {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                }

                #ifdef DBG

                //
                // On a Checked Build do an addtional validation for the Uniqueness
                // of the Sid within the Nc. The below code with a special SAMP
                // global flag will print out all instances of conflicts into the
                // kernel debugger.
                //

                if (NT_SUCCESS(NtStatus))
                {
                    DSNAME * ObjectName=NULL;
                    NTSTATUS IgnoreStatus;

                    IgnoreStatus = SampDsLookupObjectByRid(
                                    DomainContext->ObjectNameInDs,
                                    AccountId,
                                    &(ObjectName)
                                    );
                    // ASSERT(NT_SUCCESS(IgnoreStatus));

                    if (NT_SUCCESS(IgnoreStatus))
                    {
                        MIDL_user_free(ObjectName);
                    }
                }

               #endif
            }
            else
            {
                BOOLEAN fLoopBack = FALSE;
                BOOLEAN fDSA = FALSE;

                ASSERT(AccountName);

                if (SampExistsDsLoopback(&LoopbackName))
                {
                    //
                    // If it is the loop back case then get the actual Class Id by looking
                    // into the loopback structure. We will not set the security Descriptor
                    // because we are not running as fDSA and the DS will consider whichever
                    // security descriptor the LDAP client passed in.
                    //

                    SampGetLoopbackObjectClassId(&(NewContext->DsClassId));
                    fLoopBack = TRUE;
                }
                else
                {
                    //
                    // No this is not a loopback case. The client never passes in a security
                    // descriptor and since we will be running as fDSA we will have to pass
                    // in a security descriptor. For this we obtain the security descriptor from
                    // the schema. Note that we must obtain a security descriptor from the schema
                    // for the call to succeed. Further Pass in a trusted client Bit. For trusted
                    // clients no impersonation is done, but the owner and the group is set to the
                    // the Administrators Alias. For Non Trusted Clients the Client Token is
                    // queried to obtain the owner and the Group. Also if we are creating computer
                    // object's mark the context as such as because we need to put in the right
                    // default security descriptor and therefore need the correct class in DsClassId
                    //

                    if ((SampUserObjectType==ObjectType) && (ARGUMENT_PRESENT(UserAccountControl))
                            && ((*UserAccountControl)& USER_MACHINE_ACCOUNT_MASK))
                    {
                        NewContext->DsClassId = CLASS_COMPUTER;
                    }

                    NtStatus = SampMaybeBeginDsTransaction(SampDsTransactionType);
                    if (NT_SUCCESS(NtStatus))
                    {
                        NtStatus = SampGetDefaultSecurityDescriptorForClass(
                                        NewContext->DsClassId,
                                        &SecurityDescriptorLength,
                                        TrustedClient,
                                        &SecurityDescriptor
                                        );
                    }

                    if (NT_SUCCESS(NtStatus))
                    {
                        ASSERT(SecurityDescriptorLength>0);
                        ASSERT(SecurityDescriptor!=NULL);
                    }
                }

                //
                // For group objects check the group type and then
                // set the flags in the context accordingly
                //

                if (((SampGroupObjectType==ObjectType) || (SampAliasObjectType==ObjectType))
                    && (NT_SUCCESS(NtStatus)))
                {
                    NT4_GROUP_TYPE NT4GroupType;
                    NT5_GROUP_TYPE NT5GroupType;
                    BOOLEAN        SecurityEnabled;

                    //
                    // Validate the group type bits
                    //

                    NtStatus = SampCheckGroupTypeBits(
                                    DownLevelDomainControllersPresent(DomainIndex),
                                    *GroupType
                                    );
                    //
                    // If that succeeded proceed to get the group type in meaningful form
                    //

                    if (NT_SUCCESS(NtStatus))
                    {

                        NtStatus = SampComputeGroupType(
                                        SampDeriveMostBasicDsClass(NewContext->DsClassId),
                                        *GroupType,
                                        &NT4GroupType,
                                        &NT5GroupType,
                                        &SecurityEnabled
                                        );
                    }


                    if (NT_SUCCESS(NtStatus))
                    {
                        if (SampAliasObjectType==ObjectType)
                        {
                            NewContext->TypeBody.Alias.NT4GroupType = NT4GroupType;
                            NewContext->TypeBody.Alias.NT5GroupType = NT5GroupType;
                            NewContext->TypeBody.Alias.SecurityEnabled = SecurityEnabled;
                        }
                        else
                        {
                            NewContext->TypeBody.Group.NT4GroupType = NT4GroupType;
                            NewContext->TypeBody.Group.NT5GroupType = NT5GroupType;
                            NewContext->TypeBody.Group.SecurityEnabled = SecurityEnabled;
                        }
                    }
                }

                //
                // Construct the account's DSNAME
                //


                if (NT_SUCCESS(NtStatus))
                {

                    NtStatus = SampDsCreateAccountObjectDsName(
                                DomainContext->ObjectNameInDs,
                                SampDefinedDomains[DomainIndex].Sid, // Domain Sid
                                ObjectType,
                                AccountName,
                                &AccountId,     // Account Rid
                                UserAccountControl,
                                SampDefinedDomains[DomainIndex].IsBuiltinDomain,
                                &NewContext->ObjectNameInDs
                                );
                }
                //
                // Now Proceed on creating the account
                //

                if (NT_SUCCESS(NtStatus))
                {
                    //
                    // Control the fDSA flag Appropriately. Setting the fDSA flag is tricky and
                    // is actually governed by the following rules
                    //
                    // 1, Trusted Clients get fDSA.
                    //
                    // 2. All others proceed with fDSA set to FALSE
                    //
                    // 2.1.  If (2) failed access check by core DS, but the Machine account is
                    //       getting created by privilege, we will set fDSA to true for a second
                    //       try --- this requires explanation
                    //
                    //    -- NT4 had a notion of a privilege to create machine accounts. Therefore if
                    //       the privilege check passed ( and this would only be that case for machine
                    //       accounts ) then we set fDSA. This is because even though the access check
                    //       may fail the privilege allows us to create the account. ( DS does not know
                    //       about specific checks for privelege for specific classes of accounts ).
                    //

                    ASSERT(SampExistsDsTransaction());

                    if (TrustedClient)
                    {
                        SampSetDsa(TRUE);
                        fDSA = TRUE;
                    }
                    else
                    {
                        SampSetDsa(FALSE);
                        fDSA = FALSE;
                    }

                    //
                    // Create the account object with fDSA turned off for
                    // any caller except TrustedClient.
                    //
                    if (NT_SUCCESS(NtStatus))
                    {
                        ASSERT( ARGUMENT_PRESENT(UserAccountControl) || (SampUserObjectType != ObjectType) ); 

                        NtStatus = SampDsCreateInitialAccountObject(
                                       NewContext,
                                       SUPPRESS_GROUP_TYPE_DEFAULTING,
                                       AccountId,
                                       AccountName,
                                       NULL,        // CreatorSid
                                       fDSA?SecurityDescriptor:NULL,
                                       UserAccountControl,
                                       GroupType
                                       );

                        if ( NT_SUCCESS(NtStatus)  )
                        {
                            //
                            // if the client can just create Machine Account
                            // without using the privilege he holds, then
                            // we need to mark it correctly, so that caller will
                            // know it throught the returned context.
                            //
                            if (CreateByPrivilege)
                            {
                                NewContext->TypeBody.User.PrivilegedMachineAccountCreate = FALSE;
                            }
                        }
                        else if (STATUS_ACCESS_DENIED == NtStatus)
                        {
                            //
                            // if access check failed, but the client has privilege
                            // to create machine account.
                            //
                            if ( CreateByPrivilege )
                            {
                                // Asssert this privilege is only for Machine Account
                                ASSERT(SampUserObjectType == ObjectType);
                                ASSERT(NewContext->DsClassId == CLASS_COMPUTER);

                                //
                                // Clear privous DS Error
                                //
                                SampClearErrors();

                                //
                                // Check whether the client still has quota or not
                                //
                                NtStatus = SampCheckQuotaForPrivilegeMachineAccountCreation();

                                //
                                // If the caller still has quota to create machine account
                                //
                                if (NT_SUCCESS(NtStatus))
                                {
                                    PTOKEN_OWNER Owner=NULL;
                                    PTOKEN_PRIMARY_GROUP PrimaryGroup=NULL;
                                    PSID         CreatorSid = NULL;

                                    //
                                    // Get Client's SID (actual creator) from token
                                    //
                                    NtStatus = SampGetCurrentOwnerAndPrimaryGroup(
                                                        &Owner,
                                                        &PrimaryGroup
                                                        );

                                    if (NT_SUCCESS(NtStatus))
                                    {
                                        CreatorSid = Owner->Owner;

                                        //
                                        // Set fDSA to TRUE, because client has
                                        // privilege to do the machine creation
                                        //
                                        SampSetDsa(TRUE);
                                        fDSA = TRUE;

                                        NtStatus = SampDsCreateInitialAccountObject(
                                                        NewContext,
                                                        SUPPRESS_GROUP_TYPE_DEFAULTING,
                                                        AccountId,
                                                        AccountName,
                                                        CreatorSid,
                                                        fDSA?SecurityDescriptor:NULL,
                                                        UserAccountControl,
                                                        GroupType
                                                        );

                                        //
                                        // if create the machine account with privilege successfully
                                        // Then turn around, reset the Owner of the machine object
                                        // to Domain Admins
                                        //
                                        if (NT_SUCCESS(NtStatus))
                                        {
                                            PSID    DomainAdmins = NULL;

                                            //
                                            // Construct Domain_Administrators Group SID
                                            //
                                            NtStatus = SampCreateFullSid(
                                                            SampDefinedDomains[DOMAIN_START_DS + 1].Sid,
                                                            DOMAIN_GROUP_RID_ADMINS,
                                                            &DomainAdmins
                                                            );

                                            //
                                            // reset Owner to Domain Administrators Group
                                            //
                                            if (NT_SUCCESS(NtStatus))
                                            {
                                                NtStatus = SampSetMachineAccountOwner(
                                                                NewContext,
                                                                DomainAdmins
                                                                );

                                                MIDL_user_free(DomainAdmins);
                                            }
                                        }
                                    }
                                    if (NULL != Owner)
                                    {
                                        MIDL_user_free(Owner);
                                    }
                                    if (NULL != PrimaryGroup)
                                    {
                                        MIDL_user_free(PrimaryGroup);
                                    }
                                }
                            }
                        }
                    }
               }
            } // End of DS mode Account Creation Case.
        }
        else
        {
            //
            // The Domain in which the account is supposed to exist/ or to
            // be created is in the registry
            //

            //
            // Create the specified acocunt's root key name
            // and store it in the context.
            // This name remains around until the context is deleted.
            //

            NtStatus = SampBuildAccountSubKeyName(
                           ObjectType,
                           &NewContext->RootName,
                           AccountId,
                           NULL             // Don't give a sub-key name
                           );

            if (NT_SUCCESS(NtStatus)) {

                //
                // If the account should exist, try and open the root key
                // to the object - fail if it doesn't exist.
                //

                if (AccountExists) {

                    InitializeObjectAttributes(
                        &ObjectAttributes,
                        &NewContext->RootName,
                        OBJ_CASE_INSENSITIVE,
                        SampKey,
                        NULL
                        );

                    SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &ObjectAttributes, 0);

                    NtStatus = RtlpNtOpenKey(
                                   &NewContext->RootKey,
                                   (KEY_READ | KEY_WRITE),
                                   &ObjectAttributes,
                                   0
                                   );

                    if ( !NT_SUCCESS(NtStatus) ) {
                        NewContext->RootKey = INVALID_HANDLE_VALUE;
                        NtStatus = NotFoundStatus;
                    }
                }

            } else {
                RtlInitUnicodeString(&NewContext->RootName, NULL);
            }
        } // End of Registry Mode.

        //
        // Clean up the account context if we failed
        //

        if (!NT_SUCCESS(NtStatus))
        {
            SampDeleteContext( NewContext );
            NewContext = NULL;
        }

    } // End of NewContext != NULL if Statement.
    else
    {

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Return the context pointer
    //

    *AccountContext = NewContext;

    //
    // Do any necessary Cleanup
    //

    if (NULL!=SecurityDescriptor)
    {
        MIDL_user_free(SecurityDescriptor);
    }

    return(NtStatus);
}



NTSTATUS
SampIsAccountBuiltIn(
    IN ULONG Rid
    )

/*++

Routine Description:

    This routine checks to see if a specified account name is a well-known
    (built-in) account.  Some restrictions apply to such accounts, such as
    they can not be deleted or renamed.


Parameters:

    Rid - The RID of the account.


Return Values:

    STATUS_SUCCESS - The account is not a well-known (restricted) account.

    STATUS_SPECIAL_ACCOUNT - Indicates the account is a restricted
        account.  This is an error status, based upon the assumption that
        this service will primarily be utilized to determine if an
        operation may allowed on an account.


--*/
{
    SAMTRACE("SampIsAccountBuiltIn");

    if (Rid < SAMP_RESTRICTED_ACCOUNT_COUNT) {

        return(STATUS_SPECIAL_ACCOUNT);

    } else {

        return(STATUS_SUCCESS);
    }
}



NTSTATUS
SampCreateFullSid(
    IN PSID DomainSid,
    IN ULONG Rid,
    OUT PSID *AccountSid
    )

/*++

Routine Description:

    This function creates a domain account sid given a domain sid and
    the relative id of the account within the domain.

    The returned Sid may be freed with MIDL_user_free.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS

--*/
{

    NTSTATUS    NtStatus, IgnoreStatus;
    UCHAR       AccountSubAuthorityCount;
    ULONG       AccountSidLength;
    PULONG      RidLocation;

    SAMTRACE("SampCreateFullSid");

    //
    // Calculate the size of the new sid
    //

    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(DomainSid) + (UCHAR)1;
    AccountSidLength = RtlLengthRequiredSid(AccountSubAuthorityCount);

    //
    // Allocate space for the account sid
    //

    *AccountSid = MIDL_user_allocate(AccountSidLength);

    if (*AccountSid == NULL) {

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        //
        // Copy the domain sid into the first part of the account sid
        //

        IgnoreStatus = RtlCopySid(AccountSidLength, *AccountSid, DomainSid);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Increment the account sid sub-authority count
        //

        *RtlSubAuthorityCountSid(*AccountSid) = AccountSubAuthorityCount;

        //
        // Add the rid as the final sub-authority
        //

        RidLocation = RtlSubAuthoritySid(*AccountSid, AccountSubAuthorityCount-1);
        *RidLocation = Rid;

        NtStatus = STATUS_SUCCESS;
    }

    return(NtStatus);
}



NTSTATUS
SampCreateAccountSid(
    IN PSAMP_OBJECT AccountContext,
    OUT PSID *AccountSid
    )

/*++

Routine Description:

    This function creates the sid for an account object.

    The returned Sid may be freed with MIDL_user_free.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS

--*/
{
    NTSTATUS    NtStatus;
    PSID        DomainSid;
    ULONG       AccountRid = 0;

    SAMTRACE("SampCreateAccountSid");


    //
    // Get the Sid for the domain this object is in
    //


    DomainSid = SampDefinedDomains[AccountContext->DomainIndex].Sid;

    //
    // Get the account Rid
    //

    switch (AccountContext->ObjectType) {

    case SampGroupObjectType:
        AccountRid = AccountContext->TypeBody.Group.Rid;
        break;
    case SampAliasObjectType:
        AccountRid = AccountContext->TypeBody.Alias.Rid;
        break;
    case SampUserObjectType:
        AccountRid = AccountContext->TypeBody.User.Rid;
        break;
    default:
        ASSERT(FALSE);
    }


    //
    // Build a full sid from the domain sid and the account rid
    //
    ASSERT(AccountRid && "AccountRid not initialized\n");

    NtStatus = SampCreateFullSid(DomainSid, AccountRid, AccountSid);

    return(NtStatus);
}


VOID
SampNotifyNetlogonOfDelta(
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PUNICODE_STRING ObjectName,
    IN DWORD ReplicateImmediately,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    )

/*++

Routine Description:

    This routine is called after any change is made to the SAM database
    on a PDC.  It will pass the parameters, along with the database type
    and ModifiedCount to I_NetNotifyDelta() so that Netlogon will know
    that the database has been changed.

    This routine MUST be called with SAM's write lock held; however, any
    changes must have already been committed to disk.  That is, call
    SampCommitAndRetainWriteLock() first, then this routine, then
    SampReleaseWriteLock().

Arguments:

    DeltaType - Type of modification that has been made on the object.

    ObjectType - Type of object that has been modified.

    ObjectRid - The relative ID of the object that has been modified.
        This parameter is valid only when the object type specified is
        either SecurityDbObjectSamUser, SecurityDbObjectSamGroup or
        SecurityDbObjectSamAlias otherwise this parameter is set to
        zero.

    ObjectName - The old name of the object when the object type specified
        is either SecurityDbObjectSamUser, SecurityDbObjectSamGroup or
        SecurityDbObjectSamAlias and the delta type is SecurityDbRename
        otherwise this parameter is set to zero.

    ReplicateImmediately - TRUE if the change should be immediately
        repl\noticated to all BDCs.  A password change should set the flag
        TRUE.

    DeltaData - pointer to delta-type specific structure to be passed
              - to netlogon.

Return Value:

    None.


--*/
{
    SAMTRACE("SampNotifyNetlogonOfDelta");

    //
    // Only make the call if this is not a backup domain controller.
    // In DS mode the Core DS will make this call. Therefore Nothing
    // to do
    //

    if ((!SampUseDsData) && (!SampDisableNetlogonNotification))
    {
        ASSERT(SampCurrentThreadOwnsLock());
        ASSERT(SampTransactionWithinDomain);

        if ( SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ServerRole
             != DomainServerRoleBackup )
        {
        I_NetNotifyDelta(
            SecurityDbSam,
            SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber,
            DeltaType,
            ObjectType,
            ObjectRid,
            SampDefinedDomains[SampTransactionDomainIndex].Sid,
            ObjectName,
            ReplicateImmediately,
            DeltaData
            );

        //
        // Let any notification packages know about the delta.
        //

        SampDeltaChangeNotify(
            SampDefinedDomains[SampTransactionDomainIndex].Sid,
            DeltaType,
            ObjectType,
            ObjectRid,
            ObjectName,
            &SampDefinedDomains[SampTransactionDomainIndex].NetLogonChangeLogSerialNumber,
            DeltaData
            );

        }
    }
}



NTSTATUS
SampSplitSid(
    IN PSID AccountSid,
    IN OUT PSID *DomainSid OPTIONAL,
    OUT ULONG *Rid
    )

/*++

Routine Description:

    This function splits a sid into its domain sid and rid.  The caller
    can either provide a memory buffer for the returned DomainSid, or
    request that one be allocated.  If the caller provides a buffer, the buffer
    is assumed to be of sufficient size.  If allocated on the caller's behalf,
    the buffer must be freed when no longer required via MIDL_user_free.

Arguments:

    AccountSid - Specifies the Sid to be split.  The Sid is assumed to be
        syntactically valid.  Sids with zero subauthorities cannot be split.

    DomainSid - Pointer to location containing either NULL or a pointer to
        a buffer in which the Domain Sid will be returned.  If NULL is
        specified, memory will be allocated on behalf of the caller. If this
        paramter is NULL, only the account Rid is returned

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call successfully.

        STATUS_INVALID_SID - The Sid is has a subauthority count of 0.
--*/

{
    NTSTATUS    NtStatus;
    UCHAR       AccountSubAuthorityCount;
    ULONG       AccountSidLength;

    SAMTRACE("SampSplitSid");

    //
    // Calculate the size of the domain sid
    //

    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(AccountSid);


    if (AccountSubAuthorityCount < 1) {

        NtStatus = STATUS_INVALID_SID;
        goto SplitSidError;
    }

    AccountSidLength = RtlLengthSid(AccountSid);


    //
    // Get Domain Sid if caller is intersted in it.
    //

    if (DomainSid)
    {

        //
        // If no buffer is required for the Domain Sid, we have to allocate one.
        //

        if (*DomainSid == NULL) {

            //
            // Allocate space for the domain sid (allocate the same size as the
            // account sid so we can use RtlCopySid)
            //

            *DomainSid = MIDL_user_allocate(AccountSidLength);


            if (*DomainSid == NULL) {

                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto SplitSidError;
            }
        }

        //
        // Copy the Account sid into the Domain sid
        //

        RtlMoveMemory(*DomainSid, AccountSid, AccountSidLength);

        //
        // Decrement the domain sid sub-authority count
        //

        (*RtlSubAuthorityCountSid(*DomainSid))--;
    }


    //
    // Copy the rid out of the account sid
    //

    *Rid = *RtlSubAuthoritySid(AccountSid, AccountSubAuthorityCount-1);

    NtStatus = STATUS_SUCCESS;

SplitSidFinish:

    return(NtStatus);

SplitSidError:

    goto SplitSidFinish;
}



NTSTATUS
SampDuplicateUnicodeString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    )

/*++

Routine Description:

    This routine allocates memory for a new OutString and copies the
    InString string to it.

Parameters:

    OutString - A pointer to a destination unicode string

    InString - A pointer to an unicode string to be copied

Return Values:

    None.

--*/

{
    SAMTRACE("SampDuplicateUnicodeString");

    ASSERT( OutString != NULL );
    ASSERT( InString != NULL );

    if ( InString->Length > 0 ) {

        OutString->Buffer = MIDL_user_allocate( InString->Length );

        if (OutString->Buffer == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        OutString->MaximumLength = InString->Length;

        RtlCopyUnicodeString(OutString, InString);

    } else {

        RtlInitUnicodeString(OutString, NULL);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
SampUnicodeToOemString(
    IN POEM_STRING OutString,
    IN PUNICODE_STRING InString
    )

/*++

Routine Description:

    This routine allocates memory for a new OutString and copies the
    InString string to it, converting to OEM string in the process.

Parameters:

    OutString - A pointer to a destination OEM string.

    InString - A pointer to a unicode string to be copied

Return Values:

    None.

--*/

{
    ULONG
        OemLength,
        Index;

    NTSTATUS
        NtStatus;

    SAMTRACE("SampUnicodeToOemString");

    ASSERT( OutString != NULL );
    ASSERT( InString != NULL );

    if ( InString->Length > 0 ) {

        OemLength = RtlUnicodeStringToOemSize(InString);
        if ( OemLength > MAXUSHORT ) {
            return STATUS_INVALID_PARAMETER_2;
        }

        OutString->Length = (USHORT)(OemLength - 1);
        OutString->MaximumLength = (USHORT)OemLength;
        OutString->Buffer = MIDL_user_allocate(OemLength);
        if ( !OutString->Buffer ) {
            return STATUS_NO_MEMORY;
        }

        NtStatus = RtlUnicodeToOemN(
                       OutString->Buffer,
                       OutString->Length,
                       &Index,
                       InString->Buffer,
                       InString->Length
                       );

        if (!NT_SUCCESS(NtStatus)) {
            MIDL_user_free(OutString->Buffer);
            return NtStatus;
        }

        OutString->Buffer[Index] = '\0';


    } else {

        RtlInitString(OutString, NULL);
    }

    return(STATUS_SUCCESS);
}



NTSTATUS
SampChangeAccountOperatorAccessToMember(
    IN PRPC_SID MemberSid,
    IN SAMP_MEMBERSHIP_DELTA ChangingToAdmin,
    IN SAMP_MEMBERSHIP_DELTA ChangingToOperator
    )

/*++

Routine Description:

    This routine is called when a member is added to or removed from an
    ADMIN alias.  If the member is from the BUILTIN or ACCOUNT domain,
    it will change the ACL(s) of the member to allow or disallow access
    by account operators if necessary.

    This must be called BEFORE the member is actually added to the
    alias, and AFTER the member is actually removed from the alias to
    avoid security holes in the event that we are unable to complete the
    entire task.

    When this routine is called, the transaction domain is alredy set
    to that of the alias.  Note, however, that the member might be in a
    different domain, so the transaction domain may be adjusted in this
    routine.

    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.

        THIS ROUTINE IS NOT CALLED IN THE DS CASE

Arguments:

    MemberSid - The full ID of the member being added to/ deleted from
        an ADMIN alias.

    ChangingToAdmin - AddToAdmin if Member is being added to an ADMIN alias,
        RemoveFromAdmin if it's being removed.

    ChangingToOperator - AddToAdmin if Member is being added to an OPERATOR
        alias, RemoveFromAdmin if it's being removed.


Return Value:

    STATUS_SUCCESS - either the ACL(s) was modified, or it didn't need
        to be.

--*/
{
    SAMP_V1_0A_FIXED_LENGTH_GROUP GroupV1Fixed;
    PSID                        MemberDomainSid = NULL;
    PULONG                      UsersInGroup = NULL;
    NTSTATUS                    NtStatus;
    ULONG                       MemberRid;
    ULONG                       OldTransactionDomainIndex = SampDefinedDomainsCount;
    ULONG                       NumberOfUsersInGroup;
    ULONG                       i;
    ULONG                       MemberDomainIndex;
    SAMP_OBJECT_TYPE            MemberType;
    PSECURITY_DESCRIPTOR        SecurityDescriptor;
    PSECURITY_DESCRIPTOR        OldDescriptor;
    ULONG                       SecurityDescriptorLength;
    ULONG                       Revision;
    ULONG                       DomainStart;

    SAMTRACE("SampChangeAccountOperatorAccessToMember");

    ASSERT( SampTransactionWithinDomain );
        ASSERT( SampUseDsData == FALSE);


    //
    // See if the SID is from one of the local domains (BUILTIN or ACCOUNT).
    // If it's not, we don't have to worry about modifying ACLs.
    //

    NtStatus = SampSplitSid( MemberSid, &MemberDomainSid, &MemberRid );

    if ( !NT_SUCCESS( NtStatus ) ) {

        return( NtStatus );
    }

    DomainStart = SampDsGetPrimaryDomainStart();


    for ( MemberDomainIndex = DomainStart;
        MemberDomainIndex < SampDefinedDomainsCount;
        MemberDomainIndex++ ) {

        if ( RtlEqualSid(
            MemberDomainSid,
            SampDefinedDomains[MemberDomainIndex].Sid ) ) {

            break;
        }
    }

    if ( MemberDomainIndex < SampDefinedDomainsCount ) {

        //
        // The member is from one of the local domains.  MemberDomainIndex
        // indexes that domain.  First, check to see if the alias and member
        // are in the same domain.
        //

        if ( MemberDomainIndex != SampTransactionDomainIndex ) {

            //
            // The transaction domain is set to that of the alias, but
            // we need to set it to that of the member while we modify
            // the member.
            //

            SampSetTransactionWithinDomain(FALSE);

            OldTransactionDomainIndex = SampTransactionDomainIndex;

            SampSetTransactionDomain( MemberDomainIndex );
        }

        //
        // Now we need to change the member ACL(s), IF the member is being
        // added to an admin alias for the first time.  Find out whether
        // the member is a user or a group, and attack accordingly.
        //

        NtStatus = SampLookupAccountName(
                       SampTransactionDomainIndex,
                       MemberRid,
                       NULL,
                       &MemberType
                       );

        if (NT_SUCCESS(NtStatus)) {

            switch (MemberType) {

                case SampUserObjectType: {

                    NtStatus = SampChangeOperatorAccessToUser(
                                   MemberRid,
                                   ChangingToAdmin,
                                   ChangingToOperator
                                   );

                    break;
                }

                case SampGroupObjectType: {

                    PSAMP_OBJECT GroupContext;

                    //
                    // Change ACL for every user in this group.
                    // First get group member list.
                    //

                    //
                    // Try to create a context for the account.
                    //

                    NtStatus = SampCreateAccountContext(
                                     SampGroupObjectType,
                                     MemberRid,
                                     TRUE, // Trusted client
                                     FALSE,// Loopback client
                                     TRUE, // Account exists
                                     &GroupContext
                                     );
                    if (NT_SUCCESS(NtStatus)) {


                        //
                        // Now set a flag in the group itself,
                        // so that when users are added and removed
                        // in the future it is known whether this
                        // group is in an ADMIN alias or not.
                        //

                        NtStatus = SampRetrieveGroupV1Fixed(
                                       GroupContext,
                                       &GroupV1Fixed
                                       );

                        if ( NT_SUCCESS( NtStatus ) ) {

                            ULONG OldAdminStatus = 0;
                            ULONG NewAdminStatus;

                            // SAM BUG 42367 FIX - ChrisMay 7/1/96

                            SAMP_MEMBERSHIP_DELTA AdminChange = NoChange;
                            SAMP_MEMBERSHIP_DELTA OperatorChange = NoChange;

                            if (GroupV1Fixed.AdminCount != 0 ) {
                                OldAdminStatus++;
                            }
                            if (GroupV1Fixed.OperatorCount != 0) {
                                OldAdminStatus++;
                            }
                            NewAdminStatus = OldAdminStatus;

                            //
                            // Update the admin count.  If we added one and the
                            // count is now 1, then the group became administrative.
                            // If we subtracted one and the count is zero,
                            // then the group lost its administrive membership.
                            //

                            if (ChangingToAdmin == AddToAdmin) {
                                if (++GroupV1Fixed.AdminCount == 1) {
                                    NewAdminStatus++;

                                    // SAM BUG 42367 FIX - ChrisMay 7/1/96

                                    AdminChange = AddToAdmin;
                                }
                            } else if (ChangingToAdmin == RemoveFromAdmin) {


                                //
                                // For removing an admin count, we need to make
                                // sure there is at least one.  In the upgrade
                                // case there may not be, since prior versions
                                // of NT only had a boolean.
                                //
                                if (GroupV1Fixed.AdminCount > 0) {
                                    if (--GroupV1Fixed.AdminCount == 0) {
                                        NewAdminStatus --;

                                        // SAM BUG 42367 FIX - ChrisMay 7/1/96

                                        AdminChange = RemoveFromAdmin;
                                    }
                                }

                            }

                            //
                            // Update the operator count
                            //

                            if (ChangingToOperator == AddToAdmin) {
                                if (++GroupV1Fixed.OperatorCount == 1) {
                                    NewAdminStatus++;

                                    // SAM BUG 42367 FIX - ChrisMay 7/1/96

                                    OperatorChange = AddToAdmin;
                                }
                            } else if (ChangingToOperator == RemoveFromAdmin) {


                                //
                                // For removing an Operator count, we need to make
                                // sure there is at least one.  In the upgrade
                                // case there may not be, since prior versions
                                // of NT only had a boolean.
                                //
                                if (GroupV1Fixed.OperatorCount > 0) {
                                    if (--GroupV1Fixed.OperatorCount == 0) {
                                        NewAdminStatus --;

                                        // SAM BUG 42367 FIX - ChrisMay 7/1/96

                                        OperatorChange = RemoveFromAdmin;
                                    }
                                }

                            }


                            NtStatus = SampReplaceGroupV1Fixed(
                                            GroupContext,
                                            &GroupV1Fixed
                                            );
                            //
                            // If the status of the group changed,
                            // modify the security descriptor to
                            // prevent account operators from adding
                            // anybody to this group
                            //

                            if ( NT_SUCCESS( NtStatus ) &&
                                ((NewAdminStatus != 0) != (OldAdminStatus != 0)) ) {

                                //
                                // Get the old security descriptor so we can
                                // modify it.
                                //

                                NtStatus = SampGetAccessAttribute(
                                                GroupContext,
                                                SAMP_GROUP_SECURITY_DESCRIPTOR,
                                                FALSE, // don't make copy
                                                &Revision,
                                                &OldDescriptor
                                                );
                                if (NT_SUCCESS(NtStatus)) {

                                    NtStatus = SampModifyAccountSecurity(
                                                   GroupContext,
                                                   SampGroupObjectType,
                                                   (BOOLEAN) ((NewAdminStatus != 0) ? TRUE : FALSE),
                                                   OldDescriptor,
                                                   &SecurityDescriptor,
                                                   &SecurityDescriptorLength
                                                   );

                                    if ( NT_SUCCESS( NtStatus ) ) {

                                        //
                                        // Write the new security descriptor into the object
                                        //

                                        NtStatus = SampSetAccessAttribute(
                                                       GroupContext,
                                                       SAMP_GROUP_SECURITY_DESCRIPTOR,
                                                       SecurityDescriptor,
                                                       SecurityDescriptorLength
                                                       );

                                        RtlDeleteSecurityObject( &SecurityDescriptor );
                                    }
                                }
                            }

                            //
                            // Update all the members of this group so that
                            // their security descriptors are changed.
                            //

                            // SAM BUG 42367 FIX - ChrisMay 7/1/96

                            #if 0

                            if ( NT_SUCCESS( NtStatus ) ) {

                                NtStatus = SampRetrieveGroupMembers(
                                            GroupContext,
                                            &NumberOfUsersInGroup,
                                            &UsersInGroup
                                            );

                                if ( NT_SUCCESS( NtStatus ) ) {

                                    for ( i = 0; i < NumberOfUsersInGroup; i++ ) {

                                        NtStatus = SampChangeOperatorAccessToUser(
                                                       UsersInGroup[i],
                                                       ChangingToAdmin,
                                                       ChangingToOperator
                                                       );

                                        if ( !( NT_SUCCESS( NtStatus ) ) ) {

                                            break;
                                        }
                                    }

                                    MIDL_user_free( UsersInGroup );

                                }

                            }

                            #endif

                            if (NT_SUCCESS(NtStatus) &&
                                ((AdminChange != NoChange) ||
                                 (OperatorChange != NoChange))) {

                                NtStatus = SampRetrieveGroupMembers(
                                                GroupContext,
                                                &NumberOfUsersInGroup,
                                                &UsersInGroup
                                                );

                                if (NT_SUCCESS(NtStatus)) {

                                    for (i = 0; i < NumberOfUsersInGroup; i++) {

                                            NtStatus = SampChangeOperatorAccessToUser(
                                                           UsersInGroup[i],
                                                           AdminChange,
                                                           OperatorChange
                                                           );

                                            if (!(NT_SUCCESS(NtStatus))){

                                                break;
                                        }
                                    }

                                    MIDL_user_free(UsersInGroup);

                                }

                            }

                            if (NT_SUCCESS(NtStatus)) {

                                //
                                // Add the modified group to the current transaction
                                // Don't use the open key handle since we'll be deleting the context.
                                //

                                NtStatus = SampStoreObjectAttributes(GroupContext, FALSE);
                            }

                        }



                        //
                        // Clean up the group context
                        //

                        SampDeleteContext(GroupContext);
                    }

                    break;
                }

                default: {

                    //
                    // A bad RID from a domain other than the domain
                    // current at the time of the call could slip through
                    // to this point.  Return error.
                    //

                    //
                    // If the account is in a different domain than the alias,
                    //  don't report an error if we're removing the member and
                    //  the member no longer exists.
                    //
                    //  Possibly caused by deleting the object before deleting
                    //  the membership in the alias.
                    //

                    // SAM BUG 42367 FIX - ChrisMay 7/1/96

                    #if 0

                    if ( (ChangingToAdmin == AddToAdmin) ||
                         (ChangingToOperator == AddToAdmin) ||
                         OldTransactionDomainIndex == SampDefinedDomainsCount ){
                        NtStatus = STATUS_INVALID_MEMBER;
                    } else {
                        NtStatus = STATUS_SUCCESS;
                    }

                    #endif

                    NtStatus = STATUS_SUCCESS;
                }
            }
        }

        if ( OldTransactionDomainIndex != SampDefinedDomainsCount ) {

            //
            // The transaction domain should be set to that of the alias, but
            // we switched it above to that of the member while we modified
            // the member.  Now we need to switch it back.
            //

            SampSetTransactionWithinDomain(FALSE);

            SampSetTransactionDomain( OldTransactionDomainIndex );
        }
    }

    MIDL_user_free( MemberDomainSid );

    return( NtStatus );
}


NTSTATUS
SampChangeOperatorAccessToUser(
    IN ULONG UserRid,
    IN SAMP_MEMBERSHIP_DELTA ChangingToAdmin,
    IN SAMP_MEMBERSHIP_DELTA ChangingToOperator
    )

/*++

Routine Description:

    This routine adjusts the user's AdminCount field as appropriate, and
    if the user is being removed from it's last ADMIN alias or added to
    its first ADMIN alias, the ACL is adjusted to allow/disallow access
    by account operators as appropriate.

    This routine will also increment or decrement the domain's admin count,
    if this operation changes that.

    NOTE:
    This routine is similar to SampChangeOperatorAccessToUser2().
    This routine should be used in cases where a user context does NOT
    already exist (and won't later on).  You must be careful not to
    create two contexts, since they will be independently applied back
    to the registry, and the last one there will win.

    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.

Arguments:

    UserRid - The transaction-domain-relative ID of the user that is
        being added to or removed from an ADMIN alias.

    ChangingToAdmin - AddToAdmin if Member is being added to an ADMIN alias,
        RemoveFromAdmin if it's being removed.

    ChangingToOperator - AddToAdmin if Member is being added to an OPERATOR
        alias, RemoveFromAdmin if it's being removed.


Return Value:

    STATUS_SUCCESS - either the ACL was modified, or it didn't need
        to be.

--*/
{
    SAMP_V1_0A_FIXED_LENGTH_USER   UserV1aFixed;
    NTSTATUS                    NtStatus;
    PSAMP_OBJECT                UserContext;
    PSECURITY_DESCRIPTOR        SecurityDescriptor;
    ULONG                       SecurityDescriptorLength;

    SAMTRACE("SampChangeOperatorAccessToUser");

    //
    // None of this ACL modification business in DS Mode
    //

    ASSERT(FALSE==SampUseDsData);

    //
    // Get the user's fixed data, and adjust the AdminCount.
    //

    NtStatus = SampCreateAccountContext(
                   SampUserObjectType,
                   UserRid,
                   TRUE, // Trusted client
                   FALSE,// Trusted client
                   TRUE, // Account exists
                   &UserContext
                   );

    if ( NT_SUCCESS( NtStatus ) ) {

        NtStatus = SampRetrieveUserV1aFixed(
                       UserContext,
                       &UserV1aFixed
                       );

        if ( NT_SUCCESS( NtStatus ) ) {

            NtStatus = SampChangeOperatorAccessToUser2(
                            UserContext,
                            &UserV1aFixed,
                            ChangingToAdmin,
                            ChangingToOperator
                            );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // If we've succeeded (at changing the admin count, and
                // the ACL if necessary) then write out the new admin
                // count.
                //

                NtStatus = SampReplaceUserV1aFixed(
                                   UserContext,
                                   &UserV1aFixed
                                   );
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // Add the modified user context to the current transaction
            // Don't use the open key handle since we'll be deleting the context.
            //

            NtStatus = SampStoreObjectAttributes(UserContext, FALSE);
        }


        //
        // Clean up account context
        //

        SampDeleteContext(UserContext);
    }

    if ( ( !NT_SUCCESS( NtStatus ) ) &&
        (( ChangingToAdmin == RemoveFromAdmin )  ||
         ( ChangingToOperator == RemoveFromAdmin )) &&
        ( NtStatus != STATUS_SPECIAL_ACCOUNT ) ) {

        //
        // When an account is *removed* from admin groups, we can
        // ignore errors from this routine.  This routine is just
        // making the account accessible to account operators, but
        // it's no big deal if that doesn't work.  The administrator
        // can still get at it, so we should proceed with the calling
        // operation.
        //
        // Obviously, we can't ignore errors if we're being added
        // to an admin group, because that could be a security hole.
        //
        // Also, we want to make sure that the Administrator is
        // never removed, so we DO propogate STATUS_SPECIAL_ACCOUNT.
        //

        NtStatus = STATUS_SUCCESS;
    }

    return( NtStatus );
}


NTSTATUS
SampChangeOperatorAccessToUser2(
    IN PSAMP_OBJECT                    UserContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER   V1aFixed,
    IN SAMP_MEMBERSHIP_DELTA           AddingToAdmin,
    IN SAMP_MEMBERSHIP_DELTA           AddingToOperator
    )

/*++

Routine Description:

    This routine adjusts the user's AdminCount field as appropriate, and
    if the user is being removed from it's last ADMIN alias or added to
    its first ADMIN alias, the ACL is adjusted to allow/disallow access
    by account operators as appropriate.

    This routine will also increment or decrement the domain's admin count,
    if this operation changes that.

    NOTE:
    This routine is similar to SampAccountOperatorAccessToUser().
    This routine should be used in cases where a user account context
    already exists.  You must be careful not to create two contexts,
    since they will be independently applied back to the registry, and
    the last one there will win.

    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.

Arguments:

    UserContext - Context of user whose access is to be updated.

    V1aFixed - Pointer to the V1aFixed length data for the user.
        The caller of this routine must ensure that this value is
        stored back out to disk on successful completion of this
        routine.

    AddingToAdmin - AddToAdmin if Member is being added to an ADMIN alias,
        RemoveFromAdmin if it's being removed.

    AddingToOperator - AddToAdmin if Member is being added to an OPERATOR
        alias, RemoveFromAdmin if it's being removed.


Return Value:

    STATUS_SUCCESS - either the ACL(s) was modified, or it didn't need
        to be.

--*/
{
    NTSTATUS                    NtStatus = STATUS_SUCCESS;
    PSECURITY_DESCRIPTOR        OldDescriptor;
    PSECURITY_DESCRIPTOR        SecurityDescriptor;
    ULONG                       SecurityDescriptorLength;
    ULONG                       OldAdminStatus = 0, NewAdminStatus = 0;
    ULONG                       Revision;

    SAMTRACE("SampChangeOperatorAccessToUser2");

    //
    // Compute whether we are an admin now. From that we will figure
    // out how many times we were may not an admin to tell if we need
    // to update the security descriptor.
    //

    if (V1aFixed->AdminCount != 0) {
        OldAdminStatus++;
    }
    if (V1aFixed->OperatorCount != 0) {
        OldAdminStatus++;
    }

    NewAdminStatus = OldAdminStatus;



    if ( AddingToAdmin == AddToAdmin ) {

        V1aFixed->AdminCount++;
        NewAdminStatus++;
        SampDiagPrint( DISPLAY_ADMIN_CHANGES,
                       ("SAM DIAG: Incrementing admin count for user %d\n"
                        "          New admin count: %d\n",
                        V1aFixed->UserId, V1aFixed->AdminCount ) );
    } else if (AddingToAdmin == RemoveFromAdmin) {

        V1aFixed->AdminCount--;

        if (V1aFixed->AdminCount == 0) {
            NewAdminStatus--;
        }

        SampDiagPrint( DISPLAY_ADMIN_CHANGES,
                       ("SAM DIAG: Decrementing admin count for user %d\n"
                        "          New admin count: %d\n",
                        V1aFixed->UserId, V1aFixed->AdminCount ) );

        if ( V1aFixed->AdminCount == 0 ) {

            //
            // Don't allow the Administrator account to lose
            // administrative power.
            //

            if ( V1aFixed->UserId == DOMAIN_USER_RID_ADMIN ) {

                NtStatus = STATUS_SPECIAL_ACCOUNT;
            }
        }
    }
    if ( AddingToOperator == AddToAdmin ) {

        V1aFixed->OperatorCount++;
        NewAdminStatus++;
        SampDiagPrint( DISPLAY_ADMIN_CHANGES,
                       ("SAM DIAG: Incrementing operator count for user %d\n"
                        "          New admin count: %d\n",
                        V1aFixed->UserId, V1aFixed->OperatorCount ) );

    } else if (AddingToOperator == RemoveFromAdmin) {

        //
        // Only decrement if the count is > 0, since in the upgrade case
        // this field we start out zero.
        //

        if (V1aFixed->OperatorCount > 0) {
            V1aFixed->OperatorCount--;

            if (V1aFixed->OperatorCount == 0) {
                NewAdminStatus--;
            }
        }

        SampDiagPrint( DISPLAY_ADMIN_CHANGES,
                       ("SAM DIAG: Decrementing operator count for user %d\n"
                        "          New admin count: %d\n",
                        V1aFixed->UserId, V1aFixed->OperatorCount ) );
    }


    if (NT_SUCCESS(NtStatus)) {

        if ( ( NewAdminStatus != 0 ) != ( OldAdminStatus != 0 ) ) {

            //
            // User's admin status is changing.  We must change the
            // ACL.
            //

#ifdef SAMP_DIAGNOSTICS
            if (AddingToAdmin) {
                SampDiagPrint( DISPLAY_ADMIN_CHANGES,
                           ("SAM DIAG: Protecting user %d as ADMIN account\n",
                            V1aFixed->UserId ) );
            } else {
                SampDiagPrint( DISPLAY_ADMIN_CHANGES,
                           ("SAM DIAG: Protecting user %d as non-admin account\n",
                            V1aFixed->UserId ) );
            }
#endif // SAMP_DIAGNOSTICS

            //
            // Get the old security descriptor so we can
            // modify it.
            //

            NtStatus = SampGetAccessAttribute(
                            UserContext,
                            SAMP_USER_SECURITY_DESCRIPTOR,
                            FALSE, // don't make copy
                            &Revision,
                            &OldDescriptor
                            );
            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampModifyAccountSecurity(
                                UserContext,
                                SampUserObjectType,
                                (BOOLEAN) ((NewAdminStatus != 0) ? TRUE : FALSE),
                                OldDescriptor,
                                &SecurityDescriptor,
                                &SecurityDescriptorLength
                                );
            }

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Write the new security descriptor into the object
                //

                NtStatus = SampSetAccessAttribute(
                               UserContext,
                               SAMP_USER_SECURITY_DESCRIPTOR,
                               SecurityDescriptor,
                               SecurityDescriptorLength
                               );

                RtlDeleteSecurityObject( &SecurityDescriptor );
            }
        }
    }

    if ( NT_SUCCESS( NtStatus ) ) {

        //
        // Save the fixed-length attributes
        //

        NtStatus = SampReplaceUserV1aFixed(
                        UserContext,
                        V1aFixed
                        );
    }


    if ( ( !NT_SUCCESS( NtStatus ) ) &&
        ( AddingToAdmin != AddToAdmin ) &&
        ( NtStatus != STATUS_SPECIAL_ACCOUNT ) ) {

        //
        // When an account is *removed* from admin groups, we can
        // ignore errors from this routine.  This routine is just
        // making the account accessible to account operators, but
        // it's no big deal if that doesn't work.  The administrator
        // can still get at it, so we should proceed with the calling
        // operation.
        //
        // Obviously, we can't ignore errors if we're being added
        // to an admin group, because that could be a security hole.
        //
        // Also, we want to make sure that the Administrator is
        // never removed, so we DO propogate STATUS_SPECIAL_ACCOUNT.
        //

        NtStatus = STATUS_SUCCESS;
    }

    return( NtStatus );
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Services Private to this process                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SamINotifyDelta (
    IN SAMPR_HANDLE DomainHandle,
    IN SECURITY_DB_DELTA_TYPE DeltaType,
    IN SECURITY_DB_OBJECT_TYPE ObjectType,
    IN ULONG ObjectRid,
    IN PUNICODE_STRING ObjectName,
    IN DWORD ReplicateImmediately,
    IN PSAM_DELTA_DATA DeltaData OPTIONAL
    )

/*++

Routine Description:

    Performs a change to some 'virtual' data in a domain. This is used by
    netlogon to get the domain modification count updated for cases where
    fields stored in the database replicated to a down-level machine have
    changed. These fields don't exist in the NT SAM database but netlogon
    needs to keep the SAM database and the down-level database modification
    counts in sync.

Arguments:

    DomainHandle - The handle of an opened domain to operate on.

    All other parameters match those in I_NetNotifyDelta.


Return Value:


    STATUS_SUCCESS - Domain modification count updated successfully.


--*/
{
    NTSTATUS                NtStatus, IgnoreStatus;
    PSAMP_OBJECT            DomainContext;
    SAMP_OBJECT_TYPE        FoundType;

    SAMTRACE("SamINotifyDelta");


    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   DOMAIN_ALL_ACCESS,       // Trusted client should succeed
                   SampDomainObjectType,    // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Dump the context - don't save the non-existent changes
        //

        NtStatus = SampDeReferenceContext( DomainContext, FALSE );
    }





    //
    // Commit changes, if successful, and notify Netlogon of changes.
    //

    if ( NT_SUCCESS(NtStatus) ) {

        //
        // This will increment domain count and write it out
        //

        NtStatus = SampCommitAndRetainWriteLock();

        if ( NT_SUCCESS( NtStatus ) ) {

            SampNotifyNetlogonOfDelta(
                DeltaType,
                ObjectType,
                ObjectRid,
                ObjectName,
                ReplicateImmediately,
                DeltaData
                );
        }
    }

    IgnoreStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(IgnoreStatus));


    return(NtStatus);
}


NTSTATUS
SamISetAuditingInformation(
    IN PPOLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo
    )

/*++

Routine Description:

    This function sets Policy Audit Event Info relevant to SAM Auditing

Arguments:

    PolicyAuditEventsInfo - Pointer to structure containing the
        current Audit Events Information.  SAM extracts values of
        relevance.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESSFUL - The call completed successfully.

        STATUS_UNSUCCESSFUL - The call was not successful because the
            SAM lock was not acquired.
--*/

{
    NTSTATUS NtStatus;

    SAMTRACE("SamISetAuditingInformation");

    //
    // Acquire the SAM Database Write Lock.
    //

    NtStatus = SampAcquireWriteLock();

    if (NT_SUCCESS(NtStatus)) {

        //
        // Set boolean if Auditing is on for Account Management
        //

        SampSetAuditingInformation( PolicyAuditEventsInfo );

        //
        // Release the SAM Database Write Lock.  No need to commit
        // the database transaction as there are no entries in the
        // transaction log.
        //

        NtStatus = SampReleaseWriteLock( FALSE );
    }

    return(NtStatus);
}


NTSTATUS
SampRtlConvertUlongToUnicodeString(
    IN ULONG Value,
    IN ULONG Base OPTIONAL,
    IN ULONG DigitCount,
    IN BOOLEAN AllocateDestinationString,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This function converts an unsigned long integer a Unicode String.
    The string contains leading zeros and is Unicode-NULL terminated.
    Memory for the output buffer can optionally be allocated by the routine.

    NOTE:  This routine may be eligible for inclusion in the Rtl library
           (possibly after modification).  It is modeled on
           RtlIntegerToUnicodeString

Arguments:

    Value - The unsigned long value to be converted.

    Base - Specifies the radix that the converted string is to be
        converted to.

    DigitCount - Specifies the number of digits, including leading zeros
        required for the result.

    AllocateDestinationString - Specifies whether memory of the string
        buffer is to be allocated by this routine.  If TRUE is specified,
        memory will be allocated via MIDL_user_allocate().  When this memory
        is no longer required, it must be freed via MIDL_user_free.  If
        FALSE is specified, the string will be appended to the output
        at the point marked by the Length field onwards.

    UnicodeString - Pointer to UNICODE_STRING structure which will receive
        the output string.  The Length field will be set equal to the
        number of bytes occupied by the string (excluding NULL terminator).
        If memory for the destination string is being allocated by
        the routine, the MaximumLength field will be set equal to the
        length of the string in bytes including the null terminator.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_NO_MEMORY - Insufficient memory for the output string buffer.

        STATUS_BUFFER_OVERFLOW - Buffer supplied is too small to contain the
            output null-terminated string.

        STATUS_INVALID_PARAMETER_MIX - One or more parameters are
            invalid in combination.

            - The specified Relative Id is too large to fit when converted
              into an integer with DigitCount digits.

        STATUS_INVALID_PARAMETER - One or more parameters are invalid.

            - DigitCount specifies too large a number of digits.
--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    UNICODE_STRING TempStringU, NumericStringU, OutputUnicodeStringU;
    USHORT OutputLengthAvailable, OutputLengthRequired, LeadingZerosLength;

    SAMTRACE("SamRtlConvertUlongToUnicodeString");

    OutputUnicodeStringU = *UnicodeString;
    RtlZeroMemory(&TempStringU,sizeof(UNICODE_STRING));
    RtlZeroMemory(&NumericStringU,sizeof(UNICODE_STRING));

    //
    // Verify that the maximum number of digits rquested has not been
    // exceeded.
    //

    if (DigitCount > SAMP_MAXIMUM_ACCOUNT_RID_DIGITS) {

        NtStatus = STATUS_INVALID_PARAMETER;
        goto ConvertUlongToUnicodeStringError;
    }

    OutputLengthRequired = (USHORT)((DigitCount + 1) * sizeof(WCHAR));

    //
    // Allocate the Destination String Buffer if requested
    //

    if (AllocateDestinationString) {

        NtStatus = STATUS_NO_MEMORY;
        OutputUnicodeStringU.MaximumLength = OutputLengthRequired;
        OutputUnicodeStringU.Length = (USHORT) 0;

        OutputUnicodeStringU.Buffer = MIDL_user_allocate(
                                          OutputUnicodeStringU.MaximumLength
                                          );

        if (OutputUnicodeStringU.Buffer == NULL) {

            goto ConvertUlongToUnicodeStringError;
        }
    }

    //
    // Compute the length available in the output string and compare it with
    // the length required.
    //

    OutputLengthAvailable = OutputUnicodeStringU.MaximumLength -
                            OutputUnicodeStringU.Length;


    NtStatus = STATUS_BUFFER_OVERFLOW;

    if (OutputLengthRequired > OutputLengthAvailable) {

        goto ConvertUlongToUnicodeStringError;
    }

    //
    // Create a Unicode String with capacity equal to the required
    // converted Rid Length
    //

    TempStringU.MaximumLength = OutputLengthRequired;

    TempStringU.Buffer = MIDL_user_allocate( TempStringU.MaximumLength );

    NtStatus = STATUS_NO_MEMORY;

    if (TempStringU.Buffer == NULL) {

        goto ConvertUlongToUnicodeStringError;
    }

    //
    // Convert the unsigned long value to a hexadecimal Unicode String.
    //

    NtStatus = RtlIntegerToUnicodeString( Value, Base, &TempStringU );

    if (!NT_SUCCESS(NtStatus)) {

        goto ConvertUlongToUnicodeStringError;
    }

    //
    // Prepend the requisite number of Unicode Zeros.
    //

    LeadingZerosLength = OutputLengthRequired - sizeof(WCHAR) - TempStringU.Length;

    if (LeadingZerosLength > 0) {

        RtlInitUnicodeString( &NumericStringU, L"00000000000000000000000000000000" );

        RtlCopyMemory(
            ((PUCHAR)OutputUnicodeStringU.Buffer) + OutputUnicodeStringU.Length,
            NumericStringU.Buffer,
            LeadingZerosLength
            );

        OutputUnicodeStringU.Length += LeadingZerosLength;
    }

    //
    // Append the converted string
    //

    RtlAppendUnicodeStringToString( &OutputUnicodeStringU, &TempStringU);

    *UnicodeString = OutputUnicodeStringU;
    NtStatus = STATUS_SUCCESS;

ConvertUlongToUnicodeStringFinish:

    if (TempStringU.Buffer != NULL) {

        MIDL_user_free( TempStringU.Buffer);
    }

    return(NtStatus);

ConvertUlongToUnicodeStringError:

    if (AllocateDestinationString) {

        if (OutputUnicodeStringU.Buffer != NULL) {

            MIDL_user_free( OutputUnicodeStringU.Buffer);
        }
    }

    goto ConvertUlongToUnicodeStringFinish;
}


NTSTATUS
SampRtlWellKnownPrivilegeCheck(
    BOOLEAN ImpersonateClient,
    IN ULONG PrivilegeId,
    IN OPTIONAL PCLIENT_ID ClientId
    )

/*++

Routine Description:

    This function checks if the given well known privilege is enabled for an
    impersonated client or for the current process.

Arguments:

    ImpersonateClient - If TRUE, impersonate the client.  If FALSE, don't
        impersonate the client (we may already be doing so).

    PrivilegeId -  Specifies the well known Privilege Id

    ClientId - Specifies the client process/thread Id.  If already
        impersonating the client, or impersonation is requested, this
        parameter should be omitted.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully and the client
            is either trusted or has the necessary privilege enabled.

--*/

{
    NTSTATUS Status, SecondaryStatus;
    BOOLEAN PrivilegeHeld = FALSE;
    HANDLE ClientThread = NULL, ClientProcess = NULL, ClientToken = NULL;
    OBJECT_ATTRIBUTES NullAttributes;
    PRIVILEGE_SET Privilege;
    BOOLEAN ClientImpersonatedHere = FALSE;
    BOOLEAN ImpersonatingNullSession = FALSE;

    SAMTRACE("SampRtlWellKnownPrivilegeCheck");

    InitializeObjectAttributes( &NullAttributes, NULL, 0, NULL, NULL );

    //
    // If requested, impersonate the client.
    //

    if (ImpersonateClient) {

        Status = SampImpersonateClient(&ImpersonatingNullSession);

        if ( !NT_SUCCESS(Status) ) {

            goto WellKnownPrivilegeCheckError;
        }

        ClientImpersonatedHere = TRUE;
    }

    //
    // If a client process other than ourself has been specified , open it
    // for query information access.
    //

    if (ARGUMENT_PRESENT(ClientId)) {

        if (ClientId->UniqueProcess != NtCurrentProcess()) {

            Status = NtOpenProcess(
                         &ClientProcess,
                         PROCESS_QUERY_INFORMATION,        // To open primary token
                         &NullAttributes,
                         ClientId
                         );

            if ( !NT_SUCCESS(Status) ) {

                goto WellKnownPrivilegeCheckError;
            }

        } else {

            ClientProcess = NtCurrentProcess();
        }
    }

    //
    // If a client thread other than ourself has been specified , open it
    // for query information access.
    //

    if (ARGUMENT_PRESENT(ClientId)) {

        if (ClientId->UniqueThread != NtCurrentThread()) {

            Status = NtOpenThread(
                         &ClientThread,
                         THREAD_QUERY_INFORMATION,
                         &NullAttributes,
                         ClientId
                         );

            if ( !NT_SUCCESS(Status) ) {

                goto WellKnownPrivilegeCheckError;
            }

        } else {

            ClientThread = NtCurrentThread();
        }

    } else {

        ClientThread = NtCurrentThread();
    }

    //
    // Open the specified or current thread's impersonation token (if any).
    //

    Status = NtOpenThreadToken(
                 ClientThread,
                 TOKEN_QUERY,
                 TRUE,
                 &ClientToken
                 );


    //
    // Make sure that we did not get any error in opening the impersonation
    // token other than that the token doesn't exist.
    //

    if ( !NT_SUCCESS(Status) ) {

        if ( Status != STATUS_NO_TOKEN ) {

            goto WellKnownPrivilegeCheckError;
        }

        //
        // The thread isn't impersonating...open the process's token.
        // A process Id must have been specified in the ClientId information
        // in this case.
        //

        if (ClientProcess == NULL) {

            Status = STATUS_INVALID_PARAMETER;
            goto WellKnownPrivilegeCheckError;
        }

        Status = NtOpenProcessToken(
                     ClientProcess,
                     TOKEN_QUERY,
                     &ClientToken
                     );

        //
        // Make sure we succeeded in opening the token
        //

        if ( !NT_SUCCESS(Status) ) {

            goto WellKnownPrivilegeCheckError;
        }
    }

    //
    // OK, we have a token open.  Now check for the privilege to execute this
    // service.
    //

    Privilege.PrivilegeCount = 1;
    Privilege.Control = PRIVILEGE_SET_ALL_NECESSARY;
    Privilege.Privilege[0].Luid = RtlConvertLongToLuid(PrivilegeId);
    Privilege.Privilege[0].Attributes = 0;

    Status = NtPrivilegeCheck(
                 ClientToken,
                 &Privilege,
                 &PrivilegeHeld
                 );

    if (!NT_SUCCESS(Status)) {

        goto WellKnownPrivilegeCheckError;
    }

    //
    // Generate any necessary audits
    //

    SecondaryStatus = NtPrivilegedServiceAuditAlarm (
                        &SampSamSubsystem,
                        &SampSamSubsystem,
                        ClientToken,
                        &Privilege,
                        PrivilegeHeld
                        );
    // ASSERT( NT_SUCCESS(SecondaryStatus) );


    if ( !PrivilegeHeld ) {

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto WellKnownPrivilegeCheckError;
    }

WellKnownPrivilegeCheckFinish:

    //
    // If we impersonated the client, revert to ourself.
    //

    if (ClientImpersonatedHere) {

        SampRevertToSelf(ImpersonatingNullSession);

    }

    //
    // If necessary, close the client Process.
    //

    if ((ARGUMENT_PRESENT(ClientId)) &&
        (ClientId->UniqueProcess != NtCurrentProcess()) &&
        (ClientProcess != NULL)) {

        SecondaryStatus = NtClose( ClientProcess );
        ASSERT(NT_SUCCESS(SecondaryStatus));
        ClientProcess = NULL;
    }

    //
    // If necessary, close the client token.
    //

    if (ClientToken != NULL) {

        SecondaryStatus = NtClose( ClientToken );
        ASSERT(NT_SUCCESS(SecondaryStatus));
        ClientToken = NULL;
    }

    //
    // If necessary, close the client thread
    //

    if ((ARGUMENT_PRESENT(ClientId)) &&
        (ClientId->UniqueThread != NtCurrentThread()) &&
        (ClientThread != NULL)) {

        SecondaryStatus = NtClose( ClientThread );
        ASSERT(NT_SUCCESS(SecondaryStatus));
        ClientThread = NULL;
    }

    return(Status);

WellKnownPrivilegeCheckError:

    goto WellKnownPrivilegeCheckFinish;
}



BOOLEAN
SampEventIsInSetup(
    IN  ULONG   EventID
    )

/*++

Routine Description:

    Routine that determines an Enent belongs to setup process or not

Arguments:

    EventID - event log ID.

Reture Value:

    TRUE: if this EventID belongs to setup process.

    FALSE: Event doesn't belong to setup.

--*/

{
    ULONG   i;

    for (i = 0; i < ARRAY_COUNT(EventsNotInSetupTable); i ++)
    {
        if ( EventsNotInSetupTable[i] == EventID )
        {
            return (FALSE);
        }
    }

    return(TRUE);
}


VOID
SampWriteEventLog (
    IN     USHORT      EventType,
    IN     USHORT      EventCategory   OPTIONAL,
    IN     ULONG       EventID,
    IN     PSID        UserSid         OPTIONAL,
    IN     USHORT      NumStrings,
    IN     ULONG       DataSize,
    IN     PUNICODE_STRING *Strings    OPTIONAL,
    IN     PVOID       Data            OPTIONAL
    )

/*++

Routine Description:

    Routine that adds an entry to the event log

Arguments:

    EventType - Type of event.

    EventCategory - EventCategory

    EventID - event log ID.

    UserSid - SID of user involved.

    NumStrings - Number of strings in Strings array

    DataSize - Number of bytes in Data buffer

    Strings - Array of unicode strings

    Data - Pointer to data buffer

Return Value:

    None.

--*/

{
    NTSTATUS NtStatus;
    UNICODE_STRING Source;
    HANDLE LogHandle;

    SAMTRACE("SampWriteEventLog");

    RtlInitUnicodeString(&Source, L"SAM");

    if (SampIsSetupInProgress(NULL) && SampEventIsInSetup(EventID) )
    {
        SampWriteToSetupLog(
            EventType,
            EventCategory,
            EventID,
            UserSid,
            NumStrings,
            DataSize,
            Strings,
            Data
            );
    }
    else
    {
        //
        // Open the log
        //

        NtStatus = ElfRegisterEventSourceW (
                            NULL,   // Server
                            &Source,
                            &LogHandle
                            );
        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                      "SAM: Failed to registry event source with event log, status = 0x%lx\n",
                      NtStatus));

            return;
        }



        //
        // Write out the event
        //

        NtStatus = ElfReportEventW (
                            LogHandle,
                            EventType,
                            EventCategory,
                            EventID,
                            UserSid,
                            NumStrings,
                            DataSize,
                            Strings,
                            Data,
                            0,       // Flags
                            NULL,    // Record Number
                            NULL     // Time written
                            );

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAM: Failed to report event to event log, status = 0x%lx\n",
                       NtStatus));
        }



        //
        // Close the event log
        //

        NtStatus = ElfDeregisterEventSource (LogHandle);

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAM: Failed to de-register event source with event log, status = 0x%lx\n",
                       NtStatus));
        }
    }
}




BOOL
SampShutdownNotification(
    DWORD   dwCtrlType
    )

/*++

Routine Description:

    This routine is called by the system when system shutdown is occuring.

    It causes the SAM registry to be flushed if necessary.

Arguments:



Return Value:

    FALSE - to allow any other shutdown routines in this process to
        also be called.



--*/
{
    NTSTATUS
        NtStatus;

    DWORD StartTime = 0;
    DWORD StopTime = 1;

    SAMP_SERVICE_STATE  PreviousServiceState;

    SAMTRACE("SampShutdownNotification");

    // BUG: Still flushing the registry on an NT5 DC.

    // When the DC's SAM is hosted exclusively on the DS, there will not
    // be a need to flush the registy, so fix this routine.

    if (dwCtrlType == CTRL_SHUTDOWN_EVENT) {

        // Set the service state to "terminating" so that LSA doesn't attempt to
        // access SAM at this point. and wait for active threads to terminate.
        // the shudown global is updated inside of this routine

        SampWaitForAllActiveThreads( &PreviousServiceState );

        //
        // Don't wait for the flush thread to wake up.
        // Flush the registry now if necessary ...
        //

        NtStatus = SampAcquireWriteLock();
        ASSERT( NT_SUCCESS(NtStatus) ); //Nothing we can do if this fails

        if ( NT_SUCCESS( NtStatus ) ) {

            if ( PreviousServiceState != SampServiceDemoted )
            {

                //
                // This flush use to be done only if FlushThreadCreated
                // was true.  However, we seem to have a race condition
                // at setup that causes an initial replication to be
                // lost (resulting in an additional replication).
                // Until we resolve this problem, always flush on
                // shutdown.
                //

                NtStatus = NtFlushKey( SampKey );

                if (!NT_SUCCESS( NtStatus )) {
                    DbgPrint("NtFlushKey failed, Status = %X\n",NtStatus);
                    ASSERT( NT_SUCCESS(NtStatus) );
                }

                //
                // Flush the Netlogon Change numbers to Disk, for the account
                // domain.
                //

                if ((TRUE==SampUseDsData)&&(FALSE==SampDatabaseHasAlreadyShutdown))
                {
                    SampFlushNetlogonChangeNumbers();
                }
            }

            SampReleaseWriteLock( FALSE );
        }


        if ((TRUE == SampUseDsData)
                && (FALSE==SampDatabaseHasAlreadyShutdown))
        {
                    // Clean up the RID Manager, release resources, etc.


            if (TRUE==SampRidManagerInitialized)
            {
                NtStatus = SampDomainRidUninitialization();
                if (!NT_SUCCESS(NtStatus))
                {
                    KdPrintEx((DPFLTR_SAMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "SAMSS: SampDomainRidUninitialize status = 0x%lx\n",
                               NtStatus));
                }
            }


            // Terminate and close the DS database if this is a DC. If this
            // call fails, or is skipped, Jet will incorrectly terminate and
            // corrupt the database tables. Rebooting the system will cause
            // Jet to repair the database, which may take a long time.

            StartTime = GetTickCount();
            NtStatus = SampDsUninitialize();
            StopTime = GetTickCount();

            SampDiagPrint(INFORM,
                          ("SAMSS: DsUninitialize took %lu second(s) to complete\n",
                           ((StopTime - StartTime) / 1000)));

            if (NT_SUCCESS(NtStatus))
            {
                SampDatabaseHasAlreadyShutdown = TRUE;
            }

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampDsUninitialize status = 0x%lx\n",
                       NtStatus));
        }

    }

    return(FALSE);
}


NTSTATUS
SampGetAccountDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo
    )

/*++

Routine Description:

    This routine retrieves ACCOUNT domain information from the LSA
    policy database.


Arguments:

    PolicyAccountDomainInfo - Receives a pointer to a
        POLICY_ACCOUNT_DOMAIN_INFO structure containing the account
        domain info.



Return Value:

    STATUS_SUCCESS - Succeeded.

    Other status values that may be returned from:

        LsarQueryInformationPolicy()
--*/

{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    LSAPR_HANDLE
        PolicyHandle;

    SAMTRACE("SampGetAccountDomainInfo");


    NtStatus = LsaIOpenPolicyTrusted( &PolicyHandle );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Query the account domain information
        //

        NtStatus = LsarQueryInformationPolicy(
                       PolicyHandle,
                       PolicyAccountDomainInformation,
                       (PLSAPR_POLICY_INFORMATION *)PolicyAccountDomainInfo
                       );

        if (NT_SUCCESS(NtStatus)) {

            if ( (*PolicyAccountDomainInfo)->DomainSid == NULL ) {

                NtStatus = STATUS_INVALID_SID;
            }
        }

        IgnoreStatus = LsarClose( &PolicyHandle );


        ASSERT(NT_SUCCESS(IgnoreStatus));

    }

#if DBG
    if ( NT_SUCCESS(NtStatus) ) {
        ASSERT( (*PolicyAccountDomainInfo) != NULL );
        ASSERT( (*PolicyAccountDomainInfo)->DomainName.Buffer != NULL );
    }
#endif //DBG

    return(NtStatus);
}


NTSTATUS
SampFindUserA2D2Attribute(
    ATTRBLOCK *AttrsRead,
    PUSER_ALLOWED_TO_DELEGATE_TO_LIST *A2D2List)
{
    ULONG i,j;

    *A2D2List = NULL;

    for (i=0;i<AttrsRead->attrCount;i++)
    {
        if (AttrsRead->pAttr[i].attrTyp == SAMP_USER_A2D2LIST)
        {
           
            //
            // Compute the size
            //

            ULONG NumSPNs = AttrsRead->pAttr[i].AttrVal.valCount;
            ULONG Size= sizeof(USER_ALLOWED_TO_DELEGATE_TO_LIST) +
                          (NumSPNs-1)*sizeof(UNICODE_STRING);
            ULONG_PTR SPNOffset = (ULONG_PTR) Size;

            for (j=0;j<NumSPNs;j++)
            {
                Size+=AttrsRead->pAttr[i].AttrVal.pAVal[j].valLen;
            }

            //
            // Allocate memory
            //

            *A2D2List = MIDL_user_allocate(Size);
            if (NULL==*A2D2List)
            {
                return(STATUS_INSUFFICIENT_RESOURCES);
            }

            (*A2D2List)->Size = Size;
            (*A2D2List)->NumSPNs = NumSPNs;

            //
            // Fill in the pointers
            //

            for (j=0;j<NumSPNs;j++)
            {
                (*A2D2List)->SPNList[j].Length =
                    (*A2D2List)->SPNList[j].MaximumLength =
                       (USHORT) AttrsRead->pAttr[i].AttrVal.pAVal[j].valLen;
                (ULONG_PTR) (*A2D2List)->SPNList[j].Buffer = SPNOffset +
                                     (ULONG_PTR) (*A2D2List);
                RtlCopyMemory(
                    (*A2D2List)->SPNList[j].Buffer,
                    AttrsRead->pAttr[i].AttrVal.pAVal[j].pVal,
                    (*A2D2List)->SPNList[j].Length
                    );

                SPNOffset+=  (ULONG_PTR) (*A2D2List)->SPNList[j].Length;
            }

            break;
        }
    }


    return(STATUS_SUCCESS);
}


                       

//
// Additional Attributes to be fetched and kept in SAM context
// blocks. These are attributes defined in addition to what NT4
// SAM kept in the OnDisk structure of SAM context's.
//

ATTRTYP UserAdditionalAttrs[] =
{
    SAMP_FIXED_USER_SUPPLEMENTAL_CREDENTIALS,
    SAMP_FIXED_USER_LOCKOUT_TIME,
    SAMP_FIXED_USER_LAST_LOGON_TIMESTAMP,
    SAMP_FIXED_USER_UPN,
    SAMP_FIXED_USER_SITE_AFFINITY,
    SAMP_USER_A2D2LIST
};

ATTRTYP GroupAdditionalAttrs[] =
{
    SAMP_FIXED_GROUP_TYPE
};

ATTRTYP AliasAdditionalAttrs[] =
{
    SAMP_FIXED_ALIAS_TYPE
};


NTSTATUS
SampDsFillContext(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PSAMP_OBJECT     NewContext,
    IN ATTRBLOCK        AttrsRead,
    IN ATTRBLOCK        AttrsAsked,
    IN ULONG            TotalAttrsAsked,
    IN ULONG            FixedAttrsAsked,
    IN ULONG            VariableAttrsAsked
    )
/*++

      Routine Description:

      Given a Context,  and object type specifying the object in the
      DS, and an attrblock that describes all the SAM relevant properties, this routine
      fills the context with all the information. Since the DS simply "drops the attr"
      if a value is not present without any error indication, the caller needs to
      have logic to keep track of what types of attrs were missed out etc. Therefore
      the total count of attributes, plus fixed and var length attributes asked are
      passed in. This is used to track the dividing line between the variable and fixed
      length attrs. The attr block that was asked is supposed to be in the following
      general format

                            ____________
                            |           |  Object Class
                            _____________
                            |           |
                            |           |
                            |           |   Fixed Attributes
                            |           |
                            -------------
                            |           |
                            |           |   Variable Attributes
                            |           |
                            _____________
                            |           |
                            |           |   Misc additional attributes
                            _____________

      Parameters:

            ObjectType --- Object Type
            NewContext --- The new context where the data needs to be stuffed in
            AttrsRead  --- The Set of attributes describing "SAM relevant data" read from
                           the database
            AttrsAsked --- The set of attributes that were asked from the database
            TotalAttrsAsked -- The total number of attributes that were asked
            FixedAttrsAsked -- The total number of fixed length SAM attributes asked
            VariableAttrsAsked -- The total number of variable length SAM attributes asked


      Return Values:

        STATUS_SUCCESS
        Other Error codes pertaining to resource failures
--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    PVOID               SamFixedAttributes=NULL;
    PVOID               SamVariableAttributes=NULL;
    ATTRBLOCK           FixedAttrs;
    ATTRBLOCK           VariableAttrs;
    ULONG               FixedLength=0;
    ULONG               VariableLength=0;
    ULONG               i,j;


    // Due to missing attributes on the object, the result is not guaranteed
    // to be in the same order.  So make a new result set which is the same order
    // as the requested result set.

    SAMP_ALLOCA(FixedAttrs.pAttr,FixedAttrsAsked * sizeof(ATTR));
    if (NULL==FixedAttrs.pAttr)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    //
    // Generate an Attrblock containing just the fixed attributes, in the order
    // they were allocatated
    //

    FixedAttrs.attrCount = 0;

    for ( i = 1; i < (1 + FixedAttrsAsked); i++ )
    {
        for ( j = 0; j < AttrsRead.attrCount; j++ )
        {
            if ( AttrsAsked.pAttr[i].attrTyp == AttrsRead.pAttr[j].attrTyp )
            {
                FixedAttrs.pAttr[FixedAttrs.attrCount++] = AttrsRead.pAttr[j];
                ASSERT(FixedAttrs.attrCount<=FixedAttrsAsked);
                break;
            }
        }
    }


    //
    // Convert that Attrblock into a SAM OnDisk, containing the fixed
    // length attributes
    //

    NtStatus = SampDsConvertReadAttrBlock(
                                    ObjectType,
                                    SAMP_FIXED_ATTRIBUTES,
                                    &FixedAttrs,
                                    &SamFixedAttributes,
                                    &FixedLength,
                                    &VariableLength);

    if ( !NT_SUCCESS(NtStatus) || (NULL == SamFixedAttributes) )
    {
        if (NULL==SamFixedAttributes)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        goto Error;
    }

    //
    // Update this OnDisk onto the SAM context
    //

    NtStatus = SampDsUpdateContextAttributes(
                    NewContext,
                    SAMP_FIXED_ATTRIBUTES,
                    SamFixedAttributes,
                    FixedLength,
                    VariableLength
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    //
    // Generate an Attrblock containing the variable attributes
    //

    SAMP_ALLOCA(VariableAttrs.pAttr,VariableAttrsAsked * sizeof(ATTR));
    if (NULL==VariableAttrs.pAttr)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    VariableAttrs.attrCount = 0;

    for ( i = (1 + FixedAttrsAsked); i < 1+FixedAttrsAsked+VariableAttrsAsked; i++ )
    {
        for ( j = 0; j < AttrsRead.attrCount; j++ )
        {
            if ( AttrsAsked.pAttr[i].attrTyp == AttrsRead.pAttr[j].attrTyp )
            {
                VariableAttrs.pAttr[VariableAttrs.attrCount++] = AttrsRead.pAttr[j];
                ASSERT(VariableAttrs.attrCount<=VariableAttrsAsked);
                break;
            }
        }
    }


    FixedLength = 0;
    VariableLength = 0;

    //
    // Convert this attrblock into a SAM variable length attribute on Disk
    //

    NtStatus = SampDsConvertReadAttrBlock(
                    ObjectType,
                    SAMP_VARIABLE_ATTRIBUTES,
                    &VariableAttrs,
                    &SamVariableAttributes,
                    &FixedLength,
                    &VariableLength
                    );

    if ( !NT_SUCCESS(NtStatus) || (NULL == SamVariableAttributes))
    {
        if (NULL==SamVariableAttributes)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        goto Error;
    }


    //
    // Update this onto the Context
    //

    NtStatus = SampDsUpdateContextAttributes(
                    NewContext,
                    SAMP_VARIABLE_ATTRIBUTES,
                    SamVariableAttributes,
                    FixedLength,
                    VariableLength
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // For User object type, scan the attributes array to see if any
    // supplementary credentials was returned, if so cache it in the
    // context
    //

    if (SampUserObjectType==ObjectType)
    {
        ATTR * SupplementalCredentials = NULL;
        ATTR * LockoutTime = NULL, * LastLogonTimeStamp = NULL;
        ATTR * UPN = NULL;
        ATTR * AccountName = NULL;
        ATTR * SiteAffinity = NULL;

        NewContext->TypeBody.User.CachedSupplementalCredentialLength =0;
        NewContext->TypeBody.User.CachedSupplementalCredentials = NULL;

        SupplementalCredentials = SampDsGetSingleValuedAttrFromAttrBlock(
                                        SAMP_FIXED_USER_SUPPLEMENTAL_CREDENTIALS,
                                        &AttrsRead
                                        );

        if (NULL!=SupplementalCredentials)
        {
            NewContext->TypeBody.User.CachedSupplementalCredentials
                = MIDL_user_allocate(SupplementalCredentials->AttrVal.pAVal[0].valLen);
            if (NULL==NewContext->TypeBody.User.CachedSupplementalCredentials)
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }

            RtlCopyMemory(
                NewContext->TypeBody.User.CachedSupplementalCredentials,
                SupplementalCredentials->AttrVal.pAVal[0].pVal,
                SupplementalCredentials->AttrVal.pAVal[0].valLen);

            NewContext->TypeBody.User.CachedSupplementalCredentialLength =
                    SupplementalCredentials->AttrVal.pAVal[0].valLen;

        }

        //
        // Indicate we have valid, cached supplemental credentials. If we did
        // not manage to read it in the DS, it means that it is not set, and
        // this is equivalent to caching the fact that there are no credentials
        //

        NewContext->TypeBody.User.CachedSupplementalCredentialsValid = TRUE;

        //
        // Next, retrieve LockoutTime for the user's account, and cache it
        // in the user-body portion of the account context.
        //

        RtlZeroMemory(&(NewContext->TypeBody.User.LockoutTime),
                      sizeof(LARGE_INTEGER));


        LockoutTime = SampDsGetSingleValuedAttrFromAttrBlock(
                        SAMP_FIXED_USER_LOCKOUT_TIME,
                        &AttrsRead
                        );

        if (NULL != LockoutTime)
        {
            RtlCopyMemory(&(NewContext->TypeBody.User.LockoutTime),
                          LockoutTime->AttrVal.pAVal[0].pVal,
                          LockoutTime->AttrVal.pAVal[0].valLen);
        }

        //
        // Get LastLogonTimeStamp for the user account, and cache it 
        // in the user-body portion of the account context
        //

        RtlZeroMemory(&(NewContext->TypeBody.User.LastLogonTimeStamp),
                      sizeof(LARGE_INTEGER));


        LastLogonTimeStamp = SampDsGetSingleValuedAttrFromAttrBlock(
                                SAMP_FIXED_USER_LAST_LOGON_TIMESTAMP,
                                &AttrsRead
                                );

        if (NULL != LastLogonTimeStamp)
        {
            RtlCopyMemory(&(NewContext->TypeBody.User.LastLogonTimeStamp),
                          LastLogonTimeStamp->AttrVal.pAVal[0].pVal,
                          LastLogonTimeStamp->AttrVal.pAVal[0].valLen);
        }


        //
        // Add the UPN into the context
        //


        UPN = SampDsGetSingleValuedAttrFromAttrBlock(
                                        SAMP_FIXED_USER_UPN,
                                        &AttrsRead
                                        );

        if (NULL!=UPN)
        {
            NewContext->TypeBody.User.UPN.Buffer
                = MIDL_user_allocate(UPN->AttrVal.pAVal[0].valLen);
            if (NULL==NewContext->TypeBody.User.UPN.Buffer)
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }

            RtlCopyMemory(
                NewContext->TypeBody.User.UPN.Buffer,
                UPN->AttrVal.pAVal[0].pVal,
                UPN->AttrVal.pAVal[0].valLen);

            NewContext->TypeBody.User.UPN.Length =
                NewContext->TypeBody.User.UPN.MaximumLength =
                    (USHORT) UPN->AttrVal.pAVal[0].valLen;

            NewContext->TypeBody.User.UpnDefaulted = FALSE;

        }
        else
        {

            PUNICODE_STRING DefaultDomainName =
                &SampDefinedDomains[NewContext->DomainIndex].DnsDomainName;
            ULONG   DefaultUpnLength;

            //
            // Default the UPN in the context to accountname@dnsdomain domain name
            //

            AccountName = SampDsGetSingleValuedAttrFromAttrBlock(
                                        SAMP_USER_ACCOUNT_NAME,
                                        &AttrsRead
                                        );

            if (NULL==AccountName)
            {
                ASSERT(FALSE && "AccountName must exist");
                NtStatus = STATUS_INTERNAL_ERROR;
                goto Error;
            }

            DefaultUpnLength = AccountName->AttrVal.pAVal[0].valLen+
                                        DefaultDomainName->Length+2;

            NewContext->TypeBody.User.UPN.Buffer
                = MIDL_user_allocate(DefaultUpnLength);

            if (NULL==NewContext->TypeBody.User.UPN.Buffer)
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }

            RtlCopyMemory(
                NewContext->TypeBody.User.UPN.Buffer,
                AccountName->AttrVal.pAVal[0].pVal,
                AccountName->AttrVal.pAVal[0].valLen);


            RtlCopyMemory(
                (PBYTE)(NewContext->TypeBody.User.UPN.Buffer) + AccountName->AttrVal.pAVal[0].valLen + 2 ,
                DefaultDomainName->Buffer,
                DefaultDomainName->Length);

            *(NewContext->TypeBody.User.UPN.Buffer + AccountName->AttrVal.pAVal[0].valLen/2) = L'@';

            NewContext->TypeBody.User.UPN.Length =
                NewContext->TypeBody.User.UPN.MaximumLength =
                    (USHORT) DefaultUpnLength;

            NewContext->TypeBody.User.UpnDefaulted = TRUE;


        }

        //
        // Find and our site affinity
        //
        {
            NTSTATUS NtStatus2;
            SAMP_SITE_AFFINITY SiteAffinityTmp;

            NtStatus2 = SampFindUserSiteAffinity( NewContext,
                                                  &AttrsRead, 
                                                  &SiteAffinityTmp );
    
            if ( NT_SUCCESS(NtStatus2) ) {
                RtlCopyMemory(&NewContext->TypeBody.User.SiteAffinity,
                              &SiteAffinityTmp,
                              sizeof(SAMP_SITE_AFFINITY));
            }
        }

        //
        // Find the A2D2 attribute
        //

        NtStatus = SampFindUserA2D2Attribute(
                         &AttrsRead,
                         &NewContext->TypeBody.User.A2D2List 
                         );


    }

Error:

    //
    // Free the SAM attributes
    //

    if (NULL!=SamFixedAttributes)
    {
        RtlFreeHeap(RtlProcessHeap(),0,SamFixedAttributes);
    }

    if (NULL!=SamVariableAttributes)
    {
        RtlFreeHeap(RtlProcessHeap(),0,SamVariableAttributes);
    }

    return NtStatus;
}
NTSTATUS
SampDsCheckObjectTypeAndFillContext(
    IN  SAMP_OBJECT_TYPE    ObjectType,
    IN  PSAMP_OBJECT        NewContext,
    IN  ULONG               WhichFields,
    IN  ULONG               ExtendedFields,
    IN  BOOLEAN             OverrideLocalGroupCheck
    )
/*++

    This routine checks for the correct object type and reads both the fixed and variable
    attributes in a single DS read. This improves the performance of account opens.
    All "relevant" properties of the object are cached in the handle as part of the routine
    This strategy has been shown to improve performance as this eliminates subsequent
    calls to the core DS.

    Parameters:

        SampObjectType -- The type of the object
        NewContext     -- Pointer to a New context,
                          that in the process of creation for the object
        WhichFields    -- Indicates the fields of a UserAllInformationStructure
                          that is desired

        ExtendedFields -- Indicates the extended fields in a UserInternal6Information
                          structure that is desired.


    Return Values

        STATUS_SUCCESS
        Other Error codes from DS

--*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    NTSTATUS            NotFoundStatus = STATUS_NO_SUCH_USER;
    ULONG               AccountType = 0;
    ATTR                *AccountTypeAttr;
    ATTRBLOCK           DesiredAttrs;
    ATTRBLOCK           AttrsRead;
    ATTRBLOCK           FixedAttrs;
    ATTRBLOCK           VariableAttrs;
    ATTRBLOCK           TempAttrs;
    ULONG               ObjectTypeStoredInDs;
    ULONG               i;
    ULONG               AdditionalAttrIndex=0;
    ATTRTYP             *AdditionalAttrs = NULL;
    ULONG               AdditionalAttrCount = 0;
    SAMP_OBJECT_TYPE    ObjectTypeToRead = ObjectType;
    ATTR                *GroupTypeAttr = NULL;
    ULONG               GroupType;
    ATTRTYP             AttrTypForGroupType = 0;
    NT4_GROUP_TYPE      DesiredNT4GroupType = NT4LocalGroup,
                        NT4GroupType;
    NT5_GROUP_TYPE      NT5GroupType;
    BOOLEAN             SecurityEnabled;
    BOOLEAN             SidOnlyName = FALSE;
    ULONG               Rid;

    ASSERT( (ObjectType == SampGroupObjectType) ||
            (ObjectType == SampAliasObjectType) ||
            (ObjectType == SampUserObjectType) );

    switch (ObjectType)
    {
    case SampGroupObjectType:
        NotFoundStatus = STATUS_NO_SUCH_GROUP;
        AccountType = SAMP_GROUP_ACCOUNT_TYPE;
        AdditionalAttrCount = ARRAY_COUNT(GroupAdditionalAttrs);
        AdditionalAttrs = GroupAdditionalAttrs;
        AttrTypForGroupType = SAMP_FIXED_GROUP_TYPE;
        DesiredNT4GroupType = NT4GlobalGroup;
        break;
    case SampAliasObjectType:
        NotFoundStatus = STATUS_NO_SUCH_ALIAS;
        AccountType = SAMP_ALIAS_ACCOUNT_TYPE;
        AdditionalAttrCount = ARRAY_COUNT(AliasAdditionalAttrs);
        AdditionalAttrs = AliasAdditionalAttrs;
        AttrTypForGroupType = SAMP_FIXED_ALIAS_TYPE;
        DesiredNT4GroupType = NT4LocalGroup;
        break;
    case SampUserObjectType:
        NotFoundStatus = STATUS_NO_SUCH_USER;
        AccountType = SAMP_USER_ACCOUNT_TYPE;
        AdditionalAttrCount = ARRAY_COUNT(UserAdditionalAttrs);
        AdditionalAttrs = UserAdditionalAttrs;
        break;
    }

    
    //
    // Construct the fixed attr block def.
    //

    NtStatus = SampDsMakeAttrBlock(
                            ObjectType,
                            SAMP_FIXED_ATTRIBUTES,
                            WhichFields,
                            &FixedAttrs);

    if ( NT_SUCCESS(NtStatus) && (NULL == FixedAttrs.pAttr) )
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else if ( NT_SUCCESS(NtStatus) && (NULL != FixedAttrs.pAttr) )
    {
        //
        // Construct the variable attr block def.
        //

        NtStatus = SampDsMakeAttrBlock(
                                ObjectType,
                                SAMP_VARIABLE_ATTRIBUTES,
                                WhichFields,
                                &VariableAttrs);

        if ( NT_SUCCESS(NtStatus) && (NULL == VariableAttrs.pAttr) )
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else if ( NT_SUCCESS(NtStatus) && (NULL != VariableAttrs.pAttr) )
        {
            //
            // Allocate one big DesiredAttrs block.
            //

            DesiredAttrs.attrCount = 1; // object class
            DesiredAttrs.attrCount += FixedAttrs.attrCount;
            DesiredAttrs.attrCount += VariableAttrs.attrCount;


            //
            // Additional Attrs may be required depending upon
            // the object Type. For example we cache supplemental
            // credentials for the user object, or get the group
            // type for groups into the context
            //

            AdditionalAttrIndex = DesiredAttrs.attrCount;
            DesiredAttrs.attrCount += AdditionalAttrCount;

            SAMP_ALLOCA(DesiredAttrs.pAttr,DesiredAttrs.attrCount*sizeof(ATTR)); 

            if ( NULL == DesiredAttrs.pAttr )
            {
                NtStatus = STATUS_NO_MEMORY;
            }
            else
            {
                // Fill in DesiredAttrs.

                DesiredAttrs.pAttr[0].attrTyp = AccountType;
                DesiredAttrs.pAttr[0].AttrVal.valCount = 0;
                DesiredAttrs.pAttr[0].AttrVal.pAVal = NULL;

                RtlCopyMemory(
                        &DesiredAttrs.pAttr[1],
                        FixedAttrs.pAttr,
                        FixedAttrs.attrCount * sizeof(ATTR));

                RtlCopyMemory(
                        &DesiredAttrs.pAttr[1 + FixedAttrs.attrCount],
                        VariableAttrs.pAttr,
                        VariableAttrs.attrCount * sizeof(ATTR));

                // Fill in additional Attrs

                for(i=0;i<AdditionalAttrCount;i++)
                {
                    ATTR * pAttr;

                    pAttr = &(DesiredAttrs.pAttr[i+AdditionalAttrIndex]);
                    pAttr->attrTyp = AdditionalAttrs[i];
                    pAttr->AttrVal.valCount = 0;
                    pAttr->AttrVal.pAVal = NULL;
                }

            }

            RtlFreeHeap(RtlProcessHeap(), 0, VariableAttrs.pAttr);
        }

        RtlFreeHeap(RtlProcessHeap(), 0, FixedAttrs.pAttr);
    }

    if ( !NT_SUCCESS(NtStatus) )
    {
        return(NtStatus);
    }


    //
    // Grab the RID of the object , and also note if it was a SID only
    // name. This check needs to take place before the call into Dir Read
    //


    if ((NewContext->ObjectNameInDs->SidLen>0) &&
        (NewContext->ObjectNameInDs->NameLen==0) &&
        (fNullUuid(&NewContext->ObjectNameInDs->Guid)))
    {
        SidOnlyName = TRUE;
    }




    //
    // Do the read
    //

    NtStatus = SampDsRead(
                NewContext->ObjectNameInDs,
                SAM_ALLOW_REORDER,
                ObjectTypeToRead,
                &DesiredAttrs,
                &AttrsRead
                );

    //
    // Currently all errors in the above routine go through the error handing
    // path below, which does additional database accesses to check for 
    // Duplicate SID errors. However it is only necessary to take the path
    // below for duplicate SID errors alone. Since the error path is executed
    // only very rarely , it is O.K to take the performance hit on all error
    // paths.  
    //

    if ((!NT_SUCCESS(NtStatus)) &&(SidOnlyName))
    {
        DSNAME * Object;
        NTSTATUS TmpStatus;

         SampSplitSid(
            &NewContext->ObjectNameInDs->Sid,
            NULL,
            &Rid
            );

        //
        // Search for the object, so that we may get all the Duplicates and walk through
        // them and handle them.
        //

        TmpStatus = SampDsLookupObjectByRid(
                            ROOT_OBJECT,
                            Rid,
                            &Object
                            );

        if (NT_SUCCESS(TmpStatus))
        {
            MIDL_user_free(Object);
        }
    }



    if ( NT_SUCCESS(NtStatus) )
    {
        //
        // Fish out the Account Type
        //

        AccountTypeAttr = SampDsGetSingleValuedAttrFromAttrBlock(
                                AccountType,
                                &AttrsRead
                                );

        if (NULL!= AccountTypeAttr)
        {
            ULONG AccountTypeVal;

            //
            // Account Type was Successfully Read
            //

            AccountTypeVal = *((UNALIGNED ULONG *) AccountTypeAttr->AttrVal.pAVal[0].pVal);

            //
            // Mask out insignificant account type bits
            //

            AccountTypeVal &=0xF0000000;

            //
            // Get the Object Type stored in the DS
            //

            switch(AccountTypeVal)
            {
                case SAM_GROUP_OBJECT:
                case SAM_ALIAS_OBJECT:
                    ObjectTypeStoredInDs = SampGroupObjectType;
                    break;
                case SAM_USER_OBJECT:
                    ObjectTypeStoredInDs = SampUserObjectType;
                    break;
                default:
                    ASSERT(FALSE && "Unknown Object Type");
                    ObjectTypeStoredInDs = SampUnknownObjectType;
                    break;

            }

            //
            // Depending upon Object Type, and enforce the object type
            // check
            //

            switch(ObjectType)
            {
            case SampAliasObjectType:
            case SampGroupObjectType:

                // Initialize default return
                NtStatus = NotFoundStatus;

                GroupTypeAttr = SampDsGetSingleValuedAttrFromAttrBlock(
                                    AttrTypForGroupType,
                                    &AttrsRead
                                    );

                if ((NULL!=GroupTypeAttr) && (ObjectTypeStoredInDs==SampGroupObjectType))
                {
                    ULONG           GroupTypeTmp;
                    NTSTATUS        TmpStatus;

                    GroupTypeTmp = *((UNALIGNED ULONG *) GroupTypeAttr->AttrVal.pAVal[0].pVal);
                    TmpStatus = SampComputeGroupType(
                                    CLASS_GROUP,
                                    GroupTypeTmp,
                                    &NT4GroupType,
                                    &NT5GroupType,
                                    &SecurityEnabled
                                    );

                    if ((NT_SUCCESS(TmpStatus))
                       && (OverrideLocalGroupCheck ||
                          (NT4GroupType==DesiredNT4GroupType)))
                    {
                        NtStatus = STATUS_SUCCESS;
                        if (SampAliasObjectType==ObjectType)
                        {
                            NewContext->TypeBody.Alias.NT4GroupType = NT4GroupType;
                            NewContext->TypeBody.Alias.NT5GroupType = NT5GroupType;
                            NewContext->TypeBody.Alias.SecurityEnabled = SecurityEnabled;
                        }
                        else
                        {
                            NewContext->TypeBody.Group.NT4GroupType = NT4GroupType;
                            NewContext->TypeBody.Group.NT5GroupType = NT5GroupType;
                            NewContext->TypeBody.Group.SecurityEnabled = SecurityEnabled;
                        }

                    }
                }

                break;

            case SampUserObjectType:

                if ( (ULONG) ObjectType != ObjectTypeStoredInDs )
                {
                    NtStatus = NotFoundStatus;
                }
                break;
            }
        }
        else
        {
            NtStatus = NotFoundStatus;
        }

        if (NT_SUCCESS(NtStatus))
        {
            //
            //  Fill all the data in the context
            //

            NtStatus = SampDsFillContext(
                            ObjectType,
                            NewContext,
                            AttrsRead,
                            DesiredAttrs,
                            DesiredAttrs.attrCount,
                            FixedAttrs.attrCount,
                            VariableAttrs.attrCount
                            );

            if (0!=WhichFields)
            {
                //
                // If we prefetched only some and not others then mark the
                // attributes being only partially valid in the context
                //

                NewContext->AttributesPartiallyValid = TRUE;

                //
                // Mark per attribute invalid bits from WhichFields
                //

                SampMarkPerAttributeInvalidFromWhichFields(NewContext,WhichFields);
            }
        }


    }

    return(NtStatus);
}


BOOLEAN
SampNetLogonNotificationRequired(
    PSID ObjectSid,
    SAMP_OBJECT_TYPE    SampObjectType
    )
/*++

  Routine Description:

    This Routine Checks the defined domains array for the Given Sid and based on the Sid,
    determines if net logon notification is required.

  Parameters:

    ObjectSid   -- The Sid of the object, that is about to be modified.
    SampObjectType -- The type of the SAM object that is about to be modified
    fNotificationRequired -- Out Parameter, finds out if notification is required.

  Return Values

    TRUE    Notification is required
    FALSE   Notification is not required

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       i;
    PSID        DomainSid = NULL;
    ULONG       Rid;
    PSID        SidToCheck;
    BOOLEAN     fNotificationRequired = FALSE;
    BOOLEAN     LockAcquired = FALSE;



    if (!SampCurrentThreadOwnsLock())
    {
        SampAcquireSamLockExclusive();
        LockAcquired = TRUE;
    }

    //
    // The Ds better be calling us only when we are in DS Mode. The Exception to this is in
    // the Replicated Setup Case. Sam is booted in registry mode and the DS will enquire about
    // notifications to SAM while changes replicate in. Bail out saying no notifications are
    // needed.
    //

    if (FALSE==SampUseDsData)
    {
        fNotificationRequired = FALSE;
    }
    else
    {

        //
        // Copy the Passed in Sid into SidToCheck
        //

        SAMP_ALLOCA(SidToCheck,RtlLengthSid(ObjectSid));
        if (NULL==SidToCheck)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        RtlCopyMemory(SidToCheck,ObjectSid, RtlLengthSid(ObjectSid));

        //
        // For domain objects the passed in objectsid is checked in
        // the defined domains array. For other object's the domain Sid
        // is obtained and that checked in the defined domains array
        //

        if (SampDomainObjectType != SampObjectType)
        {
            //
            // The Sid is an account Sid. Obtain the Domain Sid by just decrementing
            // the sub-authority count. We do not want to call split Sid because that
            // routine will allocate memory and we should not fail in here
            //

            (*RtlSubAuthorityCountSid(SidToCheck))--;

        }
        else
        {
            //
            // Nothing to Do, SidToCheck is Domain Sid
            //
        }

        //
        // Walk through the list of defined domains arrays, for domain objects.
        //

        //
        // If we are the G.C and if the domain object is in the builtin domain, then we
        // will supply notifications to netlogon, for change in any of the builtin domains
        // in the G.C . Fortunately built domain objects do not change very often, and
        // therefore its not worthwile adding the extra check.
        //
        //


        for (i=SampDsGetPrimaryDomainStart();i<SampDefinedDomainsCount;i++)
        {
            //
            // If the Domain Sid Matches, then we
            // need to supply the notification.
            //


            if (RtlEqualSid(SampDefinedDomains[i].Sid,SidToCheck))
            {
                //
                // The Sid Matches
                //

                fNotificationRequired = TRUE;
                break;
            }
        }
    }

Error:

    if (LockAcquired)
    {
        SampReleaseSamLockExclusive();
    }

    return fNotificationRequired;
}


NTSTATUS
SampNotifyKdcInBackground(
    IN PVOID Parameter
    )
/*++

    This routine is the background worker routine for informing the KDC of account
    changes. The KDC is called in the background because it tends to make SAM calls
    on the Same thread upon this notification. Later we may consider notifying all
    third party notification packages in a back ground thread to offset the danger
    that these packages may make other LSA/SAM calls that may call back into the DS.


    Parameters:

        Parameter : Pointer to a PSAMP_NOTIFCATION_INFORMATION structure used to get
                    information regarding the notification.

--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSAMP_DELAYED_NOTIFICATION_INFORMATION NotifyInfo
                        = (PSAMP_DELAYED_NOTIFICATION_INFORMATION)Parameter;

    ASSERT(NULL!=Parameter);

    NtStatus = KdcAccountChangeNotification (
                    &NotifyInfo->DomainSid,
                    NotifyInfo->DeltaType,
                    NotifyInfo->DbObjectType,
                    NotifyInfo->Rid,
                    &NotifyInfo->AccountName,
                    &NotifyInfo->SerialNumber,
                    NULL
                    );

    SampFreeUnicodeString(&NotifyInfo->AccountName);

    MIDL_user_free(Parameter);

    return NtStatus;
}


VOID
SampNotifyReplicatedInChange(
    PSID                       ObjectSid,
    BOOL                       WriteLockHeldByDs,
    SECURITY_DB_DELTA_TYPE     DeltaType,
    SAMP_OBJECT_TYPE           ObjectType,
    PUNICODE_STRING            AccountName,
    ULONG                      AccountControl,
    ULONG                      GroupType,
    ULONG                      CallerType,
    BOOL                       MixedModeChange
    )
/*++

    Routine Description

        This is the Notification Function for SAM, called by the DS when a SAM object is changed

    Parameters:

        ObjectSid      -- Sid of the Object
        WriteLockHeldByDs --
        DeltaType      -- The Type of Change
        SampObjectType -- The Type of Sam Object
        AccountName    -- The Name of the Account
        MixedModeChange -- Indicates that the mixed domain nature of the domain
                           is changing
        CallerType     -- component that initiated the change

    Return Values:

        None -- Void Function
++*/
{
    NTSTATUS    IgnoreStatus = STATUS_SUCCESS;
    PSID        SidToFree = NULL;
    PSID        DomainSid = NULL;
    LARGE_INTEGER NetLogonChangeLogSerialNumber;
    ULONG       Rid=0;
    ULONG       i;
    SECURITY_DB_OBJECT_TYPE DbObjectType = SecurityDbObjectSamDomain;
    BOOLEAN     LockAcquired = FALSE;
    PSAMP_DELAYED_NOTIFICATION_INFORMATION NotifyInfo = NULL;
    SAM_DELTA_DATA DeltaData;
    BOOL        fAudit = FALSE;

    // Valid only in ds mode
    if ( !SampUseDsData ) {
        return;
    }

    //
    // Do not grab the Lock Recursively
    //

    if ((!WriteLockHeldByDs) && (!SampCurrentThreadOwnsLock()))
    {
        SampAcquireSamLockExclusive();
        LockAcquired = TRUE;
    }

    //
    // Initialize the serial number
    //

    NetLogonChangeLogSerialNumber.QuadPart = 0;

    //
    // Split the Sid if the Object Type is an account object Type
    //

    switch(ObjectType)
    {
    case SampDomainObjectType:

        //
        // One of the SAM domain object's has changed. The object SId is the
        // domain Sid
        //
        DbObjectType = SecurityDbObjectSamDomain;
        DomainSid = ObjectSid;
        break;

        //
        // In the following cases the Object Sid is the Account Sid. Split Sid
        // can return the domain Sid, but that will make it allocate memory
        // which can potentially fail the call. Therefore we just ask split Sid
        // to return the Rid and in place reduce the sub authority count on the
        // Sid to get the domain Sid
        //
    case SampUserObjectType:

        DbObjectType = SecurityDbObjectSamUser;
        IgnoreStatus = SampSplitSid(ObjectSid,NULL,&Rid);
        ASSERT(NT_SUCCESS(IgnoreStatus));
        (*RtlSubAuthorityCountSid(ObjectSid))--;
        DomainSid = ObjectSid;
        DeltaData.AccountControl = AccountControl;
        break;

     case SampGroupObjectType:

        DbObjectType = SecurityDbObjectSamGroup;
        IgnoreStatus = SampSplitSid(ObjectSid,NULL,&Rid);
        ASSERT(NT_SUCCESS(IgnoreStatus));
        (*RtlSubAuthorityCountSid(ObjectSid))--;
        DomainSid = ObjectSid;
        break;

     case SampAliasObjectType:

        DbObjectType = SecurityDbObjectSamAlias;
        IgnoreStatus = SampSplitSid(ObjectSid,NULL,&Rid);
        ASSERT(NT_SUCCESS(IgnoreStatus));
        (*RtlSubAuthorityCountSid(ObjectSid))--;
        DomainSid = ObjectSid;
        break;

     default:

        //
        // This should never happen
        //

        ASSERT(FALSE && "Unknown Object Type");
    }



    //
    // Now we need to obtain the correct netlogon change log serial number
    // Loop through the defined domains structure comparing the Domain Sid
    //

    for (i=SampDsGetPrimaryDomainStart();i<SampDefinedDomainsCount;i++)
    {
        //
        // Currently we do not support multiple hosted domains.
        // So O.K to change the mixed state of all domains ( otherwise
        // only that of the builtin and account domain should be invalidated ).
        //

        if (MixedModeChange)
        {
            SampDefinedDomains[i].IsMixedDomain = FALSE;
        }

        if (RtlEqualSid(DomainSid, SampDefinedDomains[i].Sid))
        {

            break;
        }
    }

    //
    // We should always be able to find a match in the defined domains structure
    //

    ASSERT(i<SampDefinedDomainsCount);

    //
    // Audit object change
    //
    // All deletion audits for DS SAM objects are performed via this notify
    // mechanism.
    //
    // Otherwise, only modifications done through LDAP are audited here.
    // All other additions and modifications on SAM objects go though
    // the SAM code base here they can leverage existing audits calls that need
    // to happen in the registry case or have thier own notification
    // call since they need special information.
    // 
    if (  ((CallerType == CALLERTYPE_LDAP) 
       && (SecurityDbChange == DeltaType))
       || ((CallerType != CALLERTYPE_DRA) 
       && (SecurityDbDelete == DeltaType)))
    {
        fAudit = TRUE;
    }

    if ( fAudit  &&
        SampDoAccountAuditing(i))
    {
        switch (ObjectType)
        {
        case SampDomainObjectType:

            if (SecurityDbChange == DeltaType)
            {
                SampAuditDomainChange(i); 
            }

            // Deletion for domain objects is not currently defined.

            break;

        case SampUserObjectType:

            if (SecurityDbChange == DeltaType)
            {
                SampAuditUserChange(i, 
                                    AccountName,
                                    &Rid,
                                    AccountControl
                                    );
            }
            else
            {
                ASSERT(SecurityDbDelete == DeltaType); 
                SampAuditUserDelete(i, 
                                    AccountName,
                                    &Rid,
                                    AccountControl
                                    );

            }
            break;

        case SampGroupObjectType:
        case SampAliasObjectType:

            if (SecurityDbChange == DeltaType)
            {
                SampAuditGroupChange(i,     // DomainIndex
                                     AccountName,
                                     &Rid,
                                     GroupType
                                     );
            }
            else
            {
                ASSERT(SecurityDbDelete == DeltaType); 
                SampAuditGroupDelete(i,     // DomainIndex
                                     AccountName,
                                     &Rid,
                                     GroupType
                                     );

            }
            
            break;

        default:
            //
            // This should never happen
            //

            ASSERT(FALSE && "Unknown Object Type");
        }
    }

    //
    // for non-security enabled group, nothing to notify, they are passed into 
    // this routine for auditing only. 
    // 

    if (((SampGroupObjectType == ObjectType) ||(SampAliasObjectType == ObjectType)) &&
        !(GROUP_TYPE_SECURITY_ENABLED & GroupType))
    {
        goto Cleanup;
    }


    //
    // if the Builtin Domain Alias information is changed, invalidate the
    // Alias Information Cache.
    //

    if (SampAliasObjectType==ObjectType && IsBuiltinDomain(i))
    {
        IgnoreStatus = SampAlInvalidateAliasInformation(i);
    }



    //
    // if the change was to the domain object, invalidate the domain cache
    //

    if (SampDomainObjectType==ObjectType)
    {
         SampInvalidateDomainCache();

         //
         // Register a notification to update the domain cache in the background
         //
         
         LsaIRegisterNotification(
             SampValidateDomainCacheCallback,
                 ( PVOID ) NULL,
                 NOTIFIER_TYPE_IMMEDIATE,
                 0,
                 NOTIFIER_FLAG_ONE_SHOT,
                 0,
                 0
                ); 
    }


    //
    // If We are in mixed mode then tell netlogon to add this change to the
    // change log
    //

    if (SampDefinedDomains[i].IsMixedDomain)
    {

           BOOLEAN NotifyUrgently = FALSE;

           //
           // Set urgent notification for interdomain trust accounts
           // Note account control is a 0 for non user accounts
           //

           if (AccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT)
           {
               NotifyUrgently = TRUE;
           }

           //
           // Issue a New Serial Number
           //

            SampDefinedDomains[i].NetLogonChangeLogSerialNumber.QuadPart+=1;
            NetLogonChangeLogSerialNumber = SampDefinedDomains[i].NetLogonChangeLogSerialNumber;


            //
            // Notify Netlogon of the Change
            //

            I_NetNotifyDelta(
                            SecurityDbSam,
                            NetLogonChangeLogSerialNumber,
                            DeltaType,
                            DbObjectType,
                            Rid,
                            DomainSid,
                            AccountName,
                            NotifyUrgently,
                            NULL
                            );
    }


    //
    // if a machine account or a trust account has changed
    // then tell netlogon about the change
    //

    if (AccountControl & USER_MACHINE_ACCOUNT_MASK )
    {
            I_NetNotifyMachineAccount(
                    Rid,
                    SampDefinedDomains[i].Sid,
                    (SecurityDbDelete==DeltaType)?AccountControl:0,
                    (SecurityDbDelete==DeltaType)?0:AccountControl,
                    AccountName
                    );
    }


    //
    // Notify the KDC about the delta
    //

    NotifyInfo = MIDL_user_allocate(sizeof(SAMP_NOTIFICATION_INFORMATION));

    if (NULL!=NotifyInfo)
    {
        NTSTATUS    Status = STATUS_SUCCESS;

        //
        // If the memory alloc failed, then drop the notification information
        // on the floor. The commit has taken place anyway and there is not much
        // that we can do.
        //

        RtlZeroMemory(NotifyInfo,sizeof(SAMP_NOTIFICATION_INFORMATION));
        RtlCopyMemory(&NotifyInfo->DomainSid,DomainSid, RtlLengthSid(DomainSid));
        NotifyInfo->DeltaType = DeltaType;
        NotifyInfo->DbObjectType = DbObjectType;
        NotifyInfo->Rid = Rid;
        NotifyInfo->SerialNumber = NetLogonChangeLogSerialNumber;

        if (NULL!=AccountName)
        {
            Status = SampDuplicateUnicodeString(
                            &NotifyInfo->AccountName,
                            AccountName
                            );
        }

        if (NT_SUCCESS(Status))
        {
            //
            // Register an LSA notification call back with the LSA
            // thread pool.
            //

            LsaIRegisterNotification(
                  SampNotifyKdcInBackground,
                  ( PVOID ) NotifyInfo,
                  NOTIFIER_TYPE_IMMEDIATE,
                  0,
                  NOTIFIER_FLAG_ONE_SHOT,
                  0,
                  0
                  );
        }
        else
        {
            //
            // Since we are not giving the notification, free the
            // notifyinfo structure
            //

            MIDL_user_free(NotifyInfo);
        }
    }

    //
    // Invalidate the ACL conversion cache
    //

    if ((SampGroupObjectType==ObjectType)||(SampAliasObjectType==ObjectType))
    {
        SampInvalidateAclConversionCache();
    }

    //
    // Let any Third Party Notification packages know about the delta.
    //

    SampDeltaChangeNotify(
        DomainSid,
        DeltaType,
        DbObjectType,
        Rid,
        AccountName,
        &NetLogonChangeLogSerialNumber,
        (DbObjectType==SecurityDbObjectSamUser)?&DeltaData:NULL
        );


Cleanup:


    if (LockAcquired)
    {
        SampReleaseSamLockExclusive();
    }
}

#define  MAX_NT5_NAME_LENGTH  64
#define  MAX_NT4_GROUP_NAME_LENGTH GNLEN        // NT4 time, max group name is 256

NTSTATUS
SampEnforceDownlevelNameRestrictions(
    PUNICODE_STRING NewAccountName,
    SAMP_OBJECT_TYPE ObjectType
    )
/*++

    This routine enforces the same name restrictions as the NT4 user interface
    did. The reason for this is backward compatibility with NT4 systems.

    Right now, for groups, it also enforces the NT5 schema limit on
    SamAccountName of 64 characters

   Parameters:

        NewAccountName -- The New Account Name that needs to be checked

        ObjectType -- Tell us the Object Type, such that we can enforce different restrictions
                      for different object.


   Return Values

        STATUS_SUCCESS -- If the name is O.K
        STATUS_INVALID_PARAMETER if the Name does not pass the test

--*/
{
    ULONG i,j;

    //
    // Check the Length
    // Do not apply Length restriction for Groups
    //

    if ((NewAccountName->Length > MAX_DOWN_LEVEL_NAME_LENGTH * sizeof (WCHAR)) &&
        (SampAliasObjectType != ObjectType) && (SampGroupObjectType != ObjectType)
       )
    {
        return STATUS_INVALID_ACCOUNT_NAME;
    }

    // For local and global groups, impose the NT4 Max Group Name Length - 256

    if ((NewAccountName->Length > MAX_NT4_GROUP_NAME_LENGTH * sizeof (WCHAR)) &&
        ((SampAliasObjectType == ObjectType) || (SampGroupObjectType == ObjectType))
       )
    {
        return STATUS_INVALID_ACCOUNT_NAME;
    }


    //
    // Check for invalid characters
    //

    for (i=0;i<(NewAccountName->Length)/sizeof(WCHAR);i++)
    {
        for (j=0;j< ARRAY_COUNT(InvalidDownLevelChars);j++)
        {
            if (InvalidDownLevelChars[j]==((WCHAR *) NewAccountName->Buffer)[i])
            {
                return STATUS_INVALID_ACCOUNT_NAME;
            }
        }
    }

    return STATUS_SUCCESS;
}


VOID
SampFlushNetlogonChangeNumbers()
/*++

    This routine flushes the latest Netlogon serial numbers to disk. This is typically
    called at shutdown time.

    Parameters

        None

    Return Values

        None

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       i;

    SAMTRACE("SampFlushNetlogonChangeNumbers");

    SampDiagPrint(INFORM,("Flushing Netlogon Serial Numbers to Disk\n"));

    for (i=SampDsGetPrimaryDomainStart();i<SampDefinedDomainsCount;i++)
    {
        LARGE_INTEGER   DomainModifiedCount;
        ATTRVAL         DomainModifiedCountVal[] = {sizeof(LARGE_INTEGER),(UCHAR *) &DomainModifiedCount};
        ATTRTYP         DomainModifiedCountTyp[] = {SAMP_FIXED_DOMAIN_MODIFIED_COUNT};
        DEFINE_ATTRBLOCK1(DomainModifiedCountAttr,DomainModifiedCountTyp,DomainModifiedCountVal);

        //
        // Domain must be DS domain.
        //

        ASSERT(IsDsObject(SampDefinedDomains[i].Context));

        DomainModifiedCount.QuadPart = SampDefinedDomains[i].NetLogonChangeLogSerialNumber.QuadPart;
        NtStatus = SampDsSetAttributes(
                        SampDefinedDomains[i].Context->ObjectNameInDs,
                        0,
                        REPLACE_ATT,
                        SampDomainObjectType,
                        &DomainModifiedCountAttr
                        );

        //
        // Not much we can do if we fail
        //

    }

    //
    // Commit the Changes. Not much can be done on failure
    //

    SampMaybeEndDsTransaction(TransactionCommit);

}


//
// The Following Functions implement a logic that ensures that
// all SAM threads accessing the Database wihout the SAM lock held
// are finished with their respective activities before the Database
// is shut down. The Way this works is as follws
//
//      1. Threads accessing the database without the SAM lock held
//         increment the active thread count while entering the Database
//         section and decrement it while leaving the database section
//
//      2. Shutdown notification code sets SampServiceState to not running
//         and waits till the active thread count is 0. This wait times out
//         after some time, so that stuck or dead locked callers are ignored
//         and a clean shut down is performed.
//


ULONG SampActiveThreadCount=0;
CRITICAL_SECTION SampActiveThreadsLock;
HANDLE SampShutdownEventHandle=INVALID_HANDLE_VALUE;
HANDLE SampAboutToShutdownEventHandle=INVALID_HANDLE_VALUE;

NTSTATUS
SampInitializeShutdownEvent()
{
    NTSTATUS NtStatus;

    //
    // Initialize the critical section for shutdown event
    // Set a spin count of 100, we expect contention to be minimal
    //

    NtStatus = RtlInitializeCriticalSectionAndSpinCount(&SampActiveThreadsLock,100);
    if (!NT_SUCCESS(NtStatus))
        return (NtStatus);

    //
    // Create the Shut down Event
    //

    NtStatus = NtCreateEvent(
                  &SampAboutToShutdownEventHandle,
                  EVENT_ALL_ACCESS,
                  NULL,
                  NotificationEvent,
                  FALSE
                  );

    if (!NT_SUCCESS(NtStatus))
       return (NtStatus);

    return(NtCreateEvent(
                &SampShutdownEventHandle,
                EVENT_ALL_ACCESS,
                NULL,
                NotificationEvent,
                FALSE));
}

NTSTATUS
SampIncrementActiveThreads()
/*++
    Routine Description

        This Routine Increments the Active Thread Count counter in an
        atomic fashion.

--*/
{
    NTSTATUS IgnoreStatus;

    IgnoreStatus = RtlEnterCriticalSection(&SampActiveThreadsLock);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    //
    // Check our Running State
    //

    if ( SampServiceState == SampServiceTerminating ) {
        IgnoreStatus = RtlLeaveCriticalSection(&SampActiveThreadsLock);
        ASSERT(NT_SUCCESS(IgnoreStatus));
        return(STATUS_INVALID_SERVER_STATE);
    }

    //
    // Increment Active Thread Count
    //

    SampActiveThreadCount++;

    IgnoreStatus = RtlLeaveCriticalSection(&SampActiveThreadsLock);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    return STATUS_SUCCESS;
}

VOID
SampDecrementActiveThreads()
/*++

    This Routine Decrements the Active Thread Count counter in an atomin
    fashion

--*/
{
    ULONG NewThreadCount;
    NTSTATUS IgnoreStatus;

    IgnoreStatus = RtlEnterCriticalSection(&SampActiveThreadsLock);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    NewThreadCount = --SampActiveThreadCount;
    if ((0==NewThreadCount) && (SampServiceState==SampServiceTerminating))
    {
        if (INVALID_HANDLE_VALUE!=SampShutdownEventHandle)
            NtSetEvent(SampShutdownEventHandle,NULL);
    }

    IgnoreStatus = RtlLeaveCriticalSection(&SampActiveThreadsLock);
    ASSERT(NT_SUCCESS(IgnoreStatus));
}

VOID
SampWaitForAllActiveThreads(
    IN PSAMP_SERVICE_STATE PreviousServiceState OPTIONAL
    )
/*++

    This Routine Waits for all threads not holding SAM lock but
    actively using the Database to finish their Work

--*/
{
    ULONG ThreadCount;
    NTSTATUS IgnoreStatus;

    IgnoreStatus = RtlEnterCriticalSection(&SampActiveThreadsLock);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    if ( PreviousServiceState )
    {
        *PreviousServiceState = SampServiceState;
    }
    SampServiceState = SampServiceTerminating;
    ThreadCount = SampActiveThreadCount;

    if (INVALID_HANDLE_VALUE!=SampAboutToShutdownEventHandle)
        NtSetEvent(SampAboutToShutdownEventHandle,NULL);

    IgnoreStatus = RtlLeaveCriticalSection(&SampActiveThreadsLock);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    if (0!=ThreadCount)
    {
        //
        // If There is at least one caller actively using the DS and
        // and not holding the SAM lock
        //

        // Wait for at most 2 seconds for such callers

        DWORD TimeToWait = 2000;


        if (INVALID_HANDLE_VALUE!=SampShutdownEventHandle)
            WaitForSingleObject(SampShutdownEventHandle,TimeToWait);
    }

    if (INVALID_HANDLE_VALUE!=SampShutdownEventHandle)
        NtClose(SampShutdownEventHandle);

    SampShutdownEventHandle = INVALID_HANDLE_VALUE;

}

BOOLEAN
SampIsSetupInProgress(
    OUT BOOLEAN *Upgrade OPTIONAL
    )
/*++

Routine Description:

    This routine makes registry calls to determine if we are running
    during gui mode setup or not.  If an unexpected error is returned
    from a system service, then we are assume we are not running during
    gui mode setup.

Arguments:

    Upgrade:  set to true if this is an upgrade

Return Value:

    TRUE we are running during gui mode setup; FALSE otherwise

--*/
{
    NTSTATUS          NtStatus;

    OBJECT_ATTRIBUTES SetupKeyObject;
    HANDLE            SetupKeyHandle;
    UNICODE_STRING    SetupKeyName;

    UNICODE_STRING    ValueName;
    DWORD             Value;

    BYTE                             Buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(DWORD)];
    PKEY_VALUE_PARTIAL_INFORMATION   KeyPartialInfo;
    ULONG                            KeyPartialInfoSize;

    BOOLEAN           SetupInProgress = FALSE;
    BOOLEAN           UpgradeInProgress = FALSE;

    RtlInitUnicodeString(&SetupKeyName, L"\\Registry\\Machine\\System\\Setup");

    RtlZeroMemory(&SetupKeyObject, sizeof(SetupKeyObject));
    InitializeObjectAttributes(&SetupKeyObject,
                               &SetupKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&SetupKeyHandle,
                         KEY_READ,
                         &SetupKeyObject);

    if (NT_SUCCESS(NtStatus)) {

        //
        // Read the value for setup
        //
        RtlInitUnicodeString(&ValueName, L"SystemSetupInProgress");

        RtlZeroMemory(Buffer, sizeof(Buffer));
        KeyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
        KeyPartialInfoSize = sizeof(Buffer);
        NtStatus = NtQueryValueKey(SetupKeyHandle,
                                   &ValueName,
                                   KeyValuePartialInformation,
                                   KeyPartialInfo,
                                   KeyPartialInfoSize,
                                   &KeyPartialInfoSize);

        if (STATUS_BUFFER_TOO_SMALL == NtStatus) {

            KeyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
                             RtlAllocateHeap(RtlProcessHeap(), 0, KeyPartialInfoSize);

            if (KeyPartialInfo) {

                NtStatus = NtQueryValueKey(SetupKeyHandle,
                                           &ValueName,
                                           KeyValuePartialInformation,
                                           KeyPartialInfo,
                                           KeyPartialInfoSize,
                                           &KeyPartialInfoSize);
            } else {
                NtStatus = STATUS_NO_MEMORY;
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            if (KeyPartialInfo->DataLength == sizeof(DWORD)) {

                Value = *(DWORD*)(KeyPartialInfo->Data);

                if (Value) {
                    SetupInProgress = TRUE;
                }
            }
        }

        if (KeyPartialInfo != (PKEY_VALUE_PARTIAL_INFORMATION)Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, KeyPartialInfo);
        }


        //
        // Now read the value for upgrade
        //
        RtlInitUnicodeString(&ValueName, L"UpgradeInProgress");

        RtlZeroMemory(Buffer, sizeof(Buffer));
        KeyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
        KeyPartialInfoSize = sizeof(Buffer);
        NtStatus = NtQueryValueKey(SetupKeyHandle,
                                   &ValueName,
                                   KeyValuePartialInformation,
                                   KeyPartialInfo,
                                   KeyPartialInfoSize,
                                   &KeyPartialInfoSize);

        if (STATUS_BUFFER_TOO_SMALL == NtStatus) {

            KeyPartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
                             RtlAllocateHeap(RtlProcessHeap(), 0, KeyPartialInfoSize);

            if (KeyPartialInfo) {

                NtStatus = NtQueryValueKey(SetupKeyHandle,
                                           &ValueName,
                                           KeyValuePartialInformation,
                                           KeyPartialInfo,
                                           KeyPartialInfoSize,
                                           &KeyPartialInfoSize);
            } else {
                NtStatus = STATUS_NO_MEMORY;
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            if (KeyPartialInfo->DataLength == sizeof(DWORD)) {

                Value = *(DWORD*)(KeyPartialInfo->Data);

                if (Value) {
                    UpgradeInProgress = TRUE;
                }
            }
        }

        if (KeyPartialInfo != (PKEY_VALUE_PARTIAL_INFORMATION)Buffer) {
            RtlFreeHeap(RtlProcessHeap(), 0, KeyPartialInfo);
        }

        NtClose(SetupKeyHandle);

    } else {

        //
        // If this key does not exist, then we certainly are not
        // running in gui mode setup.
        //
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Open of \\Registry\\Machine\\System\\Setup failed with 0x%x\n",
                   NtStatus));

    }

    if (Upgrade) {
        *Upgrade = UpgradeInProgress;
    }

    return SetupInProgress;
}

VOID
SampWriteToSetupLog(
    IN     USHORT      EventType,
    IN     USHORT      EventCategory   OPTIONAL,
    IN     ULONG       EventID,
    IN     PSID        UserSid         OPTIONAL,
    IN     USHORT      NumStrings,
    IN     ULONG       DataSize,
    IN     PUNICODE_STRING *Strings    OPTIONAL,
    IN     PVOID       Data            OPTIONAL
    )

/*++

Routine Description:

    This routine queries the resource table in samsrv.dll to get the string
    for the event id parameter and outputs it to the setup log.

Parameters:

    Same as SampWriteEventLog

Return Values:

   None

--*/
{
    HMODULE ResourceDll;
    WCHAR   *OutputString=NULL;
    PWCHAR  *InsertArray=NULL;
    ULONG   Length, Size;
    BOOL    Status;
    ULONG   i;

    SAMP_ALLOCA(InsertArray,(NumStrings+1)*sizeof(PWCHAR));
    if (NULL==InsertArray)
    {
        //
        // memory alloc failure; do not log
        //

        return;
    }

    for(i=0;i<NumStrings;i++)
    {
        InsertArray[i]=Strings[i]->Buffer;
    }
    InsertArray[NumStrings]=NULL;

    ResourceDll = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );

    if (ResourceDll) {

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        ResourceDll,
                                        EventID,
                                        0,       // Use caller's language
                                        (LPWSTR)&OutputString,
                                        0,       // routine should allocate
                                        (va_list*) (InsertArray)
                                        );
        if (OutputString) {
            // Messages from a message file have a cr and lf appended
            // to the end
            OutputString[Length-2] = L'\0';
            Length -= 2;

            if (SetupOpenLog(FALSE)) { // don't erase

                // for now everything is LogSevWarning
                Status = SetupLogError(OutputString, LogSevWarning);
                ASSERT(Status);
                SetupCloseLog();
            }
            LocalFree(OutputString);
        }

        Status = FreeLibrary(ResourceDll);
        ASSERT(Status);

    }


    return;

}

VOID
SampUpdatePerformanceCounters(
    IN DWORD                dwStat,
    IN DWORD                dwOperation,
    IN DWORD                dwChange
    )
/*++

Routine Description:

    For Server case, updates DS performance counters.
    For Workstation case, its a NOP

Arguments:

    dwStat - DSSTAT_* Statistic to update
    dwOperation - COUNTER_INCREMENT or COUNTER_SET
    dwChange - Value to set if dwOperation == COUNTER_SET

Return Value:

    None

--*/
{
    if ( SampUseDsData )
    {
        UpdateDSPerfStats( dwStat, dwOperation, dwChange );
    }
}


VOID
SamIIncrementPerformanceCounter(
    IN SAM_PERF_COUNTER_TYPE CounterType
)
/*++

    Routine Description

        This routine updates performance counters in the DS performance
        shared memory block.

    Parameters

        CounterType - Indicates what counter to increment.

    Return Values

        STATUS_SUCCESS
        Other Error Codes

--*/                 
{
    if (SampUseDsData &&
        (SampServiceState == SampServiceEnabled))
    {
        switch(CounterType)
        {
        case MsvLogonCounter:
             SampUpdatePerformanceCounters(DSSTAT_MSVLOGONS,FLAG_COUNTER_INCREMENT,0);

             break;

        case KerbServerContextCounter:
             SampUpdatePerformanceCounters(DSSTAT_KERBEROSLOGONS,FLAG_COUNTER_INCREMENT,0);
             break;

        case KdcAsReqCounter:
             SampUpdatePerformanceCounters(DSSTAT_ASREQUESTS,FLAG_COUNTER_INCREMENT,0);
             break;

        case KdcTgsReqCounter:
             SampUpdatePerformanceCounters(DSSTAT_TGSREQUESTS,FLAG_COUNTER_INCREMENT,0);
             break;
        }
    }
}


NTSTATUS
SampCommitBufferedWrites(
    IN SAMPR_HANDLE SamHandle
    )
/*++

    Routine Description

      Routine for loopback callers to flush buffered writes in the Sam context
      to Disk. Buffered writes is currently used only by loopback

    Parameters

        SamHandle -- Handle to SAM

    Return Values

        STATUS_SUCCESS
        Other Error Codes

--*/
{
   PSAMP_OBJECT Context = (PSAMP_OBJECT)SamHandle;
   NTSTATUS     NtStatus = STATUS_SUCCESS;
   NTSTATUS     IgnoreStatus = STATUS_SUCCESS;


   //
   // Increment the active thread count, so we will consider this
   // thread at shutdown time
   // 
   NtStatus = SampIncrementActiveThreads();
   if (!NT_SUCCESS(NtStatus))
   {
       return( NtStatus );
   }


   ASSERT(Context->LoopbackClient);

   //
   // Reference the Context
   //

   SampReferenceContext(Context);


   //
   // Flush any buffered Membership Operations to DS. only apply for Group and Alias Object.
   //
   switch (Context->ObjectType) {

   case SampGroupObjectType:

       if (Context->TypeBody.Group.CachedMembershipOperationsListLength)
       {
           NtStatus = SampDsFlushCachedMembershipOperationsList(Context);
       }

       break;

   case SampAliasObjectType:

       if (Context->TypeBody.Alias.CachedMembershipOperationsListLength)
       {
           NtStatus = SampDsFlushCachedMembershipOperationsList(Context);
       }

       break;

   default:

       ;
   }

   //
   // if something goes wrong, then we just quit
   //
   if (!NT_SUCCESS(NtStatus))
   {
       SampDeReferenceContext(Context, FALSE);
       ASSERT(NT_SUCCESS(IgnoreStatus));

   }
   else
   {

       //
       // Turn of Buffered Writes and force a flush
       //

       Context->BufferWrites = FALSE;

       //
       // Dereference context. Commit Changes
       //

       NtStatus = SampDeReferenceContext(Context,TRUE);

   }


   //
   // Let shutdown handling logic know that we are done
   // 

   SampDecrementActiveThreads();


   return(NtStatus);

}


ULONG
SampPositionOfHighestBit(
    ULONG Flag
    )
//
// Returns the position of the highest bit in Flag
// ranges from 32 - 0; 0 is returned if no bit is set.
//
{
    ULONG Index, Position;

    for (Index = 0x80000000, Position = 32;
            Index != 0;
                Index >>= 1, Position--)

        if ( Flag & Index )

            return Position;


    return 0;
}

NTSTATUS
SampSetAccountDomainPolicy(
    IN PUNICODE_STRING AccountDomainName,
    IN PSID            AccountDomainSid
    )
/*++

Routine Description

    This routine sets the account domain information in the LSA

Parameters

    AccountDomainName : the "external" name of the domain

    AccountDomainSid : the sid of the domain

Return Values

    STATUS_SUCCESS
    status from the LSA

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    LSAPR_HANDLE PolicyHandle = 0;
    POLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo;


    // Parameter check
    ASSERT( AccountDomainName );
    ASSERT( AccountDomainSid );

    NtStatus = LsaIOpenPolicyTrusted( &PolicyHandle );

    if ( NT_SUCCESS( NtStatus ) )
    {
        RtlZeroMemory( &AccountDomainInfo, sizeof(AccountDomainInfo) );
        AccountDomainInfo.DomainName = *AccountDomainName;
        AccountDomainInfo.DomainSid = AccountDomainSid;

        NtStatus = LsarSetInformationPolicy( PolicyHandle,
                                             PolicyAccountDomainInformation,
                                             (LSAPR_POLICY_INFORMATION*) &AccountDomainInfo );

    }


    if ( PolicyHandle )
    {
        LsarClose( &PolicyHandle );
    }

    return NtStatus;

}


VOID
SampMapNtStatusToClientRevision(
   IN ULONG ClientRevision,
   IN OUT NTSTATUS *pNtStatus
   )
/*++

    Routine Description

       This routine takes the NtStatus passed in converts it to the NTSTATUS
       code that is most appropriate for the client revision indicated.

    Parameters:

       ClientRevision -- The revision of the client
       NtStatus       -- The NtStatus to be mapped is passed in and at the
                         end of the function, the mapped NtStatus is passed out

    Return Values

       None
--*/
{
    NTSTATUS    DownLevelNtStatus = *pNtStatus;

    //
    // for DownLevel client, map the new NtStatus code to the one they can understand
    //

    if (ClientRevision < SAM_CLIENT_NT5)
    {
        switch (*pNtStatus) {

        //
        // These new status codes are all for group membership operations.
        //

        case STATUS_DS_INVALID_GROUP_TYPE:
            DownLevelNtStatus = STATUS_INVALID_PARAMETER;
            break;

        case STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN:
        case STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN:
        case STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER:
        case STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER:
        case STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER:
        case STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER:
        case STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER:
            DownLevelNtStatus = STATUS_INVALID_MEMBER;
            break;

        case STATUS_DS_HAVE_PRIMARY_MEMBERS:
            DownLevelNtStatus = STATUS_MEMBER_IN_GROUP;
            break;

        case STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED:
            DownLevelNtStatus = STATUS_QUOTA_EXCEEDED;
            break;

        default:
            ;
            break;
        }

        *pNtStatus = DownLevelNtStatus;
    }
}



NTSTATUS
SamISameSite(
   OUT BOOLEAN * result
   )
/*++

Routine Description:

    This routine retrieves the Domain Object's fSMORoleOwner attribute, which
    is the PDC's DSNAME, then get the current DC's NTDS setting object.

    Bying comparing the current DC's ntds setting with fSMORoleOwner value,
    we can tell whether this DC is in the same site with PDC or not.

Parameters:

    result -- pointer to boolean. indication PDC and the current DS are in the
              same site or not.

              TRUE - same site,   FALSE - different site.

Return Value:

    STATUS_SUCCESS -- everything goes well,

    NtStatus

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus = STATUS_SUCCESS;
    DWORD    Length = 0;
    DSNAME   *PDCObject = NULL;
    DSNAME   *PDCObjectTrimmed = NULL;
    DSNAME   *LocalDsaObject = NULL;
    DSNAME   *LocalDsaObjectTrimmed = NULL;
    DSNAME   *DomainObject = NULL;
    READARG  ReadArg;
    READRES  *ReadResult = NULL;
    ENTINFSEL EntInfSel;
    COMMARG  *CommArg = NULL;
    ATTR     AttrToRead;
    ULONG    DirError;


    SAMTRACE("SamISameSite");


    //
    // Get the Domain Object's DSNAME
    //
    NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                    &Length,
                                    DomainObject
                                    );

    if ( STATUS_BUFFER_TOO_SMALL == NtStatus )
    {
        SAMP_ALLOCA(DomainObject,Length);
        if (NULL!=DomainObject)
        {

            NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                            &Length,
                                            DomainObject
                                            );
        }
        else 
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    //
    // Get the NTDS setting object's DSNAME
    //
    Length = 0;
    NtStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                    &Length,
                                    LocalDsaObject
                                    );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        SAMP_ALLOCA(LocalDsaObject,Length);
        if (NULL!=LocalDsaObject)
        {

            NtStatus = GetConfigurationName(DSCONFIGNAME_DSA,
                                            &Length,
                                            LocalDsaObject
                                            );
        }
        else
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    //
    // Create/Begin DS Transaction
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    //
    // Prepare arguments to call DirRead,
    // read fSMORoleOwner attribute of Domain object
    //
    memset(&ReadArg, 0, sizeof(READARG));
    memset(&EntInfSel, 0, sizeof(ENTINFSEL));

    AttrToRead.attrTyp = ATT_FSMO_ROLE_OWNER;
    AttrToRead.AttrVal.valCount = 0;
    AttrToRead.AttrVal.pAVal = NULL;

    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInfSel.AttrTypBlock.attrCount = 1;
    EntInfSel.AttrTypBlock.pAttr = &AttrToRead;

    ReadArg.pObject = DomainObject;
    ReadArg.pSel = &EntInfSel;
    CommArg = &(ReadArg.CommArg);
    BuildStdCommArg(CommArg);

    DirError = DirRead(&ReadArg, &ReadResult);

    if (NULL == ReadResult)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(DirError, &ReadResult->CommRes);
    }

    SampClearErrors();

    //
    // Extract the value of fSMORoleOwner if succeed
    //
    if (NT_SUCCESS(NtStatus))
    {
        ASSERT(NULL != ReadResult);
        ASSERT(1 == ReadResult->entry.AttrBlock.attrCount);
        ASSERT(ATT_FSMO_ROLE_OWNER == ReadResult->entry.AttrBlock.pAttr[0].attrTyp);
        ASSERT(1 == ReadResult->entry.AttrBlock.pAttr[0].AttrVal.valCount);

        PDCObject = (PDSNAME) ReadResult->entry.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal;

        SAMP_ALLOCA(PDCObjectTrimmed,PDCObject->structLen);
        if (NULL==PDCObjectTrimmed)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        SAMP_ALLOCA(LocalDsaObjectTrimmed,LocalDsaObject->structLen);
        if (NULL==LocalDsaObjectTrimmed)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        if (TrimDSNameBy( PDCObject, 3, PDCObjectTrimmed) ||
            TrimDSNameBy( LocalDsaObject, 3, LocalDsaObjectTrimmed)
            )
        {
            //
            // Trim DSNAME error
            //
            NtStatus = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }

        if (NameMatched(PDCObjectTrimmed, LocalDsaObjectTrimmed))
        {
            //
            // match ==> same site
            //
            *result = TRUE;
        }
        else
        {
            //
            // not match
            //
            *result = FALSE;
        }
    }

Cleanup:

    IgnoreStatus = SampMaybeEndDsTransaction( NT_SUCCESS(NtStatus) ?
                                              TransactionCommit :
                                              TransactionAbort );

    return NtStatus;

}


BOOLEAN
SamINT4UpgradeInProgress(
    VOID
    )
/*++

Routine Description:

    RAS User Parameters Convert routine needs to know whether this machine is
    promoted from NT4 PDC or from Windows 2000 Server.

    Global variable SampNT4UpgradeInProgress is set in SamIPromote(), thus we
    can tell RAS where we are

Parameters:

    None.

Return Values:

    TRUE -- machine is promoted from NT4 PDC
    FALSE -- machine is promoted from Windows 2000 Server

--*/
{
    return (SampNT4UpgradeInProgress);
}


BOOLEAN
SampIsMemberOfBuiltinDomain(
    IN PSID Sid
    )
/*++

Routine Description:

    This routine determines if a sid is a part of the built in domain.

Parameters:

    Sid -- a valid, non null sid.

Return Values:

    TRUE if the sid is part of the builtin domain; FALSE otherwise

--*/
{
    UCHAR SubAuthorityCount;
    BOOLEAN fResult = FALSE;

    SubAuthorityCount = *RtlSubAuthorityCountSid(Sid);

    if ( SubAuthorityCount > 0 ) {

        *RtlSubAuthorityCountSid(Sid) = SubAuthorityCount-1;

        fResult = RtlEqualSid( Sid, SampBuiltinDomainSid );

        *RtlSubAuthorityCountSid(Sid) = SubAuthorityCount;
    }

    return fResult;

}


NTSTATUS
SamIGetDefaultAdministratorName(
    OUT LPWSTR Name,             OPTIONAL
    IN OUT ULONG  *NameLength
    )
/*++

Routine Description:

    This routine extracts the localized default name of the administrator's
    account.  Note: this is not necessary the current name of the admin (
    the account could have been renamed).

Parameters:

    Name -- buffer to be filled in

    NameLength -- length in characters of the buffer

Return Values:

    STATUS_SUCCESS if the name was found;
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    HMODULE AccountNameResource;
    LPWSTR AdminName = NULL;

    ASSERT( NameLength );
    if ( (*NameLength) > 0 ) {
        ASSERT( Name );
    }

    //
    // Get the localized Admin name
    //
    AccountNameResource = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );
    if ( AccountNameResource ) {

        FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                       FORMAT_MESSAGE_ALLOCATE_BUFFER,
                       AccountNameResource,
                       SAMP_USER_NAME_ADMIN,
                       0, // use the caller's language
                       (LPWSTR) &AdminName,
                       0,
                       NULL );

        FreeLibrary(  AccountNameResource );
    }

    if ( AdminName ) {

        ULONG Length = wcslen(AdminName) + 1;

        // remove the cr and lf characters
        ASSERT( Length > 2 );
        Length -= 2;

        if ( *NameLength >= Length ) {

            wcsncpy( Name, AdminName, (Length-1) );

            Name[Length-1] = L'\0';

        } else {

            Status = STATUS_BUFFER_TOO_SMALL;

        }
        *NameLength = Length;

        LocalFree( AdminName );

    } else {

        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;

}



NTSTATUS
SampConvertUiListToApiList(
    IN  PUNICODE_STRING UiList OPTIONAL,
    OUT PUNICODE_STRING ApiList,
    IN BOOLEAN BlankIsDelimiter
    )

/*++

Routine Description:

    Converts a list of workstation names in UI/Service format into a list of
    canonicalized names in API list format. UI/Service list format allows
    multiple delimiters, leading and trailing delimiters. Delimiters are the
    set "\t,;". API list format has no leading or trailing delimiters and
    elements are delimited by a single comma character.

    For each name parsed from UiList, the name is canonicalized (which checks
    the character set and name length) as a workstation name. If this fails,
    an error is returned. No information is returned as to which element
    failed canonicalization: the list should be discarded and a new one re-input

Arguments:

    UiList  - The list to canonicalize in UI/Service list format
    ApiList - The place to store the canonicalized version of the list in
              API list format.  The list will have a trailing zero character.
    BlankIsDelimiter - TRUE indicates blank should be considered a delimiter
              character.

Return Value:

    NTSTATUS
        Success = STATUS_SUCCESS
                    List converted ok

        Failure = STATUS_INVALID_PARAMETER
                    UiList parameter is in error

                  STATUS_INVALID_COMPUTER_NAME
                    A name parsed from UiList has an incorrect format for a
                    computer (aka workstation) name
--*/

{
    NTSTATUS status = STATUS_SUCCESS;
    ULONG inLen=0;
    PWSTR input;
    PWSTR buffer;
    PWSTR output;
    ULONG cLen;
    ULONG len;
    ULONG outLen = 0;
    WCHAR element[DNS_MAX_NAME_BUFFER_LENGTH+1];
    BOOLEAN firstElement = TRUE;
    BOOLEAN ok;

    try {
        if (ARGUMENT_PRESENT(UiList)) {
            inLen = UiList->MaximumLength;  // read memory test
            inLen = UiList->Length;
            input = UiList->Buffer;
            if (inLen & sizeof(WCHAR)-1) {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        RtlInitUnicodeString(ApiList, NULL);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        status = STATUS_ACCESS_VIOLATION;
    }
    if (NT_SUCCESS(status) && ARGUMENT_PRESENT(UiList) && inLen) {
        buffer = RtlAllocateHeap(RtlProcessHeap(), 0, inLen + sizeof(WCHAR));
        if (buffer == NULL) {
            status = STATUS_NO_MEMORY;
        } else {
            ApiList->Buffer = buffer;
            ApiList->MaximumLength = (USHORT)inLen + sizeof(WCHAR);
            output = buffer;
            ok = TRUE;
            while (len = SampNextElementInUIList(&input,
                                     &inLen,
                                     element,
                                     sizeof(element) - sizeof(element[0]),
                                     BlankIsDelimiter )) {
                if (len == (ULONG)-1L) {
                    ok = FALSE;
                } else {
                    cLen = len/sizeof(WCHAR);
                    element[cLen] = 0;
                    ok = SampValidateComputerName(element, cLen);
                }
                if (ok) {
                    if (!firstElement) {
                        *output++ = L',';

                        //
                        // sizeof(L',') returns 4, not 2!! because
                        // it also includes space for the NULL terminator
                        // in the end
                        //

                        outLen += sizeof(WCHAR);
                    } else {
                        firstElement = FALSE;
                    }
                    wcscpy(output, element);
                    outLen += len;
                    output += cLen;
                } else {
                    RtlFreeHeap(RtlProcessHeap(), 0, buffer);
                    ApiList->Buffer = NULL;
                    status = STATUS_INVALID_COMPUTER_NAME;
                    break;
                }
            }
        }
        if (NT_SUCCESS(status)) {
            ApiList->Length = (USHORT)outLen;
            if (!outLen) {
                ApiList->MaximumLength = 0;
                ApiList->Buffer = NULL;
                RtlFreeHeap(RtlProcessHeap(), 0, buffer);
            }
        }
    }
    return status;
}


ULONG
SampNextElementInUIList(
    IN OUT PWSTR* InputBuffer,
    IN OUT PULONG InputBufferLength,
    OUT PWSTR OutputBuffer,
    IN ULONG OutputBufferLength,
    IN BOOLEAN BlankIsDelimiter
    )

/*++

Routine Description:

    Locates the next (non-delimter) element in a string and extracts it to a
    buffer. Delimiters are the set [\t,;]

Arguments:

    InputBuffer         - pointer to pointer to input buffer including delimiters
                          Updated on successful return
    InputBufferLength   - pointer to length of characters in InputBuffer.
                          Updated on successful return
    OutputBuffer        - pointer to buffer where next element is copied
    OutputBufferLength  - size of OutputBuffer (in bytes)
    BlankIsDelimiter    - TRUE indicates blank should be considered a delimiter
              character.

Return Value:

    ULONG
                           -1 = error - extracted element breaks OutputBuffer
                            0 = no element extracted (buffer is empty or all
                                delimiters)
        1..OutputBufferLength = OutputBuffer contains extracted element

--*/

{
    ULONG elementLength = 0;
    ULONG inputLength = *InputBufferLength;
    PWSTR input = *InputBuffer;

    while (IS_DELIMITER(*input, BlankIsDelimiter) && inputLength) {
        ++input;
        inputLength -= sizeof(*input);
    }
    while (!IS_DELIMITER(*input, BlankIsDelimiter) && inputLength) {
        if (!OutputBufferLength) {
            return (ULONG)-1L;
        }
        *OutputBuffer++ = *input++;
        OutputBufferLength -= sizeof(*input);
        elementLength += sizeof(*input);
        inputLength -= sizeof(*input);
    }
    *InputBuffer = input;
    *InputBufferLength = inputLength;
    return elementLength;
}


BOOLEAN
SampValidateComputerName(
    IN  PWSTR Name,
    IN  ULONG Length
    )

/*++

Routine Description:

    Determines whether a computer name is valid or not

Arguments:

    Name    - pointer to zero terminated wide-character computer name
    Length  - of Name in characters, excluding zero-terminator

Return Value:

    BOOLEAN
        TRUE    Name is valid computer name
        FALSE   Name is not valid computer name

--*/

{

    if (0==DnsValidateName(Name,DnsNameHostnameFull))
    {
        //
        // O.K if it is a DNS name
        //

        return(TRUE);
    }

    //
    // Fall down to netbios name validation
    //

    if (Length > MAX_COMPUTERNAME_LENGTH || Length < 1) {
        return FALSE;
    }

    //
    // Don't allow leading or trailing blanks in the computername.
    //

    if ( Name[0] == ' ' || Name[Length-1] == ' ' ) {
        return(FALSE);
    }

    return (BOOLEAN)((ULONG)wcscspn(Name, InvalidDownLevelChars) == Length);
}



VOID
SamINotifyServerDelta(
    IN SAMP_NOTIFY_SERVER_CHANGE Change
    )
/*++

Routine Description:

    This routine is called by in proc components to notify SAM of global
    state change.
    
Arguments:

    Change -- the type of change that has occurred                

Return Value:

    None.

--*/
{
    PVOID fRet;

    switch ( Change ) {
    
    case SampNotifySiteChanged:

        fRet = LsaIRegisterNotification(SampUpdateSiteInfoCallback,
                                        NULL,
                                        NOTIFIER_TYPE_INTERVAL,
                                        0,            // no class
                                        NOTIFIER_FLAG_ONE_SHOT,
                                        1,          // wait for 1 seconds
                                        NULL        // no handle
                                        );

        if (!fRet) {

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAM: Failed to register SiteNotification\n"));
        }
        break;

    default:

        ASSERT( FALSE && "Unhandled change notification" );
    }

}
ULONG
SampClientRevisionFromHandle(IN PVOID handle)
{
   ULONG Revision = SAM_CLIENT_PRE_NT5;

   __try {
      Revision = ((NULL!=(PSAMP_OBJECT)handle)?(((PSAMP_OBJECT)handle)->ClientRevision):SAM_CLIENT_PRE_NT5);
   } __except (EXCEPTION_EXECUTE_HANDLER) {
      ;;
   }

   return(Revision);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dsupgrad\convobj.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    convobj.cxx

Abstract:

    These class definitions encapsulate the data and actions to move SAM objects
    located in the registry to the Directory Service.  The function definitions
    assume a running DS.

Author:

    ColinBr 30-Jul-1996

Environment:

    User Mode - Win32

Revision History:

    4-Sept-96  ColinBr  Added security change to regsitry keys so no
                        manual change would have to be done.
    15-Sept-96 ColinBr  Added code so the members of groups and aliases
                        would be extracted before the object was written
                        to the DS, since those fields are now zeroed out

++*/

#include <ntdspchx.h>
#pragma hdrstop


#include "event.hxx"

extern "C"{

#include <samsrvp.h>
#include <dslayer.h>
#include <dsmember.h>
#include <dsutilp.h>
#include <attids.h>
#include <filtypes.h>
#include <lmaccess.h>

//
// Forward declarations
//

NTSTATUS
SampRegObjToDsObj(
     IN  PSAMP_OBJECT     pObject,
     OUT ATTRBLOCK**      ppAttrBlock
     );

NTSTATUS
SampDsCreateObject(
    IN   DSNAME         *Object,
    SAMP_OBJECT_TYPE    ObjectType,
    IN   ATTRBLOCK      *AttributesToSet,
    IN   OPTIONAL PSID  DomainSid
    );

void
SampInitializeDsName(
                     IN DSNAME * pDsName,
                     IN WCHAR * NamePrefix,
                     IN ULONG NamePrefixLen,
                     IN WCHAR * ObjectName,
                     IN ULONG NameLen
                     );
NTSTATUS
SampGetAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG        AttributeIndex,
    IN BOOLEAN      MakeCopy,
    OUT PSID       *SidArray
    );

NTSTATUS
SampGetUlongArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PULONG *UlongArray,
    OUT PULONG UsedCount,
    OUT PULONG LengthCount
    );

NTSTATUS
SampGetArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PSID  *SidArray,
    OUT PULONG UsedCount,
    OUT PULONG LengthCount
    );

NTSTATUS
SampGetUnicodeStringAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PUNICODE_STRING UnicodeAttribute
    );

NTSTATUS
SampDsLookupObjectBySid(
    IN DSNAME *DomainObject,
    PSID       ObjectSid,
    DSNAME   **Object
    );

NTSTATUS
GetGroupRid(
    IN DSNAME * GroupObject,
    OUT PULONG GroupRid
    );

NTSTATUS
LookupObjectByRidAndGetPrimaryGroup(
    DSNAME      *BaseObject,
    IN  PSID     DomainSid,
    IN  ULONG    UserRid,
    OUT DSNAME **UserObject,
    OUT PULONG   UserPrimaryGroupId,
    OUT PULONG   UserAccountControl
    );

NTSTATUS
SampValidateRegAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup
    );


NTSTATUS
SampUpgradeUserParmsActual(
    IN PSAMP_OBJECT Context OPTIONAL,
    IN ULONG        Flags, 
    IN PSID         DomainSid, 
    IN ULONG        ObjectRid, 
    IN OUT PDSATTRBLOCK * AttributesBlock
    );
    

NTSTATUS
SampSetMachineAccountOwnerDuringDCPromo(
    IN PDSNAME pDsName,
    IN PSID    NewOwner 
    );

#include "util.h"

}

#include <convobj.hxx>
#include <trace.hxx>

extern CDomainObject  *pRootDomainObject;
#define RootDomainObject (*pRootDomainObject)

//
// Useful macros
//
#define CheckAndReturn(s)                                           \
if (!NT_SUCCESS(s)) {                                               \
     DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, s)); \
     return(s);                                                     \
}

#if DBG
#define MEMBER_BUFFER_SIZE 5
#else
#define MEMBER_BUFFER_SIZE 500
#endif

//
// Local utility functions
//

NTSTATUS
GetPartialRegValue (
    IN     HANDLE hRegistryHandle,
    IN     PUNICODE_STRING pUName,
    OUT    PVOID           *ppvData,
    IN OUT PULONG          pulLength
    );


//
// Static variable for CRegistryObject Class
//
ULONG CRegistryObject::_ulKeysWithPermChange = 0;

BOOL  KeyRestoreProblems(void) {

    // This function should be called at the very end of processing
    // all registry data.  Since the permission may be reset during
    // object destuction, we want to note any failures
    return(CRegistryObject::_ulKeysWithPermChange != 0);

}

//
// Class method definitions
//

NTSTATUS
CRegistryObject::Open(
    WCHAR *wcszRegName
    )
/*++

Routine Description:
    This function opens the registry specified by wcszRegName.  It also
    changes the DACL so an administrator can enumerate the keys. The change
    is undone once in the destructor.


Parameters:

    wcszRegName : the full path of a key in the registry


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CRegistryObject::Open");

    NTSTATUS          NtStatus;
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING    RegNameU;


    DebugInfo(("DSUPGRAD: Opening Registry key %ws\n", wcszRegName));

    //
    // Create the object that we will be opening in the registry
    //
    RtlInitUnicodeString( &RegNameU, wcszRegName);

    InitializeObjectAttributes(
        &Attributes,
        &RegNameU,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    //
    // Try to open for read control
    //
    NtStatus = NtOpenKey(
                  &_hRegistryKey,
                  KEY_READ,
                  &Attributes
                   );

    if ( NtStatus != STATUS_SUCCESS
      && NtStatus != STATUS_ACCESS_DENIED ) {

        CheckAndReturn(NtStatus);

    }

    if ( STATUS_ACCESS_DENIED == NtStatus ) {
        //
        // This is the default setting, we should have
        // write DACL control, though
        //
        NtStatus = NtOpenKey(
              &_hRegistryKey,
              WRITE_DAC | READ_CONTROL,
              &Attributes
               );
        if ( STATUS_ACCESS_DENIED == NtStatus ) {
            //
            // Can't do anything from here
            //
            DebugError((
            "DSUPGRAD does not have permission to KEY_READ or WRITE_DAC on registry keys\n"));
        }
        CheckAndReturn(NtStatus);

        //
        // We can write the DACL - give administrators permissions
        // to KEY_READ, and save our original permissions so they can be
        // reset
        //
        NtStatus = AddAdministratorsToPerms();
        CheckAndReturn(NtStatus);

        // Close the handle so we can reopen with WRITE_DAC
        NtClose(_hRegistryKey);

        NtStatus = NtOpenKey(
                      &_hRegistryKey,
                      KEY_READ | WRITE_DAC,
                      &Attributes
                       );
        CheckAndReturn(NtStatus);


    }

    return STATUS_SUCCESS;

}

NTSTATUS
CRegistryObject::Close(
    void
    )
/*++

Routine Description:

    This function resets the permissions on the key, if necessary,
    and then closes it.

Parameters:


Return Values:

--*/
{
    FTRACE(L"CRegistryObject::Close");

    NTSTATUS NtStatus = STATUS_SUCCESS;

    if ( _fRestorePerms ) {
        ASSERT(INVALID_HANDLE_VALUE != _hRegistryKey);
        NtStatus = RestorePerms();
        if ( !NT_SUCCESS(NtStatus) ) {
            DebugWarning(("DSUPGRAD: Unable to revert key to previous permissions\n"));
        }
        _fRestorePerms = FALSE;
    }

    if (INVALID_HANDLE_VALUE != _hRegistryKey)  {
        NtStatus = NtClose(_hRegistryKey);
        if ( !NT_SUCCESS(NtStatus) ) {
            DebugWarning(("DSUPGRAD: Unable to close key\n"));
        }
        _hRegistryKey = INVALID_HANDLE_VALUE;
    }

    if (_pSd) {
        RtlFreeHeap(RtlProcessHeap(), 0, _pSd);
        _pSd = NULL;
    }

    return NtStatus;
}

NTSTATUS
CRegistryObject::AddAdministratorsToPerms(
    void
    )
/*++

Routine Description:

    This routines querys the registry object's security info
    and adds the administrators alias to its list of SID's that
    can read and enumerate the keys.

Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CRegistryObject::AddAdministratorsFromPerms");

    NTSTATUS                 NtStatus;
    BOOL                     fAdminsFound = FALSE;
    ULONG                    i;
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;

    // Resources to be cleaned up
    PSID                     AdminsAliasSid = NULL;
    PSECURITY_DESCRIPTOR     pNewSd = NULL;

    //
    // Get the current security descriptor
    //
    NtStatus = NtQuerySecurityObject(_hRegistryKey,
                                     DACL_SECURITY_INFORMATION,
                                     NULL,
                                     0,
                                     &_ulSdLength);
    if ( NtStatus != STATUS_BUFFER_TOO_SMALL ) {
        CheckAndReturn(NtStatus);
    }

    _pSd = (PSECURITY_DESCRIPTOR) RtlAllocateHeap(RtlProcessHeap(), 0, _ulSdLength);
    if ( !_pSd ) {
        CheckAndReturn(STATUS_NO_MEMORY);
    }
    RtlZeroMemory(_pSd, _ulSdLength);

    NtStatus = NtQuerySecurityObject(_hRegistryKey,
                                     DACL_SECURITY_INFORMATION,
                                     _pSd,
                                     _ulSdLength,
                                     &_ulSdLength);
    if ( !NT_SUCCESS(NtStatus) ) {
        goto Cleanup;
    }

    //
    // Make a copy to work with
    //
    pNewSd = (PSECURITY_DESCRIPTOR) RtlAllocateHeap(RtlProcessHeap(), 0, _ulSdLength);
    if ( !pNewSd ) {
        CheckAndReturn(STATUS_NO_MEMORY);
    }
    RtlCopyMemory(pNewSd, _pSd, _ulSdLength);

    BOOL bDaclPresent, bDaclDefaulted;
    PACL pDacl;
    if (!GetSecurityDescriptorDacl(pNewSd,
                                   &bDaclPresent,
                                   &pDacl,
                                   &bDaclDefaulted)) {
        NtStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Create the well-known administrators SID
    //

    AdminsAliasSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid(2 ));
    if ( !AdminsAliasSid ) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlInitializeSid( AdminsAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( AdminsAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( AdminsAliasSid,  1 )) = DOMAIN_ALIAS_RID_ADMINS;

    //
    // Go through the ACE's looking for the Administrators'
    // entry
    //
    for (i = 0; i < pDacl->AceCount; i++ ) {
        PACCESS_ALLOWED_ACE pAce;

        NtStatus = RtlGetAce(pDacl, i, (void**)&pAce);
        if ( !NT_SUCCESS(NtStatus) ) {
            goto Cleanup;
        }

        if (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) {

            // Check the sid

            if (RtlEqualSid((PSID)&(pAce->SidStart), AdminsAliasSid)) {
                //
                // this is it!
                //
                pAce->Mask = (KEY_READ | WRITE_DAC);
                fAdminsFound = TRUE;
            }
        }
    }

    if ( !fAdminsFound ) {
        //
        // This is impossible since the key was opened up with
        // WRITE_DACL perms!
        //
        ASSERT(FALSE);
    }

    NtStatus = NtSetSecurityObject(_hRegistryKey,
                                   DACL_SECURITY_INFORMATION,
                                   pNewSd);

    if ( !NT_SUCCESS(NtStatus) ) {
        DebugError(("DSUPGRAD: Cannot set perms to read registry keys\n"));
    }

    _fRestorePerms = TRUE;
    _ulKeysWithPermChange++;

    //
    // That's it -  fall through to Cleanup
    //

Cleanup:

    if ( NULL != AdminsAliasSid ) {
        RtlFreeHeap(RtlProcessHeap(), 0, AdminsAliasSid);
    }

    if ( NULL != pNewSd ) {
        RtlFreeHeap(RtlProcessHeap(), 0, pNewSd);
    }

    CheckAndReturn(NtStatus);

    return STATUS_SUCCESS;

}

NTSTATUS
CRegistryObject::RestorePerms(
    void
    )
/*++

Routine Description:

    This routine sets the permission information of the key to
    its original state, before it was opened by this object

Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CRegistryObject::RestorePerms");

    NTSTATUS NtStatus;

    NtStatus = NtSetSecurityObject(_hRegistryKey,
                                   DACL_SECURITY_INFORMATION,
                                   _pSd);
    if ( !NT_SUCCESS(NtStatus)) {
        DebugWarning(("DSUPGRAD: Permissions not restored on key\n"));
    }
    _ulKeysWithPermChange--;

    return NtStatus;
}

CRegistrySamObject::~CRegistrySamObject()
{
    FTRACE(L"CRegistrySamObject::~CRegistrySamObject()");

    if ( _pSampObject ) {
        if ( _pSampObject->OnDisk ) {
            RtlFreeHeap(RtlProcessHeap(), 0, _pSampObject->OnDisk);
        }
        RtlFreeHeap(RtlProcessHeap(), 0, _pSampObject);
    }
}

NTSTATUS
CSeparateRegistrySamObject::Fill(void)
/*++

Routine Description:
    This routine queries the key embedding in the object for both
    the "V" and "F" values.  In addition is creates a SAMP_OBJECT
    context for the object calling this method. Memory is allocated
    is released in the destuctor.

Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CSeparateRegistrySamObject::Fill");

    NTSTATUS NtStatus;
    PVOID    pvFixed, pvVariable;
    ULONG    ulFixed, ulVariable;
    ULONG    ulTotalLength;

    //
    // CRegistryObject::Open should have succeeded
    //

    ASSERT(INVALID_HANDLE_VALUE != GetHandle());

    //
    // Allocate some space for the SAM definition of the object
    //
    _pSampObject = SampCreateContextEx(
                    _SampObjectType,
                    TRUE,  // Trusted client
                    FALSE,  // Ds Mode
                    TRUE,  // NotSharedByMultiThread
                    FALSE, // Loopback Client
                    TRUE,  // lazy commit
                    FALSE, // persist across across calls
                    FALSE, // Buffer Writes
                    TRUE,  // Opened By DCPromo
                    1 // the domain index is that of reg mode account domain
                    );

    if (NULL == _pSampObject) {
        CheckAndReturn(STATUS_INSUFFICIENT_RESOURCES);
    }

    // Set the object type
    _pSampObject->ObjectType = _SampObjectType;
    _pSampObject->RootKey    = GetHandle();
    _pSampObject->OnDiskAllocated = 0;
    _pSampObject->OnDiskFree      = 0;
    _pSampObject->OnDiskUsed      = 0;

    //
    // Inititialize the IsDSObject to Registry Object and
    // Object Name in DS to NULL. Later we will find out where
    // the Object should actually exist in the DS
    //
    SetRegistryObject(_pSampObject);
    _pSampObject->ObjectNameInDs = NULL;


    //
    // Read the attributes
    //
    ASSERT( !_pSampObject->FixedValid );
    ASSERT( !_pSampObject->VariableValid );

    NtStatus = SampValidateRegAttributes( _pSampObject,
                                          SAMP_FIXED_ATTRIBUTES );

    if ( NT_SUCCESS( NtStatus ) )
    {
        NtStatus = SampValidateRegAttributes( _pSampObject,
                                              SAMP_VARIABLE_ATTRIBUTES );
    }

    CheckAndReturn(NtStatus);


    // This is important as we never want Samp routines to
    // attempt to "validate" us!
    ASSERT( _pSampObject->FixedValid );
    ASSERT( _pSampObject->VariableValid );

    return STATUS_SUCCESS;

}

NTSTATUS
CTogetherRegistrySamObject::Fill(void)
/*++

Routine Description:
    This routine querys the key embedding in the object for just
    the "C".  In addition is creates a SAMP_OBJECT
    context for the object calling this method. Memory is allocated
    is released in the destuctor.

Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CTogetherRegistrySamObject::Fill");

    NTSTATUS NtStatus;
    PVOID    pvCombined;
    ULONG    ulCombinedLength;

    //
    // CRegistryObject::Open should have succeeded
    //
    ASSERT(INVALID_HANDLE_VALUE != GetHandle());

    //
    // Allocate some space for the SAM definition of the object
    //
    _pSampObject = SampCreateContextEx(
                    _SampObjectType,
                    TRUE,  // trusted client
                    FALSE, // ds mode
                    TRUE,  // NotSharedByMultiThread
                    FALSE, // Loopback Client
                    TRUE,  // lazy commit
                    FALSE, // persist across across calls
                    FALSE, // Buffer Writes
                    TRUE,  // Opened By DCPromo
                    1 // the domain index is that of reg mode account domain
                    );
    if (NULL == _pSampObject) {
        CheckAndReturn(STATUS_INSUFFICIENT_RESOURCES);
    }

    // Set the object type
    _pSampObject->ObjectType = _SampObjectType;
    _pSampObject->RootKey    = GetHandle();
    _pSampObject->OnDiskAllocated = 0;
    _pSampObject->OnDiskFree      = 0;
    _pSampObject->OnDiskUsed      = 0;

    //
    // Inititialize the IsDSObject to Registry Object and
    // Object Name in DS to NULL. Later we will find out where
    // the Object should actually exist
    //

    SetRegistryObject(_pSampObject);
    _pSampObject->ObjectNameInDs = NULL;


    ASSERT( !_pSampObject->FixedValid );
    ASSERT( !_pSampObject->VariableValid );

    //
    // Read the attributes
    //
    NtStatus = SampValidateRegAttributes( _pSampObject,
                                          SAMP_FIXED_ATTRIBUTES );

    if ( NT_SUCCESS( NtStatus ) )
    {
        NtStatus = SampValidateRegAttributes( _pSampObject,
                                              SAMP_VARIABLE_ATTRIBUTES );
    }

    CheckAndReturn(NtStatus);

    // This is important as we never want Samp routines to
    // attempt to "validate" us!
    ASSERT( _pSampObject->FixedValid );
    ASSERT( _pSampObject->VariableValid );


    return STATUS_SUCCESS;

}

NTSTATUS
CDsSamObject::Flush(PDSNAME pDsName)
/*++

Routine Description:

    This routine takes data in the CDsObject that should have been
    filled and converted, and writes it to the DS. _pDsName is
    assigned to pDsName, which is then freed in the destructor.

Parameters:

    pDsName : the DsName of the object

Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CDsSamObject::Flush");

    NTSTATUS NtStatus, NtStatusCreate;

    //
    // the Attribute block should be filled by now
    //
    ASSERT(_pAttributeBlock);

    ASSERT(pDsName);

    //
    // Set up the object's DS name.
    //
    _pDsName = pDsName;

    //
    // Create the object
    //
    DebugInfo(("DSUPGRAD: Creating DsObject %ws as type %d\n", _pDsName->StringName, _SampObjectType));

    //
    // Start a transaction
    //
    NtStatus = SampMaybeBeginDsTransaction(TransactionWrite);
    if (!NT_SUCCESS(NtStatus)) {
        DebugError(("DSUPGRAD: SampMaybeBeginDsTransaction error = 0x%lx\n", NtStatus));
        CheckAndReturn(NtStatus);
    }

    if ( (_ulObjectQuantifier & ulDsSamObjBuiltinDomain) == ulDsSamObjBuiltinDomain ) {
        //
        // Use a separate call
        //
        NtStatusCreate = SampDsCreateBuiltinDomainObject(_pDsName,
                                                         _pAttributeBlock);

    } else if ( (_ulObjectQuantifier & ulDsSamObjRootDomain) == ulDsSamObjRootDomain ) {
        //
        // The object is already created - just set the attributes
        //
        NtStatusCreate = SampDsSetAttributes(_pDsName,
                                             SAM_LAZY_COMMIT,
                                             ADD_ATT,
                                             _SampObjectType,
                                             _pAttributeBlock);

    } else {
        //
        // Create the object normally
        //
        if (SampUserObjectType == _SampObjectType)
        {
            ULONG Flags = SAM_LAZY_COMMIT | ALREADY_MAPPED_ATTRIBUTE_TYPES;
           
            if (RtlEqualSid(_rParentDomain.GetSid(), SampBuiltinDomainSid))
            {
                Flags |= DOMAIN_TYPE_BUILTIN;
            }
           
            NtStatusCreate = SampDsCreateObjectActual(_pDsName, 
                                                      Flags, 
                                                      _SampObjectType, 
                                                      _pAttributeBlock,
                                                      _rParentDomain.GetSid()
                                                      );

            if (NT_SUCCESS(NtStatusCreate) &&
                _PrivilegedMachineAccountCreate)
            {
                PSID    DomainAdmins = NULL;

                //
                // Construct the Domain Administrators Group SID
                // 
                NtStatusCreate = SampCreateFullSid(
                                _rParentDomain.GetSid(), 
                                DOMAIN_GROUP_RID_ADMINS,
                                &DomainAdmins
                                );


                if (NT_SUCCESS(NtStatusCreate))
                {
                    //
                    // Reset the owner of the Machine Account and 
                    // Add ms-ds-CreatorSid attribute
                    // 
                    NtStatusCreate = SampSetMachineAccountOwnerDuringDCPromo(
                                                      _pDsName,
                                                      DomainAdmins 
                                                      );

                    MIDL_user_free(DomainAdmins);
                }
            }
        }
        else 
        {
            NtStatusCreate = SampDsCreateObject(_pDsName,
                                                _SampObjectType,
                                                _pAttributeBlock,
                                                _rParentDomain.GetSid()
                                                );
        }
    }

    if ( !NT_SUCCESS(NtStatusCreate) ) {
        DebugError(("DSUPGRAD: SampDsCreateObject failed 0x%x\n", NtStatusCreate));
        // Don't bail out - we need to complete the transaction

        KdPrint(("[DsUpgrade], Failed Creation of object;DN is %S\n",_pDsName->StringName));
    }

    //
    // Commmit the transaction
    //
    NtStatus = SampMaybeEndDsTransaction(TransactionCommit);
    if (!NT_SUCCESS(NtStatus)) {
        DebugError(("DSUPGRAD: SampMaybeEndDsTransaction error = 0x%lx\n", NtStatus));
    }

    if (!NT_SUCCESS(NtStatusCreate)) {
        NtStatus = NtStatusCreate;
    }

    return NtStatus;

}

CDsObject::~CDsObject(void)
{
    FTRACE(L"CDsObject::~CDsObject");
    ULONG cAttr, cVal;

    if ( _pAttributeBlock ) {

        for ( cAttr = 0;
                  cAttr < _pAttributeBlock->attrCount;
                      cAttr++ ) {

            ASSERT(_pAttributeBlock->pAttr);

            for ( cVal = 0;
                      cVal < _pAttributeBlock->pAttr[cAttr].AttrVal.valCount;
                          cVal++ ) {

                ASSERT(_pAttributeBlock->pAttr[cAttr].AttrVal.pAVal);

                if ( _pAttributeBlock->pAttr[cAttr].AttrVal.pAVal[cVal].pVal ) {
                    RtlFreeHeap(RtlProcessHeap(), 0,
                                _pAttributeBlock->pAttr[cAttr].AttrVal.pAVal[cVal].pVal);
                }
            }

            if ( _pAttributeBlock->pAttr[cAttr].AttrVal.pAVal ) {
                RtlFreeHeap(RtlProcessHeap(), 0,
                            _pAttributeBlock->pAttr[cAttr].AttrVal.pAVal);
            }
        }

        if ( _pAttributeBlock->pAttr ) {
            RtlFreeHeap(RtlProcessHeap(), 0, _pAttributeBlock->pAttr);
        }

        RtlFreeHeap(RtlProcessHeap(), 0, _pAttributeBlock);
    }

    if ( _pDsName ) {
        //
        // This was allocated from the dslayer, which uses the MIDL* allocator.
        //
        MIDL_user_free(_pDsName);
    }
}

NTSTATUS
CGroupObject::ConvertMembers(
    VOID
    )
/*++

Routine Description:

    This method extracts the list of rids from the calling groups
    SAMP_OBJECT context and for each rid, finds the DS name and then
    adds that dsname to the membvership list.

Parameters:

    None.


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CGroupObject::ConvertMembers");

    //
    // This is the number of members we will hand off to the ds at a time.
    //

    NTSTATUS NtStatus, IgnoreStatus;

    ULONG    GroupRid;
    PSID     DomainSid, DomainSidTmp;
    DSNAME   *DomainObject, *DomainObjectTmp;

    DSNAME   *MemberNameArray[ MEMBER_BUFFER_SIZE ];
    ULONG     MemberNameCount;

    PUNICODE_STRING StringArray[2];
    UNICODE_STRING  MemberName, GroupName;
    PVOID     pTmp = NULL;

    NtStatus = STATUS_SUCCESS;

    //
    // Get the Group Rid
    //
    NtStatus = GetGroupRid( GetDsName(),&GroupRid );
    if ( !NT_SUCCESS( NtStatus ) ) {
        DebugError(("DSUPGRAD: GetGroupRid error = 0x%lx\n", NtStatus));
        CheckAndReturn(NtStatus);
    }

    //
    // Get the Domain DsName - make assure the memory stays valid for the
    // during of this function, which can span many sam/ds transactions.
    //
    DomainObjectTmp = GetRootDomain().GetDsName();

    if ( NULL == DomainObjectTmp )
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        DebugError(("DSUPGRAD: GetRootDomain().GetDsName() failure"));
        CheckAndReturn(NtStatus);
    }

    SAMP_ALLOCA(pTmp,DomainObjectTmp->structLen);
    DomainObject = (DSNAME *) pTmp;
    if ( NULL == DomainObject )
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DebugError(("DSUPGRAD: alloca failure"));
        CheckAndReturn(NtStatus);
    }
  
    RtlCopyMemory(DomainObject, DomainObjectTmp, DomainObjectTmp->structLen);

    DomainSidTmp = SampDsGetObjectSid(DomainObject);

    if ( NULL == DomainSidTmp )
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        DebugError(("DSUPGRAD: SampDsGetObjectSid() failure"));
        CheckAndReturn(NtStatus);
    }

    SAMP_ALLOCA(DomainSid,RtlLengthSid(DomainSidTmp));
    if ( NULL == DomainSid )
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DebugError(("DSUPGRAD: alloca failure"));
        CheckAndReturn(NtStatus);
    }
    RtlCopyMemory(DomainSid, DomainSidTmp, RtlLengthSid(DomainSidTmp));

    //
    // Clear the member array
    //
    RtlZeroMemory( MemberNameArray, sizeof( MemberNameArray ) );
    MemberNameCount = 0;

    //
    //  Iterate through the rids, shipping them off to the ds in batches
    //
    DebugInfo(("DSUPGRAD: Converting members of %ws\n", GetAccountName()));

    for ( ULONG i = 0;
            i < _cRids && NT_SUCCESS(NtStatus);
                i++ ) {

        PDSNAME  pUserDsName = 0;
        ULONG    UserPrimaryGroup;
        ULONG    UserAccountControl;
        BOOLEAN  fLastIteration = FALSE;

        if ( i == (_cRids - 1) )
        {
            fLastIteration = TRUE;
        }

        //
        // Get the DS name of the rid in this iteration
        //
        NtStatus = LookupObjectByRidAndGetPrimaryGroup(
                                           DomainObject,
                                           DomainSid,
                                           _aRids[i],
                                           &pUserDsName,
                                           &UserPrimaryGroup,
                                           &UserAccountControl
                                           );

        if ( NT_SUCCESS(NtStatus) )
        {
            //
            // We were able to resolve this name; now we want to consider this
            // member only if this group is not the primary group
            //
            if (  (GroupRid != UserPrimaryGroup )
                    && (!(UserAccountControl & UF_MACHINE_ACCOUNT_MASK)))
            {
                MemberNameArray[ MemberNameCount++ ] = pUserDsName;
            }
        }
        else
        {
            //
            // The name could not be resolved - log an event
            //
            WCHAR ridString[12]; // 2 for 0x + 8 for hex representation of
                                 // a 32 bit number

            StringArray[0] = &MemberName;
            StringArray[1] = &GroupName;

            swprintf(ridString, L"0x%x\0", _aRids[i]);
            RtlInitUnicodeString(&MemberName, ridString);
            RtlInitUnicodeString( &GroupName, GetAccountName() );

            SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                              0,                  // Category
                              SAMMSG_ERROR_GROUP_MEMBER_UNKNOWN,
                              NULL,               // Sid
                              2,                  // Num strings
                              sizeof(NTSTATUS),   // Data size
                              StringArray,        // String array
                              (PVOID)&NtStatus    // Data
                              );

            DebugInfo(("DSUPGRAD: Rid 0x%x NOT found when trying to add"
                       "to group %ws \n", _aRids[i], GetAccountName()));


            //
            // This scenario is handled successfully
            //
            NtStatus = STATUS_SUCCESS;

        }


        //
        // Is it time to flush MemberNameArray to the ds?
        //
        if (   (fLastIteration && MemberNameCount > 0 )
            || (MemberNameCount == (MEMBER_BUFFER_SIZE - 1))  )
        {

            //
            // Send these guys to the ds
            //

            //
            // Start a transaction
            //
            NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );

            if ( NT_SUCCESS(NtStatus) )
            {

                NtStatus = SampDsAddMultipleMembershipAttribute( GetDsName(),  // dsname of group
                                                                 SampGroupObjectType,
                                                                 SAM_LAZY_COMMIT,
                                                                 MemberNameCount,
                                                                 MemberNameArray );

                if ( NT_SUCCESS( NtStatus ) )
                {
                    //
                    // Ok, now try to commit the changes
                    //
                    NtStatus = SampMaybeEndDsTransaction( TransactionCommit );

                }
                else
                {
                    //
                    // Abort any changes
                    //
                    IgnoreStatus = SampMaybeEndDsTransaction( TransactionAbort );
                }


                if ( !NT_SUCCESS( NtStatus ) )
                {

                    //
                    // This is an unexpected case - slowly go through each member
                    // adding one at time, logging any errors that occur
                    //
                    NtStatus = STATUS_SUCCESS;

                    for ( ULONG j = 0;
                            j < MemberNameCount && NT_SUCCESS( NtStatus );
                                j++ )
                    {

                        //
                        // Start a transaction
                        //
                        NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );

                        if ( NT_SUCCESS( NtStatus ) )
                        {

                            //
                            // Add the member
                            //
                            NtStatus = SampDsAddMembershipAttribute( GetDsName(),
                                                                     SampGroupObjectType,
                                                                     MemberNameArray[j] );


                            if ( NT_SUCCESS( NtStatus ) )
                            {
                                //
                                // Ok, now try to commit the changes
                                //
                                NtStatus = SampMaybeEndDsTransaction( TransactionCommit );

                            }
                            else
                            {
                                //
                                // Abort any changes
                                //
                                IgnoreStatus = SampMaybeEndDsTransaction( TransactionAbort );
                            }

                            if ( !NT_SUCCESS( NtStatus ) )
                            {
                                //
                                // Oh well, we tried - this member really can't be
                                // transferred
                                //
                                StringArray[0] = &MemberName;
                                StringArray[1] = &GroupName;

                                RtlInitUnicodeString( &GroupName, GetAccountName() );
                                RtlInitUnicodeString( &MemberName, MemberNameArray[j]->StringName );

                                SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                                  0,                  // Category
                                                  SAMMSG_ERROR_GROUP_MEMBER,
                                                  NULL,               // Sid
                                                  2,                  // Num strings
                                                  sizeof(NTSTATUS),   // Data size
                                                  StringArray,        // String array
                                                  (PVOID)&NtStatus    // Data
                                                  );

                                DebugInfo(("DSUPGRAD: User %ws not added to group %ws\n",
                                          MemberName.Buffer, GetAccountName()));

                                //
                                // This scenario is handled successfully
                                //
                                NtStatus = STATUS_SUCCESS;

                            }
                        }
                        else
                        {
                            // Couldn't get a transaction? Bail
                            NtStatus = STATUS_NO_MEMORY;
                        }
                    }
                }
            }
            else
            {
                // Couldn't get a transaction? Bail
                NtStatus = STATUS_NO_MEMORY;
            }

            //
            // Reset the state of the MemberNameArray
            //
            for ( ULONG j = 0 ; j < MemberNameCount; j++ )
            {
                MIDL_user_free( MemberNameArray[j] );
                MemberNameArray[j] = NULL;
            }
            MemberNameCount = 0;

        }

    }

    return NtStatus;

}



NTSTATUS
CAliasObject::ConvertMembers(
    VOID
    )
/*++

Routine Description:

    This routine extracs the list of Sids for the calling aliases
    SAMP_OBJECT context data, and for each Sid, gets the dsname, and
    adds that dsname to the membership list of the alias.

Parameters:

    None.

Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CAliasObject::ConvertMembers");

    NTSTATUS NtStatus, IgnoreStatus;

    PSID     pCurrentSid = NULL;
    PSID     pDomainSid  = NULL, pDomainSidTmp = NULL;

    //
    // Locals to keep track of sids in the nt4 alias
    //
    ULONG    AliasSidIndex, AliasSidCount;

    //
    // Buffer of sids to send of to  ds
    //
    PSID     SidArray[ MEMBER_BUFFER_SIZE ];
    ULONG    SidCount, SidIndex;

    //
    // Array of dsname's resolved from sids in SidArray - allocated
    // from SAM code using MIDL
    //
    PDSNAME *NameArray = NULL;
    ULONG    NameCount = 0;

    //
    // Array of dsname's from NameArray that were actually resolved
    //
    PDSNAME  ResolvedNameArray[ MEMBER_BUFFER_SIZE ];
    ULONG    ResolvedNameCount;

    //
    // Used for event log messaging
    //
    PUNICODE_STRING StringArray[2];
    UNICODE_STRING  MemberName, AliasName;

    BOOLEAN        fLastIteration;
    ULONG          Index;

    //
    // Only a resource failure can cause this routine to fail
    //
    NtStatus = STATUS_SUCCESS;

    //
    //  Init the event log messaging
    //
    RtlInitUnicodeString( &AliasName, GetAccountName() );
    StringArray[0] = &MemberName;
    StringArray[1] = &AliasName;

    //
    // Get the domain sid
    //
    pDomainSidTmp  = SampDsGetObjectSid(GetRootDomain().GetDsName());
    if ( pDomainSidTmp )
    {
        SAMP_ALLOCA(pDomainSid,RtlLengthSid(pDomainSidTmp));
        if (NULL==pDomainSid)
        {
           CheckAndReturn(STATUS_INSUFFICIENT_RESOURCES);
        }
        RtlCopySid( RtlLengthSid(pDomainSidTmp), pDomainSid, pDomainSidTmp );
    }
    else
    {
        // No domain sid?
        CheckAndReturn( STATUS_INTERNAL_ERROR );
    }

    DebugInfo(("DSUPGRAD: Converting members of %ws\n", GetAccountName()));

    //
    // Clear the member sid array
    //
    RtlZeroMemory( SidArray, sizeof( SidArray ) );
    SidCount = 0;

    //
    // In batches of MEMBER_BUFFER_SIZE, resolve the sids into dsnames and
    // add dsnames to the alias'es membership list in the ds
    //
    for ( AliasSidIndex = 0, AliasSidCount = _cSids, pCurrentSid = _aSids;
            AliasSidIndex < AliasSidCount && NT_SUCCESS( NtStatus );
                AliasSidIndex++, pCurrentSid = (PSID) ((PBYTE)pCurrentSid
                                               + RtlLengthSid(pCurrentSid)) )

    {
        //
        // fLastIteration is set so we flush the last group of sids to ds
        // even if the buffer size is not met - hence don't increment
        // AliasSidIndex during this block!
        //
        if ( AliasSidIndex == ( AliasSidCount - 1 ) ) {
            fLastIteration = TRUE;
        } else {
            fLastIteration = FALSE;
        }

        //
        // Add the sid to current batch
        //
        SidArray[ SidCount++ ]  = pCurrentSid;


        //
        // Is it time to flush SidArray to the ds?
        //
        if (   fLastIteration
            || ( SidCount == MEMBER_BUFFER_SIZE ) )
        {

            //
            // Send the current batch to the ds
            //

            //
            // Start a transaction
            //
            NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );

            if ( NT_SUCCESS(NtStatus) )
            {
                //
                // Translate sids into dsnames
                //

                //
                // During this resolve Sids process we will
                // 1. Treat every Sid not belonging to the domain to be upgraded to be a foriegn
                //    domain security principal ( even if that Sid really belongs to some domain
                //    in the enterprise. The reason for this is that that we do not want to contact
                //    the G.C under any circumstance ( because of the sheer availability problem )
                //    Upgrades may run for a long time and the G.C may go down during this time. A
                //    further reason is that even if we implement the logic to contact the G.C and
                //    ignore any errors due to unavailability of G.C's we would still face cleanup
                //    problems.
                //

                NtStatus = SampDsResolveSidsForDsUpgrade(
                                pDomainSid,
                                SidArray,
                                SidCount,
                                ( RESOLVE_SIDS_ADD_FORIEGN_SECURITY_PRINCIPAL ),
                                &NameArray
                                );


                if ( !NT_SUCCESS( NtStatus ) )
                {
                    //
                    // We couldn't do them all at once, let's try one at a time
                    //
                    for (  Index = 0; Index < SidCount; Index++ )
                    {

                        PDSNAME *ppDsName;

                        NtStatus = SampDsResolveSidsForDsUpgrade(
                                        pDomainSid,
                                        &SidArray[Index],
                                        1,
                                        ( RESOLVE_SIDS_ADD_FORIEGN_SECURITY_PRINCIPAL ),
                                        &ppDsName
                                        );


                        if ( NT_SUCCESS(NtStatus) )
                        {
                            //
                            // N.B. SampDsResolveSidsForDsUpgrade can return
                            // STATUS_SUCCESS and set *pDsName to NULL.  This
                            // means the function successfully determined that
                            // the sid could not be resolved
                            //
                            NameArray[Index] = *ppDsName;
                        }
                        else
                        {
                            //
                            // The fact that this sid did not get resolved
                            // will be address in new loop
                            //
                            NameArray[Index] = NULL;
                        }
                    }

                    //
                    // This scenario is handled correctly
                    //
                    NtStatus = STATUS_SUCCESS;
                }

                //
                // These two arrays have the same cardinality
                //
                NameCount = SidCount;

                //
                // Package all the resolved sids into array
                //
                RtlZeroMemory( ResolvedNameArray, sizeof( ResolvedNameArray ) );
                ResolvedNameCount = 0;
                for ( Index = 0; Index < NameCount; Index++ )
                {

                    if ( NameArray[Index] )
                    {
                        ResolvedNameArray[ResolvedNameCount++] = NameArray[Index];
                    }
                    else
                    {
                        //
                        // This particular sid could not be resolved
                        //
                        IgnoreStatus = RtlConvertSidToUnicodeString(&MemberName,
                                                                    SidArray[Index],
                                                                    TRUE  // Allocate the memory
                                                                    );
                        ASSERT(NT_SUCCESS(IgnoreStatus));

                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,                  // Category
                                          SAMMSG_ERROR_ALIAS_MEMBER_UNKNOWN,
                                          NULL,               // Sid
                                          2,                  // Num strings
                                          sizeof(NTSTATUS),   // Data size
                                          StringArray,        // String array
                                          (PVOID)&NtStatus    // Data
                                          );

                        DebugInfo(("DSUPGRAD: Sid %ws NOT found when trying to add"
                                   "to alias %ws \n", MemberName.Buffer, GetAccountName()));

                        RtlFreeHeap( RtlProcessHeap(), 0, MemberName.Buffer );
                    }

                }

                //
                // Ship the resolved sids off to the ds
                //
                NtStatus = SampDsAddMultipleMembershipAttribute( GetDsName(),  // dsname of group
                                                                 SampAliasObjectType,
                                                                 SAM_LAZY_COMMIT,
                                                                 ResolvedNameCount,
                                                                 ResolvedNameArray );

                if ( NT_SUCCESS( NtStatus ) )
                {
                    //
                    // Ok, now try to commit the changes
                    //
                    NtStatus = SampMaybeEndDsTransaction( TransactionCommit );

                }
                else
                {
                    //
                    // Abort any changes
                    //
                    IgnoreStatus = SampMaybeEndDsTransaction( TransactionAbort );
                }

                if ( !NT_SUCCESS( NtStatus ) )
                {

                    //
                    // This is an unexpected case - slowly go through each member
                    // adding one at time, logging any errors that occur
                    //

                    NtStatus = STATUS_SUCCESS;

                    for ( Index = 0;
                            Index < ResolvedNameCount && NT_SUCCESS( NtStatus );
                                Index++ )
                    {

                        //
                        // Start a transaction
                        //
                        NtStatus = SampMaybeBeginDsTransaction( TransactionWrite );

                        if ( NT_SUCCESS( NtStatus ) )
                        {

                            //
                            // Add the member
                            //
                            NtStatus = SampDsAddMembershipAttribute( GetDsName(),
                                                                     SampGroupObjectType,
                                                                     ResolvedNameArray[Index] );


                            if ( NT_SUCCESS( NtStatus ) )
                            {
                                //
                                // Ok, now try to commit the changes
                                //
                                NtStatus = SampMaybeEndDsTransaction( TransactionCommit );

                            }
                            else
                            {
                                //
                                // Abort any changes
                                //
                                IgnoreStatus = SampMaybeEndDsTransaction( TransactionAbort );
                            }

                            if ( !NT_SUCCESS( NtStatus ) )
                            {
                                //
                                // Oh well, we tried - this member really can't be
                                // transferred
                                //
                                RtlInitUnicodeString( &MemberName, ResolvedNameArray[Index]->StringName );

                                SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                                  0,                  // Category
                                                  SAMMSG_ERROR_ALIAS_MEMBER,
                                                  NULL,               // Sid
                                                  2,                  // Num strings
                                                  sizeof(NTSTATUS),   // Data size
                                                  StringArray,        // String array
                                                  (PVOID)&NtStatus    // Data
                                                  );

                                DebugInfo(("DSUPGRAD: User %ws not added to group %ws\n",
                                          MemberName.Buffer, GetAccountName()));

                                //
                                // This scenario is handled successfully
                                //
                                NtStatus = STATUS_SUCCESS;

                            }
                        }
                        else
                        {
                            // Couldn't get a transaction? Bail
                            NtStatus = STATUS_NO_MEMORY;
                        }
                    }
                }
            }
            else
            {
                // Couldn't get a transaction? Bail
                NtStatus = STATUS_NO_MEMORY;
            }

            //
            // Release NameArray
            //
            if ( NameArray )
            {
                for ( Index = 0; Index < NameCount; Index++ )
                {
                    if ( NameArray[Index] )
                    {
                        MIDL_user_free( NameArray[Index] );
                        NameArray[Index] = NULL;
                    }
                }
                MIDL_user_free( NameArray );
                NameArray = NULL;
            }
            NameCount = 0;

            //
            // Reset the SidArray
            //
            RtlZeroMemory( SidArray, sizeof( SidArray ) );
            SidCount = 0;

        } // if buffer flush

    } // for

    //
    // Return to the caller, printing out any error message
    //
    CheckAndReturn( NtStatus );

    return STATUS_SUCCESS;

}

NTSTATUS
CConversionObject::Convert(void)
/*++

Routine Description:
    This routine transforms the SAMP_OBJECT data to be an in memory
    DS Sam object (ie, .OnDisk structure is changed, SetDsObject() is
    called, etc). and an AttributeBlock containing the same information
    is generated.

Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CConversionObject::Convert");

    NTSTATUS    NtStatus;

    NtStatus = SampRegObjToDsObj(_rRegObj._pSampObject, &(_rDsObj._pAttributeBlock));

    if (NT_SUCCESS(NtStatus) && 
        (SampUserObjectType == _rRegObj._SampObjectType))
    {
        _rDsObj._PrivilegedMachineAccountCreate = 
            (_rRegObj._pSampObject)->TypeBody.User.PrivilegedMachineAccountCreate;
    }

    return NtStatus;
}

NTSTATUS
CConversionObject::UpgradeUserParms(void)
/*++

Routine Description:
    This Routine upgrade SAMP_USER_OBJECT's UserParameters attribute.

Parameters:
    
    None
    
Return Values:
    
    STATUS_SUCCESS - The service completed successfully.
    
    STATUS_NO_MEMORY / STATUS_INVALID_PARAMETER  - Error return from SampUpgradeUserParmsActual.
    
--*/
{
    FTRACE(L"CConversionOject::UpgradeUserParms");
    
    ASSERT(SampUserObjectType == _rDsObj._SampObjectType);
    
    // 
    // Map SAM attribute ID to DS attribute ID, should always successful.
    // _rDsObj._pAttributeBlock has been updated.
    // 
    SampMapSamAttrIdToDsAttrId(_rDsObj._SampObjectType,
                               _rDsObj._pAttributeBlock
                               );
   
    // 
    // Upgrade UserParms Attribute, if succeed, _rDsObj._pAttributeBlock has been updated.
    // if failure, _pAttributeBlock remains unchanged.
    // 
    return SampUpgradeUserParmsActual(NULL,           // Context, OPTIONAL, 
                                      SAM_USERPARMS_DURING_UPGRADE,               // during upgrade
                                      _rDsObj._rParentDomain.GetSid(),            // Domain Sid
                                      (_rRegObj._pSampObject)->TypeBody.User.Rid,    // Object Rid
                                      &(_rDsObj._pAttributeBlock)                 // Attribute Block
                                      );
}


NTSTATUS
CDomainObject::Fill(void)
/*++

Routine Description:

    This routine, in addition to doing what the base ::Fill does,
    extracts the SID of the domain, since it is used by other objects
    during creation.

Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CDomainObject::Fill");

    NTSTATUS NtStatus;

    NtStatus = CSeparateRegistrySamObject::Fill();
    CheckAndReturn(NtStatus);

    //
    // Take the ->OnDisk structure and extract the SID
    //
    ASSERT(_pSampObject->FixedValid);
    ASSERT(_pSampObject->VariableValid);
    NtStatus = SampGetSidAttribute(_pSampObject,
                                   SAMP_DOMAIN_SID,
                                   TRUE,
                                   &_pSid);
    CheckAndReturn(NtStatus);

    ASSERT(NULL != _pSid);

    return STATUS_SUCCESS;

}

NTSTATUS
CDomainObject::SetAccountCounts(void)
/*++

Routine Description:

   This routine sets the account counts on the ds domain
   object.  The domain object should have been set at this point.
   An attrblock is allocated,  filled to set ATT_USER_COUNT,
   ATT_GROUP_COUNT, and ATT_ALIAS_COUNT attributes.

Parameters:


Return Values:

   STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CDomainObject::SetAccountsCounts");


    //
    // The DS is a multi Master System. Therefore it is no longer
    // feasible to maintain account counts. Therefore just return
    // status of Success in here
    //
    return STATUS_SUCCESS;

}

NTSTATUS
CUserObject::Fill(void)
/*++

Routine Description:

    This routine, in addition to doing what the base ::Fill does,
    extracts the Account name of the user object, so the eventually
    the DS name will be recognizable, and the account control field

Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CUserObject::Fill");

    NTSTATUS       NtStatus;
    UNICODE_STRING usTemp;


    NtStatus = CSeparateRegistrySamObject::Fill();
    CheckAndReturn(NtStatus);

    //
    // Set the Domain Sid for NT4 Security Descriptor Conversion
    // 
    _pSampObject->TypeBody.User.DomainSidForNt4SdConversion = 
                                _rParentDomain.GetSid();



    //
    // Take the ->OnDisk structure and extract the Account Name
    //
    ASSERT(_pSampObject->FixedValid);
    ASSERT(_pSampObject->VariableValid);
    NtStatus = SampGetUnicodeStringAttribute(_pSampObject,
                                             SAMP_USER_ACCOUNT_NAME,
                                             TRUE,
                                             &usTemp);
    CheckAndReturn(NtStatus);

    ASSERT(NULL != usTemp.Buffer);

    _wcszAccountName = (WCHAR*) RtlAllocateHeap(RtlProcessHeap(), 0, (usTemp.Length+1)*sizeof(WCHAR));
    if ( !_wcszAccountName ) {
        CheckAndReturn(STATUS_NO_MEMORY);
    }
    RtlZeroMemory(_wcszAccountName, (usTemp.Length+1)*sizeof(WCHAR));
    RtlCopyMemory(_wcszAccountName, usTemp.Buffer, usTemp.Length);
    _wcszAccountName[usTemp.Length] = L'\0';

    MIDL_user_free(usTemp.Buffer);

    //
    // Now get the account control field
    //
    PSAMP_V1_0A_FIXED_LENGTH_USER pFixedData = NULL;

    NtStatus = SampGetFixedAttributes(_pSampObject,
                                      FALSE,       // don't make a copy
                                      (VOID**)&pFixedData);
    CheckAndReturn(NtStatus);

    _ulAccountControl = pFixedData->UserAccountControl;
    
    //
    // Now set the TypeBody.User.Rid to the account Relative ID (UserID) 
    //
    
    _pSampObject->TypeBody.User.Rid = pFixedData->UserId;


    return STATUS_SUCCESS;

}

NTSTATUS
CGroupObject::Fill(void)
/*++

Routine Description:

    This routine, in addition to doing what the base ::Fill does,
    extracts the Account name of the user object, so the eventually
    the DS name will be recognizable.  Also the list of rids of users
    the belong in this group is extracted, as it will not be written
    to the DS, and hence it zeroed out before we can convert the
    members. The conversion of members happens after the the object is
    written to the DS, so the members must be preserved.


Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CGroupObject::Fill");

    NTSTATUS       NtStatus;
    UNICODE_STRING usTemp;

    NtStatus = CTogetherRegistrySamObject::Fill();

    CheckAndReturn(NtStatus);

    //
    // Take the ->OnDisk structure and extract the Account Name
    //
    ASSERT(_pSampObject->FixedValid);
    ASSERT(_pSampObject->VariableValid);
    NtStatus = SampGetUnicodeStringAttribute(_pSampObject,
                                             SAMP_GROUP_NAME,
                                             TRUE,
                                             &usTemp);
    CheckAndReturn(NtStatus);

    ASSERT(NULL != usTemp.Buffer);

    _wcszAccountName = (WCHAR*) RtlAllocateHeap(RtlProcessHeap(), 0, (usTemp.Length+1)*sizeof(WCHAR));
    if ( !_wcszAccountName ) {
        CheckAndReturn(STATUS_NO_MEMORY);
    }
    RtlZeroMemory(_wcszAccountName, (usTemp.Length+1)*sizeof(WCHAR));
    RtlCopyMemory(_wcszAccountName, usTemp.Buffer, usTemp.Length);
    _wcszAccountName[usTemp.Length] = L'\0';
    MIDL_user_free(usTemp.Buffer);


    //
    // Get the rid
    //
    PSAMP_V1_0A_FIXED_LENGTH_GROUP pFixedData = NULL;

    NtStatus = SampGetFixedAttributes(_pSampObject,
                                      FALSE,       // don't make a copy
                                      (VOID**)&pFixedData);
    CheckAndReturn(NtStatus);

    _GroupRid = pFixedData->RelativeId;

    //
    // Extract and copy the list of RID's
    //
    ASSERT(GetObject()->FixedValid);
    ASSERT(GetObject()->VariableValid);

    ULONG ulLength = 0;
    ULONG *aRids = NULL;

    NtStatus = SampGetUlongArrayAttribute(GetObject(),
                                          SAMP_GROUP_MEMBERS,
                                          FALSE,   // don't make a copy
                                          &aRids,
                                          &_cRids,
                                          &ulLength);
    // ulLength is the number of elements in the array; _cRids is the number
    // of "used" elements

    CheckAndReturn(NtStatus);


    if ( ulLength > 0 ) {

        ASSERT(_cRids > 0);
        ASSERT(aRids);

        _aRids = (ULONG*) RtlAllocateHeap(RtlProcessHeap(), 0, ulLength*sizeof(ULONG));
        if ( !_aRids ) {
            CheckAndReturn(STATUS_NO_MEMORY);
        }
        RtlCopyMemory(_aRids, aRids, ulLength*sizeof(ULONG));
    }

    return STATUS_SUCCESS;

}

NTSTATUS
CAliasObject::Fill(void)
/*++

Routine Description:

    This routine, in addition to doing what the base ::Fill does,
    extracts the Account name of the user object, so the eventually
    the DS name will be recognizable. Also the list of sids of members
    who belong to this group is extracted and copied, since that field
    will be zeroed before the DS write.  The conversion of members happens
    after the the object is written to the DS, so the members must be
    preserved.

Parameters:


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"CAliasObject::Fill");

    NTSTATUS       NtStatus;
    UNICODE_STRING usTemp;

    NtStatus = CTogetherRegistrySamObject::Fill();
    CheckAndReturn(NtStatus);

    //
    // Take the ->OnDisk structure and extract the Account Name
    //
    ASSERT(_pSampObject->FixedValid);
    ASSERT(_pSampObject->VariableValid);
    NtStatus = SampGetUnicodeStringAttribute(_pSampObject,
                                             SAMP_ALIAS_NAME,
                                             TRUE,
                                             &usTemp);
    CheckAndReturn(NtStatus);

    ASSERT(NULL != usTemp.Buffer);

    _wcszAccountName = (WCHAR*) RtlAllocateHeap(RtlProcessHeap(), 0, (usTemp.Length+1)*sizeof(WCHAR));
    if ( !_wcszAccountName ) {
        CheckAndReturn(STATUS_NO_MEMORY);
    }
    RtlZeroMemory(_wcszAccountName, (usTemp.Length+1)*sizeof(WCHAR));
    RtlCopyMemory(_wcszAccountName, usTemp.Buffer, usTemp.Length);
    _wcszAccountName[usTemp.Length] = L'\0';
    MIDL_user_free(usTemp.Buffer);

    //
    //  Get this alias's Rid
    //
    PSAMP_V1_FIXED_LENGTH_ALIAS pFixedData = NULL;

    NtStatus = SampGetFixedAttributes(_pSampObject,
                                      FALSE,       // don't make a copy
                                      (VOID**)&pFixedData);
    CheckAndReturn(NtStatus);

    _AliasRid = pFixedData->RelativeId;

    //
    //  We must obtain the list of SID's from the aliases
    //  OnDisk structure
    //
    ULONG ulLength = 0;
    PSID  aSids = NULL;

    ASSERT(GetObject()->FixedValid);
    ASSERT(GetObject()->VariableValid);
    NtStatus = SampGetSidArrayAttribute(GetObject(),
                                        SAMP_ALIAS_MEMBERS,
                                        FALSE,  // don't make a copy
                                        &aSids,
                                        &ulLength,
                                        &_cSids);
    CheckAndReturn(NtStatus);

    if ( ulLength > 0 ) {

        ASSERT(_cSids > 0);
        ASSERT(aSids);

        _aSids = (PSID) RtlAllocateHeap(RtlProcessHeap(), 0, ulLength);
        if ( !_aSids ) {
            CheckAndReturn(STATUS_NO_MEMORY);
        }
        RtlCopyMemory(_aSids, aSids, ulLength);
    }


    return STATUS_SUCCESS;

}


NTSTATUS
GetGroupRid(
    IN DSNAME * GroupObject,
    OUT PULONG GroupRid
    )
/*++
    Gets the Rid of a group Object

    Parameters:

        GroupObject -- DS Name of the group object
        GroupRid     -- Rid of the group object is returned
                       in here

    Return Values

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ATTRTYP RidTyp[] = { SAMP_FIXED_GROUP_RID };
    ATTRVAL RidVal[] = { 0,NULL};
    DEFINE_ATTRBLOCK1(AttrBlockToRead,RidTyp,RidVal);
    ATTRBLOCK OutAttrBlock;

    NtStatus = SampDsRead(
                GroupObject,
                0,
                SampGroupObjectType,
                &AttrBlockToRead,
                &OutAttrBlock
                );
    if (NT_SUCCESS(NtStatus))
    {
        ASSERT(OutAttrBlock.attrCount==1);

        *GroupRid =  *((ULONG *)(OutAttrBlock.pAttr->AttrVal.pAVal->pVal));
    }
    return NtStatus;
}





NTSTATUS
LookupObjectByRidAndGetPrimaryGroup(
    IN  DSNAME  *BaseObject,
    IN  PSID     DomainSid,
    IN  ULONG    UserRid,
    OUT DSNAME **UserObject,
    OUT PULONG   UserPrimaryGroupId,
    OUT PULONG   UserAccountControl
    )
/*++

    Searches for a user object by the specified Rid and retrieves
    the primary group Id of the user

    Parameters:

        BaseObject  DS Name of the base object under which to search
        DomainSid   The Sid of the domain under which we want the user
        User Rid    The Rid of the User
        UserObject  Out parameter specifying the DS Name of the User object
        UserPrmaryGroupId Out parameter specifying the Primary group of the user

    Return Values

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSID     AccountSid = NULL;
    FILTER   DsFilter;
    ULONG    AccountSubAuthorityCount;
    ULONG    AccountSidLength;
    ATTRTYP  AttrTyp[] = { SAMP_FIXED_USER_PRIMARY_GROUP_ID,
                           SAMP_FIXED_USER_ACCOUNT_CONTROL
                         };
    ATTRVAL  AttrVal[] = {{0,NULL},{0,NULL}};
    DEFINE_ATTRBLOCK2(AttrsToRead,AttrTyp,AttrVal);
    SEARCHRES * SearchRes;


    //
    // Create a full Sid as follows
    //

    //
    // Calculate the size of the new Sid
    //

    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(DomainSid) + (UCHAR)1;
    AccountSidLength = RtlLengthRequiredSid(AccountSubAuthorityCount);


    //
    // Allocate enough memory for the new Sid
    //

    AccountSid = RtlAllocateHeap(RtlProcessHeap(),0,AccountSidLength);
    if (NULL!=AccountSid)
    {
        NTSTATUS    IgnoreStatus;
        PULONG      RidLocation;

        IgnoreStatus = RtlCopySid(AccountSidLength, AccountSid, DomainSid);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Increment the account sid sub-authority count
        //

        *RtlSubAuthorityCountSid(AccountSid) = (UCHAR) AccountSubAuthorityCount;

        //
        // Add the rid as the final sub-authority
        //

        RidLocation = RtlSubAuthoritySid(AccountSid, AccountSubAuthorityCount-1);
        *RidLocation = UserRid;
    }
    else
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    //
    // Compose a Filter to search on the Sid
    //

    memset (&DsFilter, 0, sizeof (DsFilter));
    DsFilter.pNextFilter = NULL;
    DsFilter.choice = FILTER_CHOICE_ITEM;
    DsFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    DsFilter.FilterTypes.Item.FilTypes.ava.type = SampDsAttrFromSamAttr(
                                                       SampUnknownObjectType,
                                                       SAMP_UNKNOWN_OBJECTSID
                                                       );

    DsFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = AccountSidLength;
    DsFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *) AccountSid;

    NtStatus = SampDsDoSearch(
                    NULL,
                    BaseObject,
                    &DsFilter,
                    0,
                    SampUserObjectType,
                    &AttrsToRead,
                    1,
                    &SearchRes
                    );
    if ((NT_SUCCESS(NtStatus)) && SearchRes->count)
    {
        ASSERT(SearchRes->FirstEntInf.Entinf.AttrBlock.attrCount==2);
        *UserPrimaryGroupId =  *((ULONG *)
            (SearchRes->FirstEntInf.Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal));
        *UserAccountControl =  *((ULONG *)
            (SearchRes->FirstEntInf.Entinf.AttrBlock.pAttr[1].AttrVal.pAVal[0].pVal));

        *UserObject = (DSNAME *)
                        MIDL_user_allocate(SearchRes->FirstEntInf.Entinf.pName->structLen);
        if (NULL==*UserObject)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        RtlCopyMemory(*UserObject,
                  SearchRes->FirstEntInf.Entinf.pName,
                  SearchRes->FirstEntInf.Entinf.pName->structLen
                  );


    }
    else if  ((NT_SUCCESS(NtStatus)) && (0==SearchRes->count))
    {
        //
        // We are supposed to fail if no entries were returned
        //
        NtStatus = STATUS_UNSUCCESSFUL;
    }

Error:

    if (NULL!=AccountSid)
    {
        RtlFreeHeap(RtlProcessHeap(),0,AccountSid);
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dsupgrad\interfc1.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    interfac.c

Abstract:

    Interface routine to transfer SAM information in Registry to DS


Author:

    ColinBr 30-Jul-1996

Environment:

    User Mode - Win32

Revision History:

--*/

extern "C" {
#include <samsrvp.h>
#include <util.h>
}
#include <convobj.hxx>

extern CDomainObject *pRootDomainObject;

ULONG DebugInfoLevel = _DEB_ERROR | _DEB_WARNING;

extern "C"
NTSTATUS
TransferSamObjects(
    WCHAR *wcszSamRegPath
);

extern "C"
NTSTATUS
SampRegistryToDsUpgrade(
    WCHAR *wcszSamRegLocation
    )

/*++

Routine Description:

    This routine is the interface function for the routines to transfer
    SAM objects from the registry to to the directory service


Parameters:

    wcszSamLocation  - this is the location of the SAM repository in the registry

Return Values:

    STATUS_SUCCESS - The service completed successfully.

    Note all exceptions are caught so the return value will relfect any unsual
    exceptions

--*/
{
    CDomainObject RootDomainObject;

    ASSERT(wcszSamRegLocation);

    pRootDomainObject = &RootDomainObject;

    return TransferSamObjects(wcszSamRegLocation);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dsupgrad\util.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    util.h

Abstract:

    This file contains define's for hardcoded values used in dsupgrad and
    useful debug output

Author:

    ColinBr 26-Aug-1996

Environment:

    User Mode - Win32

Revision History:

--*/
#ifndef __UTIL_H
#define __UTIL_H

#define _DEB_INFO             0x0001
#define _DEB_WARNING          0x0002
#define _DEB_ERROR            0x0004
#define _DEB_TRACE            0x0008

// Defined in interfac.c
extern ULONG DebugInfoLevel;

#define DebugWarning(x) if ((DebugInfoLevel & _DEB_WARNING) == _DEB_WARNING) {KdPrint(x);}
#define DebugError(x)   if ((DebugInfoLevel & _DEB_ERROR) == _DEB_ERROR)     {KdPrint(x);}
#define DebugTrace(x)   if ((DebugInfoLevel & _DEB_TRACE) == _DEB_TRACE)     {KdPrint(x);}
#define DebugInfo(x)    if ((DebugInfoLevel & _DEB_INFO) == _DEB_INFO)       {KdPrint(x);}

#define MAX_REGISTRY_NAME_LENGTH      SAMP_MAXIMUM_NAME_LENGTH
#define MAX_REGISTRY_KEY_NAME_LENGTH  512

#endif // __UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dsupgrad\convert.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    convert.cxx

Abstract:

    Routines to transfer SAM information in Registry to DS.

    The main routine, TransferSamObjects, will only fail if the underlying
    SAM database is corrupt.  Otherwise, given a coherent SAM registry
    base, the routine will success logging all ds addition failures in the
    event log.

Author:

    ColinBr 30-Jul-1996

Environment:

    User Mode - Win32

Revision History:

    Colin Brace (ColinBr) May 21, 1997

        Improved error handling code.

--*/

#include <ntdspchx.h>
#pragma hdrstop

//
// Bring the SAM structure definitions
//

#define MAX_DOWN_LEVEL_NAME_LENGTH 20

extern "C" {

#include <samsrvp.h>

// Ignore debug stuff for GetConfigParam
#include <dsconfig.h>
#include <dslayer.h>            // SampDsLookupObjectByName
#include <attids.h>
#include "util.h"

NTSTATUS
SampDsLookupObjectByNameEx(
    IN DSNAME * DomainObject,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PUNICODE_STRING ObjectName,
    OUT DSNAME ** Object,
    ULONG SearchFlags
    );

}

#include <convobj.hxx>
#include <trace.hxx>

//
// This macro returns if a non-success occurred
//
#define CheckAndReturn(s)                                           \
if (!NT_SUCCESS(s)) {                                               \
     DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, s)); \
     return(s);                                                     \
}

BOOLEAN
SampIsNtStatusResourceError(
    NTSTATUS NtStatus
    )
{

    switch ( NtStatus )
    {
        case STATUS_NO_MEMORY:
        case STATUS_INSUFFICIENT_RESOURCES:
        case STATUS_DISK_FULL:

            return TRUE;

        default:

            return FALSE;
    }
}

    
//
// Global variables and contants
//
PWCHAR          wcszRootDomainDN = NULL;
PDSNAME        gRootDomainDsName = NULL;
CDomainObject  *pRootDomainObject;

HMODULE         SampStringNameResource = NULL;
WCHAR           SampDefaultConflictString[] = L"$AccountNameConflict";
ULONG           SampNameConflictCount;

#define RootDomainObject (*pRootDomainObject)

//
// Local Utility functions
//
NTSTATUS
ConvertDomains(
    CServerObject &ServerObject,
    WCHAR*        wcszServerRegName
    );

NTSTATUS
ConvertUsers(
    CDomainObject &DomainObject,
    WCHAR*        wcszDomainRegName
    );

NTSTATUS
ConvertGroups(
    CDomainObject &DomainObject,
    WCHAR*        wcszDomainRegName
    );

NTSTATUS
ConvertAliases(
    CDomainObject &DomainObject,
    WCHAR*        wcszDomainRegName
    );

extern "C"
NTSTATUS
GetRdnForSamObject(IN WCHAR* SamAccountName,
                   IN SAMP_OBJECT_TYPE SampObjectType,
                   OUT WCHAR* RdnBuffer,
                   IN OUT ULONG* Size
                   );

NTSTATUS
CheckForNonExistence(
    WCHAR* AccountName,
    SAMP_OBJECT_TYPE SampObjectType
    );

//
// Function Definitions
//
NTSTATUS
GetRootDomainDN(void)
{
    DWORD    cbRootDomainDN = 0;
    ULONG    dwErr=0;

    dwErr = GetConfigParamAllocW(MAKE_WIDE(ROOTDOMAINDNNAME),
                                    (PVOID *) &wcszRootDomainDN,
                                    &cbRootDomainDN);
    if ( 0!=dwErr ) {
        DebugError(("GetConfigAllocParam failed: 0x%x\n", dwErr));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // The root container for the SAM objects in the DS should have
    // set
    ASSERT(wcslen(wcszRootDomainDN) > 0);

    return STATUS_SUCCESS;

}

extern "C" {


NTSTATUS
TransferSamObjects(
    IN WCHAR *wcszSamRegistryPath
)
/*++

Routine Description:

    This routine opens the top level registry container, aka the
    Server Object, converts all the domains and their subkey and
    then finally writes out the server object.

    The critical operations in the transfer are:

    1) reading the dn of the root domain
    2) reading and writing the SAM server object
    3) reading and writing the builtin domain object
    4) reading and writing the account domain object
    5) traversing a non-corrupt SAM database

    If any of these fail, then TransferSamObjects will fail, resulting
    in an unsuccessful upgrade.

    5) implies that during the transfer sanity checks are performed on the
    SAM registry database; if any of these fail, the operation is aborted.

    Any other non-success, will be considered non-fatal; an event will be
    logged indicating the nature of the event and a debug printout will
    also be made.

Parameters:

    wcszSamRegistryPath : this is the full path to the server object


Return Values:

    STATUS_SUCCESS - The service completed successfully.
    STATUS_NO_MEMORY
    any other that might occur when dealing with DS

--*/
{
    FTRACE(L"TransferSamObjects");

    NTSTATUS               NtStatus;

    UNICODE_STRING         uServerDN;
    UNICODE_STRING         uSystemContainerDN;
    PDSNAME                SystemContainerDsName = NULL;
    PDSNAME                ServerDsName = NULL;
    PDSNAME                TempDomainDsName = NULL;
    ULONG                  Size = 0;

    CServerObject          ServerObject(RootDomainObject);

    //
    // Init some globals
    //
    SampNameConflictCount = 0;


    //
    // Get the DN of the root domain object
    //
    NtStatus = GetRootDomainDN();
    if (!NT_SUCCESS(NtStatus)) {
        // This is fatal
        DebugError(("Dsupgrad: GetRootDomainDN failed, error: 0x%x\n", NtStatus));
        goto Cleanup;
    }
    
    //
    // Construct the Domain's DSNAME from wcszRootDomainDN
    // 
    Size = (ULONG)DSNameSizeFromLen(wcslen(wcszRootDomainDN));
    
    TempDomainDsName = (PDSNAME) MIDL_user_allocate(Size);
    
    if (NULL == TempDomainDsName)
    {
        // This is fatal
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    
    memset(TempDomainDsName, 0, Size);
    
    TempDomainDsName->structLen = Size;
    TempDomainDsName->NameLen = wcslen(wcszRootDomainDN);
    wcscpy(TempDomainDsName->StringName, wcszRootDomainDN);
    
    //
    // call dslayer routine to initialize SAM global varibles which
    // pointe to well known container's ds name
    // 
    NtStatus = SampInitWellKnownContainersDsName(TempDomainDsName);
    
    // 
    // release the memory we just allocated.
    //  
    MIDL_user_free(TempDomainDsName);
    
    if (!NT_SUCCESS(NtStatus))
    {
        // This is fatal
        goto Cleanup;
    }

    //
    // Open the server object
    //
    NtStatus = ServerObject.Open(wcszSamRegistryPath);
    if (!NT_SUCCESS(NtStatus)) {
        // This is fatal
        DebugError(("Dsupgrad: GetRootDomainDN failed, error: 0x%x\n", NtStatus));
        goto Cleanup;
    }


    NtStatus = ConvertDomains(ServerObject, wcszSamRegistryPath);
    if (!NT_SUCCESS(NtStatus)) {
        // This is fatal
        DebugError(("Dsupgrad: ConvertDomains failed, error: 0x%x\n", NtStatus));
        goto Cleanup;
    }

    //
    // Now we write out the server object
    //
    NtStatus = ServerObject.Fill();
    if (!NT_SUCCESS(NtStatus)) {
        // This is fatal
        DebugError(("Dsupgrad: Could not read server object, error: 0x%x\n", NtStatus));
        goto Cleanup;
    }

    NtStatus = ServerObject.Convert();
    if (!NT_SUCCESS(NtStatus)) {
        // This is fatal
        DebugError(("Dsupgrad: Could not convert server object, error: 0x%x\n", NtStatus));
        goto Cleanup;
    }

    //
    // Create a ds name for the server object
    //

    RtlInitUnicodeString(&uSystemContainerDN,L"System");

    NtStatus = SampDsCreateDsName(gRootDomainDsName,
                                  &uSystemContainerDN,
                                  &SystemContainerDsName);
    if (!NT_SUCCESS(NtStatus)) {
        // This is fatal
        DebugError(("Dsupgrad: Could not create a name for the server object, error: 0x%x\n", NtStatus));
        goto Cleanup;
    }

    RtlInitUnicodeString(&uServerDN,L"Server");

    NtStatus = SampDsCreateDsName(SystemContainerDsName,
                                  &uServerDN,
                                  &ServerDsName);
    if (!NT_SUCCESS(NtStatus)) {
        // This is fatal
        DebugError(("Dsupgrad: Could not create a name for the server object, error: 0x%x\n", NtStatus));
        goto Cleanup;
    }


    //
    //  The server object takes ownership of the ds name
    //
    NtStatus = ServerObject.Flush(ServerDsName);
    ServerDsName = NULL;

    if (!NT_SUCCESS(NtStatus)) {
        // This is fatal
        DebugError(("Dsupgrad: Could not create server object, error: 0x%x\n", NtStatus));
        goto Cleanup;
    }

    //
    // Explicity close remaining keys
    //
    NtStatus = ServerObject.Close();
    if (!NT_SUCCESS(NtStatus)) {
        DebugWarning(("Dsupgrad: Could not close handle, error: 0x%x\n", NtStatus));
    }

    NtStatus = RootDomainObject.Close();
    if (!NT_SUCCESS(NtStatus)) {
        DebugWarning(("Dsupgrad: Could not close handle, error: 0x%x\n", NtStatus));
    }

    //
    // Make sure that if any permissions on registry keys were modified
    // that they are undone.
    //
    if ( KeyRestoreProblems() ) {
        DebugWarning((
        "DSUPGRAD *** Warning! Some registry keys not restored to original configuration\n"));
    }

    NtStatus = STATUS_SUCCESS;

    //
    //  That's it fall through to cleanup
    //

Cleanup:

    if (wcszRootDomainDN)
    {
        free(wcszRootDomainDN);
    }

    if (gRootDomainDsName) {
        MIDL_user_free(gRootDomainDsName);
    }

    if (SystemContainerDsName){
        MIDL_user_free(SystemContainerDsName);
    }

    if (SampStringNameResource) {
        FreeLibrary(SampStringNameResource);
        SampStringNameResource = NULL;
    }

    if (!NT_SUCCESS(NtStatus)) {
        //
        // A fatal error occurred
        //

        SampWriteEventLog(EVENTLOG_ERROR_TYPE,
                          0,                // Category
                          SAMMSG_FATAL_UPGRADE_ERROR,
                          NULL,             //  Sid
                          0,                // Num strings
                          sizeof(NTSTATUS), // Data size
                          NULL,             // String array
                          (PVOID)&NtStatus  // Data
                          );
    }

    return NtStatus;

}

} // extern "C"

NTSTATUS
ConvertDomains(
    IN CServerObject &ServerObject,
    IN WCHAR*        wcszServerRegName
    )
/*++

Routine Description:

    This routine finds the "Domains" key under the server object
    registry handle and then for each domain, converts it and its
    users, groups, and aliases.

    If the domain objects (either account or builtin) cannot be successfully
    created, a fatal error is returned, which will cause the upgrade to
    fail.

Parameters:

    ServerObject      : a server object that has already been opened
    wcszServerRegName : the path in the reg of this open

Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"ConvertDomain");

    NTSTATUS NtStatus = STATUS_SUCCESS;

    // Misc counters
    ULONG i;

    // This is server query data
    BYTE   ServerInfo[sizeof(KEY_FULL_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG  ulServerInfoLength = 0;

    // This is data for enumerating the keys on the server object
    BYTE   EnumServerInfo[sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG  ulEnumServerInfoLength = 0;

    // This is domains key data
    CRegistryObject DomainsKey;
    BYTE            DomainsKeyInfo[sizeof(KEY_FULL_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG           ulDomainsKeyInfoLength = 0;
    WCHAR           wcszDomainsKeyRegName[MAX_REGISTRY_NAME_LENGTH];

    // This is the Builtin Domain object - the other domain, the "Accounts"
    // will use the global RootDomainObject
    CBuiltinDomainObject BuiltinDomain(RootDomainObject);

    // Parameter checking
    ASSERT(wcszServerRegName);

    // Stack clearing
    RtlZeroMemory(ServerInfo, sizeof(ServerInfo));
    RtlZeroMemory(EnumServerInfo, sizeof(EnumServerInfo));
    RtlZeroMemory(DomainsKeyInfo, sizeof(DomainsKeyInfo));

    //
    // Get some enumeration info from the server object
    // This will tell us how many sub keys there are
    //

    NtStatus = NtQueryKey(
                   ServerObject.GetHandle(),
                   KeyFullInformation,
                   &ServerInfo,
                   sizeof(ServerInfo),
                   &ulServerInfoLength);

    CheckAndReturn(NtStatus);
    ASSERT(ulServerInfoLength <= sizeof(ServerInfo));

    //
    // Iterate through - there should only be two and
    // we are only interested in the "Domains" key
    //
    for ( i = 0; i < ((PKEY_FULL_INFORMATION)ServerInfo)->SubKeys; i++ ) {

        //
        // Get the name of the subkey
        //

        NtStatus = NtEnumerateKey(
                       ServerObject.GetHandle(),
                       i,
                       KeyBasicInformation,
                       EnumServerInfo,
                       sizeof(EnumServerInfo),
                       &ulEnumServerInfoLength);

        CheckAndReturn(NtStatus);
        ASSERT(ulEnumServerInfoLength <= sizeof(EnumServerInfo));

        if ( !wcsncmp(((PKEY_BASIC_INFORMATION)EnumServerInfo)->Name, L"Domains", 7)) {

            //
            // This is it!
            //

            //
            // Now open the subkey
            //
            wcszDomainsKeyRegName[0] = L'\0';
            wcscat(wcszDomainsKeyRegName, wcszServerRegName);
            wcscat(wcszDomainsKeyRegName, L"\\Domains");

            NtStatus = DomainsKey.Open(wcszDomainsKeyRegName);
            CheckAndReturn(NtStatus);

            // Get the full information on that key
            NtStatus = NtQueryKey(
                           DomainsKey.GetHandle(),
                           KeyFullInformation,
                           &DomainsKeyInfo,
                           sizeof(DomainsKeyInfo),
                           &ulDomainsKeyInfoLength);

            CheckAndReturn(NtStatus);
            ASSERT(ulDomainsKeyInfoLength <= sizeof(DomainsKeyInfo));

            // Other keys are irrelevant right now
            break;

        }

    }

    //
    // Make sure we have found the Domains key
    //
    if (0 == ulDomainsKeyInfoLength) {
        //
        // Bad news! This is a corrupt SAM database
        //
        DebugError(("DSUPGRAD: No \"Domains\" key found! Aborting ...\n"));
        CheckAndReturn(STATUS_INTERNAL_ERROR);
    }

    //
    // Now, iterate on the "Domains" key - there should only
    // be two domains
    //
    for ( i = 0; i < ((PKEY_FULL_INFORMATION)DomainsKeyInfo)->SubKeys; i++ ) {

        //
        // Get the name of the subkey
        //
        BYTE  DomainNameInfo[sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
        ULONG ulDomainNameInfoLength;

        WCHAR  wcszDomainRegName[MAX_REGISTRY_NAME_LENGTH];
        WCHAR* temp;
        PDSNAME        DomainDsName = NULL;
        UNICODE_STRING uDomainName;
        ULONG          Size;

        CDomainObject *pDomainObject = NULL;

        // stack clearing
        RtlZeroMemory(DomainNameInfo, sizeof(DomainNameInfo));
        RtlZeroMemory(wcszDomainRegName, sizeof(wcszDomainRegName));


        NtStatus = NtEnumerateKey(
                       DomainsKey.GetHandle(),
                       i,
                       KeyBasicInformation,
                       DomainNameInfo,
                       sizeof(DomainNameInfo),
                       &ulDomainNameInfoLength);

        CheckAndReturn(NtStatus);
        ASSERT(ulDomainNameInfoLength <= sizeof(DomainNameInfo));

        //
        // Construct the name of this registry key
        //
        WCHAR wcszTempBuffer[MAX_REGISTRY_KEY_NAME_LENGTH];
        RtlZeroMemory(wcszTempBuffer, sizeof(wcszTempBuffer));

        wcsncpy(wcszTempBuffer, ((PKEY_BASIC_INFORMATION)DomainNameInfo)->Name,
                ((PKEY_BASIC_INFORMATION)DomainNameInfo)->NameLength/sizeof(WCHAR));
        wcszTempBuffer[((PKEY_BASIC_INFORMATION)DomainNameInfo)->NameLength/sizeof(WCHAR)] = L'\0';

        wcszDomainRegName[0] = L'\0';
        wcscat(wcszDomainRegName, wcszDomainsKeyRegName);
        wcscat(wcszDomainRegName, L"\\");
        wcscat(wcszDomainRegName, wcszTempBuffer);

        //
        // Which domain is this ?
        //
        if ( !wcsncmp(((PKEY_BASIC_INFORMATION)DomainNameInfo)->Name, L"Account", 7 )) {

            // This is the "Accounts" object full name, which is the
            // container of all other SAM information in the DS

            ASSERT(wcslen(wcszRootDomainDN));

            //
            // There exists no dslayer calls to create a dsname for the domain
            // so we make it here outselves
            //
            Size = (ULONG)DSNameSizeFromLen(wcslen(wcszRootDomainDN));

            DomainDsName = (PDSNAME)MIDL_user_allocate(Size);
            if (!DomainDsName) {
                return STATUS_NO_MEMORY;
            }
            memset(DomainDsName, 0, Size);

            DomainDsName->structLen = Size;
            DomainDsName->NameLen = wcslen(wcszRootDomainDN);
            wcscpy(DomainDsName->StringName, wcszRootDomainDN);

            //
            // Store a global copy for the rest of conversions
            //
            gRootDomainDsName = (PDSNAME) MIDL_user_allocate(Size);
            if (!gRootDomainDsName) {
                return STATUS_NO_MEMORY;
            }
            memcpy(gRootDomainDsName, DomainDsName, Size);

            pDomainObject = &RootDomainObject;

        } else if ( !wcsncmp(((PKEY_BASIC_INFORMATION)DomainNameInfo)->Name, L"Builtin", 7 ) ) {

            //
            // This is the builtin account
            //
            WCHAR wcszBuiltinName[MAX_REGISTRY_KEY_NAME_LENGTH];

            RtlZeroMemory(wcszBuiltinName, sizeof(wcszBuiltinName));

            wcsncpy(wcszBuiltinName,
                   ((PKEY_BASIC_INFORMATION)DomainNameInfo)->Name,
                   ((PKEY_BASIC_INFORMATION)DomainNameInfo)->NameLength/sizeof(WCHAR));



            //
            // Create a dsname based on the dn
            //
            RtlInitUnicodeString(&uDomainName,wcszBuiltinName);

            NtStatus = SampDsCreateDsName(gRootDomainDsName,
                                          &uDomainName,
                                          &DomainDsName);
            CheckAndReturn(NtStatus);

            pDomainObject = &BuiltinDomain;



        } else {
            //
            // Bad news - there should not be anything here
            //
            DebugWarning(("DSUPGRAD: Unknown keys found under Domains key - ignoring\n"));
            continue;
        }

        //
        // Now open the subkey, fill and flush! These are all critical
        // operations; bail if necessary
        //


        NtStatus = pDomainObject->Open(wcszDomainRegName);
        CheckAndReturn(NtStatus);

        NtStatus = pDomainObject->Fill();
        CheckAndReturn(NtStatus);

        NtStatus = pDomainObject->Convert();
        CheckAndReturn(NtStatus);


        //
        //  The domain object takes ownership of the ds name
        //
        NtStatus = pDomainObject->Flush(DomainDsName);
        DomainDsName = NULL;
        CheckAndReturn(NtStatus);

        //
        // Transfer all the users; an error status will only be
        // returned if the SAM registry base is corrupt
        //
        NtStatus = ConvertUsers(*pDomainObject,
                                wcszDomainRegName);
        CheckAndReturn(NtStatus);

        //
        // Transfer all the groups; an error status will only be
        // returned if the  SAM registry base is corrupt
        //
        NtStatus = ConvertGroups(*pDomainObject,
                                 wcszDomainRegName);
        CheckAndReturn(NtStatus);

        //
        // Transfer all the aliases; an error status will only be
        // returned if the SAM registry base is corrupt
        //
        NtStatus = ConvertAliases(*pDomainObject,
                                  wcszDomainRegName);
        CheckAndReturn(NtStatus);

        //
        // Now, all the account counts should have been set
        // set in memory, so let's set them on the DS object
        // This is critical since it affects the domain object
        //
        NtStatus = pDomainObject->SetAccountCounts();
        CheckAndReturn(NtStatus);
    }

    return NtStatus;
}


NTSTATUS
ConvertUsers(
     CDomainObject &DomainObject,
     WCHAR*        wcszDomainRegName
     )
/*++

Routine Description:

    For a given domain, this routine searches for the "Names"
    key, and then converts all users found under that key.

Parameters:

    DomainObject      : the domain under which to search
    wcszDomainRegName : the name of said domain in the registry


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"ConvertUsers");

    NTSTATUS NtStatus = STATUS_SUCCESS;

    // Misc counters
    ULONG i;

    // This is domain query data to get the number of subkeys
    BYTE   DomainInfo[sizeof(KEY_FULL_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG  ulDomainInfoLength = 0;

    // This is data for enumerating the keys on the domain object
    BYTE   EnumInfo[sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG  ulEnumInfoLength = 0;

    // This is data for the "Users" key so we can enumerate it
    CRegistryObject UsersKey;
    BYTE            UsersKeyInfo[sizeof(KEY_FULL_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG           ulUsersKeyInfoLength = 0;
    WCHAR           wcszUsersKeyName[MAX_REGISTRY_NAME_LENGTH];

    DWORD           DatabaseUserCount = -1;
    DWORD           ActualUserCount = 0;

    BOOLEAN         fReadSuccess = FALSE;

    // This buffer will suffice most of the time
    WCHAR           StaticRdnBuffer[MAX_DOWN_LEVEL_NAME_LENGTH+1];
    WCHAR           *RdnBuffer = NULL;
    ULONG           Size;

    // Parameter checking
    ASSERT(wcszDomainRegName);

    // Stack clearing
    RtlZeroMemory(DomainInfo, sizeof(DomainInfo));
    RtlZeroMemory(EnumInfo, sizeof(EnumInfo));
    RtlZeroMemory(wcszUsersKeyName, sizeof(wcszUsersKeyName));

    //
    // Get some enumeration info from the server object
    // This will tell us how many sub keys there are
    //
    NtStatus = NtQueryKey(
                   DomainObject.GetHandle(),
                   KeyFullInformation,
                   &DomainInfo,
                   sizeof(DomainInfo),
                   &ulDomainInfoLength);

    CheckAndReturn(NtStatus);
    ASSERT(ulDomainInfoLength <= sizeof(DomainInfo));

    //
    // Iterate through - there should only be two and
    // we are only interested in the "Users" key
    //
    for ( i = 0; i < ((PKEY_FULL_INFORMATION)DomainInfo)->SubKeys; i++ ) {

        //
        // Get the name of the subkey
        //

        NtStatus = NtEnumerateKey(
                       DomainObject.GetHandle(),
                       i,
                       KeyBasicInformation,
                       EnumInfo,
                       sizeof(EnumInfo),
                       &ulEnumInfoLength);

        CheckAndReturn(NtStatus);
        ASSERT(ulEnumInfoLength <= sizeof(EnumInfo));

        if ( !wcsncmp(((PKEY_BASIC_INFORMATION)EnumInfo)->Name, L"Users", 5 ) ) {

            //
            // This is it!
            //

            //
            // Now open the subkey
            //

            wcszUsersKeyName[0] = L'\0';
            wcscat(wcszUsersKeyName, wcszDomainRegName);
            wcscat(wcszUsersKeyName, L"\\Users");

            NtStatus = UsersKey.Open(wcszUsersKeyName);
            CheckAndReturn(NtStatus);

            // Get the full information on that key
            NtStatus = NtQueryKey(
                           UsersKey.GetHandle(),
                           KeyFullInformation,
                           &UsersKeyInfo,
                           sizeof(UsersKeyInfo),
                           &ulUsersKeyInfoLength);

            CheckAndReturn(NtStatus);
            ASSERT(ulUsersKeyInfoLength <= sizeof(UsersKeyInfo));

            //
            // Now get the user count value that is mysteriously stored
            // here by SAM. The value is stored as the type! Use it for
            // comparison use only with the actual count at the end of
            // this function.
            //
            ULONG KeyValueLength = 0;
            LARGE_INTEGER IgnoreLastWriteTime;

            NtStatus = RtlpNtQueryValueKey(UsersKey.GetHandle(),
                                          &DatabaseUserCount,
                                          NULL,
                                          &KeyValueLength,
                                          &IgnoreLastWriteTime
                                       );
            CheckAndReturn(NtStatus);



            // Other keys are irrelevant right now
            break;

        }

    }

    //
    // Make sure we've found the "Users" key
    //
    if (0 == ulUsersKeyInfoLength) {
        //
        // Bad news! This is a corrupt SAM database
        //
        DebugError(("DSUPGRAD: No \"Users\" key found! Aborting ...\n"));
        CheckAndReturn(STATUS_INTERNAL_DB_ERROR);
    }

    //
    // Now, iterate on the "Users" key - and copy over all users
    //
    for ( i = 0; i < ((PKEY_FULL_INFORMATION)UsersKeyInfo)->SubKeys; i++ ) {

        BYTE  UserNameInfo[sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
        ULONG ulUserNameInfoLength = 0;

        WCHAR   wcszUserRegName[MAX_REGISTRY_NAME_LENGTH];
        PDSNAME UserDsName = NULL;

        UNICODE_STRING  Name;
        PDSNAME         DsObject = NULL;

        // Stack clearing
        RtlZeroMemory(UserNameInfo, sizeof(UserNameInfo));
        RtlZeroMemory(wcszUserRegName, sizeof(wcszUserRegName));

        //
        // Get the name of the subkey
        //

        NtStatus = NtEnumerateKey(
                       UsersKey.GetHandle(),
                       i,
                       KeyBasicInformation,
                       UserNameInfo,
                       sizeof(UserNameInfo),
                       &ulUserNameInfoLength);

        CheckAndReturn(NtStatus);
        ASSERT(ulUserNameInfoLength <= sizeof(UserNameInfo));

        if ( !wcsncmp(((PKEY_BASIC_INFORMATION)UserNameInfo)->Name, L"Names", 5 )) {

            //
            // This is not a user! Ignore
            //

            continue;
        }

        //
        // Start a new stack frame to make use of destructors
        //
        {

            CUserObject UserObject(RootDomainObject, DomainObject);
            // The name given by NtEnumerateKey is not NULL-terminating

            WCHAR wcszUserName[MAX_REGISTRY_KEY_NAME_LENGTH];
            RtlZeroMemory(wcszUserName, sizeof(wcszUserName));

            wcsncpy(wcszUserName, ((PKEY_BASIC_INFORMATION)UserNameInfo)->Name,
                    ((PKEY_BASIC_INFORMATION)UserNameInfo)->NameLength/sizeof(WCHAR));
            wcszUserName[((PKEY_BASIC_INFORMATION)UserNameInfo)->NameLength/sizeof(WCHAR)] = L'\0';

            //
            // Construct the full registry path
            //

            wcszUserRegName[0] = L'\0';
            wcscat(wcszUserRegName, wcszDomainRegName);
            wcscat(wcszUserRegName, L"\\Users\\");
            wcscat(wcszUserRegName, wcszUserName);


            //
            // At this point, we are open to errors from either reading the
            // registry or writing to the ds.  If any event we will want
            // to continue with the next user.
            //
            __try
            {

                //
                // Open and extract data
                //

                NtStatus = UserObject.Open(wcszUserRegName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugWarning(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                NtStatus = UserObject.Fill();
                if (!NT_SUCCESS(NtStatus)) {
                    DebugWarning(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                fReadSuccess = TRUE;

                //
                // Find a unique RDN.
                //
                RdnBuffer = StaticRdnBuffer;
                Size      = sizeof(StaticRdnBuffer);
                NtStatus = GetRdnForSamObject(UserObject.GetAccountName(),
                                              SampUserObjectType,
                                              RdnBuffer,
                                              &Size);
                if (STATUS_BUFFER_TOO_SMALL == NtStatus ) {
                    RdnBuffer = (WCHAR*) RtlAllocateHeap(RtlProcessHeap(),
                                                         0,
                                                         Size);
                    if (!RdnBuffer) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        __leave;
                    }

                    NtStatus = GetRdnForSamObject(UserObject.GetAccountName(),
                                                  SampUserObjectType,
                                                  RdnBuffer,
                                                  &Size);

                }

                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: Failed to find unique rdn for %ws, error = 0x%x\n",
                               UserObject.GetAccountName(), NtStatus));
                    __leave;
                }

                //
                // Call the dslayer to construct the name
                //
                DWORD   AccountControl = UserObject.GetAccountControl();
                UNICODE_STRING uAccountName;

                RtlInitUnicodeString(&uAccountName, RdnBuffer);
                NtStatus = SampDsCreateAccountObjectDsName(DomainObject.GetDsName(),
                                                           NULL,        // Domain SID
                                                           SampUserObjectType,
                                                           &uAccountName,
                                                           NULL,        // User RID
                                                           &AccountControl,
                                                           DomainObject.AmIBuiltinDomain() != 0,
                                                           &UserDsName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }



                //
                // Transfer
                //

                NtStatus = UserObject.Convert();
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }
               
                // 
                // Upgrade UserObject's UserParameters Attribute 
                // the error is ignoreable, but we would like to log the error in System Event Log
                // 
                NtStatus = UserObject.UpgradeUserParms();
                
                if (!NT_SUCCESS(NtStatus)) {
                    
                    UNICODE_STRING Name;
                    PUNICODE_STRING NameArray[1];
                
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    
                    NameArray[0] = &Name;
                    RtlInitUnicodeString(&Name, UserObject.GetAccountName());
                    
                    SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                      0,                    // Category 
                                      SAMMSG_ACCEPTABLE_ERROR_UPGRADE_USER,
                                      NULL,                 // User Sid 
                                      1,                    // Num of String 
                                      sizeof(NTSTATUS),     // Data Size
                                      NameArray,            // String Array, contain User Name
                                      (PVOID) &NtStatus     // Data
                                      ); 
                }
                
                //
                //  The user object takes ownership of the ds name
                //
                NtStatus = UserObject.Flush(UserDsName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }
                UserDsName = NULL;

                //
                // That's it - fall through to the finally
                //

            }
            __finally
            {
                //
                //  If an error occured, log that this user was unsuccessfully
                //  added.
                //
                if (STATUS_USER_EXISTS == NtStatus) {
                    //
                    // We have a duplicate name
                    //
                    UNICODE_STRING Name;
                    PUNICODE_STRING  NameArray[1];

                    NameArray[0] = &Name;
                    RtlInitUnicodeString(&Name, UserObject.GetAccountName());

                    SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                      0,                   // Category
                                      SAMMSG_DUPLICATE_ACCOUNT,
                                      NULL,                // User Sid
                                      1,                   // Num strings
                                      sizeof(NTSTATUS),    // Data size
                                      NameArray,           // String array
                                      (PVOID)&NtStatus     // Data
                                      );

                    NtStatus = STATUS_SUCCESS;

                } else if ( !NT_SUCCESS( NtStatus ) 
                         && !SampIsNtStatusResourceError( NtStatus ) ) {

                    if (fReadSuccess) {
                        //
                        // Log an error with the user's name
                        //
                        UNICODE_STRING Name;
                        PUNICODE_STRING  NameArray[1];

                        NameArray[0] = &Name;
                        RtlInitUnicodeString(&Name, UserObject.GetAccountName());
                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,                  // Category
                                          SAMMSG_USER_NOT_UPGRADED,
                                          NULL,               // User Sid
                                          1,                  // Num strings
                                          sizeof(NTSTATUS),   // Data size
                                          NameArray,          // String array
                                          (PVOID)&NtStatus    // Data
                                          );
                    } else {
                        //
                        // We didn't even read the object
                        //

                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,                  // Category
                                          SAMMSG_UNKNOWN_USER_NOT_UPGRADED,
                                          NULL,               // User Sid
                                          0,                  // Num strings
                                          sizeof(NTSTATUS),   // Data size
                                          NULL,               // String array
                                          (PVOID)&NtStatus    // Data
                                          );
                    }

                    NtStatus = STATUS_SUCCESS;

                } else if ( NT_SUCCESS( NtStatus ) ) {
                    // The user was transferred correctly
                    ActualUserCount++;
                }

                fReadSuccess = FALSE;

                if ( RdnBuffer && RdnBuffer != StaticRdnBuffer ) {
                    RtlFreeHeap(RtlProcessHeap(), 0, RdnBuffer);
                    RdnBuffer = NULL;
                }

            }  // finally

            if ( !NT_SUCCESS( NtStatus ) )
            {
                break;
            }
        }
    }

    if (NT_SUCCESS(NtStatus)) {
        if (ActualUserCount != DatabaseUserCount) {
            DebugInfo(("DSUPGRAD: User counts differ\n"));
        }
        DomainObject.SetUserCount(ActualUserCount);
    }

    return NtStatus;

}

NTSTATUS
ConvertGroups(
     CDomainObject &DomainObject,
     WCHAR*        wcszDomainRegName
     )
/*++

Routine Description:

    For a given domain, this routine searches for the "Groups"
    key, and then converts all groups found under that key. For
    each group, all accounts in that group are transferred too.

Parameters:

    DomainObject      : the domain under which to search
    wcszDomainRegName : the name of said domain in the registry


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"ConvertGroups");

    NTSTATUS NtStatus;

    // Misc counters
    ULONG i;

    // This is domain query data to get the number of subkeys
    BYTE   DomainInfo[sizeof(KEY_FULL_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG  ulDomainInfoLength = 0;

    // This is data for enumerating the keys on the domain object
    BYTE   EnumInfo[sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG  ulEnumInfoLength = 0;

    // This is data for the "Groups" key so we can enumerate it
    CRegistryObject GroupsKey;
    BYTE            GroupsKeyInfo[sizeof(KEY_FULL_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG           ulGroupsKeyInfoLength = 0;
    WCHAR           wcszGroupsKey[MAX_REGISTRY_NAME_LENGTH];

    DWORD           DatabaseGroupCount = -1;
    DWORD           ActualGroupCount = 0;
    BOOLEAN         fReadSuccess = FALSE;


    // This buffer will suffice most of the time
    WCHAR           StaticRdnBuffer[MAX_DOWN_LEVEL_NAME_LENGTH+1];
    WCHAR           *RdnBuffer = NULL;
    ULONG           Size;

    // Parameter checking
    ASSERT(wcszDomainRegName);

    // Stack clearing
    RtlZeroMemory(DomainInfo, sizeof(DomainInfo));
    RtlZeroMemory(EnumInfo, sizeof(EnumInfo));
    RtlZeroMemory(GroupsKeyInfo, sizeof(GroupsKeyInfo));
    RtlZeroMemory(wcszGroupsKey, sizeof(wcszGroupsKey));


    //
    // Get some enumeration info from the server object
    // This will tell us how many sub keys there are
    //
    NtStatus = NtQueryKey(
                   DomainObject.GetHandle(),
                   KeyFullInformation,
                   &DomainInfo,
                   sizeof(DomainInfo),
                   &ulDomainInfoLength);

    CheckAndReturn(NtStatus);
    ASSERT(ulDomainInfoLength <= sizeof(DomainInfo));

    //
    // Iterate through - there should only be two and
    // we are only interested in the "Groups" key
    //
    for ( i = 0; i < ((PKEY_FULL_INFORMATION)DomainInfo)->SubKeys; i++ ) {

        //
        // Get the name of the subkey
        //

        NtStatus = NtEnumerateKey(
                       DomainObject.GetHandle(),
                       i,
                       KeyBasicInformation,
                       EnumInfo,
                       sizeof(EnumInfo),
                       &ulEnumInfoLength);

        CheckAndReturn(NtStatus);
        ASSERT(ulEnumInfoLength <= sizeof(EnumInfo));

        if ( !wcsncmp(((PKEY_BASIC_INFORMATION)EnumInfo)->Name, L"Groups", 6 ) ) {

            //
            // This is it!
            //

            //
            // Now open the subkey
            //

            wcszGroupsKey[0] = L'\0';
            wcscat(wcszGroupsKey, wcszDomainRegName);
            wcscat(wcszGroupsKey, L"\\Groups");

            NtStatus = GroupsKey.Open(wcszGroupsKey);
            CheckAndReturn(NtStatus);

            // Get the full information on that key
            NtStatus = NtQueryKey(
                           GroupsKey.GetHandle(),
                           KeyFullInformation,
                           &GroupsKeyInfo,
                           sizeof(GroupsKeyInfo),
                           &ulGroupsKeyInfoLength);

            CheckAndReturn(NtStatus);
            ASSERT(ulGroupsKeyInfoLength <= sizeof(GroupsKeyInfo));

            //
            // Now get the group count value that is mysteriously stored
            // here by SAM. The value is stored as the type! Use it for
            // comparison use only with the actual count at the end of
            // this function.
            //

            //
            ULONG ulGroupCount = 0;
            LARGE_INTEGER IgnoreLastWriteTime;
            ULONG         KeyValueLength = 0;

            NtStatus = RtlpNtQueryValueKey(GroupsKey.GetHandle(),
                                          &DatabaseGroupCount,
                                          NULL,
                                          &KeyValueLength,
                                          &IgnoreLastWriteTime
                                       );
            CheckAndReturn(NtStatus);

            // Other keys are irrelevant right now
            break;

        }

    }

    //
    // Make sure we have found the Groups key
    //
    if (0 == ulGroupsKeyInfoLength) {
        //
        // Bad news! This is a corrupt SAM database
        //
        DebugError(("DSUPGRAD: No \"Groups\" key found! Aborting ...\n"));
        CheckAndReturn(STATUS_INTERNAL_DB_ERROR);
    }

    //
    // Now, iterate on the "Groups" key - and copy over all groups
    //
    for ( i = 0; i < ((PKEY_FULL_INFORMATION)GroupsKeyInfo)->SubKeys; i++ ) {

        BYTE  GroupNameInfo[sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_NAME_LENGTH];
        ULONG ulGroupNameInfoLength = 0;

        WCHAR   wcszGroupRegName[MAX_REGISTRY_NAME_LENGTH];
        PDSNAME GroupDsName = NULL;


        // Stack clearing
        RtlZeroMemory(GroupNameInfo, sizeof(GroupNameInfo));
        RtlZeroMemory(wcszGroupRegName, sizeof(wcszGroupRegName));

        //
        // Get the name of the subkey
        //

        NtStatus = NtEnumerateKey(
                       GroupsKey.GetHandle(),
                       i,
                       KeyBasicInformation,
                       GroupNameInfo,
                       sizeof(GroupNameInfo),
                       &ulGroupNameInfoLength);

        CheckAndReturn(NtStatus);
        ASSERT(ulGroupNameInfoLength < sizeof(GroupNameInfo));

        if ( !wcsncmp(((PKEY_BASIC_INFORMATION)GroupNameInfo)->Name, L"Names", 5 )) {

            //
            // This is not a group! Ignore
            //

            continue;
        }


        //
        // Start a new stack frame to make use of destructors
        //
        {
            CGroupObject GroupObject(RootDomainObject, DomainObject);

            // The name given by NtEnumerateKey is not always NULL-terminating!

            WCHAR wcszGroupName[MAX_REGISTRY_NAME_LENGTH];
            RtlZeroMemory(wcszGroupName, sizeof(wcszGroupName));

            wcsncpy(wcszGroupName, ((PKEY_BASIC_INFORMATION)GroupNameInfo)->Name,
                    ((PKEY_BASIC_INFORMATION)GroupNameInfo)->NameLength/sizeof(WCHAR));
            wcszGroupName[((PKEY_BASIC_INFORMATION)GroupNameInfo)->NameLength/sizeof(WCHAR)] = L'\0';

            //
            // Construct the full registry path
            //

            wcszGroupRegName[0] = L'\0';
            wcscat(wcszGroupRegName, wcszDomainRegName);
            wcscat(wcszGroupRegName, L"\\Groups\\");
            wcscat(wcszGroupRegName, wcszGroupName);


            //
            // At this point, we are open to errors from either reading the
            // registry or writing to the ds.  If any event we will want
            // to continue with the next group.
            //
            __try
            {

                //
                // Open and extract data
                //

                NtStatus = GroupObject.Open(wcszGroupRegName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugWarning(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                NtStatus = GroupObject.Fill();
                if (!NT_SUCCESS(NtStatus)) {
                    DebugWarning(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                fReadSuccess = TRUE;


                if (  ( DOMAIN_GROUP_RID_USERS == GroupObject.GetRid() )
                   && ( !SampNT4UpgradeInProgress ) )
                {
                    //
                    // This is the "none" group - don't migrate it
                    //
                    NtStatus = STATUS_SUCCESS;
                    __leave;
                }

                //
                // Find a unique RDN.
                //
                RdnBuffer = StaticRdnBuffer;
                Size      = sizeof(StaticRdnBuffer);
                NtStatus = GetRdnForSamObject(GroupObject.GetAccountName(),
                                              SampGroupObjectType,
                                              RdnBuffer,
                                              &Size);
                if (STATUS_BUFFER_TOO_SMALL == NtStatus ) {
                    RdnBuffer = (WCHAR*) RtlAllocateHeap(RtlProcessHeap(),
                                                         0,
                                                         Size);
                    if (!RdnBuffer) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        __leave;
                    }

                    NtStatus = GetRdnForSamObject(GroupObject.GetAccountName(),
                                                  SampGroupObjectType,
                                                  RdnBuffer,
                                                  &Size);

                }

                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: Failed to find unique rdn for %ws, error = 0x%x\n",
                               GroupObject.GetAccountName(), NtStatus));
                    __leave;
                }

                //
                // Call the dslayer to construct the name
                //
                UNICODE_STRING uAccountName;
                ULONG          AccountRid = GroupObject.GetRid();
                RtlInitUnicodeString(&uAccountName, RdnBuffer);
                NtStatus = SampDsCreateAccountObjectDsName(DomainObject.GetDsName(),
                                                           DomainObject.GetSid(),   // Domain Sid
                                                           SampGroupObjectType,
                                                           &uAccountName,
                                                           NULL,         // Account RID
                                                           NULL,  // Account Control field,
                                                           DomainObject.AmIBuiltinDomain() != 0,
                                                           &GroupDsName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }



                //
                // Transfer!
                //

                NtStatus = GroupObject.Convert();
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                //
                //  The group object takes ownership of the ds name
                //
                NtStatus = GroupObject.Flush(GroupDsName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }
                GroupDsName = NULL;

                //
                // Now add the members
                //
                NtStatus = GroupObject.ConvertMembers();
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                //
                // That's it - fall through to the finally
                //
            }
            __finally
            {

                //
                //  If an error occured, log that this Group was unsuccessfully
                //  added.
                //
                if (STATUS_GROUP_EXISTS == NtStatus) {
                    //
                    // We have a duplicate name
                    //
                    UNICODE_STRING Name;
                    PUNICODE_STRING  NameArray[1];

                    NameArray[0] = &Name;
                    RtlInitUnicodeString(&Name, GroupObject.GetAccountName());

                    SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                      0,                 // Category
                                      SAMMSG_DUPLICATE_ACCOUNT,
                                      NULL,              // Group Sid
                                      1,                 // Num strings
                                      sizeof(NTSTATUS),  // Data size
                                      NameArray,         // String array
                                      (PVOID)&NtStatus   // Data
                                      );

                    NtStatus = STATUS_SUCCESS;

                } else if (  !NT_SUCCESS( NtStatus )
                          && !SampIsNtStatusResourceError( NtStatus ) ) {

                    if (fReadSuccess) {
                        //
                        // Log an error with the Group's name
                        //
                        UNICODE_STRING Name;
                        PUNICODE_STRING  NameArray[1];

                        NameArray[0] = &Name;
                        RtlInitUnicodeString(&Name, GroupObject.GetAccountName());
                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,                        // Category
                                          SAMMSG_GROUP_NOT_UPGRADED,
                                          NULL,                     // Group Sid
                                          1,                        // Num strings
                                          sizeof(NTSTATUS),         // Data size
                                          NameArray,                // String array
                                          (PVOID)&NtStatus          // Data
                                          );
                    } else {
                        //
                        // We didn't even read the object
                        //

                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,  // Category
                                          SAMMSG_UNKNOWN_GROUP_NOT_UPGRADED,
                                          NULL, // Group Sid
                                          0, // Num strings
                                          sizeof(NTSTATUS), // Data size
                                          NULL, // String array
                                          (PVOID)&NtStatus // Data
                                          );
                    }

                    NtStatus = STATUS_SUCCESS;

                } else if ( NT_SUCCESS( NtStatus ) ) {
                    // The Group was transferred correctly
                    ActualGroupCount++;
                }

                fReadSuccess = FALSE;

                if (RdnBuffer && RdnBuffer != StaticRdnBuffer) {
                    RtlFreeHeap(RtlProcessHeap(), 0, RdnBuffer);
                    RdnBuffer = NULL;
                }

            } // finally

            if ( !NT_SUCCESS( NtStatus ) )
            {
                break;
            }
        }
    }

    if (NT_SUCCESS(NtStatus)) {
        //
        // The -1 on the Database group count accounts for the ommission
        // of the "None" group
        //
        if (ActualGroupCount != (DatabaseGroupCount-1)) {
            DebugInfo(("DSUPGRAD: Group counts differ\n"));
        }
        DomainObject.SetGroupCount(ActualGroupCount);
    }

    return NtStatus;

}

NTSTATUS
ConvertAliases(
     CDomainObject &DomainObject,
     WCHAR*        wcszDomainRegName
     )
/*++

Routine Description:

    For a given domain, this routine searches for the "Aliases"
    key, and then converts all aliases found under that key. For
    each alias, all accounts in that group are transferred too.

Parameters:

    DomainObject      : the domain under which to search
    wcszDomainRegName : the name of said domain in the registry


Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    FTRACE(L"ConvertAliases");

    NTSTATUS NtStatus;

    // Misc counters
    ULONG i;

    // This is domain query data to get the number of subkeys
    BYTE   DomainInfo[sizeof(KEY_FULL_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG  ulDomainInfoLength = 0;

    // This is data for enumerating the keys on the domain object
    BYTE   EnumInfo[sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG  ulEnumInfoLength = 0;

    // This is data for the "Aliases" key so we can enumerate it
    CRegistryObject AliasesKey;
    BYTE            AliasesKeyInfo[sizeof(KEY_FULL_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_KEY_NAME_LENGTH];
    ULONG           ulAliasesKeyInfoLength = 0;
    WCHAR           wcszAliasesKey[MAX_REGISTRY_NAME_LENGTH];

    DWORD           DatabaseAliasCount = -1;
    DWORD           ActualAliasCount = 0;
    BOOLEAN         fReadSuccess = TRUE;


    // This buffer will suffice most of the time
    WCHAR           StaticRdnBuffer[MAX_DOWN_LEVEL_NAME_LENGTH+1];
    WCHAR           *RdnBuffer = NULL;
    ULONG           Size;

    // Parameter checking
    ASSERT(wcszDomainRegName);

    // Stack clearing
    RtlZeroMemory(DomainInfo, sizeof(DomainInfo));
    RtlZeroMemory(EnumInfo, sizeof(EnumInfo));
    RtlZeroMemory(AliasesKeyInfo, sizeof(AliasesKeyInfo));
    RtlZeroMemory(wcszAliasesKey, sizeof(wcszAliasesKey));

    //
    // Get some enumeration info from the server object
    // This will tell us how many sub keys there are
    //
    NtStatus = NtQueryKey(
                   DomainObject.GetHandle(),
                   KeyFullInformation,
                   &DomainInfo,
                   sizeof(DomainInfo),
                   &ulDomainInfoLength);

    CheckAndReturn(NtStatus);
    ASSERT(ulDomainInfoLength <= sizeof(DomainInfo));

    //
    // Iterate through - there should only be two and
    // we are only interested in the "Aliases" key
    //
    for ( i = 0; i < ((PKEY_FULL_INFORMATION)DomainInfo)->SubKeys; i++ ) {

        //
        // Get the name of the subkey
        //

        NtStatus = NtEnumerateKey(
                       DomainObject.GetHandle(),
                       i,
                       KeyBasicInformation,
                       EnumInfo,
                       sizeof(EnumInfo),
                       &ulEnumInfoLength);

        CheckAndReturn(NtStatus);
        ASSERT(ulEnumInfoLength < sizeof(EnumInfo));


        if ( !wcsncmp(((PKEY_BASIC_INFORMATION)EnumInfo)->Name, L"Aliases", 7 ) ) {

            //
            // This is it!
            //

            //
            // Now open the subkey
            //

            wcszAliasesKey[0] = L'\0';
            wcscat(wcszAliasesKey, wcszDomainRegName);
            wcscat(wcszAliasesKey, L"\\Aliases");

            NtStatus = AliasesKey.Open(wcszAliasesKey);
            CheckAndReturn(NtStatus);

            // Get the full information on that key
            NtStatus = NtQueryKey(
                           AliasesKey.GetHandle(),
                           KeyFullInformation,
                           &AliasesKeyInfo,
                           sizeof(AliasesKeyInfo),
                           &ulAliasesKeyInfoLength);

            CheckAndReturn(NtStatus);
            ASSERT(ulAliasesKeyInfoLength <= sizeof(AliasesKeyInfo));

            //
            // Now get the alias count value that is mysteriously stored
            // here by SAM. The value is stored as the type! Use it for
            // comparison use only with the actual count at the end of
            // this function.
            //

            ULONG KeyValueLength = 0;
            LARGE_INTEGER IgnoreLastWriteTime;

            NtStatus = RtlpNtQueryValueKey(AliasesKey.GetHandle(),
                                          &DatabaseAliasCount,
                                          NULL,
                                          &KeyValueLength,
                                          &IgnoreLastWriteTime
                                       );
            CheckAndReturn(NtStatus);

            // Other keys are irrelevant right now
            break;

        }

    }
    //
    // Make sure we have found the Domains key
    //
    if (0 == ulAliasesKeyInfoLength) {
        //
        // Bad news! This is a corrupt SAM database
        //
        DebugError(("DSUPGRAD: No \"Aliases\" key found! Aborting ...\n"));
        CheckAndReturn(STATUS_INTERNAL_DB_ERROR);
    }

    //
    // Now, iterate on the "Aliases" key - and copy over all groups
    //
    for ( i = 0; i < ((PKEY_FULL_INFORMATION)AliasesKeyInfo)->SubKeys; i++ ) {

        BYTE  AliasNameInfo[sizeof(KEY_BASIC_INFORMATION) + sizeof(WCHAR)*MAX_REGISTRY_NAME_LENGTH];
        ULONG ulAliasNameInfoLength;

        WCHAR   wcszAliasRegName[MAX_REGISTRY_NAME_LENGTH];
        PDSNAME AliasDsName = NULL;


        // Stack clearing
        RtlZeroMemory(AliasNameInfo, sizeof(AliasNameInfo));
        RtlZeroMemory(wcszAliasRegName, sizeof(wcszAliasRegName));

        //
        // Get the name of the subkey
        //

        NtStatus = NtEnumerateKey(
                       AliasesKey.GetHandle(),
                       i,
                       KeyBasicInformation,
                       AliasNameInfo,
                       sizeof(AliasNameInfo),
                       &ulAliasNameInfoLength);

        CheckAndReturn(NtStatus);
        ASSERT(ulAliasNameInfoLength <= sizeof(AliasNameInfo));

        if ( !wcsncmp(((PKEY_BASIC_INFORMATION)AliasNameInfo)->Name, L"Names", 5 )
          || !wcsncmp(((PKEY_BASIC_INFORMATION)AliasNameInfo)->Name, L"Members", 7 )) {

            //
            // This is not a alias! Ignore
            //

            continue;
        }


        //
        // Start a new stack frame to make use of destructors
        //
        {

            CAliasObject AliasObject(RootDomainObject, DomainObject);

            // The name given by NtEnumerateKey is not NULL-terminating
            WCHAR wcszAliasName[MAX_REGISTRY_NAME_LENGTH];
            RtlZeroMemory(wcszAliasName, sizeof(wcszAliasName));

            wcsncpy(wcszAliasName, ((PKEY_BASIC_INFORMATION)AliasNameInfo)->Name,
                    ((PKEY_BASIC_INFORMATION)AliasNameInfo)->NameLength/sizeof(WCHAR));
            wcszAliasName[((PKEY_BASIC_INFORMATION)AliasNameInfo)->NameLength/sizeof(WCHAR)] = L'\0';

            //
            // Construct the full registry path
            //

            wcszAliasRegName[0] = L'\0';
            wcscat(wcszAliasRegName, wcszDomainRegName);
            wcscat(wcszAliasRegName, L"\\Aliases\\");
            wcscat(wcszAliasRegName, wcszAliasName);


            //
            // At this point, we are open to errors from either reading the
            // registry or writing to the ds.  If any event we will want
            // to continue with the next group.
            //
            __try
            {

                //
                // Open and extract data
                //

                NtStatus = AliasObject.Open(wcszAliasRegName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugWarning(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                NtStatus = AliasObject.Fill();
                if (!NT_SUCCESS(NtStatus)) {
                    DebugWarning(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                fReadSuccess = TRUE;

                if ( DOMAIN_ALIAS_RID_POWER_USERS ==
                     AliasObject.GetRid() )
                {
                    //
                    // This group should not exist on a domain contoller
                    //
                    NtStatus = STATUS_SUCCESS;
                    __leave;
                }

                //
                // Find a unique RDN.
                //
                RdnBuffer = StaticRdnBuffer;
                Size      = sizeof(StaticRdnBuffer);
                NtStatus = GetRdnForSamObject(AliasObject.GetAccountName(),
                                              SampAliasObjectType,
                                              RdnBuffer,
                                              &Size);
                if (STATUS_BUFFER_TOO_SMALL == NtStatus ) {
                    RdnBuffer = (WCHAR*) RtlAllocateHeap(RtlProcessHeap(),
                                                         0,
                                                         Size);
                    if (!RdnBuffer) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        __leave;
                    }

                    NtStatus = GetRdnForSamObject(AliasObject.GetAccountName(),
                                                  SampUserObjectType,
                                                  RdnBuffer,
                                                  &Size);

                }

                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: Failed to find unique rdn for %ws, error = 0x%x\n",
                               AliasObject.GetAccountName(), NtStatus));
                    __leave;
                }

                //
                // Call the dslayer to construct the name
                //
                UNICODE_STRING uAccountName;
                ULONG          AccountRid = AliasObject.GetRid();
                RtlInitUnicodeString(&uAccountName, RdnBuffer);
                NtStatus = SampDsCreateAccountObjectDsName(DomainObject.GetDsName(),
                                                           DomainObject.GetSid(),   // Domain Sid
                                                           SampAliasObjectType,
                                                           &uAccountName,
                                                           NULL,             // Account Rid
                                                           NULL,  // Account Control field,
                                                           DomainObject.AmIBuiltinDomain() != 0,
                                                           &AliasDsName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }



                //
                // Transfer!
                //

                NtStatus = AliasObject.Convert();
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                //
                //  The alias object takes ownership of the ds name
                //
                NtStatus = AliasObject.Flush(AliasDsName);
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }
                AliasDsName = NULL;

                //
                // Now add the members
                //
                NtStatus = AliasObject.ConvertMembers();
                if (!NT_SUCCESS(NtStatus)) {
                    DebugError(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
                    __leave;
                }

                //
                // That's it - fall through to the finally
                //
            }
            __finally
            {

                //
                //  If an error occured, log that this Alias was unsuccessfully
                //  added.
                //
                if (STATUS_ALIAS_EXISTS == NtStatus) {
                    //
                    // We have a duplicate name
                    //
                    UNICODE_STRING Name;
                    PUNICODE_STRING  NameArray[1];

                    NameArray[0] = &Name;
                    RtlInitUnicodeString(&Name, AliasObject.GetAccountName());

                    SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                      0,                 // Category
                                      SAMMSG_DUPLICATE_ACCOUNT,
                                      NULL,              // Sid
                                      1,                 // Num strings
                                      sizeof(NTSTATUS),  // Data size
                                      NameArray,         // String array
                                      (PVOID)&NtStatus   // Data
                                      );

                    NtStatus = STATUS_SUCCESS;

                } else if ( !NT_SUCCESS( NtStatus )
                         && !SampIsNtStatusResourceError(NtStatus) ) {

                    if (fReadSuccess) {
                        //
                        // Log an error with the Alias's name
                        //
                        UNICODE_STRING Name;
                        PUNICODE_STRING  NameArray[1];

                        NameArray[0] = &Name;
                        RtlInitUnicodeString(&Name, AliasObject.GetAccountName());
                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,                   // Category
                                          SAMMSG_ALIAS_NOT_UPGRADED,
                                          NULL,                //  Sid
                                          1,                   // Num strings
                                          sizeof(NTSTATUS),    // Data size
                                          NameArray,           // String array
                                          (PVOID)&NtStatus     // Data
                                          );
                    } else {
                        //
                        // We didn't even read the object
                        //

                        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                                          0,                    // Category
                                          SAMMSG_UNKNOWN_ALIAS_NOT_UPGRADED,
                                          NULL,                 //  Sid
                                          0,                    // Num strings
                                          sizeof(NTSTATUS),     // Data size
                                          NULL,                 // String array
                                          (PVOID)&NtStatus      // Data
                                          );
                    }

                    NtStatus = STATUS_SUCCESS;

                } else if ( NT_SUCCESS( NtStatus ) ) {
                    // The Alias was transferred correctly
                    ActualAliasCount++;
                }

                fReadSuccess = FALSE;

                if (RdnBuffer && RdnBuffer != StaticRdnBuffer) {
                    RtlFreeHeap(RtlProcessHeap(), 0, RdnBuffer);
                    RdnBuffer = NULL;
                }

            } // finally

            if ( !NT_SUCCESS( NtStatus ) )
            {
                break;
            }
        }
    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // The minus one is for the power users alias omission
        //
        if ( ActualAliasCount != (DatabaseAliasCount-1) ) {
            DebugInfo(("DSUPGRAD: Alias counts differ\n"));
        }
        DomainObject.SetAliasCount(ActualAliasCount);
    }

    return NtStatus;

}


NTSTATUS
CheckForNonExistence(
    WCHAR* AccountName,
    SAMP_OBJECT_TYPE SampObjectType
    )
/*++

Routine Description:

    Given an account name and type, this routine checks to see
    if an account with an equivalent name exists. It also checks
    to see if the account name passed in satisfies all DS constraints


    It is possible that two given SAM user account id's
    map to the same string in the DS/Jet internals.  Check
    to make sure that the account name does not already exist.

Parameters:

    AccountName    : the name of the account
    SampObjectType : the type of the account

Return Values:

    STATUS_SUCCESS if the name does not exist
    STATUS_USER_EXISTS, STATUS_GROUP_EXISTS, STATUS_ALIAS_EXISTS
    Otherwise, ds related error.

--*/
{
    NTSTATUS       NtStatus;
    UNICODE_STRING Name;
    PDSNAME        DsObject = NULL;
    ATTRVAL        AttValCN;
    BOOL           fConstraintCheckPassed = FALSE;

    ASSERT(AccountName);

    RtlInitUnicodeString(&Name, AccountName);


    //
    // The intent of the call to SampDsLookupObjectByNameEx is to determine
    // if we can use the samaccountname of the account as the RDN of the object
    // In most cases this is possible, however the DS uses a different
    // string comparison routine than registry SAM. So there are some cases
    // where two strings are unique for SAM, but not for the DS and since all
    // user objects are placed in the same container, the second object can't
    // use the samaccountname as the RDN since it will conflict.  A common
    // example of these types of names are names with the character 'o' and
    // o<umlate>.  So "foo" and "foo<umlate>", while different sam account names
    // are the same string to the DS.
    //
    
    // 
    // SampDsLookupObjectByNameEx can be controlled to handle this scenario.
    // The flag SAM_UNICODE_STRING_MANUAL_COMPARISON can be passed in to tell
    // the routine to walk through all return values (from a search based
    // on samaccountname) and "manually" compare (do a unicode string compare)
    // to see if the accounts returned have identical samaccountnames or simply
    // samaccountnames that the DS thinks are the same.  For the purposes of 
    // the current routine, we don't want this behavoir, so we don't pass in 
    // the flag.  We want to find all the accounts with samaccountnames that
    // the DS thinks are the same so this routine knows not to use it.
    //

    //
    // Next, SampDsLookupObjectByNameEx will also event log when duplicate
    // accounts are found; we don't want this behavoir either since the message
    // tells the admin to delete the duplicate accounts.  Hence we do pass in
    // in the SAM_UPGRADE_FROM_REGISTRY flag which tells 
    // SampDsLookupObjectByNameEx to not log events when duplicate accounts
    // are found.
    //

    //
    // If a name is found to exist, a unique RDN will be generated.  Its
    // uniqueness is gaureenteed by searching for it to make sure it doesn't
    // already exist and by adding a monotonically increased integer to the end.
    //
    // For example, consider the case where 3 names map to the same name for the
    // DS.  The first once will get its samaccountname as the RDN, the second
    // will get the $AccountNameConflict0, and the third will get
    // $AccountNameConflict1
    //

    NtStatus = SampDsLookupObjectByNameEx(RootDomainObject.GetDsName(),
                                          SampObjectType,
                                          &Name,
                                          &DsObject,
                                          SAM_UPGRADE_FROM_REGISTRY );

    //
    // Use DS constraint check to see if it can be used as a CN
    // SampDsLookupObjectByName would have created a thread state
    // the DsCheckConstraint can use.
    //
    
    AttValCN.valLen = Name.Length;
    AttValCN.pVal = (PUCHAR) Name.Buffer;

    fConstraintCheckPassed = DsCheckConstraint(
                                   ATT_COMMON_NAME,
                                   &AttValCN,
                                   TRUE      // also check RDN 
                                   );

    SampMaybeEndDsTransaction(TransactionCommit);

    if (( NT_SUCCESS(NtStatus) ) || (!fConstraintCheckPassed))
    {
        if (NULL!=DsObject)
        {
            MIDL_user_free(DsObject);
        }

        switch (SampObjectType)
        {

            case SampUserObjectType:
                NtStatus = STATUS_USER_EXISTS;
                break;

            case SampGroupObjectType:
                NtStatus = STATUS_GROUP_EXISTS;
                break;

            case SampAliasObjectType:
                NtStatus = STATUS_ALIAS_EXISTS;
                break;

            default:
                ASSERT(FALSE);
                NtStatus = STATUS_USER_EXISTS;
                break;

        }
        DebugWarning(("DSUPGRAD: skipping duplicate name \"%ws\"\n", AccountName));

    }
    else if ( STATUS_NOT_FOUND == NtStatus )
    {
        // Don't have this name yet
        NtStatus = STATUS_SUCCESS;
        NULL;
    }
    else
    {
        // Error case.
        DebugWarning(("DSUPGRAD: %s, %d, error = 0x%x\n", __FILE__, __LINE__, NtStatus));
    }

    return NtStatus;

}


WCHAR*
GetNameConflictString(
    ULONG Count
    )

/*++

Routine Description:

    This routine loads the resource table from samsrv.dll to get the
    string used for name conflicts.  If any of these operations fail,
    a harded value is used instead.


Parameters:

   Count, a 32 bit integer

Return Values:

   A unique rdn or null if memory allocation fails

--*/
{

    WCHAR   ConflictCountString[10];  // holds a 32 bit number
    WCHAR   *CountArray[2];
    WCHAR   *UniqueRdn = NULL;
    ULONG   Size, Length;

    //
    // Prepare the unique number as a string
    //
    RtlZeroMemory(ConflictCountString, sizeof(ConflictCountString));
    _itow(Count, ConflictCountString, 10);
    CountArray[0] = (WCHAR*)&(ConflictCountString[0]);
    CountArray[1] = NULL; // this is the sentinel

    if (!SampStringNameResource) {

        SampStringNameResource = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );

    }

    if (SampStringNameResource) {

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        SampStringNameResource,
                                        SAMP_NAME_CONFLICT_RDN,
                                        0,       // Use caller's language
                                        (LPWSTR)&UniqueRdn,
                                        0,       // routine should allocate
                                        (va_list*)&(CountArray[0])
                                        );
        if (UniqueRdn) {
            // Messages from a message file have a cr and lf appended
            // to the end
            UniqueRdn[Length-2] = L'\0';
            Length -= 2;
        }

    }

    if (!UniqueRdn) {

        // Large enough to hold the default string an a 32 bit integer
        Size = (wcslen(SampDefaultConflictString)+1+10)*sizeof(WCHAR);
        UniqueRdn = (WCHAR*)LocalAlloc(0, Size);
        if (UniqueRdn) {

            RtlZeroMemory(UniqueRdn, Size);
            wcscpy(UniqueRdn, SampDefaultConflictString);
            wcscat(UniqueRdn, ConflictCountString);
        }

    }

    return UniqueRdn;
}

extern "C"
NTSTATUS
GetRdnForSamObject(IN  WCHAR* SamAccountName,
                   IN  SAMP_OBJECT_TYPE SampObjectType,
                   OUT WCHAR* Rdn,
                   IN OUT ULONG* RdnSize
                   )
/*++

Routine Description:

    This routine finds an rdn for a SAM object. The algorithm is
    as follows:

    1) try to the sam account name - this will work 99.9% of the time
    2) if it does not, then try the string found in the resource table
    for such a case and appended an increasing integer at the end until the
    rdn is unique.

Parameters:

    AccountName    : the name of the account
    SampObjectType : the type of the account
    Rdn            : buffer to put the name into
    Size           : size in bytes of the buffer

Return Values:

    STATUS_SUCCESS

    STATUS_BUFFER_TOO_SMALL if the space provided was not large enough

--*/
{
    NTSTATUS NtStatus;

    ULONG    SamAccountNameSize;
    BOOLEAN  RdnIsUnique = FALSE;
    BOOLEAN  RdnIsNotSamAccountName = FALSE;
    ULONG    NextNumber = 0;

    // Most account names will be MAX_DOWN_LEVEL_NAME_LENGTH
    WCHAR    InitialBuffer[MAX_DOWN_LEVEL_NAME_LENGTH+1];
    WCHAR   *UniqueRdn = InitialBuffer;
    ULONG    UniqueRdnSize = sizeof(InitialBuffer);

    ASSERT(SamAccountName);
    ASSERT(RdnSize);

    RtlZeroMemory(InitialBuffer, sizeof(InitialBuffer));

    if (NULL!=SamAccountName)
    {

        //
        // If an account name is passed in then first try that
        //

        SamAccountNameSize = (wcslen(SamAccountName)+1) * sizeof(WCHAR);
        if (SamAccountNameSize > UniqueRdnSize) {

            UniqueRdn = (WCHAR*)LocalAlloc(0, SamAccountNameSize);
            if (!UniqueRdn) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
            UniqueRdnSize = SamAccountNameSize;
        }
        RtlZeroMemory(UniqueRdn, UniqueRdnSize);
        wcscpy(UniqueRdn, SamAccountName);

        //
        // Is this unique?
        //
        NtStatus = CheckForNonExistence(UniqueRdn, SampObjectType);
        switch (NtStatus) {
            case STATUS_USER_EXISTS:
            case STATUS_GROUP_EXISTS:
            case STATUS_ALIAS_EXISTS:

                NtStatus = STATUS_SUCCESS;
                RdnIsUnique = FALSE;
                break;

            case STATUS_SUCCESS:

                RdnIsUnique = TRUE;
                break;

            default:
                // We want to trap these cases. Assume the rdn is not
                // unique
                ASSERT(FALSE);
                NtStatus = STATUS_SUCCESS;
                RdnIsUnique = FALSE;

        }
    }

    if (!RdnIsUnique) {

        RdnIsNotSamAccountName = TRUE;

        NextNumber = SampNameConflictCount;
        do {


            if (UniqueRdn != InitialBuffer) {
                LocalFree(UniqueRdn);
            }

            //
            // This function loads the string from the resource table in
            // samsrv.dll.  (If the loading of the resource table fails, then
            // a hard coded string is used).
            //
            UniqueRdn =  GetNameConflictString(NextNumber);

            if (UniqueRdn) {

                NtStatus = CheckForNonExistence(UniqueRdn, SampObjectType);
                switch (NtStatus) {
                    case STATUS_USER_EXISTS:
                    case STATUS_GROUP_EXISTS:
                    case STATUS_ALIAS_EXISTS:

                        NtStatus = STATUS_SUCCESS;
                        RdnIsUnique = FALSE;
                        break;

                    case STATUS_SUCCESS:

                        RdnIsUnique = TRUE;
                        break;

                    default:
                        // We want to trap these cases. To prevent the possibility
                        // of an endless loop, assume the rdn is unique
                        ASSERT(FALSE);
                        NtStatus = STATUS_SUCCESS;
                        RdnIsUnique = TRUE;
                }

            } else {

                return STATUS_INSUFFICIENT_RESOURCES;

            }

            NextNumber++;

        } while (!RdnIsUnique && NT_SUCCESS(NtStatus));


    }

    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }
    ASSERT(UniqueRdn);

    UniqueRdnSize = (wcslen(UniqueRdn)+1) * sizeof(WCHAR);

    //
    // Return the rdn if we can
    //
    if (Rdn && UniqueRdnSize <= *RdnSize) {
        if ( NextNumber > SampNameConflictCount ) {
            SampNameConflictCount = NextNumber;
        }
        RtlZeroMemory(Rdn, *RdnSize);
        wcscpy(Rdn, UniqueRdn);
        NtStatus = STATUS_SUCCESS;

    } else {

        NtStatus = STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Return the amount buffer space the rdn requires or was
    // used
    //
    *RdnSize = UniqueRdnSize;

    if (UniqueRdn != InitialBuffer) {
        LocalFree(UniqueRdn);
    }

    if ( NT_SUCCESS( NtStatus )
      && RdnIsNotSamAccountName  ) {

        UNICODE_STRING Name;
        PUNICODE_STRING  NameArray[1];
        
        NameArray[0] = &Name;
        RtlInitUnicodeString(&Name, SamAccountName);
        
        SampWriteEventLog(EVENTLOG_WARNING_TYPE,
                          0,                   // Category
                          SAMMSG_DUPLICATE_ACCOUNT,
                          NULL,                // User Sid
                          1,                   // Num strings
                          sizeof(NTSTATUS),    // Data size
                          NameArray,           // String array
                          (PVOID)&NtStatus     // Data
                          );
        
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dsupgrad\dsupgrad.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Main Routine to test dsupgrad.lib


Author:

    ColinBr  12-Aug-1996

Environment:

    User Mode - Win32

Revision History:


--*/

#include <stdio.h>
#include <samsrvp.h>
#include <duapi.h>
#include <dslayer.h>
#include <mappings.h>
#include <process.h>


#include "util.h"
#include <sdconvrt.h>

VOID
SampInitDsObjectInfoAttributes(
    );

VOID
SampInitObjectInfoAttributes(
    );

NTSTATUS
DsWaitUntilDelayedStartupIsDone(void);

NTSTATUS
SampRegistryToDsUpgrade (
    WCHAR* wcszRegPath
    );

VOID
Usage(
    char *pgmName
    )
{
    printf("Usage: %s [/?] [/t] [/i] [/e]\n", pgmName);
    printf("\nThis a tool to move registry based SAM data to a DS.  This should only\nbe run on a PDC and requires that the DS NOT be running.\n");
    printf("\nNote : All operational output is piped through to the kernel debugger\n\n");
    printf("\t/?                Display this usage message\n");
    printf("\t/t                Show function trace (through kd)\n");
    printf("\t/i                Show informational messages(through kd)\n");
    printf("\t/e                Prints status at end of execution\n");

    printf("\n");

    return;
}

void
InitSamGlobals()
{
    RtlInitUnicodeString( &SampCombinedAttributeName, L"C" );
    RtlInitUnicodeString( &SampFixedAttributeName, L"F" );
    RtlInitUnicodeString( &SampVariableAttributeName, L"V" );

    SampInitDsObjectInfoAttributes();
    SampInitObjectInfoAttributes();
}

VOID __cdecl
main(int argc, char *argv[])
/*++

Routine Description:


Parameters:

Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    NTSTATUS  NtStatus = STATUS_SUCCESS;
    NTSTATUS  UnInitNtStatus = STATUS_SUCCESS;
    BOOL      PrintStatus = FALSE;
    int arg = 1;

    // Parse command-line arguments.
    while(arg < argc)
    {

        if (0 == _stricmp(argv[arg], "/?"))
        {
            Usage(argv[0]);
            exit(0);
        }
        else if (0 == _stricmp(argv[arg], "/t"))
        {
            DebugInfoLevel |= _DEB_TRACE;
        }
        else if (0 == _stricmp(argv[arg], "/i"))
        {
            DebugInfoLevel |= _DEB_INFO;
        }
        else if (0 == _stricmp(argv[arg], "/e"))
        {
            PrintStatus = TRUE;
        }
        else {
            Usage(argv[0]);
            exit(0);
        }

        arg++;
    }

    InitSamGlobals();


    //
    // Initialize the Directory Service.
    //

    NtStatus = SampDsInitialize(FALSE);     // SAM loopback disabled


    if (!NT_SUCCESS(NtStatus)) {
        fprintf(stderr, "SampDsInitialize error = 0x%lx\n", NtStatus);
        goto Error;
    }

    //
    // This is a hack to ensure the delayed startup has completed. The real fix
    // is change the dit install so the DS can be running without the interfaces
    // being initialized.
    // 
    NtStatus = DsWaitUntilDelayedStartupIsDone();
    if (!NT_SUCCESS(NtStatus)) {
        fprintf(stderr, "DsWaitUntilDelayedStartupIsDone error = 0x%lx\n", 
                NtStatus);
        goto Error;
    }

    //
    // Initialize the security descriptor conversion
    //
					 
    NtStatus = SampInitializeSdConversion();

    
    if (!NT_SUCCESS(NtStatus)) {
        fprintf(stderr, "SampInitializeSdConversion = 0x%lx\n", NtStatus);
        goto Error;
    }

    //
    // Do the conversion!
    //
		            
    NtStatus = SampRegistryToDsUpgrade(L"\\Registry\\Machine\\Security\\SAM");
    if (!NT_SUCCESS(NtStatus))
    {
        fprintf(stderr, "SampRegistryToDsUpgrade error = 0x%lx\n", NtStatus);
    }

    //
    //  This fprintf is for processes who might have
    //  created this executable and want to see the return
    //  value.  We do this before SampDsUnitialize because
    //  we suspect it is causing an exception and want the
    //  upgrade to register as successful since all data has
    //  been committted by now.  (BUGBUG - TP workaround.)
    //

    if ( PrintStatus ) {
        fprintf(stderr, "\n$%s$%d$\n", argv[0],
                RtlNtStatusToDosError(NtStatus));
    }

Error:

    __try 
    {
        UnInitNtStatus = SampDsUninitialize();
    } 
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        UnInitNtStatus = STATUS_UNHANDLED_EXCEPTION;
    }

    if (!NT_SUCCESS(UnInitNtStatus))
    {
        fprintf(stderr, "SampDsUninitialize error = 0x%lx\n", UnInitNtStatus);
    }

    //
    // Propogate errors that happened above first
    // 
    if (NT_SUCCESS(NtStatus) && !NT_SUCCESS(UnInitNtStatus)) {
        NtStatus = UnInitNtStatus; 
    }

}

//
// Dummy functions to avoid nasty includes
//

NTSTATUS
SampBuildAccountSubKeyName(
    IN SAMP_OBJECT_TYPE ObjectType,
    OUT PUNICODE_STRING AccountKeyName,
    IN ULONG AccountRid,
    IN PUNICODE_STRING SubKeyName OPTIONAL
    )
{
    ASSERT(FALSE);
    return STATUS_SUCCESS;
}

NTSTATUS
SampBuildDomainSubKeyName(
    OUT PUNICODE_STRING KeyName,
    IN PUNICODE_STRING SubKeyName OPTIONAL
    )
{
    ASSERT(FALSE);
    return STATUS_SUCCESS;
}


NTSTATUS
SampDuplicateUnicodeString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    )

/*++

Routine Description:

    This routine allocates memory for a new OutString and copies the
    InString string to it.

Parameters:

    OutString - A pointer to a destination unicode string

    InString - A pointer to an unicode string to be copied

Return Values:

    None.

--*/

{
    SAMTRACE("SampDuplicateUnicodeString");

    ASSERT( OutString != NULL );
    ASSERT( InString != NULL );

    if ( InString->Length > 0 ) {

        OutString->Buffer = MIDL_user_allocate( InString->Length );

        if (OutString->Buffer == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        OutString->MaximumLength = InString->Length;

        RtlCopyUnicodeString(OutString, InString);

    } else {

        RtlInitUnicodeString(OutString, NULL);
    }

    return(STATUS_SUCCESS);
}

VOID
SampFreeUnicodeString(
    IN PUNICODE_STRING String
    )

/*++

Routine Description:

    This routine frees the buffer associated with a unicode string
    (using MIDL_user_free()).


Arguments:

    Target - The address of a unicode string to free.


Return Value:

    None.

--*/
{

    SAMTRACE("SampFreeUnicodeString");

    if (String->Buffer != NULL) {
        MIDL_user_free( String->Buffer );
    }

    return;
}

NTSTATUS
SampSplitSid(
    IN PSID AccountSid,
    IN OUT PSID *DomainSid OPTIONAL,
    OUT ULONG *Rid
    )

/*++

Routine Description:

    This function splits a sid into its domain sid and rid.  The caller
    can either provide a memory buffer for the returned DomainSid, or
    request that one be allocated.  If the caller provides a buffer, the buffer
    is assumed to be of sufficient size.  If allocated on the caller's behalf,
    the buffer must be freed when no longer required via MIDL_user_free.

Arguments:

    AccountSid - Specifies the Sid to be split.  The Sid is assumed to be
        syntactically valid.  Sids with zero subauthorities cannot be split.

    DomainSid - Pointer to location containing either NULL or a pointer to
        a buffer in which the Domain Sid will be returned.  If NULL is
        specified, memory will be allocated on behalf of the caller. If this
        paramter is NULL, only the account Rid is returned

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call successfully.

        STATUS_INVALID_SID - The Sid is has a subauthority count of 0.
--*/

{
    NTSTATUS    NtStatus;
    UCHAR       AccountSubAuthorityCount;
    ULONG       AccountSidLength;

    SAMTRACE("SampSplitSid");

    //
    // Calculate the size of the domain sid
    //

    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(AccountSid);


    if (AccountSubAuthorityCount < 1) {

        NtStatus = STATUS_INVALID_SID;
        goto SplitSidError;
    }

    AccountSidLength = RtlLengthSid(AccountSid);


    //
    // Get Domain Sid if caller is intersted in it.
    //

    if (DomainSid)
    {

        //
        // If no buffer is required for the Domain Sid, we have to allocate one.
        //

        if (*DomainSid == NULL) {

            //
            // Allocate space for the domain sid (allocate the same size as the
            // account sid so we can use RtlCopySid)
            //

            *DomainSid = MIDL_user_allocate(AccountSidLength);


            if (*DomainSid == NULL) {

                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto SplitSidError;
            }
        }

        //
        // Copy the Account sid into the Domain sid
        //

        RtlMoveMemory(*DomainSid, AccountSid, AccountSidLength);

        //
        // Decrement the domain sid sub-authority count
        //

        (*RtlSubAuthorityCountSid(*DomainSid))--;
    }


    //
    // Copy the rid out of the account sid
    //

    *Rid = *RtlSubAuthoritySid(AccountSid, AccountSubAuthorityCount-1);

    NtStatus = STATUS_SUCCESS;

SplitSidFinish:

    return(NtStatus);

SplitSidError:

    goto SplitSidFinish;
}

NTSTATUS
SampGetObjectSD(
    IN PSAMP_OBJECT Context,
    OUT PULONG SecurityDescriptorLength,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )

/*++

Routine Description:

    This retrieves a security descriptor from a SAM object's backing store.




Arguments:

    Context - The object to which access is being requested.

    SecurityDescriptorLength - Receives the length of the security descriptor.

    SecurityDescriptor - Receives a pointer to the security descriptor.



Return Value:

    STATUS_SUCCESS - The security descriptor has been retrieved.

    STATUS_INTERNAL_DB_CORRUPTION - The object does not have a security descriptor.
        This is bad.


    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated to retrieve the
        security descriptor.

    STATUS_UNKNOWN_REVISION - The security descriptor retrieved is no one known by
        this revision of SAM.



--*/
{

    NTSTATUS NtStatus;
    ULONG Revision;

    SAMTRACE("SampGetObjectSD");


    (*SecurityDescriptorLength) = 0;

    NtStatus = SampGetAccessAttribute(
                    Context,
                    SAMP_OBJECT_SECURITY_DESCRIPTOR,
                    TRUE, // Make copy
                    &Revision,
                    SecurityDescriptor
                    );

    if (NT_SUCCESS(NtStatus)) {

        if ( ((Revision && 0xFFFF0000) > SAMP_MAJOR_REVISION) ||
             (Revision > SAMP_REVISION) ) {

            NtStatus = STATUS_UNKNOWN_REVISION;
        }


        if (!NT_SUCCESS(NtStatus)) {
            MIDL_user_free( (*SecurityDescriptor) );
        }
    }


    if (NT_SUCCESS(NtStatus)) {
        *SecurityDescriptorLength = RtlLengthSecurityDescriptor(
                                        (*SecurityDescriptor) );
    }

    return(NtStatus);
}


VOID
SampWriteEventLog (
    IN     USHORT      EventType,
    IN     USHORT      EventCategory   OPTIONAL,
    IN     ULONG       EventID,
    IN     PSID        UserSid         OPTIONAL,
    IN     USHORT      NumStrings,
    IN     ULONG       DataSize,
    IN     PUNICODE_STRING *Strings    OPTIONAL,
    IN     PVOID       Data            OPTIONAL
    )

/*++

Routine Description:

    *** This function is added here for the unit test only. ***
    Routine that adds an entry to the event log

Arguments:

    EventType - Type of event.

    EventCategory - EventCategory

    EventID - event log ID.

    UserSid - SID of user involved.

    NumStrings - Number of strings in Strings array

    DataSize - Number of bytes in Data buffer

    Strings - Array of unicode strings

    Data - Pointer to data buffer

Return Value:

    None.

--*/

{
    NTSTATUS NtStatus;
    UNICODE_STRING Source;
    HANDLE LogHandle;

    SAMTRACE("SampWriteEventLog");

    RtlInitUnicodeString(&Source, L"SAM");

    //
    // Open the log
    //

    NtStatus = ElfRegisterEventSourceW (
                        NULL,   // Server
                        &Source,
                        &LogHandle
                        );
    if (!NT_SUCCESS(NtStatus)) {
        KdPrint(("SAM: Failed to registry event source with event log, status = 0x%lx\n", NtStatus));
        return;
    }



    //
    // Write out the event
    //

    NtStatus = ElfReportEventW (
                        LogHandle,
                        EventType,
                        EventCategory,
                        EventID,
                        UserSid,
                        NumStrings,
                        DataSize,
                        Strings,
                        Data,
                        0,       // Flags
                        NULL,    // Record Number
                        NULL     // Time written
                        );

    if (!NT_SUCCESS(NtStatus)) {
        KdPrint(("SAM: Failed to report event to event log, status = 0x%lx\n", NtStatus));
    }



    //
    // Close the event log
    //

    NtStatus = ElfDeregisterEventSource (LogHandle);

    if (!NT_SUCCESS(NtStatus)) {
        KdPrint(("SAM: Failed to de-register event source with event log, status = 0x%lx\n", NtStatus));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dsupgrad\interfac.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    interfac.c

Abstract:

    Interface routine to transfer SAM information in Registry to DS


Author:

    ColinBr 30-Jul-1996

Environment:

    User Mode - Win32

Revision History:

--*/

#include <samsrvp.h>
#include <util.h>

ULONG DebugInfoLevel = _DEB_ERROR | _DEB_WARNING;

NTSTATUS
TransferSamObjects(
    WCHAR *wcszSamRegPath
);

NTSTATUS
SampRegistryToDsUpgrade(
    WCHAR *wcszSamRegLocation
    )

/*++

Routine Description:

    This routine is the interface function for the routines to transfer
    SAM objects from the registry to to the directory service


Parameters:

    wcszSamLocation  - this is the location of the SAM repository in the registry

Return Values:

    STATUS_SUCCESS - The service completed successfully.

    Note all exceptions are caught so the return value will relfect any unsual
    exceptions

--*/
{

    ASSERT(wcszSamRegLocation);

    return TransferSamObjects(wcszSamRegLocation);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\test\crack\crack.c ===
#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsapi.h>
#include <ntdsapip.h>
#include <winsock2.h>

// test from ds side

// Not all formats are legal for both input and output.  The first example
// of this is DS_SID_OR_SID_HISTORY_NAME which is legal for input, but not
// output.  So we map to the best equivalent output format.

typedef struct _Format
{
    DWORD   offered;
    DWORD   desired;
} Format;

Format rFormats[] = 
{
    { DS_FQDN_1779_NAME,            DS_FQDN_1779_NAME },
    { DS_NT4_ACCOUNT_NAME,          DS_NT4_ACCOUNT_NAME },
    { DS_DISPLAY_NAME,              DS_DISPLAY_NAME },
    { DS_UNIQUE_ID_NAME,            DS_UNIQUE_ID_NAME },
    { DS_CANONICAL_NAME,            DS_CANONICAL_NAME },
    { DS_USER_PRINCIPAL_NAME,       DS_USER_PRINCIPAL_NAME },
    { DS_CANONICAL_NAME_EX,         DS_CANONICAL_NAME_EX },
    { DS_SERVICE_PRINCIPAL_NAME,    DS_SERVICE_PRINCIPAL_NAME },
    { DS_SID_OR_SID_HISTORY_NAME,   DS_STRING_SID_NAME }
};

#define cFormats        9
#define iFqdn           0
#define iCanonical      4
#define iCanonicalEx    6

CHAR status_buffer[100];

CHAR * Status(
    DWORD status)
{
    switch ( status )
    {
    // from sdk\inc\ntdsapi.h
    case DS_NAME_NO_ERROR:          
        return("DS_NAME_NO_ERROR");
    case DS_NAME_ERROR_RESOLVING:   
        return("DS_NAME_ERROR_RESOLVING");
    case DS_NAME_ERROR_NOT_FOUND:   
        return("DS_NAME_ERROR_NOT_FOUND");
    case DS_NAME_ERROR_NOT_UNIQUE:  
        return("DS_NAME_ERROR_NOT_UNIQUE");
    case DS_NAME_ERROR_NO_MAPPING:  
        return("DS_NAME_ERROR_NO_MAPPING");
    case DS_NAME_ERROR_DOMAIN_ONLY: 
        return("DS_NAME_ERROR_DOMAIN_ONLY");
    case DS_NAME_ERROR_TRUST_REFERRAL:
        return ("DS_NAME_ERROR_TRUST_REFERRAL");
    case DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING:
        return("DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING");
    // from src\dsamain\include\ntdsapip.h
    case DS_NAME_ERROR_IS_FPO:
        return("DS_NAME_ERROR_IS_FPO");
    case DS_NAME_ERROR_IS_SID_USER:
        return("DS_NAME_ERROR_IS_SID_USER");
    case DS_NAME_ERROR_IS_SID_GROUP:
        return("DS_NAME_ERROR_IS_SID_GROUP");
    case DS_NAME_ERROR_IS_SID_ALIAS:
        return("DS_NAME_ERROR_IS_SID_ALIAS");
    case DS_NAME_ERROR_IS_SID_UNKNOWN:
        return("DS_NAME_ERROR_IS_SID_UNKNOWN");
    case DS_NAME_ERROR_IS_SID_HISTORY_USER:
        return("DS_NAME_ERROR_IS_SID_HISTORY_USER");
    case DS_NAME_ERROR_IS_SID_HISTORY_GROUP:
        return("DS_NAME_ERROR_IS_SID_HISTORY_GROUP");
    case DS_NAME_ERROR_IS_SID_HISTORY_ALIAS:
        return("DS_NAME_ERROR_IS_SID_HISTORY_ALIAS");
    case DS_NAME_ERROR_IS_SID_HISTORY_UNKNOWN:
        return("DS_NAME_ERROR_IS_SID_HISTORY_UNKNOWN");
    }

    sprintf(status_buffer, "unknown status - 0x%x", status);

    return(status_buffer);
}

BOOL CrackNameStatusSuccess(
    DWORD s)
{
    switch ( s ) 
    {
    case DS_NAME_NO_ERROR:
    case DS_NAME_ERROR_IS_SID_USER:
    case DS_NAME_ERROR_IS_SID_GROUP:
    case DS_NAME_ERROR_IS_SID_ALIAS:
    case DS_NAME_ERROR_IS_SID_UNKNOWN:
    case DS_NAME_ERROR_IS_SID_HISTORY_USER:
    case DS_NAME_ERROR_IS_SID_HISTORY_GROUP:
    case DS_NAME_ERROR_IS_SID_HISTORY_ALIAS:
    case DS_NAME_ERROR_IS_SID_HISTORY_UNKNOWN:

        return TRUE;
    }

    return FALSE;
}

CHAR * pszFormat(
    DWORD format)
{
    switch ( format )
    {
    case DS_UNKNOWN_NAME:               return("DS_UNKNOWN_NAME");
    case DS_FQDN_1779_NAME:             return("DS_FQDN_1779_NAME");
    case DS_NT4_ACCOUNT_NAME:           return("DS_NT4_ACCOUNT_NAME");
    case DS_DISPLAY_NAME:               return("DS_DISPLAY_NAME");
    case DS_UNIQUE_ID_NAME:             return("DS_UNIQUE_ID_NAME");
    case DS_CANONICAL_NAME:             return("DS_CANONICAL_NAME");
    case DS_USER_PRINCIPAL_NAME:        return("DS_USER_PRINCIPAL_NAME");
    case DS_CANONICAL_NAME_EX:          return("DS_CANONICAL_NAME_EX");
    case DS_SERVICE_PRINCIPAL_NAME:     return("DS_SERVICE_PRINCIPAL_NAME");
    case DS_STRING_SID_NAME:            return("DS_STRING_SID_NAME");
    case DS_SID_OR_SID_HISTORY_NAME:    return("DS_SID_OR_SID_HISTORY_NAME");
    }

    return("unknown format");
}

extern VOID SiteInfo(HANDLE hDS);
extern VOID LdapInfo(HANDLE hDS, CHAR *pszDomain);
extern VOID GuidInfo(HANDLE hDS);
extern VOID DomainInfo1(HANDLE hDS, CHAR *pszDomain);
extern VOID DomainInfo2(HANDLE hDS, CHAR *pszDomain);
extern VOID CheckInternationalDN(HANDLE hDS, CHAR *pszName);
extern VOID GCInfo(HANDLE hDS);
extern VOID QuoteRdn(CHAR *pszUnquotedRdn);
extern VOID UnquoteRdn(CHAR *pszQuotedRdn);
extern VOID GetRdn(CHAR *psDN);

void _cdecl
main(
    int     argc, 
    char    **argv)
{
    DWORD                       dwErr;
    DS_NAME_RESULTA             *rpResult[cFormats];
    DS_NAME_RESULTA             *pResult;
    DWORD                       i;
    HANDLE                      hDS;
    CHAR                        *pchar = NULL;
    BOOL                        fDoSyntacticTest = TRUE;
    RPC_AUTH_IDENTITY_HANDLE    hAuth = NULL;
    CHAR                        *bindArg1, *bindArg2;
    DWORD                       knownFormatOffered;
    DWORD                       cKnownFormatOffered = 0;
    CHAR                        *pszSpn;
    CHAR                        *pDom, *pUser, *pPwd;

    if ( 8 == argc )
    {
        // First 3 args are domain user and password.
        pDom = _stricmp(argv[1], "null") ? argv[1] : NULL;
        pUser = _stricmp(argv[2], "null") ? argv[2] : NULL;
        pPwd = _stricmp(argv[3], "null") ? argv[3] : NULL;

        dwErr = DsMakePasswordCredentialsA(pUser, pDom, pPwd, &hAuth);

        if ( 0 != dwErr )
        {
            printf("DsMakePasswordCredentialsA error 0x%x\n", dwErr);
            goto Usage;
        }

        // Advance argc and argv so as not to have to rewrite all code
        // which pre-existed {dom user pwd} support.

        argc -= 3;
        argv = &argv[3];
    }

    if ( 5 != argc && 3 != argc )
    {
Usage:
        printf("usage:\n");
        printf("\tcrack {dom user pwd} DottedIpAddress/NULL DnsDomainName/NULL SPN/NULL name\n");
        printf("\tcrack {dom user pwd} -siteInfo DottedIpAddress/NULL DnsDomainName/NULL SPN/NULL\n");
        printf("\tcrack {dom user pwd} -schemaGuid DottedIpAddress/NULL DnsDomainName/NULL SPN/NULL\n");
        printf("\tcrack {dom user pwd} -domInfo1:domainName DottedIpAddress/NULL DnsDomainName/NULLSPN/NULL \n");
        printf("\tcrack {dom user pwd} -domInfo2:domainName DottedIpAddress/NULL DnsDomainName/NULL SPN/NULL\n");
        printf("\tcrack {dom user pwd} -intlDN:objName DottedIpAddress/NULL DnsDomainName/NULLSPN/NULL\n");
        printf("\tcrack {dom user pwd} -ldapInfo:domainName DottedIpAddress/NULL DnsDomainName/NULL SPN/NULL\n");
        printf("\tcrack {dom user pwd} -gcInfo DottedIpAddress/NULL DnsDomainName/NULL SPN/NULL\n");
        printf("\tcrack                -quote UnquotedRdnValue\n");
        printf("\tcrack                -unquote QuotedRdnValue\n");
        printf("\tcrack                -getrdn DN\n");
        return;
    }

    //
    // crack ...
    //
    if ( (_stricmp("-quote", argv[1]) == 0) ||
         (_stricmp("-unquote", argv[1]) == 0) ||
         (_stricmp("-getrdn", argv[1]) == 0) )
    {
        //
        // Make quoted Rdn
        //
        if ( argc != 3 )
        {
            goto Usage;
        }
    }
    else
    {
        if (    _stricmp("-siteInfo", argv[1]) 
             && _strnicmp("-ldapInfo:", argv[1], 10) 
             && _strnicmp("-domInfo1:", argv[1], 10) 
             && _strnicmp("-domInfo2:", argv[1], 10) 
             && _strnicmp("-intlDN:", argv[1], 8) 
             && _stricmp("-schemaGuid", argv[1]) 
             && _stricmp("-gcInfo", argv[1]) )
        {
            bindArg1 = _stricmp(argv[1], "null") ? argv[1] : NULL;
            bindArg2 = _stricmp(argv[2], "null") ? argv[2] : NULL;
            pszSpn   = _stricmp(argv[3], "null") ? argv[3] : NULL;
        }
        else
        {
            bindArg1 = _stricmp(argv[2], "null") ? argv[2] : NULL;
            bindArg2 = _stricmp(argv[3], "null") ? argv[3] : NULL;
            pszSpn   = _stricmp(argv[4], "null") ? argv[4] : NULL;
        }

        if ( pszSpn )
        {
            dwErr = DsBindWithSpnA(bindArg1, bindArg2, hAuth, pszSpn, &hDS);
            if ( hAuth ) DsFreePasswordCredentials(hAuth);
        }
        else if ( hAuth )
        {
            dwErr = DsBindWithCredA(bindArg1, bindArg2, hAuth, &hDS);
            DsFreePasswordCredentials(hAuth);
        }
        else
        {
            dwErr = DsBindA(bindArg1, bindArg2, &hDS);
        }

        if ( 0 != dwErr )
        {
            printf("%s error 0x%x\n", 
                   ( pszSpn 
                        ? "DsBindWithSpnA"
                        : ( hAuth
                                ? "DsBindWithCredA"
                                : "DsBindA" ) ),
                   dwErr);
            return;
        }
    }

    if ( !_stricmp("-getrdn", argv[1]) )
    {
        GetRdn(argv[2]);

        return;
    } else if ( !_stricmp("-quote", argv[1]) )
    {
        QuoteRdn(argv[2]);

        return;
    }
    else if ( !_stricmp("-unquote", argv[1]) )
        {
            UnquoteRdn(argv[2]);
    
            return;
    }
    else if ( !_stricmp("-siteInfo", argv[1]) )
    {
        SiteInfo(hDS);

        dwErr = DsUnBindA(&hDS);

        if ( 0 != dwErr )
        {
            printf("DsUnbindA error 0x%x\n", dwErr);
        }

        return;
    }
    else if ( !_strnicmp("-ldapInfo:", argv[1],10) )
    {
        LdapInfo(hDS, &argv[1][10]);

        dwErr = DsUnBindA(&hDS);

        if ( 0 != dwErr )
        {
            printf("DsUnbindA error 0x%x\n", dwErr);
        }

        return;
    }
    else if ( !_strnicmp("-intlDN:", argv[1], 8) )
    {
        CheckInternationalDN(hDS, &argv[1][8]);

        dwErr = DsUnBindA(&hDS);

        if ( 0 != dwErr )
        {
            printf("DsUnbindA error 0x%x\n", dwErr);
        }

        return;
    }
    else if ( !_strnicmp("-domInfo1:", argv[1], 10) )
    {
        DomainInfo1(hDS, &argv[1][10]);

        dwErr = DsUnBindA(&hDS);

        if ( 0 != dwErr )
        {
            printf("DsUnbindA error 0x%x\n", dwErr);
        }

        return;
    }
    else if ( !_strnicmp("-domInfo2:", argv[1], 10) )
    {
        DomainInfo2(hDS, &argv[1][10]);

        dwErr = DsUnBindA(&hDS);

        if ( 0 != dwErr )
        {
            printf("DsUnbindA error 0x%x\n", dwErr);
        }

        return;
    }
    else if ( !_stricmp("-schemaGuid", argv[1]) )
    {
        GuidInfo(hDS);

        dwErr = DsUnBindA(&hDS);

        if ( 0 != dwErr )
        {
            printf("DsUnbindA error 0x%x\n", dwErr);
        }

        return;
    }
    else if ( !_stricmp("-gcInfo", argv[1]) )
    {
        GCInfo(hDS);

        dwErr = DsUnBindA(&hDS);

        if ( 0 != dwErr )
        {
            printf("DsUnbindA error 0x%x\n", dwErr);
        }

        return;
    }
        
    // Since the client side implementation is really in WCHAR, we call
    // the ANSI version thereby also testing ANSI<-->UNICODE conversion.

    memset(rpResult, 0, sizeof(rpResult));

    for ( i = 0; i < cFormats; i++ )
    {
        dwErr = DsCrackNamesA(
                hDS,
                DS_NAME_FLAG_TRUST_REFERRAL,// flags
                DS_UNKNOWN_NAME,        // format offered
                rFormats[i].desired,    // format desired
                1,                      // name count
                &argv[4],
                &rpResult[i]);

        if ( (0 != dwErr)  ||
             (1 != rpResult[i]->cItems) ||
             (NULL == rpResult[i]->rItems) )
        {
            printf("DsCrackNamesA error 0x%x\n", dwErr);
            fDoSyntacticTest = FALSE;
            break;
        }

        printf("%s\n", pszFormat(rFormats[i].desired));
        printf("\tstatus          %s\n", Status(rpResult[i]->rItems[0].status));

        if (    (DS_NAME_NO_ERROR == rpResult[i]->rItems[0].status)
             || (DS_NAME_ERROR_DOMAIN_ONLY == rpResult[i]->rItems[0].status) 
             || (DS_NAME_ERROR_TRUST_REFERRAL == rpResult[i]->rItems[0].status) )
        {
            printf("\tDNS domain      %s\n", rpResult[i]->rItems[0].pDomain);
        }

        if ( CrackNameStatusSuccess(rpResult[i]->rItems[0].status) )
        {
            if ( DS_CANONICAL_NAME_EX == rFormats[i].desired )
            {
                pchar = strrchr(rpResult[i]->rItems[0].pName, '\n');

                if ( NULL == pchar )
                {
                    printf("\t*** Extended canonical form missing '\\n'\n");
                }
                else
                {
                    *pchar = '!';
                }
            }

            printf("\tcracked name    %s\n", rpResult[i]->rItems[0].pName);

            if ( NULL != pchar )
            {
                *pchar = '\n';
            }

            // Current mapping was from UNKNOWN to formatDesired.  Infer
            // a known formatOffered if the input and output string compare.

            if ( !_stricmp(argv[4], rpResult[i]->rItems[0].pName) )
            {
                knownFormatOffered = rFormats[i].offered;
                cKnownFormatOffered += 1;
            }
        }
        else
        {
            if (    (DS_FQDN_1779_NAME == rFormats[i].desired)
                 || (DS_CANONICAL_NAME == rFormats[i].desired)
                 || (DS_CANONICAL_NAME_EX == rFormats[i].desired) )
            {
                // One of the formats we need for later syntactical checking
                // failed - therefore turn off client side syntactic testing.

                fDoSyntacticTest = FALSE;
            }
        }
    }

    printf("\n");

    // There was a bug in the client side syntactical mapping logic whereby 
    // cracking a name from DS_UNKNOWN_NAME format would succeed yet cracking
    // from a known format would fail.  So we retry all calls again from the 
    // inferred known input format and see if we get the same result.

    if ( 0 == cKnownFormatOffered )
    {
        printf("Unable to infer format offered - skipping test\n");
    }
    else if ( cKnownFormatOffered > 1 )
    {
        printf("Too many inferred format offered (%d) - skipping test\n",
               cKnownFormatOffered);
    }
    else
    {
        DS_NAME_RESULTA *pRes;

        printf("Inferred format offered is %s - testing ...\n",
               pszFormat(knownFormatOffered));

        for ( i = 0; i < cFormats; i++ )
        {
            dwErr = DsCrackNamesA(
                        hDS,
                        DS_NAME_FLAG_TRUST_REFERRAL,// flags
                        knownFormatOffered,     // format offered
                        rFormats[i].desired,    // format desired
                        1,                      // name count
                        &argv[4],
                        &pRes);
        
            if ( (0 != dwErr)  ||
                 (1 != pRes->cItems) ||
                 (NULL == pRes->rItems) )
            {
                printf("DsCrackNamesA error 0x%x\n", dwErr);
                break;
            }

            // Test for complete result equivalence.  Special case
            // DS_STRING_SID_NAME which can return DS_NAME_ERROR_IS_SID_*
            // values while original call we're checking against offered
            // DS_UNKNOWN_NAME but matched against DS_SID_OR_SID_HISTORY_NAME
            // which does *not* return DS_NAME_ERROR_IS_SID_* values.

            if (    (pRes->rItems[0].status != rpResult[i]->rItems[0].status)
                 && !(    (DS_STRING_SID_NAME == rFormats[i].desired)
                       && CrackNameStatusSuccess(pRes->rItems[0].status)
                       && (DS_NAME_NO_ERROR == rpResult[i]->rItems[0].status)))
            {
                printf("\tStatus mismatch: %s => %s\n",
                        pszFormat(knownFormatOffered),
                        pszFormat(rFormats[i].desired));
                printf("\t\tinferred(%s) original(%s)\n",
                       Status(pRes->rItems[0].status),
                       Status(rpResult[i]->rItems[0].status));
                DsFreeNameResultA(pRes);
                continue;
            }

            if (    (    CrackNameStatusSuccess(pRes->rItems[0].status)
                      || (DS_NAME_ERROR_DOMAIN_ONLY == pRes->rItems[0].status) )
                 && _stricmp(pRes->rItems[0].pDomain,
                             rpResult[i]->rItems[0].pDomain) )
            {
                printf("\tDomain mismatch: %s ==> %s\n",
                        pszFormat(knownFormatOffered),
                        pszFormat(rFormats[i].desired));
                printf("\t\tinferred(%s)\n\t\toriginal(%s)\n",
                       pRes->rItems[0].pDomain,
                       rpResult[i]->rItems[0].pDomain);
                DsFreeNameResultA(pRes);
                continue;
            }

            if (    CrackNameStatusSuccess(pRes->rItems[0].status)
                 && _stricmp(pRes->rItems[0].pName, 
                             rpResult[i]->rItems[0].pName) )
            {
                printf("\tName mismatch: %s ==> %s\n",
                        pszFormat(knownFormatOffered),
                        pszFormat(rFormats[i].desired));
                printf("\t\tinferred(%s)\n\t\toriginal(%s)\n",
                       pRes->rItems[0].pName,
                       rpResult[i]->rItems[0].pName);
                DsFreeNameResultA(pRes);
                continue;
            }

            DsFreeNameResultA(pRes);
        }
    }

    // We're done with the official work, now let's test client side 
    // syntactic mapping if that makes sense.  

    if ( fDoSyntacticTest )
    {
        for ( i = 0; i <= 1; i++ )
        {
            pResult = NULL;

            dwErr = DsCrackNamesA(
                    // syntactic map shouldn't required valid handle
                    INVALID_HANDLE_VALUE,
                    DS_NAME_FLAG_SYNTACTICAL_ONLY,
                    DS_FQDN_1779_NAME,
                    i ? DS_CANONICAL_NAME : DS_CANONICAL_NAME_EX,
                    1,
                    &rpResult[iFqdn]->rItems[0].pName,
                    &pResult);

            if (    (0 == dwErr) 
                 && (DS_NAME_NO_ERROR == pResult->rItems[0].status) )
            {
                if ( 0 == i )
                {
                    pchar = strrchr(pResult->rItems[0].pName, '\n');

                    if ( NULL == pchar )
                    {
                        printf("\t*** Extended canonical form missing '\\n'\n");
                    }
                    else
                    {
                        *pchar = '!';
                    }
                }

                printf("syntactic %d ==> %s\n", i, pResult->rItems[0].pName);

                if ( 0 == i )
                {
                    *pchar = L'\n';
                }
            }
            else if ( 0 != dwErr )
            {
                printf("syntactic %d ==> dwErr 0x%x\n", i, dwErr);
            }
            else
            {
                printf("syntactic %d ==> status %s\n", 
                       i, Status(pResult->rItems[0].status));
            }
    
            if (    (0 != dwErr)
                 || (1 != pResult->cItems)
                 || (NULL == pResult->rItems)
                 || (DS_NAME_NO_ERROR != pResult->rItems[0].status)
                 || (_stricmp(
                     pResult->rItems[0].pName,
                     rpResult[i?iCanonical:iCanonicalEx]->rItems[0].pName)) )
            {
                printf("crack.exe - Syntactic mapping %d failed\n", i);
            }

            DsFreeNameResultA(pResult);
        }
    }

    for ( i = 0; i < cFormats; i++ )
    {
        DsFreeNameResultA(rpResult[i]);
    }

    dwErr = DsUnBindA(&hDS);

    if ( 0 != dwErr )
    {
        printf("DsUnbindA error 0x%x\n", dwErr);
        return;
    }
}

VOID
GetRdn(
    CHAR *paDN)
{
    DWORD   dwErr;
    WCHAR   *pwDN;
    WCHAR   *pwDNSav;
    DWORD   ccDN;
    DWORD   ccDNSav;
    WCHAR   *pwKey;
    DWORD   ccKey;
    WCHAR   *pwVal;
    DWORD   ccVal;
    WCHAR   c;

    ccDN = strlen(paDN);
    pwDN = malloc((ccDN + 1) * sizeof(WCHAR));
    swprintf(pwDN, L"%hs", paDN);
    printf("%ws\n", pwDN);

    pwDNSav = pwDN;
    ccDNSav = ccDN;
    while (ccDN) {
        dwErr = DsGetRdnW(&pwDN,
                          &ccDN,
                          &pwKey,
                          &ccKey,
                          &pwVal,
                          &ccVal);
        if (dwErr) {
            printf("DsGetRdnW(%d:%ws:) error 0x%x\n",
                   ccDN,
                   pwDN,
                   dwErr);
            return;
        } else {
            printf("DsGetRdnW(%d:%ws:)\n", ccDNSav, pwDNSav);
            printf("   DN : %d:%ws:\n", ccDN, pwDN);
            if (ccKey) {
                c = pwKey[ccKey];
                pwKey[ccKey] = 0;
                printf("   Key: %d:%ws:\n", ccKey, pwKey);
                pwKey[ccKey] = c;
            }
            if (ccVal) {
                c = pwVal[ccVal];
                pwVal[ccVal] = 0;
                printf("   Val: %d:%ws:\n", ccVal, pwVal);
                pwVal[ccVal] = c;
            }
        }
    }
}

VOID
QuoteRdn(
    CHAR *pszUnquotedRdn)
{
    DWORD   dwErr;
    DWORD   QuotedLength;
    DWORD   UnquotedLength;
    CHAR    QuotedRdn[MAX_PATH+1];
    CHAR    UnquotedRdn[MAX_PATH+1];

    //
    // UnquotedRdn -> QuotedRdn
    //
    QuotedLength = MAX_PATH;
    dwErr = DsQuoteRdnValueA(strlen(pszUnquotedRdn),
                        pszUnquotedRdn,
                        &QuotedLength,
                        QuotedRdn);
    if ( 0 != dwErr ) {
        printf("DsQuotedRdnValueA(%s) error 0x%x\n",
               pszUnquotedRdn,
               dwErr);
    } else {
        QuotedRdn[QuotedLength] = L'\0';
        printf("DsQuoteRdnValueA(%s) -> %s\n",
               pszUnquotedRdn,
               QuotedRdn);
    }

    //
    // Quoted Rdn -> Unquoted Rdn
    //
    if (dwErr == ERROR_SUCCESS) {
        UnquotedLength = MAX_PATH;
        dwErr = DsUnquoteRdnValueA(QuotedLength,
                                   QuotedRdn,
                                   &UnquotedLength,
                                   UnquotedRdn);
        if ( 0 != dwErr ) {
            printf("DsUnquoteRdnValueA(%s) error 0x%x\n",
                   QuotedRdn,
                   dwErr);
        }
        else {
            UnquotedRdn[UnquotedLength] = L'\0';
            printf("DsUnquoteRdnValueA(%s) -> %s\n",
                   QuotedRdn,
                   UnquotedRdn);
        }
    }
}

VOID
UnquoteRdn(
    CHAR *pszQuotedRdn)
{
    DWORD   dwErr;
    DWORD   QuotedLength;
    DWORD   UnquotedLength;
    CHAR    QuotedRdn[MAX_PATH+1];
    CHAR    UnquotedRdn[MAX_PATH+1];

    //
    // Quoted Rdn -> Unquoted Rdn
    //
    UnquotedLength = MAX_PATH;
    dwErr = DsUnquoteRdnValueA(strlen(pszQuotedRdn),
                               pszQuotedRdn,
                               &UnquotedLength,
                               UnquotedRdn);
    if ( 0 != dwErr ) {
        printf("DsUnquoteRdnValueA(%s) error 0x%x\n",
               pszQuotedRdn,
               dwErr);
    }
    else {
        UnquotedRdn[UnquotedLength] = L'\0';
        printf("DsUnquoteRdnValueA(%s) -> %s\n",
               pszQuotedRdn,
               UnquotedRdn);
    }

    //
    // UnquotedRdn -> QuotedRdn
    //
    if (dwErr == ERROR_SUCCESS) {
        QuotedLength = MAX_PATH;
        dwErr = DsQuoteRdnValueA(UnquotedLength,
                                 UnquotedRdn,
                                 &QuotedLength,
                                 QuotedRdn);
        if ( 0 != dwErr ) {
            printf("DsQuotedRdnValueA(%s) error 0x%x\n",
                   UnquotedRdn,
                   dwErr);
        } else {
            QuotedRdn[QuotedLength] = L'\0';
            printf("DsQuoteRdnValueA(%s) -> %s\n",
                   UnquotedRdn,
                   QuotedRdn);
        }
    }
}

VOID
SiteInfo(
    HANDLE hDS)
{
    DWORD               dwErr;
    PDS_NAME_RESULTA    sites;
    PDS_NAME_RESULTA    servers;
    PDS_NAME_RESULTA    domains;
    PDS_NAME_RESULTA    info;
    PDS_NAME_RESULTA    roles;
    DWORD               i, j, k;

    // Try out all the site info APIs.

    if ( dwErr = DsListRolesA(hDS, &roles) )
    {
        printf("DsListRolesA error 0x%x\n", dwErr);
        return;
    }

    printf("*** Found %d roles ***\n", roles->cItems);

    for ( i = 0; i < roles->cItems; i++ )
    {
        if ( DS_NAME_NO_ERROR != roles->rItems[i].status )
        {
            printf("Role item[%d] error %s\n", 
                   i, Status(roles->rItems[i].status));
            continue;
        }

        switch ( i )
        {
        case DS_ROLE_INFRASTRUCTURE_OWNER:

            printf("Schema - %s\n", roles->rItems[i].pName);
            break;

        case DS_ROLE_SCHEMA_OWNER:

            printf("Schema - %s\n", roles->rItems[i].pName);
            break;
            
        case DS_ROLE_DOMAIN_OWNER:

            printf("Domain - %s\n", roles->rItems[i].pName);
            break;

        case DS_ROLE_PDC_OWNER:

            printf("PDC - %s\n", roles->rItems[i].pName);
            break;

        case DS_ROLE_RID_OWNER:

            printf("RID - %s\n", roles->rItems[i].pName);
            break;

        default:

            printf("Unknown item %d ==> %s\n",
                   i, Status(roles->rItems[i].status));
            break;
        }
    }

    DsFreeNameResultA(roles);

    if ( dwErr = DsListSitesA(hDS, &sites) )
    {
        printf("DsListSitesA error 0x%x\n", dwErr);
        return;
    }

    printf("*** Found 0x%x sites ***\n", sites->cItems);

    for ( i = 0; i < sites->cItems; i++ )
    {
        if ( DS_NAME_NO_ERROR != sites->rItems[i].status )
        {
            printf("DsSitesA status[0x%x] ==> %s\n", 
                   i, Status(sites->rItems[i].status));
            return;
        }

        printf("0x%x - %s(%s)\n", 
               i,
               sites->rItems[i].pName,
               sites->rItems[i].pDomain);

        dwErr = DsListServersInSiteA(hDS, sites->rItems[i].pName, &servers);

        if ( dwErr ) 
        {
            printf("DsListServersInSiteA error 0x%x\n", dwErr);
            return;
        }

        printf("\t*** Found 0x%x servers in site 0x%x ***\n", 
               servers->cItems, i);

        for ( j = 0; j < servers->cItems; j++ )
        {
            if ( DS_NAME_NO_ERROR != servers->rItems[j].status )
            {
                printf("DsListServersInSiteA status[0x%x] ==> %s\n", 
                       j, Status(servers->rItems[j].status));
                return;
            }

            printf("\t0x%x - %s(%s)\n",
                   j,
                   servers->rItems[j].pName,
                   servers->rItems[j].pDomain);

            dwErr = DsListInfoForServerA(hDS, servers->rItems[j].pName, &info);

            if ( dwErr ) 
            {
                printf("DsListInfoForServerA error 0x%x\n", dwErr);
                return;
            }
            else if ( 3 != info->cItems )
            {
                printf("DsListInfoForServerA error - 0x%x items returned\n",
                       info->cItems);
                return;
            }

            printf("\t\t*** Found 0x%x info items for server 0x%x ***\n",
                   info->cItems, j);

            for ( k = 0; k < info->cItems; k++ )
            {
                switch ( k )
                {
                    case DS_LIST_DSA_OBJECT_FOR_SERVER:
                        printf("\t\tNTDS-DSA: ");         break;
                    case DS_LIST_DNS_HOST_NAME_FOR_SERVER:
                        printf("\t\tDNS host name: ");    break;
                    case DS_LIST_ACCOUNT_OBJECT_FOR_SERVER:
                        printf("\t\tAccount object: ");   break;
                }

                if ( DS_NAME_NO_ERROR != info->rItems[k].status )
                {
                    printf("%s\n", Status(info->rItems[k].status));
                }
                else
                {
                    printf("%s(%s)\n",
                           info->rItems[k].pName,
                           info->rItems[k].pDomain);
                }
            }

            DsFreeNameResultA(info);
        }

        DsFreeNameResultA(servers);

        dwErr = DsListDomainsInSiteA(hDS, sites->rItems[i].pName, &domains);

        if ( dwErr ) 
        {
            printf("DsListDomainsInSiteA error 0x%x\n", dwErr);
            return;
        }

        printf("\t*** Found 0x%x domains in site 0x%x ***\n", 
               domains->cItems, i);

        for ( j = 0; j < domains->cItems; j++ )
        {
            if ( DS_NAME_NO_ERROR != domains->rItems[i].status )
            {
                printf("DsListDomainsInSiteA status[0x%x] ==> %s\n", 
                       i, Status(domains->rItems[i].status));
                return;
            }

            printf("\t0x%x - %s(%s)\n",
                   j,
                   domains->rItems[j].pName,
                   domains->rItems[j].pDomain);

        }
    }

    for ( i = 0; i < sites->cItems; i++ )
    {
        for ( j = 0; j < domains->cItems; j++ )
        {
            dwErr = DsListServersForDomainInSiteA(
                                hDS,
                                domains->rItems[j].pName,
                                sites->rItems[i].pName,
                                &servers);

            if ( dwErr ) 
            {
                printf("DsListServersForDomainInSite error 0x%x\n", dwErr);
                return;
            }

            printf("*** Found 0x%x servers for domain 0x%x in site 0x%x ***\n",
                   servers->cItems, j, i);

            for ( k = 0; k < servers->cItems; k++ )
            {
                if ( DS_NAME_NO_ERROR != servers->rItems[i].status )
                {
                    printf("DsListServersForDomainInSiteA status[0x%x] ==> %s\n", 
                           i, Status(servers->rItems[i].status));
                    return;
                }

                printf("0x%x - %s(%s)\n",
                       k,
                       servers->rItems[k].pName,
                       servers->rItems[k].pDomain);
            }

            DsFreeNameResultA(servers);
        }
    }

    DsFreeNameResultA(sites);
    DsFreeNameResultA(domains);
}

VOID
LdapInfo(
    HANDLE hDS,
    CHAR    *pszDomain)
{

    DWORD err;
    DWORD nRead;
    PDS_DOMAIN_CONTROLLER_INFO_FFFFFFFF Buffer = NULL;

    err = DsGetDomainControllerInfo(hDS,
                                    pszDomain,
                                    DS_DCINFO_LEVEL_FFFFFFFF,
                                    &nRead,
                                    &Buffer
                                    );

    if ( err == NO_ERROR ) {

        DWORD i;

        printf("*** Found %d LDAP connections ***\n", nRead);

        for (i=0;i<nRead;i++) {

            IN_ADDR addr;
            
            addr.s_addr = Buffer[i].IPAddress;

            printf("Client %s. ",inet_ntoa(addr));

            printf("Flags: ");
            if ( Buffer[i].Flags & LDAP_CONN_FLAG_BOUND ) {
                printf("Bound");
            } else {
                printf("Not Bound");
            }

            if ( Buffer[i].Flags & LDAP_CONN_FLAG_SSL ) {
                printf(";SSL");
            }
            if ( Buffer[i].Flags & LDAP_CONN_FLAG_UDP ) {
                printf(";UDP");
            }
            if ( Buffer[i].Flags & LDAP_CONN_FLAG_GC ) {
                printf(";GC Port");
            }
            if ( Buffer[i].Flags & LDAP_CONN_FLAG_SIMPLE ) {
                printf(";Simple Bind");
            }
            if ( Buffer[i].Flags & LDAP_CONN_FLAG_GSSAPI ) {
                printf(";GSSAPI Bind");
            }
            if ( Buffer[i].Flags & LDAP_CONN_FLAG_SPNEGO ) {
                printf(";SPNEGO Bind");
            }
            if ( Buffer[i].Flags & LDAP_CONN_FLAG_SIGN ) {
                printf(";Sign");
            }
            if ( Buffer[i].Flags & LDAP_CONN_FLAG_SEAL ) {
                printf(";Seal");
            }

            printf("\nTime connected %d sec.\n",Buffer[i].secTimeConnected);

            if ( Buffer[i].NotificationCount != 0 ) {
                printf("%d notifications outstanding\n",Buffer[i].NotificationCount);
            }

            if ( Buffer[i].UserName != NULL ) {
                printf("UserName: %s\n",Buffer[i].UserName);
            }
            printf("\n");
        }

        DsFreeDomainControllerInfo(DS_DCINFO_LEVEL_FFFFFFFF,nRead,Buffer);
    } else {
        printf("DsGetDomainControlerInfoA(VFFFFFFFF) error 0x%x\n", err);
    }
    return;
}


VOID
GuidInfo(
    HANDLE hDS)
{
    // Lookup a known GUID in each category as well as a bogus GUID 
    // and verify the results.

    DWORD               i;
    DWORD               dwErr;
    DS_SCHEMA_GUID_MAPA *pMap = NULL;
    GUID                rGuids[5] = {
        // 0 == DS_SCHEMA_GUID_NOT_FOUND
        { 0x00000000,0x0000,0x0000,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },

        // 1 == DS_SCHEMA_GUID_ATTR ==> Common-Name, aka "cn"
        { 0xbf96793f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2 },

        // 2 == DS_SCHEMA_GUID_ATTR_SET ==> Common-Name's prop set
        { 0xe48d0154,0xbcf8,0x11d1,0x87,0x02,0x00,0xc0,0x4f,0xb9,0x60,0x50 },

        // 3 == DS_SCHEMA_GUID_CLASS ==> "user"
        { 0xbf967aba,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2 },

        // 4 == DS_SCHEMA_GUID_CONTROL_RIGHT ==> "Change Schema Master"
        { 0xe12b56b6,0x0a95,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd } };
    PCHAR               rNames[5] = {   NULL,
                                        "cn",
    // See comments in SchemaGuidCrackNames in src\dsamain\src\cracknam.c
    // to understand where the following string comes from.
                                        "Public Information",
                                        "user",
                                        "Change Schema Master" };
    PCHAR               rLabels[5] = {  "DS_SCHEMA_GUID_NOT_FOUND",
                                        "DS_SCHEMA_GUID_ATTR",
                                        "DS_SCHEMA_GUID_ATTR_SET",
                                        "DS_SCHEMA_GUID_CLASS",
                                        "DS_SCHEMA_GUID_CONTROL_RIGHT" };

    if ( dwErr = DsMapSchemaGuidsA(hDS, 5, rGuids, &pMap) )
    {
        printf("DsMapSchemaGuidsA error 0x%x\n", dwErr);
        return;
    }

    if ( !pMap )
    {
        printf("DsMapSchemaGuidsA returned NULL DS_SCHEMA_GUID_MAPA\n");
        return;
    }
    
    for ( i = 0; i < 5; i++ )
    {
        // Test DS_SCHEMA_GUID_MAPA.guid.

        if ( memcmp(&rGuids[i], &pMap[i].guid, sizeof(GUID)) )
        {
            printf("Output missing guid # 0x%x\n", i);
            return;
        }

        // Test DS_SCHEMA_GUID_MAPA.guidType.

        // Note that control data was contrived such that array offset
        // is also the expected guid type.

        if ( i != pMap[i].guidType )
        {
            printf("Guid type mismatch - expected(0x%x) received(0x%x)\n",
                   i, pMap[i].guidType);
            if (    (DS_SCHEMA_GUID_NOT_FOUND != pMap[i].guidType)
                 && pMap[i].pName )
            {
                printf("\tname is: %s\n", pMap[i].pName);
            }
            return;
        }

        // Test DS_SCHEMA_GUID_MAPA.pName.

        if ( !rNames[i] && pMap[i].pName )
        {
            printf("%s name error - expected NULL name, but got \"%s\"\n",
                   rLabels[i], pMap[i].pName);
            return;
        }
        else if ( rNames[i] && !pMap[i].pName )
        {
            printf("%s name error - expected \"%s\", but got NULL\n",
                   rLabels[i], rNames[i]);
            return;
        }
        else if (    rNames[i] && pMap[i].pName 
                  && _stricmp(rNames[i], pMap[i].pName) )
        {
            printf("%s name error - expected \"%s\", but got \"%s\"\n",
                   rNames[i], pMap[i].pName, rNames[i]);
            return;
        }
    }

    DsFreeSchemaGuidMapA(pMap);
    printf("Schema guid map tests passed!\n");
}

VOID
DomainInfo1(
    HANDLE  hDS,
    CHAR    *pszDomain)
{
    DS_DOMAIN_CONTROLLER_INFO_1A    *pInfo;
    DWORD                           cInfo;
    DWORD                           dwErr;
    DWORD                           i;

    dwErr = DsGetDomainControllerInfoA( hDS,
                                        pszDomain,
                                        1,
                                        &cInfo,
                                        &pInfo);

    if ( dwErr )
    {
        printf("DsGetDomainControlerInfoA(V1) error 0x%x\n", dwErr);
        return;
    }

    printf("0x%x domain controllers found\n", cInfo);

    for ( i = 0; i < cInfo; i++ )
    {
        printf("*** %d ***\n", i);
        printf("\tNetbiosName           %s\n", pInfo[i].NetbiosName);
        printf("\tDnsHostName           %s\n", pInfo[i].DnsHostName);
        printf("\tSiteName              %s\n", pInfo[i].SiteName);
        printf("\tComputerObjectName    %s\n", pInfo[i].ComputerObjectName);
        printf("\tServerObjectName      %s\n", pInfo[i].ServerObjectName);
        printf("\tfIsPdc                0x%x\n", pInfo[i].fIsPdc);
        printf("\tfDsEnabled            0x%x\n", pInfo[i].fDsEnabled);
    }

    DsFreeDomainControllerInfoA(1, cInfo, pInfo);
}

VOID
DomainInfo2(
    HANDLE  hDS,
    CHAR    *pszDomain)
{
    DS_DOMAIN_CONTROLLER_INFO_2A    *pInfo;
    DWORD                           cInfo;
    DWORD                           dwErr;
    DWORD                           i;
    CHAR                            *pszGuid;

    dwErr = DsGetDomainControllerInfoA( hDS,
                                        pszDomain,
                                        2,
                                        &cInfo,
                                        &pInfo);

    if ( dwErr )
    {
        printf("DsGetDomainControlerInfoA(V2) error 0x%x\n", dwErr);
        return;
    }

    printf("0x%x domain controllers found\n", cInfo);

    for ( i = 0; i < cInfo; i++ )
    {
        printf("*** %d ***\n", i);
        printf("\tNetbiosName           %s\n", pInfo[i].NetbiosName);
        printf("\tDnsHostName           %s\n", pInfo[i].DnsHostName);
        printf("\tSiteName              %s\n", pInfo[i].SiteName);

        printf("\tSiteObjectName        %s\n", pInfo[i].SiteObjectName);
        UuidToStringA(&pInfo[i].SiteObjectGuid, &pszGuid);
        printf("\tSiteObjectGuid        %s\n", pszGuid);
        RpcStringFreeA(&pszGuid);

        printf("\tComputerObjectName    %s\n", pInfo[i].ComputerObjectName);
        UuidToStringA(&pInfo[i].ComputerObjectGuid, &pszGuid);
        printf("\tComputerObjectGuid    %s\n", pszGuid);
        RpcStringFreeA(&pszGuid);

        printf("\tServerObjectName      %s\n", pInfo[i].ServerObjectName);
        UuidToStringA(&pInfo[i].ServerObjectGuid, &pszGuid);
        printf("\tServerObjectGuid      %s\n", pszGuid);
        RpcStringFreeA(&pszGuid);

        printf("\tNtdsDsaObjectName     %s\n", pInfo[i].NtdsDsaObjectName);
        UuidToStringA(&pInfo[i].NtdsDsaObjectGuid, &pszGuid);
        printf("\tNtdsDsaObjectGuid     %s\n", pszGuid);
        RpcStringFreeA(&pszGuid);

        printf("\tfIsPdc                0x%x\n", pInfo[i].fIsPdc);
        printf("\tfDsEnabled            0x%x\n", pInfo[i].fDsEnabled);
        printf("\tfIsGc                 0x%x\n", pInfo[i].fIsGc);
    }

    DsFreeDomainControllerInfoA(2, cInfo, pInfo);
}

VOID
CheckInternationalDN(
    HANDLE  hDS,
    CHAR    *pszName)
{
    DWORD           dwErr;
    WCHAR           *pwszName;
    DS_NAME_RESULTW *pResultGuid1;
    DS_NAME_RESULTW *pResultDN;
    DS_NAME_RESULTW *pResultGuid2;
    DS_NAME_RESULTW *pResultCanonical;

    pwszName = (WCHAR *) alloca(sizeof(WCHAR) * (strlen(pszName) + 1));
    mbstowcs(pwszName, pszName, strlen(pszName) + 1);

    // Crack to GUID.

    dwErr = DsCrackNamesW(
                hDS,
                DS_NAME_FLAG_TRUST_REFERRAL,
                DS_UNKNOWN_NAME,
                DS_UNIQUE_ID_NAME,
                1,
                &pwszName,
                &pResultGuid1);

    if ( dwErr )
    {
        printf("Error 0x%x on initial GUID crack\n", dwErr);
        return;
    }
    else if ( DS_NAME_NO_ERROR != pResultGuid1->rItems[0].status )
    {
        printf("Status %s on initial GUID crack\n", 
               Status(pResultGuid1->rItems[0].status));
        return;
    }

    printf("GUID is %ws\n", pResultGuid1->rItems[0].pName);
    
    // Crack to (international) DN.

    dwErr = DsCrackNamesW(
                hDS,
                DS_NAME_FLAG_TRUST_REFERRAL,
                DS_UNIQUE_ID_NAME,
                DS_FQDN_1779_NAME,
                1,
                &pResultGuid1->rItems[0].pName,
                &pResultDN);

    if ( dwErr )
    {
        printf("Error 0x%x on DN crack\n", dwErr);
        return;
    }
    else if ( DS_NAME_NO_ERROR != pResultDN->rItems[0].status )
    {
        printf("Status %s on DN crack\n", 
               Status(pResultDN->rItems[0].status));
        return;
    }

    printf("DN is \"%ws\"\n", pResultDN->rItems[0].pName);

    // Crack this (presumed) international DN back to the GUID.

    dwErr = DsCrackNamesW(
                hDS,
                DS_NAME_FLAG_TRUST_REFERRAL,
                DS_FQDN_1779_NAME,
                DS_UNIQUE_ID_NAME,
                1,
                &pResultDN->rItems[0].pName,
                &pResultGuid2);

    if ( dwErr )
    {
        printf("Error 0x%x on DN to GUID crack\n", dwErr);
        return;
    }
    else if ( DS_NAME_NO_ERROR != pResultGuid2->rItems[0].status )
    {
        printf("Status %s on DN to GUID crack\n", 
               Status(pResultGuid2->rItems[0].status));
        return;
    }

    if ( wcscmp(pResultGuid1->rItems[0].pName, pResultGuid2->rItems[0].pName) )
    {
        printf("Guid mismatch: %ws *** %ws\n",
               pResultGuid1->rItems[0].pName,
               pResultGuid2->rItems[0].pName);
    }
    else
    {
        printf("Guids matched OK\n");
    }

    // Crack DN to GUID using DS_UNKNOWN_NAME.

    printf("Cracking DN to canonical using DS_UNKNOWN_NAME ...\n");
    dwErr = DsCrackNamesW(
                hDS,
                DS_NAME_FLAG_TRUST_REFERRAL,
                DS_UNKNOWN_NAME,
                DS_CANONICAL_NAME,
                1,
                &pResultDN->rItems[0].pName,
                &pResultCanonical);

    if ( dwErr )
    {
        printf("Error 0x%x on DN to CANONICAL crack\n", dwErr);
        return;
    }
    else if ( DS_NAME_NO_ERROR != pResultCanonical->rItems[0].status )
    {
        printf("Status %s on DN to CANONICAL crack\n", 
               Status(pResultCanonical->rItems[0].status));
        return;
    }

    printf("CANONICAL name is \"%ws\"\n", pResultCanonical->rItems[0].pName);

    DsFreeNameResultW(pResultGuid1);
    DsFreeNameResultW(pResultGuid2);
    DsFreeNameResultW(pResultDN);
    DsFreeNameResultW(pResultCanonical);
}

VOID
GCInfo(
    HANDLE  hDS)
{
    DWORD           i, dwErr;
    LPSTR           dummy = "dummy";
    DS_NAME_RESULTA *pGC;

    dwErr = DsCrackNamesA(hDS,
                          DS_NAME_FLAG_TRUST_REFERRAL,
                          DS_LIST_GLOBAL_CATALOG_SERVERS,
                          DS_FQDN_1779_NAME,
                          1,
                          &dummy,
                          &pGC);

    if ( dwErr )
    {
        printf("DsCrackNamesA(DS_LIST_GLOBAL_CATALOG_SERVERS) error 0x%x\n", 
                dwErr);
        return;
    }

    printf("0x%x GCs found\n", pGC->cItems);

    for ( i = 0; i < pGC->cItems; i++ )
    {
        printf("*** %d ***\n", i);

        if ( DS_NAME_NO_ERROR != pGC->rItems[i].status )
        {
            printf("\tStatus %s\n", Status(pGC->rItems[i].status));
        }
        else
        {
            printf("\tSite:          %s\n", pGC->rItems[i].pName);
            printf("\tDNS Host Name: %s\n", pGC->rItems[i].pDomain);
        }
    }

    DsFreeNameResultA(pGC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\test\main.c ===
/*++

Copyright (c) 1990 - 1996 Microsoft Corporation

Module Name:

    main.c

Abstract:

    This file contains a set of test routines that constitute the SAM DS
    developer regression test. The test routines call the public SAM API
    as would any client of SAM. This test should always be run as a pre-
    requisite to checking in any changes to the SAM module, and is intended
    to serve as the primary developer regression test for SAM.

    The final test status should only display either "PASSED" or "FAILED"
    to stdout. All other output should optionally go to stdout or to a
    debugger as appropriate.

Author:

    Chris Mayhall (ChrisMay) 19-Jun-1996

Environment:

    User Mode - Win32

Revision History:

    ChrisMay        28-Sep-1996
        Picked up original version from MikeSw's unit tests and updated it.
        Converted any C++ specific code to C for easier debugging in ntsd,
        and removed obsolete Cairo code.
    ChrisMay        06-Oct-1996
        Fixed buffer lengths in alias routines, got -gam working again.
        Removed redundant #include files.

--*/

#include <ntdspch.h> // Apparently required to correctly binplace DS files.
#pragma hdrstop

#include <ntsam.h>
#include <ntlsa.h>
#define SECURITY_WIN32
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
#include <samrpc.h>
#include <samisrv.h>    
#include <lsarpc.h>
#include <lsaisrv.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <wxlpc.h>

// Since kdprint doesn't seem to be exported anymore, define a private macro
// for debugging. Currently set to display to stdout if SAM_DRT_DBG is 1.

#define SAM_DRT_DBG 0

#if SAM_DRT_DBG == 1
#define kdprint(x) printf x
#else
#define kdprint(x)
#endif

typedef NTSTATUS (TestFunc)( WCHAR *Parameter[]);

typedef struct _Commands
{
    PSTR Name;
    ULONG Parameter; // TRUE = yes, FALSE = no
    TestFunc *Function;
} CommandPair, *PCommandPair;


typedef struct _Action
{
    ULONG CommandNumber;
    LPWSTR Parameter[8];
} Action, *PAction;

/*
NTSTATUS
WxReadSysKey(
    IN OUT PULONG BufferLength,
    OUT PVOID  Key
    );
*/
TestFunc Help;

//
// TEST                         SAM ROUTINES CALLED IN THE TEST
//

TestFunc OpenDomain;                // SamOpenDomain
TestFunc EnumDomains;               // SamEnumerateDomainsInSamServer
                                    // SamFreeMemory
TestFunc EnumAccounts;              // SamEnumerateUsersInDomain
                                    // SamEnumerateGroupsInDomain
                                    // SamEnumerateAliasesInDomain
                                    // SamFreeMemory
TestFunc QueryDisplay;              // SamQueryDisplayInformation
                                    // SamFreeMemory
TestFunc OpenGroup;                 // SamLookupNamesInDomain
                                    // SamOpenGroup
                                    // SamFreeMemory
TestFunc GroupMembers;              // SamGetMembersInGroup
                                    // SamFreeMemory
TestFunc OpenAlias;                 // SamLookupNamesInDomain
                                    // SamFreeMemory
TestFunc AliasMembers;              // SamGetMembersInAlias
                                    // SamFreeMemory
TestFunc GetAliasMembership;        // SamGetAliasMembership
                                    // SamFreeMemory
TestFunc OpenUser;                  // SamOpenUser
TestFunc GetGroupsForUser;          // SamGetGroupsForUser
                                    // SamFreeMemory
TestFunc DumpAllUsers;              // SamEnumerateUsersInDomain
                                    // SamCloseHandle
                                    // SamFreeMemory
TestFunc DumpAllGroups;             // SamEnumerateGroupsInDomain
                                    // SamCloseHandle
                                    // SamFreeMemory
TestFunc DumpUser;                  // SamQueryInformationUser
                                    // SamFreeMemory
TestFunc DumpGroup;                 // SamQueryInformationGroup
                                    // SamFreeMemory
TestFunc CreateUser;                // SamCreateUser2InDomain
TestFunc AddAliasMember;            // SamAddMemberToAlias
TestFunc CreateGroup;               // SamCreateGroupInDomain
TestFunc CreateAlias;               // SamCreateAliasInDomain
TestFunc DumpDomain;                // SamQueryInformationDomain
                                    // SamFreeMemory
TestFunc Connect;                   // SamConnect
TestFunc DelUser;                   // SamDeleteUser
TestFunc DelAlias;                  // SamDeleteAlias
TestFunc DelGroup;                  // SamDeleteGroup
TestFunc SetLogonHours;             // SamSetLogonHours
TestFunc SetPassword;               // SamSetInformationUser
TestFunc ChangeKey;                 // SamiSetBootKeyInformation
//
// SAM ROUTINES NOT CALLED IN ANY TEST (but work in usrmgr, boot, etc.).
//

// BUG: The remaining SAM API should be added to the samdsdrt test.

// SamSetSecurityObject
// SamQuerySecurityObject
// SamShutdownSamServer
// SamLookupDomainInSamServer
// SamSetInformationDomain
// SamCreateUserInDomain
// SamLookupIdsInDomain
// SamGetDisplayEnumerationIndex
// SamSetInformationGroup
// SamAddMemberToGroup
// SamRemoveMemberFromGroup
// SamSetMemberAttributesOfGroup
// SamQueryInformationAlias
// SamSetInformationAlias
// SamRemoveMemberFromAlias
// SamRemoveMemberFromForeignDomain
// SamAddMulitpleMembersToAlias
// SamRemoveMultipleMembersFromAlias
// SamSetInformationUser
// SamChangePasswordUser
// SamChangePasswordUser2

// SamiLmChangePasswordUser
// SamiChangePasswordUser
// SamiChangePasswordUser2
// SamiOemChangePasswordUser2
// SamiEncryptPasswords

// Command-line switch, parameter, and test routine table. New tests are
// added to this table.

CommandPair Commands[] =
{
    // TEST                                         CURRENT STATUS

    // switch   # params    test routine

    {"-od",     1,          OpenDomain},            // passed
    {"-ed",     0,          EnumDomains},           // passed
    {"-ea",     1,          EnumAccounts},          // passed
    {"-qd",     1,          QueryDisplay},          // passed
    {"-og",     1,          OpenGroup},             // passed
    {"-gm",     0,          GroupMembers},          // passed
    {"-oa",     1,          OpenAlias},             // passed
    {"-am",     0,          AliasMembers},          // passed
    {"-gam",    1,          GetAliasMembership},    // passed
    {"-ou",     1,          OpenUser},              // passed
    {"-ggu",    0,          GetGroupsForUser},      // passed
    {"-dau",    0,          DumpAllUsers},          // passed
    {"-dag",    0,          DumpAllGroups},         // passed
    {"-du",     0,          DumpUser},              // passed
    {"-dg",     0,          DumpGroup},             // passed
    {"-cu",     1,          CreateUser},            // passed
    {"-aam",    1,          AddAliasMember},        // passed
    {"-cg",     1,          CreateGroup},           // passed
    {"-ca",     1,          CreateAlias},           // passed
    {"-dd",     0,          DumpDomain},            // passed
    {"-c",      1,          Connect},               // passed
    {"-delu",   0,          DelUser},               // passed
    {"-dela",   0,          DelAlias},              // passed
    {"-delg",   0,          DelGroup},              // passed
    {"-slh",    0,          SetLogonHours},         // passed
    {"-spwd",   0,          SetPassword},           // passed
    {"-chgk",   0,          ChangeKey},
    {"-?",      0,          Help}
};

#define NUM_COMMANDS (sizeof(Commands) / sizeof(CommandPair))

// Global Data

SAM_HANDLE SamHandle;
SAM_HANDLE DomainHandle;
SAM_HANDLE GroupHandle;
SAM_HANDLE AliasHandle;
SAM_HANDLE UserHandle;
UNICODE_STRING ServerName;

NTSTATUS
Help(
    LPWSTR *Parameter
    )
{
    // BUG: Work in progress -- need better help message for samdsdrt.

    printf("Usage:\n");
    printf("\t-od       Open a domain\n");
    printf("\t-ed       Enumerate domains\n");
    printf("\t-ea       Enumerate accounts\n");
    printf("\t-qd       Show display information\n");
    printf("\t-og       Open a group\n");
    printf("\t-gm       Show group members\n");
    printf("\t-oa       Open an alias\n");
    printf("\t-am       Show alias members\n");
    printf("\t-gam      Show alias membership\n");
    printf("\t-ou       Open a user\n");
    printf("\t-ggu      Show a user's groups\n");
    printf("\t-dau      Show all users\n");
    printf("\t-dag      Show all groups\n");
    printf("\t-du       Show a user's attributes\n");
    printf("\t-dg       Show a group's attributes\n");
    printf("\t-cu       Create a user\n");
    printf("\t-aam      Add a member to an alias\n");
    printf("\t-cg       Create a group\n");
    printf("\t-ca       Create an alias\n");
    printf("\t-dd       Show a domain\n");
    printf("\t-c        Connect to a SAM server\n");
    printf("\t-delu     Delete a user\n");
    printf("\t-dela     Delete an alias\n");
    printf("\t-delg     Delete a group\n");
    printf("\t-slh      Set a user's logon hours\n");
    printf("\t-spwd     Set a user's password\n");
    printf("\t-?        This message, also see samdrt.cmd\n");

    return(STATUS_SUCCESS);
}

VOID
PrintTime (
    CHAR * String,
    PVOID Time
    )
{
    SYSTEMTIME st;

    FileTimeToSystemTime((PFILETIME)Time, &st);

    kdprint(("%s %d-%d-%d %d:%2.2d:%2.2d\n",
           String,
           st.wMonth,
           st.wDay,
           st.wYear,
           st.wHour,
           st.wMinute,
           st.wSecond));
}

VOID
PrintDeltaTime(
    IN LPSTR Message,
    IN PLARGE_INTEGER Time
    )
{
    ULONG Seconds;
    ULONG Minutes;
    ULONG Hours;
    ULONG Days;
    ULONG Chars;
    CHAR TimeBuffer[256] = "";
    LPSTR TimeString = TimeBuffer;
    LARGE_INTEGER DeltaTime;

    DeltaTime.QuadPart = -Time->QuadPart;

    Seconds = (ULONG) (DeltaTime.QuadPart / 10000000);

    Minutes = Seconds / 60;
    Hours = Minutes / 60;
    Days = Hours / 24;

    Hours = Hours % 24;
    Minutes = Minutes % 60;
    Seconds = Seconds % 60;

    if (Days >= 1)
    {
        Chars = sprintf(TimeString,"%d days ",Days);
        TimeString += Chars;
    }
    if (Hours >= 1 )
    {
        Chars = sprintf(TimeString,"%d hours ",Hours);
        TimeString += Chars;
    }

    if (Minutes >= 1 && Days == 0)
    {
        Chars = sprintf(TimeString,"%d minutes ",Minutes);
        TimeString += Chars;
    }

    if (Seconds >= 1 && (Days == 0) && (Hours == 0) )
    {
        Chars = sprintf(TimeString,"%d seconds ",Seconds);
        TimeString += Chars;
    }

    kdprint(("%s %s\n",Message,TimeBuffer));

}


NTSTATUS
Connect( LPWSTR * Parameter)
{
    OBJECT_ATTRIBUTES oa;
    NTSTATUS Status;

    RtlInitUnicodeString(
        &ServerName,
        Parameter[0]
        );

    InitializeObjectAttributes(&oa,NULL,0,NULL,NULL);

    Status = SamConnect(
                &ServerName,
                &SamHandle,
                MAXIMUM_ALLOWED,
                &oa);
    return(Status);
}

NTSTATUS
CloseSam()
{
    return(SamCloseHandle(SamHandle));
}



NTSTATUS
EnumDomains(
                LPWSTR * Parameter )
{
    NTSTATUS Status;
    SHORT Language;
    SAM_ENUMERATE_HANDLE Context = 0;
    PSAM_RID_ENUMERATION Buffer = NULL;
    ULONG Count = 0;
    ULONG i;

    Status = SamEnumerateDomainsInSamServer(
                    SamHandle,
                    &Context,
                    (PVOID *) &Buffer,
                    2000,
                    &Count
                    );

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }


    for (i = 0; i < Count ; i++ )
    {
        kdprint(("Domain = %wZ\n",&Buffer[i].Name));
    }
    SamFreeMemory(Buffer);
    return(STATUS_SUCCESS);
}

NTSTATUS
OpenDomain( LPWSTR * Parameter )
{
    GUID DomainGuid;
    BOOLEAN fBuiltin;
    NTSTATUS Status;
    SID *DomainSid = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    if (!_wcsicmp(Parameter[0],L"Builtin"))
    {
        fBuiltin = TRUE;
    }
    else if (!_wcsicmp(Parameter[0],L"Account"))
    {
        fBuiltin = FALSE;
    }
    else
    {
        kdprint(("Invalid domain to open: %ws\n",Parameter[0]));
        return(STATUS_UNSUCCESSFUL);
    }

    // Maximum SID size is 28 bytes, although domain SIDs are 24 bytes.

    DomainSid = (SID *)malloc(28);

    if (NULL == DomainSid)
    {
        return(STATUS_NO_MEMORY);
    }

    if (fBuiltin)
    {
        DomainSid->Revision = SID_REVISION;
        DomainSid->SubAuthorityCount = 1;
        DomainSid->IdentifierAuthority = NtAuthority;
        //DomainSid->ZerothSubAuthority = SECURITY_BUILTIN_DOMAIN_RID;
        DomainSid->SubAuthority[0] = SECURITY_BUILTIN_DOMAIN_RID;
    }
    else
    {
        LSA_HANDLE LsaHandle = NULL;
        OBJECT_ATTRIBUTES Oa;
        PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo = NULL;

        RtlZeroMemory(&Oa, sizeof(OBJECT_ATTRIBUTES));
        Status = LsaOpenPolicy(
                    &ServerName,
                    &Oa,
                    POLICY_VIEW_LOCAL_INFORMATION,
                    &LsaHandle
                    );
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed to open policy: 0x%x\n",Status));
            return(Status);
        }
        Status = LsaQueryInformationPolicy(
                    LsaHandle,
                    PolicyAccountDomainInformation,
                    (PVOID *) &DomainInfo
                    );
        LsaClose(LsaHandle);
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed to query account domain: 0x%x\n",Status));
            return(Status);
        }
        RtlCopyMemory(
            DomainSid,
            DomainInfo->DomainSid,
            RtlLengthSid(DomainInfo->DomainSid)
            );
        LsaFreeMemory(DomainInfo);
    }

    Status = SamOpenDomain(
                SamHandle,
                MAXIMUM_ALLOWED,
                (PSID)DomainSid,
                &DomainHandle
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to open domain: 0x%x\n",Status));
    }

    free(DomainSid);

    return(Status);

}

NTSTATUS
EnumAccounts(   LPWSTR * Parameter )
{
    ULONG PreferedMax = 100;
    NTSTATUS Status;
    SAM_ENUMERATE_HANDLE EnumContext = 0;
    ULONG CountReturned;

    PSAM_RID_ENUMERATION Accounts = NULL;

    swscanf(Parameter[0],L"%d",&PreferedMax);

    kdprint(("EnumAccounts: %d\n",PreferedMax));


    EnumContext = 0;
    ASSERT(DomainHandle != NULL);
    do
    {
        Status = SamEnumerateUsersInDomain(
                        DomainHandle,
                        &EnumContext,
                        0,
                        (PVOID *) &Accounts,
                        PreferedMax,
                        &CountReturned
                        );

        if (NT_SUCCESS(Status) && (Status != STATUS_NO_MORE_ENTRIES))
        {
            ULONG Index;
            UNICODE_STRING SidString;

            for (Index = 0; Index < CountReturned; Index++)
            {
                kdprint(("Account : %wZ 0x%x\n",&Accounts[Index].Name, Accounts[Index].RelativeId));
            }
            SamFreeMemory(Accounts);
        }
        else kdprint(("Failed to enumerate users: 0x%x\n",Status));
    } while (NT_SUCCESS(Status) && (Status != STATUS_SUCCESS) && (CountReturned != 0) );

    EnumContext = 0;
    do
    {
        Status = SamEnumerateGroupsInDomain(
                        DomainHandle,
                        &EnumContext,
                        (PVOID *) &Accounts,
                        PreferedMax,
                        &CountReturned
                        );

        if (NT_SUCCESS(Status) && (Status != STATUS_NO_MORE_ENTRIES))
        {
            ULONG Index;
            UNICODE_STRING SidString;

            for (Index = 0; Index < CountReturned; Index++)
            {
                kdprint(("Group : %wZ 0x%x\n",&Accounts[Index].Name, Accounts[Index].RelativeId));
            }
            SamFreeMemory(Accounts);
        }
        else kdprint(("Failed to enumerate Groups: 0x%x\n",Status));
    } while (NT_SUCCESS(Status)  && (CountReturned != 0) ); // && (Status != STATUS_SUCCESS)


    EnumContext = 0;
    do
    {
        Status = SamEnumerateAliasesInDomain(
                        DomainHandle,
                        &EnumContext,
                        (PVOID *) &Accounts,
                        PreferedMax,
                        &CountReturned
                        );

        if (NT_SUCCESS(Status) && (Status != STATUS_NO_MORE_ENTRIES))
        {
            ULONG Index;
            UNICODE_STRING SidString;

            for (Index = 0; Index < CountReturned; Index++)
            {
                kdprint(("Alias : %wZ 0x%x\n",&Accounts[Index].Name, Accounts[Index].RelativeId));
            }
            SamFreeMemory(Accounts);
        }
        else kdprint(("Failed to enumerate aliases: 0x%x\n",Status));
    } while (NT_SUCCESS(Status)  && (CountReturned != 0) ); // && (Status != STATUS_SUCCESS)



    return(Status);
}


NTSTATUS
QueryDisplay(   LPWSTR * Parameter )
{
    NTSTATUS Status;
    DOMAIN_DISPLAY_INFORMATION Type;
    PVOID Buffer = NULL;
    ULONG TotalAvailable = 0;
    ULONG TotalReturned = 0;
    ULONG ReturnedCount = 0;
    ULONG Index;
    ULONG SamIndex = 0;

    if (!_wcsicmp(Parameter[0],L"user"))
    {
        Type = DomainDisplayUser;
    } else if (!_wcsicmp(Parameter[0],L"Machine"))
    {
        Type = DomainDisplayMachine;
    } else if (!_wcsicmp(Parameter[0],L"Group"))
    {
        Type = DomainDisplayGroup;
    } else if (!_wcsicmp(Parameter[0],L"OemUser"))
    {
        Type = DomainDisplayOemUser;
    } else if (!_wcsicmp(Parameter[0],L"OemGroup"))
    {
        Type = DomainDisplayOemGroup;
    } else {
        kdprint(("Invalid parameter %ws\n", Parameter[0]));
        return(STATUS_INVALID_PARAMETER);
    }

    do
    {
        Status = SamQueryDisplayInformation(
                    DomainHandle,
                    Type,
                    SamIndex,
                    5,
                    1000,
                    &TotalAvailable,
                    &TotalReturned,
                    &ReturnedCount,
                    &Buffer
                    );

        if (NT_SUCCESS(Status) && (ReturnedCount > 0))
        {
            kdprint(("Total returned = %d\t total available = %d\n",
                TotalReturned, TotalAvailable));
            switch(Type) {
            case DomainDisplayUser:
                {
                    PDOMAIN_DISPLAY_USER Users = (PDOMAIN_DISPLAY_USER) Buffer;
                    for (Index = 0; Index < ReturnedCount ; Index++ )
                    {
                        kdprint(("User %d: Index %d\n Rid 0x%x\n Control 0x%x\n name %wZ\n Comment %wZ\n Full Name %wZ\n",
                            Index,
                            Users[Index].Index,
                            Users[Index].Rid,
                            Users[Index].AccountControl,
                            &Users[Index].LogonName,
                            &Users[Index].AdminComment,
                            &Users[Index].FullName
                            ));
                    }
                    break;
                }
            case DomainDisplayGroup:
                {
                    PDOMAIN_DISPLAY_GROUP Groups = (PDOMAIN_DISPLAY_GROUP) Buffer;
                    for (Index = 0; Index < ReturnedCount ; Index++ )
                    {
                        kdprint(("Group %d\n Index %d\n Rid 0x%x\n Attributes 0x%x\n name %wZ\n Comment %wZ\n",
                            Index,
                            Groups[Index].Index,
                            Groups[Index].Rid,
                            Groups[Index].Attributes,
                            &Groups[Index].Group,
                            &Groups[Index].Comment
                            ));

                    }
                    break;
                }
            case DomainDisplayMachine:
                {
                    PDOMAIN_DISPLAY_MACHINE Machines = (PDOMAIN_DISPLAY_MACHINE) Buffer;
                    for (Index = 0; Index < ReturnedCount ; Index++ )
                    {
                        kdprint(("Machine %d\n Index %d\n Rid 0x%x\n Control 0x%x\n Name %wZ\n Comment %wZ\n",
                            Index,
                            Machines[Index].Index,
                            Machines[Index].Rid,
                            Machines[Index].AccountControl,
                            &Machines[Index].Machine,
                            &Machines[Index].Comment
                            ));
                    }
                    break;
                }
            case DomainDisplayOemUser:
                {
                    PDOMAIN_DISPLAY_OEM_USER OemUsers = (PDOMAIN_DISPLAY_OEM_USER) Buffer;
                    for (Index = 0; Index < ReturnedCount ; Index++ )
                    {
                        kdprint(("OemUser %d\n Index %d\n Name %Z\n",
                            Index,
                            OemUsers[Index].Index,
                            &OemUsers[Index].User
                            ));
                    }
                    break;
                }
            case DomainDisplayOemGroup:
                {
                    PDOMAIN_DISPLAY_OEM_GROUP OemGroups = (PDOMAIN_DISPLAY_OEM_GROUP) Buffer;
                    for (Index = 0; Index < ReturnedCount ; Index++ )
                    {
                        kdprint(("OemGroup %d\n Index %d\n Name %Z\n",
                            Index,
                            OemGroups[Index].Index,
                            &OemGroups[Index].Group
                            ));
                    }
                    break;
                }

            }
            SamFreeMemory(Buffer);
            SamIndex += ReturnedCount;
        }


    } while (NT_SUCCESS(Status) && (ReturnedCount > 0));
    kdprint(("QDI returned 0x%x\n",Status));

    return(Status);


}

NTSTATUS
OpenGroup(  LPWSTR * Parameter)
{
    PSID_NAME_USE Use = NULL;
    PULONG Rid = NULL;
    NTSTATUS Status;
    UNICODE_STRING GroupName;
    ULONG RelativeId = 0;

//    swscanf(Parameter[0],L"%x",&RelativeId);
    if (RelativeId == 0)
    {
        RtlInitUnicodeString(
            &GroupName,
            Parameter[0]
            );

        kdprint(("Looking up group %wZ\n",&GroupName));

        Status = SamLookupNamesInDomain(
                    DomainHandle,
                    1,
                    &GroupName,
                    &Rid,
                    &Use
                    );
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed to lookup group: 0x%x\n",Status));
            return(Status);
        }
        RelativeId = *Rid;
        SamFreeMemory(Rid);
        SamFreeMemory(Use);
    }

    kdprint(("Opening Group 0x%x\n",RelativeId));
    Status= SamOpenGroup(
                DomainHandle,
                MAXIMUM_ALLOWED, // GROUP_LIST_MEMBERS | GROUP_READ_INFORMATION,
                RelativeId,
                &GroupHandle
                );

    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to open group: 0x%x\n",Status));
    }
    return(Status);
}

NTSTATUS
GroupMembers(LPWSTR * Parameter)
{
    NTSTATUS Status;
    ULONG MembershipCount;
    PULONG Attributes = NULL;
    PULONG Rids = NULL;
    ULONG Index;

    Status = SamGetMembersInGroup(
                GroupHandle,
                &Rids,
                &Attributes,
                &MembershipCount
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get members in group: 0x%x\n",Status));
        return(Status);
    }

    for (Index = 0; Index < MembershipCount ; Index++ )
    {
        kdprint(("Member %d: rid 0x%x, attributes 0x%x\n",
                Index,Rids[Index],Attributes[Index]));
    }
    SamFreeMemory(Rids);
    SamFreeMemory(Attributes);
    return(STATUS_SUCCESS);

}


NTSTATUS
OpenAlias(  LPWSTR * Parameter)
{
    PSID_NAME_USE Use = NULL;
    PULONG Rid = NULL;
    NTSTATUS Status;
    UNICODE_STRING AliasName;
    ULONG RelativeId;

    #if 0
    swscanf(Parameter[0],L"%x",&RelativeId);
    if (RelativeId == 0)
    {
        RtlInitUnicodeString(
            &AliasName,
            Parameter[0]
            );

        kdprint(("Looking up Alias %wZ\n",&AliasName));

        // Find Alias RIDs for each name passed in.

        Status = SamLookupNamesInDomain(
                    DomainHandle,
                    1,
                    &AliasName, // IN
                    &Rid,       // OUT
                    &Use        // OUT
                    );
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed to lookup Alias: 0x%x\n",Status));
            return(Status);
        }
        RelativeId = *Rid;
        SamFreeMemory(Rid);
        SamFreeMemory(Use);
    }

    kdprint(("Opening Alias 0x%x\n",RelativeId));
    #endif

    RtlInitUnicodeString(
        &AliasName,
        Parameter[0]
        );

    kdprint(("Looking up Alias %wZ\n",&AliasName));

    // Find Alias RIDs for each name passed in.

    Status = SamLookupNamesInDomain(
                DomainHandle,
                1,
                &AliasName, // IN
                &Rid,       // OUT
                &Use        // OUT
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to lookup Alias: 0x%x\n",Status));
        return(Status);
    }
    RelativeId = *Rid;
    SamFreeMemory(Rid);
    SamFreeMemory(Use);

    Status= SamOpenAlias(
                DomainHandle,

                // The alias was created with MAXIMUM_ALLOWED, which must be
                // the same access specified in the open call.

                // ALIAS_LIST_MEMBERS | ALIAS_ADD_MEMBER | ALIAS_REMOVE_MEMBER,
                MAXIMUM_ALLOWED,
                RelativeId,
                &AliasHandle
                );

    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to open alias: 0x%x\n",Status));
    }
    return(Status);
}

NTSTATUS
AliasMembers(LPWSTR * Parameter)
{
    NTSTATUS Status;
    ULONG MembershipCount;
    PSID * Members = NULL;
    ULONG Index;
    UNICODE_STRING Sid;

    Status = SamGetMembersInAlias(
                AliasHandle,
                &Members,
                &MembershipCount
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get members in Alias: 0x%x\n",Status));
        return(Status);
    }

    for (Index = 0; Index < MembershipCount ; Index++ )
    {
        RtlConvertSidToUnicodeString(
            &Sid,
            Members[Index],
            TRUE
            );
        kdprint(("Member %d: sid %wZ\n",
                Index,&Sid));
        RtlFreeUnicodeString(&Sid);
    }
    SamFreeMemory(Members);
    return(STATUS_SUCCESS);

}


NTSTATUS
GetAliasMembership(LPWSTR * Parameter)
{
    NTSTATUS Status;

    // NT5 SIDs are a maximum of 28 bytes.

    BYTE Buffer[28];
    PSID SidAddress = (PSID) Buffer;
    ULONG SidLength = sizeof(Buffer);
    WCHAR ReferencedDomainName[256];
    ULONG DomainNameLength = 256;
    SID_NAME_USE SidUse;
    ULONG Index;
    UNICODE_STRING Name;
    OBJECT_ATTRIBUTES Oa;
    LSA_HANDLE LsaHandle = NULL;
    ULONG MembershipCount;
    PULONG AliasList = NULL;

    kdprint(("Looking up groups for user %ws\n",Parameter[0]));

    if (!LookupAccountNameW(NULL,
                            Parameter[0],
                            SidAddress,
                            &SidLength,
                            ReferencedDomainName,
                            &DomainNameLength,
                            &SidUse))
    {
        kdprint(("Failed to lookup account sid: %d\n",GetLastError()));
        return(STATUS_UNSUCCESSFUL);
    }

    Status = SamGetAliasMembership(DomainHandle,
                                   1,
                                   &SidAddress,
                                   &MembershipCount,
                                   &AliasList);

    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get alises : 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Alias membership count = %lu\n", MembershipCount));

    for (Index = 0; Index < MembershipCount ; Index++ )
    {
        kdprint(("Alias Member %d: rid 0x%x\n", Index, AliasList[Index]));
    }

    SamFreeMemory(AliasList);
    return(STATUS_SUCCESS);
}

NTSTATUS
GetAccountRid( LPWSTR Parameter,
               PULONG RelativeId)
{

    PSID_NAME_USE Use = NULL;
    PULONG Rid = NULL;
    NTSTATUS Status;
    UNICODE_STRING UserName;

    RtlInitUnicodeString(
        &UserName,
        Parameter
        );

    kdprint(("Looking up User %wZ\n",&UserName));

    Status = SamLookupNamesInDomain(
                DomainHandle,
                1,
                &UserName,
                &Rid,
                &Use
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to lookup User: 0x%x\n",Status));
        return(Status);
    }
    *RelativeId = *Rid;
    SamFreeMemory(Rid);
    SamFreeMemory(Use);

    return(STATUS_SUCCESS);
}
NTSTATUS
OpenUser(  LPWSTR * Parameter)
{
    PSID_NAME_USE Use = NULL;
    PULONG Rid = NULL;
    NTSTATUS Status;
    UNICODE_STRING UserName;
    ULONG RelativeId = 0;

    Status = GetAccountRid(Parameter[0],&RelativeId);
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get account rid: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Opening User 0x%x\n",RelativeId));
    Status= SamOpenUser(
                DomainHandle,
                MAXIMUM_ALLOWED,
                RelativeId,
                &UserHandle
                );

    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to open User: 0x%x\n",Status));
    }
    return(Status);
}

NTSTATUS
DelUser( LPWSTR * Parameter)
{
    NTSTATUS Status;

    Status = SamDeleteUser(UserHandle);
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to delete user: 0x%x\n",Status));
    }
    else
    {
        // If successfully deleted, set the handle to NULL so that the
        // cleanup routine at the end of the test won't try to close an
        // invalid handle.

        UserHandle = NULL;
    }
    return(Status);
}

NTSTATUS
DelGroup( LPWSTR * Parameter)
{
    NTSTATUS Status;

    Status = SamDeleteGroup(GroupHandle);
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to delete group: 0x%x\n",Status));
    }
    else
    {
        // If successfully deleted, set the handle to NULL so that the
        // cleanup routine at the end of the test won't try to close an
        // invalid handle.

        GroupHandle = NULL;
    }
    return(Status);
}

NTSTATUS
DelAlias( LPWSTR * Parameter)
{
    NTSTATUS Status;

    Status = SamDeleteAlias(AliasHandle);
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to delete alias: 0x%x\n",Status));
    }
    else
    {
        // If successfully deleted, set the handle to NULL so that the
        // cleanup routine at the end of the test won't try to close an
        // invalid handle.

        AliasHandle = NULL;
    }
    return(Status);
}

NTSTATUS
CreateUser(  LPWSTR * Parameter)
{
    PSID_NAME_USE Use = NULL;
    PULONG Rid = NULL;
    NTSTATUS Status;
    UNICODE_STRING UserName;
    ULONG RelativeId = 0;
    ACCESS_MASK GrantedAccess;


    RtlInitUnicodeString(
        &UserName,
        Parameter[0]
        );

    kdprint(("Creating User %wZ\n",&UserName));

    Status= SamCreateUser2InDomain(
                DomainHandle,
                &UserName,
                USER_NORMAL_ACCOUNT,
                MAXIMUM_ALLOWED,
                &UserHandle,
                &GrantedAccess,
                &RelativeId
                );

    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to create User: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("Created user with rid 0x%x, access 0x%x\n",
        RelativeId, GrantedAccess));
    return(Status);
}

NTSTATUS
CreateGroup(  LPWSTR * Parameter)
{
    PSID_NAME_USE Use = NULL;
    PULONG Rid = NULL;
    NTSTATUS Status;
    UNICODE_STRING GroupName;
    ULONG RelativeId = 0;


    RtlInitUnicodeString(
        &GroupName,
        Parameter[0]
        );

    kdprint(("Creating Group %wZ\n",&GroupName));

    Status= SamCreateGroupInDomain(
                DomainHandle,
                &GroupName,
                MAXIMUM_ALLOWED,
                &GroupHandle,
                &RelativeId
                );

    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to create Group: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("Created Group with rid 0x%x, access 0x%x\n",
        RelativeId));
    return(Status);
}

NTSTATUS
CreateAlias(  LPWSTR * Parameter)
{
    PSID_NAME_USE Use = NULL;
    PULONG Rid = NULL;
    NTSTATUS Status;
    UNICODE_STRING AliasName;
    ULONG RelativeId = 0;


    RtlInitUnicodeString(
        &AliasName,
        Parameter[0]
        );

    kdprint(("Creating Alias %wZ\n",&AliasName));

    Status= SamCreateAliasInDomain(
                DomainHandle,
                &AliasName,
                MAXIMUM_ALLOWED,
                &AliasHandle,
                &RelativeId
                );

    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to create Alias: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("Created Alias with rid 0x%x, access 0x%x\n", RelativeId));
    return(Status);
}



NTSTATUS
GetGroupsForUser(LPWSTR * Parameter)
{
    NTSTATUS Status;
    ULONG MembershipCount;
    PULONG Attributes = NULL;
    PULONG Rids = NULL;
    ULONG Index;
    PGROUP_MEMBERSHIP Groups = NULL;

    Status = SamGetGroupsForUser(
                UserHandle,
                &Groups,
                &MembershipCount
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get groups for user: 0x%x\n",Status));
        return(Status);
    }

    for (Index = 0; Index < MembershipCount ; Index++ )
    {
        kdprint(("Member %d: rid 0x%x, attributes 0x%x\n",
                Index,Groups[Index].RelativeId, Groups[Index].Attributes ));
    }
    SamFreeMemory(Groups);
    return(STATUS_SUCCESS);

}

VOID
PrintLogonHours(
    CHAR * String,
    PLOGON_HOURS LogonHours
    )
{
    int Index;
    kdprint(("%s",String));
    for (Index = 0; Index < (LogonHours->UnitsPerWeek + 7) / 8 ;Index++ )
    {
        kdprint(("0x%2.2x ",LogonHours->LogonHours[Index]));
    }
    kdprint(("\n"));
}


NTSTATUS
DumpUser(LPWSTR * Parameter)
{
    NTSTATUS Status;
    PUSER_ALL_INFORMATION UserAll = NULL;
    PUSER_GENERAL_INFORMATION UserGeneral = NULL;
    PUSER_PREFERENCES_INFORMATION UserPreferences = NULL;
    PUSER_LOGON_INFORMATION UserLogon = NULL;
    PUSER_ACCOUNT_INFORMATION UserAccount = NULL;
    PUSER_ACCOUNT_NAME_INFORMATION UserAccountName = NULL;
    PUSER_FULL_NAME_INFORMATION UserFullName = NULL;
    PUSER_NAME_INFORMATION UserName = NULL;
    PUSER_PRIMARY_GROUP_INFORMATION UserPrimary = NULL;
    PUSER_HOME_INFORMATION UserHome = NULL;
    PUSER_SCRIPT_INFORMATION UserScript = NULL;
    PUSER_PROFILE_INFORMATION UserProfile = NULL;
    PUSER_ADMIN_COMMENT_INFORMATION UserAdminComment = NULL;
    PUSER_WORKSTATIONS_INFORMATION UserWksta = NULL;
    PUSER_CONTROL_INFORMATION UserControl = NULL;
    PUSER_EXPIRES_INFORMATION UserExpires = NULL;
    PUSER_LOGON_HOURS_INFORMATION UserLogonHours = NULL;

    kdprint(("\nDumpUser.\n"));
    Status = SamQueryInformationUser(
                UserHandle,
                UserAllInformation,
                (PVOID *) &UserAll
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user all: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("UserAll:\n"));
    PrintTime("\tLastLogon = ",&UserAll->LastLogon);
    PrintTime("\tLastLogoff = ",&UserAll->LastLogoff);
    PrintTime("\tPasswordLastSet = ",&UserAll->PasswordLastSet);
    PrintTime("\tAccountExpires = ",&UserAll->AccountExpires);
    PrintTime("\tPasswordCanChange = ",&UserAll->PasswordCanChange);
    PrintTime("\tPasswordMustChange = ",&UserAll->PasswordMustChange);
    kdprint(("\tUserName = %wZ\n",&UserAll->UserName));
    kdprint(("\tFullName = %wZ\n",&UserAll->FullName));
    kdprint(("\tHomeDirectory = %wZ\n",&UserAll->HomeDirectory));
    kdprint(("\tHomeDirectoryDrive = %wZ\n",&UserAll->HomeDirectoryDrive));
    kdprint(("\tScriptPath = %wZ\n",&UserAll->ScriptPath));
    kdprint(("\tProfilePath = %wZ\n",&UserAll->ProfilePath));
    kdprint(("\tAdminComment = %wZ\n",&UserAll->AdminComment));
    kdprint(("\tWorkStations = %wZ\n",&UserAll->WorkStations));
    kdprint(("\tUserComment = %wZ\n",&UserAll->UserComment));
    kdprint(("\tParameters = %wZ\n",&UserAll->Parameters));
    kdprint(("\tUserId = 0x%x\n",UserAll->UserId));
    kdprint(("\tPrimaryGroupId = 0x%x\n",UserAll->PrimaryGroupId));
    kdprint(("\tUserAccountControl = 0x%x\n",UserAll->UserAccountControl));
    kdprint(("\tWhichFields = 0x%x\n",UserAll->WhichFields));
    PrintLogonHours("\tLogonHours = ",&UserAll->LogonHours);
    kdprint(("\tLogonCount = %d\n",UserAll->LogonCount));
    kdprint(("\tCountryCode = %d\n",UserAll->CountryCode));
    kdprint(("\tCodePage = %d\n",UserAll->CodePage));

    SamFreeMemory(UserAll);

    Status = SamQueryInformationUser(
                UserHandle,
                UserGeneralInformation,
                (PVOID *) &UserGeneral
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user general: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserGeneral:\n"));
    kdprint(("\tUserName = %wZ\n",&UserGeneral->UserName));
    kdprint(("\tFullName = %wZ\n",&UserGeneral->FullName));
    kdprint(("\tPrimaryGroupId = 0x%x\n",UserGeneral->PrimaryGroupId));
    kdprint(("\tAdminComment = 0x%x\n",&UserGeneral->AdminComment));
    kdprint(("\tUserComment = 0x%x\n",&UserGeneral->UserComment));

    SamFreeMemory(UserGeneral);

    Status = SamQueryInformationUser(
                UserHandle,
                UserPreferencesInformation,
                (PVOID *) &UserPreferences
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user preferences: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserPreferences:\n"));
    kdprint(("\tUserComment = %wZ\n",&UserPreferences->UserComment));
    kdprint(("\tReserved1 = %wZ\n",&UserPreferences->Reserved1));
    kdprint(("\tCountryCode = %d\n",&UserPreferences->CountryCode));
    kdprint(("\tCodePage = %d\n",&UserPreferences->CodePage));

    SamFreeMemory(UserPreferences);

    Status = SamQueryInformationUser(
                UserHandle,
                UserLogonInformation,
                (PVOID *) &UserLogon
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user Logon: 0x%x\n",Status));
        return(Status);
    }


    kdprint(("UserLogon:\n"));
    kdprint(("\tUserName = %wZ\n",&UserLogon->UserName));
    kdprint(("\tFullName = %wZ\n",&UserLogon->FullName));
    kdprint(("\tUserId = 0x%x\n",UserLogon->UserId));
    kdprint(("\tPrimaryGroupId = 0x%x\n",UserLogon->PrimaryGroupId));
    kdprint(("\tHomeDirectory = %wZ\n",&UserLogon->HomeDirectory));
    kdprint(("\tHomeDirectoryDrive = %wZ\n",&UserLogon->HomeDirectoryDrive));
    kdprint(("\tScriptPath = %wZ\n",&UserLogon->ScriptPath));
    kdprint(("\tProfilePath = %wZ\n",&UserLogon->ProfilePath));
    kdprint(("\tWorkStations = %wZ\n",&UserLogon->WorkStations));
    PrintTime("\tLastLogon = ",&UserLogon->LastLogon);
    PrintTime("\tLastLogoff = ",&UserLogon->LastLogoff);
    PrintTime("\tPasswordLastSet = ",&UserLogon->PasswordLastSet);
    PrintTime("\tPasswordCanChange = ",&UserLogon->PasswordCanChange);
    PrintTime("\tPasswordMustChange = ",&UserLogon->PasswordMustChange);
    PrintLogonHours("\tLogonHours = ",&UserLogon->LogonHours);
    kdprint(("\tBadPasswordCount = %d\n",UserLogon->BadPasswordCount));
    kdprint(("\tLogonCount = %d\n",UserLogon->LogonCount));
    kdprint(("\tUserAccountControl = 0x%x\n",UserLogon->UserAccountControl));

    SamFreeMemory(UserLogon);

    Status = SamQueryInformationUser(
                UserHandle,
                UserAccountInformation,
                (PVOID *) &UserAccount
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user account: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserAccount:\n"));
    kdprint(("\tUserName = %wZ\n",&UserAccount->UserName));
    kdprint(("\tFullName = %wZ\n",&UserAccount->FullName));
    kdprint(("\tUserId = 0x%x\n",UserAccount->UserId));
    kdprint(("\tPrimaryGroupId = 0x%x\n",UserAccount->PrimaryGroupId));
    kdprint(("\tHomeDirectory = %wZ\n",&UserAccount->HomeDirectory));
    kdprint(("\tHomeDirectoryDrive = %wZ\n",&UserAccount->HomeDirectoryDrive));
    kdprint(("\tScriptPath = %wZ\n",&UserAccount->ScriptPath));
    kdprint(("\tProfilePath = %wZ\n",&UserAccount->ProfilePath));
    kdprint(("\tAdminComment = %wZ\n",&UserAccount->AdminComment));
    kdprint(("\tWorkStations = %wZ\n",&UserAccount->WorkStations));
    PrintTime("\tLastLogon = ",&UserAccount->LastLogon);
    PrintTime("\tLastLogoff = ",&UserAccount->LastLogoff);
    PrintLogonHours("\tLogonHours = ",&UserAccount->LogonHours);
    kdprint(("\tBadPasswordCount = %d\n",UserAccount->BadPasswordCount));
    kdprint(("\tLogonCount = %d\n",UserAccount->LogonCount));
    PrintTime("\tPasswordLastSet = ",&UserAccount->PasswordLastSet);
    PrintTime("\tAccountExpires = ",&UserAccount->AccountExpires);
    kdprint(("\tUserAccountControl = 0x%x\n",UserAccount->UserAccountControl));

    SamFreeMemory(UserAccount);

    Status = SamQueryInformationUser(
                UserHandle,
                UserAccountNameInformation,
                (PVOID *) &UserAccountName
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user account name: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserAccountName:\n"));
    kdprint(("\tUserName = %wZ\n",&UserAccountName->UserName));
    SamFreeMemory(UserAccountName);

    Status = SamQueryInformationUser(
                UserHandle,
                UserFullNameInformation,
                (PVOID *) &UserFullName
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user full name: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserFullName:\n"));
    kdprint(("\tFullName = %wZ\n",&UserFullName->FullName));
    SamFreeMemory(UserFullName);

    Status = SamQueryInformationUser(
                UserHandle,
                UserNameInformation,
                (PVOID *) &UserName
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user name: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserName:\n"));
    kdprint(("\tUserName = %wZ\n",&UserName->UserName));
    kdprint(("\tFullName = %wZ\n",&UserName->FullName));
    SamFreeMemory(UserName);

    Status = SamQueryInformationUser(
                UserHandle,
                UserPrimaryGroupInformation,
                (PVOID *) &UserPrimary
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user all: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("UserPrimaryGroup:\n"));
    kdprint(("PrimaryGroupid = 0x%x\n",UserPrimary->PrimaryGroupId));
    SamFreeMemory(UserPrimary);

    Status = SamQueryInformationUser(
                UserHandle,
                UserHomeInformation,
                (PVOID *) &UserHome
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user home: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("UserHome:\n"));
    kdprint(("\tHomeDirectory = %wZ\n",&UserHome->HomeDirectory));
    kdprint(("\tHomeDirectoryDrive = %wZ\n",&UserHome->HomeDirectoryDrive));

    SamFreeMemory(UserHome);

    Status = SamQueryInformationUser(
                UserHandle,
                UserScriptInformation,
                (PVOID *) &UserScript
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user Script: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("UserScript:\n"));
    kdprint(("\tScriptPath = %wZ\n",&UserScript->ScriptPath));

    SamFreeMemory(UserScript);

    Status = SamQueryInformationUser(
                UserHandle,
                UserProfileInformation,
                (PVOID *) &UserProfile
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user Profile: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("UserProfile:\n"));
    kdprint(("\tProfilePath = %wZ\n",&UserProfile->ProfilePath));

    SamFreeMemory(UserProfile);
    Status = SamQueryInformationUser(
                UserHandle,
                UserAdminCommentInformation,
                (PVOID *) &UserAdminComment
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user AdminComment: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("UserAdminComment:\n"));
    kdprint(("\tAdminComment = %wZ\n",&UserAdminComment->AdminComment));
    SamFreeMemory(UserAdminComment);

    Status = SamQueryInformationUser(
                UserHandle,
                UserWorkStationsInformation,
                (PVOID *) &UserWksta
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user wksta: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserWorkStations:\n"));
    kdprint(("\tWorkStations = %wZ\n",&UserWksta->WorkStations));
    SamFreeMemory(UserWksta);

    Status = SamQueryInformationUser(
                UserHandle,
                UserControlInformation,
                (PVOID *) &UserControl
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user Control: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserControl:\n"));
    kdprint(("\tUserAccountControl = 0x%x\n",UserControl->UserAccountControl));
    SamFreeMemory(UserControl);

    Status = SamQueryInformationUser(
                UserHandle,
                UserExpiresInformation,
                (PVOID *) &UserExpires
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user Expires: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("UserExpires:\n"));
    PrintTime("\tAccountExpires = ",&UserExpires->AccountExpires);
    SamFreeMemory(UserExpires);

    Status = SamQueryInformationUser(
                UserHandle,
                UserLogonHoursInformation,
                (PVOID *) &UserLogonHours
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query user LogonHours: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("UserLogonHours:\n"));
    PrintLogonHours("\tLogonHours = ",&UserLogonHours->LogonHours);

    SamFreeMemory(UserLogonHours);


    return(STATUS_SUCCESS);
}

NTSTATUS
DumpGroup(LPWSTR * Parameter)
{
    NTSTATUS Status;
    PGROUP_GENERAL_INFORMATION General = NULL;
    PGROUP_NAME_INFORMATION Name = NULL;
    PGROUP_ATTRIBUTE_INFORMATION Attribute = NULL;
    PGROUP_ADM_COMMENT_INFORMATION AdmComment = NULL;

    kdprint(("\nDumpGroup.\n"));
    Status = SamQueryInformationGroup(
                GroupHandle,
                GroupGeneralInformation,
                (PVOID *) &General
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get group general information: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Group General.Name = %wZ\n",&General->Name));
    kdprint(("Group General.Attributes = 0x%x\n",General->Attributes));
    kdprint(("Group general.memberCount = %d\n",General->MemberCount));
    kdprint(("Group general.AdminComment = %wZ\n",&General->AdminComment));
    SamFreeMemory(General);

    Status = SamQueryInformationGroup(
                GroupHandle,
                GroupNameInformation,
                (PVOID *) &Name
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get group name information: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Group Name.Name = %wZ\n",&Name->Name));
    SamFreeMemory(Name);

    Status = SamQueryInformationGroup(
                GroupHandle,
                GroupAttributeInformation,
                (PVOID *) &Attribute
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get group Attribute information: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Group Attribute.Attributes = 0x%x\n",Attribute->Attributes));
    SamFreeMemory(Attribute);

    Status = SamQueryInformationGroup(
                GroupHandle,
                GroupAdminCommentInformation,
                (PVOID *) &AdmComment
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to get group admin comment information: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Group Admin comment.AdminComment = %wZ\n",&AdmComment->AdminComment));
    SamFreeMemory(AdmComment);

    return(STATUS_SUCCESS);
}

NTSTATUS
DumpAllGroups(LPWSTR * Parameter)
{
    // ULONG PreferedMax = 1000;
    ULONG PreferedMax = 36;
    NTSTATUS Status,EnumStatus;
    SAM_ENUMERATE_HANDLE EnumContext = 0;
    ULONG CountReturned;
    LPWSTR GroupName[1];

    PSAM_RID_ENUMERATION Accounts = NULL;


    GroupName[0] = (LPWSTR) malloc(128);
    if (NULL == GroupName[0])
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    kdprint(("DumpAllGroups:\n"));


    EnumContext = 0;
    ASSERT(DomainHandle != NULL);
    do
    {
        EnumStatus = SamEnumerateGroupsInDomain(
                        DomainHandle,
                        &EnumContext,
                        (PVOID *) &Accounts,
                        PreferedMax,
                        &CountReturned
                        );

        if (NT_SUCCESS(EnumStatus) && (EnumStatus != STATUS_NO_MORE_ENTRIES))
        {
            ULONG Index;
            UNICODE_STRING SidString;

            for (Index = 0; Index < CountReturned; Index++)
            {
                RtlCopyMemory(
                    GroupName[0],
                    Accounts[Index].Name.Buffer,
                    Accounts[Index].Name.Length
                    );
                GroupName[0][Accounts[Index].Name.Length/sizeof(WCHAR)] = L'\0';

                Status = OpenGroup(GroupName);
                if (!NT_SUCCESS(Status))
                {
                    break;
                }
                Status = DumpGroup(NULL);
                SamCloseHandle(GroupHandle);
                GroupHandle = NULL;

            }
            SamFreeMemory(Accounts);
        }
        else kdprint(("Failed to enumerate Groups: 0x%x\n",Status));
    } while (NT_SUCCESS(EnumStatus) && (EnumStatus != STATUS_SUCCESS) && (CountReturned != 0) );

    free(GroupName[0]);
    return(STATUS_SUCCESS);
}

NTSTATUS
DumpAllUsers(LPWSTR * Parameter)
{
    ULONG PreferedMax = 1000;
    NTSTATUS Status,EnumStatus;
    SAM_ENUMERATE_HANDLE EnumContext = 0;
    ULONG CountReturned;
    LPWSTR UserName[1];

    PSAM_RID_ENUMERATION Accounts = NULL;


    UserName[0] = (LPWSTR) malloc(128);
    if (NULL == UserName[0])
    {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    kdprint(("DumpAllUsers:\n"));


    EnumContext = 0;
    ASSERT(DomainHandle != NULL);
    do
    {
        EnumStatus = SamEnumerateUsersInDomain(
                        DomainHandle,
                        &EnumContext,
                        0,
                        (PVOID *) &Accounts,
                        PreferedMax,
                        &CountReturned
                        );

        if (NT_SUCCESS(EnumStatus) && (EnumStatus != STATUS_NO_MORE_ENTRIES))
        {
            ULONG Index;
            UNICODE_STRING SidString;

            for (Index = 0; Index < CountReturned; Index++)
            {
                RtlCopyMemory(
                    UserName[0],
                    Accounts[Index].Name.Buffer,
                    Accounts[Index].Name.Length
                    );
                UserName[0][Accounts[Index].Name.Length/sizeof(WCHAR)] = L'\0';

                Status = OpenUser(UserName);
                if (!NT_SUCCESS(Status))
                {
                    break;
                }
                Status = DumpUser(NULL);
                Status = GetGroupsForUser(NULL);
                SamCloseHandle(UserHandle);
                UserHandle = NULL;

            }
            SamFreeMemory(Accounts);
        }
        else kdprint(("Failed to enumerate users: 0x%x\n",Status));
    } while (NT_SUCCESS(EnumStatus) && (EnumStatus != STATUS_SUCCESS) && (CountReturned != 0) );

    free(UserName[0]);
    return(STATUS_SUCCESS);
}

NTSTATUS
AddAliasMember( LPWSTR * Parameter )
{
    BYTE Buffer[100];
    PSID AccountSid = Buffer;
    ULONG SidLen = 100;
    SID_NAME_USE Use;
    WCHAR ReferencedDomain[100];
    ULONG DomainLen = 100;
    NTSTATUS Status;

    kdprint(("Adding account %ws to alias\n",Parameter[0]));
    if (!LookupAccountNameW(
            NULL,
            Parameter[0],
            AccountSid,
            &SidLen,
            ReferencedDomain,
            &DomainLen,
            &Use))
    {
        kdprint(("Failed to lookup account name: %d\n",GetLastError()));
        return(STATUS_UNSUCCESSFUL);
    }

    Status = SamAddMemberToAlias(
                AliasHandle,
                AccountSid
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to add member to alias: 0x%x\n",Status));
    }
    return(Status);
}

NTSTATUS
DumpDomain( LPWSTR * Parameter )
{
    NTSTATUS Status;
    PDOMAIN_PASSWORD_INFORMATION Password = NULL;
    PDOMAIN_GENERAL_INFORMATION General = NULL;
    PDOMAIN_LOGOFF_INFORMATION Logoff = NULL;
    PDOMAIN_OEM_INFORMATION Oem = NULL;
    PDOMAIN_NAME_INFORMATION Name = NULL;
    PDOMAIN_REPLICATION_INFORMATION Replica = NULL;
    PDOMAIN_SERVER_ROLE_INFORMATION ServerRole = NULL;
    PDOMAIN_MODIFIED_INFORMATION Modified = NULL;
    PDOMAIN_STATE_INFORMATION State = NULL;
    PDOMAIN_GENERAL_INFORMATION2 General2 = NULL;
    PDOMAIN_LOCKOUT_INFORMATION Lockout = NULL;
    PDOMAIN_MODIFIED_INFORMATION2 Modified2 = NULL;


    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainPasswordInformation,
                (PVOID *) &Password
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query password information: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Password:\n"));
    kdprint(("\tMinPasswordLength = %d\n",Password->MinPasswordLength));
    kdprint(("\tPasswordHistoryLength = %d\n",Password->PasswordHistoryLength));
    kdprint(("\tPasswordProperties = 0x%x\n",Password->PasswordProperties));
    PrintDeltaTime("\tMaxPasswordAge = ",&Password->MaxPasswordAge);
    PrintDeltaTime("\tMinPasswordAge = ",&Password->MinPasswordAge);

    SamFreeMemory(Password);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainGeneralInformation,
                (PVOID *) &General
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query general: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("General:\n"));
    PrintDeltaTime("\t ForceLogoff = ",&General->ForceLogoff);
    kdprint(("\t OemInformation = %wZ\n",&General->OemInformation));
    kdprint(("\t DomainName = %wZ\n",&General->DomainName));
    kdprint(("\t ReplicaSourceNodeName =%wZ\n",&General->ReplicaSourceNodeName));
    kdprint(("\t DomainModifiedCount = 0x%x,0x%x\n",
        General->DomainModifiedCount.HighPart,
        General->DomainModifiedCount.LowPart ));
    kdprint(("\t DomainServerState = %d\n",General->DomainServerState));
    kdprint(("\t DomainServerRole = %d\n",General->DomainServerRole));
    kdprint(("\t UasCompatibilityRequired = %d\n",General->UasCompatibilityRequired));
    kdprint(("\t UserCount = %d\n",General->UserCount));
    kdprint(("\t GroupCount = %d\n",General->GroupCount));
    kdprint(("\t AliasCount = %d\n",General->AliasCount));

    SamFreeMemory(General);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainLogoffInformation,
                (PVOID *) &Logoff
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query logoff: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Logoff:\n"));
    PrintDeltaTime("\t ForceLogoff = ",&Logoff->ForceLogoff);
    SamFreeMemory(Logoff);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainOemInformation,
                (PVOID *) &Oem
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query Oem: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Oem:\n\t OemInformation = %wZ\n",&Oem->OemInformation));

    SamFreeMemory(Oem);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainNameInformation,
                (PVOID *) &Name
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query Name: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("Name:\n\t DomainName = %wZ\n",&Name->DomainName));

    SamFreeMemory(Name);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainReplicationInformation,
                (PVOID *) &Replica
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query Replica: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Replica:\n\t ReplicaSourceNodeName = %wZ\n", &Replica->ReplicaSourceNodeName));
    SamFreeMemory(Replica);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainServerRoleInformation,
                (PVOID *) &ServerRole
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query ServerRole: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("ServerRole:\n\t DomainServerRole = %d\n",ServerRole->DomainServerRole));
    SamFreeMemory(ServerRole);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainModifiedInformation,
                (PVOID *) &Modified
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query Modified: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("Modified:\n"));
    kdprint(("\t DomainModifiedCount = 0x%x,0x%x\n",
        Modified->DomainModifiedCount.HighPart,
        Modified->DomainModifiedCount.LowPart ));
    PrintTime("\t CreationTime = ",&Modified->CreationTime);



    SamFreeMemory(Modified);


    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainStateInformation,
                (PVOID *) &State
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query State: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("State:\n\t DomainServerState = %d\n",State->DomainServerState));
    SamFreeMemory(State);


    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainGeneralInformation2,
                (PVOID *) &General2
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query General2: 0x%x\n",Status));
        return(Status);
    }

    kdprint(("General2:\n"));
    General = &General2->I1;
    PrintDeltaTime("\t ForceLogoff = ",&General->ForceLogoff);
    kdprint(("\t OemInformation = %wZ\n",&General->OemInformation));
    kdprint(("\t DomainName = %wZ\n",&General->DomainName));
    kdprint(("\t ReplicaSourceNodeName =%wZ\n",&General->ReplicaSourceNodeName));
    kdprint(("\t DomainModifiedCount = 0x%x,0x%x\n",
        General->DomainModifiedCount.HighPart,
        General->DomainModifiedCount.LowPart ));
    kdprint(("\t DomainServerState = %d\n",General->DomainServerState));
    kdprint(("\t DomainServerRole = %d\n",General->DomainServerRole));
    kdprint(("\t UasCompatibilityRequired = %d\n",General->UasCompatibilityRequired));
    kdprint(("\t UserCount = %d\n",General->UserCount));
    kdprint(("\t GroupCount = %d\n",General->GroupCount));
    kdprint(("\t AliasCount = %d\n",General->AliasCount));
    PrintDeltaTime("\t LockoutDuration = ",&General2->LockoutDuration);
    PrintDeltaTime("\t LockoutObservationWindow = ",&General2->LockoutObservationWindow);
    kdprint(("\t LockoutThreshold = %d\n",General2->LockoutThreshold));

    SamFreeMemory(General2);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainLockoutInformation,
                (PVOID *) &Lockout
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query Lockout: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("Lockout:\n"));
    PrintDeltaTime("\t LockoutDuration = ",&Lockout->LockoutDuration);
    PrintDeltaTime("\t LockoutObservationWindow = ",&Lockout->LockoutObservationWindow);
    kdprint(("\t LockoutThreshold = %d\n",Lockout->LockoutThreshold));

    SamFreeMemory(Lockout);

    Status = SamQueryInformationDomain(
                DomainHandle,
                DomainModifiedInformation2,
                (PVOID *) &Modified2
                );
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to query Modified2: 0x%x\n",Status));
        return(Status);
    }
    kdprint(("Modified2:\n"));
    PrintTime("\t CreationTime = ",&Modified->CreationTime);
    kdprint(("\t DomainModifiedCount = 0x%x,0x%x\n",
        Modified2->DomainModifiedCount.HighPart,
        Modified2->DomainModifiedCount.LowPart ));

    kdprint(("\t ModifiedCountAtLastPromotion = 0x%x,0x%x\n",
        Modified2->ModifiedCountAtLastPromotion.HighPart,
        Modified2->ModifiedCountAtLastPromotion.LowPart ));

    SamFreeMemory(Modified2);

    return(STATUS_SUCCESS);

}


NTSTATUS
SetLogonHours( LPWSTR * Parameter )
{
    // The purpose of this test is to verify that attempts to change the
    // logon hours time units will cause SAM to return STATUS_NOT_SUPPORTED
    // in the NT5 Beta Release. By default, SAM sets the time units to
    // SAM_HOURS_PER_WEEK, the most natural value of the three possible
    // settings. This test tries to reset the logon hours to the other two
    // values (minutes per week and days per week). These cases should fail
    // and return STATUS_NOT_SUPPORTED. Setting the value to the default
    // SAM_HOURS_PER_WEEK REQUIRES THAT MORE OF THE SAM USER-INFORMATION
    // DATA ALSO BE SET, otherwise garbage values for group membership, etc.
    // will be set (with unpredictable results).

    NTSTATUS NtStatus = STATUS_SUCCESS;
    LOGON_HOURS LogonHours;
    UCHAR Allow = 0xFF;

    // One bit per chosen time unit in the logon-hours bitmask.

    UCHAR DaysPerWeek[1];                           // 7 bits, 1 byte
    UCHAR HoursPerWeek[SAM_HOURS_PER_WEEK / 8];     // 168 bits, 21 bytes
    UCHAR MinutesPerWeek[SAM_MINUTES_PER_WEEK / 8]; // 10080 bits, 1260 bytes

    // Try each of the two alternative time units allowed. For now, since
    // accounts are created with NULL logon hours (implying always allow
    // logon initially), these two attempts to reset the time units to
    // some other value will fail with STATUS_NOT_SUPPORTED, which is the
    // desired result until DS-SAM supports the ability to modify logon
    // hours TIME UNITS.

    RtlCopyMemory(&DaysPerWeek, &Allow, sizeof(DaysPerWeek));
    LogonHours.UnitsPerWeek = SAM_DAYS_PER_WEEK;
    LogonHours.LogonHours = (PUCHAR)&DaysPerWeek;

    NtStatus = SamSetInformationUser(UserHandle,
                                     UserLogonHoursInformation,
                                     &LogonHours);

    kdprint(("SetLogonHours [Days Per Week] status = 0x%lx\n", NtStatus));

    if (STATUS_NOT_SUPPORTED != NtStatus)
    {
        return(NtStatus);
    }

    RtlCopyMemory(&MinutesPerWeek, &Allow, sizeof(MinutesPerWeek));
    LogonHours.UnitsPerWeek = SAM_MINUTES_PER_WEEK;
    LogonHours.LogonHours = (PUCHAR)&MinutesPerWeek;

    NtStatus = SamSetInformationUser(UserHandle,
                                     UserLogonHoursInformation,
                                     &LogonHours);

    kdprint(("SetLogonHours [Minutes Per Week] status = 0x%lx\n", NtStatus));

    if (STATUS_NOT_SUPPORTED != NtStatus)
    {
        return(NtStatus);
    }

    // If the test has made it this far, STATUS_NOT_SUPPORTED has been re-
    // turned from all test cases. This is the desired result for now.

    NtStatus = STATUS_SUCCESS;

    return(NtStatus);
}

NTSTATUS
SetPassword( LPWSTR * Parameter )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    USER_SET_PASSWORD_INFORMATION PasswordInfo;

    RtlZeroMemory(&PasswordInfo, sizeof(USER_SET_PASSWORD_INFORMATION));

    RtlInitUnicodeString(&(PasswordInfo.Password), L"Password");
    PasswordInfo.PasswordExpired = FALSE;

    NtStatus = SamSetInformationUser(UserHandle,
                                     UserSetPasswordInformation,
                                     &PasswordInfo);

    if (!NT_SUCCESS(NtStatus))
    {
        kdprint(("SamSetInformationUser status = 0x%lx\n", NtStatus));
    }

    return(NtStatus);
}

NTSTATUS
ChangeKey( LPWSTR * Parameter )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    UCHAR    SyskeyBuffer[16];
    ULONG    len = sizeof(SyskeyBuffer);

    NtStatus = WxReadSysKey(&len,SyskeyBuffer);
    if (NT_SUCCESS(NtStatus))
    {
        UNICODE_STRING Syskey;

        Syskey.Length = Syskey.MaximumLength = (USHORT)len;
        Syskey.Buffer = (WCHAR * )SyskeyBuffer;

        NtStatus = SamiSetBootKeyInformation(
                        DomainHandle,
                        SamBootChangePasswordEncryptionKey,
                        &Syskey,
                        &Syskey
                        );

        printf("SamiSetBootKeyInformation status = 0x%lx\n", NtStatus);
    }
    else
    {
        printf("WxReadSyskey status = 0x%lx\n", NtStatus);
    }

    return(NtStatus);
}

VOID
_cdecl
main(INT argc, CHAR *argv[])
{
    ULONG Command = 0;
    ULONG i,j,k;
    BOOLEAN Found;
    NTSTATUS Status;
    Action Actions[20];
    ULONG ActionCount = 0;

    BOOLEAN TestStatus = TRUE;

    for (i = 1; i < (ULONG) argc ; i++ )
    {
        Found = FALSE;
        for (j = 0; j < NUM_COMMANDS ; j++ )
        {
            if (!_stricmp(argv[i],Commands[j].Name))
            {
                Actions[ActionCount].CommandNumber = j;

                if (Commands[j].Parameter != 0)
                {
                    for (k = 0; k < Commands[j].Parameter ;k++ )
                    {
                        Actions[ActionCount].Parameter[k] = (LPWSTR) malloc(128);
                        if ((ULONG) argc > i)
                        {
                            mbstowcs(Actions[ActionCount].Parameter[k],argv[++i],128);
                        }
                        else
                        {
                            Actions[ActionCount].Parameter[k][0] = L'\0';
                        }
                    }
                }
                Found = TRUE;
                ActionCount++;
                break;
            }
        }
        if (!Found)
        {
            kdprint(("Switch %s not found\n", argv[i]));
            exit(2);
        }
    }

    for (i = 0; i < ActionCount ; i++ )
    {
        Status = Commands[Actions[i].CommandNumber].Function(Actions[i].Parameter);
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed test %s : 0x%x\n",Commands[Actions[i].CommandNumber].Name,Status));
            TestStatus = FALSE;
            goto Cleanup;

        }
    }

Cleanup:
    if (DomainHandle != NULL)
    {
        Status = SamCloseHandle(DomainHandle);
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed to close domain handle: 0x%x\n",Status));
        }
    }
    if (GroupHandle != NULL)
    {
        Status = SamCloseHandle(GroupHandle);
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed to close group handle: 0x%x\n",Status));
        }
    }
    if (AliasHandle != NULL)
    {
        Status = SamCloseHandle(AliasHandle);
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed to close alias handle: 0x%x\n",Status));
        }
    }
    if (UserHandle != NULL)
    {
        Status = SamCloseHandle(UserHandle);
        if (!NT_SUCCESS(Status))
        {
            kdprint(("Failed to close user handle: 0x%x\n",Status));
        }
    }
    Status = CloseSam();
    if (!NT_SUCCESS(Status))
    {
        kdprint(("Failed to close lsa: 0x%x\n",Status));
    }

    // This test should always conclude by displaying its status to stdout.
    // All other output should optionally go to stdout or a debugger, but
    // should not display to stdout by default (so that this test can be
    // used in the BVT lab tests if needed).

    if (TRUE == TestStatus)
    {
        printf("PASSED\n");
        exit(0);
    }
    else
    {
        printf("FAILED\n");
        exit(1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\test\ldaprepltest\auth.c ===
#include <NTDSpch.h>
#pragma hdrstop


#include "auth.h"

// Global DRS RPC call flags.  Should hold 0 or DRS_ASYNC_OP.
ULONG gulDrsFlags = 0;

// Global credentials.
SEC_WINNT_AUTH_IDENTITY_W   gCreds = { 0 };
SEC_WINNT_AUTH_IDENTITY_W * gpCreds = NULL;
void DoAssert( char *a, char *b, int c)
{
    printf("ASSERT %s, %s, %d\n",a,b,c);
    exit(-1);
}

int
GetPassword(
    WCHAR *     pwszBuf, 
    DWORD       cchBufMax,
    DWORD *     pcchBufUsed
    )  
/*++ 

Routine Description: 

    Retrieve password from command line (without echo).
    Code stolen from LUI_GetPasswdStr (net\netcmd\common\lui.c).

Arguments:

    pwszBuf - buffer to fill with password
    cchBufMax - buffer size (incl. space for terminating null)
    pcchBufUsed - on return holds number of characters used in password

Return Values:

    DRAERR_Success - success
    other - failure
 
--*/
{
    WCHAR   ch;
    WCHAR * bufPtr = pwszBuf;
    DWORD   c;
    int     err;
    int     mode;

    cchBufMax -= 1;    /* make space for null terminator */
    *pcchBufUsed = 0;               /* GP fault probe (a la API's) */
    GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode);
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsoleW(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);
        if (!err || c != 1)
            ch = 0xffff;

        if ((ch == CR) || (ch == 0xffff))       /* end of the line */
            break;

        if (ch == BACKSPACE) {  /* back up one or two */
            /*
             * IF bufPtr == buf then the next two lines are
             * a no op.
             */
            if (bufPtr != pwszBuf) {
                bufPtr--;
                (*pcchBufUsed)--;
            }
        }
        else {

            *bufPtr = ch;

            if (*pcchBufUsed < cchBufMax)
                bufPtr++ ;                   /* don't overflow buf */
            (*pcchBufUsed)++;                        /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);
    *bufPtr = L'\0';         /* null terminate the string */
    putchar('\n');

    if (*pcchBufUsed > cchBufMax)
    {
        printf("Password too long!\n");
        //PrintMsg( REPADMIN_PASSWORD_TOO_LONG );
        return ERROR_INVALID_PARAMETER;
    }
    else
    {
        return ERROR_SUCCESS;
    }
}

int
PreProcessGlobalParams(
    int *    pargc,
    LPWSTR **pargv
    )
/*++

Routine Description:

    Scan command arguments for user-supplied credentials of the form
        [/-](u|user):({domain\username}|{username})
        [/-](p|pw|pass|password):{password}
    Set credentials used for future DRS RPC calls and LDAP binds appropriately.
    A password of * will prompt the user for a secure password from the console.

    Also scan args for /async, which adds the DRS_ASYNC_OP flag to all DRS RPC
    calls.

    CODE.IMPROVEMENT: The code to build a credential is also available in
    ntdsapi.dll\DsMakePasswordCredential().

Arguments:

    pargc
    pargv

Return Values:

    ERROR_Success - success
    other - failure

--*/
{
    int     ret = 0;
    int     iArg;
    LPWSTR  pszOption;
    DWORD   cchOption;
    LPWSTR  pszDelim;
    LPWSTR  pszValue;
    DWORD   cchValue;

    for (iArg = 1; iArg < *pargc; )
    {
        if (((*pargv)[iArg][0] != L'/') && ((*pargv)[iArg][0] != L'-'))
        {
            // Not an argument we care about -- next!
            iArg++;
        }
        else
        {
            pszOption = &(*pargv)[iArg][1];
            pszDelim = wcschr(pszOption, L':');

            if (NULL == pszDelim)
            {
                if (0 == _wcsicmp(L"async", pszOption))
                {
                    // This constant is the same for all operations
                    gulDrsFlags |= DS_REPADD_ASYNCHRONOUS_OPERATION;

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else
                {
                    // Not an argument we care about -- next!
                    iArg++;
                }
            }
            else
            {
                cchOption = (DWORD)(pszDelim - (*pargv)[iArg]);

                if (    (0 == _wcsnicmp(L"p:",        pszOption, cchOption))
                     || (0 == _wcsnicmp(L"pw:",       pszOption, cchOption))
                     || (0 == _wcsnicmp(L"pass:",     pszOption, cchOption))
                     || (0 == _wcsnicmp(L"password:", pszOption, cchOption)) )
                {
                    // User-supplied password.
                    pszValue = pszDelim + 1;
                    cchValue = 1 + wcslen(pszValue);

                    if ((2 == cchValue) && ('*' == pszValue[0]))
                    {
                        // Get hidden password from console.
                        cchValue = 64;

                        gCreds.Password = malloc(sizeof(WCHAR) * cchValue);

                        if (NULL == gCreds.Password)
                        {
                            printf( "No memory.\n" );
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }

                        printf("Password: ");

                        ret = GetPassword(gCreds.Password, cchValue, &cchValue);
                    }
                    else
                    {
                        // Get password specified on command line.
                        gCreds.Password = pszValue;
                    }

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else if (    (0 == _wcsnicmp(L"u:",    pszOption, cchOption))
                          || (0 == _wcsnicmp(L"user:", pszOption, cchOption)) )
                {
                    // User-supplied user name (and perhaps domain name).
                    pszValue = pszDelim + 1;
                    cchValue = 1 + wcslen(pszValue);

                    pszDelim = wcschr(pszValue, L'\\');

                    if (NULL == pszDelim)
                    {
                        // No domain name, only user name supplied.
                        printf("User name must be prefixed by domain name.\n");
                        //PrintMsg( REPADMIN_DOMAIN_BEFORE_USER );
                        return ERROR_INVALID_PARAMETER;
                    }

                    *pszDelim = L'\0';
                    gCreds.Domain = pszValue;
                    gCreds.User = pszDelim + 1;

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else
                {
                    iArg++;
                }
            }
        }
    }

    if (NULL == gCreds.User)
    {
        if (NULL != gCreds.Password)
        {
            // Password supplied w/o user name.
            printf( "Password must be accompanied by user name.\n" );
            //PrintMsg( REPADMIN_PASSWORD_NEEDS_USERNAME );
            ret = ERROR_INVALID_PARAMETER;
        }
        else
        {
            // No credentials supplied; use default credentials.
            ret = ERROR_SUCCESS;
        }
    }
    else
    {
        gCreds.PasswordLength = gCreds.Password ? wcslen(gCreds.Password) : 0;
        gCreds.UserLength   = wcslen(gCreds.User);
        gCreds.DomainLength = gCreds.Domain ? wcslen(gCreds.Domain) : 0;
        gCreds.Flags        = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        // CODE.IMP: The code to build a SEC_WINNT_AUTH structure also exists
        // in DsMakePasswordCredentials.  Someday use it

        // Use credentials in DsBind and LDAP binds
        gpCreds = &gCreds;
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\test\ldaprepltest\auth.h ===
#ifndef T_CHRISK_AUTH_H
#define T_CHRISK_AUTH_H

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>
#include <winerror.h>
#include <stdio.h>
#include <ntdsapi.h>

#define CR 0xD
#define BACKSPACE 0x8

// Global DRS RPC call flags.  Should hold 0 or DRS_ASYNC_OP.
extern ULONG gulDrsFlags;

// Global credentials.
extern SEC_WINNT_AUTH_IDENTITY_W   gCreds;
extern SEC_WINNT_AUTH_IDENTITY_W * gpCreds;

int
PreProcessGlobalParams(
    int *    pargc,
    LPWSTR **pargv
    );
/*++

Routine Description:

    Scan command arguments for user-supplied credentials of the form
        [/-](u|user):({domain\username}|{username})
        [/-](p|pw|pass|password):{password}
    Set credentials used for future DRS RPC calls and LDAP binds appropriately.
    A password of * will prompt the user for a secure password from the console.

    Also scan args for /async, which adds the DRS_ASYNC_OP flag to all DRS RPC
    calls.

    CODE.IMPROVEMENT: The code to build a credential is also available in
    ntdsapi.dll\DsMakePasswordCredential().

Arguments:

    pargc
    pargv

Return Values:

    ERROR_Success - success
    other - failure

--*/


#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\test\ldaprepltest\replcompare.hpp ===
#ifndef _T_CHRISK_REPLCOMPARE_
#define _T_CHRISK_REPLCOMPARE_

DWORD
Repl_ArrayComp(DS_REPL_STRUCT_TYPE structId,
                   puReplStructArray pStructArrayA,
                   puReplStructArray pStructArrayB);

DWORD
Repl_StructComp(DS_REPL_STRUCT_TYPE structId,
                    puReplStruct pStructA,
                    puReplStruct pStructB);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\test\ldaprepltest\main.cpp ===
#include <NTDSpchx.h>
#pragma hdrstop

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>

#include <winbase.h>
#include <winerror.h>
#include <assert.h>
#include <ntdsapi.h>

#include <ntsecapi.h>
#include <ntdsa.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <drs.h>
#include <stddef.h>

#include "ldaprepltest.hpp"
#include "auth.h"
#include "ReplStructInfo.hxx"
#include "ReplCompare.hpp"

// Globals
LPWSTR gpszDomainDn = NULL;
LPWSTR gpszDns = NULL;
LPWSTR gpszBaseDn = NULL;
LPWSTR gpszGroupDn = NULL;


int __cdecl
wmain( int argc, LPWSTR argv[] ) {

    PreProcessGlobalParams(&argc, &argv);

    if (argc < 4) {
        printf( "usage: %ls <domaindn> <domaindns> <groupdn>\n", argv[0] );
        return 0;
    }

    gpszDomainDn = argv[1];
    gpszDns = argv[2];
    gpszBaseDn = argv[1];
    gpszGroupDn = argv[3];

    testMarshaler(NULL, gpszDns, (RPC_AUTH_IDENTITY_HANDLE)gpCreds, gpszBaseDn);
    testRPCSpoof(NULL, gpszDns, (RPC_AUTH_IDENTITY_HANDLE)gpCreds, gpszBaseDn);
    testXml((RPC_AUTH_IDENTITY_HANDLE)gpCreds);
    testRange(gpCreds);
    testSingle(gpCreds);
    sample((PWCHAR)gpCreds, gpszDomainDn, gpszDns, gpszBaseDn, gpszGroupDn);
    printf("\n * Testing complete *\n");

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\test\ldaprepltest\ldaprepltest.hpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ldaprepltest.hpp

Abstract:

    abstract

Author:

    Will Lees (wlees) 10-Oct-2000

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#ifndef _LDAPREPLTEST__
#define _LDAPREPLTEST_

// Extern
extern LPWSTR gpszDomainDn;
extern LPWSTR gpszDns;
extern LPWSTR gpszBaseDn;
extern LPWSTR gpszGroupDn;

#define whine(pred) if (!(pred)) { printf("\n\n***************Failed in file %s line %d\n\n\n", __FILE__, __LINE__); return; }

BOOL
testRPCSpoof(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    LPWSTR pczNC); 

BOOL
testMarshaler(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    LPWSTR pczNC); 
void
testXml(RPC_AUTH_IDENTITY_HANDLE AuthIdentity);

void
testRange(RPC_AUTH_IDENTITY_HANDLE AuthIdentity);

void
testSingle(RPC_AUTH_IDENTITY_HANDLE AuthIdentity);

void
sample(PWCHAR AuthIdentity,
       LPWSTR szDomain,
       LPWSTR szDns,
       LPWSTR szBase,
       LPWSTR szGroup);

#endif /* _LDAPREPLTEST.H_ */

/* end ldaprepltest.hpp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\test\ldaprepltest\replcompare.cpp ===
#include <NTDSpchx.h>
#pragma hdrstop

#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <attids.h> 
#include <ntsecapi.h>
#include <ntdsa.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <drs.h>
#include <stddef.h>
#include <debug.h>

#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "ReplCompare.hpp"

DWORD
structComp(PCHAR pStructA,
	   	   PCHAR pStructB, 
           DWORD dwStructLen, 
           DWORD rPtrOffset[],
           DWORD rPtrLen[],
           DWORD dwNumPtrs);

DWORD
Wcslen(const wchar_t *wstr);

DWORD
Wcslen(const wchar_t *wstr)
{
    if (wstr)
        return wcslen(wstr);
    else
        return 0;
}

DWORD
Repl_ArrayComp(DS_REPL_STRUCT_TYPE structId,
                   puReplStructArray pStructArrayA,
                   puReplStructArray pStructArrayB)
{
    DWORD i;
    DWORD dwMinArraySize;
    DWORD dwElementSize;
    PCHAR rStructA, rStructB;

    Repl_GetElemArray(structId, pStructArrayB, &rStructB);
    Repl_GetElemArray(structId, pStructArrayA, &rStructA);
    dwElementSize = Repl_GetElemSize(structId);
    dwMinArraySize = min(Repl_GetArrayLength(structId, pStructArrayA),
                      Repl_GetArrayLength(structId, pStructArrayB));

    switch(structId)
    {
    case dsReplNeighbor:
        {
            DWORD i;
            UUID zUUID = { 0 };
            for (i = 0; i < pStructArrayA->neighborsw.cNumNeighbors; i ++)
            {
                // TODO: Figure out why RPC Doesn't return these values.
                pStructArrayA->neighborsw.rgNeighbor[i].uuidNamingContextObjGuid = zUUID;
                pStructArrayA->neighborsw.rgNeighbor[i].uuidSourceDsaObjGuid = zUUID;
                pStructArrayB->neighborsw.rgNeighbor[i].uuidNamingContextObjGuid = zUUID;
                pStructArrayB->neighborsw.rgNeighbor[i].uuidSourceDsaObjGuid = zUUID;
            }
        }
        break;
    }

    DWORD dwDiff = 0;
    DWORD success = 0;
    for(i = 0; i < dwMinArraySize; i ++)
    {
        if (Repl_StructComp(structId, 
                                (puReplStruct)(rStructA + (i * dwElementSize)), 
                                (puReplStruct)(rStructB + (i * dwElementSize))))
        {
            dwDiff = 1;
            break;
        }
        else
        {
            success ++;
        }
    }

    if (dwDiff & !success)
    {
        DWORD j;
        dwDiff = 0;
        for(i = 0, j = Repl_GetArrayLength(structId, pStructArrayB) - 1; i < dwMinArraySize; j--, i ++)
        {
            if (Repl_StructComp(structId, 
                                    (puReplStruct)(rStructA + (i * dwElementSize)), 
                                    (puReplStruct)(rStructB + (j * dwElementSize))))
            {
                dwDiff = 1;
                break;
            }
            else
            {
                success++;
            }
        }
    }

    if (dwDiff & !success)
    {
        DWORD a, b;
        dwDiff = 0;
        for(i = 0, 
            b = Repl_GetArrayLength(structId, pStructArrayB) - 1,
            a = Repl_GetArrayLength(structId, pStructArrayA) - 1; i < dwMinArraySize; a--, b--, i ++)
        {
            if (Repl_StructComp(structId, 
                                    (puReplStruct)(rStructA + (a * dwElementSize)), 
                                    (puReplStruct)(rStructB + (b * dwElementSize))))
            {
                dwDiff = 1;
                break;
            }
            else
            {
                success++;
            }
        }
    }

    if (dwDiff)
        return success;
    else
        return 0;
}

DWORD
Repl_StructComp(DS_REPL_STRUCT_TYPE structId,
                puReplStruct pStructA,
                puReplStruct pStructB)
{
    DWORD dwNumPtrs = Repl_GetPtrCount(structId);
    PDWORD aPtrLengths;
    DWORD ret;

    if (dwNumPtrs)
        aPtrLengths = (PDWORD)malloc(sizeof(PDWORD) * dwNumPtrs);
    
    Assert(pStructA && pStructB);
    Repl_GetPtrLengths(structId, pStructA, aPtrLengths, dwNumPtrs, NULL);

    ret = structComp((PCHAR)pStructA, (PCHAR)pStructB,
        Repl_GetElemSize(structId),
        Repl_GetPtrOffsets(structId),
        aPtrLengths,
        dwNumPtrs
        );

    if (dwNumPtrs)
        free(aPtrLengths);
    return ret;
}

DWORD
structComp(PCHAR pStructA,
	   	   PCHAR pStructB, 
           DWORD dwStructLen, 
           DWORD rPtrOffset[],
           DWORD rPtrLen[],
           DWORD dwNumPtrs)
{
	PCHAR pA = pStructA;
	PCHAR pB = pStructB;
	DWORD i, dwNPDSize;

	// Without pointer case is easy
	if (!dwNumPtrs) {
		return memcmp(pA, pB, dwStructLen);
	}

	// compare NPD before first pointer
	dwNPDSize = rPtrOffset[0] - 0;
	if (dwNPDSize && memcmp(pA, pB, dwNPDSize))
		return 1;

	for(i = 0;;)
	{
		// advance to pointer
        pA = pStructA + rPtrOffset[i];
        pB = pStructB + rPtrOffset[i];

        if (memcmp(*(PCHAR *)pA, *(PCHAR *)pB, rPtrLen[i]))
        {
//            printf("%ws != %ws", *(LPWSTR *)pA, *(LPWSTR *)pB);
            return 1;
        }

		// skip over pointer
		pA += sizeof(PCHAR);
		pB += sizeof(PCHAR);

		if (++i == dwNumPtrs)
			break;

		// compare NPD between pointers
		dwNPDSize = rPtrOffset[i] - rPtrOffset[i-1] - sizeof(PCHAR);
		if (dwNPDSize && memcmp(pA, pB, dwNPDSize))
			return 1;
	}

	// compare NPD after last pointer
	dwNPDSize = dwStructLen - (pA - pStructA);	
	if (dwNPDSize && memcmp(pA, pB, dwNPDSize))
		return 1; 

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\test\ldaprepltest\testrange.cpp ===
#include <NTDSpchx.h>
#pragma hdrstop

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>

#include <winbase.h>
#include <winerror.h>
#include <assert.h>
#include <winldap.h>
#include <ntdsapi.h>

#include <ntsecapi.h>
#include <ntdsa.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <drs.h>
#include <stddef.h>
#include <attids.h>
#include <debug.h>

#include "ldaprepltest.hpp"
#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "ReplCompare.hpp"

DWORD
Repl_DeMarshalBerval(DS_REPL_STRUCT_TYPE dsReplStructType, 
                     berval * ldapValue[], OPTIONAL
                     DWORD dwNumValues,
                     puReplStructArray pReplStructArray, OPTIONAL
                     PDWORD pdwReplStructArrayLen);

void
vCheckRangeResult(DWORD dwBaseIndex, 
                  DWORD dwUpperReqBound, 
                  DWORD dwUpperRetBound, 
                  DWORD dwNumRet);
void
testAttributeRange(LDAP * pLdap,
                   PWCHAR szBase, 
                   ATTRTYP attrId);
void
ldapCall(LDAP * pLdap, 
         ATTRTYP attrId, 
         PWCHAR szBase, 
         DWORD dwBaseIndex, 
         PDWORD pdwUpperIndex, 
         berval ** ppBerval);

puReplStructArray gpReplStructArray;
DWORD gdwMaxIndex;

void
testRange(RPC_AUTH_IDENTITY_HANDLE AuthIdentity)
{
    LDAP * pLdap;
    DWORD err;

    // Open
    pLdap = ldap_openW(gpszDns, LDAP_PORT);
    if (NULL == pLdap) {
        printf("Cannot open LDAP connection to %ls.\n", gpszDns);
        return;
    }
    
    // Bind
    err = ldap_bind_sW(pLdap, gpszDns, (PWCHAR)AuthIdentity, LDAP_AUTH_SSPI);
    if (err != LDAP_SUCCESS)
    {
        err = LdapMapErrorToWin32(err);
    }

    
    printf("\n* Testing range support * \n");
    testAttributeRange(pLdap, gpszBaseDn, ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS);
    testAttributeRange(pLdap, gpszBaseDn, ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS);
    testAttributeRange(pLdap, gpszBaseDn, ATT_MS_DS_NC_REPL_CURSORS);
    testAttributeRange(pLdap, gpszBaseDn, ATT_MS_DS_REPL_ATTRIBUTE_META_DATA);
    testAttributeRange(pLdap, gpszGroupDn, ATT_MS_DS_REPL_VALUE_META_DATA);

    // Range support for Root DSE attrs added Oct 2000
    testAttributeRange(pLdap, NULL, ROOT_DSE_MS_DS_REPL_PENDING_OPS);
    testAttributeRange(pLdap, NULL, ROOT_DSE_MS_DS_REPL_LINK_FAILURES);
    testAttributeRange(pLdap, NULL, ROOT_DSE_MS_DS_REPL_CONNECTION_FAILURES);
    testAttributeRange(pLdap, NULL, ROOT_DSE_MS_DS_REPL_ALL_INBOUND_NEIGHBORS);
    testAttributeRange(pLdap, NULL, ROOT_DSE_MS_DS_REPL_ALL_OUTBOUND_NEIGHBORS);
}

void
testAttributeRange(LDAP * pLdap, PWCHAR szBase, ATTRTYP attrId)
{
    berval * pBerval;
    DWORD dwUpperReqBound, dwUpperRetBound;
    DWORD dwBaseIndex;
    DWORD i;
    DS_REPL_STRUCT_TYPE structId = Repl_Attr2StructTyp(attrId);

    LDAPMessage * pLDAPMsg = NULL; 
    WCHAR buf[256];
    LPCWSTR szAttribute = Repl_GetLdapCommonName(attrId, TRUE);
    swprintf(buf, L"%s;Range=0-*", szAttribute);
    LPCWSTR aAttributes[2] = { buf, NULL, };
    ldap_search_sW(pLdap, szBase, LDAP_SCOPE_BASE, L"(objectclass=*)", (LPWSTR*)aAttributes , FALSE, &pLDAPMsg);

    // Get values
    berval ** ppBerval;
    PWCHAR szRetAttribute;
    berelement * pCookie;
    szRetAttribute = ldap_first_attributeW(pLdap, pLDAPMsg, &pCookie);
    ppBerval = ldap_get_values_lenW(pLdap, pLDAPMsg, szRetAttribute);
    ldap_memfreeW(szRetAttribute);
    gdwMaxIndex = ldap_count_values_len(ppBerval) - 1;
    if (gdwMaxIndex == -1)
    {
        printf("No data set\n");
        return;
    }

    DWORD cb;
    Repl_DeMarshalBerval(structId, ppBerval, gdwMaxIndex + 1, NULL, &cb);
    gpReplStructArray = (puReplStructArray)malloc(cb);
    Repl_DeMarshalBerval(structId, ppBerval, gdwMaxIndex + 1, gpReplStructArray, &cb);

    DWORD aaTest[][2] = { 
        { 0, 0 }, { 0, gdwMaxIndex-1 }, { 0, gdwMaxIndex }, { 0, gdwMaxIndex+1 }, 
        { 1, 1 }, { 1, gdwMaxIndex-1 }, { 1, gdwMaxIndex }, { 1, gdwMaxIndex+1 }, 
        { gdwMaxIndex-1, gdwMaxIndex-1 }, { gdwMaxIndex-1, gdwMaxIndex}, { gdwMaxIndex-1, gdwMaxIndex+1 }, 
        { gdwMaxIndex, gdwMaxIndex}, { gdwMaxIndex, gdwMaxIndex+1 }, 
        { gdwMaxIndex+1, gdwMaxIndex+1 },
        { 0, -1 }, { 1, -1 }, { gdwMaxIndex-1, -1 }, { gdwMaxIndex, -1 }, { gdwMaxIndex+1, -1 },
        {0xfffffffe, 0xfffffffe }, {0xffffffff, 0xffffffff },
        // add any additional test cases here.. Did I miss any?!?
    };

    printf("** dwMaxIndex for %ws = %u **\n", aAttributes[0], gdwMaxIndex);

    for (i = 0; i < sizeof(aaTest)/2/sizeof(DWORD); i ++)
    {
        dwBaseIndex = aaTest[i][0];
        dwUpperReqBound =  aaTest[i][1];

        if (dwBaseIndex <= dwUpperReqBound)
        {
            dwUpperRetBound = dwUpperReqBound;
            ldapCall(pLdap, attrId, szBase, dwBaseIndex, &dwUpperRetBound, &pBerval);
        }
    }

    printf("\n");
}

void
ldapCall(LDAP * pLdap, ATTRTYP attrId, PWCHAR szBase, DWORD dwBaseIndex, PDWORD pdwUpperIndex, berval ** ppBerval)
{
    Assert(pdwUpperIndex);
    DWORD dwUpperRetIndex;
    DWORD dwUpperReqIndex = *pdwUpperIndex;

    LDAPMessage * pLDAPMsg = NULL; 
    LPCWSTR szAttribute = NULL;
    LPCWSTR aAttributes[2] = {
        NULL, 
        NULL,
    };

    // Construct name
    DWORD dwNumValues = 0;
    WCHAR buf[256];
    szAttribute = Repl_GetLdapCommonName(attrId, TRUE);
    if (-1 == dwUpperReqIndex)
    {
        swprintf(buf, L"%s;Range=%u-*", szAttribute, dwBaseIndex);
    }
    else 
    {
        Assert(dwBaseIndex <= dwUpperReqIndex);
        swprintf(buf, L"%s;Range=%u-%u", szAttribute, dwBaseIndex, dwUpperReqIndex);
    }
    aAttributes[0] = buf;

    // Search
    printf("Making ldap call for %ws\n", aAttributes[0]);
    ldap_search_sW(pLdap, szBase, LDAP_SCOPE_BASE, L"(objectclass=*)", (LPWSTR*)aAttributes , FALSE, &pLDAPMsg);

    // Get values
    PWCHAR szRetAttribute;
    berelement * pCookie;
    szRetAttribute = ldap_first_attributeW(pLdap, pLDAPMsg, &pCookie);
    ppBerval = ldap_get_values_lenW(pLdap, pLDAPMsg, szRetAttribute);
    ldap_memfreeW(szRetAttribute);
    dwNumValues = ldap_count_values_len(ppBerval);
    if ( (!dwNumValues) && (dwBaseIndex > gdwMaxIndex))
    {
        // Base index out of range, and no values returned
        return;
    }
    
    // Extract any range information
    if (!swscanf(wcsstr(szRetAttribute, L"ange="), L"ange=%*u-%u", &dwUpperRetIndex))
        dwUpperRetIndex = -1;
    ldap_memfreeW(szRetAttribute);
    // ldap_ber_free( pBerElem, 0 ); Documented but not supported

    vCheckRangeResult(dwBaseIndex, dwUpperReqIndex, dwUpperRetIndex, dwNumValues);


    // Emulate client demarshaling
    puReplStructArray pReplStructArray;
    DWORD bc, err;
    DS_REPL_STRUCT_TYPE structId = Repl_Attr2StructTyp(attrId);
    err = Repl_DeMarshalBerval(structId, ppBerval, dwNumValues, NULL, &bc);
    if (err)
        printf("FAILEDa\n");
    pReplStructArray = (puReplStructArray)malloc(bc);
    err = Repl_DeMarshalBerval(structId, ppBerval, dwNumValues, pReplStructArray, &bc);
    if (err)
        printf("FAILEDb\n");

    // See if we get the same result
    err = Repl_ArrayComp(structId, pReplStructArray, gpReplStructArray);
    if (err)
        printf("FAILED to Compare\n");
    
}

void
vCheckRangeResult(DWORD dwBaseIndex, DWORD dwUpperReqBound, 
                  DWORD dwUpperRetBound, DWORD dwNumRet)
{
    Assert(dwBaseIndex <= dwUpperReqBound);
    if (dwUpperReqBound < gdwMaxIndex)
    {
        if (dwUpperRetBound != dwUpperReqBound ||
            dwNumRet != dwUpperReqBound - dwBaseIndex + 1)
            printf("FAILED1\n");
    }
    else
    {
        if (dwUpperRetBound != -1 ||
            dwNumRet != gdwMaxIndex - dwBaseIndex + 1)
            printf("FAILED2\n"); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\test\ldaprepltest\testmarshaler.cpp ===
#include <NTDSpchx.h>
#pragma hdrstop

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>

#include <winbase.h>
#include <winerror.h>
#include <assert.h>
#include <winldap.h>
#include <ntdsapi.h>

#include <ntsecapi.h>
#include <ntdsa.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <drs.h>
#include <stddef.h>


#include "ldaprepltest.hpp"
#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "ReplCompare.hpp"

#define THSTATE DWORD
#define DSNAME PWCHAR
DWORD
Repl_DeMarshalBerval(DS_REPL_STRUCT_TYPE dsReplStructType, 
                     berval * ldapValue[], OPTIONAL
                     DWORD dwNumValues,
                     puReplStructArray pReplStructArray, OPTIONAL
                     PDWORD pdwReplStructArrayLen);

extern "C" {
HANDLE ghRPC;
LPWSTR gpObjDSName;
DWORD 
draGetLDAPReplInfo(IN THSTATE * pTHS,
			  IN ATTRTYP attrId, 
			  IN DSNAME * pObjDSName,
			  IN DWORD dwBaseIndex,
			  IN PDWORD pdwNumRequested,
			  OUT ATTR * pAttr);
}

void
testAttribute(HANDLE hRPC, DS_REPL_INFO_TYPE dsReplInfoType, LPWSTR pczNC);

BOOL
testMarshaler(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    LPWSTR pczNC)
{
    HANDLE hRPC;
    DWORD err;

    err = DsBindWithCredW(DomainControllerName,
                          DnsDomainName,
                          (RPC_AUTH_IDENTITY_HANDLE)AuthIdentity,
                          &hRPC);
	if (err != NO_ERROR) {
            printf( "failed to bind to dc %ls dns %ls\n",
                    DomainControllerName, DnsDomainName );
        return err;
	}




    printf("\n* Testing struct marshaler - spoofing ntdsa.dll with RPC calls *\n");
    testAttribute(hRPC, DS_REPL_INFO_NEIGHBORS, pczNC);
    testAttribute(hRPC, (DS_REPL_INFO_TYPE)DS_REPL_INFO_REPSTO, pczNC);
    testAttribute(hRPC, DS_REPL_INFO_CURSORS_3_FOR_NC, pczNC);
    testAttribute(hRPC, DS_REPL_INFO_METADATA_2_FOR_OBJ, pczNC);
    testAttribute(hRPC, DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE, gpszGroupDn);
    testAttribute(hRPC, DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES, NULL);
    testAttribute(hRPC, DS_REPL_INFO_KCC_DSA_LINK_FAILURES, NULL);
    testAttribute(hRPC, DS_REPL_INFO_PENDING_OPS, NULL);
    testAttribute(hRPC, DS_REPL_INFO_NEIGHBORS, NULL);
    testAttribute(hRPC, (DS_REPL_INFO_TYPE)DS_REPL_INFO_REPSTO, NULL);

    return 0;
}

void
testAttribute(HANDLE hRPC, DS_REPL_INFO_TYPE dsReplInfoType, LPWSTR pczNC)
{
    ATTR attr;
    DWORD err, i, replStructArrayLen, dwBufferSize; 
    PCHAR pBuffer;
    ATTRTYP attrId = Repl_Info2AttrTyp(dsReplInfoType);
    DS_REPL_STRUCT_TYPE structId = Repl_Attr2StructTyp(attrId);
    puReplStructArray pReplStructArray;
    puReplStructArray pBaseReplStructArray;

    printf("%ws\n", Repl_GetLdapCommonName(attrId, TRUE));

    // Base casls
    err = DsReplicaGetInfo2W(hRPC, dsReplInfoType, pczNC, NULL, NULL, NULL, 0, 0, (void **)&pBaseReplStructArray);
    if (err) {
        printf( "call to DsReplicaGetInfo2W, object=%ls, failed with error %d\n",
                pczNC, err );
    }
    whine(err == ERROR_SUCCESS);

    // Emulate dra functionality
    ghRPC = hRPC;
    gpObjDSName = pczNC;
    
    err = DsReplicaGetInfo2W(hRPC, dsReplInfoType, pczNC, NULL, NULL, NULL, 0, 0, (void **)&pReplStructArray);
    whine(!err);

    // See if we get the same result
    err = Repl_ArrayComp(structId, pReplStructArray, pBaseReplStructArray);
    whine(!err);

    err = Repl_StructArray2Attr(Repl_Attr2StructTyp(attrId), pReplStructArray, &dwBufferSize, NULL, &attr);
    whine(!err);
    if (dwBufferSize)
    {
        pBuffer = (PCHAR)malloc(dwBufferSize);
        err = Repl_StructArray2Attr(Repl_Attr2StructTyp(attrId), pReplStructArray, &dwBufferSize, pBuffer, &attr);
        whine(!err);
    }

    // internal attr to external berval
    berval * rBerval = NULL;
    berval ** rpBerval = NULL;
    rBerval = (berval *)malloc(attr.AttrVal.valCount * sizeof(berval));
    rpBerval = (berval **)malloc(attr.AttrVal.valCount * sizeof(berval *));
    for(i = 0; i < attr.AttrVal.valCount; i ++)
    {
        rpBerval[i] = &rBerval[i];
        rpBerval[i]->bv_len = attr.AttrVal.pAVal[i].valLen;
        rpBerval[i]->bv_val = (PCHAR)attr.AttrVal.pAVal[i].pVal;
    }

    // Emulate client demarshaling
    err = Repl_DeMarshalBerval(structId, rpBerval, attr.AttrVal.valCount, 
        NULL, &replStructArrayLen);
    pReplStructArray = (puReplStructArray)malloc(replStructArrayLen);
    err = Repl_DeMarshalBerval(structId, rpBerval, attr.AttrVal.valCount, 
        pReplStructArray, &replStructArrayLen);
    whine(!err);

    // See if we get the same result
    err = Repl_ArrayComp(structId, pReplStructArray, pBaseReplStructArray);
    whine(!err);

    puReplStruct pReplStruct;
    PWCHAR szXml;
    DWORD dwXmlLen;

    if (Repl_GetArrayLength(structId, pReplStructArray))
    {
        Repl_GetElemArray(structId, pReplStructArray, (PCHAR*)&pReplStruct);
        Repl_MarshalXml(pReplStruct, attrId, NULL, &dwXmlLen);
        szXml = (PWCHAR)malloc(dwXmlLen);
        Repl_MarshalXml(pReplStruct, attrId, szXml, &dwXmlLen);
        wprintf(L"%ws", szXml);
    }

    // See if we get the same result
    err = Repl_ArrayComp(structId, pReplStructArray, pBaseReplStructArray);
    whine(!err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\test\ldaprepltest\testrpcspoof.cpp ===
#include <NTDSpchx.h>
#pragma hdrstop

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>

#include <winbase.h>
#include <winerror.h>
#include <assert.h>
#include <winldap.h>
#include <ntdsapi.h>

#include <ntsecapi.h>
#include <ntdsa.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <drs.h>
#include <stddef.h>

#include "ldaprepltest.hpp"
#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "ReplRpcSpoofProto.hxx"
#include "ReplCompare.hpp"

void
testAttribute(HANDLE hRPC, HANDLE hDS, DS_REPL_INFO_TYPE dsReplInfoType, LPWSTR pczNC);

BOOL
testRPCSpoof(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         pczDNS,                 // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    LPWSTR pczNC)
{
    DWORD ret;
    HANDLE hDS, hRPC;

    printf("\n* Testing RPC Spoof library - comparing LDAP to RPC *\n");
    
#if 0
    ret = DsBindWithCredW(pczNC,
                          NULL,
                          (RPC_AUTH_IDENTITY_HANDLE) AuthIdentity,
                          &hRPC);
    if (ERROR_SUCCESS != ret) {
        printf("DsBindWithCred to %ls failed\n", pczDNS);
        return ret;
    }
    DsUnBind( &hRPC );

    ret = _DsBindWithCredW(pczNC,
                           NULL,
                           (RPC_AUTH_IDENTITY_HANDLE) AuthIdentity,
                           &hDS); 

    if (ERROR_SUCCESS != ret) {
        printf("DsBindWithCred to %ls failed\n", pczDNS);
        return ret;
    }
    _DsUnBind( &hDS );
#endif

    ret = DsBindWithCredW(NULL,
                          pczDNS,
                          (RPC_AUTH_IDENTITY_HANDLE) AuthIdentity,
                          &hRPC);
    if (ERROR_SUCCESS != ret) {
        printf("DsBindWithCred to %ls failed\n", pczDNS);
        return ret;
    }

    ret = _DsBindWithCredW(NULL,
                           pczDNS,
                           (RPC_AUTH_IDENTITY_HANDLE) AuthIdentity,
                           &hDS);
    if (ERROR_SUCCESS != ret) {
        printf("DsBindWithCred to %ls failed\n", pczDNS);
        return ret;
    }



    testAttribute(hRPC, hDS, DS_REPL_INFO_NEIGHBORS, NULL);
    testAttribute(hRPC, hDS, (DS_REPL_INFO_TYPE)DS_REPL_INFO_REPSTO, NULL);
    testAttribute(hRPC, hDS, DS_REPL_INFO_NEIGHBORS, pczNC);
    testAttribute(hRPC, hDS, (DS_REPL_INFO_TYPE)DS_REPL_INFO_REPSTO, pczNC);
    testAttribute(hRPC, hDS, DS_REPL_INFO_CURSORS_3_FOR_NC, pczNC);
    testAttribute(hRPC, hDS, DS_REPL_INFO_METADATA_2_FOR_OBJ, pczNC);
    testAttribute(hRPC, hDS, DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE, gpszGroupDn);
    testAttribute(hRPC, hDS, DS_REPL_INFO_PENDING_OPS, NULL);
    testAttribute(hRPC, hDS, DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES, NULL);
    testAttribute(hRPC, hDS, DS_REPL_INFO_KCC_DSA_LINK_FAILURES, NULL);

    return TRUE;
} 

void
testAttribute(HANDLE hRPC, HANDLE hDS, DS_REPL_INFO_TYPE dsReplInfoType, LPWSTR pczNC)
{
    puReplStructArray pBaseReplStructArray;
    puReplStructArray pReplStructArray;
    DWORD err;
    
    err = DsReplicaGetInfo2W(hRPC, dsReplInfoType, pczNC, NULL, NULL, NULL, 0, 0, (void **)&pBaseReplStructArray);
    if (err)
    {
        DWORD ourErr = _DsReplicaGetInfoW(hDS, dsReplInfoType, pczNC, NULL, (void **)&pReplStructArray);
        if (err != ourErr) {
            printf("   ERROR Codes for _DsReplicaGetInfo don't match\n");
        }
        return;
    }
    whine(!err);

    err = _DsReplicaGetInfoW(hDS, dsReplInfoType, pczNC, NULL, (void **)&pReplStructArray);
    whine(!err);

    ATTRTYP attrId = Repl_Info2AttrTyp(dsReplInfoType);
    DS_REPL_STRUCT_TYPE structId = Repl_Attr2StructTyp(attrId);
    err = Repl_ArrayComp(structId, pBaseReplStructArray, pReplStructArray);
    if (err)
        printf("FAILED\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\test\ldaprepltest\testxml.cpp ===
#include <NTDSpchx.h>
#pragma hdrstop

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>

#include <winbase.h>
#include <winerror.h>
#include <assert.h>
#include <winldap.h>
#include <ntdsapi.h>

#include <ntsecapi.h>
#include <ntdsa.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <drs.h>
#include <stddef.h>
#include <attids.h> 

#include "ldaprepltest.hpp"
#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "ReplRpcSpoofProto.hxx"
#include "ReplCompare.hpp"

void
testXmlAttribute(LDAP * pLdap, PWCHAR pzBase, ATTRTYP attrId);

void
testXml(RPC_AUTH_IDENTITY_HANDLE AuthIdentity)
{
    LDAP * pLdap;
    DWORD ret;

    // Open
    pLdap = ldap_openW(gpszDns, LDAP_PORT);
    if (NULL == pLdap) {
        printf("Cannot open LDAP connection to %ls.\n", gpszDns);
        return;
    }
    
    // Bind
    ret = ldap_bind_sW(pLdap, gpszDns, (PWCHAR)AuthIdentity, LDAP_AUTH_SSPI);
    if (ret != LDAP_SUCCESS)
    {
        ret = LdapMapErrorToWin32(ret);
    }
    
    printf("\n* Testing XML marshaler *\n");
    testXmlAttribute(pLdap, gpszBaseDn, ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS);
    testXmlAttribute(pLdap, gpszBaseDn, ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS);
    testXmlAttribute(pLdap, gpszBaseDn, ATT_MS_DS_NC_REPL_CURSORS);
    testXmlAttribute(pLdap, gpszBaseDn, ATT_MS_DS_REPL_ATTRIBUTE_META_DATA);
    testXmlAttribute(pLdap, gpszGroupDn, ATT_MS_DS_REPL_VALUE_META_DATA);
    testXmlAttribute(pLdap, NULL, ROOT_DSE_MS_DS_REPL_PENDING_OPS);
    testXmlAttribute(pLdap, NULL, ROOT_DSE_MS_DS_REPL_LINK_FAILURES);
    testXmlAttribute(pLdap, NULL, ROOT_DSE_MS_DS_REPL_CONNECTION_FAILURES);
    testXmlAttribute(pLdap, NULL, ROOT_DSE_MS_DS_REPL_ALL_INBOUND_NEIGHBORS);
    testXmlAttribute(pLdap, NULL, ROOT_DSE_MS_DS_REPL_ALL_OUTBOUND_NEIGHBORS);

}

void
testXmlAttribute(LDAP * pLdap, PWCHAR pzBase, ATTRTYP attrId)
{
    LDAPMessage * pLDAPMsg;   
    PWCHAR szFilter = L"(objectclass=*)";
    PWCHAR attrs[2] = { NULL, NULL };
    LPCWSTR szAttribute; 
    DWORD err, dwNumValues;
    PWCHAR * ppValue;

    szAttribute = Repl_GetLdapCommonName(attrId, FALSE);
    
    attrs[0] = (LPWSTR)szAttribute;
    err = ldap_search_sW(pLdap, pzBase, LDAP_SCOPE_BASE, szFilter, attrs, FALSE, &pLDAPMsg);

    // Get values
    ppValue = ldap_get_valuesW(pLdap, pLDAPMsg, (LPWSTR)szAttribute);
    dwNumValues = ldap_count_valuesW(ppValue);
    if (dwNumValues == -1)
    {
        printf("FAILED\n");
        return;
    }

    printf("%d XML strs = \"%ws\"\n", dwNumValues, dwNumValues ? ppValue[0] : L"(null)");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\test\ldaprepltest\testsingle.cpp ===
#include <NTDSpchx.h>
#pragma hdrstop

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>

#include <winbase.h>
#include <winerror.h>
#include <assert.h>
#include <winldap.h>
#include <ntdsapi.h>

#include <ntsecapi.h>
#include <ntdsa.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <drs.h>
#include <stddef.h>

#include "ldaprepltest.hpp"
#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "ReplRpcSpoofProto.hxx"
#include "ReplCompare.hpp"

DWORD
Repl_DeMarshalBerval(DS_REPL_STRUCT_TYPE dsReplStructType, 
                     berval * ldapValue[], OPTIONAL
                     DWORD dwNumValues,
                     puReplStructArray pReplStructArray, OPTIONAL
                     PDWORD pdwReplStructArrayLen);

void
testSingle(RPC_AUTH_IDENTITY_HANDLE AuthIdentity)
{
    LDAP * pLdap;
    DWORD err;

    // Open
    pLdap = ldap_openW(gpszDns, LDAP_PORT);
    if (NULL == pLdap) {
        printf("Cannot open LDAP connection to %ls.\n", gpszDns);
        return;
    }
    
    // Bind
    err = ldap_bind_sW(pLdap, gpszDns, (PWCHAR)AuthIdentity, LDAP_AUTH_SSPI);
    if (err != LDAP_SUCCESS)
    {
        err = LdapMapErrorToWin32(err);
    }

    DWORD dwCount;
    DWORD attrId = ROOT_DSE_MS_DS_REPL_QUEUE_STATISTICS;
    DS_REPL_STRUCT_TYPE structId = Repl_Attr2StructTyp(attrId);

    LDAPMessage * pLDAPMsg = NULL; 
    WCHAR buf[256];
    LPCWSTR aAttribute[2] = { buf, NULL, };

    aAttribute[0] = Repl_GetLdapCommonName(attrId, TRUE);
    ldap_search_sW(pLdap, NULL, LDAP_SCOPE_BASE, L"(objectclass=*)", (LPWSTR*)aAttribute , FALSE, &pLDAPMsg);

    // Get values
    berval ** ppBerval;
    PWCHAR szRetAttribute;
    berelement * pCookie;
    szRetAttribute = ldap_first_attributeW(pLdap, pLDAPMsg, &pCookie);
    ppBerval = ldap_get_values_lenW(pLdap, pLDAPMsg, szRetAttribute);
    ldap_memfreeW(szRetAttribute);
    dwCount = ldap_count_values_len(ppBerval);

    DWORD cb;
    puReplStructArray pReplStructArray;
    Repl_DeMarshalBerval(structId, ppBerval, dwCount, NULL, &cb);
    pReplStructArray = (puReplStructArray)malloc(cb);
    Repl_DeMarshalBerval(structId, ppBerval, dwCount, pReplStructArray, &cb);

    wprintf(L"Queue statistic {%d.%d}{%d}\n\n", 
        pReplStructArray->singleReplStruct.queueStatistics.ftimeCurrentOpStarted.dwHighDateTime,
        pReplStructArray->singleReplStruct.queueStatistics.ftimeCurrentOpStarted.dwLowDateTime,
        pReplStructArray->singleReplStruct.queueStatistics.cNumPendingOps);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\test\replctrl\replctrltest.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    test.c

Abstract:

    LDAP Replication Control Test

    This test works at the leading edge of the replication change stream.
    First it reads all changes from usn 0 up to the present. It records a
    cookie marking this point in the stream. Then it creates
    a container, two child objects in the container, and then makes some
    modifications. When we ask for changes since the cookie, we know exactly
    what we should be getting.

Author:

    Will Lees (wlees) 14-Nov-2000

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <windows.h>
#include <ntldap.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>
#include <aclapi.h>

#include <winbase.h>
#include <winerror.h>
#include <assert.h>
#include <ntdsapi.h>

#include <ntsecapi.h>
#include <ntdsa.h>
#include <winldap.h>
#include <ntdsapi.h>
#include <drs.h>
#include <stddef.h>
#include <mdglobal.h>

#include "replctrl.h"

#define CONTAINER_RDN_W L"ou=replctrltest,"
#define CONTACT1_RDN_W L"cn=contact1,"
#define CONTACT2_RDN_W L"cn=contact2,"

/* External */

/* Static */

// Structures to describe object attributes
// These are at module level so that object creation and object
// verification can take advantage of them.

// objectClass: organizationUnit
LPWSTR rgpszValues1[2] = { L"organizationalUnit", NULL };
LDAPModW modAttr1 = { LDAP_MOD_ADD, L"objectClass", rgpszValues1 };
LDAPMod *rgpmodAttrs1[2] = { &modAttr1, NULL };

// objectClass: contact
// notes: this is some notes
// sn: Lees
// initials: B
// givenName: William
LPWSTR rgpszValues2[2] = { L"contact", NULL };
LDAPModW modAttr2 = { LDAP_MOD_ADD, L"objectClass", rgpszValues2 };
LPWSTR rgpszValues2a[2] = { L"this is some notes", NULL };
LDAPModW modAttr2a = { LDAP_MOD_ADD, L"notes", rgpszValues2a };
LPWSTR rgpszValues2b[2] = { L"Lees", NULL };
LDAPModW modAttr2b = { LDAP_MOD_ADD, L"sn", rgpszValues2b };
LPWSTR rgpszValues2c[2] = { L"B", NULL };
LDAPModW modAttr2c = { LDAP_MOD_ADD, L"initials", rgpszValues2c };
LPWSTR rgpszValues2d[2] = { L"William", NULL };
LDAPModW modAttr2d = { LDAP_MOD_ADD, L"givenName", rgpszValues2d };
LDAPMod *rgpmodAttrs2[6] = {
    &modAttr2,
    &modAttr2a,
    &modAttr2b,
    &modAttr2c,
    &modAttr2d,
    NULL };

// objectClass: contact
// notes: other notes
// sn: Parham
// initials: ?
// givenName: Jeffrey
LPWSTR rgpszValues4[2] = { L"contact", NULL };
LDAPModW modAttr4 = { LDAP_MOD_ADD, L"objectClass", rgpszValues4 };
LPWSTR rgpszValues4a[2] = { L"other notes", NULL };
LDAPModW modAttr4a = { LDAP_MOD_ADD, L"notes", rgpszValues4a };
LPWSTR rgpszValues4b[2] = { L"Parham", NULL };
LDAPModW modAttr4b = { LDAP_MOD_ADD, L"sn", rgpszValues4b };
LPWSTR rgpszValues4c[2] = { L"?", NULL };
LDAPModW modAttr4c = { LDAP_MOD_ADD, L"initials", rgpszValues4c };
LPWSTR rgpszValues4d[2] = { L"Jeffrey", NULL };
LDAPModW modAttr4d = { LDAP_MOD_ADD, L"givenName", rgpszValues4d };
LDAPMod *rgpmodAttrs4[6] = {
    &modAttr4,
    &modAttr4a,
    &modAttr4b,
    &modAttr4c,
    &modAttr4d,
    NULL };

// description: this is the description
LPWSTR rgpszValues3[2] = { L"this is the description", NULL };
LDAPModW modAttr3 = { LDAP_MOD_ADD, L"description", rgpszValues3 };

// managedBy: <dn filled in at runtime>
// This is a linked attribute by the way, which is critical for some
// of these tests.  It was difficult to find a linked attribute that would
// go on a vanilla container. Usually these are pretty specialized.
WCHAR szDn5a[MAX_PATH];
LPWSTR rgpszValues5[2] = { szDn5a, NULL };
LDAPModW modAttr5 = { LDAP_MOD_ADD, L"managedby", rgpszValues5 };
LDAPMod *rgpmodAttrs5[3] = {
    &modAttr3, &modAttr5, NULL };


/* Forward */
/* End Forward */


#if 0
// OBSOLETE method of changing a security descriptor
// Since I went to all the trouble of reversing engineering how to
// do this, I'm not about to delete it!
DWORD
protectObjectsDsVersion(
    LDAP *pLdap,
    LPWSTR pszNC
    )

/*++

Routine Description:

   This is the old way of changing a security descriptor.

Arguments:

    pLdap - 
    pszNC - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwWin32Error = ERROR_SUCCESS;
    ULONG ulLdapError = LDAP_SUCCESS;
    WCHAR szDn[MAX_PATH];
    LDAPMessage *pResults = NULL;
    LPWSTR rgpszAttrList[2] = { L"nTSecurityDescriptor", NULL };
    LDAPControlW ctrlSecurity;
    LDAPControlW *rgpctrlServer[2];
    BYTE berValue[2*sizeof(ULONG)];
    SECURITY_INFORMATION seInfo = DACL_SECURITY_INFORMATION
        | GROUP_SECURITY_INFORMATION
        | OWNER_SECURITY_INFORMATION;
    struct berval **ppbvValues = NULL;

    struct berval bvValue;
    struct berval *rgpbvValues[2] = { &bvValue, NULL };
    LDAPModW modAttr = { LDAP_MOD_REPLACE | LDAP_MOD_BVALUES,
                         L"nTSecurityDescriptor",
                         (LPWSTR *) rgpbvValues };
    LDAPMod *rgpmodAttrs[2] = { &modAttr, NULL };

    // initialize the ber val
    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE) (seInfo & 0xF);

    wcscpy( szDn, CONTACT1_RDN_W );
    wcscat( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    ctrlSecurity.ldctl_oid = LDAP_SERVER_SD_FLAGS_OID_W;
    ctrlSecurity.ldctl_iscritical = TRUE;
    ctrlSecurity.ldctl_value.bv_len = 5;
    ctrlSecurity.ldctl_value.bv_val = (PCHAR)berValue;

    rgpctrlServer[0] = &ctrlSecurity;
    rgpctrlServer[1] = NULL;

    ulLdapError = ldap_search_ext_s(pLdap,  // handle
                                    szDn,   // base
                                    LDAP_SCOPE_BASE, // scope
                                    L"(objectClass=*)", // filter
                                    rgpszAttrList, // attrs
                                    0, // attrsonly
                                    rgpctrlServer, // server controls
                                    NULL, // client controls
                                    NULL, // timeout
                                    0, // sizelimit
                                    &pResults);
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_search", dwWin32Error );
        goto cleanup;
    }
    if (pResults == NULL) {
        dwWin32Error = ERROR_DS_NO_SUCH_OBJECT;
        goto cleanup;
    }

    ppbvValues = ldap_get_values_len( pLdap, pResults, rgpszAttrList[0] );
    if (ppbvValues == NULL) {
        printf( "Expected attribute %ls is missing from entry %ls\n",
                rgpszAttrList[0],
                szDn);
        dwWin32Error = ERROR_DS_MISSING_REQUIRED_ATT;
        goto cleanup;
    }

    // Update the security descriptor

    bvValue.bv_len = (*ppbvValues)->bv_len;
    bvValue.bv_val = (*ppbvValues)->bv_val;

    // Write it back

    ulLdapError = ldap_modify_sW( pLdap, szDn, rgpmodAttrs );
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_modify", dwWin32Error );
        goto cleanup;
    }

    printf( "\tprotected %ls.\n", szDn );

cleanup:
    if (pResults) {
        ldap_msgfree(pResults);
    }
    if ( ppbvValues ) {
        ldap_value_free_len(ppbvValues);
    }

    return dwWin32Error;

} /* protectObjectsDsVersion */
#endif


DWORD
protectSingleObject(
    LPWSTR pszDn
    )

/*++

Routine Description:

    Revoke authenticated user access to an object

Arguments:

    pszDn - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwWin32Error = ERROR_SUCCESS;
    PACL pOldDacl, pNewDacl = NULL;
    PBYTE pSD = NULL;
    EXPLICIT_ACCESS ea;

   dwWin32Error = GetNamedSecurityInfoW( pszDn,
                                         SE_DS_OBJECT_ALL,
                                         DACL_SECURITY_INFORMATION,
                                         NULL, // psidOwner
                                         NULL, // psidGroup
                                         &pOldDacl, // pDacl
                                         NULL, // pSacl
                                         &pSD );
    if (dwWin32Error) {
        printf( "Call %s failed with win32 error %d\n", "GetNamedSecurityInfo(DS_OBJECT)", dwWin32Error );
        goto cleanup;
    }

    // Revoke access to domain authenticated users
    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
    ea.grfAccessMode = REVOKE_ACCESS;
    ea.Trustee.TrusteeForm = TRUSTEE_IS_NAME;
    ea.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    ea.Trustee.ptstrName = "AUTHENTICATED USERS";

    dwWin32Error = SetEntriesInAcl( 1, &ea, pOldDacl, &pNewDacl );
    if (dwWin32Error) {
        printf( "Call %s failed with win32 error %d\n", "SetEntriesInAcl", dwWin32Error );
        goto cleanup;
    }

    dwWin32Error = SetNamedSecurityInfoW( pszDn,
                                         SE_DS_OBJECT_ALL,
                                         DACL_SECURITY_INFORMATION,
                                         NULL, // psidOwner
                                         NULL, // psidGroup
                                         pNewDacl, // pDacl
                                         NULL // pSacl
                                         );
    if (dwWin32Error) {
        printf( "Call %s failed with win32 error %d\n", "SetNamedSecurityInfo(DS_OBJECT)", dwWin32Error );
        goto cleanup;
    }

    printf( "\tprotected %ls.\n", pszDn );

cleanup:
    if (pSD) {
        LocalFree( pSD );
    }
    if (pNewDacl) {
        LocalFree( pNewDacl );
    }

    return dwWin32Error;
} /* protectSingleObject */


DWORD
protectObjects(
    LPWSTR pszNC
    )

/*++

Routine Description:

    Protect some objects against the user

Arguments:

    pszNC - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwWin32Error = ERROR_SUCCESS;
    WCHAR szDn[MAX_PATH];

    wcscpy( szDn, CONTACT1_RDN_W );
    wcscat( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    dwWin32Error = protectSingleObject( szDn );
    if (dwWin32Error) {
        goto cleanup;
    }

    wcscpy( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    dwWin32Error = protectSingleObject( szDn );
    if (dwWin32Error) {
        goto cleanup;
    }

cleanup:
    return dwWin32Error;

} /* protectObjects */

DWORD
getForestVersion(
    LDAP *pLdap,
    DWORD *pdwForestVersion
    )

/*++

Routine Description:

    Read the forest version attribute

Arguments:

    pLdap - 
    pdwForestVersion - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwWin32Error = ERROR_SUCCESS;
    ULONG ulLdapError = LDAP_SUCCESS;
    LDAPMessage *pRootResults = NULL;
    LDAPMessage *pPartResults = NULL;
    LPWSTR *ppszConfigNC = NULL;
    LPWSTR *ppszValues = NULL;
    WCHAR pszPartitionsDn[MAX_PATH];
    LPWSTR rgpszAttrList[2] = { L"msds-behavior-version", NULL };

    // Read config nc from RootDSE
    ulLdapError = ldap_search_s(pLdap, NULL, LDAP_SCOPE_BASE, L"(objectClass=*)", NULL,
                          0, &pRootResults);
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_search", dwWin32Error );
        goto cleanup;
    }
    if (pRootResults == NULL) {
        dwWin32Error = ERROR_DS_NO_SUCH_OBJECT;
        goto cleanup;
    }

    ppszConfigNC = ldap_get_valuesW(pLdap, pRootResults,
                                    L"configurationNamingContext");
    if ( (ppszConfigNC == NULL) ||
         (*ppszConfigNC == NULL) ||
         (wcslen(*ppszConfigNC) == 0) ) {
        printf( "Expected attribute %ls is missing from entry %ls\n",
                L"configurationNamingContext",
                L"(root)");
        dwWin32Error = ERROR_DS_MISSING_REQUIRED_ATT;
        goto cleanup;
    }

    // Form partitions container dn

    wcscpy( pszPartitionsDn, L"cn=partitions," );
    wcscat( pszPartitionsDn, *ppszConfigNC );

    // Read behavior version
    ulLdapError = ldap_search_s(pLdap, pszPartitionsDn, LDAP_SCOPE_BASE, L"(objectClass=*)",
                                rgpszAttrList, 0, &pPartResults);
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_search", dwWin32Error );
        goto cleanup;
    }
    if (pPartResults == NULL) {
        dwWin32Error = ERROR_DS_NO_SUCH_OBJECT;
        goto cleanup;
    }

    ppszValues = ldap_get_valuesW(pLdap, pPartResults,
                                    L"msds-behavior-version");
    if ( (ppszValues == NULL) ||
         (*ppszValues == NULL) ||
         (wcslen(*ppszValues) == 0) ) {
        printf( "Expected attribute %ls is missing from entry %ls\n",
                L"msds-behavior-version",
                pszPartitionsDn);
        dwWin32Error = ERROR_DS_MISSING_REQUIRED_ATT;
        goto cleanup;
    }

    *pdwForestVersion = _wtoi(*ppszValues);

cleanup:
    // Release results
    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }
    if (pPartResults) {
        ldap_msgfree(pPartResults);
    }
    if (ppszConfigNC) {
        ldap_value_free( ppszConfigNC );
    }
    if (ppszValues) {
        ldap_value_free( ppszValues );
    }

    return dwWin32Error;

} /* getForestVersion */



DWORD
verifySingleObjectAttribute(
    LDAP *pLdap,
    LDAPMessage *pLdapEntry,
    LPWSTR pszDN,
    LDAPModW *pmodCurrent
    )

/*++

Routine Description:

    Given a LDAPMOD structure describing a single change to an attribute, see
    if that change is reflected in the Ldap Entry

Arguments:

    pLdap - 
    pLdapEntry - 
    pszDN - 
    pmodCurrent - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwWin32Error = ERROR_SUCCESS;
    LPWSTR *ppszLastValue;
    LPWSTR *ppszValues = NULL;
    LPWSTR pszValue;
    WCHAR szAttributeName[MAX_PATH];

    wcscpy( szAttributeName, pmodCurrent->mod_type );
    ppszValues = ldap_get_values( pLdap, pLdapEntry, szAttributeName );
    if (!ppszValues) {
        wcscat( szAttributeName, L";range=1-1" );
        ppszValues = ldap_get_values( pLdap, pLdapEntry, szAttributeName );
    }
    if (!ppszValues) {
        printf( "Expected attribute %ls is missing from entry %ls\n",
                pmodCurrent->mod_type,
                pszDN);
        dwWin32Error = ERROR_DS_MISSING_REQUIRED_ATT;
        goto cleanup;
    }

    // Skip to the last value in a multi-value
    ppszLastValue = ppszValues;
    while( *(ppszLastValue + 1) ) {
        ppszLastValue++;
    }

    // Deal with dn-values, which come back in extended form
    pszValue = wcschr( *ppszLastValue, L';' );
    if (pszValue) {
        pszValue++; // Skip separator
    } else {
        pszValue = *ppszLastValue;
    }

    if (_wcsicmp( pszValue, pmodCurrent->mod_vals.modv_strvals[0] )) {
        printf( "Expected value %ls on attribute %ls is missing from entry %ls\n",
                pmodCurrent->mod_vals.modv_strvals[0],
                pmodCurrent->mod_type,
                pszDN);
        printf( "Expected: %ls, actual: %ls\n",
                pmodCurrent->mod_vals.modv_strvals[0],
                *pszValue );
        dwWin32Error = ERROR_DS_MISSING_REQUIRED_ATT;
        goto cleanup;
    }

cleanup:
    if (ppszValues) {
        ldap_value_free( ppszValues );
    }

    return dwWin32Error;
} /* verifySingleObjectAttribute */


DWORD
verifyObjectAttributes(
    LDAP *pLdap,
    LDAPMessage *pLdapEntry,
    LPWSTR pszRDN,
    LDAPModW **rgpmodAttrs
    )

/*++

Routine Description:

    Verify that the changes described by the LDAPMod structure are actually
    present in the entry.

Arguments:

    pLdap - 
    pLdapEntry - 
    pszRDN - 
    rgpmodAttrs - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwWin32Error = ERROR_SUCCESS;
    LDAPModW *pmodCurrent;
    LPWSTR pszDN = NULL;

    pszDN = ldap_get_dnW(pLdap, pLdapEntry);
    if (pszDN == NULL) {
        printf( "Expected entry dn is missing\n" );
        dwWin32Error = ERROR_DS_MISSING_REQUIRED_ATT;
        goto cleanup;
    }

    // Skip to second segment of extended dn
    pszDN = wcschr( pszDN, L';' ) + 1;

    if (_wcsnicmp( pszDN, pszRDN, wcslen( pszRDN ) )) {
        printf( "Expected entry dn is missing\n" );
        printf( "Expected: %ls, actual: %ls\n", pszRDN, pszDN );
        dwWin32Error = ERROR_DS_NO_SUCH_OBJECT;
        goto cleanup;
    }

    while (pmodCurrent = *rgpmodAttrs++) {
        dwWin32Error = verifySingleObjectAttribute(
            pLdap,
            pLdapEntry,
            pszDN,
            pmodCurrent );
        if (dwWin32Error) {
            goto cleanup;
        }
    }

    printf( "\tverified %ls.\n", pszDN );

cleanup:
    if (pszDN) {
        ldap_memfreeW(pszDN);
    }

    return dwWin32Error;

} /* verifyObjectAttributes */


DWORD
getSecuredChanges(
    LDAP *pLdap,
    LPWSTR pszNC,
    PBYTE pbCookie,
    DWORD cbCookie
    )

/*++

Routine Description:

    Check for changes that should be visible to an unprivileged user
    after the objects have been protected

Arguments:

    pLdap - 
    pszNC - 
    pbCookie - 
    cbCookie - 

Return Value:

    DWORD - 

--*/

{
    BOOL fMoreData = TRUE;
    DWORD dwWin32Error = ERROR_SUCCESS;
    LDAPMessage *pChangeEntries = NULL;
    PBYTE pbCookieNew = NULL;
    DWORD cbCookieNew = 0;
    DWORD cEntries, cExpectedEntries;
    LDAPMessage *pLdapEntry;
    DWORD dwReplFlags = 0;

    dwReplFlags |= DRS_DIRSYNC_PUBLIC_DATA_ONLY |
        DRS_DIRSYNC_INCREMENTAL_VALUES;

    printf( "\tBegin expected errors...\n" );
    // Try once without the OBJECT_SECURITY flag
    dwWin32Error = DsGetSourceChangesW(
        pLdap,  // ldap handle
        pszNC,  // search base
        NULL, // Source filter
        dwReplFlags, // repl flags
        pbCookie,
        cbCookie,
        &pChangeEntries,  // search result
        &fMoreData,
        &pbCookieNew,
        &cbCookieNew,
        NULL // att list array
        );
    printf( "\tEnd expected errors...\n" );
    if (dwWin32Error != ERROR_ACCESS_DENIED) {
        if (dwWin32Error == ERROR_SUCCESS) {
            dwWin32Error = ERROR_DS_INTERNAL_FAILURE;
        }
        // New cookie will not be allocated
        printf( "Call %s failed with win32 error %d\n", "DsGetSourceChanges", dwWin32Error );
        goto cleanup;
    }

    dwReplFlags |= DRS_DIRSYNC_OBJECT_SECURITY;
    // Try again with the OBJECT_SECURITY flag
    dwWin32Error = DsGetSourceChangesW(
        pLdap,  // ldap handle
        pszNC,  // search base
        NULL, // Source filter
        dwReplFlags, // repl flags
        pbCookie,
        cbCookie,
        &pChangeEntries,  // search result
        &fMoreData,
        &pbCookieNew,
        &cbCookieNew,
        NULL // att list array
        );
    if (dwWin32Error != ERROR_SUCCESS) {
        // New cookie will not be allocated
        printf( "Call %s failed with win32 error %d\n", "DsGetSourceChanges", dwWin32Error );
        goto cleanup;
    }
    if (!pChangeEntries) {
        printf( "Expected change entries not returned\n" );
        dwWin32Error = ERROR_DS_NO_SUCH_OBJECT;
        goto cleanup;
    }

    if (fMoreData) {
        printf( "Expected end of change entries not returned\n" );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    cExpectedEntries = 1;

    cEntries = ldap_count_entries(pLdap, pChangeEntries);

    // We are expecting a certain number of objects here
    if (cEntries != cExpectedEntries) {
        printf( "Expected number of change entries not returned\n" );
        printf( "Expected: %d, actual %d\n", cExpectedEntries, cEntries );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    // First object
    pLdapEntry = ldap_first_entry( pLdap, pChangeEntries );
    dwWin32Error = verifySingleObjectAttribute(
        pLdap,
        pLdapEntry,
        CONTACT2_RDN_W,
        &modAttr4b );
    if (dwWin32Error) {
        goto cleanup;
    }

    // End of stream
    pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    if (pLdapEntry) {
        printf( "Expected end of change entries not returned\n" );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

cleanup:

    // Release changes
    if (pChangeEntries) {
        ldap_msgfree(pChangeEntries);
    }

    if ( pbCookieNew ) {
        DsFreeReplCookie( pbCookieNew );
    }

    return dwWin32Error;
} /* getFilteredChanges */


DWORD
getFilteredChanges(
    LDAP *pLdap,
    LPWSTR pszNC,
    PBYTE pbCookie,
    DWORD cbCookie
    )

/*++

Routine Description:

    Check that the correct changes are visible when filtering is being used

Arguments:

    pLdap - 
    pszNC - 
    pbCookie - 
    cbCookie - 

Return Value:

    DWORD - 

--*/

{
    BOOL fMoreData = TRUE;
    DWORD dwWin32Error = ERROR_SUCCESS;
    LDAPMessage *pChangeEntries = NULL;
    PBYTE pbCookieNew = NULL;
    DWORD cbCookieNew = 0;
    DWORD cEntries, cExpectedEntries;
    LDAPMessage *pLdapEntry;
    DWORD dwReplFlags = 0;
    LPWSTR rgpszAttList[2] = { L"sn", NULL };

    dwReplFlags |= DRS_DIRSYNC_PUBLIC_DATA_ONLY |
        DRS_DIRSYNC_INCREMENTAL_VALUES;

    dwWin32Error = DsGetSourceChangesW(
        pLdap,  // ldap handle
        pszNC,  // search base
        L"(objectClass=contact)", // Source filter
        dwReplFlags, // repl flags
        pbCookie,
        cbCookie,
        &pChangeEntries,  // search result
        &fMoreData,
        &pbCookieNew,
        &cbCookieNew,
        rgpszAttList // att list array
        );
    if (dwWin32Error != ERROR_SUCCESS) {
        // New cookie will not be allocated
        printf( "Call %s failed with win32 error %d\n", "DsGetSourceChanges", dwWin32Error );
        goto cleanup;
    }

    if (!pChangeEntries) {
        printf( "Expected change entries not returned\n" );
        dwWin32Error = ERROR_DS_NO_SUCH_OBJECT;
        goto cleanup;
    }

    if (fMoreData) {
        printf( "Expected end of change entries not returned\n" );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    cExpectedEntries = 2;

    cEntries = ldap_count_entries(pLdap, pChangeEntries);

    // We are expecting a certain number of objects here
    if (cEntries != cExpectedEntries) {
        printf( "Expected number of change entries not returned\n" );
        printf( "Expected: %d, actual %d\n", cExpectedEntries, cEntries );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    // First object
    pLdapEntry = ldap_first_entry( pLdap, pChangeEntries );
    dwWin32Error = verifySingleObjectAttribute(
        pLdap,
        pLdapEntry,
        CONTACT1_RDN_W,
        &modAttr2b );
    if (dwWin32Error) {
        goto cleanup;
    }

    // Second object
    pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    dwWin32Error = verifySingleObjectAttribute(
        pLdap,
        pLdapEntry,
        CONTACT2_RDN_W,
        &modAttr4b );
    if (dwWin32Error) {
        goto cleanup;
    }

    // End of stream
    pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    if (pLdapEntry) {
        printf( "Expected end of change entries not returned\n" );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

cleanup:

    // Release changes
    if (pChangeEntries) {
        ldap_msgfree(pChangeEntries);
    }

    if ( pbCookieNew ) {
        DsFreeReplCookie( pbCookieNew );
    }

    return dwWin32Error;
} /* getFilteredChanges */


DWORD
getAllChanges(
    LDAP *pLdap,
    LPWSTR pszNC,
    PBYTE pbCookie,
    DWORD cbCookie,
    DWORD dwReplFlags
    )

/*++

Routine Description:

    Check that the changes match what we expect.
    Different kinds of checks are done according to:
    flags = none (ie last change first order)
    flags = ancestors first
    flags = incremental values

Arguments:

    pLdap - 
    pszNC - 
    pbCookie - 
    cbCookie - 
    fAncestorFirstOrder - 

Return Value:

    DWORD - 

--*/

{
    BOOL fMoreData = TRUE;
    DWORD dwWin32Error = ERROR_SUCCESS;
    LDAPMessage *pChangeEntries = NULL;
    PBYTE pbCookieNew = NULL;
    DWORD cbCookieNew = 0;
    DWORD cEntries, cExpectedEntries;
    LDAPMessage *pLdapEntry;
    LPWSTR pszFirstRdn, pszSecondRdn, pszThirdRdn;
    LDAPModW **rgpmodFirstMod, **rgpmodSecondMod, **rgpmodThirdMod;

    dwReplFlags |= DRS_DIRSYNC_PUBLIC_DATA_ONLY;

    dwWin32Error = DsGetSourceChangesW(
        pLdap,  // ldap handle
        pszNC,  // search base
        NULL, // Source filter
        dwReplFlags, // repl flags
        pbCookie,
        cbCookie,
        &pChangeEntries,  // search result
        &fMoreData,
        &pbCookieNew,
        &cbCookieNew,
        NULL // att list array
        );
    if (dwWin32Error != ERROR_SUCCESS) {
        // New cookie will not be allocated
        printf( "Call %s failed with win32 error %d\n", "DsGetSourceChanges", dwWin32Error );
        goto cleanup;
    }

    if (!pChangeEntries) {
        printf( "Expected change entries not returned\n" );
        dwWin32Error = ERROR_DS_NO_SUCH_OBJECT;
        goto cleanup;
    }

    if (fMoreData) {
        printf( "Expected end of change entries not returned\n" );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    cExpectedEntries = (dwReplFlags & DRS_DIRSYNC_INCREMENTAL_VALUES) ? 4 : 3;

    cEntries = ldap_count_entries(pLdap, pChangeEntries);

    // We are expecting three objects here
    if (cEntries != cExpectedEntries) {
        printf( "Expected number of change entries not returned\n" );
        printf( "Expected: %d, actual %d\n", cExpectedEntries, cEntries );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    if (dwReplFlags & DRS_DIRSYNC_ANCESTORS_FIRST_ORDER) {
        pszFirstRdn = CONTAINER_RDN_W;
        pszSecondRdn = CONTACT1_RDN_W; 
        pszThirdRdn = CONTACT2_RDN_W; 
        rgpmodFirstMod = rgpmodAttrs1;
        rgpmodSecondMod = rgpmodAttrs2;
        rgpmodThirdMod = rgpmodAttrs4;
    } else {
        pszFirstRdn = CONTACT1_RDN_W;
        pszSecondRdn = CONTACT2_RDN_W;
        pszThirdRdn = CONTAINER_RDN_W;
        rgpmodFirstMod = rgpmodAttrs2;
        rgpmodSecondMod = rgpmodAttrs4;
        rgpmodThirdMod = rgpmodAttrs1;
    }

    // First object
    pLdapEntry = ldap_first_entry( pLdap, pChangeEntries );
    dwWin32Error = verifyObjectAttributes( pLdap, pLdapEntry, pszFirstRdn, rgpmodFirstMod );
    if (dwWin32Error) {
        goto cleanup;
    }

    // Second object
    pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    dwWin32Error = verifyObjectAttributes( pLdap, pLdapEntry, pszSecondRdn, rgpmodSecondMod );
    if (dwWin32Error) {
        goto cleanup;
    }

    // Third object
    pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    dwWin32Error = verifyObjectAttributes( pLdap, pLdapEntry, pszThirdRdn, rgpmodThirdMod );
    if (dwWin32Error) {
        goto cleanup;
    }

    if (dwReplFlags & DRS_DIRSYNC_INCREMENTAL_VALUES) {
        // The linked attr change should appear as a separate change
        // in incremental mode
        pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );

        dwWin32Error = verifySingleObjectAttribute(
            pLdap,
            pLdapEntry,
            CONTAINER_RDN_W,
            &modAttr5 );
        if (dwWin32Error) {
            goto cleanup;
        }
    }

    // End of stream
    pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    if (pLdapEntry) {
        printf( "Expected end of change entries not returned\n" );
        dwWin32Error = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        goto cleanup;
    }

    // Reposition on container, whereever it is in the stream
    pLdapEntry = ldap_first_entry( pLdap, pChangeEntries );
    if (!(dwReplFlags & DRS_DIRSYNC_ANCESTORS_FIRST_ORDER)) {
        pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
        pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    }

    if (!(dwReplFlags & DRS_DIRSYNC_INCREMENTAL_VALUES)) {
        // The linked attr change should appear as part of the object
        // in non-incremental mode
        dwWin32Error = verifySingleObjectAttribute(
            pLdap,
            pLdapEntry,
            CONTAINER_RDN_W,
            &modAttr5 );
        if (dwWin32Error) {
            goto cleanup;
        }
    }

    // The container should have the non-linked attr change
    dwWin32Error = verifySingleObjectAttribute(
        pLdap,
        pLdapEntry,
        CONTAINER_RDN_W,
        &modAttr3 );
    if (dwWin32Error) {
        goto cleanup;
    }

cleanup:

    // Release changes
    if (pChangeEntries) {
        ldap_msgfree(pChangeEntries);
    }

    if ( pbCookieNew ) {
        DsFreeReplCookie( pbCookieNew );
    }

    return dwWin32Error;
} /* getAllChanges */


DWORD
syncChanges(
    LDAP *pLdap,
    LPWSTR pszNC,
    PBYTE *ppbCookie,
    DWORD *pcbCookie
    )

/*++

Routine Description:

    Read all changes up to the present

Arguments:

    pLdap - 
    ppbCookie - 
    pcbCookie - 

Return Value:

    BOOL - 

--*/

{
    PBYTE pbCookie = NULL;
    DWORD cbCookie = 0;
    BOOL fMoreData = TRUE;
    DWORD dwWin32Error = ERROR_SUCCESS;
    LDAPMessage *pChangeEntries = NULL;

    // Start from scratch
    // Perf optimization: we only want the cookie advanced. We don't care
    // about the changes themselves. Filter them out.


    while (fMoreData) {
        PBYTE pbCookieNew;
        DWORD cbCookieNew;

        dwWin32Error = DsGetSourceChangesW(
            pLdap,  // ldap handle
            pszNC,  // search base
            L"(!(objectClass=*))", // Source filter
            DRS_DIRSYNC_PUBLIC_DATA_ONLY, // repl flags
            pbCookie,
            cbCookie,
            &pChangeEntries,  // search result
            &fMoreData,
            &pbCookieNew,
            &cbCookieNew,
            NULL // att list array
            );
        if (dwWin32Error != ERROR_SUCCESS) {
            // New cookie will not be allocated
            break;
        }

        {
            LDAPMessage *pLdapEntry;
            BerElement *pBer = NULL;
            LPWSTR attr;
            DWORD cAttributes = 0;

            for( pLdapEntry = ldap_first_entry( pLdap, pChangeEntries );
                 pLdapEntry;
                 pLdapEntry = ldap_next_entry( pLdap, pLdapEntry ) ) {

                // List attributes in object
                for (attr = ldap_first_attributeW(pLdap, pLdapEntry, &pBer);
                     attr != NULL;
                     attr = ldap_next_attributeW(pLdap, pLdapEntry, pBer))
                {
                    cAttributes++;
                }
            }
            printf( "\t[skipped %d entries, %d attributes]\n",
                    ldap_count_entries(pLdap, pChangeEntries),
                    cAttributes );
        }

        // Release changes
        ldap_msgfree(pChangeEntries);

        // get rid of old cookie
        if ( pbCookie ) {
            DsFreeReplCookie( pbCookie );
        }
        // Make new cookie the current cookie
        pbCookie = pbCookieNew;
        cbCookie = cbCookieNew;
    }

// Cleanup

    if (dwWin32Error) {
        if ( pbCookie ) {
            DsFreeReplCookie( pbCookie );
        }
    } else {
        // return the cookie
        *ppbCookie = pbCookie;
        *pcbCookie = cbCookie;
    }

    return dwWin32Error;
} /* syncChanges */


DWORD
createObjects(
    LDAP *pLdap,
    LPWSTR pszNC
    )

/*++

Routine Description:

    Create the objects and changes for the test

Arguments:

    pLdap - 
    pszNC - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwWin32Error = ERROR_SUCCESS;
    ULONG ulLdapError = LDAP_SUCCESS;
    WCHAR szDn[MAX_PATH];

    // Create the container

    wcscpy( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    ulLdapError = ldap_add_sW( pLdap, szDn, rgpmodAttrs1 );
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_add", dwWin32Error );
        goto cleanup;
    }
    printf( "\tadded %ls.\n", szDn );

    // Create a contact in the container

    wcscpy( szDn, CONTACT1_RDN_W );
    wcscat( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );
    wcscpy( szDn5a, szDn );  // Initialize global

    ulLdapError = ldap_add_sW( pLdap, szDn, rgpmodAttrs2 );
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_add", dwWin32Error );
        goto cleanup;
    }
    printf( "\tadded %ls.\n", szDn );

    // Create another contact in the container

    wcscpy( szDn, CONTACT2_RDN_W );
    wcscat( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    ulLdapError = ldap_add_sW( pLdap, szDn, rgpmodAttrs4 );
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_add", dwWin32Error );
        goto cleanup;
    }
    printf( "\tadded %ls.\n", szDn );

    // Modify the container
    // This forces it to replicate later in the stream

    wcscpy( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    ulLdapError = ldap_modify_sW( pLdap, szDn, rgpmodAttrs5 );
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_modify", dwWin32Error );
        goto cleanup;
    }
    printf( "\tmodified %ls.\n", szDn );


cleanup:

    return dwWin32Error;
} /* createObjects */


DWORD
deleteObjects(
    LDAP *pLdap,
    LPWSTR pszNC
    )

/*++

Routine Description:

    Delete the objects from the prior run of the test

Arguments:

    pLdap - 
    pszNC - 

Return Value:

    DWORD - 

--*/

{
    DWORD dwWin32Error = ERROR_SUCCESS;
    ULONG ulLdapError = LDAP_SUCCESS;
    WCHAR szDn[MAX_PATH];

    wcscpy( szDn, CONTACT1_RDN_W );
    wcscat( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    ulLdapError = ldap_delete_sW( pLdap, szDn );
    if (ulLdapError) {
        if (ulLdapError != LDAP_NO_SUCH_OBJECT) {
            printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
            dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
            printf( "Call %s failed with win32 error %d\n", "ldap_delete", dwWin32Error );
            goto cleanup;
        }
    } else {
        printf( "\tdeleted %ls.\n", szDn );
    }

    wcscpy( szDn, CONTACT2_RDN_W );
    wcscat( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    ulLdapError = ldap_delete_sW( pLdap, szDn );
    if (ulLdapError) {
        if (ulLdapError != LDAP_NO_SUCH_OBJECT) {
            printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
            dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
            printf( "Call %s failed with win32 error %d\n", "ldap_delete", dwWin32Error );
            goto cleanup;
        }
    } else {
        printf( "\tdeleted %ls.\n", szDn );
    }

    wcscpy( szDn, CONTAINER_RDN_W );
    wcscat( szDn, pszNC );

    ulLdapError = ldap_delete_sW( pLdap, szDn );
    if (ulLdapError) {
        if (ulLdapError != LDAP_NO_SUCH_OBJECT) {
            printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
            dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
            printf( "Call %s failed with win32 error %d\n", "ldap_delete", dwWin32Error );
            goto cleanup;
        }
    } else {
        printf( "\tdeleted %ls.\n", szDn );
    }

cleanup:

    return dwWin32Error;

} /* deleteObjects */


int __cdecl
wmain(
    int Argc,
    LPWSTR Argv[]
    )

/*++

Routine Description:

    Run the LDAP replication control test

Arguments:

    argc - 
    [] - 

Return Value:

    int __cdecl - 

--*/

{
    LDAP *pLdap;
    ULONG ulOptions;
    DWORD dwWin32Error = ERROR_SUCCESS;
    ULONG ulLdapError = LDAP_SUCCESS;
    PBYTE pbCookie = NULL;
    DWORD cbCookie;
    LPWSTR pszNC, pszUser, pszDomain, pszPassword;
    DWORD dwForestVersion;
    RPC_AUTH_IDENTITY_HANDLE hCredentials = NULL;

    if (Argc < 5) {
        printf( "%ls <naming context> <user> <domain> <password>\n", Argv[0] );
        printf( "The logged in account should be able to create objects.\n" );
        printf( "The supplied account will be used for impersonation during\n" );
        printf( "the test.  It should be a normal domain account.\n" );
        printf( "The forest version should be Whistler, although this program\n" );
        printf( "will run most of the tests in W2K forest mode.\n" );
        return 1;
    }

    printf( "LDAP Replication Control Test\n" );

    pszNC = Argv[1];
    pszUser = Argv[2];
    pszDomain = Argv[3];
    pszPassword = Argv[4];

    pLdap = ldap_initW(L"localhost", LDAP_PORT);
    if (NULL == pLdap) {
        printf("Cannot open LDAP connection to localhost.\n" );
        dwWin32Error = GetLastError();
        printf( "Call %s failed with win32 error %d\n", "ldap_init", dwWin32Error );
        goto cleanup;
    }

    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( pLdap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    //
    // Bind
    //

    ulLdapError = ldap_bind_sA( pLdap, NULL, NULL, LDAP_AUTH_SSPI);
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_bind", dwWin32Error );
        goto cleanup;
    }

    // Check that the test can run
    dwWin32Error = getForestVersion( pLdap, &dwForestVersion );
    if (dwWin32Error) {
        goto cleanup;
    }

    // Clean out old objects from prior run
    printf( "\nClean out prior objects.\n" );
    dwWin32Error = deleteObjects( pLdap, pszNC );
    if (dwWin32Error) {
        goto cleanup;
    }

    printf( "\nSynchronize with change stream.\n" );
    dwWin32Error = syncChanges( pLdap, pszNC, &pbCookie, &cbCookie );
    if (dwWin32Error) {
        goto cleanup;
    }

    // Create some changes
    printf( "\nMake some changes by creating objects.\n" );
    dwWin32Error = createObjects( pLdap, pszNC );
    if (dwWin32Error) {
        goto cleanup;
    }

    // Get all changes
    // nc granular security, no incremental, no ancestors
    printf( "\nTest: all changes are returned in last-changed (USN) order.\n" );
    dwWin32Error = getAllChanges( pLdap, pszNC, pbCookie, cbCookie,
                                  0 /* no flags */ );
    if (dwWin32Error) {
        goto cleanup;
    }
    printf( "\tPassed.\n" );

    // nc granular security, no incremental, ancestors
    printf( "\nTest: all changes are returned in ancestor-first order.\n" );
    dwWin32Error = getAllChanges( pLdap, pszNC, pbCookie, cbCookie,
                                  DRS_DIRSYNC_ANCESTORS_FIRST_ORDER );
    if (dwWin32Error) {
        goto cleanup;
    }
    printf( "\tPassed.\n" );

    if (dwForestVersion > DS_BEHAVIOR_WIN2000) {
        // nc granular security, incremental, ancestors
        printf( "\nTest: all changes in USN order, values shown incrementally.\n" );
        dwWin32Error = getAllChanges( pLdap, pszNC, pbCookie, cbCookie,
                                      DRS_DIRSYNC_INCREMENTAL_VALUES );
        if (dwWin32Error) {
            goto cleanup;
        }
        printf( "\tPassed.\n" );
    } else {
        printf( "\nWarning: incremental value test skipped because forest verson is too low.\n" );
    }

    // Object filter
    // Attribute filter
    printf( "\nTest: filtered object/attribute.\n" );
    dwWin32Error = getFilteredChanges( pLdap, pszNC, pbCookie, cbCookie );
    if (dwWin32Error) {
        goto cleanup;
    }
    printf( "\tPassed.\n" );

    // Deny visibility of some objects
    printf( "\nChange protection on objects\n" );
    dwWin32Error = protectObjects( pszNC );
    if (dwWin32Error) {
        goto cleanup;
    }

    // Impersonate a user
    dwWin32Error = DsMakePasswordCredentialsW( pszUser, pszDomain, pszPassword, &hCredentials );
    if (dwWin32Error) {
        printf( "Failed to construct password credentials.\n" );
        goto cleanup;
    }

    if (pLdap) {
        ldap_unbind(pLdap);
    }
    pLdap = ldap_initW(L"localhost", LDAP_PORT);
    if (NULL == pLdap) {
        printf("Cannot open LDAP connection to localhost.\n" );
        dwWin32Error = GetLastError();
        printf( "Call %s failed with win32 error %d\n", "ldap_init", dwWin32Error );
        goto cleanup;
    }

    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( pLdap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    //
    // Bind
    //

    ulLdapError = ldap_bind_sA( pLdap, NULL, hCredentials, LDAP_AUTH_SSPI);
    if (ulLdapError) {
        printf( "Ldap error: %ws\n", ldap_err2string( ulLdapError ) );
        dwWin32Error = LdapMapErrorToWin32( ulLdapError ); 
        printf( "Call %s failed with win32 error %d\n", "ldap_bind", dwWin32Error );
        goto cleanup;
    }

    // Verify that we cannot see the objects
    // Verify that we cannot see the values
    printf( "\nTest: secured object/attribute.\n" );
    dwWin32Error = getSecuredChanges( pLdap, pszNC, pbCookie, cbCookie );
    if (dwWin32Error) {
        goto cleanup;
    }
    printf( "\tPassed.\n" );
 
cleanup:
    if ( pbCookie) {
        DsFreeReplCookie( pbCookie );
    }

    if (pLdap) {
        ldap_unbind(pLdap);
    }

    if (hCredentials) {
        DsFreePasswordCredentials( hCredentials );
    }

    if (dwWin32Error) {
        printf( "\nSummary: One or more failures occurred.\n" );
    } else {
        printf( "\nSummary: All tests passed.\n" );
    }

    return 0;
} /* wmain */

/* end test.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\test\spn\testspn.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    testspn.c

Abstract:

    Program to test SPN api functions

Author:

    Will Lees (wlees) 20-Jan-1998

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsapi.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntdsapi.h>
#include <ntdsapip.h>

#define SECURITY_WIN32      // Who should set this, and to what?
#include <security.h>       // GetComputerNameEx

#include <winsock2.h>

#define MAX_SPN 1024
#define MAX_NAME_LENGTH 256
#define MAX_INSTANCES 5
#define MAX_ALIASES 5

#define COMPUTERNAME_TOKEN "<computername>"
#define COMPUTERDNS_TOKEN "<computerdns>"
#define COMPUTERDN_TOKEN "<computerdn>"

typedef struct _MAKE_SPN_TEST_CASE {
    LPSTR ServiceClass;
    LPSTR ServiceName;
    LPSTR InstanceName;
    USHORT InstancePort;
    LPSTR Referrer;
    LPSTR PrincipalName;
} MAKE_SPN_TEST_CASE, *PMAKE_SPN_TEST_CASE;

typedef struct _CLIENT_MAKE_SPN_TEST_CASE {
    LPSTR ServiceClass;
    LPSTR InstanceName;
    LPSTR PrincipalName;
} CLIENT_MAKE_SPN_TEST_CASE, *PCLIENT_MAKE_SPN_TEST_CASE;

typedef struct _GET_SPN_TEST_CASE {
    DS_SPN_NAME_TYPE ServiceType;
    LPSTR ServiceClass;
    LPSTR ServiceName;
    USHORT InstancePort;
    USHORT cInstanceNames;
    LPSTR InstanceNames[MAX_INSTANCES];
    USHORT InstancePorts[MAX_INSTANCES];
    DWORD cSpn;
    LPSTR Spn[MAX_INSTANCES + MAX_ALIASES];
} GET_SPN_TEST_CASE, *PGET_SPN_TEST_CASE;

#define NUMBER_ELEMENTS( A ) ( sizeof( A ) / sizeof( A[0] ) )

/* External */

/* Static */

static MAKE_SPN_TEST_CASE makeSpnTestCaseArray[] = {
    // ServClass   ServName   InstName   InstPort   Referrer

    // 0: Normal case without port
    { "ldap", "ntdev.ms.com", "dc1.ntdev.ms.com", 0, NULL,
      "ldap/dc1.ntdev.ms.com/ntdev.ms.com" },

    // 1: Normal case with port
    { "ldap", "ntdev.ms.com", "dc1.ntdev.ms.com", 123, NULL,
      "ldap/dc1.ntdev.ms.com:123/ntdev.ms.com" },

    // 2: IP address for service name, use referrer
    { "ldap", "1.2.3.4", "dc1.ntdev.ms.com", 123, "refer.ms.com",
      "ldap/dc1.ntdev.ms.com:123/refer.ms.com" },

    // 3: Normal case with duplicate service name and port, host based service
    { "ldap", "ntdev.ms.com", "ntdev.ms.com", 123, NULL,
      "ldap/ntdev.ms.com:123" },

    // 4: Normal case with duplicate service name, no port, host based service
    { "ldap", "ntdev.ms.com", "ntdev.ms.com", 0, NULL,
      "ldap/ntdev.ms.com" },

    // 5: Normal case with NULL instance and port, host based service
    { "ldap", "ntdev.ms.com", NULL, 123, NULL,
      "ldap/ntdev.ms.com:123" },

    // 6: Normal case with NULL instance, no port, host based service
    { "ldap", "ntdev.ms.com", NULL, 0, NULL,
      "ldap/ntdev.ms.com" },

    // 7: IP address for service name, use referrer, with NULL instance
    { "ldap", "1.2.3.4", NULL, 123, "refer.ms.com",
      "ldap/1.2.3.4:123/refer.ms.com" },

    // 8: Same as prev, but with a sneaky service name
    { "ldap", "1234567890123456789.guidbaseddnsname", NULL, 123, "refer.ms.com",
//      "ldap/1234567890123456789.guidbaseddnsname:123/1234567890123456789.guidbaseddnsname"
      "ldap/1234567890123456789.guidbaseddnsname:123"
    },

    // 9: Normal case without port, with dots at end
    { "ldap", "ntdev.ms.com.", "dc1.ntdev.ms.com.", 0, NULL,
      "ldap/dc1.ntdev.ms.com/ntdev.ms.com" },

    // 10: Normal case with port
    { "ldap", "ntdev.ms.com.", "dc1.ntdev.ms.com.", 123, NULL,
      "ldap/dc1.ntdev.ms.com:123/ntdev.ms.com" },

    // 11: IP address for service name, use referrer
    { "ldap", "1.2.3.4", "dc1.ntdev.ms.com.", 123, "refer.ms.com.",
      "ldap/dc1.ntdev.ms.com:123/refer.ms.com" },

    // 12: Normal case with duplicate service name and port, host based service
    { "ldap", "ntdev.ms.com.", "ntdev.ms.com.", 123, NULL,
      "ldap/ntdev.ms.com:123" }

};

static CLIENT_MAKE_SPN_TEST_CASE clientMakeSpnTestCaseArray[] = {
    // fully qualified domain name
    { "ldap", "<computerdns>",
//      "ldap/<computerdns>/<computerdns>"
      "ldap/<computerdns>"
    },
    // fqdns, with . at end
    { "ldap", "<computerdns>.",
//      "ldap/<computerdns>/<computerdns>"
      "ldap/<computerdns>"
    },
    // not qualified dns
    { "ldap", "<computername>",
//      "ldap/<computerdns>/<computerdns>"
      "ldap/<computerdns>"
    },
    // netbios name
    { "ldap", "\\\\<computername>",
//      "ldap/<computerdns>/<computerdns>"
      "ldap/<computerdns>"
    },
    // stringified ip address
    { "ldap", "172.31.234.189",
//      "ldap/<computerdns>/<computerdns>"
      "ldap/<computerdns>"
    }
};

static GET_SPN_TEST_CASE *getSpnTestCaseArray = NULL;

static GET_SPN_TEST_CASE getSpnTestCaseData[] = {

    { DS_SPN_DNS_HOST, "http", NULL, 0,
      1,
      { "p2.b26.ms.com" },
      { 0 },
      1,
//      { "http/p2.b26.ms.com/<computerdns>" }
      { "http/p2.b26.ms.com" }
    },

    { DS_SPN_DNS_HOST, "http", NULL, 0,
      0,
      { 0 },
      { 0 },
      2,
//      { "http/<computerdns>/<computerdns>",
//        "http/<computername>.dns.microsoft.com/<computerdns>" }
      { "http/<computerdns>",
        "http/<computername>.dns.microsoft.com" }
    },

    { DS_SPN_DNS_HOST, "http", NULL, 1234,
      0,
      { 0 },
      { 0 },
      2,
//      { "http/<computerdns>:1234/<computerdns>",
//        "http/<computername>.dns.microsoft.com:1234/<computerdns>" }
      { "http/<computerdns>:1234",
        "http/<computername>.dns.microsoft.com:1234" }
    },

    { DS_SPN_DN_HOST, "http", NULL, 0,
      1,
      { "p2.b26.ms.com" },
      { 0 },
      1,
//      { "http/p2.b26.ms.com/<computerdn>" }
      { "http/p2.b26.ms.com" }
    },

    { DS_SPN_NB_HOST, "http", NULL, 0,
      2,
      { "paulle3", "paulle4" },
      { 0 },
      2,
//      { "http/paulle3/<computername>", "http/paulle4/<computername>" }
      { "http/paulle3", "http/paulle4" }
    },

    { DS_SPN_SERVICE, "http", "www.ms.com", 0,
      0,
      { 0 },
      { 0 },
      1,
      { "http/www.ms.com/www.ms.com" }
   },

    { DS_SPN_SERVICE, "anRpcSvc", "cn=anRpcSvc,cn=RPC Services,cn=system,dc=ms,dc=com", 0,
      1,
      { "p2.b26.ms.com" },
      { 0 },
      1,
      { "anRpcSvc/p2.b26.ms.com/cn=anRpcSvc,cn=RPC Services,cn=system,dc=ms,dc=com" }
    },

    { DS_SPN_DOMAIN, "ldap", "ntdev.ms.com", 0,
      1,
      { "dc1.ntdev.ms.com" },
      { 0 },
      1,
      { "ldap/dc1.ntdev.ms.com/ntdev.ms.com" }
    },

    { DS_SPN_DOMAIN, "ldap", "dc=ntdev,dc=ms,dc=com", 0,
      1,
      { "p2.b26.ms.com" },
      { 0 },
      1,
      { "ldap/p2.b26.ms.com/ntdev.ms.com" }
    },

    { DS_SPN_NB_DOMAIN, "ldap", "ntdev", 0,
      1,
      { "ntdev-dc1" },
      { 0 },
      1,
      { "ldap/ntdev-dc1/ntdev" }
    },

    { DS_SPN_SERVICE, "ldap", "info.ms.com", 0,
      1,
      { "isrv2.mis.ms.com" },
      { 0 },
      1,
      { "ldap/isrv2.mis.ms.com/info.ms.com" }
    },

    { DS_SPN_SERVICE, "http", "www.ms.com", 8080,
      0,
      { 0 },
      { 0 },
      1,
      { "http/www.ms.com:8080/www.ms.com" }
    },

    { DS_SPN_SERVICE, "ldap", "ntdev.ms.com", 0,
      1,
      { "dc1.ntdev.ms.com" },
      { 7777 },
      1,
      { "ldap/dc1.ntdev.ms.com:7777/ntdev.ms.com" }
    }



};

/* Forward */ /* Generated by Emacs 19.34.1 on Tue Aug 11 09:39:41 1998 */

int __cdecl
main(
    int argc,
    CHAR *argv[]
    );

static BOOLEAN
testWriteAccount(
    int argc,
    char *argv[]
    );

static void
usage(
    char *program
    );

BOOLEAN
runMakeSpnTestCasesA(
    void
    );

static void
dumpTestMakeSpnCase(
    PMAKE_SPN_TEST_CASE Case
    );

static BOOLEAN
runClientMakeSpnTestCasesA(
    void
    );

static void
dumpTestClientMakeSpnCase(
    PCLIENT_MAKE_SPN_TEST_CASE Case
    );

static BOOLEAN
runGetSpnTestCasesA(
    void
    );

static void
dumpGetSpnTestCase(
    PGET_SPN_TEST_CASE test
    );

static BOOLEAN
runCrackSpnTestCasesA(
    void
    );

static void
setComputernameSpnTestCases(
    void
    );

static void
allocSubstitute(
    LPSTR Input,
    LPSTR OldValue,
    LPSTR NewValue,
    LPSTR *pOutput
    );

/* End Forward */


int __cdecl
main(
    int argc,
    CHAR *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;

    printf( "SPN API Tests\n" );

    if (argc > 1) {
        if (!testWriteAccount(argc, argv)) {
            printf( "WriteAccountSpn test failed\n" );
        } else {
            printf( "WriteAccountSpn test succeeded\n" );
        }
        return 0;
    }

    setComputernameSpnTestCases();

    if (!runMakeSpnTestCasesA()) {
        printf( "One or more MakeSpn test cases failed\n" );
    } else {
        printf( "MakeSpn test cases were successful\n" );
    }

    if (!runClientMakeSpnTestCasesA()) {
        printf( "One or more ClientMakeSpn test cases failed\n" );
    } else {
        printf( "ClientMakeSpn test cases were successful\n" );
    }

    if (!runGetSpnTestCasesA()) {
        printf( "One or more GetSpn test cases failed\n" );
    } else {
        printf( "GetSpn test cases were successful\n" );
    }

    if (!runCrackSpnTestCasesA()) {
        printf( "One or more CrackSpn test cases failed\n" );
    } else {
        printf( "CrackSpn test cases were successful\n" );
    }

    return 0;
}


static BOOLEAN
testWriteAccount(
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status, cSpn, i;
    DS_SPN_WRITE_OP operation;
    LPSTR dcName, domainName, account;
    LPSTR pSpn[20];
    BOOLEAN error = FALSE;
    HANDLE hDS;

    if (argc < 3) {
        usage( argv[0] );
        return FALSE;
    }

    if (_stricmp( argv[1], "-register" ) == 0) {
        LPSTR class = (argc > 2) ? argv[2] : NULL;
        LPSTR DN = (argc > 3) ? argv[3] : NULL;

        status = DsServerRegisterSpnA( DS_SPN_ADD_SPN_OP, class, DN );
        if (status != ERROR_SUCCESS) {
        printf( "DsServerRegisterSpnA failed with status %d\n", status );
        error = TRUE;
        }
        goto exit;
    } else if (_stricmp( argv[1], "-deregister" ) == 0) {
        LPSTR class = (argc > 2) ? argv[2] : NULL;
        LPSTR DN = (argc > 3) ? argv[3] : NULL;

        status = DsServerRegisterSpnA( DS_SPN_DELETE_SPN_OP, class, DN );
        if (status != ERROR_SUCCESS) {
        printf( "DsServerDeregisterSpnA failed with status %d\n", status );
        error = TRUE;
        }
        goto exit;
    } else if (_stricmp( argv[1], "-add" ) == 0) {
        operation = DS_SPN_ADD_SPN_OP;
    } else if (_stricmp( argv[1], "-replace" ) == 0) {
        operation = DS_SPN_REPLACE_SPN_OP;
    } else if (_stricmp( argv[1], "-delete" ) == 0) {
        operation = DS_SPN_DELETE_SPN_OP;
    } else {
        usage( argv[0] );
        return FALSE;
    }

    if (_stricmp( argv[2], "null" ) == 0) {
        dcName = NULL;
    } else {
        dcName = argv[2];
    }

    if (_stricmp( argv[3], "null" ) == 0) {
        domainName = NULL;
    } else {
        domainName = argv[3];
    }

    if (argc < 5) {
        usage( argv[0] );
        return FALSE;
    }
    account = argv[4];

    cSpn = argc - 5;
    for( i = 5; i < (DWORD) argc; i++ ) {
        pSpn[i - 5] = argv[i];
    }

    status = DsBindA( dcName, domainName, &hDS );
    if (status != ERROR_SUCCESS) {
        printf( "DsBind failed with status %d\n", status );
        return TRUE;
    }

    status = DsWriteAccountSpnA( hDS, operation, account, cSpn, pSpn );
    if (status != ERROR_SUCCESS) {
        printf( "DsWriteAccountSpnA failed with status %d\n", status );
        error = TRUE;
    }

    status = DsUnBindA( &hDS );
    if (status != ERROR_SUCCESS) {
        printf( "DsUnBind failed with status %d\n", status );
        return TRUE;
    }

exit:

    return !error;
}


static void
usage(
    char *program
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    printf( "usage:\n" );
    printf( "%s\n", program );
    printf( "%s -register/deregister ServiceClass [objectdn]\n", program );
    printf( "%s -add|-replace|-delete dcname/null domainname/null accountDN [spn1 spn2 ...]\n", program );
}


BOOLEAN
runMakeSpnTestCasesA(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD i;
    DWORD status, length;
    CHAR buffer[MAX_SPN];
    PMAKE_SPN_TEST_CASE Case;
    BOOLEAN error = FALSE;
    PCHAR instanceNameA;

    printf( "\nAscii Make SPN test cases\n" );

    for( i = 0; i < NUMBER_ELEMENTS( makeSpnTestCaseArray ); i++ ) {
        Case = makeSpnTestCaseArray + i;

        printf( "test %d SPN %s:\n", i, Case->PrincipalName );

        length = MAX_SPN;
        status = DsMakeSpnA(
            Case->ServiceClass,
            Case->ServiceName,
            Case->InstanceName,
            Case->InstancePort,
            Case->Referrer,
            &length,
            buffer );
        if (status != ERROR_SUCCESS) {
            printf( "Test case %d failed with status %d\n", i, status );
            dumpTestMakeSpnCase( Case );
            error = TRUE;
        }

        if (strcmp( Case->PrincipalName, buffer ) != 0) {
            printf( "Test case %d did not return expected result\n", i );
            printf( "\tActual Result: %s\n", buffer );
            dumpTestMakeSpnCase( Case );
            error = TRUE;
        } else if (length != (strlen( Case->PrincipalName ) + 1)) {
            printf( "Test case %d did not return expected length\n", i );
            printf( "\tActual Length: %d\tExpected Length: %d\n",
                    length, (strlen( Case->PrincipalName )+1) );
            dumpTestMakeSpnCase( Case );
            error = TRUE;
        }
    }

    // Make sure overflow detection logic works!

    Case = makeSpnTestCaseArray;

    // len != 0, buf == 0  INVALID
    printf( "test %d overflow SPN %s:\n", 100, Case->PrincipalName );
    length = 1;
    status = DsMakeSpnA(
        Case->ServiceClass,
        Case->ServiceName,
        Case->InstanceName,
        Case->InstancePort,
        Case->Referrer,
        &length,
        NULL );
    if (status != ERROR_INVALID_PARAMETER) {
        printf( "Test case %d should have failed invalid but returned %d\n", 100, status );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }

    // len == 0, buf == 0  VALID
    printf( "test %d overflow SPN %s:\n", 101, Case->PrincipalName );
    length = 0;
    status = DsMakeSpnA(
        Case->ServiceClass,
        Case->ServiceName,
        Case->InstanceName,
        Case->InstancePort,
        Case->Referrer,
        &length,
        NULL );
    if (status != ERROR_BUFFER_OVERFLOW) {
        printf( "Test case %d should have overflowed but returned %d\n", 101, status );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }
    if (length != strlen( Case->PrincipalName ) + 1) {
        printf( "Test case %d returned wrong length %d\n", 101, length );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }

    // len == 0, buf != 0  VALID
    printf( "test %d overflow SPN %s:\n", 102, Case->PrincipalName );
    length = 0;
    status = DsMakeSpnA(
        Case->ServiceClass,
        Case->ServiceName,
        Case->InstanceName,
        Case->InstancePort,
        Case->Referrer,
        &length,
        buffer );
    if (status != ERROR_BUFFER_OVERFLOW) {
        printf( "Test case %d should have overflowed but returned %d\n", 102, status );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }
    if (length != strlen( Case->PrincipalName ) + 1) {
        printf( "Test case %d returned wrong length %d\n", 102, length );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }

    // len < total, buf != 0  VALID
    printf( "test %d overflow SPN %s:\n", 103, Case->PrincipalName );
    length = 1;
    status = DsMakeSpnA(
        Case->ServiceClass,
        Case->ServiceName,
        Case->InstanceName,
        Case->InstancePort,
        Case->Referrer,
        &length,
        buffer );
    if (status != ERROR_BUFFER_OVERFLOW) {
        printf( "Test case %d should have overflowed but returned %d\n", 103, status );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }
    if (length != strlen( Case->PrincipalName ) + 1) {
        printf( "Test case %d returned wrong length %d\n", 103, length );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }

    // len = total - 1, buf != 0  VALID
    printf( "test %d overflow SPN %s:\n", 104, Case->PrincipalName );
    length = strlen( Case->PrincipalName ); // don't include terminator
    status = DsMakeSpnA(
        Case->ServiceClass,
        Case->ServiceName,
        Case->InstanceName,
        Case->InstancePort,
        Case->Referrer,
        &length,
        buffer );
    if (status != ERROR_BUFFER_OVERFLOW) {
        printf( "Test case %d should have overflowed but returned %d\n", 104, status );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }
    if (length != strlen( Case->PrincipalName ) + 1) {
        printf( "Test case %d returned wrong length %d\n", 104, length );
        dumpTestMakeSpnCase( Case );
        error = TRUE;
    }

    return !error;
}


static void
dumpTestMakeSpnCase(
    PMAKE_SPN_TEST_CASE Case
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    printf( "\tService Class: %s\n", Case->ServiceClass );
    printf( "\tService Name: %s\n", Case->ServiceName );
    printf( "\tInstance Name: %s\n",
            (Case->InstanceName != NULL) ? Case->InstanceName : "not present" );
    printf( "\tInstance Port: %d\n", Case->InstancePort );
    printf( "\tReferrer: %s\n",
            (Case->Referrer != NULL) ? Case->Referrer : "not present" );
    printf( "\tExpected: %s\n", Case->PrincipalName );
}


static BOOLEAN
runClientMakeSpnTestCasesA(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
//#define WIDE_SPN L"myservice/ntdsdc0.dns.microsoft.com/ntdsdc0.dns.microsoft.com"
#define WIDE_SPN L"myservice/ntdsdc0.dns.microsoft.com"
    DWORD i;
    DWORD status, length;
    CHAR buffer[MAX_SPN];
    WCHAR wbuffer[MAX_SPN];
    PCLIENT_MAKE_SPN_TEST_CASE Case;
    BOOLEAN error = FALSE;
    WCHAR wideSpn[] = WIDE_SPN;
    DWORD wideLength = NUMBER_ELEMENTS( wideSpn );

    printf( "\nAscii DsClientMakeSpnForTargetServer test cases\n" );

    for( i = 0; i < NUMBER_ELEMENTS( clientMakeSpnTestCaseArray ); i++ ) {
        Case = clientMakeSpnTestCaseArray + i;

        printf( "test %d SPN %s/%s:\n",
                i,
                Case->ServiceClass,
                Case->InstanceName );

        length = MAX_SPN;
        status = DsClientMakeSpnForTargetServerA(
            Case->ServiceClass,
            Case->InstanceName,
            &length,
            buffer );
        if (status != ERROR_SUCCESS) {
            printf( "Test case %d failed with status %d\n", i, status );
            dumpTestClientMakeSpnCase( Case );
            error = TRUE;
        } else if (strcmp( Case->PrincipalName, buffer ) != 0) {
            printf( "Test case %d did not return expected result\n", i );
            printf( "\tActual Result: %s\n", buffer );
            dumpTestClientMakeSpnCase( Case );
            error = TRUE;
        } else if (length != (strlen( Case->PrincipalName ) + 1)) {
            printf( "Test case %d did not return expected length\n", i );
            printf( "\tActual Length: %d\tExpected Length: %d\n",
                    length, (strlen( Case->PrincipalName )+1) );
            dumpTestClientMakeSpnCase( Case );
            error = TRUE;
        }

        // Check length inquiry
        length = 0;
        status = DsClientMakeSpnForTargetServerA(
            Case->ServiceClass,
            Case->InstanceName,
            &length,
            NULL );
        if (status != ERROR_BUFFER_OVERFLOW) {
            printf( "Test case %d failed with status %d\n", i, status );
            dumpTestClientMakeSpnCase( Case );
            error = TRUE;
        } else if (length != (strlen( Case->PrincipalName ) + 1)) {
            printf( "Test case %d did not return expected length\n", i );
            printf( "\tActual Length: %d\tExpected Length: %d\n",
                    length, (strlen( Case->PrincipalName )+1) );
            dumpTestClientMakeSpnCase( Case );
            error = TRUE;
        }

        // Check length off by one
        length = strlen( Case->PrincipalName ); // missing terminator
        status = DsClientMakeSpnForTargetServerA(
            Case->ServiceClass,
            Case->InstanceName,
            &length,
            buffer );
        if (status != ERROR_BUFFER_OVERFLOW) {
            printf( "Test case %d failed with status %d\n", i, status );
            dumpTestClientMakeSpnCase( Case );
            error = TRUE;
        } else if (length != (strlen( Case->PrincipalName ) + 1)) {
            printf( "Test case %d did not return expected length\n", i );
            printf( "\tActual Length: %d\tExpected Length: %d\n",
                    length, (strlen( Case->PrincipalName )+1) );
            dumpTestClientMakeSpnCase( Case );
            error = TRUE;
        }
    }

    if (error) { goto exit; }

    // test bad name
    printf( "test bad name:\n" );
    length = MAX_SPN;
    status = DsClientMakeSpnForTargetServerA(
        "foobar",
        "badname",
        &length,
        buffer );
    if (status != ERROR_INVALID_DOMAINNAME) {
        printf( "test for bad name did not return expected failure, actual:%d\n", status );
        error = TRUE;
        goto exit;
    }

    // test wide name
    printf( "test wide name:\n" );
    length = MAX_SPN;
    status = DsClientMakeSpnForTargetServerW(
        L"myservice",
        L"ntdsdc0",
        &length,
        wbuffer );
    if ( (status) ||
         (0 != _wcsicmp( wideSpn, wbuffer )) ||
         (length != wideLength)) {
        printf( "wide test case did not return expected result, expected '%ws', actual '%ws', exp %d act %d\n", wideSpn, wbuffer, wideLength, length );
        error = TRUE;
        goto exit;
    }

    // test wide overflow case
    printf( "test wide name overflow:\n" );
    length = 0;
    status = DsClientMakeSpnForTargetServerW(
        L"myservice",
        L"ntdsdc0",
        &length,
        NULL );
    if ( (status != ERROR_BUFFER_OVERFLOW) ||
         (length != wideLength)) {
        printf( "wide test case overflow did not return expected result, exp %d act %d\n", wideLength, length );
        error = TRUE;
        goto exit;
    }

exit:

    return !error;
}


static void
dumpTestClientMakeSpnCase(
    PCLIENT_MAKE_SPN_TEST_CASE Case
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    printf( "\tService Class: %s\n", Case->ServiceClass );
    printf( "\tInstance Name: %s\n",
            (Case->InstanceName != NULL) ? Case->InstanceName : "not present" );
    printf( "\tExpected: %s\n", Case->PrincipalName );
}


static BOOLEAN
runGetSpnTestCasesA(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status, i, j, cSpn;
    PGET_SPN_TEST_CASE test;
    BOOLEAN error = FALSE;
    LPSTR *pSpn;

    printf( "\nGet Spn Test Cases\n" );

    for( i = 0; i < NUMBER_ELEMENTS( getSpnTestCaseData ); i++ ) {
        test = getSpnTestCaseArray + i;
        printf( "test %d (%s):\n", i, test->Spn[0] );

        cSpn = 0;
        pSpn = NULL;

        status = DsGetSpnA( test->ServiceType,
                            test->ServiceClass,
                            test->ServiceName,
                            test->InstancePort,
                            test->cInstanceNames,
                            test->cInstanceNames ? test->InstanceNames : NULL,
                            test->cInstanceNames ? test->InstancePorts : NULL,
                            &cSpn,
                            &pSpn );
        if (status != ERROR_SUCCESS) {
            printf( "DsGetSpnA failed with status %d\n", status );
            dumpGetSpnTestCase( test );
            error = TRUE;
        } else if (cSpn != test->cSpn) {
            printf( "DsGetSpnA returned unexpected number of results, exp %d, act %d\n",
                    test->cSpn, cSpn );
            dumpGetSpnTestCase( test );
            error = TRUE;
            printf( "Actual:\n" );
            for( j = 0; j < cSpn; j++ ) {
                printf( "Spn[%d] = %s\n", j, pSpn[j] );
            }
        } else {
            for( j = 0; j < cSpn; j++ ) {
                if (strcmp( pSpn[j], test->Spn[j] ) != 0) {
                    printf( "DsGetSpnA returned unexpected spn:\nExpected: '%s'\nActual: '%s'\n",
                            test->Spn[j], pSpn[j] );
                    dumpGetSpnTestCase( test );
                    error = TRUE;
                }
            }
        }

        if (pSpn) {
            DsFreeSpnArrayA( cSpn, pSpn );
        }
    }

    return !error;
}


static void
dumpGetSpnTestCase(
    PGET_SPN_TEST_CASE test
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD i;

    printf( "\tService Type: %d\n", test->ServiceType );
    printf( "\tService Class: %s\n", test->ServiceClass );
    printf( "\tService Name: %s\n",
            test->ServiceName ? test->ServiceName : "not present" );
    printf( "\tInstance Port: %d\n", test->InstancePort );
    if (test->cInstanceNames) {
        printf( "\tInstance Names = %d\n", test->cInstanceNames );
        for( i = 0; i < test->cInstanceNames; i++ ) {
            printf( "\t\tname[%d] = %s, port = %d\n",
                    i, test->InstanceNames[i], test->InstancePorts[i] );
        }
    }
    printf( "\tExpected spns = %d\n", test->cSpn );
    for( i = 0; i < test->cSpn; i++ ) {
        printf( "\t\tSpn[%d] = %s\n", i, test->Spn[i] );
    }
}


static BOOLEAN
runCrackSpnTestCasesA(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status, i;
    PGET_SPN_TEST_CASE test;
    CHAR serviceClassA[MAX_NAME_LENGTH];
    CHAR serviceNameA[MAX_NAME_LENGTH];
    CHAR instanceNameA[MAX_NAME_LENGTH];
    CHAR spnA[MAX_SPN];
    DWORD serviceClassALength, serviceNameALength, instanceNameALength;
    USHORT port;
    BOOLEAN error = FALSE;
    CHAR numberBuffer[10];

    printf( "\nCrack Spn Test Cases\n" );

    // Do test with arguments null

    printf( "argument null:\n" );
    status = DsCrackSpnA( "class/instance:123/service",
                          NULL, NULL,
                          NULL, NULL,
                          NULL, NULL,
                          &port );
    if (status != ERROR_SUCCESS) {
        printf( "DsCrackSpnA failed with unexpected status %d\n", status );
        error = TRUE;
    } else if (port != 123) {
        printf( "DsCrackSpnA returned unexpected result:\nexpected:%d\nactual:%\n",
                123, port );
    }

    status = DsCrackSpn2A( "class/instance:123/service",
    	                  strlen( "class/instance:123/service" ),
                          NULL, NULL,
                          NULL, NULL,
                          NULL, NULL,
                          &port );
    if (status != ERROR_SUCCESS) {
        printf( "DsCrackSpn2A failed with unexpected status %d\n", status );
        error = TRUE;
    } else if (port != 123) {
        printf( "DsCrackSpn2A returned unexpected result:\nexpected:%d\nactual:%\n",
                123, port );
    }

    // Do test with bad argument

    printf( "too many slashes:\n" );
    status = DsCrackSpnA( "class/instance:123/service/foobar",
                          NULL, NULL,
                          NULL, NULL,
                          NULL, NULL,
                          &port );
    if (status != ERROR_INVALID_PARAMETER) {
        printf( "DsCrackSpnA failed with unexpected status %d\n", status );
        error = TRUE;
    }

    status = DsCrackSpn2A( "class/instance:123/service/foobar",
    	                  strlen( "class/instance:123/service/foobar" ),
                          NULL, NULL,
                          NULL, NULL,
                          NULL, NULL,
                          &port );
    if (status != ERROR_INVALID_PARAMETER) {
        printf( "DsCrackSpn2A failed with unexpected status %d\n", status );
        error = TRUE;
    }

    printf( "not enough slashes:\n" );
    status = DsCrackSpnA( "class",
                          NULL, NULL,
                          NULL, NULL,
                          NULL, NULL,
                          &port );
    if (status != ERROR_INVALID_PARAMETER) {
        printf( "DsCrackSpnA failed with unexpected status %d\n", status );
        error = TRUE;
    }

    status = DsCrackSpn2A( "class",
    	                  strlen( "class" ),
                          NULL, NULL,
                          NULL, NULL,
                          NULL, NULL,
                          &port );
    if (status != ERROR_INVALID_PARAMETER) {
        printf( "DsCrackSpn2A failed with unexpected status %d\n", status );
        error = TRUE;
    }

    printf( "no slash after port #:\n" );
    status = DsCrackSpnA( "foo/bar:123xxx/yyy",
    	                  NULL, NULL,
    	                  NULL, NULL,
    	                  NULL, NULL,
    	                  &port );
    if ( status != ERROR_INVALID_PARAMETER ) {
    	printf( "DsCrackSpnA failed with unexpected status %d\n", status );
    	error = TRUE;
    }

    status = DsCrackSpn2A( "foo/bar:123xxx/yyy",
                          strlen( "foo/bar:123xxx/yyy" ),
    	                  NULL, NULL,
    	                  NULL, NULL,
    	                  NULL, NULL,
    	                  &port );
    if ( status != ERROR_INVALID_PARAMETER ) {
    	printf( "DsCrackSpn2A failed with unexpected status %d\n", status );
    	error = TRUE;
    }

    // Try abbreviated spn without port number

    printf( "abbreviated spn, no port:\n" );
    serviceClassALength = MAX_NAME_LENGTH;
    serviceNameALength = MAX_NAME_LENGTH;
    instanceNameALength = MAX_NAME_LENGTH;
    status = DsCrackSpnA( "class/instance",
                          &serviceClassALength, serviceClassA,
                          &serviceNameALength, serviceNameA,
                          &instanceNameALength, instanceNameA,
                          &port );
    if (status != ERROR_SUCCESS) {
        printf( "DsCrackSpnA failed with unexpected status %d\n", status );
        error = TRUE;
    } else if ( (strcmp( serviceClassA, "class" )) ||
                (strcmp( instanceNameA, "instance" )) ||
                (strcmp( instanceNameA, serviceNameA )) ||
                (port) ) {
        printf( "DsCrackSpnA returned unexpected result\n" );
        error = TRUE;
    }

    serviceClassALength = MAX_NAME_LENGTH;
    serviceNameALength = MAX_NAME_LENGTH;
    instanceNameALength = MAX_NAME_LENGTH;
    status = DsCrackSpn2A( "class/instance",
    	                  strlen( "class/instance" ),
                          &serviceClassALength, serviceClassA,
                          &serviceNameALength, serviceNameA,
                          &instanceNameALength, instanceNameA,
                          &port );
    if (status != ERROR_SUCCESS) {
        printf( "DsCrackSpn2A failed with unexpected status %d\n", status );
        error = TRUE;
    } else if ( (strcmp( serviceClassA, "class" )) ||
                (strcmp( instanceNameA, "instance" )) ||
                (strcmp( instanceNameA, serviceNameA )) ||
                (port) ) {
        printf( "DsCrackSpn2A returned unexpected result\n" );
        error = TRUE;
    }

    // Try abbreviated spn with port number

    printf( "abbreviated spn, with port:\n" );
    serviceClassALength = MAX_NAME_LENGTH;
    serviceNameALength = MAX_NAME_LENGTH;
    instanceNameALength = MAX_NAME_LENGTH;
    status = DsCrackSpnA( "class/service:123",
                          &serviceClassALength, serviceClassA,
                          &serviceNameALength, serviceNameA,
                          &instanceNameALength, instanceNameA,
                          &port );
    if (status != ERROR_SUCCESS) {
        printf( "DsCrackSpnA failed with unexpected status %d\n", status );
        error = TRUE;
    } else if ( (strcmp( serviceClassA, "class" )) ||
                (strcmp( instanceNameA, "service" )) ||
                (strcmp( instanceNameA, serviceNameA )) ||
                (port != 123) ) {
        printf( "DsCrackSpnA returned unexpected result\n" );
        error = TRUE;
    }


    // Run through get spn test case data, using it for crack spn

    for( i = 0; i < NUMBER_ELEMENTS( getSpnTestCaseData ); i++ ) {
        test = getSpnTestCaseArray + i;

        printf( "test %d (%s):\n", i, test->Spn[0] );

        serviceClassALength = MAX_NAME_LENGTH;
        serviceNameALength = MAX_NAME_LENGTH;
        instanceNameALength = MAX_NAME_LENGTH;

        status = DsCrackSpnA( test->Spn[0],
                              &serviceClassALength, serviceClassA,
                              &serviceNameALength, serviceNameA,
                              &instanceNameALength, instanceNameA,
                              &port );
        if (status != ERROR_SUCCESS) {
            printf( "DsCrackSpnA failed with unexpected status %d\n", status );
            error = TRUE;
        } else if (
            (serviceClassALength != strlen( serviceClassA ) + 1) ||
            (serviceNameALength != strlen( serviceNameA ) + 1) ||
            (instanceNameALength != strlen( instanceNameA ) + 1) ) {
            printf( "DsCrackSpnA returned unexpected parameter length\n" );
            error = TRUE;
        } else {
            strcpy( spnA, serviceClassA );
            strcat( spnA, "/" );
            strcat( spnA, instanceNameA );
            if (port) {
                strcat( spnA, ":" );
                _itoa( port, numberBuffer, 10 );
                strcat( spnA, numberBuffer );
            }
            if ( ( (test->ServiceType != DS_SPN_DNS_HOST) &&
                   (test->ServiceType != DS_SPN_DN_HOST) &&
                   (test->ServiceType != DS_SPN_NB_HOST) ) ||
                 (_stricmp( serviceNameA, instanceNameA ) != 0) ) {
                strcat( spnA, "/" );
                strcat( spnA, serviceNameA );
            }

            if (strcmp( spnA, test->Spn[0] ) != 0) {
                printf( "DsCrackSpnA returned unexpected result:\nexpected:%s\nactual:%s\n",
                        test->Spn[0], spnA );
                printf( "class '%s' instance '%s' service '%s'\n",
                        serviceClassA, instanceNameA, serviceNameA );
                error = TRUE;
            }
        }

        serviceClassALength = MAX_NAME_LENGTH;
        serviceNameALength = MAX_NAME_LENGTH;
        instanceNameALength = MAX_NAME_LENGTH;

        status = DsCrackSpn2A( test->Spn[0],
        	                  test->Spn[0] ? strlen( test->Spn[0] ) : 0,
                              &serviceClassALength, serviceClassA,
                              &serviceNameALength, serviceNameA,
                              &instanceNameALength, instanceNameA,
                              &port );
        if (status != ERROR_SUCCESS) {
            printf( "DsCrackSpn2A failed with unexpected status %d\n", status );
            error = TRUE;
        } else if (
            (serviceClassALength != strlen( serviceClassA ) + 1) ||
            (serviceNameALength != strlen( serviceNameA ) + 1) ||
            (instanceNameALength != strlen( instanceNameA ) + 1) ) {
            printf( "DsCrackSpn2A returned unexpected parameter length\n" );
            error = TRUE;
        } else {
            strcpy( spnA, serviceClassA );
            strcat( spnA, "/" );
            strcat( spnA, instanceNameA );
            if (port) {
                strcat( spnA, ":" );
                _itoa( port, numberBuffer, 10 );
                strcat( spnA, numberBuffer );
            }
            if ( ( (test->ServiceType != DS_SPN_DNS_HOST) &&
                   (test->ServiceType != DS_SPN_DN_HOST) &&
                   (test->ServiceType != DS_SPN_NB_HOST) ) ||
                 (_stricmp( serviceNameA, instanceNameA ) != 0) ) {
                strcat( spnA, "/" );
                strcat( spnA, serviceNameA );
            }

            if (strcmp( spnA, test->Spn[0] ) != 0) {
                printf( "DsCrackSpn2A returned unexpected result:\nexpected:%s\nactual:%s\n",
                        test->Spn[0], spnA );
                printf( "class '%s' instance '%s' service '%s'\n",
                        serviceClassA, instanceNameA, serviceNameA );
                error = TRUE;
            }
        }

    }

    return !error;
}


static void
setComputernameSpnTestCases(
    void
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD i, j, length, status, elements;
    PGET_SPN_TEST_CASE test;
    PCLIENT_MAKE_SPN_TEST_CASE cmtest;
    CHAR computername[MAX_COMPUTERNAME_LENGTH + 1];
    CHAR computerdn[MAX_SPN + 1];
    CHAR computerdns[MAX_PATH + 1];
    struct hostent *he;

    elements = NUMBER_ELEMENTS( getSpnTestCaseData );
    length = elements * sizeof( GET_SPN_TEST_CASE );

    getSpnTestCaseArray = getSpnTestCaseData;

    for( i = 0; i < elements; i++ ) {
        test = getSpnTestCaseArray + i;
    }

    length = MAX_COMPUTERNAME_LENGTH + 1;
    if (!GetComputerName( computername, &length )) {
        status = GetLastError();
        printf( "GetComputerName failed with status %d\n", status );
        return;
    }
    length = MAX_SPN + 1;
    if (!GetComputerObjectName( NameFullyQualifiedDN, computerdn, &length )) {
        status = GetLastError();
        printf( "GetComputerNameEx failed with status %d\n", status );
        return;
    }
    // Get Dns hostname
    he = gethostbyname( "" );
    if (he == NULL) {
        status = WSAGetLastError();
        printf( "gethostbyname failed with status %d\n", status );
        return;
    }
    strcpy( computerdns, he->h_name );

    for( i = 0; i < NUMBER_ELEMENTS( clientMakeSpnTestCaseArray ); i++ ) {
        cmtest = clientMakeSpnTestCaseArray + i;

        // BUGBUG replaced value of test->Spn[i] is lost, might need to be freed?
        if (strstr( cmtest->InstanceName, COMPUTERNAME_TOKEN ) != NULL) {
            allocSubstitute( cmtest->InstanceName, COMPUTERNAME_TOKEN, computername, &(cmtest->InstanceName) );
            }
        if (strstr( cmtest->InstanceName, COMPUTERDN_TOKEN ) != NULL) {
            allocSubstitute( cmtest->InstanceName, COMPUTERDN_TOKEN, computerdn, &(cmtest->InstanceName) );
            }
        if (strstr( cmtest->InstanceName, COMPUTERDNS_TOKEN ) != NULL) {
            allocSubstitute( cmtest->InstanceName, COMPUTERDNS_TOKEN, computerdns, &(cmtest->InstanceName) );
        }

        if (strstr( cmtest->PrincipalName, COMPUTERNAME_TOKEN ) != NULL) {
            allocSubstitute( cmtest->PrincipalName, COMPUTERNAME_TOKEN, computername, &(cmtest->PrincipalName) );
            }
        if (strstr( cmtest->PrincipalName, COMPUTERDN_TOKEN ) != NULL) {
            allocSubstitute( cmtest->PrincipalName, COMPUTERDN_TOKEN, computerdn, &(cmtest->PrincipalName) );
            }
        if (strstr( cmtest->PrincipalName, COMPUTERDNS_TOKEN ) != NULL) {
            allocSubstitute( cmtest->PrincipalName, COMPUTERDNS_TOKEN, computerdns, &(cmtest->PrincipalName) );
        }
    }

    for( i = 0; i < NUMBER_ELEMENTS( getSpnTestCaseData ); i++ ) {
        test = getSpnTestCaseArray + i;

        for( j = 0; j < test->cSpn; j++ ) {

            // BUGBUG replaced value of test->Spn[i] is lost, might need to be freed?
            if (strstr( test->Spn[j], COMPUTERNAME_TOKEN ) != NULL) {
                allocSubstitute( test->Spn[j], COMPUTERNAME_TOKEN, computername, &(test->Spn[j]) );
            }
            if (strstr( test->Spn[j], COMPUTERDN_TOKEN ) != NULL) {
                allocSubstitute( test->Spn[j], COMPUTERDN_TOKEN, computerdn, &(test->Spn[j]) );
            }
            if (strstr( test->Spn[j], COMPUTERDNS_TOKEN ) != NULL) {
                allocSubstitute( test->Spn[j], COMPUTERDNS_TOKEN, computerdns, &(test->Spn[j]) );
            }
        }

    }
}


static void
allocSubstitute(
    LPSTR Input,
    LPSTR OldValue,
    LPSTR NewValue,
    LPSTR *pOutput
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD length;
    LPSTR output = NULL, p1, p2, p3;

    length = strlen( Input ) + 1 + (10 * strlen(NewValue));
    output = LocalAlloc( LPTR, length );
    if (output == NULL){
        printf( "failed to allocate %d bytes\n", length );
        return;
    }

    p3 = output;
    p1 = Input;
    while (1) {
        p2 = strstr( p1, OldValue );
        if (p2 == NULL) {
            strcpy( p3, p1 );
            break;
        }
        strncpy( p3, p1, (UINT)(p2 - p1) );
        p3 += (p2 - p1);

        strcpy( p3, NewValue );
        p3 += strlen( NewValue );

        p1 = p2 + strlen( OldValue );
    }

    *pOutput = output;
}

/* end testspn.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\test\replctrl\replctrl.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    replctrl.h

Abstract:

API for replctrl.c

Author:

    Will Lees (wlees) 14-Nov-2000

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#ifndef _REPLCTRL_
#define _REPLCTRL_

// Move this to ntdsapi.h someday
DWORD
DsMakeReplCookieForDestW(
    DS_REPL_NEIGHBORW *pNeighbor,
    DS_REPL_CURSORS * pCursors,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    );
DWORD
DsFreeReplCookie(
    PBYTE pCookie
    );
DWORD
DsGetSourceChangesW(
    LDAP *m_pLdap,
    LPWSTR m_pSearchBase,
    LPWSTR pszSourceFilter,
    DWORD dwReplFlags,
    PBYTE pCookieCurr,
    DWORD dwCookieLenCurr,
    LDAPMessage **ppSearchResult,
    BOOL *pfMoreData,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    PWCHAR *ppAttListArray
    );

#endif /* _REPLCTRL_ */

/* end replctrl.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\test\replctrl\replctrl.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    replctrl.c

Abstract:

    Callable api to the ldap replication control

    Use the dirsync replication control to get changes from a
    source and nc given a usn and utd

    This code derived from
    \nt\private\dirsync\dsserver\adread\read.cpp:
        GetMoreDataFromDS()

    The source is essentially stateless for change positioning. The caller
    (destination) records where he was last.  A change position is represented
    by a opaque data structure called a cookie.

    The is no support at the moment to explode and construct cookies, so that
    one could build an arbitrary one.  Instead, you may either duplicate a cookie
    from a reps-from, or you can start with no cookie, and iterate sequentially 
    through all the changes, and then proceeding incrementally from there.

Author:

    Will Lees (wlees) 30-Apr-1999

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <ismapi.h>
#include <schedule.h>
#include <ntldap.h>
#include <winber.h>

#define CHK_LD_STATUS( x )                        \
{                                                 \
    if ( LDAP_SUCCESS != (x) )                    \
    {                                             \
        err = LdapMapErrorToWin32(x);             \
        printf( "[%s, %d] LDAP error %d (%ls) win32 %d.\n", \
                __FILE__,                         \
                __LINE__,                         \
                (x),                              \
                ldap_err2stringW( x ),            \
                err );                            \
       goto error;                                \
    }                                             \
}

#define MemAlloc( x ) malloc( x )
#define MemFree( x ) free( x )

#define BAIL() \
printf( "Fatal error at line %d, file %s\n", __LINE__, __FILE__ ); \
goto error;
#define BAIL_ON_NULL(x) if (!(x)) { \
printf( "%s had unexpected null value at line %d, file %s\n", #x,__LINE__, __FILE__ ); \
err = ERROR_NOT_ENOUGH_MEMORY; \
goto error; \
}
#define BAIL_ON_FAILURE(x) if (x) { \
printf( "%s had unexpected failure value at line %d, file %s\n", #x,__LINE__, __FILE__ ); \
goto error; \
}
#define ERR(parenarglist) \
printf parenarglist; \
goto error;

// Read 100 objects at a time
#define DIRSYNC_SIZE_LIMIT 100
// Maximum attrs to return
// sic
#define MAX_ATTIBUTES        1048576

// The following is from  dsamain/ldap/const.hxx

//
// version of the repl dirsync control cookie structure
//
// structure for v1
//   REPL VERSION
//   vector To
//   UTD Vector
//
// structure for v2
//   REPL VERSION
//   cb UTD vector
//   vectorTo
//   invocation ID
//   UTD Vector
//
// structure for v3
//   REPL_SIGNATURE
//   REPL_VERSION
//   TIMESTAMP
//   RESERVED
//   cb UTD vector
//   vectorTo
//   invocation ID
//   UTD Vector
//

#define REPL_VERSION        3
#define REPL_SIGNATURE      'SDSM'
#define LDAP_VALID_DIRSYNC_CONTROL_FLAGS    (DRS_GET_ANC)

//
// minimum size of a repl control cookie
//

#define MIN_REPL_CONTROL_BLOB_LENGTH    (sizeof(DWORD) + sizeof(DWORD) + sizeof(FILETIME) + \
                                        sizeof(LARGE_INTEGER) + sizeof(DWORD) + \
                                        sizeof(USN_VECTOR) + sizeof(UUID))

#define ASCII_TO_INT(x)    ((x)<='9' ? (x)-'0' : ((x) <='F' ? (x)-'A' + 10 : (x)-'a' + 10))
#define ASCII_TO_INTW(x)    ((x)<=L'9' ? (x)-L'0' : ((x) <=L'F' ? (x)-L'A' + 10 : (x)-L'a' + 10))

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Mon May 03 15:25:45 1999 */

DWORD
BerEncodeReplicationControl(
    DWORD dwReplFlags,
    PBYTE pCookie,
    DWORD dwLen,
    PBERVAL *ppBerVal
    );

DWORD
BerDecodeReplicationCookie(
    LDAP *m_pLdap,
    LDAPMessage *m_pSearchResult,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    BOOL *pfMoreData
    );

void
displayResults(
    LDAP *pLdap,
    LDAPMessage *pSearchResult,
    BOOL fVerbose
    );

void
dumpCookie(
    PBYTE pCookieNext,
    DWORD dwCookieLenNext
    );

DWORD
packCookie(
    USN_VECTOR *pUsnVec,
    GUID *puuidInvocationId,
    UPTODATE_VECTOR *pUtdvecV1,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    );

/* End Forward */


DWORD
DsMakeReplCookieForDestW(
    DS_REPL_NEIGHBORW *pNeighbor,
    DS_REPL_CURSORS * pCursors,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    )

/*++

Routine Description:

A Cookie represents a position in the changes stream for a particular source.

Build a cookie from neighbor and cursor information representing the
position of a destination with respect to some source

Cookie is output on success, otherwise not returned.

Arguments:

    pNeighbor - 
    pCursors - 
    ppCookieNext - 
    pdwCookieLenNext - 

Return Value:

    DWORD - 

--*/

{
    DWORD err, i;
    USN_VECTOR usnVec;
    UPTODATE_VECTOR *pUTD = NULL;
    DWORD cbUTD = 0;

    // Initialize out parameters
    *ppCookieNext = NULL;
    *pdwCookieLenNext = 0;

    // Construct USN VECTOR
    ZeroMemory( &usnVec, sizeof( USN_VECTOR ) );
    usnVec.usnHighObjUpdate = pNeighbor->usnLastObjChangeSynced;
    usnVec.usnHighPropUpdate = pNeighbor->usnAttributeFilter;

    // Construct UPTODATE VECTOR
    cbUTD = UpToDateVecV1SizeFromLen( pCursors->cNumCursors );
    pUTD = malloc( cbUTD );
    if (pUTD == NULL) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    ZeroMemory( pUTD, cbUTD );
    pUTD->dwVersion = 1;
    pUTD->V1.cNumCursors = pCursors->cNumCursors;
    for( i = 0; i < pCursors->cNumCursors; i++ ) {
        pUTD->V1.rgCursors[i].uuidDsa = pCursors->rgCursor[i].uuidSourceDsaInvocationID;
        pUTD->V1.rgCursors[i].usnHighPropUpdate = pCursors->rgCursor[i].usnAttributeFilter;
    }

    // Build the initial cookie
    err = packCookie(
        &usnVec,
        &(pNeighbor->uuidSourceDsaInvocationID),
        pUTD,
        ppCookieNext,
        pdwCookieLenNext
        );
    if (err != ERROR_SUCCESS) {
        goto error;
    }

    err = ERROR_SUCCESS;
error:

    if (pUTD) {
        free(pUTD);
    }

    return err;
} /* DsMakeReplCookieForDest */


DWORD
DsFreeReplCookie(
    PBYTE pCookie
    )

/*++

Routine Description:

Free a cookie returned by DsMakeReplCookie

Arguments:

    pCookie - pointer to cookie

Return Value:

    DWORD - errors if cookie not valid

--*/

{
    DWORD dwSignature;

    if (pCookie == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the Signature.
    //
    dwSignature = *((PDWORD)pCookie);

    if (dwSignature != REPL_SIGNATURE) {
        return ERROR_INVALID_PARAMETER;
    }

    MemFree( pCookie );

    return ERROR_SUCCESS;
} /* DsFreeReplCookie */


DWORD
DsGetSourceChangesW(
    LDAP *m_pLdap,
    LPWSTR m_pSearchBase,
    LPWSTR pszSourceFilter,
    DWORD dwReplFlags,
    PBYTE pCookieCurr,
    DWORD dwCookieLenCurr,
    LDAPMessage **ppSearchResult,
    BOOL *pfMoreData,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    PWCHAR *ppAttListArray
    )

/*++

Return a packet of changes given position information in "current cookie".

If successful, an updated position will be returned in "next cookie".

Cookies are self describing and position independent: they may be saved to long
term storage and retrieved later as a kind of bookmark.  Cookies are specific to
the source server and naming context they were created for.

The caller is responsible for deallocating the cookies himself.  The "next
cookie" in particular must be deallocated using DsFreeReplCookie.  The current
cookie may come from a file or other long term storage.

The changes are returned as an LDAP message of entries, attributes and values.
Secret data will have been supressed.

Arguments:

The out parameters are initialized to null at the start.

    m_pLdap - ldap handle to source server.
    m_pSearchBase - The dn of the nc head to search
    pszSourceFilter - Ldap search filter, if any
    dwReplFlags - Replication flags, DRS_GET_ANC, etc
    pCookieCurr - null, or cookie previously returned by DsGetSourceChanges.
          The cookie must have come from a call with the same source server and
          same naming context.
    dwCookieLenCurr - cookie length, or zero
    ppSearchResult - pointer to pointer, to receive ldap message
    pfMoreData - Indication whether there is more data and this call should be made
        again with the updated cookie.  This is independent of whether the current
        call returned data.
    ppCookieNext - Newly allocated cookie for the updated position
    pdwCookieLenNext - Length of new cookie
    ppAttListArray - A Null terminated list of pointers to attributes to return

The out parameters are not allocated on error.

Even if there are no changes (entries in result are zero), the cookie may
have been updated with the latest positioning information.

Return Value:

    DWORD - 

--*/

{
    PBERVAL pBerVal = NULL;
    LDAPControlW replControl;
    LDAPControlW extDNControl;
    PLDAPControlW controlArray[3];
    int lderr, err;
    LDAP_TIMEVAL TimeVal;

    // Initialize out parameters
    *ppSearchResult = NULL;
    *pfMoreData = FALSE;
    *ppCookieNext = NULL;
    *pdwCookieLenNext = 0;

    //
    // The replication control has the USN that specifies where to
    // continue from. This can be treated as opaque information by us.
    //

    err = BerEncodeReplicationControl(dwReplFlags,
                                      pCookieCurr, dwCookieLenCurr,
                                      &pBerVal);
    BAIL_ON_FAILURE( err );

    replControl.ldctl_oid = LDAP_SERVER_DIRSYNC_OID_W;
    replControl.ldctl_iscritical = TRUE;
    replControl.ldctl_value.bv_len = pBerVal->bv_len;
    replControl.ldctl_value.bv_val = (PCHAR)(pBerVal->bv_val);
    extDNControl.ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
    extDNControl.ldctl_iscritical = TRUE;
    extDNControl.ldctl_value.bv_len = 0;
    extDNControl.ldctl_value.bv_val = NULL;

    controlArray[0] = &replControl;
    controlArray[1] = &extDNControl;
    controlArray[2] = NULL;

    //
    // Adding in timeout so that we can recover if the server do not respond
    //
    TimeVal.tv_usec = 0;
    TimeVal.tv_sec = LDAP_TIMEOUT;

//    dumpCookie( *ppCookieNext, *pdwCookieLenNext );

    lderr = ldap_search_ext_sW(m_pLdap,
                               m_pSearchBase,
                               LDAP_SCOPE_SUBTREE, // m_pSessionData->SourceScope
                               pszSourceFilter,
                               ppAttListArray,
                               0,
                               (PLDAPControlW *) &controlArray,
                               NULL,
                               &TimeVal,
                               DIRSYNC_SIZE_LIMIT,
                               ppSearchResult);

    CHK_LD_STATUS( lderr );

    if ( (*ppSearchResult) == NULL )
    {
        // Let caller know there is no search result or cookie
        err = ERROR_DS_PROTOCOL_ERROR;
        goto error;
    }

    //
    // Save the returned cookie value
    //

    err = BerDecodeReplicationCookie(
        m_pLdap,
        *ppSearchResult,
        ppCookieNext,
        pdwCookieLenNext,
        pfMoreData
        );
    BAIL_ON_FAILURE( err );

    err = ERROR_SUCCESS;

error:

    // On error, return the same cookie that came in

    // Release results on error
    if ( (err != ERROR_SUCCESS) && (*ppSearchResult) )
    {
        ldap_msgfree(*ppSearchResult);
        *ppSearchResult = NULL;
    }

    if (pBerVal)
        ber_bvfree(pBerVal);

    return err;

} /* DsGetSourceChanges */


DWORD
BerEncodeReplicationControl(
    DWORD dwReplFlags,
    PBYTE pCookie,
    DWORD dwLen,
    PBERVAL *ppBerVal
    )

/*++

Routine Description:

    This encodes the replication cookie into a BERVAL that can be put in
    an LDAP control.

Arguments:

    dwReplFlags - Replication flags
    pCookie - Pointer to replication cookie
    dwLen - Length of cookie
    ppBerVal - Pointer that received the BERVAL structure. Called needs to
               free this using ber_bvfree().

Return Value:

    S_OK on success, error code otherwise

--*/

{
    DWORD err = ERROR_INVALID_PARAMETER;
    BerElement *pBer = NULL;

    pBer = ber_alloc_t(LBER_USE_DER);
    BAIL_ON_NULL(pBer);

    //
    // flag - set to zero, so order of parent & child objects is not important
    //

    if (ber_printf(pBer, "{iio}", dwReplFlags, MAX_ATTIBUTES, pCookie, dwLen) == -1)
    {
        err = ERROR_INTERNAL_ERROR;
        ERR(("Error in ber_printf\n"));
        BAIL();
    }

    //
    // Pull data from the BerElement into a BERVAL struct.
    // Caller needs to free ppBerVal.
    //

    if (ber_flatten(pBer, ppBerVal) != 0)
    {
        err = ERROR_INTERNAL_ERROR;
        ERR(("Error in ber_flatten\n"));
        BAIL();
    }

    err = ERROR_SUCCESS;

error:
    if (pBer)
    {
        ber_free(pBer,1);
    }

    return err;

}



DWORD
BerDecodeReplicationCookie(
    LDAP *m_pLdap,
    LDAPMessage *m_pSearchResult,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    BOOL *pfMoreData
    )

/*++

Routine Description:

    This saves the replication cookie that came back from the server so that
    it can be used for the next call

Arguments:

    m_pLdap - 
    m_pSearchResult - 
    ppCookieNext - 
    pdwCookieLenNext - 
    pfMoreData - 

Return Value:

    DWORD - 

--*/

{
    PLDAPControlW *ppServerControl = NULL;
    BERVAL berVal;
    DWORD err = ERROR_INVALID_PARAMETER;
    ULONG lderr;
    BerElement *pBer = NULL;
    PBERVAL pbv = NULL;
    DWORD size;
    DWORD i;

    lderr = ldap_parse_resultW(m_pLdap,
                               m_pSearchResult,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               &ppServerControl,
                               FALSE);
    CHK_LD_STATUS( lderr );

    //
    // Find the replication control
    //

    i = 0;
    while (ppServerControl[i] &&
           wcscmp(ppServerControl[i]->ldctl_oid,LDAP_SERVER_DIRSYNC_OID_W) != 0)
    {
        i++;
    }

    if (!ppServerControl[i])
    {
        err = ERROR_NOT_FOUND;
        ERR(("Did not get a replication server control back\n"));
        BAIL();
    }

    berVal.bv_len = ppServerControl[i]->ldctl_value.bv_len;
    berVal.bv_val = ppServerControl[i]->ldctl_value.bv_val;
    pBer = ber_init(&berVal);

    ber_scanf(pBer, "{iiO}", pfMoreData, &size, &pbv);

    *pdwCookieLenNext = pbv->bv_len;
    *ppCookieNext = (PBYTE)MemAlloc(pbv->bv_len);
    BAIL_ON_NULL(*ppCookieNext);

    memcpy(*ppCookieNext, pbv->bv_val, *pdwCookieLenNext);

    err = ERROR_SUCCESS;

error:
    if (pbv)
        ber_bvfree(pbv);
    if (pBer)
        ber_free(pBer, 1);
    if (ppServerControl)
        ldap_controls_freeW(ppServerControl);

    return err;
} /* BerDecodeReplicationCookie */


#if DBG


void
dumpCookie(
    PBYTE pCookieNext,
    DWORD dwCookieLenNext
    )

/*++

Routine Description:

    //
    // If the cookie is available, this debug code will dump out the cookie
    // value to the debugger
    //

Arguments:

    None

Return Value:

    None

--*/

{
    PUCHAR p;
    DWORD dwVersion, dwSignature;
    DWORD cbVecSize;
    USN_VECTOR usnVec;

    if (!pCookieNext)  {
        printf( "Cookie: null\n" );
    }

    p = pCookieNext;

    //
    // Get the Signature.
    //
    dwSignature = *((PDWORD)p);
    p += sizeof(DWORD);

    //
    // Get the Version.
    //
    dwVersion = *((PDWORD)p);
    p += sizeof(DWORD);

    // Skip filetime
    p += sizeof(FILETIME);

    // Skip reserved
    p += sizeof(LARGE_INTEGER);

    //
    // Get the size of the up to date vector
    //
    cbVecSize = *((PDWORD)p);
    p += sizeof(DWORD);

    // Usnvec
    memcpy(&usnVec,p,sizeof(USN_VECTOR));

    // todo: invocation uuid
    // todo: uptodatevec

    printf("Cookie: ver %d,\nHighObjUpdate: %I64d,\nHighPropUpdate: %I64d\n",
           dwVersion, usnVec.usnHighObjUpdate, usnVec.usnHighPropUpdate);
}
#endif


DWORD
packCookie(
    USN_VECTOR *pUsnVec,
    GUID *puuidInvocationId,
    UPTODATE_VECTOR *pUtdvecV1,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    )

/*++

Routine Description:

The following logic is taken from
    dsamain\ldap\ldapconv.cxx:LDAP_PackReplControl

Arguments:

    pUsnVec - 
    puuidInvocationId - 
    pUtdvecV1 - 
    ppCookieNext - 
    pdwCookieLenNext - 

Return Value:

    DWORD - 

--*/

{
    DWORD cbCookie = MIN_REPL_CONTROL_BLOB_LENGTH;
    DWORD cbVecSize = 0;
    PBYTE p, pbCookie = NULL;

    // todo: deal with not having a utd

    Assert( pUtdvecV1 != NULL );
    Assert(IS_VALID_UPTODATE_VECTOR(pUtdvecV1));

    if (pUtdvecV1->V1.cNumCursors > 0) {      
        cbVecSize = UpToDateVecV1Size(pUtdvecV1);
        cbCookie += cbVecSize;
    }

    pbCookie = MemAlloc( cbCookie );
    if (pbCookie == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory( pbCookie, cbCookie );

    p = pbCookie;

    //
    // Pack the signature
    //

    *((PDWORD)p) = REPL_SIGNATURE;
    p += sizeof(DWORD);

    //
    // Pack the Version. 
    //

    *((PDWORD)p) = REPL_VERSION;    
    p += sizeof(DWORD);

    //
    // Set the current time
    //

    GetSystemTimeAsFileTime((PFILETIME)p);
    p += sizeof(FILETIME);

    //
    // reserved for now
    //

    p += sizeof(LARGE_INTEGER);

    //
    // Pack the size of the up to date vector
    //

    *((PDWORD)p) = cbVecSize;
    p += sizeof(DWORD);

    //
    // Copy the usnvecTo. 
    //

    CopyMemory( p,pUsnVec, sizeof(USN_VECTOR));
    p += sizeof(USN_VECTOR);

    //
    // Copy the invocation UUID
    //

    CopyMemory( p, puuidInvocationId, sizeof(UUID));

    p += sizeof(UUID);

    //
    // Copy the UPTODATE_VECTOR if it exists
    //

    if( cbVecSize > 0 ) {
        CopyMemory( p,
                    pUtdvecV1, 
                    cbVecSize);
    }

    *pdwCookieLenNext = cbCookie;
    *ppCookieNext = pbCookie;

    return ERROR_SUCCESS;
} /* packCookie */

/* end dirsync.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\test\mangle\mangle.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    testspn.c

Abstract:

    Program to test mangled rdn api functions

Author:

    Will Lees (wlees) 22-Feb-2001

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsapi.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntdsapi.h>
#include <ntdsapip.h>

#define DS_MANGLE_NOT_MANGLED ((DS_MANGLE_FOR) 100)



BOOL
testCrackMangledRdn(
    void
    )

/*++

Routine Description:

    Test the DsCrackUnquotedMangledRdn API

Arguments:

    void - 

Return Value:

    BOOL - TRUE for error, FALSE for success

--*/

{
    struct _CRACK_MANGLED_RDN_TEST_CASE {
        LPSTR pszRdn;
        LPSTR pszGuid;
        DS_MANGLE_FOR eDsMangleFor;
    } testCases[] = {
        { "MPDC02\nCNF:e65c039f-e2f6-4d34-8ecb-ce70e7183299",
          "e65c039f-e2f6-4d34-8ecb-ce70e7183299",
          DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT },
        { "SLON00PDC500\nDEL:623e116d-5b60-48cb-a501-7d9c523345fd",
          "623e116d-5b60-48cb-a501-7d9c523345fd",
          DS_MANGLE_OBJECT_RDN_FOR_DELETION },
        { "CN=SLON00PDC500\nDEL:623e116d-5b60-48cb-a501-7d9c523345fd",
          "623e116d-5b60-48cb-a501-7d9c523345fd",
          DS_MANGLE_OBJECT_RDN_FOR_DELETION },
        { "DC=wlees4",
          NULL,
          DS_MANGLE_NOT_MANGLED }
    };
#define NUMBER_TEST_CASES (sizeof(testCases) / sizeof(testCases[0]))
    struct _CRACK_MANGLED_RDN_TEST_CASE *pTestCase;
    DWORD i, ret;
    GUID guid;
    DS_MANGLE_FOR eDsMangleFor;
    LPSTR pszGuid;
    BOOL fIsMangled;

    printf( "DsCrackUnquotedMangledRdnA Tests\n" );

    for( i = 0,pTestCase = testCases; i < NUMBER_TEST_CASES; i++,pTestCase++ ) {
        ZeroMemory( &guid, sizeof(GUID) );
        eDsMangleFor = DS_MANGLE_UNKNOWN;
        printf( "\tRdn[%d] %s\n", i, pTestCase->pszRdn );
        fIsMangled = DsCrackUnquotedMangledRdnA( pTestCase->pszRdn,
                                                 strlen( pTestCase->pszRdn ),
                                                 &guid,
                                                 &eDsMangleFor );
        if (!fIsMangled) {
            if (pTestCase->eDsMangleFor == DS_MANGLE_NOT_MANGLED) {
                continue;
            }
            printf( "DsCrackUnquotedMangledRdnA gave unexpected result\n" );
            return TRUE;
        }
        if (eDsMangleFor != pTestCase->eDsMangleFor) {
            printf( "Mangle state doesn't match\n" );
            return TRUE;
        }
        ret = UuidToString( &guid, &pszGuid );
        if (ret) {
            printf( "UuidToStsring failed with error %d\n", ret );
            return TRUE;
        }
        if (strcmp(pszGuid,pTestCase->pszGuid)) {
            printf( "Decoded guid doesn't match\n" );
            return TRUE;
        }
        RpcStringFree( &pszGuid );
    }

    return FALSE;
#undef NUMBER_TEST_CASES
} /* testCrackMangledRdn */


BOOL
testIsMangledRdn(
    void
    )

/*++

Routine Description:

    Test the IsMangledRdnValue function

Arguments:

    void - 

Return Value:

    BOOL - TRUE for error, FALSE for success

--*/

{
    struct _IS_MANGLED_RDN_TEST_CASE {
        LPSTR pszRdn;
        DS_MANGLE_FOR eDsMangleFor;
    } testCases[] = {
        { "MPDC02\nCNF:e65c039f-e2f6-4d34-8ecb-ce70e7183299",
           DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT },
        { "SLON00PDC500\nDEL:623e116d-5b60-48cb-a501-7d9c523345fd",
              DS_MANGLE_OBJECT_RDN_FOR_DELETION },
        { "SLON00PDC500\\0ADEL:623e116d-5b60-48cb-a501-7d9c523345fd",
              DS_MANGLE_OBJECT_RDN_FOR_DELETION },
        { "wlees4",
              DS_MANGLE_NOT_MANGLED }
    };
#define NUMBER_TEST_CASES (sizeof(testCases) / sizeof(testCases[0]))
    struct _IS_MANGLED_RDN_TEST_CASE *pTestCase;
    DWORD i, ret;
    BOOL fIsMangledForNameConflict, fIsMangledForDeletion;
    printf( "DsIsMangledRdnA Tests\n" );

    for( i = 0,pTestCase = testCases; i < NUMBER_TEST_CASES; i++,pTestCase++ ) {
        printf( "\tRdn[%d] %s\n", i, pTestCase->pszRdn );
        fIsMangledForNameConflict =
            DsIsMangledRdnValueA( pTestCase->pszRdn,
                                  strlen( pTestCase->pszRdn ),
                                  DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT );
        fIsMangledForDeletion =
            DsIsMangledRdnValueA( pTestCase->pszRdn,
                                  strlen( pTestCase->pszRdn ),
                                  DS_MANGLE_OBJECT_RDN_FOR_DELETION );
        switch (pTestCase->eDsMangleFor) {
        case DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT:
            if ( !fIsMangledForNameConflict ||
                 fIsMangledForDeletion ) {
                printf( "Wrong mangle type\n" );
                return TRUE;
            }
            break;
        case DS_MANGLE_OBJECT_RDN_FOR_DELETION:
            if ( fIsMangledForNameConflict ||
                 !fIsMangledForDeletion ) {
                printf( "Wrong mangle type\n" );
                return TRUE;
            }
            break;
        case DS_MANGLE_NOT_MANGLED:
            if ( fIsMangledForNameConflict ||
                 fIsMangledForDeletion ) {
                printf( "Wrong mangle type\n" );
                return TRUE;
            }
            break;
        default:
            printf( "Internal error\n" );
            return TRUE;
        }
    }

    return FALSE;
#undef NUMBER_TEST_CASES
} /* testIsMangledRdn */


BOOL
testIsMangledDn(
    void
    )

/*++

Routine Description:

    Test the IsMangledDn API

Arguments:

    void - 

Return Value:

    BOOL - TRUE for error, FALSE for success

--*/

{
    struct _IS_MANGLED_DN_TEST_CASE {
        LPSTR pszDn;
        DS_MANGLE_FOR eDsMangleFor;
    } testCases[] = {
        { "CN=MPDC02\nCNF:e65c039f-e2f6-4d34-8ecb-ce70e7183299,CN=blah",
              DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT },
        { "OU=SLON00PDC500\nDEL:623e116d-5b60-48cb-a501-7d9c523345fd,OU=foo,OU=bar",
              DS_MANGLE_OBJECT_RDN_FOR_DELETION },
        { "DC=SLON00PDC500\\0ADEL:623e116d-5b60-48cb-a501-7d9c523345fd,DC=nttest,DC=microsoft,dc=com",
              DS_MANGLE_OBJECT_RDN_FOR_DELETION },
        { "DC=wlees4,DC=wleesdom,DC=nttest,DC=microsoft,DC=com",
              DS_MANGLE_NOT_MANGLED }
    };
#define NUMBER_TEST_CASES (sizeof(testCases) / sizeof(testCases[0]))
    struct _IS_MANGLED_DN_TEST_CASE *pTestCase;
    DWORD i, ret;
    BOOL fIsMangledForNameConflict, fIsMangledForDeletion;
    printf( "DsIsMangledDnA Tests\n" );

    for( i = 0,pTestCase = testCases; i < NUMBER_TEST_CASES; i++,pTestCase++ ) {
        printf( "\tDn[%d] %s\n", i, pTestCase->pszDn );
        fIsMangledForNameConflict =
            DsIsMangledDnA( pTestCase->pszDn,
                            DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT );
        fIsMangledForDeletion =
            DsIsMangledDnA( pTestCase->pszDn,
                            DS_MANGLE_OBJECT_RDN_FOR_DELETION );
        switch (pTestCase->eDsMangleFor) {
        case DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT:
            if ( !fIsMangledForNameConflict ||
                 fIsMangledForDeletion ) {
                printf( "Wrong mangle type\n" );
                return TRUE;
            }
            break;
        case DS_MANGLE_OBJECT_RDN_FOR_DELETION:
            if ( fIsMangledForNameConflict ||
                 !fIsMangledForDeletion ) {
                printf( "Wrong mangle type\n" );
                return TRUE;
            }
            break;
        case DS_MANGLE_NOT_MANGLED:
            if ( fIsMangledForNameConflict ||
                 fIsMangledForDeletion ) {
                printf( "Wrong mangle type\n" );
                return TRUE;
            }
            break;
        default:
            printf( "Internal error\n" );
            return TRUE;
        }
    }

    return FALSE;
#undef NUMBER_TEST_CASES
} /* testIsMangledDn */


int __cdecl
main(
    int argc,
    CHAR *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;

    printf( "Mangled RDN API Tests\n" );

    if (testCrackMangledRdn()) {
        printf( "Failed.\n" );
    }
    if (testIsMangledRdn()) {
        printf( "Failed.\n" );
    }
    if (testIsMangledDn()) {
        printf( "Failed.\n" );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\aclguids\aclguids.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       aclguids.c
//
//  Author:     Marios Zikos
//
//--------------------------------------------------------------------------

//
// Aclguids is a utility that generates an include file with all the
// guids that can be used in ACLs. These guids are all the schema objects
// and all the control access rights
//
// The generated header file contains an array of guids, sorted on the guid.
// It is used by ldp, dsexts in order to print the name of a particular guid
// that is found on an ACL.
//
// This utility should be run periodically, whenever schema changes take place,
// inorder to have an updated version of the header file.
// It requires an installed DC with the schema that will be used to 
// generate the header file.

#include <util.h>

BOOL    List = FALSE;

CHAR    *pgUser         = NULL;
CHAR    *pgDom          = NULL;
CHAR    *pgPwd          = NULL;
CHAR    *pgDc           = NULL;
CHAR    *pFilename      = NULL;

Arg args[] =  { 
                { "-user:", &pgUser,       TRUE  },
                { "-dom:",  &pgDom,        TRUE  },
                { "-pwd:",  &pgPwd,        TRUE  },
                { "-dc:",   &pgDc,         TRUE  },
                { "-output:",&pFilename,    FALSE },
              };

DWORD argCount = sizeof(args) / sizeof(args[0]);

void GetArgs(
    int     argc, 
    char    **argv)
{
    char    *arg;
    DWORD   i;
    BOOL    found;

    while ( --argc > 0 ) {
        arg = argv[argc];
        found = FALSE;

        if (!_stricmp(arg, "/v") || !_stricmp(arg, "-v")) {
            Verbose = TRUE;
            continue;
        }

        if (!_stricmp(arg, "/l") || !_stricmp(arg, "-l")) {
            List = TRUE;
            continue;
        }

        for ( i = 0; i < argCount; i++ ) {
            if ( !_strnicmp(arg, args[i].prefix, strlen(args[i].prefix)) ) {
                *args[i].ppArg = &arg[strlen(args[i].prefix)];
                found = TRUE;
            }
        }

        if ( !found ) {
            printf("\nDon't understand %s\n", arg);
            goto Usage;
        }
    }

    for ( i = 0; i < argCount; i++ ) {
        if ( !args[i].optional && !*args[i].ppArg ) {
            printf("\nMissing %s\n", args[i].prefix);
            goto Usage;
        }
    }

    if (Verbose) {
        printf("Arguments:%s%s\n", 
               (Verbose) ? " /v" : "",
               (List) ? " /l" : ""
                );
        for ( i = 0; i < argCount; i++ ) {
            printf("\t%s%s\n", args[i].prefix, *args[i].ppArg);
        }
    }

    return;

Usage:

    printf("\nUsage: %s [/v(erbose)] args...\n", argv[0]);
    for ( i = 0; i < argCount; i++ ) {
        printf("\t%s %sxxx\n", 
               (args[i].optional) ? "(Optional)" : "(Required)",
               args[i].prefix);
    }

    exit(1);
}

char *insert_space (int len)
{
    static char buffer[256];
    int i;

    for (i=0; i<len && i<255; i++) {
        buffer[i]=' ';
    }

    buffer[i]='\0';

    return buffer;
}

typedef struct GuidCache
{
    GUID                guid;
    CHAR                *name;
    int                 type;
} GuidCache;

#define MAX_GUID_CACHE_SIZE 5000
GuidCache guidcache[MAX_GUID_CACHE_SIZE];
int guidCount = 0;


int __cdecl CompareGuidCache(const void * pv1, const void * pv2)
{
    return memcmp ( &((GuidCache *)pv1)->guid, &((GuidCache *)pv2)->guid, sizeof (GUID));
}


void _cdecl 
main(
    int     argc, 
    char    **argv)
{
    DWORD           dwErr, count;
    PCHAR           RootDn = NULL;
    PCHAR           ConfigNC = NULL;
    PCHAR           SchemaNC = NULL;
    
    LDAP            *hLdapConn = NULL;
    PLDAPSearch     hPage;
    PLDAPMessage    ldap_message = NULL;
    PLDAPMessage    entry = NULL;
    
    CHAR            filter[512];
    CHAR            *attrs[3];
    PCHAR           dn;
    LDAP_TIMEVAL    tm;
    ULONG           ulPageSize, ulEntryCount;
    
    PLDAP_BERVAL    *sd_value = NULL;

    FILE            *fp = NULL;
    
    int             i;

    // Args
    GetArgs(argc, argv);

    // Bind to DC
    hLdapConn = LdapBind(pgDc, pgUser, pgDom, pgPwd);
    if (!hLdapConn) {
        goto cleanup;
    }

    // get ROOT DN
    RootDn = GetRootDn(hLdapConn, "");
    if (!RootDn) {
        goto cleanup;
    }

    ConfigNC = GetRootDn(hLdapConn, CONFIG_NAMING_CONTEXT);
    if (!ConfigNC) {
        goto cleanup;
    }

    SchemaNC = GetRootDn(hLdapConn, SCHEMA_NAMING_CONTEXT);
    if (!SchemaNC) {
        goto cleanup;
    }

    fprintf(stderr, "RootDN: %s\nConfigNC: %s\nSchemaNC: %s\n", RootDn, ConfigNC, SchemaNC);


    fp = fopen (pFilename, "w");
    if (!fp) {
        fprintf(stderr, "Error opening file: %s\n", pFilename);
        goto cleanup;
    }

    // first search the schema
    //

    strcpy (filter , "schemaIdGuid=*");
    attrs[0] = "ldapDisplayName";
    attrs[1] = "schemaIdGuid";
    attrs[2] = NULL;

    tm.tv_sec = 1000;
    tm.tv_usec = 1000;
    ulPageSize = 100;

    hPage = ldap_search_init_page(  hLdapConn,
                                    SchemaNC,
                                    LDAP_SCOPE_SUBTREE,     // whole tree
                                    filter,                 // filter
                                    attrs,                  // list of attributes
                                    0,
                                    NULL, 
                                    NULL,
                                    100000,
                                    ulPageSize,
                                    NULL);

    if(hPage == NULL) {
        dwErr = LdapGetLastError();
        printf ( "Error: Search: %s. <%ld>", ldap_err2string(dwErr), dwErr);
    }

    do {
        dwErr = ldap_get_next_page_s(hLdapConn, 
                                     hPage, 
                                     &tm, 
                                     ulPageSize, 
                                     &ulEntryCount, 
                                     &ldap_message);    

        if (ldap_message != NULL) {

            entry = ldap_first_entry( hLdapConn, ldap_message );

            while (entry != NULL) {

                //dn = ldap_get_dn( hLdapConn, entry );
                //printf( "Distinguished Name is : %s\n", dn );
                //ldap_memfree( dn );

                if (!(sd_value = ldap_get_values_lenA(hLdapConn, entry, attrs[0])) )
                {
                    printf ( "Error\n");
                    break;
                }

                guidcache[guidCount].name = _strdup ((char*)(*sd_value)->bv_val);

                ldap_value_free_len(sd_value);

                if (!(sd_value = ldap_get_values_lenA(hLdapConn, entry, attrs[1])) )
                {
                    printf ( "Error\n");
                    break;
                }

                guidcache[guidCount].guid = *(GUID *)(*sd_value)->bv_val;
                guidcache[guidCount].type = 2;
                guidCount++;

                ldap_value_free_len(sd_value);

                entry = ldap_next_entry( hLdapConn, entry );
            }
            ldap_msgfree( ldap_message );
        }

    } while ( dwErr == LDAP_SUCCESS );
    
    ldap_search_abandon_page(hLdapConn, hPage);
    
    
    
    // next search the contolAccessRights
    //

    strcpy (filter , "(&(objectCategory=controlAccessRight)(rightsGUID=*))");

    attrs[0] = "displayName";
    attrs[1] = "rightsGUID";
    attrs[2] = NULL;

    hPage = ldap_search_init_page(  hLdapConn,
                                    ConfigNC,
                                    LDAP_SCOPE_SUBTREE,     // whole tree
                                    filter,                 // filter
                                    attrs,                  // list of attributes
                                    0,
                                    NULL, 
                                    NULL,
                                    100000,
                                    ulPageSize,
                                    NULL);

    if(hPage == NULL) {
        dwErr = LdapGetLastError();
        printf ( "Error: Search: %s. <%ld>", ldap_err2string(dwErr), dwErr);
    }

    do {
        dwErr = ldap_get_next_page_s(hLdapConn, 
                                     hPage, 
                                     &tm, 
                                     ulPageSize, 
                                     &ulEntryCount, 
                                     &ldap_message);    

        if (ldap_message != NULL) {

            entry = ldap_first_entry( hLdapConn, ldap_message );

            while (entry != NULL) {

                if (!(sd_value = ldap_get_values_lenA(hLdapConn, entry, attrs[0])) )
                {
                    printf ( "Error\n");
                    break;
                }

                guidcache[guidCount].name = _strdup ((char*)(*sd_value)->bv_val);

                ldap_value_free_len(sd_value);

                if (!(sd_value = ldap_get_values_lenA(hLdapConn, entry, attrs[1])) )
                {
                    printf ( "Error\n");
                    break;
                }

                UuidFromString ((char *)(*sd_value)->bv_val, &guidcache[guidCount].guid);
                guidcache[guidCount].type = 1;
                guidCount++;

                ldap_value_free_len(sd_value);

                entry = ldap_next_entry( hLdapConn, entry );
            }
            ldap_msgfree( ldap_message );
        }

    } while ( dwErr == LDAP_SUCCESS );
    
    ldap_search_abandon_page(hLdapConn, hPage);


    qsort(guidcache, guidCount, sizeof (GuidCache), CompareGuidCache);

    for (i=0; i<guidCount; i++) {
        fprintf(fp, "{\"%s\",%s", 
                       guidcache[i].name,
                       insert_space (40 - strlen (guidcache[i].name)));

        fprintf(fp, "{0x%08x,0x%04x,0x%04x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x,0x%02x}",
               guidcache[i].guid.Data1,
               guidcache[i].guid.Data2,
               guidcache[i].guid.Data3,
               guidcache[i].guid.Data4[0],
               guidcache[i].guid.Data4[1],
               guidcache[i].guid.Data4[2],
               guidcache[i].guid.Data4[3],
               guidcache[i].guid.Data4[4],
               guidcache[i].guid.Data4[5],
               guidcache[i].guid.Data4[6],
               guidcache[i].guid.Data4[7]
               );
               
        fprintf(fp, ", %d},\n", guidcache[i].type);

        free (guidcache[i].name);
    }
    fprintf(fp, "{ NULL, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 0}\n");

cleanup:
    FREE(RootDn);
    FREE(ConfigNC);
    FREE(SchemaNC);
    UNBIND(hLdapConn);
    if (fp) {
        fclose (fp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\aclguids\base64.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       base64.c
//
//--------------------------------------------------------------------------
NTSTATUS
base64encode(
    IN  VOID *  pDecodedBuffer,
    IN  DWORD   cbDecodedBufferSize,
    OUT LPSTR   pszEncodedString,
    IN  DWORD   cchEncodedStringSize,
    OUT DWORD * pcchEncoded             OPTIONAL
    )
/*++

Routine Description:

    Decode a base64-encoded string.

Arguments:

    pDecodedBuffer (IN) - buffer to encode.
    cbDecodedBufferSize (IN) - size of buffer to encode.
    cchEncodedStringSize (IN) - size of the buffer for the encoded string.
    pszEncodedString (OUT) = the encoded string.
    pcchEncoded (OUT) - size in characters of the encoded string.

Return Values:

    0 - success.
    STATUS_INVALID_PARAMETER
    STATUS_BUFFER_TOO_SMALL

--*/
{
    static char rgchEncodeTable[64] = {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
    };

    DWORD   ib;
    DWORD   ich;
    DWORD   cchEncoded;
    BYTE    b0, b1, b2;
    BYTE *  pbDecodedBuffer = (BYTE *) pDecodedBuffer;

    // Calculate encoded string size.
    cchEncoded = 1 + (cbDecodedBufferSize + 2) / 3 * 4;

    if (NULL != pcchEncoded) {
        *pcchEncoded = cchEncoded;
    }

    if (cchEncodedStringSize < cchEncoded) {
        // Given buffer is too small to hold encoded string.
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Encode data byte triplets into four-byte clusters.
    ib = ich = 0;
    while (ib < cbDecodedBufferSize) {
        b0 = pbDecodedBuffer[ib++];
        b1 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;
        b2 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;

        pszEncodedString[ich++] = rgchEncodeTable[b0 >> 2];
        pszEncodedString[ich++] = rgchEncodeTable[((b0 << 4) & 0x30) | ((b1 >> 4) & 0x0f)];
        pszEncodedString[ich++] = rgchEncodeTable[((b1 << 2) & 0x3c) | ((b2 >> 6) & 0x03)];
        pszEncodedString[ich++] = rgchEncodeTable[b2 & 0x3f];
    }

    // Pad the last cluster as necessary to indicate the number of data bytes
    // it represents.
    switch (cbDecodedBufferSize % 3) {
      case 0:
        break;
      case 1:
        pszEncodedString[ich - 2] = '=';
        // fall through
      case 2:
        pszEncodedString[ich - 1] = '=';
        break;
    }

    // Null-terminate the encoded string.
    pszEncodedString[ich++] = '\0';

    Assert(ich == cchEncoded);

    return STATUS_SUCCESS;
}


NTSTATUS
base64decode(
    IN  LPSTR   pszEncodedString,
    OUT VOID *  pDecodeBuffer,
    IN  DWORD   cbDecodeBufferSize,
    OUT DWORD * pcbDecoded              OPTIONAL
    )
/*++

Routine Description:

    Decode a base64-encoded string.

Arguments:

    pszEncodedString (IN) - base64-encoded string to decode.
    cbDecodeBufferSize (IN) - size in bytes of the decode buffer.
    pbDecodeBuffer (OUT) - holds the decoded data.
    pcbDecoded (OUT) - number of data bytes in the decoded data (if success or
        STATUS_BUFFER_TOO_SMALL).

Return Values:

    0 - success.
    STATUS_INVALID_PARAMETER
    STATUS_BUFFER_TOO_SMALL

--*/
{
#define NA (255)
#define DECODE(x) (((int)(x) < sizeof(rgbDecodeTable)) ? rgbDecodeTable[x] : NA)

    static BYTE rgbDecodeTable[128] = {
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  // 0-15 
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  // 16-31
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 63, NA, NA, NA, 62,  // 32-47
       52, 53, 54, 55, 56, 57, 58, 59, 60, 61, NA, NA, NA, NA, NA, NA,  // 48-63
       NA, NA,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,  // 64-79
       15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, NA, NA, NA, NA, NA,  // 80-95
       NA, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,  // 96-111
       41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, NA, NA, NA, NA, NA,  // 112-127
    };

    DWORD   cbDecoded;
    DWORD   cchEncodedSize;
    DWORD   ich;
    DWORD   ib;
    BYTE    b0, b1, b2, b3;
    BYTE *  pbDecodeBuffer = (BYTE *) pDecodeBuffer;

    cchEncodedSize = lstrlenA(pszEncodedString);

    if ((0 == cchEncodedSize) || (0 != (cchEncodedSize % 4))) {
        // Input string is not sized correctly to be base64.
        return STATUS_INVALID_PARAMETER;
    }

    // Calculate decoded buffer size.
    cbDecoded = (cchEncodedSize + 3) / 4 * 3;
    if (pszEncodedString[cchEncodedSize-1] == '=') {
        if (pszEncodedString[cchEncodedSize-2] == '=') {
            // Only one data byte is encoded in the last cluster.
            cbDecoded -= 2;
        }
        else {
            // Only two data bytes are encoded in the last cluster.
            cbDecoded -= 1;
        }
    }

    if (NULL != pcbDecoded) {
        *pcbDecoded = cbDecoded;
    }

    if (cbDecoded > cbDecodeBufferSize) {
        // Supplied buffer is too small.
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Decode each four-byte cluster into the corresponding three data bytes.
    ich = ib = 0;
    while (ich < cchEncodedSize) {
        b0 = DECODE(pszEncodedString[ich++]);
        b1 = DECODE(pszEncodedString[ich++]);
        b2 = DECODE(pszEncodedString[ich++]);
        b3 = DECODE(pszEncodedString[ich++]);

        if ((NA == b0) || (NA == b1) || (NA == b2) || (NA == b3)) {
            // Contents of input string are not base64.
            return STATUS_INVALID_PARAMETER;
        }

        pbDecodeBuffer[ib++] = (b0 << 2) | (b1 >> 4);

        if (ib < cbDecodeBufferSize) {
            pbDecodeBuffer[ib++] = (b1 << 4) | (b2 >> 2);
    
            if (ib < cbDecodeBufferSize) {
                pbDecodeBuffer[ib++] = (b2 << 6) | b3;
            }
        }
    }

    Assert(ib == cbDecoded);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\aclguids\util.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       util.h
//
//--------------------------------------------------------------------------
#ifndef _UTILH_
#define _UTILH_

//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Windows Headers
//
#include <windows.h>

//
// C-Runtime Header
//
#include <malloc.h>
#include <memory.h>
#include <process.h>
#include <signal.h>
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <excpt.h>
#include <conio.h>
#include <sys\types.h>
#include <errno.h>
#include <sys\stat.h>
#include <ctype.h>

//
// API headers
//
#include <rpc.h>
#include <ntdsapi.h>
#include <winldap.h>
#include <sddl.h>
#include <ntldap.h>

//
// Defines
//

// DACLS
#define DACL_ALLOW_DELETE   "(A;;SD;;;AU)"

// STUBS
#define STUB_BJF_CLASS  "bjfclass"
#define STUB_BJF_OBJECT "bjfobject"

// ds
#define FILTER_CATEGORY_ANY     "(objectCategory=*)"
#define FILTER_LINKID_ANY       "(linkId=*)"
#define FILTER_CATEGORY_ATTR    "(objectCategory=attributeSchema)"
#define FILTER_CATEGORY_CLASS   "(objectCategory=classSchema)"
#define FILTER_OBJECT_SID       "(objectSID=.)"
#define FILTER_BJF_CLASS        "(cn=" STUB_BJF_CLASS "*)"

#define CN_ROOT                 ""
#define CN_TOP                  "Top"
#define CN_BJF_CONTAINER        "bjfContainer"

#define SCHEMA_NAMING_CONTEXT   "cn=schema"
#define CONFIG_NAMING_CONTEXT   "cn=configuration"

#define ATTR_NAMING_CONTEXTS    "namingContexts"
#define ATTR_CN                 "cn"
#define ATTR_DN                 "distinguishedName"
#define ATTR_IS_SINGLE_VALUED   "isSingleValued"
#define ATTR_LINK_ID            "linkId"
#define ATTR_MAY_CONTAIN        "mayContain"
#define ATTR_SYSTEM_MAY_CONTAIN "systemmayContain"
#define ATTR_MUST_CONTAIN        "mustContain"
#define ATTR_SYSTEM_MUST_CONTAIN "systemmustContain"
#define ATTR_LDAP_DISPLAY_NAME   "ldapDisplayName"
#define ATTR_PARTIAL_SET         "isMemberOfPartialAttributeSet"
#define ATTR_SYSTEM_FLAGS        "systemFlags"
#define ATTR_SYSTEM_ONLY         "systemOnly"
#define ATTR_GOVERNS_ID          "governsId"
#define ATTR_ATTRIBUTE_ID        "attributeId"
#define ATTR_SD                  "nTSecurityDescriptor"
#define ATTR_TG                 "tokenGroups"
#define ATTR_TGGU               "tokenGroupsGlobalAndUniversal"
#define ATTR_TGNOGC             "tokenGroupsNoGcAcceptable"
#define ATTR_DEFAULT_NC         "defaultNamingContext"
#define ATTR_OBJECT_SID         "objectSID"
#define ATTR_ENTRY_TTL          "EntryTTL"

// registry
#define NTDS_SERVICE            "NTDS"
#define NTDS_ROOT               "System\\CurrentControlSet\\Services\\" NTDS_SERVICE
#define NTDS_PARAMETERS         NTDS_ROOT "\\Parameters"
#define NTDS_UPDATE_SCHEMA      "Schema Update Allowed"
#define NTDS_DELETE_SCHEMA      "Schema Delete Allowed"
#define NTDS_SYSTEM_SCHEMA      "Allow System Only Change"

#define FREE(_x_)       { if (_x_) free(_x_); _x_ = NULL; }
#define FREE_LOCAL(_x_) { if (_x_) LocalFree(_x_); _x_ = NULL; }
#define FREECREDS(_x_)  { if (_x_) DsFreePasswordCredentials(_x_); _x_ = NULL; }
#define UNBIND(_x_)     { if (_x_) ldap_unbind(_x_); _x_ = NULL; }
#define FREE_MSG(x)        {if (x) {ldap_msgfree(x); (x) = NULL;}}
#define FREE_VALUES(x)     {if (x) {ldap_value_free(x); (x) = NULL;}}
#define FREE_BERVALUES(x)  {if (x) {ldap_value_free_len(x); (x) = NULL;}}
#define FREE_BER_VALUES(x) {if (x) {ldap_value_free_len(x); (x) = NULL;}}

//
// Globals and Params
//
extern BOOL Verbose;

typedef struct _Arg {
    CHAR    *prefix;
    CHAR    **ppArg;
    BOOL    optional;
} Arg;
    
PCHAR
ExtendDn(
    IN PCHAR Dn,
    IN PCHAR Cn
    );

BOOL
LdapSearch(
    IN PLDAP        ldap,
    IN PCHAR        Base,
    IN ULONG        Scope,
    IN PCHAR        Filter,
    IN PCHAR        Attrs[],
    IN LDAPMessage  **Res
    );

PCHAR *
GetValues(
    IN PLDAP  Ldap,
    IN PCHAR  Dn,
    IN PCHAR  DesiredAttr
    );
PCHAR
GetRootDn(
    IN PLDAP    Ldap,
    IN PCHAR    NamingContext
    );
VOID
FreeMod(
    IN OUT LDAPMod ***pppMod
    );
VOID
AddMod(
    IN PCHAR  AttrType,
    IN PCHAR  AttrValue,
    IN OUT LDAPMod ***pppMod
    );
VOID
AddModMod(
    IN PCHAR  AttrType,
    IN PCHAR  AttrValue,
    IN OUT LDAPMod ***pppMod
    );
VOID
AddModVal(
    IN PCHAR  AttrType,
    IN PCHAR  AttrValue,
    IN OUT LDAPMod ***pppMod
    );
BOOL
PutRegDWord(
    IN PCHAR    FQKey,
    IN PCHAR    Value,
    IN DWORD    DWord
    );
BOOL
GetRegDWord(
    IN  PCHAR   FQKey,
    IN  PCHAR   Value,
    OUT DWORD   *pDWord
    );
VOID
RefreshSchema(
    IN PLDAP Ldap
    );
PCHAR *
FindValues(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapEntry,
    IN PCHAR        DesiredAttr
    );
BOOL
DupStrValue(
    IN  PLDAP           Ldap,
    IN  PLDAPMessage    LdapEntry,
    IN  PCHAR           DesiredAttr,
    OUT PCHAR           *ppStr
    );
BOOL
DupBoolValue(
    IN  PLDAP           Ldap,
    IN  PLDAPMessage    LdapEntry,
    IN  PCHAR           DesiredAttr,
    OUT PBOOL           pBool
    );

DWORD
LdapSearchPaged(
    IN PLDAP        ldap,
    IN PCHAR        Base,
    IN ULONG        Scope,
    IN PCHAR        Filter,
    IN PCHAR        Attrs[],
    IN BOOL         (*Worker)(PLDAP Ldap, PLDAPMessage LdapMsg, PVOID Arg),
    IN PVOID        Arg
    );
BOOL
LdapDeleteTree(
    IN PLDAP        Ldap,
    IN PCHAR        Base
    );
BOOL
LdapDeleteEntries(
    IN PLDAP        Ldap,
    IN PCHAR        Base,
    IN PCHAR        Filter
    );
BOOL
LdapDumpSd(
    IN PLDAP        Ldap,
    IN PCHAR        Base,
    IN PCHAR        Filter
    );
BOOL
LdapAddDacl(
    IN PLDAP        Ldap,
    IN PCHAR        Base,
    IN PCHAR        Filter,
    IN PCHAR        AddStringSd
    );
PLDAP
LdapBind(
    IN PCHAR    pDc,
    IN PCHAR    pDom,
    IN PCHAR    pUser,
    IN PCHAR    pPwd
    );
DWORD
base64decode(
    IN  LPSTR   pszEncodedString,
    OUT VOID *  pDecodeBuffer,
    IN  DWORD   cbDecodeBufferSize,
    OUT DWORD * pcbDecoded              OPTIONAL
    );
#endif _UTILH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\base64\base64.c ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    base64.c

ABSTRACT:

    Base64 encoding and decoding functions.

DETAILS:
    
CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#include "debug.h"
#include "base64.h"


NTSTATUS
base64encode(
    IN  VOID *  pDecodedBuffer,
    IN  DWORD   cbDecodedBufferSize,
    OUT LPSTR   pszEncodedString,
    IN  DWORD   cchEncodedStringSize,
    OUT DWORD * pcchEncoded             OPTIONAL
    )
/*++

Routine Description:

    Decode a base64-encoded string.

Arguments:

    pDecodedBuffer (IN) - buffer to encode.
    cbDecodedBufferSize (IN) - size of buffer to encode.
    cchEncodedStringSize (IN) - size of the buffer for the encoded string.
    pszEncodedString (OUT) = the encoded string.
    pcchEncoded (OUT) - size in characters of the encoded string.

Return Values:

    0 - success.
    STATUS_INVALID_PARAMETER
    STATUS_BUFFER_TOO_SMALL

--*/
{
    static char rgchEncodeTable[64] = {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
    };

    DWORD   ib;
    DWORD   ich;
    DWORD   cchEncoded;
    BYTE    b0, b1, b2;
    BYTE *  pbDecodedBuffer = (BYTE *) pDecodedBuffer;

    // Calculate encoded string size.
    cchEncoded = 1 + (cbDecodedBufferSize + 2) / 3 * 4;

    if (NULL != pcchEncoded) {
        *pcchEncoded = cchEncoded;
    }

    if (cchEncodedStringSize < cchEncoded) {
        // Given buffer is too small to hold encoded string.
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Encode data byte triplets into four-byte clusters.
    ib = ich = 0;
    while (ib < cbDecodedBufferSize) {
        b0 = pbDecodedBuffer[ib++];
        b1 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;
        b2 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;

        pszEncodedString[ich++] = rgchEncodeTable[b0 >> 2];
        pszEncodedString[ich++] = rgchEncodeTable[((b0 << 4) & 0x30) | ((b1 >> 4) & 0x0f)];
        pszEncodedString[ich++] = rgchEncodeTable[((b1 << 2) & 0x3c) | ((b2 >> 6) & 0x03)];
        pszEncodedString[ich++] = rgchEncodeTable[b2 & 0x3f];
    }

    // Pad the last cluster as necessary to indicate the number of data bytes
    // it represents.
    switch (cbDecodedBufferSize % 3) {
      case 0:
        break;
      case 1:
        pszEncodedString[ich - 2] = '=';
        // fall through
      case 2:
        pszEncodedString[ich - 1] = '=';
        break;
    }

    // Null-terminate the encoded string.
    pszEncodedString[ich++] = '\0';

    Assert(ich == cchEncoded);

    return STATUS_SUCCESS;
}


NTSTATUS
base64decode(
    IN  LPSTR   pszEncodedString,
    OUT VOID *  pDecodeBuffer,
    IN  DWORD   cbDecodeBufferSize,
    OUT DWORD * pcbDecoded              OPTIONAL
    )
/*++

Routine Description:

    Decode a base64-encoded string.

Arguments:

    pszEncodedString (IN) - base64-encoded string to decode.
    cbDecodeBufferSize (IN) - size in bytes of the decode buffer.
    pbDecodeBuffer (OUT) - holds the decoded data.
    pcbDecoded (OUT) - number of data bytes in the decoded data (if success or
        STATUS_BUFFER_TOO_SMALL).

Return Values:

    0 - success.
    STATUS_INVALID_PARAMETER
    STATUS_BUFFER_TOO_SMALL

--*/
{
#define NA (255)
#define DECODE(x) (((int)(x) < sizeof(rgbDecodeTable)) ? rgbDecodeTable[x] : NA)

    static BYTE rgbDecodeTable[128] = {
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  // 0-15 
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  // 16-31
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 62, NA, NA, NA, 63,  // 32-47
       52, 53, 54, 55, 56, 57, 58, 59, 60, 61, NA, NA, NA,  0, NA, NA,  // 48-63
       NA,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,  // 64-79
       15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, NA, NA, NA, NA, NA,  // 80-95
       NA, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,  // 96-111
       41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, NA, NA, NA, NA, NA,  // 112-127
    };

    DWORD   cbDecoded;
    DWORD   cchEncodedSize;
    DWORD   ich;
    DWORD   ib;
    BYTE    b0, b1, b2, b3;
    BYTE *  pbDecodeBuffer = (BYTE *) pDecodeBuffer;

    cchEncodedSize = lstrlenA(pszEncodedString);

    if ((0 == cchEncodedSize) || (0 != (cchEncodedSize % 4))) {
        // Input string is not sized correctly to be base64.
        return STATUS_INVALID_PARAMETER;
    }

    // Calculate decoded buffer size.
    cbDecoded = (cchEncodedSize + 3) / 4 * 3;
    if (pszEncodedString[cchEncodedSize-1] == '=') {
        if (pszEncodedString[cchEncodedSize-2] == '=') {
            // Only one data byte is encoded in the last cluster.
            cbDecoded -= 2;
        }
        else {
            // Only two data bytes are encoded in the last cluster.
            cbDecoded -= 1;
        }
    }

    if (NULL != pcbDecoded) {
        *pcbDecoded = cbDecoded;
    }

    if (cbDecoded > cbDecodeBufferSize) {
        // Supplied buffer is too small.
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Decode each four-byte cluster into the corresponding three data bytes.
    ich = ib = 0;
    while (ich < cchEncodedSize) {
        b0 = DECODE(pszEncodedString[ich]); ich++;
        b1 = DECODE(pszEncodedString[ich]); ich++;
        b2 = DECODE(pszEncodedString[ich]); ich++;
        b3 = DECODE(pszEncodedString[ich]); ich++;

        if ((NA == b0) || (NA == b1) || (NA == b2) || (NA == b3)) {
            // Contents of input string are not base64.
            return STATUS_INVALID_PARAMETER;
        }

        pbDecodeBuffer[ib++] = (b0 << 2) | (b1 >> 4);

        if (ib < cbDecoded) {
            pbDecodeBuffer[ib++] = (b1 << 4) | (b2 >> 2);
    
            if (ib < cbDecoded) {
                pbDecodeBuffer[ib++] = (b2 << 6) | b3;
            }
        }
    }

    Assert(ib == cbDecoded);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\bootopt\exe\main.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    main.c

Abstract:

    This module implements functions to detect the system partition drive and
    providing extra options in boot.ini for NTDS setup on intel platform.

Author:

    R.S. Raghavan (rsraghav)    

Revision History:
    
    Created             10/07/96    rsraghav

--*/

#include <windows.h>
#include <bootopt.h>
#include <stdio.h>

int __cdecl main(int argc, char *argv[])
{
    BOOLEAN fUsage = FALSE;
    DWORD   WinError = ERROR_SUCCESS;
    NTDS_BOOTOPT_MODTYPE Modification = eAddBootOption;
    CHAR   *Option;

    if ( argc == 2 )
    {
        Option = argv[1];

        if ( *Option == '-' || *Option == '/' )
        {
            Option++;
        }

        if ( !_stricmp( Option, "add" ) )
        {
            printf( "Adding ds repair boot option ...\n");
            Modification = eAddBootOption;
        }
        else if ( !_stricmp( Option, "remove" ) )
        {
            printf( "Removing ds repair boot option ...\n");
            Modification = eRemoveBootOption;
        }
        else
        {
            fUsage = TRUE;
        }
    }
    else
    {
        fUsage = TRUE;
    }

    if ( fUsage )
    {
        printf( "%s -[add|remove]\nThis command adds or removes the ds repair"\
                 " option from your system boot options.\n", argv[0] );
    }
    else
    {
        WinError = NtdspModifyDsRepairBootOption( Modification );

        if ( WinError == ERROR_SUCCESS )
        {
            printf( "The command completed successfully.\n" );
        }
        else
        {
            printf( "The command errored with %d.\n", WinError );
        }
    }

    return ( fUsage ?  0  : WinError );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\aclguids\util.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       util.c
//
//--------------------------------------------------------------------------
#include <util.h> 

BOOL Verbose = FALSE;

PCHAR
ExtendDn(
    IN PCHAR Dn,
    IN PCHAR Cn
    )
/*++
Routine Description:
    Extend an existing DN with a new CN= component.

Arguments:
    Dn  - distinguished name
    Cn  - common name

Return Value:
    CN=Cn,Dn
--*/
{
    ULONG  Len;
    PCHAR  NewDn;

    if (!Dn || !Cn) {
        return NULL;
    }

    Len = strlen("CN=,") + strlen(Dn) + strlen(Cn) + 1;
    NewDn = (PCHAR)malloc(Len);
    strcpy(NewDn, "CN=");
    strcat(NewDn, Cn);
    strcat(NewDn, ",");
    strcat(NewDn, Dn);
    return NewDn;
}

BOOL
LdapSearch(
    IN PLDAP        ldap,
    IN PCHAR        Base,
    IN ULONG        Scope,
    IN PCHAR        Filter,
    IN PCHAR        Attrs[],
    IN LDAPMessage  **Res
    )
/*++
Routine Description:
    Issue the ldap ldap_search_s call and check for errors.

Arguments:
    ldap
    Base
    Scope
    Filter
    Attrs
    Res

Return Value:
    The ldap array of values.
    The ldap array is freed with ldap_value_free().
--*/
{
    DWORD dwErr;

    // Issue the ldap search
    dwErr = ldap_search_s(ldap, Base, Scope, Filter, Attrs, FALSE, Res);

    // Check for errors
    if (dwErr) {
        if (Verbose) {
            printf("ldap_search_s(%s) ==> %08x (%08x): %s\n",
               Base, dwErr, LdapMapErrorToWin32(dwErr), ldap_err2string(dwErr));
        }
        return FALSE;
    }
    return TRUE;
}

BOOL
LdapDelete(
    IN PLDAP        ldap,
    IN PCHAR        Base
    )
/*++
Routine Description:
    Issue the ldap ldap_delete_s call and check for errors.

Arguments:
    ldap
    Base

Return Value:
    FALSE if problems
--*/
{
    DWORD dwErr;

printf("deleting %s\n", Base);

    // Issue the ldap search
    dwErr = ldap_delete_s(ldap, Base);

    // Check for errors
    if (dwErr != LDAP_SUCCESS && dwErr != LDAP_NO_SUCH_OBJECT) {
        if (Verbose) {
            printf("ldap_delete_s(%s) ==> %08x (%08x): %s\n",
               Base, dwErr, LdapMapErrorToWin32(dwErr), ldap_err2string(dwErr));
        }
        return FALSE;
    }
    return TRUE;
}

PCHAR *
GetValues(
    IN PLDAP  Ldap,
    IN PCHAR  Dn,
    IN PCHAR  DesiredAttr
    )
/*++
Routine Description:
    Return the DS values for one attribute in an object.

Arguments:
    ldap        - An open, bound ldap port.
    Base        - The "pathname" of a DS object.
    DesiredAttr - Return values for this attribute.

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with ldap_value_free(). NULL if unsuccessful.
--*/
{
    PCHAR           Attr;
    BerElement      *Ber;
    PLDAPMessage    LdapMsg;
    PLDAPMessage    LdapEntry;
    PCHAR           Attrs[2];
    PCHAR           *Values = NULL;

    // Search Base for all of its attributes + values
    Attrs[0] = DesiredAttr;
    Attrs[1] = NULL;

    // Issue the ldap search
    if (!LdapSearch(Ldap, Dn, LDAP_SCOPE_BASE, FILTER_CATEGORY_ANY,
                    Attrs, &LdapMsg)) {
        return NULL;
    }
    LdapEntry = ldap_first_entry(Ldap, LdapMsg);
    if (LdapEntry) {
        Attr = ldap_first_attribute(Ldap, LdapEntry, &Ber);
        if (Attr) {
            Values = ldap_get_values(Ldap, LdapEntry, Attr);
        }
    }
    ldap_msgfree(LdapMsg);
    return Values;
}

PCHAR
GetRootDn(
    IN PLDAP    Ldap,
    IN PCHAR    NamingContext
    )
/*++
Routine Description:

Arguments:

Return Value:
--*/
{
    PCHAR   Root;       // DS pathname of configuration container
    PCHAR   *Values;    // values from the attribute "namingContexts"
    DWORD   NumVals;    // number of values

    // Return all of the values for the attribute namingContexts
    Values = GetValues(Ldap, CN_ROOT, ATTR_NAMING_CONTEXTS);
    if (Values == NULL)
        return NULL;

    // Find the naming context that begins with CN=Configuration
    NumVals = ldap_count_values(Values);
    while (NumVals--) {
        _strlwr(Values[NumVals]);
        Root = strstr(Values[NumVals], NamingContext);
        if (Root != NULL && Root == Values[NumVals]) {
            Root = _strdup(Root);
            ldap_value_free(Values);
            return Root;
        }
    }
    printf("COULD NOT FIND %s\n", NamingContext);
    ldap_value_free(Values);
    return NULL;
}

VOID
FreeMod(
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Free the structure built by successive calls to AddMod().

Arguments:
    pppMod  - Address of a null-terminated array.

Return Value:
    *pppMod set to NULL.
--*/
{
    DWORD   i, j;
    LDAPMod **ppMod;

    if (!pppMod || !*pppMod) {
        return;
    }

    // For each attibute
    ppMod = *pppMod;
    for (i = 0; ppMod[i] != NULL; ++i) {
        //
        // For each value of the attribute
        //
        for (j = 0; (ppMod[i])->mod_values[j] != NULL; ++j) {
            // Free the value
            if (ppMod[i]->mod_op & LDAP_MOD_BVALUES) {
                free(ppMod[i]->mod_bvalues[j]->bv_val);
            }
            free((ppMod[i])->mod_values[j]);
        }
        free((ppMod[i])->mod_values);   // Free the array of pointers to values
        free((ppMod[i])->mod_type);     // Free the string identifying the attribute
        free(ppMod[i]);                 // Free the attribute
    }
    free(ppMod);        // Free the array of pointers to attributes
    *pppMod = NULL;     // Now ready for more calls to AddMod()
}

VOID
AddModVal(
    IN PCHAR  AttrType,
    IN PCHAR  AttrValue,
    IN LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add a value to an existing attribute and an existing structure that
    will eventually be used in an ldap_add/modify() function to add/modify
    an object to the DS.

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    pppMod          - Address of an array of pointers to "attributes".

Return Value:
    Additional value for AttrType
--*/
{
    DWORD   i;
    LDAPMod **ppMod;    // Address of the first entry in the Mod array

    for (ppMod = *pppMod; *ppMod != NULL; ++ppMod) {
        if (!_stricmp((*ppMod)->mod_type, AttrType)) {
            for (i = 0; (*ppMod)->mod_values[i]; ++i);
            (*ppMod)->mod_values = (PCHAR *)realloc((*ppMod)->mod_values, 
                                                    sizeof (PCHAR *) * (i + 2));
            (*ppMod)->mod_values[i] = _strdup(AttrValue);
            (*ppMod)->mod_values[i+1] = NULL;
            break;
        }
    }
}

VOID
AddModOrAdd(
    IN PCHAR  AttrType,
    IN PCHAR  AttrValue,
    IN ULONG  mod_op,
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    mod_op          - LDAP_MOD_ADD/REPLACE
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    DWORD   NumMod;     // Number of entries in the Mod array
    LDAPMod **ppMod;    // Address of the first entry in the Mod array
    LDAPMod *Attr;      // An attribute structure
    PCHAR    *Values;    // An array of pointers to bervals

    if (AttrValue == NULL)
        return;

    //
    // The null-terminated array doesn't exist; create it
    //
    if (*pppMod == NULL) {
        *pppMod = (LDAPMod **)malloc(sizeof (*pppMod));
        **pppMod = NULL;
    }

    //
    // Increase the array's size by 1
    //
    for (ppMod = *pppMod, NumMod = 2; *ppMod != NULL; ++ppMod, ++NumMod);
    *pppMod = (LDAPMod **)realloc(*pppMod, sizeof (*pppMod) * NumMod);

    //
    // Add the new attribute + value to the Mod array
    //
    Values = (PCHAR  *)malloc(sizeof (PCHAR ) * 2);
    Values[0] = _strdup(AttrValue);
    Values[1] = NULL;

    Attr = (LDAPMod *)malloc(sizeof (*Attr));
    Attr->mod_values = Values;
    Attr->mod_type = _strdup(AttrType);
    Attr->mod_op = mod_op;

    (*pppMod)[NumMod - 1] = NULL;
    (*pppMod)[NumMod - 2] = Attr;
}

VOID
AddMod(
    IN PCHAR  AttrType,
    IN PCHAR  AttrValue,
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    AddModOrAdd(AttrType, AttrValue, LDAP_MOD_ADD, pppMod);
}

VOID
AddModMod(
    IN PCHAR  AttrType,
    IN PCHAR  AttrValue,
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_modify() function to change an object in the DS.
    The null-terminated array referenced by pppMod grows with each call
    to this routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    AddModOrAdd(AttrType, AttrValue, LDAP_MOD_REPLACE, pppMod);
}

VOID
AddBerMod(
    IN PCHAR  AttrType,
    IN PCHAR  AttrValue,
    IN DWORD  AttrValueLen,
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    DWORD   NumMod;     // Number of entries in the Mod array
    LDAPMod **ppMod;    // Address of the first entry in the Mod array
    LDAPMod *Attr;      // An attribute structure
    PCHAR   *Values;    // An array of pointers to bervals
    PBERVAL Berval;

    if (AttrValue == NULL) {
        return;
    }

    //
    // The null-terminated array doesn't exist; create it
    //
    if (*pppMod == NULL) {
        *pppMod = (LDAPMod **)malloc(sizeof (*pppMod));
        **pppMod = NULL;
    }

    //
    // Increase the array's size by 1
    //
    for (ppMod = *pppMod, NumMod = 2; *ppMod != NULL; ++ppMod, ++NumMod);
    *pppMod = (LDAPMod **)realloc(*pppMod, sizeof (*pppMod) * NumMod);

    //
    // Construct a berval
    //
    Berval = (PBERVAL)malloc(sizeof(BERVAL));
    Berval->bv_len = AttrValueLen;
    Berval->bv_val = (PCHAR)malloc(AttrValueLen);
    CopyMemory(Berval->bv_val, AttrValue, AttrValueLen);

    //
    // Add the new attribute + value to the Mod array
    //
    Values = (PCHAR  *)malloc(sizeof (PCHAR ) * 2);
    Values[0] = (PCHAR)Berval;
    Values[1] = NULL;

    Attr = (LDAPMod *)malloc(sizeof (*Attr));
    Attr->mod_values = Values;
    Attr->mod_type = _strdup(AttrType);
    Attr->mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;

    (*pppMod)[NumMod - 1] = NULL;
    (*pppMod)[NumMod - 2] = Attr;
}

BOOL
PutRegDWord(
    IN PCHAR    FQKey,
    IN PCHAR    Value,
    IN DWORD    DWord
    )
/*++
Routine Description:
    This function writes a keyword value into the registry.

Arguments:
    HKey    - Key to be read
    Param   - value string to update
    DWord   - dword to be written

Return Value:
    TRUE    - Success
    FALSE   - Not
--*/
{
    HKEY    HKey;
    DWORD   dwErr;

    //
    // Open the key
    //
    dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, FQKey, &HKey);
    if (dwErr) {
        if (Verbose) {
            printf("RegOpenKey(%s\\%s) ==> %08x\n", FQKey, Value, dwErr);
        }
        return FALSE;
    }
    //

    //
    // Write the value
    //
    dwErr = RegSetValueEx(HKey,
                          Value,
                          0,
                          REG_DWORD,
                          (PUCHAR)&DWord,
                          sizeof(DWord));
    RegCloseKey(HKey);
    if (dwErr) {
        if (Verbose) {
            printf("RegSetValueEx(%s\\%s) ==> %08x\n", FQKey, Value, dwErr);
        }
        return FALSE;
    }
    return TRUE;
}

BOOL
GetRegDWord(
    IN  PCHAR   FQKey,
    IN  PCHAR   Value,
    OUT DWORD   *pDWord
    )
/*++
Routine Description:
    This function reads a keyword value from the registry.

Arguments:
    HKey    - Key to be read
    Param   - value string to update
    pDWord  - address of dword read from registry

Return Value:
    TRUE    - Success
    FALSE   - Not
--*/
{
    HKEY    HKey;
    DWORD   dwErr;
    DWORD   dwSize = sizeof(DWORD);
    DWORD   dwType;

    //
    // Open the key
    //
    dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, FQKey, &HKey);
    if (dwErr) {
        return FALSE;
    }
    //

    //
    // Read the value
    //
    dwErr = RegQueryValueEx(HKey,
                            Value,
                            NULL,
                            &dwType,
                            (PUCHAR) pDWord,
                            &dwSize);
    RegCloseKey(HKey);
    if (dwErr) {
        return FALSE;
    }
    if (dwType != REG_DWORD) {
        return FALSE;
    }
    return TRUE;
}

VOID
RefreshSchema(
    IN PLDAP Ldap
    )
/*++
Routine Description:

Arguments:
    None.

Return Value:
    None.
--*/
{
    DWORD   dwErr;
    LDAPMod **Mod = NULL;

    AddMod("schemaUpdateNow", "1", &Mod);
    dwErr = ldap_modify_s(Ldap, "", Mod);
    FreeMod(&Mod);
    if (dwErr) {
        if (Verbose) {
            printf("ldap_modify_s(schemaUpdateNow) ==> %08x (%08x): %s\n", 
               dwErr, LdapMapErrorToWin32(dwErr), ldap_err2string(dwErr));
        }
    }
}

PCHAR *
FindValues(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapEntry,
    IN PCHAR        DesiredAttr
    )
/*++
Routine Description:
    Return the DS values for one attribute in an entry.

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    DesiredAttr - Return values for this attribute.

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with LDAP_FREE_VALUES().
    NULL if unsuccessful.
--*/
{
    PCHAR       LdapAttr;
    BerElement  *LdapBer;

    // Search the entry for the desired attribute
    for (LdapAttr = ldap_first_attribute(Ldap, LdapEntry, &LdapBer);
         LdapAttr != NULL;
         LdapAttr = ldap_next_attribute(Ldap, LdapEntry, LdapBer)) {

        if (!_stricmp(DesiredAttr, LdapAttr)) {
            // Return the values for DesiredAttr
            return ldap_get_values(Ldap, LdapEntry, LdapAttr);
        }
    }
    return NULL;
}

PBERVAL *
FindBerValues(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapEntry,
    IN PCHAR        DesiredAttr
    )
/*++
Routine Description:
    Return the DS ber values for one attribute in an entry.

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    DesiredAttr - Return values for this attribute.

Return Value:
    An array of char pointers that represents the values for the attribute.
    The caller must free the array with LDAP_FREE_VALUES().
    NULL if unsuccessful.
--*/
{
    PCHAR       LdapAttr;
    BerElement  *LdapBer;

    // Search the entry for the desired attribute
    for (LdapAttr = ldap_first_attribute(Ldap, LdapEntry, &LdapBer);
         LdapAttr != NULL;
         LdapAttr = ldap_next_attribute(Ldap, LdapEntry, LdapBer)) {

        if (!_stricmp(DesiredAttr, LdapAttr)) {
            // Return the values for DesiredAttr
            return ldap_get_values_len(Ldap, LdapEntry, LdapAttr);
        }
    }
    return NULL;
}

BOOL
DupStrValue(
    IN  PLDAP           Ldap,
    IN  PLDAPMessage    LdapEntry,
    IN  PCHAR           DesiredAttr,
    OUT PCHAR           *ppStr
    )
/*++
Routine Description:
    Dup the first value for the attribute DesiredAttr

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    DesiredAttr - locate the values for this attribute
    Value       - Dup of first value (NULL if none)

Return Value:
    TRUE  - found a value, ppStr is set (free with FREE(*ppStr))
    FALSE - Not, ppStr is NULL
--*/
{
    PCHAR   *Values = NULL;


    *ppStr = NULL;

    // Dup the first value for DesiredAttr
    Values = FindValues(Ldap, LdapEntry, DesiredAttr);
    if (!Values || !Values[0]) {
        return FALSE;
    }
    *ppStr = _strdup(Values[0]);
    FREE_VALUES(Values);
    return TRUE;
}

BOOL
DupBoolValue(
    IN  PLDAP           Ldap,
    IN  PLDAPMessage    LdapEntry,
    IN  PCHAR           DesiredAttr,
    OUT PBOOL           pBool
    )
/*++
Routine Description:
    Dup the first value for the attribute DesiredAttr

Arguments:
    Ldap        - An open, bound ldap port.
    LdapEntry   - An ldap entry returned by ldap_search_s()
    DesiredAttr - locate the values for this attribute
    Value       - Dup of first value (NULL if none)

Return Value:
    TRUE  - found a value, *pBool is set
    FALSE - Not, pBool is undefined
--*/
{
    PCHAR   sBool = NULL;

    if (!DupStrValue(Ldap, LdapEntry, DesiredAttr, &sBool)) {
        return FALSE;
    }
    if (!_stricmp(sBool, "TRUE")) {
        *pBool = TRUE;
    } else if (!_stricmp(sBool, "FALSE")) {
        *pBool = FALSE;
    } else {
        FREE(sBool);
        return FALSE;
    }
    FREE(sBool);
    return TRUE;
}

DWORD
LdapSearchPaged(
    IN PLDAP        Ldap,
    IN PCHAR        Base,
    IN ULONG        Scope,
    IN PCHAR        Filter,
    IN PCHAR        Attrs[],
    IN BOOL         (*Worker)(PLDAP Ldap, PLDAPMessage LdapMsg, PVOID Arg),
    IN PVOID        Arg
    )
/*++
Routine Description:
    Call the Worker for each successful paged search

Arguments:
    ldap
    Base
    Scope
    Filter
    Attrs
    Res
    Worker
    Arg
            
Return Value:
    FALSE if problem
--*/
{
    PLDAPMessage    LdapMsg = NULL;
    DWORD           TotalEstimate, dwErr;
    LDAPSearch      *pSearch = NULL;

    // Paged search
    pSearch = ldap_search_init_page(Ldap,
                                    Base,
                                    Scope,
                                    Filter,
                                    Attrs,
                                    FALSE, NULL, NULL, 0, 0, NULL);
    if (pSearch == NULL) {
        dwErr = LdapGetLastError();
        if (Verbose) {
            printf("ldap_search_init_page(%s) ==> %08x (%08x): %s\n",
               Base, dwErr, LdapMapErrorToWin32(dwErr), ldap_err2string(dwErr));
        }
        goto cleanup;
    }

NextPage:
    FREE_MSG(LdapMsg);
    dwErr = ldap_get_next_page_s(Ldap,
                                 pSearch,
                                 0,
                                 2048,
                                 &TotalEstimate,
                                 &LdapMsg);
    if (dwErr != LDAP_SUCCESS) {
        if (dwErr == LDAP_NO_RESULTS_RETURNED) {
            dwErr = LDAP_SUCCESS;
        } else {
            if (Verbose) {
                printf("ldap_get_next_page_s(%s) ==> %08x (%08x): %s\n",
                   Base, dwErr, LdapMapErrorToWin32(dwErr), ldap_err2string(dwErr));
            }
        }
        goto cleanup;
    }

    // Call worker
    if ((*Worker)(Ldap, LdapMsg, Arg)) {
        goto NextPage;
    }

cleanup:
    FREE_MSG(LdapMsg);
    if (pSearch) {
        ldap_search_abandon_page(Ldap, pSearch);
    }
    return (dwErr);
}

BOOL
LdapDeleteTreeWorker(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapMsg,
    IN PVOID        Arg
    )
/*++
Routine Description:
    Delete the contents of each returned entry

Arguments:

Return Value:
    FALSE if problem
--*/
{
    PLDAPMessage    LdapEntry = NULL;
    BOOL            *pBool = Arg;
    PCHAR           *Values = NULL;

    // no problems, yet
    *pBool = TRUE;

    // scan thru the paged results
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL && *pBool;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        // Delete this entry and its contents
        Values = FindValues(Ldap, LdapEntry, ATTR_DN);
        if (Values && Values[0] && *Values[0]) {
            *pBool = LdapDeleteTree(Ldap, Values[0]);
        } else {
            *pBool = FALSE;
        }
        FREE_VALUES(Values);
    }
    return *pBool;
}

BOOL
LdapDeleteTree(
    IN PLDAP        Ldap,
    IN PCHAR        Base
    )
/*++
Routine Description:
    Delete Base and its contents

Arguments:
            
Return Value:
    FALSE if problem
--*/
{
    DWORD   dwErr;
    PCHAR   Attrs[16];
    BOOL    WorkerBool = TRUE;

    Attrs[0] = ATTR_DN;
    Attrs[1] = NULL;
    dwErr = LdapSearchPaged(Ldap,
                            Base,
                            LDAP_SCOPE_ONELEVEL,
                            FILTER_CATEGORY_ANY,
                            Attrs,
                            LdapDeleteTreeWorker,
                            &WorkerBool);
    // paged search went okay
    if (dwErr != LDAP_SUCCESS && dwErr != LDAP_NO_SUCH_OBJECT) {
        return FALSE;
    }

    // delete of contents went okay
    if (!WorkerBool) {
        return FALSE;
    }

    // delete base
    return LdapDelete(Ldap, Base);
}

BOOL
LdapDeleteEntriesWorker(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapMsg,
    IN PVOID        Arg
    )
/*++
Routine Description:
    Delete each returned entry

Arguments:

Return Value:
    FALSE if problem
--*/
{
    PLDAPMessage    LdapEntry = NULL;
    BOOL            *pBool = Arg;
    PCHAR           *Values = NULL;

    // no problems, yet
    *pBool = TRUE;

    // scan thru the paged results
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL && *pBool;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        // Delete this entry and its contents
        Values = FindValues(Ldap, LdapEntry, ATTR_DN);
        if (Values && Values[0] && *Values[0]) {
            *pBool = LdapDelete(Ldap, Values[0]);
        } else {
            *pBool = FALSE;
        }
        FREE_VALUES(Values);
    }
    return *pBool;
}

BOOL
LdapDeleteEntries(
    IN PLDAP        Ldap,
    IN PCHAR        Base,
    IN PCHAR        Filter
    )
/*++
Routine Description:
    Delete entries returned from one level search of Base

Arguments:
    ldap
    Base
    Filter
            
Return Value:
    FALSE if problem
--*/
{
    DWORD   dwErr;
    PCHAR   Attrs[16];
    BOOL    WorkerBool = TRUE;

    Attrs[0] = ATTR_DN;
    Attrs[1] = NULL;
    dwErr = LdapSearchPaged(Ldap,
                            Base,
                            LDAP_SCOPE_ONELEVEL,
                            Filter,
                            Attrs,
                            LdapDeleteEntriesWorker,
                            &WorkerBool);
    // paged search went okay
    if (dwErr != LDAP_SUCCESS && dwErr != LDAP_NO_SUCH_OBJECT) {
        return FALSE;
    }
    return WorkerBool;
}

BOOL
LdapDumpSdWorker(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapMsg,
    IN PVOID        Arg
    )
/*++
Routine Description:
    Dump the Sd of each entry

Arguments:

Return Value:
    FALSE if problem
--*/
{
    PLDAPMessage    LdapEntry = NULL;
    PCHAR           *ValuesCn = NULL;
    PBERVAL         *ValuesSd = NULL;
    PCHAR           StringSd = NULL;
    DWORD           nStringSd = 0;

    // scan thru the paged results
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        // cn
        ValuesCn = FindValues(Ldap, LdapEntry, ATTR_CN);

        // SD
        ValuesSd = FindBerValues(Ldap, LdapEntry, ATTR_SD);
        if (ValuesSd && 
            ValuesSd[0] && 
            ValuesSd[0]->bv_len && 
            ValuesSd[0]->bv_val) {
            if (!ConvertSecurityDescriptorToStringSecurityDescriptor(
                    ValuesSd[0]->bv_val,
                    SDDL_REVISION_1,
                    GROUP_SECURITY_INFORMATION |
                    SACL_SECURITY_INFORMATION |
                    DACL_SECURITY_INFORMATION |
                    OWNER_SECURITY_INFORMATION,
                    &StringSd,
                    &nStringSd)) {
                printf("ConvertSd() ==> %08x\n", GetLastError());
            }
        }

        printf("%s: %s\n",
               (ValuesCn) ? ValuesCn[0] : "?", StringSd);
        FREE_VALUES(ValuesCn);
        FREE_BERVALUES(ValuesSd);
        FREE_LOCAL(StringSd);
    }
    return TRUE;
}

BOOL
LdapDumpSd(
    IN PLDAP        Ldap,
    IN PCHAR        Base,
    IN PCHAR        Filter
    )
/*++
Routine Description:
    Delete entries returned from one level search of Base

Arguments:
            
Return Value:
    FALSE if problem
--*/
{
    DWORD   dwErr;
    PCHAR   Attrs[16];

    Attrs[0] = ATTR_CN;
    Attrs[1] = ATTR_SD;
    Attrs[2] = NULL;
    dwErr = LdapSearchPaged(Ldap,
                            Base,
                            LDAP_SCOPE_SUBTREE,
                            Filter,
                            Attrs,
                            LdapDumpSdWorker,
                            NULL);
    // paged search went okay
    if (dwErr != LDAP_SUCCESS && dwErr != LDAP_NO_SUCH_OBJECT) {
        return FALSE;
    }
    return TRUE;
}

BOOL
LdapAddDaclWorker(
    IN PLDAP        Ldap,
    IN PLDAPMessage LdapMsg,
    IN PVOID        Arg
    )
/*++
Routine Description:
    Add SDDL Aces to the DACL

Arguments:

Return Value:
    FALSE if problem
--*/
{
    PLDAPMessage            LdapEntry = NULL;
    PCHAR                   *ValuesCn = NULL;
    PCHAR                   *ValuesDn = NULL;
    PBERVAL                 *OldValuesSd = NULL;
    PCHAR                   OldStringSd = NULL;
    DWORD                   nOldStringSd = 0;
    LDAPMod                 **Mod = NULL;
    BOOL                    Ret = FALSE;
    PCHAR                   AddStringSd = Arg;
    PCHAR                   NewStringSd = NULL;
    DWORD                   nNewStringSd;
    PSECURITY_DESCRIPTOR    Sd;
    DWORD                   nSd;
    DWORD                   dwErr;
    LDAPControl             Control;
    LDAPControl             *aControl[2];
    BYTE                    AclInfo[5]
    ; INT                      Dacl = DACL_SECURITY_INFORMATION;

    Control.ldctl_oid = LDAP_SERVER_SD_FLAGS_OID;
    Control.ldctl_value.bv_len = sizeof(INT);
    Control.ldctl_value.bv_val = (PVOID)&Dacl;
    Control.ldctl_iscritical = TRUE;
    aControl[0] = &Control;
    aControl[1] = NULL;

    // scan thru the paged results
    for (LdapEntry = ldap_first_entry(Ldap, LdapMsg);
         LdapEntry != NULL;
         LdapEntry = ldap_next_entry(Ldap, LdapEntry)) {

        // cn
        ValuesCn = FindValues(Ldap, LdapEntry, ATTR_CN);
        if (!ValuesCn || !ValuesCn[0]) {
            goto cleanup;
        }

        printf("Processing %s...\n", ValuesCn[0]);

        // dn
        ValuesDn = FindValues(Ldap, LdapEntry, ATTR_DN);
        if (!ValuesDn || !ValuesDn[0]) {
            goto cleanup;
        }

        // Get Old SD
        OldValuesSd = FindBerValues(Ldap, LdapEntry, ATTR_SD);
        if (!OldValuesSd || 
            !OldValuesSd[0] || 
            !OldValuesSd[0]->bv_len || 
            !OldValuesSd[0]->bv_val) {
            goto cleanup;
        }

        // Old Sd -> Old String SD
        if (!ConvertSecurityDescriptorToStringSecurityDescriptor(OldValuesSd[0]->bv_val,
                                                                 SDDL_REVISION_1,
                                                                 DACL_SECURITY_INFORMATION,
                                                                 &OldStringSd,
                                                                 &nOldStringSd)) {
            if (Verbose) {
                printf("ConvertSdtoString(%s) ==> %08x\n", ValuesCn[0], GetLastError());
            }
            goto cleanup;
        }

        // Create new dacl
        nNewStringSd = strlen(OldStringSd) + strlen(AddStringSd) + 1;
        NewStringSd = malloc(nNewStringSd);
        strcpy(NewStringSd, OldStringSd);
        strcat(NewStringSd, AddStringSd);
        printf("%s: %s\n", ValuesCn[0], NewStringSd);
        if (!ConvertStringSecurityDescriptorToSecurityDescriptor(NewStringSd,
                                                                 SDDL_REVISION_1,
                                                                 &Sd,
                                                                 &nSd)) {
            if (Verbose) {
                printf("ConvertStringToSd(%s) ==> %08x\n", ValuesCn[0], GetLastError());
            }
            goto cleanup;
        }

        AddBerMod(ATTR_SD, Sd, nSd, &Mod);
        dwErr = ldap_modify_ext_s(Ldap, ValuesDn[0], Mod, aControl, NULL);
        if (dwErr) {
            if (Verbose) {
                printf("ldap_modify_ext_s(%s) ==> %08x (%08x): %s\n", 
                   ValuesCn[0], dwErr, LdapMapErrorToWin32(dwErr), ldap_err2string(dwErr));
            }
        }

        FREE_VALUES(ValuesCn);
        FREE_VALUES(ValuesDn);
        FREE_BERVALUES(OldValuesSd);
        FREE_LOCAL(OldStringSd);
        FREE_LOCAL(Sd);
        FreeMod(&Mod);
    }

    Ret = TRUE;

cleanup:
    FREE_VALUES(ValuesCn);
    FREE_VALUES(ValuesDn);
    FREE_BERVALUES(OldValuesSd);
    FREE_LOCAL(OldStringSd);
    FREE_LOCAL(Sd);
    FREE(NewStringSd);
    FreeMod(&Mod);
    return Ret;
}

BOOL
LdapAddDacl(
    IN PLDAP        Ldap,
    IN PCHAR        Base,
    IN PCHAR        Filter,
    IN PCHAR        AddStringSd
    )
/*++
Routine Description:
    Delete entries returned from one level search of Base

Arguments:
            
Return Value:
    FALSE if problem
--*/
{
    DWORD   dwErr;
    PCHAR   Attrs[16];

    if (!AddStringSd) {
        return FALSE;
    }

    Attrs[0] = ATTR_CN;
    Attrs[1] = ATTR_SD;
    Attrs[2] = ATTR_DN;
    Attrs[3] = NULL;
    dwErr = LdapSearchPaged(Ldap,
                            Base,
                            LDAP_SCOPE_SUBTREE,
                            Filter,
                            Attrs,
                            LdapAddDaclWorker,
                            AddStringSd);
    // paged search went okay
    if (dwErr != LDAP_SUCCESS && dwErr != LDAP_NO_SUCH_OBJECT) {
        return FALSE;
    }
    return TRUE;
}

PLDAP
LdapBind(
    IN PCHAR    pDc,
    IN PCHAR    pUser,
    IN PCHAR    pDom,
    IN PCHAR    pPwd
    )
/*++
Routine Description:
    Bind to the DC

Arguments:
    pDc - domain controller or NULL
    pUser - user name or NULL
    pDom - domain name for pUser or NULL
    pPwd - password or NULL
            
Return Value:
    NULL if problem; otherwise bound ldap handle
--*/
{
    DWORD                       dwErr;
    PCHAR                       HostName = NULL;
    PLDAP                       Ldap = NULL;
    RPC_AUTH_IDENTITY_HANDLE    AuthIdentity = NULL;

    if (pUser || pDom || pPwd) {
        dwErr = DsMakePasswordCredentials(pUser, pDom, pPwd, &AuthIdentity);
        if (dwErr) {
            printf("DsMakePasswordCredentials(%s, %s, %s) ==> %08x\n",
                   pUser, pDom, pPwd, dwErr);
            return NULL;
        }
    }

    Ldap = ldap_open(pDc, LDAP_PORT);
    if (!Ldap) {
        dwErr = GetLastError();
        printf("ldap_open(%s) ==> %08x\n", pDc, dwErr);
        return NULL;
    }

    dwErr = ldap_bind_s(Ldap, "", AuthIdentity, LDAP_AUTH_NEGOTIATE);
    if (dwErr) {
        printf("ldap_bind_s() ==> %08x (%08x): %s\n", 
               dwErr, LdapMapErrorToWin32(dwErr), ldap_err2string(dwErr));
        UNBIND(Ldap);
        return NULL;
    }

    dwErr = ldap_get_option(Ldap,
                            LDAP_OPT_HOST_NAME,
                            &HostName);
    if (dwErr == LDAP_SUCCESS && HostName) {
        printf("\nBound to DC %s\n", HostName);
    }

    return (Ldap);
}

DWORD
base64encode(
    IN  VOID *  pDecodedBuffer,
    IN  DWORD   cbDecodedBufferSize,
    OUT LPSTR   pszEncodedString,
    IN  DWORD   cchEncodedStringSize,
    OUT DWORD * pcchEncoded             OPTIONAL
    )
/*++

Routine Description:

    Encode a base64-encoded string.

Arguments:

    pDecodedBuffer (IN) - buffer to encode.
    cbDecodedBufferSize (IN) - size of buffer to encode.
    cchEncodedStringSize (IN) - size of the buffer for the encoded string.
    pszEncodedString (OUT) = the encoded string.
    pcchEncoded (OUT) - size in characters of the encoded string.

Return Values:

    0 - success.
    ERROR_INVALID_PARAMETER
    ERROR_BUFFER_OVERFLOW

--*/
{
    static char rgchEncodeTable[64] = {
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
    };

    DWORD   ib;
    DWORD   ich;
    DWORD   cchEncoded;
    BYTE    b0, b1, b2;
    BYTE *  pbDecodedBuffer = (BYTE *) pDecodedBuffer;

    // Calculate encoded string size.
    cchEncoded = 1 + (cbDecodedBufferSize + 2) / 3 * 4;

    if (NULL != pcchEncoded) {
        *pcchEncoded = cchEncoded;
    }

    if (cchEncodedStringSize < cchEncoded) {
        // Given buffer is too small to hold encoded string.
        return ERROR_BUFFER_OVERFLOW;
    }

    // Encode data byte triplets into four-byte clusters.
    ib = ich = 0;
    while (ib < cbDecodedBufferSize) {
        b0 = pbDecodedBuffer[ib++];
        b1 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;
        b2 = (ib < cbDecodedBufferSize) ? pbDecodedBuffer[ib++] : 0;

        pszEncodedString[ich++] = rgchEncodeTable[b0 >> 2];
        pszEncodedString[ich++] = rgchEncodeTable[((b0 << 4) & 0x30) | ((b1 >> 4) & 0x0f)];
        pszEncodedString[ich++] = rgchEncodeTable[((b1 << 2) & 0x3c) | ((b2 >> 6) & 0x03)];
        pszEncodedString[ich++] = rgchEncodeTable[b2 & 0x3f];
    }

    // Pad the last cluster as necessary to indicate the number of data bytes
    // it represents.
    switch (cbDecodedBufferSize % 3) {
      case 0:
        break;
      case 1:
        pszEncodedString[ich - 2] = '=';
        // fall through
      case 2:
        pszEncodedString[ich - 1] = '=';
        break;
    }

    // Null-terminate the encoded string.
    pszEncodedString[ich++] = '\0';

    return ERROR_SUCCESS;
}

DWORD
base64decode(
    IN  LPSTR   pszEncodedString,
    OUT VOID *  pDecodeBuffer,
    IN  DWORD   cbDecodeBufferSize,
    OUT DWORD * pcbDecoded              OPTIONAL
    )
/*++

Routine Description:

    Decode a base64-encoded string.

Arguments:

    pszEncodedString (IN) - base64-encoded string to decode.
    cbDecodeBufferSize (IN) - size in bytes of the decode buffer.
    pbDecodeBuffer (OUT) - holds the decoded data.
    pcbDecoded (OUT) - number of data bytes in the decoded data (if success or
        ERROR_BUFFER_OVERFLOW).

Return Values:

    0 - success.
    ERROR_INVALID_PARAMETER
    ERROR_BUFFER_OVERFLOW

--*/
{
#define NA (255)
#define DECODE(x) (((int)(x) < sizeof(rgbDecodeTable)) ? rgbDecodeTable[x] : NA)

    static BYTE rgbDecodeTable[128] = {
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  // 0-15 
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,  // 16-31
       NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 63, NA, NA, NA, 62,  // 32-47
       52, 53, 54, 55, 56, 57, 58, 59, 60, 61, NA, NA, NA, NA, NA, NA,  // 48-63
       NA, NA,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,  // 64-79
       15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, NA, NA, NA, NA, NA,  // 80-95
       NA, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,  // 96-111
       41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, NA, NA, NA, NA, NA,  // 112-127
    };

    DWORD   cbDecoded;
    DWORD   cchEncodedSize;
    DWORD   ich;
    DWORD   ib;
    BYTE    b0, b1, b2, b3;
    BYTE *  pbDecodeBuffer = (BYTE *) pDecodeBuffer;

    cchEncodedSize = lstrlenA(pszEncodedString);

    if ((0 == cchEncodedSize) || (0 != (cchEncodedSize % 4))) {
        // Input string is not sized correctly to be base64.
        return ERROR_INVALID_PARAMETER;
    }

    // Calculate decoded buffer size.
    cbDecoded = (cchEncodedSize + 3) / 4 * 3;
    if (pszEncodedString[cchEncodedSize-1] == '=') {
        if (pszEncodedString[cchEncodedSize-2] == '=') {
            // Only one data byte is encoded in the last cluster.
            cbDecoded -= 2;
        }
        else {
            // Only two data bytes are encoded in the last cluster.
            cbDecoded -= 1;
        }
    }

    if (NULL != pcbDecoded) {
        *pcbDecoded = cbDecoded;
    }

    if (cbDecoded > cbDecodeBufferSize) {
        // Supplied buffer is too small.
        return ERROR_BUFFER_OVERFLOW;
    }

    // Decode each four-byte cluster into the corresponding three data bytes.
    ich = ib = 0;
    while (ich < cchEncodedSize) {
        b0 = DECODE(pszEncodedString[ich++]);
        b1 = DECODE(pszEncodedString[ich++]);
        b2 = DECODE(pszEncodedString[ich++]);
        b3 = DECODE(pszEncodedString[ich++]);

        if ((NA == b0) || (NA == b1) || (NA == b2) || (NA == b3)) {
            // Contents of input string are not base64.
            return ERROR_INVALID_PARAMETER;
        }

        pbDecodeBuffer[ib++] = (b0 << 2) | (b1 >> 4);

        if (ib < cbDecodeBufferSize) {
            pbDecodeBuffer[ib++] = (b1 << 4) | (b2 >> 2);
    
            if (ib < cbDecodeBufferSize) {
                pbDecodeBuffer[ib++] = (b2 << 6) | b3;
            }
        }
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\bootopt\lib\common.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    utils.h

Abstract:

    This module proto-types helper functions for the bootopt library and
    the structure definitions for structures that are common to intel and
    non-intel platforms.

Author:

    R.S. Raghavan (rsraghav)    

Revision History:
    
    Created             10/07/96    rsraghav

--*/

// C Runtime
#include <stdio.h>
#include <stdlib.h>

// NT APIs
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>

// Windos APIs
#include <windows.h>

#include <bootopt.h>

//  Macro Definitions

#define MALLOC(cb)              Malloc(cb)
#define REALLOC(pv, cbNew)      Realloc((pv),(cbNew))
#define FREE(pv)                Free(&(pv))

#define DISPLAY_STRING_DS_REPAIR    L"Windows NT (Directory Service Repair)"

#define MAX_DRIVE_NAME_LEN              (3)             // ?:\0

#define MAX_BOOT_START_OPTIONS_LEN      (256)
#define MAX_BOOT_PATH_LEN               (256)
#define MAX_BOOT_DISPLAY_LEN            (256)

#define INITIAL_KEY_COUNT   (10)
#define DEFAULT_KEY_INCREMENT (2)


//  Memory routine proto-types

PVOID   Malloc(IN DWORD cb);
PVOID   Realloc(IN PVOID pv, IN DWORD cbNew);
VOID    Free(IN OUT PVOID *ppv);

//  Other Common Util proto-types
BOOL   FModifyStartOptionsToBootKey(TCHAR *pszStartOptions, NTDS_BOOTOPT_MODTYPE Modification );

PTSTR DupString(IN PTSTR String);
PCWSTR StringString(IN PCWSTR String, IN PCWSTR SubString);
LPWSTR _lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength);
PWSTR NormalizeArcPath(IN PWSTR Path);
PWSTR DevicePathToArcPath(IN PWSTR NtPath, BOOL fFindSecond);
PWSTR GetSystemRootDevicePath();

VOID DnConcatenatePaths(IN OUT PTSTR Path1, IN     PTSTR Path2, IN     DWORD BufferSizeChars);

// Function proto-types     (X86)
TCHAR   GetX86SystemPartition();
VOID    InitializeBootKeysForIntel();
VOID    WriteBackBootKeysForIntel();

// Function proto-types     (non-intel)
BOOL    InitializeNVRAMForNonIntel();
BOOL    FModifyStartOptionsNVRAM(TCHAR *pszStartOptions, NTDS_BOOTOPT_MODTYPE Modification );
VOID    WriteBackNVRAMForNonIntel( NTDS_BOOTOPT_MODTYPE Modification );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\bootopt\lib\common.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    utils.c

Abstract:

    This module implements helper functions for the bootopt library.

Author:

    R.S. Raghavan (rsraghav)

Revision History:

    Created             10/07/96    rsraghav

--*/

#include "common.h"

WCHAR ArcNameDirectory[] = L"\\ArcName";

//
// Helper macro to make object attribute initialization a little cleaner.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )


PTSTR
DupString(
    IN PTSTR String
    )
{
    PTSTR p;

    p = MALLOC((lstrlen(String)+1)*sizeof(TCHAR));
    if (p == NULL) {
        return NULL;
    }
    lstrcpy(p,String);
    return(p);
}

VOID
DnConcatenatePaths(
    IN OUT PTSTR Path1,
    IN     PTSTR Path2,
    IN     DWORD BufferSizeChars
    )
{
    BOOL NeedBackslash = TRUE;
    DWORD l = lstrlen(Path1);

    if(BufferSizeChars >= sizeof(TCHAR)) {
        //
        // Leave room for terminating nul.
        //
        BufferSizeChars -= sizeof(TCHAR);
    }

    //
    // Determine whether we need to stick a backslash
    // between the components.
    //
    if(l && (Path1[l-1] == TEXT('\\'))) {

        NeedBackslash = FALSE;
    }

    if(*Path2 == TEXT('\\')) {

        if(NeedBackslash) {
            NeedBackslash = FALSE;
        } else {
            //
            // Not only do we not need a backslash, but we
            // need to eliminate one before concatenating.
            //
            Path2++;
        }
    }

    //
    // Append backslash if necessary and if it fits.
    //
    if(NeedBackslash && (l < BufferSizeChars)) {
        lstrcat(Path1,TEXT("\\"));
    }

    //
    // Append second part of string to first part if it fits.
    //
    if(l+lstrlen(Path2) < BufferSizeChars) {
        lstrcat(Path1,Path2);
    }
}

PWSTR
StringUpperN(
    IN OUT PWSTR    p,
    IN     unsigned n
    )
{
    unsigned u;

    for(u=0; u<n; u++) {
        p[u] = (WCHAR)CharUpperW((PWCHAR)p[u]);
    }

    return(p);
}

PCWSTR
StringString(
    IN PCWSTR String,
    IN PCWSTR SubString
    )
{
    int l1,l2,x,i;

    l1 = lstrlen(String);
    l2 = lstrlen(SubString);
    x = l1-l2;

    for(i=0; i<=x; i++) {
        if(!memcmp(String+i,SubString,l2*sizeof(TCHAR))) {
            return(String+i);
        }
    }

    return(NULL);
}

LPWSTR
_lstrcpynW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    )
{
    LPWSTR src,dst;

    src = (LPWSTR)lpString2;
    dst = lpString1;

    if(iMaxLength) {
        while(iMaxLength && *src) {
            *dst++ = *src++;
            iMaxLength--;
        }
        if(iMaxLength) {
            *dst = '\0';
        } else {
            dst--;
            *dst = '\0';
        }
    }
    return lpString1;
}

PWSTR
NormalizeArcPath(
    IN PWSTR Path
    )

/*++

Routine Description:

    Transform an ARC path into one with no sets of empty parenthesis
    (ie, transforom all instances of () to (0).).

    The returned path will be all lowercase.

Arguments:

    Path - ARC path to be normalized.

Return Value:

    Pointer to buffer containing normalized path.
    Caller must free this buffer with FREE().

--*/

{
    PWSTR p,q,r;
    PWSTR NormalizedPath, NewPath;

    NormalizedPath = MALLOC((lstrlen(Path)+100)*sizeof(WCHAR));
    if (NormalizedPath == NULL) {
        return NULL;
    }
    ZeroMemory(NormalizedPath,(lstrlen(Path)+100)*sizeof(WCHAR));

    for(p=Path; q=(PWSTR)StringString(p,L"()"); p=q+2) {

        r = NormalizedPath + lstrlen(NormalizedPath);
        _lstrcpynW(r,p,(INT)((q-p)+1));
        lstrcat(NormalizedPath,L"(0)");
    }
    lstrcat(NormalizedPath,p);

    // Resize buffer to free up unused space

    NewPath = REALLOC(NormalizedPath,(lstrlen(NormalizedPath)+1)*sizeof(WCHAR));

    // If success, return new block, otherwise return old block
    if (NewPath) {
        NormalizedPath = NewPath;
    }

    return(NormalizedPath);
}

PWSTR GetSystemRootDevicePath()
{
    TCHAR szSystemRoot[MAX_BOOT_PATH_LEN];
    PWSTR pstrSystemDir = NULL;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE ObjectHandle;
    NTSTATUS Status;
    PWSTR pstrDevicePath = NULL;
    PWSTR pstrDirStart = NULL;

    GetEnvironmentVariable(L"SystemRoot", szSystemRoot, MAX_BOOT_PATH_LEN);

    pstrSystemDir = wcschr(szSystemRoot, TEXT(':'));
    if (pstrSystemDir)
        pstrSystemDir++;    // now it points to directory part of the systemroot.
    _wcslwr(pstrSystemDir); // lowercase version of the system root env variable

    // Open \SystemRoot symbolic link object
    RtlInitUnicodeString(&UnicodeString, L"\\SystemRoot");
    InitializeObjectAttributes(&Obja, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);
    Status = NtOpenSymbolicLinkObject(&ObjectHandle, READ_CONTROL | SYMBOLIC_LINK_QUERY, &Obja);
    if (NT_SUCCESS(Status))
    {
        // allocate memory for the DevicePath
        pstrDevicePath = MALLOC(MAX_PATH * sizeof(WCHAR));
        if (pstrDevicePath)
        {
            UnicodeString.Buffer = pstrDevicePath;
            UnicodeString.Length = 0;
            UnicodeString.MaximumLength = (MAX_PATH * sizeof(WCHAR));

            RtlZeroMemory(pstrDevicePath, UnicodeString.MaximumLength);

            Status = NtQuerySymbolicLinkObject(ObjectHandle, &UnicodeString, NULL);
            if (NT_SUCCESS(Status))
            {
                // pstrDevicePath points to the DevicePath with directory extension.
                // truncate the directory extension

                _wcslwr(pstrDevicePath); // lowercase version of the device path

                pstrDirStart = wcsstr(pstrDevicePath, pstrSystemDir);
                if (pstrDirStart)
                    *pstrDirStart = TEXT('\0');
            }
            else
            {
                // NtQuerySymbolicLinkObject() failed
                FREE(pstrDevicePath);
                pstrDevicePath = NULL;
            }
        }

        NtClose(ObjectHandle);
    }
    
    return pstrDevicePath;
}

PWSTR
DevicePathToArcPath(
    IN PWSTR NtPath,
    BOOL fFindSecond
    )
{
    UNICODE_STRING UnicodeString;
    HANDLE DirectoryHandle;
    HANDLE ObjectHandle;
    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    BOOLEAN RestartScan;
    DWORD Context;
    BOOL MoreEntries;
    PWSTR ArcName;
    UCHAR Buffer[1024];
    POBJECT_DIRECTORY_INFORMATION DirInfo = (POBJECT_DIRECTORY_INFORMATION)Buffer;
    PWSTR ArcPath;
    BOOL fFoundFirst = FALSE;

    //
    // Assume failure.
    //
    ArcPath = NULL;

    //
    // Open the \ArcName directory.
    //
    INIT_OBJA(&Obja,&UnicodeString,ArcNameDirectory);

    Status = NtOpenDirectoryObject(&DirectoryHandle,DIRECTORY_QUERY,&Obja);

    if(NT_SUCCESS(Status)) {

        RestartScan = TRUE;
        Context = 0;
        MoreEntries = TRUE;

        do {

            Status = NtQueryDirectoryObject(
                        DirectoryHandle,
                        Buffer,
                        sizeof(Buffer),
                        TRUE,           // return single entry
                        RestartScan,
                        &Context,
                        NULL            // return length
                        );

            if(NT_SUCCESS(Status)) {

                CharLower(DirInfo->Name.Buffer);

                //
                // Make sure this name is a symbolic link.
                //
                if(DirInfo->Name.Length
                && (DirInfo->TypeName.Length >= 24)
                && StringUpperN((PWSTR)DirInfo->TypeName.Buffer,12)
                && !memcmp(DirInfo->TypeName.Buffer,L"SYMBOLICLINK",24))
                {
                    ArcName = MALLOC(DirInfo->Name.Length + sizeof(ArcNameDirectory) + sizeof(WCHAR));

                    if (ArcName == NULL) {
                        ArcPath = NULL;
                        break;
                    }
                    lstrcpy(ArcName,ArcNameDirectory);
                    DnConcatenatePaths(ArcName,DirInfo->Name.Buffer,(DWORD)(-1));

                    //
                    // We have the entire arc name in ArcName.  Now open it as a symbolic link.
                    //
                    INIT_OBJA(&Obja,&UnicodeString,ArcName);

                    Status = NtOpenSymbolicLinkObject(
                                &ObjectHandle,
                                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                                &Obja
                                );

                    if(NT_SUCCESS(Status)) {

                        //
                        // Finally, query the object to get the link target.
                        //
                        UnicodeString.Buffer = (PWSTR)Buffer;
                        UnicodeString.Length = 0;
                        UnicodeString.MaximumLength = sizeof(Buffer);

                        Status = NtQuerySymbolicLinkObject(
                                    ObjectHandle,
                                    &UnicodeString,
                                    NULL
                                    );

                        if(NT_SUCCESS(Status)) {

                            //
                            // nul-terminate the returned string
                            //
                            UnicodeString.Buffer[UnicodeString.Length/sizeof(WCHAR)] = 0;

                            if(!lstrcmpi(UnicodeString.Buffer,NtPath)) {

                                ArcPath = ArcName
                                        + (sizeof(ArcNameDirectory)/sizeof(WCHAR));

                                if (fFindSecond && !fFoundFirst)
                                {   // We are requested to find the second match and this is the first match
                                    // skip this match and continue to look for a second match
                                    fFoundFirst = TRUE;
                                    ArcPath = NULL;
                                }
                            }
                        }

                        NtClose(ObjectHandle);
                    }

                    if(!ArcPath) {
                        FREE(ArcName);
                    }
                }

            } else {

                MoreEntries = FALSE;
                if(Status == STATUS_NO_MORE_ENTRIES) {
                    Status = STATUS_SUCCESS;
                }
            }

            RestartScan = FALSE;

        } while(MoreEntries && !ArcPath);

        NtClose(DirectoryHandle);
    }

    //
    // ArcPath points into thje middle of a buffer.
    // The caller needs to be able to free it, so place it in its
    // own buffer here.
    //
    if(ArcPath) {
        ArcPath = DupString(ArcPath);
        FREE(ArcName);
    }

    return(ArcPath);
}

/*************************************************************************************
Routine Description:

    Displays a message box to indicate that there has been a memory allocation error.

Arguments:

Return Value:

**************************************************************************************/
void  ErrMemDlg()
{
    KdPrint(("NTDSETUP: Insufficient memory to continue\n"));
}


/*************************************************************************************
Routine Description:

    Allocates memory and fatal errors if none is available.

Arguments:

    cb - number of bytes to allocate

Return Value:

    Pointer to memory.

**************************************************************************************/

PVOID   Malloc(IN DWORD cb)
{
    PVOID p;

    if (((p = (PVOID) malloc(cb)) == NULL) && (cb != 0))
    {
        ErrMemDlg();
    }

    if ( p )
    {
        RtlZeroMemory( p, cb );
    }

    return(p);
}


/*************************************************************************************
Routine Description:

    Reallocates a block of memory previously allocated with Malloc();
    fatal error if no memory available.

Arguments:

    pv - pointer to the block of memory to be resized
    cb - number of bytes to allocate

Return Value:

    Pointer to memory.

**************************************************************************************/

PVOID   Realloc(IN PVOID pv, IN DWORD cbNew)
{
    PVOID p;

    if (((p = realloc(pv,cbNew)) == NULL) && (cbNew != 0))
    {
        ErrMemDlg();
    }

    return (p);
}

/*************************************************************************************
Routine Description:

    Free a block of memory previously allocated with Malloc().
    Sets the pointer to NULL.

Arguments:

    ppv - pointer to the pointer to the block to be freed.

Return Value:

    none.

**************************************************************************************/

VOID    Free(IN OUT PVOID *ppv)
{
    if (*ppv)
        free(*ppv);

    *ppv = NULL;
}


DWORD NtdspModifyDsRepairBootOption( NTDS_BOOTOPT_MODTYPE Modification )
{

#ifdef _X86_
    InitializeBootKeysForIntel();
    if (FModifyStartOptionsToBootKey(L" /debug /safeboot:DSREPAIR", Modification))
    {
        // We have really added a new key - write back to the system
        WriteBackBootKeysForIntel();
    }
#else
    if (InitializeNVRAMForNonIntel())
    {
        if (FModifyStartOptionsNVRAM(L"/debug /safeboot:DSREPAIR", Modification ))
        {
            WriteBackNVRAMForNonIntel( Modification );
        }
    }
#endif
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\bootopt\lib\nonintel.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    nonintel.c

Abstract:

    This module implements functions to deal with NVRAM for non-intel platforms.

Author:

    R.S. Raghavan (rsraghav)    

Revision History:
    
    Created             10/07/96    rsraghav
    
    Colin Brace  (ColinBr)  05/12/97
        Improved error handling

--*/

// Include files
#include "common.h"

#define SIZECHARS(buffer)   (sizeof(buffer)/sizeof(TCHAR))

// nv-ram stuff
typedef enum {
    BootVarSystemPartition = 0,
    BootVarOsLoader,
    BootVarOsLoadPartition,
    BootVarOsLoadFilename,
    BootVarLoadIdentifier,
    BootVarOsLoadOptions,
    BootVarMax
} BOOT_VARS;

PWSTR BootVarNames[BootVarMax] = { L"SYSTEMPARTITION",
                                   L"OSLOADER",
                                   L"OSLOADPARTITION",
                                   L"OSLOADFILENAME",
                                   L"LOADIDENTIFIER",
                                   L"OSLOADOPTIONS"
                                 };

PWSTR BootVarValues[BootVarMax];
DWORD BootVarComponentCount[BootVarMax];
PWSTR *BootVarComponents[BootVarMax];
DWORD LargestComponentCount;

PWSTR NewBootVarValues[BootVarMax];

PWSTR pstrArcPath;
PWSTR pstrLoadFilePath;
PWSTR pstrNewStartOption;
DWORD bootMarker = 0;


ULONG *SaveEntry;

WCHAR Buffer[4096];

#define OLD_SAMUSEREG_OPTION_NONINTEL   L"SAMUSEREG"
#define OLD_SAMUSEREG_OPTION_NONINTEL_2 L"/DEBUG /SAMUSEREG"
#define OLD_SAMUSEREG_OPTION_NONINTEL_3 L"/DEBUG /SAMUSEDS"
#define OLD_SAMUSEREG_OPTION_NONINTEL_4 L"/DEBUG /SAFEMODE"

BOOL  fFixedExisting = FALSE;

BOOL
EnablePrivilege(
    IN PTSTR PrivilegeName,
    IN BOOL  Enable
    )
{
    HANDLE Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        return(GetLastError() == ERROR_CALL_NOT_IMPLEMENTED);
    }

    if(!LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

    b = AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

    //
    // AdjustTokenPrivileges always returns TRUE; the real info is
    // in the LastError
    //

    if (ERROR_SUCCESS == GetLastError()) {
        b = TRUE;
    } else {
        KdPrint(("NTDSETUP: Unable to AdjustTokenPriviledges, error %d\n", GetLastError()));
        b = FALSE;
    }

    return(b);
}


BOOL
SetNvRamVar(
    IN PWSTR VarName,
    IN PWSTR VarValue
    )
{
    UNICODE_STRING U1,U2;

    RtlInitUnicodeString(&U1,VarName);
    RtlInitUnicodeString(&U2,VarValue);

    return(NT_SUCCESS(NtSetSystemEnvironmentValue(&U1,&U2)));
}


VOID
GetVarComponents(
    IN  PWSTR    VarValue,
    OUT PWSTR  **Components,
    OUT PDWORD   ComponentCount
    )
{
    PWSTR *components;
    DWORD componentCount;
    PWSTR p;
    PWSTR Var;
    PWSTR comp;
    DWORD len;
    DWORD dwCurrentMax = INITIAL_KEY_COUNT;


    components = MALLOC(dwCurrentMax * sizeof(PWSTR));
    if (!components)
    {
        *Components = NULL;
        *ComponentCount = 0;
        return;
    }
    

    for(Var=VarValue,componentCount=0; *Var; ) {

        //
        // Skip leading spaces.
        //
        while((*Var == L' ') || (*Var == L'\t')) {
            Var++;
        }

        if(*Var == 0) {
            break;
        }

        p = Var;

        while(*p && (*p != L';')) {
            p++;
        }

        len = (DWORD)((PUCHAR)p - (PUCHAR)Var);

        comp = MALLOC(len + sizeof(WCHAR));

        len /= sizeof(WCHAR);

        _lstrcpynW(comp,Var,len+1);

        components[componentCount] = NormalizeArcPath(comp);

        FREE(comp);

        componentCount++;

        if(componentCount == dwCurrentMax) 
        {
            dwCurrentMax += DEFAULT_KEY_INCREMENT;
            components = REALLOC(components, dwCurrentMax * sizeof(PWSTR));
            if (!components)
            {
                *Components = NULL;
                *ComponentCount = 0;
                return;
            }
        }

        Var = p;
        if(*Var) {
            Var++;      // skip ;
        }
    }

    *Components = REALLOC(components,componentCount*sizeof(PWSTR));
    *ComponentCount = (*Components) ? componentCount : 0;
}

BOOL
InitializeNVRAMForNonIntel()
{
    DWORD var;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG i;

    //
    // Get relevent boot vars.
    //
    // Enable privilege 
    //
    if(!EnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE)) {
        KdPrint(("NTDSETUP: EnablePrivilege failed, error %d\n", GetLastError()));
    } else 
    {

        for(var=0; var<BootVarMax; var++) {

            RtlInitUnicodeString(&UnicodeString,BootVarNames[var]);

            Status = NtQuerySystemEnvironmentValue(
                        &UnicodeString,
                        Buffer,
                        SIZECHARS(Buffer),
                        NULL
                        );

            if(NT_SUCCESS(Status)) {
                BootVarValues[var] = DupString(Buffer);
            } else {
                //
                // Error out
                //
                KdPrint(("NTDSETUP: NtQuerySystemEnvironmentValue failed with 0x%x\n", Status));
                return FALSE;
            }

            GetVarComponents(
                BootVarValues[var],
                &BootVarComponents[var],
                &BootVarComponentCount[var]
                );

            //
            // Track the variable with the most number of components.
            //
            if(BootVarComponentCount[var] > LargestComponentCount) {
                LargestComponentCount = BootVarComponentCount[var];
            }
        }
    }

    //
    // Allocate space the record of whether entries should be saved
    //
    SaveEntry = ( PULONG ) MALLOC( LargestComponentCount * sizeof(ULONG ) );
    if ( !SaveEntry )
    {
        return FALSE;
    }

    for ( i = 0; i < LargestComponentCount; i++ )
    {
        SaveEntry[i] = TRUE;
    }

    return TRUE;

}

BOOL 
FModifyStartOptionsNVRAM(
    IN TCHAR *pszStartOptions, 
    IN NTDS_BOOTOPT_MODTYPE Modification
    )
{
    TCHAR szSystemRoot[MAX_BOOT_PATH_LEN];
    TCHAR szDriveName[MAX_DRIVE_NAME_LEN];
    DWORD i, j;
    DWORD cMaxIterations;
    PWSTR pstrSystemRootDevicePath = NULL;
    BOOL  fRemovedAtLeastOneEntry = FALSE;

    if (!pszStartOptions)
    {
        KdPrint(("NTDSETUP: Unable to add the start option\n"));
        return FALSE;
    }

    GetEnvironmentVariable(L"SystemDrive", szDriveName, MAX_DRIVE_NAME_LEN);
    GetEnvironmentVariable(L"SystemRoot", szSystemRoot, MAX_BOOT_PATH_LEN);

    pstrSystemRootDevicePath = GetSystemRootDevicePath();
    if (!pstrSystemRootDevicePath)
        return FALSE;
    else
    {
        pstrArcPath      = DevicePathToArcPath(pstrSystemRootDevicePath, FALSE);
        FREE(pstrSystemRootDevicePath);
    }

    if (!pstrArcPath)
    {
        KdPrint(("NTDSETUP: Unable to add the start option\n"));
        return FALSE;
    }

    // point pstrLoadFilePath to the first letter after <drive>:
    pstrLoadFilePath = wcschr(szSystemRoot, TEXT(':'));
    if (!pstrLoadFilePath)
    {
        KdPrint(("NTDSETUP: Unable to add the start option\n"));
        return FALSE;
    }
    pstrLoadFilePath++;

    // check to see if there is already a corresponding entry which has the same start option
    // also keep track of the marker corresponding to the current boot partion/loadfile combination
    cMaxIterations = min(BootVarComponentCount[BootVarOsLoadPartition],BootVarComponentCount[BootVarOsLoadFilename]);
    for (i = 0; i <  cMaxIterations; i++)
    {
        if (!lstrcmpi(pstrArcPath, BootVarComponents[BootVarOsLoadPartition][i]) && 
            !lstrcmpi(pstrLoadFilePath, BootVarComponents[BootVarOsLoadFilename][i]))
        {
            bootMarker = i;

            if (i >= BootVarComponentCount[BootVarOsLoadOptions])
            {
                // no start options available for this combo
                continue;
            }

            // Now check if the given start option already exists at this marker        - if so, no need to add a new one
            if (!lstrcmpi(pszStartOptions, BootVarComponents[BootVarOsLoadOptions][i]))
            {
                if ( Modification == eRemoveBootOption )
                {
                    SaveEntry[ i ] = FALSE;
                    fRemovedAtLeastOneEntry = TRUE;
                }
                else
                {
                    ASSERT( Modification == eAddBootOption );

                    return FALSE;
                }

            }
            else if (!lstrcmpi(OLD_SAMUSEREG_OPTION_NONINTEL, BootVarComponents[BootVarOsLoadOptions][i]) ||
                 !lstrcmpi(OLD_SAMUSEREG_OPTION_NONINTEL_2, BootVarComponents[BootVarOsLoadOptions][i]) ||
                 !lstrcmpi(OLD_SAMUSEREG_OPTION_NONINTEL_4, BootVarComponents[BootVarOsLoadOptions][i]) ||
                 !lstrcmpi(OLD_SAMUSEREG_OPTION_NONINTEL_3, BootVarComponents[BootVarOsLoadOptions][i]) )
            {

                if ( Modification == eRemoveBootOption )
                {
                    SaveEntry[ i ] = FALSE;
                    fRemovedAtLeastOneEntry = TRUE;
                }
                else
                {

                    ASSERT( Modification == eAddBootOption );

                    // Old samusereg option exists - convert it to the new option and display string
                    FREE(BootVarValues[BootVarLoadIdentifier]);
                    Buffer[0] = TEXT('\0');
                    if (0 == i)
                        lstrcat(Buffer, DISPLAY_STRING_DS_REPAIR);
                    else if (BootVarComponentCount[BootVarLoadIdentifier] > 0)
                        lstrcat(Buffer, BootVarComponents[BootVarLoadIdentifier][0]);
    
                    for (j = 1; j < BootVarComponentCount[BootVarLoadIdentifier]; j++)
                    {
                        lstrcat(Buffer, L";");
                        if (j == i)
                            lstrcat(Buffer, DISPLAY_STRING_DS_REPAIR);
                        else
                            lstrcat(Buffer, BootVarComponents[BootVarLoadIdentifier][j]);
                    }
                    BootVarValues[BootVarLoadIdentifier] = DupString(Buffer);
    
                    FREE(BootVarValues[BootVarOsLoadOptions]);
                    Buffer[0] = TEXT('\0');
                    if (0 == i)
                        lstrcat(Buffer, pszStartOptions);
                    else if (BootVarComponentCount[BootVarOsLoadOptions] > 0)
                        lstrcat(Buffer, BootVarComponents[BootVarOsLoadOptions][0]);
    
                    for (j = 1; j < BootVarComponentCount[BootVarOsLoadOptions]; j++)
                    {
                        lstrcat(Buffer, L";");
                        if (j == i)
                            lstrcat(Buffer, pszStartOptions);
                        else
                            lstrcat(Buffer, BootVarComponents[BootVarOsLoadOptions][j]);
                    }
                    BootVarValues[BootVarOsLoadOptions] = DupString(Buffer);
    
                    fFixedExisting = TRUE;
                    break;
                }
            }
        }
    }

    if ( !fRemovedAtLeastOneEntry && (Modification == eRemoveBootOption) )
    {
        // No changes necessary
        return FALSE;
    }

    // Use the part corresponding to the boot marker as the default value for any component and store the start option for later writing
    pstrNewStartOption = DupString(pszStartOptions);    

    return TRUE;
}

/*****************************************************************************

Routine Description:

    This writes all the boot-related NVRAM variables back to the NVRAM
    space.

Arguments:

    fWriteOriginal - if TRUE, it attempts to write original NVRAM vars 
                                unaltered;
                     if FALSE, it attempst to write the new NVRAM vars

Return Value:

    TRUE, if all the boot-related NVRAM vars are written back successfully
    FALSE, otherwise.

*****************************************************************************/

BOOL FWriteNVRAMVars(BOOL fWriteOriginal) 
{
    // set new system partition
    wsprintf(Buffer, L"%s;%s", BootVarValues[BootVarSystemPartition], BootVarComponents[BootVarSystemPartition][bootMarker]);
    if (!SetNvRamVar(BootVarNames[BootVarSystemPartition], (fWriteOriginal || fFixedExisting)? BootVarValues[BootVarSystemPartition] : Buffer))
        return FALSE;

    // set new os loader
    wsprintf(Buffer, L"%s;%s", BootVarValues[BootVarOsLoader], BootVarComponents[BootVarOsLoader][bootMarker]);
    if (!SetNvRamVar(BootVarNames[BootVarOsLoader], (fWriteOriginal || fFixedExisting)? BootVarValues[BootVarOsLoader] : Buffer))
        return FALSE;

    // set new Load Partition
    wsprintf(Buffer, L"%s;%s", BootVarValues[BootVarOsLoadPartition], pstrArcPath);
    if (!SetNvRamVar(BootVarNames[BootVarOsLoadPartition], (fWriteOriginal || fFixedExisting)? BootVarValues[BootVarOsLoadPartition] : Buffer))
        return FALSE;

    // set new Load File Name
    wsprintf(Buffer, L"%s;%s", BootVarValues[BootVarOsLoadFilename], pstrLoadFilePath);
    if (!SetNvRamVar(BootVarNames[BootVarOsLoadFilename], (fWriteOriginal || fFixedExisting)? BootVarValues[BootVarOsLoadFilename] : Buffer))
        return FALSE;

    // set new Load Identifier
    wsprintf(Buffer, L"%s;%s", BootVarValues[BootVarLoadIdentifier], DISPLAY_STRING_DS_REPAIR);
    if (!SetNvRamVar(BootVarNames[BootVarLoadIdentifier], (fWriteOriginal || fFixedExisting)? BootVarValues[BootVarLoadIdentifier] : Buffer))
        return FALSE;

    // set new Load Option
    wsprintf(Buffer, L"%s;%s", BootVarValues[BootVarOsLoadOptions], pstrNewStartOption);
    if (!SetNvRamVar(BootVarNames[BootVarOsLoadOptions], (fWriteOriginal || fFixedExisting)? BootVarValues[BootVarOsLoadOptions] : Buffer))
        return FALSE;

    return TRUE;
}

BOOL
FRemoveLoadEntries(
    VOID
    )
/*++

Description:

    This routine copies all of the boot entries from the original buffers into 
    new buffers except for the entries marked as "don't keep" from the
    SaveEntry[] array.

Parameters:

    None

Return Values:

    TRUE is successful.

--*/
{

    ULONG iComponent, iBootVar, Size;

    for ( iBootVar = 0 ; iBootVar < BootVarMax; iBootVar++ )
    {
        Size = 0;

        for ( iComponent = 0; iComponent < BootVarComponentCount[iBootVar]; iComponent++ )
        {
            // +1 for the ";"
            Size += (wcslen(BootVarComponents[iBootVar][iComponent]) + 1) * sizeof(WCHAR);
        }

        // +1 for the null terminator
        Size += 1;

        NewBootVarValues[ iBootVar ] = (PWSTR) MALLOC( Size );
        if ( !NewBootVarValues[ iBootVar ] )
        {
            return FALSE;
        }

    }

    for ( iComponent = 0; iComponent < LargestComponentCount; iComponent++ )
    {
        if ( SaveEntry[ iComponent ] )
        {           
            for ( iBootVar = 0 ; iBootVar < BootVarMax; iBootVar++ )
            {
                if ( iComponent < BootVarComponentCount[iBootVar] )
                {
                    if ( iComponent > 0 )
                    {
                        wcscat( NewBootVarValues[iBootVar], L";" );
                    }

                    if ( BootVarComponents[iBootVar][iComponent] )
                    {
                        wcscat( NewBootVarValues[iBootVar], BootVarComponents[iBootVar][iComponent] );
                    }
                }
            }
        }
    }

    return TRUE;
}

BOOL
FWriteSmallerNVRAMVars(
    BOOL fWriteOriginal
    )
/*++

Description:

Parameters:

Return Values:

--*/
{
    ULONG iBootVar;
    int Status;

    for ( iBootVar = 0 ; iBootVar < BootVarMax; iBootVar++ )
    {
        Status = SetNvRamVar( BootVarNames[ iBootVar ],
                                (fWriteOriginal) ? BootVarValues[ iBootVar ] 
                                    : NewBootVarValues[ iBootVar ] );

        if ( !Status )
        {
            return FALSE;
        }
    }

    return TRUE;
}

/*****************************************************************************

Routine Description:

    This writes attempts to write the modified boot variables to 
    NVRAM space. If the attempt failed, it attempts write the original
    boot variables back to NVRAM space. Puts out an appropriate error
    message box on failure.

Arguments:

    None.

Return Value:

    None.
*****************************************************************************/

VOID WriteBackNVRAMForNonIntel( NTDS_BOOTOPT_MODTYPE Modification )
{

    if ( Modification == eRemoveBootOption )
    {

        //
        // Create new (smaller) buffers
        //
        if ( FRemoveLoadEntries() )
        {
            // First attempt to write the modified NVRAM vars
            if (!FWriteSmallerNVRAMVars(FALSE))
            {
                // Writing to NVRAM failed - attempt to write the original NVRAM back
                if (!FWriteSmallerNVRAMVars(TRUE))
                {

                    KdPrint(("NTDSETUP: Unable to add a Directory Service Repair boot option to NVRAM - \
                            Final entry in the boot list might be invalid!\n")); 
                }
                else
                {
                    // Unable to modify NVRAM - but old NVRAM is reverted back
                    KdPrint(("NTDSETUP: Unable to remove a Directory Service Repair boot option to NVRAM\n"));
                }
            }
        }
        else
        {
            KdPrint(("NTDSETUP: Unable to remove the Directory Service Repair boot option to NVRAM\n" ));
        }

    }
    else
    {
        ASSERT( Modification == eAddBootOption );

        // First attempt to write the modified NVRAM vars
        if (!FWriteNVRAMVars(FALSE))
        {
            // Writing to NVRAM failed - attempt to write the original NVRAM back
            if (!FWriteNVRAMVars(TRUE))
            {
                KdPrint(("NTDSETUP: Unable to add a Directory Service Repair boot option to NVRAM - \
                        Final entry in the boot list might be invalid!\n")); 
            }
            else
            {
                // Unable to modify NVRAM - but old NVRAM is reverted back
                KdPrint(("NTDSETUP: Unable to add a Directory Service Repair boot option to NVRAM\n"));
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\clntutl\inc\helper.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       helper.h
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    File        : helper.h
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 9/17/1996
*    Description : common declarations
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef HELPER_H
#define HELPER_H

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#endif


#ifdef __cplusplus
extern "C" {
#endif
// include //
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}
#endif

#include <windows.h>
#include <string.h>
#include <assert.h>
#include <stdio.h>
#include <tchar.h>
// #include <crtdbg.h>


// defines //
// convinience
/**
#ifndef SZ
#define SZ x  PCHAR x[]
#endif
**/
#ifndef _T
#define _T(x)  _TEXT(x)
#endif


// defaults
#define MAXSTR			   1024
#define MAXLIST            256
#define MAX_TINY_LIST      32


//
// Debugging flags
//

#define DBG_0			         0x0         // no debug
#define DBG_MEM   	             0x00000001
#define DBG_FLOW		         0x00000002
#define DBG_ERROR                0x00000004
#define DBG_WARN                 0x00000008
#define DBG_ALWAYS	             0xffffffff  // always out






// prototypes //

#ifdef __cplusplus
extern "C" {
#endif
// global variables //
extern DWORD g_dwDebugLevel;    // debug print level



extern void dprintf(DWORD dwLevel, LPCTSTR lpszFormat, ...);
extern void fatal(LPCTSTR msg);


#ifdef __cplusplus
}
#endif


#endif

/******************* EOF *********************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\aclguids\guidcache.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       guidcache.h
//
//--------------------------------------------------------------------------

//
// This is a generated file. Use aclguids to generate this file.
//

{"msWMI-WMIGPO",                            {0x05630000,0x3927,0x4ede,0xbf,0x27,0xca,0x91,0xf2,0x75,0xc2,0x6f}, 2},
{"aNR",                                     {0x45b01500,0xc419,0x11d1,0xbb,0xc9,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msExchMailStorage",                       {0x03652000,0xa981,0x11d2,0xa9,0xff,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"Receive Message",                         {0x06bd3200,0xdf3e,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"Account Restrictions",                    {0x4c164200,0x20c0,0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29}, 1},
{"Check Stale Phantoms",                    {0x69ae6200,0x7f46,0x11d2,0xb9,0xad,0x00,0xc0,0x4f,0x79,0xf8,0x05}, 1},
{"formData",                                {0xa8df7400,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"primaryGroupID",                          {0xbf967a00,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"shortServerName",                         {0x45b01501,0xc419,0x11d1,0xbb,0xc9,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"Peek Message",                            {0x06bd3201,0xdf3e,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"priorSetTime",                            {0xbf967a01,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Send Message",                            {0x06bd3202,0xdf3e,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"msDS-Site-Affinity",                      {0xc17c5602,0xbcb7,0x46f0,0x96,0x56,0x63,0x70,0xca,0x88,0x4b,0x72}, 2},
{"msExchServer2AlwaysCreateAs",             {0x25f95802,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"priorValue",                              {0xbf967a02,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"proxiedObjectName",                       {0xe1aea402,0xcd5b,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Receive Journal",                         {0x06bd3203,0xdf3e,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"privateKey",                              {0xbf967a03,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"queryPolicyObject",                       {0xe1aea403,0xcd5b,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-ID",                                {0x9339a803,0x94b8,0x47f7,0x91,0x23,0xa8,0x53,0xb9,0xff,0x7e,0x45}, 2},
{"lastLogonTimestamp",                      {0xc0e20a04,0x0e5a,0x4ff3,0x94,0x82,0x5e,0xfe,0xae,0xcd,0x70,0x60}, 2},
{"generationQualifier",                     {0x16775804,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"groupsToIgnore",                          {0xeea65904,0x8ac6,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mS-SQL-SPX",                              {0x86b08004,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"aCSResourceLimits",                       {0x2e899b04,0x2834,0x11d3,0x91,0xd4,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"queryPolicyBL",                           {0xe1aea404,0xcd5b,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"groupPriority",                           {0xeea65905,0x8ac6,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"hideDLMembership",                        {0xa8df7405,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"profilePath",                             {0xbf967a05,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msExchExpansionServerName",               {0xa1241706,0xb093,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"desktopProfile",                          {0xeea65906,0x8ac6,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"proxyAddresses",                          {0xbf967a06,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"pKICriticalExtensions",                   {0xfc5a9106,0x3b9d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"houseIdentifier",                         {0xa8df7407,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"proxyLifetime",                           {0xbf967a07,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-Cached-Membership",                  {0x69cab008,0xcdd4,0x4bc9,0xba,0xb8,0x0f,0xf3,0x7e,0xfe,0x1b,0x20}, 2},
{"pwdHistoryLength",                        {0xbf967a09,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"addressTemplate",                         {0x5fd4250a,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"pwdLastSet",                              {0xbf967a0a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-Preferred-GC-Site",                  {0xd921b50a,0x0ab2,0x42cd,0x87,0xf6,0x09,0xcf,0x83,0xa9,0x18,0x54}, 2},
{"applicationProcess",                      {0x5fd4250b,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"pwdProperties",                           {0xbf967a0b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msExchRemotePrivateISList",               {0x1e29030c,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"aCSMaxAggregatePeakRatePerUser",          {0xf072230c,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"displayTemplate",                         {0x5fd4250c,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"rangeLower",                              {0xbf967a0c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msExchServer1DeletionOption",             {0x22edb70c,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"altSecurityIdentities",                   {0x00fbf30c,0x91fe,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"aCSNonReservedTxSize",                    {0xf072230d,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rangeUpper",                              {0xbf967a0d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"isCriticalSystemObject",                  {0x00fbf30d,0x91fe,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"aCSEnableRSVPAccounting",                 {0xf072230e,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-GPSHeight",                        {0xbcdd4f0e,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"name",                                    {0xbf967a0e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msPKI-OID-CPS",                           {0x5f49940e,0xa79f,0x4a51,0xbb,0x6f,0x3d,0x44,0x6a,0x54,0xdc,0x6b}, 2},
{"mS-SQL-GPSLatitude",                      {0xb222ba0e,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msExchHomeServerName",                    {0xa284f30e,0xb093,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"showInAddressBook",                       {0x3e74f60e,0x3e73,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"aCSRSVPAccountFilesLocation",             {0xf072230f,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rDNAttID",                                {0xbf967a0f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"addressBookContainer",                    {0x3e74f60f,0x3e73,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msExchCASchemaPolicy",                    {0x948f0e10,0xb093,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"Logon Information",                       {0x5f202010,0x79a5,0x11d0,0x90,0x20,0x00,0xc0,0x4f,0xc2,0xd4,0xcf}, 1},
{"aCSMaxNoOfAccountFiles",                  {0xf0722310,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"registeredAddress",                       {0xbf967a10,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-InformationURL",                   {0xa42cd510,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"aCSMaxSizeOfRSVPAccountFile",             {0xf0722311,0xaef5,0x11d1,0xbd,0xcf,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"foreignSecurityPrincipal",                {0x89e31c12,0x8530,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"remoteServerName",                        {0xbf967a12,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"upgradeProductCode",                      {0xd9e18312,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQQueueQuota",                          {0x3f6b8e12,0xd57f,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"msWMI-PolicyType",                        {0x595b2613,0x4109,0x4e77,0x90,0x13,0xa3,0xbb,0x4e,0xf2,0x77,0xc7}, 2},
{"msiScript",                               {0xd9e18313,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dSUISettings",                            {0x09b10f14,0x6f93,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msWMI-MergeablePolicyTemplate",           {0x07502414,0xfdca,0x4851,0xb0,0x4a,0x13,0x64,0x5b,0x11,0xd2,0x26}, 2},
{"remoteSource",                            {0xbf967a14,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"canUpgradeScript",                        {0xd9e18314,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msExchRemoteServerList",                  {0x1e58b214,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"accountExpires",                          {0xbf967915,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"remoteSourceType",                        {0xbf967a15,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"fileExtPriority",                         {0xd9e18315,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msDS-NC-Replica-Locations",               {0x97de9615,0xb537,0x46bc,0xac,0x0f,0x10,0x72,0x0f,0x39,0x09,0xf3}, 2},
{"Open Address List",                       {0xa1990816,0x4298,0x11d1,0xad,0xe2,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"defaultHidingValue",                      {0xb7b13116,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msExchServer2HighestUSN",                 {0x283a5116,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"activationSchedule",                      {0xbf967916,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"replUpToDateVector",                      {0xbf967a16,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"localizedDescription",                    {0xd9e18316,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"objectCount",                             {0x34aaa216,0xb699,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"flatName",                                {0xb7b13117,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"aCSNonReservedMinPolicedSize",            {0xb6873917,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"msMQ-Custom-Recipient",                   {0x876d6817,0x35cc,0x436c,0xac,0xea,0x5e,0xf7,0x17,0x4d,0xd9,0xbe}, 2},
{"activationStyle",                         {0xbf967917,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"productCode",                             {0xd9e18317,0x8939,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"volumeCount",                             {0x34aaa217,0xb699,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"ipsecPolicyReference",                    {0xb7b13118,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"adminCount",                              {0xbf967918,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"replicaSource",                           {0xbf967a18,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"nonSecurityMember",                       {0x52458018,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"physicalLocationObject",                  {0xb7b13119,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"adminDescription",                        {0xbf967919,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"nonSecurityMemberBL",                     {0x52458019,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-OLAPDatabase",                     {0x20af031a,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"adminDisplayName",                        {0xbf96791a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"fRSReplicaSetGUID",                       {0x5245801a,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"replInterval",                            {0x45ba9d1a,0x56fa,0x11d2,0x90,0xd0,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"replicationSensitivity",                  {0xbf967a1b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"parentCA",                                {0x5245801b,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msExchServer1Flags",                      {0x234d151c,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"msExchServer2Type",                       {0x2a74231c,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"serviceBindingInformation",               {0xb7b1311c,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"directReports",                           {0xbf967a1c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rightsGuid",                              {0x8297931c,0x86d3,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"terminalServer",                          {0x6db69a1c,0x9422,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msExchServer2DeletionOption",             {0x26e09c1c,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"assistant",                               {0x0296c11c,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"ipsecName",                               {0xb40ff81c,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"serviceClassName",                        {0xb7b1311d,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"internetEncoding",                        {0x1677581d,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"repsFrom",                                {0xbf967a1d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"superiorDNSRoot",                         {0x5245801d,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"appliesTo",                               {0x8297931d,0x86d3,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"tokenGroupsGlobalAndUniversal",           {0x46a9b11d,0x60ae,0x405a,0xb7,0xe8,0xff,0x8a,0x58,0xd4,0x56,0xd2}, 2},
{"otherFacsimileTelephoneNumber",           {0x0296c11d,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"ipsecID",                                 {0xb40ff81d,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"groupType",                               {0x9a9a021e,0x4a5b,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-TargetType",                        {0xca2a281e,0x262b,0x4ff7,0xb4,0x19,0xbc,0x12,0x33,0x52,0xa4,0xe9}, 2},
{"msTAPI-ConferenceBlob",                   {0x4cc4601e,0x7201,0x4141,0xab,0xc8,0x3e,0x52,0x9a,0xe8,0x88,0x63}, 2},
{"altRecipient",                            {0xbf96791e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"repsTo",                                  {0xbf967a1e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"fRSLevelLimit",                           {0x5245801e,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"foreignIdentifier",                       {0x3e97891e,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"controlAccessRight",                      {0x8297931e,0x86d3,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"otherMobile",                             {0x0296c11e,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"ipsecDataType",                           {0xb40ff81e,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"userSharedFolder",                        {0x9a9a021f,0x4a5b,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"knowledgeInformation",                    {0x1677581f,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSRootSecurity",                         {0x5245801f,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"nTMixedDomain",                           {0x3e97891f,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msWMI-TargetNameSpace",                   {0x1c4ab61f,0x3420,0x44e5,0x84,0x9d,0x8b,0x5d,0xbf,0x60,0xfe,0xb7}, 2},
{"msDS-Cached-Membership-Time-Stamp",       {0x3566bf1f,0xbeee,0x4dcb,0x8a,0xbe,0xef,0x89,0xfc,0xfe,0xc6,0xc1}, 2},
{"primaryInternationalISDNNumber",          {0x0296c11f,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"ipsecData",                               {0xb40ff81f,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"userSharedFolderOther",                   {0x9a9a0220,0x4a5b,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"labeledURI",                              {0x16775820,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSExtensions",                           {0x52458020,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootInitialization",                   {0x3e978920,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"managedBy",                               {0x0296c120,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQQueueType",                           {0x9a0dc320,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"Refresh Group Cache for Logons",          {0x9432c620,0x033c,0x4db7,0x8b,0x58,0x14,0xef,0x6d,0x0b,0xf4,0x77}, 1},
{"ipsecISAKMPReference",                    {0xb40ff820,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"url",                                     {0x9a9a0221,0x4a5b,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"ipsecPolicy",                             {0xb7b13121,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"language",                                {0x16775821,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"revision",                                {0xbf967a21,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"dynamicLDAPServer",                       {0x52458021,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootGUID",                             {0x3e978921,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"primaryTelexNumber",                      {0x0296c121,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQJournal",                             {0x9a0dc321,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ipsecNFAReference",                       {0xb40ff821,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"classDisplayName",                        {0x548e1c22,0xdea6,0x11d0,0xb0,0x10,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"physicalLocation",                        {0xb7b13122,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"attributeID",                             {0xbf967922,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rid",                                     {0xbf967a22,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"prefixMap",                               {0x52458022,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msPKI-RA-Policies",                       {0xd546ae22,0x0951,0x4d47,0x81,0x7e,0x1c,0x9f,0x96,0xfa,0xad,0x46}, 2},
{"mhsORAddress",                            {0x0296c122,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQQuota",                               {0x9a0dc322,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ipsecNegotiationPolicyReference",         {0xb40ff822,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"serviceAdministrationPoint",              {0xb7b13123,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"schemaIDGUID",                            {0xbf967923,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rpcNsBindings",                           {0xbf967a23,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"initialAuthIncoming",                     {0x52458023,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootMachineFilePath",                  {0x3e978923,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"otherMailbox",                            {0x0296c123,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQBasePriority",                        {0x9a0dc323,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ipsecFilterReference",                    {0xb40ff823,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"schedule",                                {0xdd712224,0x10e4,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"subnet",                                  {0xb7b13124,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"attributeSecurityGUID",                   {0xbf967924,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rpcNsGroup",                              {0xbf967a24,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"initialAuthOutgoing",                     {0x52458024,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"siteGUID",                                {0x3e978924,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"managedObjects",                          {0x0296c124,0x40da,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQJournalQuota",                        {0x9a0dc324,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ipsecOwnersReference",                    {0xb40ff824,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"subnetContainer",                         {0xb7b13125,0xb82e,0x11d0,0xaf,0xee,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"attributeSyntax",                         {0xbf967925,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rpcNsInterfaceID",                        {0xbf967a25,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"operatingSystem",                         {0x3e978925,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQLabelEx",                             {0x4580ad25,0xd407,0x48d2,0xad,0x24,0x43,0xe6,0xe5,0x67,0x93,0xd7}, 2},
{"mSMQLabel",                               {0x9a0dc325,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ipsecBase",                               {0xb40ff825,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"queryFilter",                             {0xcbf70a26,0x7e78,0x11d2,0x99,0x21,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"applicationName",                         {0xdd712226,0x10e4,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"operatingSystemVersion",                  {0x3e978926,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQAuthenticate",                        {0x9a0dc326,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ipsecFilter",                             {0xb40ff826,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rpcNsPriority",                           {0xbf967a27,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"operatingSystemServicePack",              {0x3e978927,0x8c01,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQPrivacyLevel",                        {0x9a0dc327,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ipsecNegotiationPolicy",                  {0xb40ff827,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"authenticationOptions",                   {0xbf967928,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rpcNsProfileEntry",                       {0xbf967a28,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"publicKeyPolicy",                         {0x80a67e28,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQOwnerID",                             {0x9a0dc328,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ipsecISAKMPPolicy",                       {0xb40ff828,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fileLinkTracking",                        {0xdd712229,0x10e4,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"autoReply",                               {0xbf967929,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"domainWidePolicy",                        {0x80a67e29,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQTransactional",                       {0x9a0dc329,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ipsecNFA",                                {0xb40ff829,0x427a,0x11d1,0xa9,0xc2,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"autoReplyMessage",                        {0xbf96792a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"domainPolicyReference",                   {0x80a67e2a,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"Add/Remove Replica In Domain",            {0x9923a32a,0x3607,0x11d2,0xb9,0xbe,0x00,0x00,0xf8,0x7a,0x36,0xb2}, 1},
{"mSMQSites",                               {0x9a0dc32a,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"replicationSignature",                    {0x9909d92a,0xb093,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"schemaFlagsEx",                           {0xbf967a2b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQOutRoutingServers",                   {0x9a0dc32b,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msWMI-IntMax",                            {0xfb920c2c,0xf294,0x4426,0x8a,0xc1,0xd2,0x4b,0x42,0xaa,0x2b,0xce}, 2},
{"msExchActiveDirectoryConnector",          {0xe605672c,0xa980,0x11d2,0xa9,0xff,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"auxiliaryClass",                          {0xbf96792c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"schemaVersion",                           {0xbf967a2c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQInRoutingServers",                    {0x9a0dc32c,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"badPasswordTime",                         {0xbf96792d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"searchFlags",                             {0xbf967a2d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQServiceType",                         {0x9a0dc32d,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msWMI-CreationDate",                      {0x748b0a2e,0x3351,0x4b3f,0xb1,0x71,0x2f,0x17,0x41,0x4e,0xa7,0x79}, 2},
{"badPwdCount",                             {0xbf96792e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"searchGuide",                             {0xbf967a2e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQComputerType",                        {0x9a0dc32e,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"mS-SQL-InformationDirectory",             {0xd0aedb2e,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"builtinCreationTime",                     {0xbf96792f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"securityIdentifier",                      {0xbf967a2f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQForeign",                             {0x9a0dc32f,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"Open Connector Queue",                    {0xb4e60130,0xdf3f,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"msExchADCOptions",                        {0x90891630,0xb093,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"defaultSecurityDescriptor",               {0x807a6d30,0x1669,0x11d0,0xa0,0x64,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"builtinModifiedCount",                    {0xbf967930,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"securityProtocol",                        {0xbf967a30,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQOSType",                              {0x9a0dc330,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"cRLPartitionedRevocationList",            {0x963d2731,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"businessCategory",                        {0xbf967931,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"seeAlso",                                 {0xbf967a31,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-StringValidValues",                 {0x37609d31,0xa2bf,0x4b58,0x8f,0x53,0x2b,0x64,0xe5,0x7a,0x07,0x6d}, 2},
{"mSMQEncryptKey",                          {0x9a0dc331,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msWMI-UintSetParam",                      {0x8f4beb31,0x4e19,0x46f5,0x93,0x2e,0x5f,0xa0,0x3c,0x33,0x9b,0x1d}, 2},
{"mS-DS-CreatorSID",                        {0xc5e60132,0x1480,0x11d3,0x91,0xc1,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"certificateAuthorityObject",              {0x963d2732,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"cACertificate",                           {0xbf967932,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"serialNumber",                            {0xbf967a32,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQUserSid",                             {0xc58aae32,0x56f9,0x11d2,0x90,0xd0,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"mSMQSignKey",                             {0x9a0dc332,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"parentCACertificateChain",                {0x963d2733,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"serverRole",                              {0xbf967a33,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQNameStyle",                           {0x9a0dc333,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"domainID",                                {0x963d2734,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"serverState",                             {0xbf967a34,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQCSPName",                             {0x9a0dc334,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"cAConnect",                               {0x963d2735,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"serviceClassID",                          {0xbf967a35,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msTAPI-RtConference",                     {0xca7b9735,0x4b2a,0x4e49,0x89,0xc3,0x99,0x02,0x53,0x34,0xdc,0x94}, 2},
{"mSMQLongLived",                           {0x9a0dc335,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"cAWEBURL",                                {0x963d2736,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Change Rid Master",                       {0xd58d5f36,0x0a98,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"serviceClassInfo",                        {0xbf967a36,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-intFlags3",                         {0xf29fa736,0xde09,0x4be4,0xb2,0x3a,0xe7,0x34,0xc1,0x24,0xba,0xcc}, 2},
{"msDS-User-Account-Control-Computed",      {0x2cc4b836,0xb63f,0x4940,0x8d,0x23,0xea,0x7a,0xcf,0x06,0xaf,0x56}, 2},
{"mSMQVersion",                             {0x9a0dc336,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"cRLObject",                               {0x963d2737,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msiScriptPath",                           {0xbf967937,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"serviceInstanceVersion",                  {0xbf967a37,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQSite1",                               {0x9a0dc337,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"cAUsages",                                {0x963d2738,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"codePage",                                {0xbf967938,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"adminPropertyPages",                      {0x52458038,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"primaryGroupToken",                       {0xc0ed8738,0x7efd,0x4481,0x84,0xd9,0x66,0xd2,0xdb,0x8b,0xe3,0x69}, 2},
{"mSMQSite2",                               {0x9a0dc338,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"adminContextMenu",                        {0x553fd038,0xf32e,0x11d0,0xb0,0xbc,0x00,0xc0,0x4f,0xd8,0xdc,0xa6}, 2},
{"msPKI-Key-Recovery-Agent",                {0x26ccf238,0xa08e,0x4b86,0x9a,0x82,0xa8,0xc9,0xac,0x7e,0xe5,0xcb}, 2},
{"mS-SQL-MultiProtocol",                    {0x8157fa38,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"previousCACertificates",                  {0x963d2739,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"st",                                      {0xbf967a39,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"shellPropertyPages",                      {0x52458039,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQSiteGates",                           {0x9a0dc339,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"shellContextMenu",                        {0x553fd039,0xf32e,0x11d0,0xb0,0xbc,0x00,0xc0,0x4f,0xd8,0xdc,0xa6}, 2},
{"dhcpUniqueKey",                           {0x963d273a,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-Genus",                             {0x50c8673a,0x8f56,0x4614,0x93,0x08,0x9e,0x13,0x40,0xfb,0x9a,0xf3}, 2},
{"street",                                  {0xbf967a3a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"nTFRSReplicaSet",                         {0x5245803a,0xca6a,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQCost",                                {0x9a0dc33a,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msExchConnectionAgreement",               {0xee64c93a,0xa980,0x11d2,0xa9,0xff,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"dhcpType",                                {0x963d273b,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"cOMClassID",                              {0xbf96793b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"subClassOf",                              {0xbf967a3b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQSignCertificates",                    {0x9a0dc33b,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"operatingSystemHotfix",                   {0xbd951b3c,0x9c96,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"pendingCACertificates",                   {0x963d273c,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-Description",                      {0x8386603c,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"cOMInterfaceID",                          {0xbf96793c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"subRefs",                                 {0xbf967a3c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQDigests",                             {0x9a0dc33c,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"previousParentCA",                        {0x963d273d,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"cOMProgID",                               {0xbf96793d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQServices",                            {0x9a0dc33d,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"pendingParentCA",                         {0x963d273e,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-ServiceAccount",                   {0x64933a3e,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msDS-App-Configuration",                  {0x90df3c3e,0x1854,0x4455,0xa5,0xd7,0xca,0xd4,0x0d,0x56,0x65,0x7a}, 2},
{"info",                                    {0xbf96793e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"submissionContLength",                    {0xbf967a3e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQQMID",                                {0x9a0dc33e,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msWMI-Query",                             {0x65fff93e,0x35e3,0x45a3,0x85,0xae,0x87,0x6c,0x67,0x18,0x29,0x7f}, 2},
{"currentParentCA",                         {0x963d273f,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"cn",                                      {0xbf96793f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"supplementalCredentials",                 {0xbf967a3f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"aCSNonReservedPeakRate",                  {0xa331a73f,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"mSMQMigrated",                            {0x9a0dc33f,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"cACertificateDN",                         {0x963d2740,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"nameServiceFlags",                        {0x80212840,0x4bdc,0x11d1,0xa9,0xc4,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"oOFReplyToOriginator",                    {0xa8df7440,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"Group Membership",                        {0xbc0ac240,0x79a9,0x11d0,0x90,0x20,0x00,0xc0,0x4f,0xc2,0xd4,0xcf}, 1},
{"mSMQSiteID",                              {0x9a0dc340,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"mS-SQL-NamedPipe",                        {0x7b91c840,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"allowedAttributes",                       {0x9a7ad940,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"dhcpFlags",                               {0x963d2741,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rpcNsEntryFlags",                         {0x80212841,0x4bdc,0x11d1,0xa9,0xc4,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"sn",                                      {0xbf967a41,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"allowedAttributesEffective",              {0x9a7ad941,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"notes",                                   {0x6d05fb41,0x246b,0x11d0,0xa9,0xc8,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"dhcpIdentification",                      {0x963d2742,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rpcContainer",                            {0x80212842,0x4bdc,0x11d1,0xa9,0xc4,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"General Information",                     {0x59ba2f42,0x79a2,0x11d0,0x90,0x20,0x00,0xc0,0x4f,0xc2,0xd3,0xcf}, 1},
{"msExchServer1LastUpdateTime",             {0x23e34942,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"allowedChildClasses",                     {0x9a7ad942,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"dhcpObjName",                             {0x963d2743,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msDS-Security-Descriptor-Reference-Domain",{0xa48f4343,0x256e,0x4394,0x91,0x2a,0x65,0x6d,0xa9,0x55,0x9c,0x4b}, 2},
{"contentIndexingAllowed",                  {0xbf967943,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"systemAuxiliaryClass",                    {0xbf967a43,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQQueue",                               {0x9a0dc343,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msDS-Approx-Immed-Subordinates",          {0xe185d243,0xf6ce,0x4adb,0xb4,0x96,0xb0,0xc0,0x05,0xd7,0x82,0x3c}, 2},
{"allowedChildClassesEffective",            {0x9a7ad943,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"dhcpObjDescription",                      {0x963d2744,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"cost",                                    {0xbf967944,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"systemMayContain",                        {0xbf967a44,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-Location",                         {0x561c9644,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"mSMQConfiguration",                       {0x9a0dc344,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"attributeTypes",                          {0x9a7ad944,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"dhcpServers",                             {0x963d2745,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"c",                                       {0xbf967945,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"systemMustContain",                       {0xbf967a45,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQEnterpriseSettings",                  {0x9a0dc345,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"canonicalName",                           {0x9a7ad945,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msPKI-Certificate-Policy",                {0x38942346,0xcc5b,0x424b,0xa7,0xd8,0x6f,0xfd,0x12,0x02,0x9c,0x5f}, 2},
{"dhcpSubnets",                             {0x963d2746,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"extraColumns",                            {0xd24e2846,0x1dd9,0x4bcf,0x99,0xd7,0xa6,0x22,0x7c,0xc8,0x6d,0xa7}, 2},
{"creationTime",                            {0xbf967946,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"systemOnly",                              {0xbf967a46,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQSiteLink",                            {0x9a0dc346,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"dITContentRules",                         {0x9a7ad946,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"dhcpMask",                                {0x963d2747,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"currentValue",                            {0xbf967947,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"systemPossSuperiors",                     {0xbf967a47,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"dNSHostName",                             {0x72e39547,0x7b18,0x11d1,0xad,0xef,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 2},
{"Validated write to DNS host name",        {0x72e39547,0x7b18,0x11d1,0xad,0xef,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"msWMI-Int8Max",                           {0xe3d8b547,0x003d,0x4946,0xa3,0x2b,0xdc,0x7c,0xed,0xc9,0x6b,0x74}, 2},
{"mSMQSettings",                            {0x9a0dc347,0xc100,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"extendedAttributeInfo",                   {0x9a7ad947,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msPKI-Certificate-Application-Policy",    {0xdbd90548,0xaa37,0x4202,0x99,0x66,0x8c,0x53,0x7b,0xa5,0xce,0x32}, 2},
{"rpcNsObjectID",                           {0x29401c48,0x7a27,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"dhcpRanges",                              {0x963d2748,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"objectVersion",                           {0x16775848,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msMQ-Recipient-FormatName",               {0x3bfe6748,0xb544,0x485a,0xb0,0x67,0x1b,0x31,0x0c,0x43,0x34,0xbf}, 2},
{"addressBookRoots",                        {0xf70b6e48,0x06f4,0x11d2,0xaa,0x53,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"defaultClassStore",                       {0xbf967948,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"globalAddressList",                       {0xf754c748,0x06f4,0x11d2,0xaa,0x53,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"extendedClassInfo",                       {0x9a7ad948,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"dynamicObject",                           {0x66d51249,0x3355,0x4c1f,0xb2,0x4e,0x81,0xf2,0x52,0xac,0xa2,0x3b}, 2},
{"dhcpSites",                               {0x963d2749,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"telephoneNumber",                         {0xbf967a49,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"fromEntry",                               {0x9a7ad949,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"rpcNsTransferSyntax",                     {0x29401c4a,0x7a27,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"dhcpReservations",                        {0x963d274a,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-SQLDatabase",                      {0x1d08694a,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"ipPhone",                                 {0x4d146e4a,0x48d4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"delivContLength",                         {0xbf96794a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"teletexTerminalIdentifier",               {0xbf967a4a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-AllowAnonymousSubscription",       {0xdb77be4a,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"modifyTimeStamp",                         {0x9a7ad94a,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msExchServer1NetworkAddress",             {0x2412f84a,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"superScopes",                             {0x963d274b,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"otherIpPhone",                            {0x4d146e4b,0x48d4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"presentationAddress",                     {0xa8df744b,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"telexNumber",                             {0xbf967a4b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"dSCorePropagationData",                   {0xd167aa4b,0x8b08,0x11d2,0x99,0x39,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"objectClasses",                           {0x9a7ad94b,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msPKI-RA-Signature",                      {0xfe17e04b,0x937d,0x4f7e,0x8e,0x0e,0x92,0x92,0xc8,0xd5,0x68,0x3e}, 2},
{"superScopeDescription",                   {0x963d274c,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"siteObject",                              {0x3e10944c,0xc354,0x11d0,0xaf,0xf8,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"possibleInferiors",                       {0x9a7ad94c,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msExchNTAccountOptions",                  {0x14ebe64c,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"msDS-Other-Settings",                     {0x79d2f34c,0x9d7d,0x42bb,0x83,0x8f,0x86,0x6b,0x3e,0x44,0x00,0xe2}, 2},
{"optionDescription",                       {0x963d274d,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msCOM-UserLink",                          {0x9e6f3a4d,0x242c,0x4f37,0xb0,0x68,0x36,0xb5,0x7f,0x9f,0xc8,0x52}, 2},
{"deliverAndRedirect",                      {0xbf96794d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"localPolicyReference",                    {0x80a67e4d,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"siteObjectBL",                            {0x3e10944d,0xc354,0x11d0,0xaf,0xf8,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"subSchemaSubEntry",                       {0x9a7ad94d,0xca53,0x11d1,0xbb,0xd0,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"optionsLocation",                         {0x963d274e,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Recalculate Hierarchy",                   {0x0bc1554e,0x0a99,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"qualityOfService",                        {0x80a67e4e,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"unmergedAtts",                            {0x9947d64e,0xb093,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"mS-SQL-SQLPublication",                   {0x17c2f64e,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"dhcpOptions",                             {0x963d274f,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"department",                              {0xbf96794f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"machineWidePolicy",                       {0x80a67e4f,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"applicationEntity",                       {0x3fdfee4f,0x47f4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dhcpClasses",                             {0x963d2750,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msExchServer1AuthenticationType",         {0x22b94350,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"purportedSearch",                         {0xb4b54e50,0x943a,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"description",                             {0xbf967950,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"thumbnailPhoto",                          {0x8d3bca50,0x1d7e,0x11d0,0xa0,0x81,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"certificationAuthority",                  {0x3fdfee50,0x47f4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mscopeId",                                {0x963d2751,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"destinationIndicator",                    {0xbf967951,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-ScopeGuid",                         {0x87b78d51,0x405f,0x4b7f,0x80,0xed,0x2b,0xd2,0x87,0x86,0xf4,0x8d}, 2},
{"msExchServer2AuthenticationType",         {0x26a50152,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"Domain Administer Server",                {0xab721a52,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b}, 1},
{"dhcpState",                               {0x963d2752,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQSiteGatesMig",                        {0xe2704852,0x3b7b,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"mSMQInterval2",                           {0x99b88f52,0x3b7b,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"lDAPAdminLimits",                         {0x7359a352,0x90f7,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dSA",                                     {0x3fdfee52,0x47f4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Change Password",                         {0xab721a53,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b}, 1},
{"dhcpProperties",                          {0x963d2753,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"options",                                 {0x19195a53,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"displayName",                             {0xbf967953,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"lDAPIPDenyList",                          {0x7359a353,0x90f7,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Public Information",                      {0xe48d0154,0xbcf8,0x11d1,0x87,0x02,0x00,0xc0,0x4f,0xb9,0x60,0x50}, 1},
{"Send As",                                 {0xab721a54,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b}, 1},
{"dhcpMaxKey",                              {0x963d2754,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-CreationDate",                     {0xede14754,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"mS-SQL-AllowKnownPullSubscription",       {0xc3bb7054,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"displayNamePrintable",                    {0xbf967954,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Send To",                                 {0xab721a55,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b}, 1},
{"dhcpUpdateTime",                          {0x963d2755,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dc",                                      {0x19195a55,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"title",                                   {0xbf967a55,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Receive As",                              {0xab721a56,0x1e2f,0x11d0,0x98,0x19,0x00,0xaa,0x00,0x40,0x52,0x9b}, 1},
{"dHCPClass",                               {0x963d2756,0x48be,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"notificationList",                        {0x19195a56,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msWMI-RangeParam",                        {0x45fb5a57,0x5018,0x4d0f,0x90,0x56,0x99,0x7c,0x8c,0x91,0x22,0xd9}, 2},
{"msDS-Behavior-Version",                   {0xd31a8757,0x2447,0x4545,0x80,0x81,0x3b,0xb6,0x10,0xca,0xcb,0xf2}, 2},
{"personalTitle",                           {0x16775858,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msExchConfigurationContainer",            {0xd03d6858,0x06f4,0x11d2,0xaa,0x53,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"mS-SQL-Publisher",                        {0xc1676858,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"mSMQNt4Flags",                            {0xeb38a158,0xd57f,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"dnsRoot",                                 {0xbf967959,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"trustAuthIncoming",                       {0xbf967a59,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-Int8Default",                       {0xf4d8085a,0x8c5b,0x4785,0x95,0x9b,0xdc,0x58,0x55,0x66,0xe4,0x45}, 2},
{"domain",                                  {0x19195a5a,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"trustAttributes",                         {0x80a67e5a,0x9f22,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"domainDNS",                               {0x19195a5b,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mS-SQL-SQLRepository",                    {0x11d43c5c,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"applicationSiteSettings",                 {0x19195a5c,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"trustDirection",                          {0xbf967a5c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msPKI-Enterprise-Oid",                    {0x37cfd85c,0x6719,0x4ad8,0x8f,0x9e,0x86,0x78,0xba,0x62,0x75,0x63}, 2},
{"otherWellKnownObjects",                   {0x1ea64e5d,0xac0f,0x11d2,0x90,0xdf,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"nTDSSiteSettings",                        {0x19195a5d,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"domainPolicyObject",                      {0xbf96795d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"trustPartner",                            {0xbf967a5d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"protocolSettings",                        {0x1677585e,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"reportToOriginator",                      {0xa8df745e,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"domainReplica",                           {0xbf96795e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"trustPosixOffset",                        {0xbf967a5e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msExchCorrelationAttribute",              {0x9c098e5e,0xb093,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"interSiteTopologyGenerator",              {0xb7c69e5e,0x2cc7,0x11d2,0x85,0x4e,0x00,0xa0,0xc9,0x83,0xf6,0x08}, 2},
{"nTDSService",                             {0x19195a5f,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"reportToOwner",                           {0xa8df745f,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"trustAuthOutgoing",                       {0xbf967a5f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-Class",                             {0x90c1925f,0x4a24,0x4b07,0xb2,0x02,0xbe,0x32,0xeb,0x3c,0x8b,0x74}, 2},
{"interSiteTopologyRenew",                  {0xb7c69e5f,0x2cc7,0x11d2,0x85,0x4e,0x00,0xa0,0xc9,0x83,0xf6,0x08}, 2},
{"nTDSConnection",                          {0x19195a60,0x6da0,0x11d0,0xaf,0xd3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"Domain Password & Lockout Policies",      {0xc7407360,0x20bf,0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29}, 1},
{"trustType",                               {0xbf967a60,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msExchChildSyncAgreements",               {0x9b309860,0xb093,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"interSiteTopologyFailover",               {0xb7c69e60,0x2cc7,0x11d2,0x85,0x4e,0x00,0xa0,0xc9,0x83,0xf6,0x08}, 2},
{"tombstoneLifetime",                       {0x16c3a860,0x1273,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"msExchServer2SSLPort",                    {0x2a3faf60,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"Update Schema Cache",                     {0xbe2bb760,0x7f46,0x11d2,0xb9,0xad,0x00,0xc0,0x4f,0x79,0xf8,0x05}, 1},
{"msExchServer1NTAccountDomain",            {0x2449ce60,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"addressEntryDisplayTable",                {0x5fd42461,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"subSchema",                               {0x5a8b3261,0xc38d,0x11d1,0xbb,0xc9,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"mail",                                    {0xbf967961,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"uASCompat",                               {0xbf967a61,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"systemFlags",                             {0xe0fa1e62,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msExchReplicateNow",                      {0x1eac2462,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"addressEntryDisplayTableMSDOS",           {0x5fd42462,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"employeeID",                              {0xbf967962,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msCOM-PartitionLink",                     {0x09abac62,0x043f,0x4702,0xac,0x2b,0x6c,0xa1,0x5e,0xee,0x57,0x54}, 2},
{"msiScriptName",                           {0x96a7dd62,0x9118,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"addressSyntax",                           {0x5fd42463,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"enabledConnection",                       {0xbf967963,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msiScriptSize",                           {0x96a7dd63,0x9118,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"addressType",                             {0x5fd42464,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"msExchAccessControlMap",                  {0x8ff54464,0xb093,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"uNCName",                                 {0xbf967a64,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"installUiLevel",                          {0x96a7dd64,0x9118,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dnsAllowDynamic",                         {0xe0fa1e65,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"roleOccupant",                            {0xa8df7465,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"expirationTime",                          {0xbf967965,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"appSchemaVersion",                        {0x96a7dd65,0x9118,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQQueueJournalQuota",                   {0x8e441266,0xd57f,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"dnsAllowXFR",                             {0xe0fa1e66,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"extendedCharsAllowed",                    {0xbf967966,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"dnsSecureSecondaries",                    {0xe0fa1e67,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"defaultObjectCategory",                   {0x26d97367,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"extensionAttribute1",                     {0xbf967967,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"dnsNotifySecondaries",                    {0xe0fa1e68,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msExchServer2ObjectMatch",                {0x293e3168,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"printShareName",                          {0xba305f68,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"extensionAttribute10",                    {0xbf967968,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"userAccountControl",                      {0xbf967a68,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Enroll",                                  {0x0e10c968,0x78fb,0x11d2,0x90,0xd4,0x00,0xc0,0x4f,0x79,0xdc,0x55}, 1},
{"ms-DS-MachineAccountQuota",               {0xd064fb68,0x1480,0x11d3,0x91,0xc1,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"dnsRecord",                               {0xe0fa1e69,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"printOwner",                              {0xba305f69,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"objectCategory",                          {0x26d97369,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"extensionAttribute2",                     {0xbf967969,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"userCert",                                {0xbf967a69,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-OLAPCube",                         {0x09f0506a,0xcd28,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"printNotify",                             {0xba305f6a,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"dSUIShellMaximum",                        {0xfcca766a,0x6f91,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"extensionAttribute3",                     {0xbf96796a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"comment",                                 {0xbf967a6a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msPKI-Cert-Template-OID",                 {0x3164c36a,0xba26,0x468c,0x8b,0xda,0xc1,0xe5,0xcc,0x25,0x67,0x28}, 2},
{"msExchDoFullReplication",                 {0x9e1ad86a,0xb093,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"printStatus",                             {0xba305f6b,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"fRSReplicaSetType",                       {0x26d9736b,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"extensionAttribute4",                     {0xbf96796b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-UnknownRangeParam",                 {0xb82ac26b,0xc6db,0x4098,0x92,0xc6,0x49,0xc1,0x8a,0x33,0x36,0xe1}, 2},
{"msPKI-Template-Minor-Revision",           {0x13f5236c,0x1884,0x46b1,0xb5,0xd0,0x48,0x4e,0x38,0x99,0x0d,0x58}, 2},
{"replicatedObjectVersion",                 {0x1677586c,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"printSpooling",                           {0xba305f6c,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"sAMAccountType",                          {0x6e7b626c,0x64f2,0x11d0,0xaf,0xd2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"fRSVersionGUID",                          {0x26d9736c,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"extensionAttribute5",                     {0xbf96796c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"sPNMappings",                             {0x2ab0e76c,0x7041,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msWMI-SourceOrganization",                {0x34f7ed6c,0x615d,0x418d,0xaa,0x00,0x54,0x9a,0x7d,0x7b,0xe0,0x3e}, 2},
{"printKeepPrintedJobs",                    {0xba305f6d,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"serverReference",                         {0x26d9736d,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"extensionAttribute6",                     {0xbf96796d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"userParameters",                          {0xbf967a6d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"tokenGroups",                             {0xb7c69e6d,0x2cc7,0x11d2,0x85,0x4e,0x00,0xa0,0xc9,0x83,0xf6,0x08}, 2},
{"printerName",                             {0x244b296e,0x5abd,0x11d0,0xaf,0xd2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"pKIDefaultCSPs",                          {0x1ef6336e,0x3b9e,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"driverVersion",                           {0xba305f6e,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mS-SQL-AllowImmediateUpdatingSubscription",{0xc4186b6e,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"serverReferenceBL",                       {0x26d9736e,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"extensionAttribute7",                     {0xbf96796e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"userPassword",                            {0xbf967a6e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-TrustForestTrustInfo",               {0x29cc866e,0x49d3,0x4969,0x94,0x2e,0x1d,0xbc,0x09,0x25,0xd1,0x83}, 2},
{"pKIDefaultKeySpec",                       {0x426cae6e,0x3b9d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"printMediaSupported",                     {0x244b296f,0x5abd,0x11d0,0xaf,0xd2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"printMaxXExtent",                         {0xba305f6f,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mailAddress",                             {0x26d9736f,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"extensionAttribute8",                     {0xbf96796f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"uSNChanged",                              {0xbf967a6f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"wbemPath",                                {0x244b2970,0x5abd,0x11d0,0xaf,0xd2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mS-SQL-Status",                           {0x9a7d4770,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"printMaxYExtent",                         {0xba305f70,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"extensionAttribute9",                     {0xbf967970,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"uSNCreated",                              {0xbf967a70,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"lastKnownParent",                         {0x52ab8670,0x5709,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Reset Password",                          {0x00299570,0x246d,0x11d0,0xa7,0x68,0x00,0xaa,0x00,0x6e,0x05,0x29}, 1},
{"msExchServer2PageSize",                   {0x296de070,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"fRSFileFilter",                           {0x1be8f170,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"countryCode",                             {0x5fd42471,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"printMinXExtent",                         {0xba305f71,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"uSNDSALastObjRemoved",                    {0xbf967a71,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"lostAndFound",                            {0x52ab8671,0x5709,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSDirectoryFilter",                      {0x1be8f171,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"printMinYExtent",                         {0xba305f72,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"transportDLLName",                        {0x26d97372,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"extensionName",                           {0xbf967972,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msExchServer2AuthenticationCredentials",  {0x26329072,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"fRSUpdateTimeout",                        {0x1be8f172,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"createTimeStamp",                         {0x2df90d73,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"msDS-Auxiliary-Classes",                  {0xc4af1073,0xee50,0x4be0,0xb8,0xc0,0x89,0xa4,0x1f,0xe9,0x9a,0xbe}, 2},
{"printStaplingSupported",                  {0xba305f73,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"uSNLastObjRem",                           {0xbf967a73,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"fRSWorkingPath",                          {0x1be8f173,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"parentGUID",                              {0x2df90d74,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"msCOM-Partition",                         {0xc9010e74,0x4e58,0x49f7,0x8a,0x89,0x5e,0x3e,0x23,0x40,0xfc,0xf8}, 2},
{"iPSECNegotiationPolicyType",              {0x07383074,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"printMemory",                             {0xba305f74,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"transportType",                           {0x26d97374,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"facsimileTelephoneNumber",                {0xbf967974,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"fRSRootPath",                             {0x1be8f174,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQPrevSiteGates",                       {0x2df90d75,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"iPSECNegotiationPolicyAction",            {0x07383075,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"assetNumber",                             {0xba305f75,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"queryPolicy",                             {0x83cc7075,0xcca7,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"interSiteTransportContainer",             {0x26d97375,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSStagingPath",                          {0x1be8f175,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQDependentClientServices",             {0x2df90d76,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"netbootAllowNewClients",                  {0x07383076,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"bytesPerMinute",                          {0xba305f76,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"interSiteTransport",                      {0x26d97376,0x6070,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"flags",                                   {0xbf967976,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"versionNumber",                           {0xbf967a76,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mSMQRoutingServices",                     {0x2df90d77,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"netbootLimitClients",                     {0x07383077,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"printRate",                               {0xba305f77,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"forceLogoff",                             {0xbf967977,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"whenChanged",                             {0xbf967a77,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"fRSDSPoll",                               {0x1be8f177,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQDsServices",                          {0x2df90d78,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"domainIdentifier",                        {0x7f561278,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"frsComputerReference",                    {0x2a132578,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootMaxClients",                       {0x07383078,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"sIDHistory",                              {0x17eb4278,0xd167,0x11d0,0xb0,0x02,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"printRateUnit",                           {0xba305f78,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msExchServer2ImportContainer",            {0x286c6278,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"msWMI-Som",                               {0xab857078,0x0142,0x4406,0x94,0x5b,0x34,0xc9,0xb6,0xb1,0x33,0x72}, 2},
{"whenCreated",                             {0xbf967a78,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-SQLServer",                        {0x05f6c878,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"pKIEnrollmentAccess",                     {0x926be278,0x56f9,0x11d2,0x90,0xd0,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"fRSFaultCondition",                       {0x1be8f178,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSTimeOfDay",                            {0x7f561279,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"frsComputerReferenceBL",                  {0x2a132579,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootCurrentClientCount",               {0x07383079,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"printNetworkAddress",                     {0xba305f79,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"fromServer",                              {0xbf967979,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"winsockAddresses",                        {0xbf967a79,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"aCSDirection",                            {0x7f56127a,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSControlDataCreation",                  {0x2a13257a,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootAnswerRequests",                   {0x0738307a,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"printMACAddress",                         {0xba305f7a,0x47e3,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"generatedConnection",                     {0xbf96797a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"wWWHomePage",                             {0xbf967a7a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"domainCAs",                               {0x7bfdcb7a,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msPKI-OID-User-Notice",                   {0x04c4da7a,0xe114,0x4e69,0x88,0xde,0xe2,0x93,0xf2,0xd3,0xb3,0x95}, 2},
{"trustParent",                             {0xb000ea7a,0xa086,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSMaxTokenRatePerFlow",                  {0x7f56127b,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSControlInboundBacklog",                {0x2a13257b,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootAnswerOnlyValidClients",           {0x0738307b,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"x121Address",                             {0xbf967a7b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rIDSetReferences",                        {0x7bfdcb7b,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"domainCrossRef",                          {0xb000ea7b,0xa086,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSMaxPeakBandwidthPerFlow",              {0x7f56127c,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSControlOutboundBacklog",               {0x2a13257c,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootNewMachineNamingPolicy",           {0x0738307c,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"transportAddressAttribute",               {0xc1dc867c,0xa261,0x11d1,0xb6,0x06,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingID",                               {0x11b6cc7c,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"siteServer",                              {0x1be8f17c,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSAggregateTokenRatePerUser",            {0x7f56127d,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSFlags",                                {0x2a13257d,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootNewMachineOU",                     {0x0738307d,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-IntRangeParam",                     {0x50ca5d7d,0x5c8b,0x4ef3,0xb9,0xdf,0x5b,0x66,0xd4,0x91,0xe5,0x26}, 2},
{"governsID",                               {0xbf96797d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msPKI-Supersede-Templates",               {0x9de8ae7d,0x7a5b,0x421d,0xb5,0xe4,0x06,0x1f,0x79,0xdf,0xd5,0xd7}, 2},
{"adminMultiselectPropertyPages",           {0x18f9b67d,0x5ac6,0x4b3b,0x97,0xdb,0xd0,0xa4,0x06,0xaf,0xb7,0xba}, 2},
{"msiFileList",                             {0x7bfdcb7d,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingName",                             {0x11b6cc7d,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"licensingSiteSettings",                   {0x1be8f17d,0xa9ff,0x11d0,0xaf,0xe2,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSMaxDurationPerFlow",                   {0x7f56127e,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSMemberReference",                      {0x2a13257e,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msExchServer1HighestUSN",                 {0x237f267e,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"netbootIntelliMirrorOSes",                {0x0738307e,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msExchServer1PageSize",                   {0x24b0537e,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"groupAttributes",                         {0xbf96797e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"pKIKeyUsage",                             {0xe9b0a87e,0x3b9d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"categories",                              {0x7bfdcb7e,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingDescription",                      {0x11b6cc7e,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"aCSServiceType",                          {0x7f56127f,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSMemberReferenceBL",                    {0x2a13257f,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootTools",                            {0x0738307f,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"userCertificate",                         {0xbf967a7f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"retiredReplDSASignatures",                {0x7bfdcb7f,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingKeyword",                          {0x11b6cc7f,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"aCSTotalNoOfFlows",                       {0x7f561280,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSPartnerAuthLevel",                     {0x2a132580,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootLocallyInstalledOSes",             {0x07383080,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"attributeDisplayNames",                   {0xcb843f80,0x48d9,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"groupMembershipSAM",                      {0xbf967980,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"attributeSchema",                         {0xbf967a80,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"validAccesses",                           {0x4d2fa380,0x7f54,0x11d2,0x99,0x2a,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"mS-SQL-AllowQueuedUpdatingSubscription",  {0xc458ca80,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"rootTrust",                               {0x7bfdcb80,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingLocation",                         {0x11b6cc80,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQRoutingService",                      {0x2df90d81,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"aCSPriority",                             {0x7f561281,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSPrimaryMember",                        {0x2a132581,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootServer",                           {0x07383081,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"homePostalAddress",                       {0x16775781,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"hasPartialReplicaNCs",                    {0xbf967981,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"builtinDomain",                           {0xbf967a81,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"catalogs",                                {0x7bfdcb81,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingProtocol",                         {0x11b6cc81,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msFRS-Hub-Member",                        {0x5643ff81,0x35b6,0x4ca9,0x95,0x12,0xba,0xf0,0xbd,0x0a,0x27,0x72}, 2},
{"mSMQDsService",                           {0x2df90d82,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"aCSPermissionBits",                       {0x7f561282,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSServiceCommandStatus",                 {0x2a132582,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"netbootSCPBL",                            {0x07383082,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Abandon Replication",                     {0xee914b82,0x0a98,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"hasMasterNCs",                            {0xbf967982,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"classRegistration",                       {0xbf967a82,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"meetingType",                             {0x11b6cc82,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-PropertyName",                      {0xab920883,0xe7f8,0x4d72,0xb4,0xa0,0xc0,0x44,0x98,0x97,0x50,0x9d}, 2},
{"mSMQDependentClientService",              {0x2df90d83,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"aCSAllocableRSVPBandwidth",               {0x7f561283,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSTimeLastCommand",                      {0x2a132583,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"pekList",                                 {0x07383083,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-Rule",                              {0x3c7e6f83,0xdd0e,0x481b,0xa0,0xc2,0x74,0xcd,0x96,0xef,0x2a,0x66}, 2},
{"classSchema",                             {0xbf967a83,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"wellKnownObjects",                        {0x05308983,0x7688,0x11d1,0xad,0xed,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 2},
{"replTopologyStayOfExecution",             {0x7bfdcb83,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingApplication",                      {0x11b6cc83,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"iconPath",                                {0xf0f8ff83,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"netbootSIFFile",                          {0x2df90d84,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"aCSMaxPeakBandwidth",                     {0x7f561284,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fRSTimeLastConfigChange",                 {0x2a132584,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-DS-ReplicatesNCReason",                {0x0ea12b84,0x08b3,0x11d3,0x91,0xbc,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"pekKeyChangeInterval",                    {0x07383084,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"telephoneAssistant",                      {0xa8df7484,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"showInAdvancedViewOnly",                  {0xbf967984,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"classStore",                              {0xbf967a84,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-Size",                             {0xe9098084,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"meetingLanguage",                         {0x11b6cc84,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"streetAddress",                           {0xf0f8ff84,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"netbootMirrorDataFile",                   {0x2df90d85,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"aCSEnableRSVPMessageLogging",             {0x7f561285,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-Parm1",                             {0x27e81485,0xb1b0,0x4a8b,0xbe,0xdd,0xce,0x19,0xa8,0x37,0xe2,0x6e}, 2},
{"fRSVersion",                              {0x2a132585,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"intellimirrorSCP",                        {0x07383085,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"homeDirectory",                           {0xbf967985,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"comConnectionPoint",                      {0xbf967a85,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msNPAllowDialin",                         {0xdb0c9085,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"msDS-Replication-Notify-Subsequent-DSA-Delay",{0xd63db385,0xdd92,0x4b52,0xb1,0xd8,0x0d,0x3e,0xcc,0x0e,0x86,0xb6}, 2},
{"creator",                                 {0x7bfdcb85,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingMaxParticipants",                  {0x11b6cc85,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dNReferenceUpdate",                       {0x2df90d86,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"aCSEventLogLevel",                        {0x7f561286,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rIDManagerReference",                     {0x66171886,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"nTFRSMember",                             {0x2a132586,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"intellimirrorGroup",                      {0x07383086,0x91df,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"homeDrive",                               {0xbf967986,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"computer",                                {0xbf967a86,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msExchServer2Port",                       {0x29a4b686,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"Personal Information",                    {0x77b5b886,0x944a,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1}, 1},
{"queryPoint",                              {0x7bfdcb86,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingOriginator",                       {0x11b6cc86,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msExchServer1ImportContainer",            {0x23aed586,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"dSHeuristics",                            {0xf0f8ff86,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"mSMQQueueNameExt",                        {0x2df90d87,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"aCSEnableACSService",                     {0x7f561287,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"fSMORoleOwner",                           {0x66171887,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"nTFRSSubscriptions",                      {0x2a132587,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"personalPager",                           {0xa8df7487,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"homeMDB",                                 {0xbf967987,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"configuration",                           {0xbf967a87,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"indexedScopes",                           {0x7bfdcb87,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingContactInfo",                      {0x11b6cc87,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"businessRoles",                           {0xf0f8ff87,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"aCSPolicy",                               {0x7f561288,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msPKI-OID-Attribute",                     {0x8c9e1288,0x5028,0x4f4f,0xa7,0x04,0x76,0xd0,0x26,0xf2,0x46,0xef}, 2},
{"rIDAvailablePool",                        {0x66171888,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"nTFRSSubscriber",                         {0x2a132588,0x9373,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"servicePrincipalName",                    {0xf3a64788,0x5306,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Validated write to service principal name",{0xf3a64788,0x5306,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 1},
{"friendlyNames",                           {0x7bfdcb88,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingOwner",                            {0x11b6cc88,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-LastDiagnosticDate",               {0xf6d6dd88,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"company",                                 {0xf0f8ff88,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"infrastructureUpdate",                    {0x2df90d89,0x009f,0x11d2,0xaa,0x4c,0x00,0xc0,0x4f,0xd7,0xd8,0x3a}, 2},
{"aCSSubnet",                               {0x7f561289,0x5301,0x11d1,0xa9,0xc5,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rIDAllocationPool",                       {0x66171889,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"textEncodedORAddress",                    {0xa8df7489,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"homeMTA",                                 {0xbf967989,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msNPCalledStationID",                     {0xdb0c9089,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"rIDSet",                                  {0x7bfdcb89,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingIP",                               {0x11b6cc89,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msCOM-UserPartitionSetLink",              {0x8e940c8a,0xe477,0x4367,0xb0,0x8d,0xff,0x2f,0xf9,0x42,0xdc,0xd7}, 2},
{"rIDPreviousAllocationPool",               {0x6617188a,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"displaySpecifier",                        {0xe0fa1e8a,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msNPCallingStationID",                    {0xdb0c908a,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"mS-SQL-UnicodeSortOrder",                 {0x72dc918a,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"createDialog",                            {0x2b09958a,0x8931,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQSiteForeign",                         {0xfd129d8a,0xd57e,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"mS-SQL-Keywords",                         {0x01e9a98a,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"indexServerCatalog",                      {0x7bfdcb8a,0x4807,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingScope",                            {0x11b6cc8a,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"rIDUsedPool",                             {0x6617188b,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"dnsZone",                                 {0xe0fa1e8b,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"attributeCertificate",                    {0x1677578b,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msCOM-ObjectId",                          {0x430f678b,0x889f,0x41f2,0x98,0x43,0x20,0x3b,0x5a,0x65,0x57,0x2f}, 2},
{"container",                               {0xbf967a8b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"createWizardExt",                         {0x2b09958b,0x8931,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"meetingAdvertiseScope",                   {0x11b6cc8b,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dMDLocation",                             {0xf0f8ff8b,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"rIDNextRID",                              {0x6617188c,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"dnsNode",                                 {0xe0fa1e8c,0x9b45,0x11d0,0xaf,0xdd,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mS-SQL-Memory",                           {0x5b5d448c,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"instanceType",                            {0xbf96798c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"country",                                 {0xbf967a8c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"meetingURL",                              {0x11b6cc8c,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"enabledProtocols",                        {0xf0f8ff8c,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"rIDManager",                              {0x6617188d,0x8f3c,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"authorityRevocationList",                 {0x1677578d,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"internationalISDNNumber",                 {0xbf96798d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"crossRef",                                {0xbf967a8d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"meetingRating",                           {0x11b6cc8d,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"folderPathname",                          {0xf0f8ff8d,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"msExchIsBridgeheadSite",                  {0xa6b1108e,0xb093,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"machinePasswordChangeInterval",           {0xc9b6358e,0xbb38,0x11d0,0xaf,0xef,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msExchServer2LastUpdateTime",             {0x28a3388e,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"msWMI-Parm2",                             {0x0003508e,0x9c42,0x4a76,0xa8,0xf4,0x38,0xbf,0x64,0xba,0xb0,0xde}, 2},
{"supportedAlgorithms",                     {0x1677588e,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"invocationId",                            {0xbf96798e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"device",                                  {0xbf967a8e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msNPSavedCallingStationID",               {0xdb0c908e,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"meetingIsEncrypted",                      {0x11b6cc8e,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"givenName",                               {0xf0f8ff8e,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"supportedApplicationContext",             {0x1677588f,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-NormalizedClass",                   {0xeaba628f,0xeb8e,0x4fe9,0x83,0xfc,0x69,0x3b,0xe6,0x95,0x55,0x9b}, 2},
{"isDeleted",                               {0xbf96798f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"dMD",                                     {0xbf967a8f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"meetingRecurrence",                       {0x11b6cc8f,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Apply Group Policy",                      {0xedacfd8f,0xffb3,0x11d1,0xb4,0x1d,0x00,0xa0,0xc9,0x68,0xf9,0x39}, 1},
{"samDomain",                               {0xbf967a90,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-Clustered",                        {0x7778bd90,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"meetingStartTime",                        {0x11b6cc90,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msExchADCGlobalNames",                    {0x9062f090,0xb093,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"initials",                                {0xf0f8ff90,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"memberOf",                                {0xbf967991,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"samDomainBase",                           {0xbf967a91,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"meetingEndTime",                          {0x11b6cc91,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mDBOverQuotaLimit",                       {0xf0f8ff91,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"implementedCategories",                   {0x7d6c0e92,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"isSingleValued",                          {0xbf967992,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"server",                                  {0xbf967a92,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"pKIEnrollmentService",                    {0xee4aa692,0x3bba,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"tokenGroupsNoGCAcceptable",               {0x040fc392,0x33df,0x11d2,0x98,0xb2,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"meetingBandwidth",                        {0x11b6cc92,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mDBStorageQuota",                         {0xf0f8ff92,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"requiredCategories",                      {0x7d6c0e93,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"keywords",                                {0xbf967993,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"meetingBlob",                             {0x11b6cc93,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mDBUseDefaults",                          {0xf0f8ff93,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"dSUIAdminNotification",                   {0xf6ea0a94,0x6f91,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"categoryId",                              {0x7d6c0e94,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mS-SQL-Vines",                            {0x94c56394,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"secretary",                               {0xa8df7394,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"languageCode",                            {0xbf967994,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-GPSLongitude",                     {0xb7577c94,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"meeting",                                 {0x11b6cc94,0x48c4,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"aCSMinimumPolicedSize",                   {0x8d0e7195,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"unauthOrig",                              {0xa8df7495,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"lastContentIndexed",                      {0xbf967995,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Change PDC",                              {0xbae50096,0x4752,0x11d1,0x90,0x52,0x00,0xc0,0x4f,0xc2,0xd4,0xcf}, 1},
{"msExchHideFromAddressLists",              {0xa21c0b96,0xb093,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"packageType",                             {0x7d6c0e96,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"policyReplicationFlags",                  {0x19405b96,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"lastLogoff",                              {0xbf967996,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"setupCommand",                            {0x7d6c0e97,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"printPagesPerMinute",                     {0x19405b97,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQMigratedUser",                        {0x50776997,0x3c3d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"authOrig",                                {0xa8df7397,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"lastLogon",                               {0xbf967997,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"packageName",                             {0x7d6c0e98,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"privilegeDisplayName",                    {0x19405b98,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"USNIntersite",                            {0xa8df7498,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"lastSetTime",                             {0xbf967998,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-QueryLanguage",                     {0x7d3cfa98,0xc17b,0x4254,0x8b,0xd7,0x4d,0xe9,0xb9,0x32,0xa3,0x45}, 2},
{"packageFlags",                            {0x7d6c0e99,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"privilegeValue",                          {0x19405b99,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"domainPolicy",                            {0xbf967a99,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-IntSetParam",                       {0x292f0d9a,0xcf76,0x42b0,0x84,0x1f,0xb6,0x50,0xf3,0x31,0xdf,0x62}, 2},
{"versionNumberHi",                         {0x7d6c0e9a,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSPolicyName",                           {0x1cb3559a,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"privilegeAttributes",                     {0x19405b9a,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"lDAPDisplayName",                         {0xbf96799a,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-TargetPath",                        {0x5006a79a,0x6bfe,0x4561,0x9f,0x52,0x13,0xcf,0x4d,0xd3,0xe5,0x60}, 2},
{"publicDelegates",                         {0xf0f8ff9a,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"versionNumberLo",                         {0x7d6c0e9b,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSMinimumDelayVariation",                {0x9c65329b,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"aCSRSVPLogFilesLocation",                 {0x1cb3559b,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"privilegeHolder",                         {0x19405b9b,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"linkID",                                  {0xbf96799b,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"lastUpdateSequence",                      {0x7d6c0e9c,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSMaxNoOfLogFiles",                      {0x1cb3559c,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"isPrivilegeHolder",                       {0x19405b9c,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"dBCSPwd",                                 {0xbf96799c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"group",                                   {0xbf967a9c,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msRADIUSCallbackNumber",                  {0xdb0c909c,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"Change Domain Master",                    {0x014bf69c,0x7b3b,0x11d1,0x85,0xf6,0x08,0x00,0x2b,0xe7,0x4f,0xab}, 1},
{"categoryRegistration",                    {0x7d6c0e9d,0x7e20,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"aCSMaxSizeOfRSVPLogFile",                 {0x1cb3559d,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"isMemberOfPartialAttributeSet",           {0x19405b9d,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"lmPwdHistory",                            {0xbf96799d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"groupOfNames",                            {0xbf967a9d,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"aCSDSBMPriority",                         {0x1cb3559e,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"partialAttributeSet",                     {0x19405b9e,0x3cfa,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"localPolicyFlags",                        {0xbf96799e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"leaf",                                    {0xbf967a9e,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"aCSDSBMRefresh",                          {0x1cb3559f,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"certificateRevocationList",               {0x1677579f,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"defaultLocalPolicyObject",                {0xbf96799f,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-Mof",                               {0x6736809f,0x2064,0x443e,0xa1,0x45,0x81,0x26,0x2b,0x1f,0x13,0x66}, 2},
{"structuralObjectClass",                   {0x3860949f,0xf6a8,0x4b38,0x99,0x50,0x81,0xec,0xb6,0xbc,0x29,0x82}, 2},
{"location",                                {0x09dcb79f,0x165f,0x11d0,0xa0,0x64,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"targetAddress",                           {0xf0f8ff9f,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"division",                                {0xfe6136a0,0x2073,0x11d0,0xa9,0xc2,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"aCSDSBMDeadTime",                         {0x1cb355a0,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"locality",                                {0xbf967aa0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"serverName",                              {0x09dcb7a0,0x165f,0x11d0,0xa0,0x64,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"templateRoots",                           {0xed9de9a0,0x7041,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msExchHomeSyncService",                   {0xa2a3f1a0,0xb093,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"msWMI-ChangeDate",                        {0xf9cdf7a0,0xec44,0x4937,0xa7,0x9b,0xcd,0x91,0x52,0x2b,0x3a,0xa8}, 2},
{"garbageCollPeriod",                       {0x5fd424a1,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"aCSCacheTimeout",                         {0x1cb355a1,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"localeID",                                {0xbf9679a1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mailRecipient",                           {0xbf967aa1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"homePhone",                               {0xf0f8ffa1,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"aCSNonReservedTxLimit",                   {0x1cb355a2,0x56d0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"l",                                       {0xbf9679a2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-StringSetParam",                    {0x0bc579a2,0x1da7,0x4cea,0xb6,0x99,0x80,0x7f,0x3b,0x9d,0x63,0xa4}, 2},
{"pKICertificateTemplate",                  {0xe5209ca2,0x3bba,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"msDS-NC-Head-Creator",                    {0xc1f0efa2,0xdfab,0x410d,0x82,0x52,0x89,0xc0,0x32,0x0d,0x93,0xf7}, 2},
{"msExchServer1AuthenticationPassword",     {0x228bf6a2,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"otherHomePhone",                          {0xf0f8ffa2,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"organization",                            {0xbf967aa3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-Parm4",                             {0x3800d5a3,0xf1ce,0x4b82,0xa5,0x9a,0x15,0x28,0xea,0x79,0x5f,0x59}, 2},
{"mobile",                                  {0xf0f8ffa3,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"msExchServer2SearchFilter",               {0x2a0b3ba4,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"lockOutObservationWindow",                {0xbf9679a4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"organizationalPerson",                    {0xbf967aa4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msRADIUSFramedIPAddress",                 {0xdb0c90a4,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"otherPager",                              {0xf0f8ffa4,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"aCSServerList",                           {0x7cbd59a5,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"msWMI-TargetObject",                      {0xc44f67a5,0x7de5,0x4a1f,0x92,0xd9,0x66,0x2b,0x57,0x36,0x4b,0x77}, 2},
{"lockoutDuration",                         {0xbf9679a5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"organizationalUnit",                      {0xbf967aa5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"otherTelephone",                          {0xf0f8ffa5,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"mS-SQL-TCPIP",                            {0x8ac263a6,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"mS-SQL-CharacterSet",                     {0x696177a6,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"lockoutThreshold",                        {0xbf9679a6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"packageRegistration",                     {0xbf967aa6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"sDRightsEffective",                       {0xc3dbafa6,0x33df,0x11d2,0x98,0xb2,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"gPCWQLFilter",                            {0x7bd4c7a6,0x1add,0x4436,0x8c,0x04,0x39,0x99,0xa8,0x80,0x15,0x4c}, 2},
{"pager",                                   {0xf0f8ffa6,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"helpData16",                              {0x5fd424a7,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"person",                                  {0xbf967aa7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"co",                                      {0xf0f8ffa7,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"helpData32",                              {0x5fd424a8,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"Recalculate Security Inheritance",        {0x62dd28a8,0x7f46,0x11d2,0xb9,0xad,0x00,0xc0,0x4f,0x79,0xf8,0x05}, 1},
{"scriptPath",                              {0xbf9679a8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"printQueue",                              {0xbf967aa8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-Type",                             {0xca48eba8,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msWMI-Int8ValidValues",                   {0x103519a9,0xc002,0x441b,0x98,0x1a,0xb0,0xb3,0xe0,0x12,0xc8,0x03}, 2},
{"helpFileName",                            {0x5fd424a9,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"thumbnailLogo",                           {0xbf9679a9,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"remoteMailRecipient",                     {0xbf967aa9,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msRADIUSFramedRoute",                     {0xdb0c90a9,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"mSMQInterval1",                           {0x8ea825aa,0x3b7b,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"logonCount",                              {0xbf9679aa,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Replicating Directory Changes",           {0x1131f6aa,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2}, 1},
{"msCOM-PartitionSet",                      {0x250464ab,0xc417,0x497a,0x97,0x5a,0x9e,0x0d,0x45,0x9a,0x7c,0xa1}, 2},
{"logonHours",                              {0xbf9679ab,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Replication Synchronization",             {0x1131f6ab,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2}, 1},
{"nTDSDSA",                                 {0xf0f8ffab,0x1191,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"logonWorkstation",                        {0xbf9679ac,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rpcEntry",                                {0xbf967aac,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msMQ-Group",                              {0x46b27aac,0xaafa,0x4ffb,0xb7,0x73,0xe5,0xbf,0x62,0x1e,0xe8,0x7b}, 2},
{"applicationVersion",                      {0xddc790ac,0xaf4d,0x442a,0x8f,0x0f,0xa1,0xd4,0xca,0xa7,0xdd,0x92}, 2},
{"msRRASVendorAttributeEntry",              {0xf39b98ac,0x938d,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-intFlags4",                         {0xbd74a7ac,0xc493,0x4c9c,0xbd,0xfa,0x5c,0x7b,0x11,0x9c,0xa6,0xb2}, 2},
{"msExchServer2NTAccountDomain",            {0x2909bdac,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"Manage Replication Topology",             {0x1131f6ac,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2}, 1},
{"Add GUID",                                {0x440820ad,0x65b4,0x11d1,0xa3,0xda,0x00,0x00,0xf8,0x75,0xae,0x0d}, 1},
{"uSNSource",                               {0x167758ad,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"lSACreationTime",                         {0xbf9679ad,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"samServer",                               {0xbf967aad,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msRRASAttribute",                         {0xf39b98ad,0x938d,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"schemaInfo",                              {0xf9fb64ae,0x93b4,0x11d2,0x99,0x45,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"lSAModifiedCount",                        {0xbf9679ae,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"secret",                                  {0xbf967aae,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rRASAdministrationDictionary",            {0xf39b98ae,0x938d,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-Alias",                            {0xe0c6baae,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"machineArchitecture",                     {0xbf9679af,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"securityObject",                          {0xbf967aaf,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"securityPrincipal",                       {0xbf967ab0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"remoteStorageGUID",                       {0x2a39c5b0,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"serviceClass",                            {0xbf967ab1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"certificateTemplates",                    {0x2a39c5b1,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"crossCertificatePair",                    {0x167757b2,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"machineRole",                             {0xbf9679b2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"serviceInstance",                         {0xbf967ab2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Phone and Mail Options",                  {0xe45795b2,0x9455,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1}, 1},
{"msWMI-UintRangeParam",                    {0xd9a799b2,0xcef3,0x48b3,0xb5,0xad,0xfb,0x85,0xf8,0xdd,0x32,0x14}, 2},
{"userSMIMECertificate",                    {0xe16a9db2,0x403c,0x11d1,0xa9,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msExchServer1SearchFilter",               {0x254daeb2,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"mSMQSiteName",                            {0xffadb4b2,0xde39,0x11d1,0x90,0xa5,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"signatureAlgorithms",                     {0x2a39c5b2,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mailNickname",                            {0xbf9679b3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"site",                                    {0xbf967ab3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Web Information",                         {0xe45795b3,0x9455,0x11d1,0xae,0xbd,0x00,0x00,0xf8,0x03,0x67,0xc1}, 1},
{"enrollmentProviders",                     {0x2a39c5b3,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"schemaUpdate",                            {0x1e2d06b4,0xac8f,0x11d0,0xaf,0xe3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msExchServer2Flags",                      {0x28083fb4,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"msTAPI-RtPerson",                         {0x53ea1cb5,0xb704,0x4df9,0x81,0x8f,0x5c,0xb4,0xec,0x86,0xca,0xc1}, 2},
{"deltaRevocationList",                     {0x167757b5,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"manager",                                 {0xbf9679b5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"storage",                                 {0xbf967ab5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-SimplePolicyTemplate",              {0x6cc8b2b5,0x12df,0x44f6,0x83,0x07,0xe7,0x4f,0x5c,0xde,0xe3,0x69}, 2},
{"aCSIdentityName",                         {0xdab029b6,0xddf7,0x11d1,0x90,0xa5,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"msWMI-StringDefault",                     {0x152e42b6,0x37c5,0x4f55,0xab,0x48,0x16,0x06,0x38,0x4a,0x9a,0xea}, 2},
{"Change Schema Master",                    {0xe12b56b6,0x0a95,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"msWMI-Parm3",                             {0x45958fb6,0x52bd,0x48ce,0x9f,0x9f,0xc2,0x71,0x2d,0x9f,0x2b,0xfc}, 2},
{"msRADIUSServiceType",                     {0xdb0c90b6,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"dNSTombstoned",                           {0xd5eb2eb7,0xbe4e,0x463b,0xa2,0x14,0x63,0x4a,0x44,0xd7,0x39,0x2e}, 2},
{"mAPIID",                                  {0xbf9679b7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"top",                                     {0xbf967ab7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"serviceDNSName",                          {0x28630eb8,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-PublicationURL",                   {0xae0c11b8,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"mAPIRecipient",                           {0xbf9679b8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"trustedDomain",                           {0xbf967ab8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-intFlags1",                         {0x18e006b9,0x6445,0x48e3,0x9d,0xcf,0xb5,0xec,0xfb,0xc4,0xdf,0x8e}, 2},
{"dmdName",                                 {0x167757b9,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"marshalledInterface",                     {0xbf9679b9,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msExchServer1ExportContainers",           {0x231b03ba,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"serviceDNSNameType",                      {0x28630eba,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"user",                                    {0xbf967aba,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-IntMin",                            {0x68c2e3ba,0x9837,0x4c70,0x98,0xe0,0xf0,0xc3,0x36,0x95,0xd0,0x23}, 2},
{"userPrincipalName",                       {0x28630ebb,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"maxPwdAge",                               {0xbf9679bb,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"volume",                                  {0xbf967abb,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"legacyExchangeDN",                        {0x28630ebc,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-ClassDefinition",                   {0x2b9c0ebc,0xc272,0x45cb,0x99,0xd2,0x4d,0x0e,0x69,0x16,0x32,0xe0}, 2},
{"dSASignature",                            {0x167757bc,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"maxRenewAge",                             {0xbf9679bc,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"treeName",                                {0x28630ebd,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"maxStorage",                              {0xbf9679bd,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"remoteStorageServicePoint",               {0x2a39c5bd,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"isDefunct",                               {0x28630ebe,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"gPLink",                                  {0xf30e3bbe,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"additionalTrustedServiceNames",           {0x032160be,0x9824,0x11d1,0xae,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msDs-Schema-Extensions",                  {0xb39a61be,0xed07,0x4cab,0x9a,0x4a,0x49,0x63,0xed,0x01,0x41,0xe1}, 2},
{"maxTicketAge",                            {0xbf9679be,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rRASAdministrationConnectionPoint",       {0x2a39c5be,0x8960,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"lockoutTime",                             {0x28630ebf,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"gPOptions",                               {0xf30e3bbf,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"uPNSuffixes",                             {0x032160bf,0x9824,0x11d1,0xae,0xc0,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"organizationalRole",                      {0xa8df74bf,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"mayContain",                              {0xbf9679bf,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msPKI-RA-Application-Policies",           {0x3c91fbbf,0x4773,0x4ccd,0xa8,0x7b,0x85,0xd5,0x3e,0x7b,0xcf,0x6a}, 2},
{"Receive Dead Letter",                     {0x4b6e08c0,0xdf3c,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"partialAttributeDeletionList",            {0x28630ec0,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"replPropertyMetaData",                    {0x281416c0,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"gPCFunctionalityVersion",                 {0xf30e3bc0,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-SortOrder",                        {0x6ddc42c0,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"assocNTAccount",                          {0x398f63c0,0xca60,0x11d1,0xbb,0xd1,0x00,0x00,0xf8,0x1f,0x10,0xc0}, 2},
{"Add/Remove self as member",               {0xbf9679c0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 1},
{"member",                                  {0xbf9679c0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"serversContainer",                        {0xf780acc0,0x56f0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Peek Dead Letter",                        {0x4b6e08c1,0xdf3c,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"serviceConnectionPoint",                  {0x28630ec1,0x41d5,0x11d1,0xa9,0xc1,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"gPCFileSysPath",                          {0xf30e3bc1,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"applicationSettings",                     {0xf780acc1,0x56f0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-Author",                            {0x6366c0c1,0x6972,0x4e66,0xb3,0xa5,0x1d,0x52,0xad,0x0c,0x05,0x47}, 2},
{"Receive Computer Journal",                {0x4b6e08c2,0xdf3c,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"msExchAdditionalDNMap",                   {0x90a814c2,0xb093,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"groupPolicyContainer",                    {0xf30e3bc2,0x9ff0,0x11d1,0xb6,0x03,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-DS-ConsistencyGuid",                   {0x23773dc2,0xb63a,0x11d2,0x90,0xe1,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"msPKI-Private-Key-Flag",                  {0xbab04ac2,0x0435,0x4709,0x93,0x07,0x28,0x38,0x0e,0x7c,0x70,0x01}, 2},
{"dLMemRejectPerms",                        {0xa8df73c2,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"minPwdAge",                               {0xbf9679c2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-DS-ConsistencyChildCount",             {0x178b7bc2,0xb63a,0x11d2,0x90,0xe1,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"scopeFlags",                              {0x16f3a4c2,0x7e79,0x11d2,0x99,0x21,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"nTFRSSettings",                           {0xf780acc2,0x56f0,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msExchServer1ObjectMatch",                {0x247bdfc2,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"Peek Computer Journal",                   {0x4b6e08c3,0xdf3c,0x11d1,0x9c,0x86,0x00,0x60,0x08,0x76,0x4d,0x0e}, 1},
{"minPwdLength",                            {0xbf9679c3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"portName",                                {0x281416c4,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mDBOverHardQuotaLimit",                   {0x8fcf1ec4,0xb093,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"dLMemSubmitPerms",                        {0xa8df73c4,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"minTicketAge",                            {0xbf9679c4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-Build",                            {0x603e94c4,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msPKI-Certificate-Name-Flag",             {0xea1dddc4,0x60ff,0x416e,0x8c,0xc0,0x17,0xce,0xe5,0x34,0xbc,0xe7}, 2},
{"driverName",                              {0x281416c5,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"modifiedCount",                           {0xbf9679c5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msRASSavedCallbackNumber",                {0xdb0c90c5,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"printSeparatorFile",                      {0x281416c6,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"dnQualifier",                             {0x167758c6,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"gPCUserExtensionNames",                   {0x42a75fc6,0x783f,0x11d2,0x99,0x16,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"modifiedCountAtLastProm",                 {0xbf9679c6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msRASSavedFramedIPAddress",               {0xdb0c90c6,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"priority",                                {0x281416c7,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"deletedItemFlags",                        {0x167757c7,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"moniker",                                 {0xbf9679c7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msRASSavedFramedRoute",                   {0xdb0c90c7,0xc1f2,0x11d1,0xbb,0xc5,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"defaultPriority",                         {0x281416c8,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msExchCustomAttributes",                  {0x00e629c8,0xa981,0x11d2,0xa9,0xff,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"monikerDisplayName",                      {0xbf9679c8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msExchServer1SSLPort",                    {0x258484c8,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"moveTreeState",                           {0x1f2ac2c8,0x3b71,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"printStartTime",                          {0x281416c9,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-intFlags2",                         {0x075a42c9,0xc55a,0x45b1,0xac,0x93,0xeb,0x08,0x6b,0x31,0xf6,0x10}, 2},
{"msWMI-ObjectEncoding",                    {0x55dd81c9,0xc312,0x41f9,0xa8,0x4d,0xc6,0xad,0xbd,0xf1,0xe8,0xe1}, 2},
{"aCSNonReservedTokenSize",                 {0xa916d7c9,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"printEndTime",                            {0x281416ca,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"cRLDistributionPoint",                    {0x167758ca,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-LastBackupDate",                   {0xf2b6abca,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"printFormName",                           {0x281416cb,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"printDuplexSupported",                    {0x281416cc,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"gPCMachineExtensionNames",                {0x32ff8ecc,0x783f,0x11d2,0x99,0x16,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"entryTTL",                                {0xd213decc,0xd81a,0x4384,0xaa,0xc2,0xdc,0xfc,0xfd,0x63,0x1c,0xf8}, 2},
{"printBinNames",                           {0x281416cd,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"originalDisplayTable",                    {0x5fd424ce,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"printMaxResolutionSupported",             {0x281416cf,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"connectionPoint",                         {0x5cb41ecf,0x0e4c,0x11d0,0xa2,0x86,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"originalDisplayTableMSDOS",               {0x5fd424cf,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"rpcProfileElement",                       {0xf29653cf,0x7ad0,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msTAPI-ProtocolId",                       {0x89c1ebcf,0x7a5f,0x41fd,0x99,0xca,0xc9,0x00,0xb3,0x22,0x99,0xab}, 2},
{"printOrientationsSupported",              {0x281416d0,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"contact",                                 {0x5cb41ed0,0x0e4c,0x11d0,0xa2,0x86,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rpcServerElement",                        {0xf29653d0,0x7ad0,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"sAMAccountName",                          {0x3e0abfd0,0x126a,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"mS-SQL-Version",                          {0xc07cc1d0,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"printMaxCopies",                          {0x281416d1,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-Int8Min",                           {0xed1489d1,0x54cc,0x4066,0xb3,0x68,0xa0,0x0d,0xaa,0x26,0x64,0xf1}, 2},
{"localizationDisplayId",                   {0xa746f0d1,0x78d0,0x11d2,0x99,0x16,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"printCollate",                            {0x281416d2,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"pKIExpirationPeriod",                     {0x041570d2,0x3b9e,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"msExchNtdsExportContainers",              {0x155bf4d2,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"printColor",                              {0x281416d3,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"perMsgDialogDisplayTable",                {0x5fd424d3,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"mustContain",                             {0xbf9679d3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"perRecipDialogDisplayTable",              {0x5fd424d4,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"mS-SQL-LastUpdatedDate",                  {0x9fcc43d4,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"printLanguage",                           {0x281416d6,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"proxyGenerationEnabled",                  {0x5fd424d6,0x1262,0x11d0,0xa0,0x60,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"residentialPerson",                       {0xa8df74d6,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"nCName",                                  {0xbf9679d6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-TargetClass",                       {0x95b6d8d6,0xc9e8,0x4661,0xa2,0xbc,0x6a,0x5c,0xab,0xc0,0x4c,0x62}, 2},
{"msExchSchemaPolicyConsumers",             {0x20c6f7d6,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"printAttributes",                         {0x281416d7,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-Settings",                           {0x0e1b47d7,0x40a3,0x4b48,0x8d,0x1b,0x4c,0xac,0x0c,0x1c,0xdf,0x21}, 2},
{"userWorkstations",                        {0xbf9679d7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msDS-Entry-Time-To-Die",                  {0xe1e9bad7,0xc6dd,0x4101,0xa8,0x43,0x79,0x4c,0xec,0x85,0xb0,0x38}, 2},
{"nETBIOSName",                             {0xbf9679d8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-Contact",                          {0x4f6cbdd8,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"mS-SQL-Name",                             {0x3532dfd8,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msPKI-Enrollment-Flag",                   {0xd15ef7d8,0xf226,0x46db,0xae,0x79,0xb3,0x4e,0x56,0x0b,0xd1,0x2c}, 2},
{"cOMCLSID",                                {0x281416d9,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"networkAddress",                          {0xbf9679d9,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"cOMUniqueLIBID",                          {0x281416da,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"sitesContainer",                          {0x7a4117da,0xcd67,0x11d0,0xaf,0xff,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-ConnectionURL",                    {0xa92d23da,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"bridgeheadTransportList",                 {0xd50c2cda,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"nextLevelStore",                          {0xbf9679da,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"cOMTreatAsClassId",                       {0x281416db,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"bridgeheadServerListBL",                  {0xd50c2cdb,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"nextRid",                                 {0xbf9679db,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msCOM-PartitionSetLink",                  {0x67f121dc,0x7d02,0x4c7d,0x82,0xf5,0x9a,0xd4,0xc9,0x50,0xac,0x34}, 2},
{"siteList",                                {0xd50c2cdc,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mS-SQL-Database",                         {0xd5a0dbdc,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"cOMOtherProgId",                          {0x281416dd,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"siteLinkList",                            {0xd50c2cdd,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"Generate Resultant Set of Policy",        {0xb7b1b3dd,0xab09,0x4242,0x9e,0x30,0x99,0x80,0xe5,0xd3,0x22,0xf7}, 1},
{"cOMTypelibId",                            {0x281416de,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rpcNsAnnotation",                         {0x88611bde,0x8cf4,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"siteLink",                                {0xd50c2cde,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msExchServer1Type",                       {0x25bb5ade,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"vendor",                                  {0x281416df,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"rpcGroup",                                {0x88611bdf,0x8cf4,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"siteLinkBridge",                          {0xd50c2cdf,0x8951,0x11d1,0xae,0xbc,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-ShadowObject",                      {0xf1e44bdf,0x8dd3,0x4235,0x9c,0x86,0xf9,0x1f,0x31,0xf5,0xb5,0x69}, 2},
{"nTGroupMembers",                          {0xbf9679df,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"aCSMaxTokenBucketPerFlow",                {0x81f6e0df,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"dSUIAdminMaximum",                        {0xee8d0ae0,0x6f91,0x11d2,0x99,0x05,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"rpcServer",                               {0x88611be0,0x8cf4,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msFRS-Topology-Pref",                     {0x92aa27e0,0x5c50,0x402d,0x9e,0xc1,0xee,0x84,0x7d,0xef,0x97,0x88}, 2},
{"crossRefContainer",                       {0xef9e60e0,0x56f7,0x11d1,0xa9,0xc6,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"masteredBy",                              {0xe48e64e0,0x12c9,0x11d3,0x91,0x02,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"Do Garbage Collection",                   {0xfec364e0,0x0a98,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"msExchServer1Port",                       {0x24e264e0,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"rpcNsCodeset",                            {0x7a0ba0e0,0x8e98,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mSMQDigestsMig",                          {0x0f71d8e0,0xda3b,0x11d1,0x90,0xa5,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"rpcProfile",                              {0x88611be1,0x8cf4,0x11d0,0xaf,0xda,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"unicodePwd",                              {0xbf9679e1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"linkTrackSecret",                         {0x2ae80fe2,0x47b4,0x11d0,0xa1,0xa4,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"typeLibrary",                             {0x281416e2,0x1968,0x11d0,0xa2,0x8f,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"syncWithObject",                          {0x037651e2,0x441d,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"ntPwdHistory",                            {0xbf9679e2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-RealRangeParam",                    {0x6afe8fe2,0x70bc,0x4cce,0xb1,0x66,0xa9,0x6f,0x73,0x59,0xc5,0x14}, 2},
{"defaultGroup",                            {0x720bc4e2,0xa54a,0x11d0,0xaf,0xdf,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msExchServer2AuthenticationPassword",     {0x266bc8e2,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"treatAsLeaf",                             {0x8fd044e3,0x771f,0x11d1,0xae,0xae,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"syncMembership",                          {0x037651e3,0x441d,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"nTSecurityDescriptor",                    {0xbf9679e3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"aCSNonReservedMaxSDUSize",                {0xaec2cfe3,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"syncAttributes",                          {0x037651e4,0x441d,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"distinguishedName",                       {0xbf9679e4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"syncWithSID",                             {0x037651e5,0x441d,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"objectClass",                             {0xbf9679e5,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-Name",                              {0xc6c8ace5,0x7e81,0x42af,0xad,0x72,0x77,0x41,0x2c,0x59,0x41,0xc4}, 2},
{"mSMQNt4Stub",                             {0x6f914be6,0xd57e,0x11d1,0x90,0xa2,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"objectClassCategory",                     {0xbf9679e6,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"objectGUID",                              {0xbf9679e7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"lastBackupRestorationTime",               {0x1fbb0be8,0xba63,0x11d0,0xaf,0xef,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"mSMQComputerTypeEx",                      {0x18120de8,0xf4c4,0x4341,0xbd,0x95,0x32,0xeb,0x5b,0xcf,0x7c,0x80}, 2},
{"msDS-Security-Group-Extra-Classes",       {0x4f146ae8,0xa4fe,0x4801,0xa7,0x31,0xf5,0x18,0x48,0xa4,0xf4,0xe4}, 2},
{"objectSid",                               {0xbf9679e8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-AllowSnapshotFilesFTPDownloading", {0xc49b8be8,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msExchServer2SchemaMap",                  {0x29d6c7e8,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"msExchNtdsImportContainer",               {0x1592cae8,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"mS-SQL-OLAPServer",                       {0x0c7e18ea,0xccef,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"mS-SQL-RegisteredOwner",                  {0x48fd44ea,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"oEMInformation",                          {0xbf9679ea,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-Applications",                     {0xfbcda2ea,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msExchServer2ExportContainers",           {0x27cca4ea,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"mSMQSignCertificatesMig",                 {0x3881b8ea,0xda3b,0x11d1,0x90,0xa5,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"msTAPI-uid",                              {0x70a4e7ea,0xb3b9,0x4643,0x89,0x18,0xe6,0xdd,0x24,0x71,0xbf,0xd4}, 2},
{"accountNameHistory",                      {0x031952ec,0x3b72,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"oMObjectClass",                           {0xbf9679ec,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"pKIOverlapPeriod",                        {0x1219a3ec,0x3b9e,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"eFSPolicy",                               {0x8e4eb2ec,0x4712,0x11d0,0xa1,0xa0,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msExchServer1AlwaysCreateAs",             {0x222efaec,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"creationWizard",                          {0x4d8601ed,0xac85,0x11d0,0xaf,0xe3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"oMSyntax",                                {0xbf9679ed,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"fileLinkTrackingEntry",                   {0x8e4eb2ed,0x4712,0x11d0,0xa1,0xa0,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"contextMenu",                             {0x4d8601ee,0xac85,0x11d0,0xaf,0xe3,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"fRSServiceCommand",                       {0xddac0cee,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"operatorCount",                           {0xbf9679ee,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"employeeNumber",                          {0xa8df73ef,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"o",                                       {0xbf9679ef,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"timeVolChange",                           {0xddac0cf0,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msExchServer2NetworkAddress",             {0x28d549f0,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"isEphemeral",                             {0xf4c453f0,0xc5f1,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"employeeType",                            {0xa8df73f0,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"ou",                                      {0xbf9679f0,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"pKTGuid",                                 {0x8447f9f0,0x1027,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"timeRefresh",                             {0xddac0cf1,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"otherLoginWorkstations",                  {0xbf9679f1,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msWMI-PolicyTemplate",                    {0xe2bc80f1,0x244a,0x4d59,0xac,0xc6,0xca,0x5c,0x4f,0x82,0xe6,0xe1}, 2},
{"pKT",                                     {0x8447f9f1,0x1027,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"seqNotification",                         {0xddac0cf2,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"Enabled",                                 {0xa8df73f2,0xc5ea,0x11d1,0xbb,0xcb,0x00,0x80,0xc7,0x66,0x70,0xc0}, 2},
{"middleName",                              {0xbf9679f2,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msExchSchemaMapPolicy",                   {0x348af8f2,0xa982,0x11d2,0xa9,0xff,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"dfsConfiguration",                        {0x8447f9f2,0x1027,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"oMTGuid",                                 {0xddac0cf3,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"owner",                                   {0xbf9679f3,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"fTDfs",                                   {0x8447f9f3,0x1027,0x11d0,0xa0,0x5f,0x00,0xaa,0x00,0x6c,0x33,0xed}, 2},
{"linkTrackVolumeTable",                    {0xddac0cf4,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"mS-SQL-Language",                         {0xc57f72f4,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"ownerBL",                                 {0xbf9679f4,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"mS-SQL-AppleTalk",                        {0x8fda89f4,0xccee,0x11d2,0x99,0x93,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msExchServer1AuthenticationCredentials",  {0x225ea9f4,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"msDS-Replication-Notify-First-DSA-Delay", {0x85abd4f4,0x0a89,0x4e49,0xbd,0xec,0x6f,0x35,0xbb,0x25,0x62,0xba}, 2},
{"printNumberUp",                           {0x3bcbfcf4,0x4d3d,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"linkTrackObjectMoveTable",                {0xddac0cf5,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msPKI-Minimal-Key-Size",                  {0xe96a63f5,0x417f,0x46d3,0xbe,0x52,0xdb,0x77,0x03,0xc5,0x03,0xdf}, 2},
{"msPKI-Template-Schema-Version",           {0x0c15e9f5,0x491d,0x4594,0x91,0x8f,0x32,0x81,0x3a,0x09,0x1d,0xa9}, 2},
{"printMediaReady",                         {0x3bcbfcf5,0x4d3d,0x11d0,0xa1,0xa6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"linkTrackVolEntry",                       {0xddac0cf6,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msExchServer1SchemaMap",                  {0x25193af6,0xb098,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"msExchSynchronizationDirection",          {0x20a151f6,0xb099,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"extensionAttribute11",                    {0x167757f6,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"msWMI-IntValidValues",                    {0x6af565f6,0xa749,0x4b72,0x96,0x34,0x3c,0x5d,0x47,0xe6,0xb4,0xe0}, 2},
{"pKIExtendedKeyUsage",                     {0x18976af6,0x3b9e,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"linkTrackOMTEntry",                       {0xddac0cf7,0xaf8f,0x11d0,0xaf,0xeb,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"msCOM-DefaultPartitionLink",              {0x998b10f7,0xaa1a,0x4364,0xb8,0x67,0x75,0x3d,0x19,0x7f,0xe6,0x70}, 2},
{"extensionAttribute12",                    {0x167757f7,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"physicalDeliveryOfficeName",              {0xbf9679f7,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msTAPI-IpAddress",                        {0xefd7d7f7,0x178e,0x4767,0x87,0xfa,0xf8,0xa1,0x6b,0x84,0x05,0x44}, 2},
{"msWMI-IntDefault",                        {0x1b0c07f8,0x76dd,0x4060,0xa1,0xe1,0x70,0x08,0x46,0x19,0xdc,0x90}, 2},
{"extensionAttribute13",                    {0x167757f8,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"pOPCharacterSet",                         {0xbf9679f8,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Allocate Rids",                           {0x1abd7cf8,0x0a99,0x11d1,0xad,0xbb,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"Remote Access Information",               {0x037088f8,0x0ae1,0x11d2,0xb4,0x22,0x00,0xa0,0xc9,0x68,0xf9,0x39}, 1},
{"extensionAttribute14",                    {0x167757f9,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"birthLocation",                           {0x1f0075f9,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"pOPContentFormat",                        {0xbf9679f9,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"aCSMaximumSDUSize",                       {0x87a2d8f9,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"mSMQSiteNameEx",                          {0x422144fa,0xc17f,0x4649,0x94,0xd6,0x97,0x31,0xed,0x27,0x84,0xed}, 2},
{"extensionAttribute15",                    {0x167757fa,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"oMTIndxGuid",                             {0x1f0075fa,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"possSuperiors",                           {0xbf9679fa,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"pKIMaxIssuingDepth",                      {0xf0bfdefa,0x3b9d,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"volTableIdxGUID",                         {0x1f0075fb,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"postOfficeBox",                           {0xbf9679fb,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"Change Infrastructure Master",            {0xcc17b1fb,0x33d9,0x11d2,0x97,0xd4,0x00,0xc0,0x4f,0xd8,0xd5,0xcd}, 1},
{"aCSMinimumLatency",                       {0x9517fefb,0x3b90,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"mS-SQL-ThirdParty",                       {0xc4e311fc,0xd34b,0x11d2,0x99,0x9a,0x00,0x00,0xf8,0x7a,0x57,0xd4}, 2},
{"msDS-Non-Security-Group-Extra-Classes",   {0x2de144fc,0x1f52,0x486f,0xbd,0xf4,0x16,0xfc,0xc3,0x08,0x4e,0x54}, 2},
{"currentLocation",                         {0x1f0075fc,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"postalAddress",                           {0xbf9679fc,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"controlAccessRights",                     {0x6da8a4fc,0x0e52,0x11d0,0xa2,0x86,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"volTableGUID",                            {0x1f0075fd,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"postalCode",                              {0xbf9679fd,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"dNSProperty",                             {0x675a15fe,0x3b70,0x11d2,0x90,0xcc,0x00,0xc0,0x4f,0xd9,0x1a,0xb1}, 2},
{"currMachineId",                           {0x1f0075fe,0x7e40,0x11d0,0xaf,0xd6,0x00,0xc0,0x4f,0xd9,0x30,0xc9}, 2},
{"preferredDeliveryMethod",                 {0xbf9679fe,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"auditingPolicy",                          {0x6da8a4fe,0x0e52,0x11d0,0xa2,0x86,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{"msExchDereferenceAliases",                {0x9d60e0fe,0xb093,0x11d2,0xaa,0x06,0x00,0xc0,0x4f,0x8e,0xed,0xd8}, 2},
{"forwardingAddress",                       {0x167757ff,0x47f3,0x11d1,0xa9,0xc3,0x00,0x00,0xf8,0x03,0x67,0xc1}, 2},
{"preferredOU",                             {0xbf9679ff,0x0de6,0x11d0,0xa2,0x85,0x00,0xaa,0x00,0x30,0x49,0xe2}, 2},
{ NULL, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 0}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\clntutl\src\helper.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       helper.c
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    File        : helper.c
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 9/17/1996
*    Description : common declarations
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef HELPER_C
#define HELPER_C



// include //
#include "helper.h"

// defines //



#ifdef __cplusplus
extern "C" {
#endif
// global variables //
DWORD g_dwDebugLevel=DBG_ERROR|DBG_WARN;




// functions //

/*+++
Function   : dprintf
Description: Debug print function
Parameters : variable args
Return     :
Remarks    : none.
---*/
void dprintf(DWORD dwLevel, LPCTSTR lpszFormat, ...){

#if DBG

	TCHAR szBuff[MAXSTR];
	va_list argList;

	
	if(dwLevel & g_dwDebugLevel){

		va_start(argList, lpszFormat);

		_vstprintf(szBuff, lpszFormat, argList);
		OutputDebugString(szBuff);
		OutputDebugString(_T("\r\n"));


		//
		// done
		//
		va_end(argList);
	}

#endif
}




/*+++
Function   : fatal
Description: fatal abort function
Parameters : debug port message
Return     :
Remarks    : none.
---*/
void fatal(LPCTSTR msg){

   dprintf(DBG_ALWAYS, _T("Fatal abort: %s"), msg);
   ExitProcess(0);
}


#ifdef __cplusplus
}
#endif




#endif

/******************* EOF *********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\clntutl\src\cfgstore.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       cfgstore.cxx
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    File        : cfgstore.cxx
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 3/9/1998
*    Description : Retrieves & stores domain configuration
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef CFGSTORE_CXX
#define CFGSTORE_CXX



// include //
#include "helper.h"
#include "excpt.hxx"
#include <winldap.h>
#include <ntldap.h>
#include <rpc.h>
#include <ntdsa.h>

#ifdef __cplusplus
extern "C" {
#endif
#include <winsock2.h>
#include <ipexport.h>
#include <icmpapi.h>

#ifdef __cplusplus
}
#endif

#ifdef _DEBUG_MEMLEAK
#include <crtdbg.h>
#endif


#include "cfgstore.hxx"


// defines //
#define VALIDATE(x)     if(!m_bValid) return x
#define INVALIDATE      m_bValid = FALSE

#define ICMP_TIMEOUT    500            // 300 ms for a icmp reply


// types //




/*+++
class   : DomainInfo
Description: Contain server basic information
---*/



DomainInfo::DomainInfo(LPTSTR pNcName,
                 LPTSTR pDnsRoot,
                 LPTSTR pFlatName,
                 LPTSTR pTrustParent_,
                 LPTSTR pPartition_)
                                   : m_pszNcName(pNcName),
                                     m_pszDnsRoot(pDnsRoot),
                                     m_pszFlatName(pFlatName),
                                     m_pszTrustParent(pTrustParent_),
                                     m_pszPartitionName(pPartition_) {

#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&s1);
#endif
}



DomainInfo::~DomainInfo(void){

   delete m_pszNcName;
   delete m_pszDnsRoot;
   delete m_pszFlatName;
   delete m_pszTrustParent;
   delete m_pszPartitionName;

#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&s2);
   if ( _CrtMemDifference( &s3, &s1, &s2 ) ){

    OutputDebugString("*** [DomainInfo] _CrtMemDifference detected memory leak ***\n");
    _CrtMemDumpStatistics( &s3 );
    _CrtMemDumpAllObjectsSince(&s3);
    OutputDebugString("*** [DomainInfo] end of dump ***\n");

   }
   ASSERT(_CrtCheckMemory());
#endif


}

/******************  SERVERINFO *******************/
/*+++
class   : ServerInfo
Description: Contain server basic information
---*/

/*+++
Function   : Constructor
Description:
Parameters :
Return     :
Remarks    : none.
---*/
ServerInfo::ServerInfo(LPTSTR Dest_, SEC_WINNT_AUTH_IDENTITY *pAuth_){

#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&s1);
#endif

   dprintf(DBG_FLOW, _T("Call: ServerInfo constructor\n"));
   InitDefaults();

   if(!logon(Dest_) || !LoadOperationalAttributes()){
      INVALIDATE;
   }
   else{
      //
      // good logon
      //

      m_lpszFlatName = Dest_;
      m_bValid = TRUE;
      m_bOwnLd = TRUE;
   }

}


ServerInfo::ServerInfo(LDAP *ld_){

#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&s1);
#endif

   dprintf(DBG_FLOW, _T("Call: ServerInfo constructor(2)\n"));
   InitDefaults();

   m_ld=ld_;
   m_bOwnLd = FALSE;

   if(!LoadOperationalAttributes()){
      INVALIDATE;
   }
   else{
      //
      // good logon
      //

      m_lpszFlatName = NULL;
      m_bValid = TRUE;
   }

}



/*+++
Function   : Destructor
Description:
Parameters :
Return     :
Remarks    : none.
---*/
ServerInfo::~ServerInfo(void){

   dprintf(DBG_FLOW, _T("Call: ServerInfo destructor\n"));

   if(m_bOwnLd)
       ldap_unbind(m_ld);
   delete m_lpszDsService;
   delete m_lpszServer;
   delete m_lpszSchemaNC;
   delete m_lpszDefaultNC;
   delete m_lpszConfigNC;
   delete m_lpszRootNC;
   delete m_lpszLdapService;
   delete m_lpszDomain;

#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&s2);
   if ( _CrtMemDifference( &s3, &s1, &s2 ) ){

    OutputDebugString("*** [ServerInfo] _CrtMemDifference detected memory leak ***\n");
    _CrtMemDumpStatistics( &s3 );
    _CrtMemDumpAllObjectsSince(&s3);
    OutputDebugString("*** [ServerInfo] end of dump ***\n");

   }
   ASSERT(_CrtCheckMemory());
#endif



}



/*+++
Function   : InitDefaults
Description:
Parameters :
Return     :
Remarks    : none.
---*/
VOID ServerInfo::InitDefaults(void){

   //
   // general
   //
   dprintf(DBG_FLOW, _T("Call: ServerInfo::InitDefaults\n"));
   m_bValid = TRUE;
   m_pAuth = NULL;
   m_ld = NULL;
   //
   // Operational Attributes info
   //
   m_lpszDsService = NULL;
   m_lpszServer = NULL;
   m_lpszSchemaNC = NULL;
   m_lpszConfigNC = NULL;
   m_lpszDefaultNC = NULL;
   m_lpszRootNC = NULL;
   m_lpszLdapService = NULL;
   m_lpszDomain=NULL;
   pDomainInfo=NULL;
   m_lpszFlatName = NULL;
   m_dwOptions = 0;
   m_bOwnLd = FALSE;
}



/*+++
Function   : ping
Description: Pings the specified server
Parameters : none
Return     : TRUE if any error condition or got the server
             FALSE if ping returned an error (0 icmp)
Remarks    : none.
---*/
BOOL ServerInfo::ping(LPTSTR pSvr){

   VALIDATE(m_bValid);
   BOOL bStatus = TRUE;
   IPAddr address;
   struct hostent *hostp = NULL;

   //
   // see if we have a valid server specified for icmpping
   //
   if(!pSvr)
      return TRUE;

   //
   // Get its address for icmpSendEcho
   //
   address = inet_addr(pSvr);
   if (address == -1L)
   {
       hostp = gethostbyname(pSvr);
       if (hostp)
       {
           address = *(long *)hostp->h_addr;
       }
       else
       {
          dprintf(DBG_ERROR, _T("Error<%lu>: cannot find server address %s.\n"),
                                                         WSAGetLastError(), pSvr);
          return FALSE;
       }
   }

   HANDLE hIcmp = IcmpCreateFile();

   if(hIcmp == INVALID_HANDLE_VALUE){
      dprintf(DBG_ERROR, _T("Error<%lu>: Cannot open Icmp handle\n"), GetLastError());
      bStatus = TRUE;
   }
   else{
      //
      // send echo req
      //
      DWORD dwStatus=0;
      const BYTE IcmpBuffer[] = {"IcmpEchoRequest"};
      const INT cIcmpBuffer   = 16;
      const INT cReplyBuffer = sizeof(ICMP_ECHO_REPLY)+24;
      LPBYTE pReplyBuffer = new BYTE[cReplyBuffer];
      assert(pReplyBuffer);



      dwStatus = IcmpSendEcho(hIcmp,
                              address,
                              (LPVOID)IcmpBuffer,
                              cIcmpBuffer,
                              NULL,
                              pReplyBuffer,
                              cReplyBuffer,
                              ICMP_TIMEOUT);
      if(dwStatus == 0){
         //
         // dead server
         //
         dprintf(DBG_WARN, _T("Warning <%lu>: IcmpSendEcho returned 0 entries\n"),
                                                               GetLastError());
         bStatus = FALSE;
      }
      else{
         //
         // Cool, it's alive
         //
         bStatus = TRUE;
      }

      delete pReplyBuffer;
   }
   IcmpCloseHandle(hIcmp);

   return bStatus;

}


/*+++
Function   : logon
Description: logs (ldap_open/bind) into the specified svr
Parameters : dest svr, can be NULL for default
Return     :
Remarks    : none.
---*/
BOOL ServerInfo::logon(LPTSTR pDest){

   ULONG ulStatus=0;

   dprintf(DBG_FLOW, _T("Call: ServerInfo::logon\n"));
   VALIDATE(m_bValid);

   if(pDest && !ping(pDest)){
      dprintf(DBG_FLOW, _T("Failed to ping %s\n"), pDest);
      INVALIDATE;
      return m_bValid;
   }

   m_ld = ldap_open(pDest, LDAP_PORT);
   if(m_ld){
      ulStatus = ldap_bind_s(m_ld, NULL, (LPTSTR)m_pAuth, LDAP_AUTH_SSPI);
      if(ulStatus != LDAP_SUCCESS){
         dprintf(DBG_WARN, _T("Warning: connected as anonymous\n"));
      }

      INT iChaseRefferal=0;
      ldap_set_option(m_ld, LDAP_OPT_REFERRALS, (PVOID)&iChaseRefferal);
   }
   else{
      INVALIDATE;
   }

   return m_bValid;
}


/*+++
Function   : LoadOperationalAttributes
Description:
Parameters :
Return     :
Remarks    : none.
---*/
BOOL ServerInfo::LoadOperationalAttributes(void){

   ULONG ulStatus = 0;
   LDAP_TIMEVAL tv={ 180, 0};
   LDAPMessage *pMsg=NULL, *pEntry;
   LPTSTR *pVal=NULL;

   dprintf(DBG_FLOW, _T("Call: ServerInfo::LoadOperationalAttributes\n"));
   VALIDATE(m_bValid);

   try{

      ulStatus = ldap_search_st(m_ld,
                                NULL,
                                LDAP_SCOPE_BASE,
                                _T("objectclass=*"),
                                NULL,
                                FALSE,
                                &tv,
                                &pMsg);

      if(ulStatus != LDAP_SUCCESS){
         throw (CLocalException(_T("Failed to get operational attributes"), LdapGetLastError()));
      }

      pEntry = ldap_first_entry(m_ld, pMsg);
      if(!pEntry){
         throw (CLocalException(_T("failed to process operational entry"), LdapGetLastError()));
      }

      pVal = ldap_get_values(m_ld, pMsg, _T("DsServiceName"));
      if(pVal != NULL && pVal[0] != NULL){
         m_lpszDsService = new TCHAR[_tcslen(pVal[0])+1];
         if (!m_lpszDsService) {
             throw(CLocalException(_T("Could not allocate memory!\n")));
         }

         _tcscpy(m_lpszDsService, pVal[0]);
      }
      else{
         throw (CLocalException(_T("Warning: failed to get DsServiceName"), LdapGetLastError()));
      }
      ldap_value_free(pVal);

      pVal = ldap_get_values(m_ld, pMsg, _T("ServerName"));
      if(pVal != NULL && pVal[0] != NULL){
         m_lpszServer = new TCHAR[_tcslen(pVal[0])+1];
         if (!m_lpszServer) {
             throw(CLocalException(_T("Could not allocate memory!\n")));
         }

         _tcscpy(m_lpszServer, pVal[0]);
      }
      else{
         throw (CLocalException(_T("failed to get ServerName")));
      }
      ldap_value_free(pVal);

      pVal = ldap_get_values(m_ld, pMsg, _T("ConfigurationNamingContext"));
      if(pVal != NULL && pVal[0] != NULL){
         m_lpszConfigNC = new TCHAR[_tcslen(pVal[0])+1];
         if (!m_lpszConfigNC) {
             throw(CLocalException(_T("Could not allocate memory!\n")));
         }

         _tcscpy(m_lpszConfigNC, pVal[0]);
      }
      else{
         throw (CLocalException(_T("failed to get ConfigurationNamingContext")));
      }
      ldap_value_free(pVal);


      pVal = ldap_get_values(m_ld, pMsg, _T("SchemaNamingContext"));
      if(pVal != NULL && pVal[0] != NULL){
         m_lpszSchemaNC = new TCHAR[_tcslen(pVal[0])+1];
         if (!m_lpszSchemaNC) {
             throw(CLocalException(_T("Could not allocate memory!\n")));
         }

         _tcscpy(m_lpszSchemaNC, pVal[0]);
      }
      else{
         throw (CLocalException(_T("failed to get SchemaNamingContext")));
      }
      ldap_value_free(pVal);

      pVal = ldap_get_values(m_ld, pMsg, _T("DefaultNamingContext"));
      if(pVal != NULL && pVal[0] != NULL){
         m_lpszDefaultNC = new TCHAR[_tcslen(pVal[0])+1];
         _tcscpy(m_lpszDefaultNC, pVal[0]);
      }
      else{
         throw (CLocalException(_T("failed to get DefaultNamingContext")));
      }
      ldap_value_free(pVal);



      pVal = ldap_get_values(m_ld, pMsg, _T("RootDomainNamingContext"));
      if(pVal != NULL && pVal[0] != NULL){
         m_lpszRootNC = new TCHAR[_tcslen(pVal[0])+1];
         _tcscpy(m_lpszRootNC, pVal[0]);
      }
      else{
         throw (CLocalException(_T("failed to get RootDomainNamingContext")));
      }
      ldap_value_free(pVal);

      pVal = ldap_get_values(m_ld, pMsg, _T("LdapServiceName"));
      if(pVal != NULL && pVal[0] != NULL){
         LPTSTR p1=NULL, p2=NULL;
         m_lpszLdapService = new TCHAR[_tcslen(pVal[0])+1];
         _tcscpy(m_lpszLdapService, pVal[0]);
         p1 = _tcschr(m_lpszLdapService, ':');
         if(p1){
            p1++;
            assert(p1!=NULL);
            p2 = _tcschr(p1, '\\');
            if(p2){
               //
               // old format
               //
               assert(p2!=NULL);
               m_lpszDomain = new TCHAR[(p2-p1)+1];
               _tcsncpy(m_lpszDomain, p1, sizeof(TCHAR)*(p2-p1));
            }
            else if((p2 = _tcschr(p1, '@')) != NULL){
               //
               // use new format
               //
               assert(p2);
               p2++;
               m_lpszDomain = new TCHAR[_tcslen(p2)+1];
               _tcscpy(m_lpszDomain, p2);
            }
            else{
               throw (CLocalException(_T("failed to parse LdapServiceName")));
            }
         }
      }
      else{
         throw (CLocalException(_T("failed to get LdapServiceName")));
      }
      ldap_value_free(pVal);



   } // try

   catch(CLocalException &e){
      //
      // PREFIX: PREFIX complains that we can potentially dereference the NULL
      // pointer e.  PREFIX appears to be just plain wrong here.  There is no
      // way that e can be NULL, and no way that either of it's two member
      // variables could be dereferenced as NULL.
      //
      dprintf(DBG_ERROR, _T("Error<%lu>: %s\n"), e.ulErr, e.msg? e.msg: _T("none"));
      INVALIDATE;
   }

   if(pMsg)
      ldap_msgfree(pMsg);

   return m_bValid;
}










/******************  CONFIGSTORE *******************/

/*+++
class   : ConfigStore
Description:
Remarks    : none.
---*/

ConfigStore::ConfigStore(LPTSTR pDest_){


#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&s1);
#endif



   m_bValid = TRUE;
   m_pDest=pDest_;


   if(CreateDomainList() &&
      CreateServerList() &&
      AssocDomainServers() &&
      CreateDomainHierarchy()){
      dprintf(DBG_FLOW, _T("Created configuration store\n"));
   }
   else{
      dprintf(DBG_ERROR, _T("Failed to create configuration store\n"));
   }
}




ConfigStore::ConfigStore(LDAP *ld){

#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&s1);
#endif


   m_bValid = TRUE;
   m_pDest=NULL;


   if(CreateDomainList(ld) &&
      CreateServerList(ld) &&
      AssocDomainServers() &&
      CreateDomainHierarchy()){
      dprintf(DBG_FLOW, _T("Created configuration store\n"));
   }
   else{
      dprintf(DBG_ERROR, _T("Failed to create configuration store\n"));
   }

}





/*+++
Function   : Destructor
Description: nothing to do here yet
Parameters :
Return     :
Remarks    : none.
---*/
ConfigStore::~ConfigStore(void){

   //
   // delete domain list
   //
   vector<DomainInfo*>::iterator itDmn;

   for(itDmn = DomainList.begin(); itDmn != DomainList.end(); itDmn++){
      delete (*itDmn);
   }
   if(!DomainList.empty()){
      DomainList.erase(DomainList.begin(), DomainList.end());
   }

   //
   // delete server list
   //
   vector<ServerInfo*>::iterator itSvr;
   for(itSvr = ServerList.begin(); itSvr != ServerList.end(); itSvr++){
      delete (*itSvr);
   }
   if(!ServerList.empty()){
      ServerList.erase(ServerList.begin(), ServerList.end());
   }



#ifdef _DEBUG_MEMLEAK
   _CrtMemCheckpoint(&s2);
   if ( _CrtMemDifference( &s3, &s1, &s2 ) ){

    OutputDebugString("*** [ConfigStore] _CrtMemDifference detected memory leak ***\n");
    _CrtMemDumpStatistics( &s3 );
    _CrtMemDumpAllObjectsSince(&s3);
    OutputDebugString("*** [ConfigStore] end of dump ***\n");

   }
   ASSERT(_CrtCheckMemory());
#endif


}



BOOL ConfigStore::CreateDomainList(LDAP *ld_){

   VALIDATE(FALSE);

   //
   // Create server for initial info
   //

   ServerInfo *svr=NULL;

   if(ld_){
      svr = new ServerInfo(ld_);
   }
   else{
      svr = new ServerInfo(m_pDest);
   }

   if(!svr || !svr->valid()){
     delete svr;
     return INVALIDATE;
   }

   LDAPMessage *res=NULL, *entry=NULL;
   LDAP_TIMEVAL tv = { 120, 0};
   ULONG ulErr = 0;
   LPTSTR attrs[] = { _T("dnsRoot"),
                      _T("nCName"),
                      _T("Name"),
                      _T("trustParent"),
                      NULL};
   LPTSTR *vals=NULL;
   INT i=0, iDomains=0;

   dprintf(DBG_FLOW, _T("Call: ConfigStore::CreateDomainList\n"));


   try{

      TCHAR szSysFlagVal[8];
      CHAR szFilter[MAXSTR];

      //
      // construct filter
      //
      _itoa(FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN, szSysFlagVal, 10);
      _stprintf(szFilter, _T("(& (objectClass=crossRef)(systemFlags:%s:=%s))"),
                         LDAP_MATCHING_RULE_BIT_AND,
                         szSysFlagVal);
//      CHAR szFilter[] = {_T("(& (objectClass=crossRef)(systemFlags=3))")};

      dprintf(DBG_FLOW, _T("Searching %s for domain partitions...\n"), svr->m_lpszConfigNC);
      ulErr = ldap_search_st(svr->ld(),
                           svr->m_lpszConfigNC,
                           LDAP_SCOPE_SUBTREE,
                           szFilter,
                           attrs,
                           FALSE,
                           &tv,
                           &res);
      if(ulErr != LDAP_SUCCESS){
         throw(CLocalException(ldap_err2string(ulErr), ulErr));
      }
      //
      // Count partitions
      //
      for(entry = ldap_first_entry(svr->ld(), res), iDomains=0;
          entry != NULL;
          entry = ldap_next_entry(svr->ld(), entry), iDomains++);

      if(iDomains == 0){
         throw(CLocalException(_T("Retrieved 0 partitions!\n")));
      }

      DomainList.reserve(iDomains);



      //
      // Prepare partition list
      //
      dprintf(DBG_FLOW, _T("retrieved %d domains\n"), iDomains);

      for(i=0, entry = ldap_first_entry(svr->ld(), res);
          entry != NULL;
          entry = ldap_next_entry(svr->ld(), entry), i++){

         LPTSTR pNcName = NULL, pDnsRoot=NULL, pFlatName=NULL;
         LPTSTR pTrustParent=NULL;

         //
         // Get partition name
         //
         LPTSTR pTmpDn = ldap_get_dn(svr->ld(), entry);
         assert(pTmpDn);
         LPTSTR pDn = new TCHAR[_tcslen(pTmpDn)+1];
         _tcscpy(pDn, pTmpDn);
         ldap_memfree(pTmpDn);

         //
         // Get DnsRoot
         //
         vals = ldap_get_values(svr->ld(), entry, _T("dnsRoot"));
         assert(vals != NULL && vals[0] != NULL);

         pDnsRoot = new TCHAR[_tcslen(vals[0])+sizeof(TCHAR)];
         assert(pDnsRoot);
         _tcscpy(pDnsRoot, vals[0]);
         dprintf(DBG_FLOW, _T("\tpDnsRoot[%d] = %s\n"), i, pDnsRoot);

         ldap_value_free(vals);


         //
         // Get nc name
         //
         vals = ldap_get_values(svr->ld(), entry, _T("nCName"));
         assert(vals != NULL && vals[0] != NULL);

         pNcName = new TCHAR[_tcslen(vals[0])+sizeof(TCHAR)];
         assert(pNcName);
         _tcscpy(pNcName, vals[0]);
         dprintf(DBG_FLOW, _T("\tpNcName[%d] = %s\n"), i, pNcName);

         ldap_value_free(vals);

         //
         // Get flat name
         //
         vals = ldap_get_values(svr->ld(), entry, _T("Name"));
         assert(vals != NULL && vals[0] != NULL);

         pFlatName = new TCHAR[_tcslen(vals[0])+sizeof(TCHAR)];
         assert(pFlatName);
         _tcscpy(pFlatName, vals[0]);
         dprintf(DBG_FLOW, _T("\tpFlatName[%d] = %s\n"), i, pFlatName);

         ldap_value_free(vals);

         //
         // Get trustParent
         //
         vals = ldap_get_values(svr->ld(), entry, _T("trustParent"));
         if(vals && vals[0]){

            //
            // none enterprise root: enterprise root, will not have a trust parent
            //
            pTrustParent = new TCHAR[_tcslen(vals[0])+sizeof(TCHAR)];
            assert(pTrustParent);
            _tcscpy(pTrustParent, vals[0]);
            dprintf(DBG_FLOW, _T("\tpTrustParent[%d] = %s\n"), i, pTrustParent);

            ldap_value_free(vals);
         }


         //
         // Create DomainInfo
         //
         DomainList.push_back(new DomainInfo(pNcName, pDnsRoot, pFlatName, pTrustParent, pDn));
      }
   }     // try
   catch(CLocalException &e){
      dprintf(DBG_ERROR, _T("Error<%lu>: %s\n"), e.ulErr, e.msg? e.msg: _T("none"));
      INVALIDATE;
   }

   ldap_msgfree(res);
   delete svr;

   return m_bValid;
}




/*+++
Function   : CreateServerList
Description: Query NTDS for a list of all servers.
Parameters :
Return     :
Remarks    : none.
---*/
BOOL ConfigStore::CreateServerList(LDAP *ld_){


   VALIDATE(NULL);
   //
   // Create server for initial info
   //

   ServerInfo *svr=NULL;
   BOOL bStatus = TRUE;

   if(ld_){
      svr = new ServerInfo(ld_);
   }
   else{
      svr = new ServerInfo(m_pDest);
   }

   if(!svr || !svr->valid()){
      delete svr;
      return INVALIDATE;
   }

   LDAPMessage *res=NULL, *entry=NULL;
   LDAP_TIMEVAL tv = { 120, 0};
   ULONG ulErr = 0;
   LPTSTR attrs[] = { _T("Name"), NULL};

   LPTSTR *vals=NULL;
   INT i=0, iServers=0;

   dprintf(DBG_FLOW, _T("Call: ConfigStore::CreateServerList\n"));


   try{

      dprintf(DBG_FLOW, _T("Searching %s for servers...\n"), svr->m_lpszConfigNC);
      ulErr = ldap_search_st(svr->ld(),
                           svr->m_lpszConfigNC,
                           LDAP_SCOPE_SUBTREE,
                           _T("objectClass=Server"),
                           attrs,
                           FALSE,
                           &tv,
                           &res);
      if(ulErr != LDAP_SUCCESS){
         throw(CLocalException(ldap_err2string(ulErr), ulErr));
      }
      //
      // Count servers
      //
      for(entry = ldap_first_entry(svr->ld(), res), iServers=0;
          entry != NULL;
          entry = ldap_next_entry(svr->ld(), entry), iServers++);

      if(iServers == 0){
         ldap_msgfree(res);
         throw(CLocalException(_T("Retrieved 0 servers!\n")));
      }


      ServerList.reserve(iServers);


      //
      // Prepare server list
      // Any Server will be in the least. If it isn't nTDSDSA, it'll show up
      // an non-connected since ldap-based load will fail.
      //
      dprintf(DBG_FLOW, _T("retrieved %d servers\n"), iServers);

      for(i=0, entry = ldap_first_entry(svr->ld(), res);
          entry != NULL;
          entry = ldap_next_entry(svr->ld(), entry), i++){

         LPTSTR pFlatName=NULL;

         //
         // Get flat name
         //
         vals = ldap_get_values(svr->ld(), entry, _T("Name"));
         assert(vals != NULL && vals[0] != NULL);

         pFlatName = new TCHAR[_tcslen(vals[0])+sizeof(TCHAR)];
         assert(pFlatName);
         _tcscpy(pFlatName, vals[0]);
         dprintf(DBG_FLOW, _T("\tpFlatName[%d] = %s\n"), i, pFlatName);

         ldap_value_free(vals);

         //
         // Create ServerInfo & add to list
         //
         ServerInfo *pCurrSvr= new ServerInfo(pFlatName);
         if(!pCurrSvr->valid()){
            dprintf(DBG_ERROR, _T("Error: Cannot connect to server %s\n"), pFlatName);
            pCurrSvr->m_lpszFlatName = pFlatName;
         }
         //
         // Get minimal info but leave in invalid state
         //
         LPTSTR dn = ldap_get_dn(svr->ld(), entry);
         bStatus = LoadNTDSDsaServer(svr->ld(), dn, pCurrSvr);
         dprintf(DBG_FLOW, _T("LoadUnavailServer returned 0x%X\n"), bStatus);
         ldap_memfree(dn);

         ServerList.push_back(pCurrSvr);
      }

      //
      // Associate domains w/ servers
      //
   }     // try
   catch(CLocalException &e){
      dprintf(DBG_ERROR, _T("Error<%lu>: %s\n"), e.ulErr, e.msg? e.msg: _T("none"));
      INVALIDATE;
   }

   ldap_msgfree(res);
   delete svr;

   return m_bValid;
}



BOOL ConfigStore::LoadNTDSDsaServer(LDAP *ld, LPTSTR dn, ServerInfo *pSvr){

   LDAPMessage *res=NULL, *entry=NULL;
   LDAP_TIMEVAL tv = { 120, 0};
   ULONG ulErr = 0;
   LPTSTR attrs[] = { _T("hasMasterNCs"),
                      _T("Options"),
                      NULL};

   LPTSTR *vals=NULL;
   INT i=0;
   INT cbVals=0;

   dprintf(DBG_FLOW, _T("Call: ConfigStore::LoadNTDSDsaServer\n"));


   try{

      //
      // Loading nTDSDSA server
      //
      dprintf(DBG_FLOW, _T("Searching %s for ntdsdsa...\n"), dn);
      ulErr = ldap_search_st(ld,
                           dn,
                           LDAP_SCOPE_ONELEVEL,
                           _T("objectClass=nTDSDSA"),
                           attrs,
                           FALSE,
                           &tv,
                           &res);
      if(ulErr != LDAP_SUCCESS){
         throw(CLocalException(ldap_err2string(ulErr), ulErr));
      }
      //
      // Count servers
      //
      entry = ldap_first_entry(ld, res);
      if(!entry){
         throw(CLocalException(ldap_err2string(ulErr), ulErr));
      }

      if(!pSvr->valid()){
         //
         // Get NC's for unavailable servers (avail ones get NC's at connect from
         // operational attributes query
         //
         vals = ldap_get_values(ld, entry, _T("hasMasterNCs"));
         assert(vals != NULL && vals[0] != NULL);

         cbVals = ldap_count_values(vals);
         assert(cbVals != 0);

         for(i=0; i<cbVals; i++){
            assert(vals[i]);
            if(!_tcsnicmp(_T("CN=Schema"), vals[i], _tcslen(_T("CN=Schema")))){
               //
               // got schema
               //
               pSvr->m_lpszSchemaNC = new TCHAR[_tcslen(vals[i])+1];
               if (!pSvr->m_lpszSchemaNC) {
                   throw(CLocalException(_T("Could not allocate memory!\n")));
               }
               
               _tcscpy(pSvr->m_lpszSchemaNC, vals[i]);
            }
            else if(!_tcsnicmp(_T("CN=Configuration"), vals[i], _tcslen(_T("CN=Configuration")))){
               //
               // got Config
               //
               pSvr->m_lpszConfigNC = new TCHAR[_tcslen(vals[i])+1];
               if (!pSvr->m_lpszConfigNC) {
                   throw(CLocalException(_T("Could not allocate memory!\n")));
               }
               
               _tcscpy(pSvr->m_lpszConfigNC, vals[i]);
            }
            else{
               //
               // got data NC
               //
               pSvr->m_lpszDefaultNC = new TCHAR[_tcslen(vals[i])+1];
               if (!pSvr->m_lpszDefaultNC) {
                   throw(CLocalException(_T("Could not allocate memory!\n")));
               }

               _tcscpy(pSvr->m_lpszDefaultNC, vals[i]);
            }
         }

         ldap_value_free(vals);
      }

      //
      // Get NTDSDSA Options
      //
      vals = ldap_get_values(ld, entry, _T("Options"));
      if(vals != NULL && vals[0] != NULL){
         //
         // Options exist
         //
         pSvr->m_dwOptions = (DWORD)atol(vals[0]);

      }
      ldap_value_free(vals);


   }     // try
   catch(CLocalException &e){
      //
      // PREFIX: PREFIX complains that we can potentially dereference the NULL
      // pointer e.  PREFIX appears to be just plain wrong here.  There is no
      // way that e can be NULL, and no way that either of it's two member
      // variables could be dereferenced as NULL.
      //
      dprintf(DBG_WARN, _T("Warning<%lu>: %s\n"), e.ulErr, e.msg? e.msg: _T("none"));
   }

   ldap_msgfree(res);

   return m_bValid;

}


/*+++
Function   : CreateDomainHierarchy
Description: link domain list in a hierarchy
Parameters :
Return     :
Remarks    : none.
---*/
BOOL ConfigStore::CreateDomainHierarchy(void){

   INT i=0;

   dprintf(DBG_FLOW, _T("Call: ConfigStore::CreateDomainHierarchy\n"));
   VALIDATE(m_bValid);

   if(DomainList.size() == 0 || ServerList.size() == 0){
      dprintf(DBG_ERROR, _T("Error: found %d domains & %d servers. aborting\n"),
                                         DomainList.size(), ServerList.size());
      return INVALIDATE;
   }


   //
   // traverse all domains:
   // - no trust parent => root domain (nothing to do)
   // - if we have a trust parent, find it's domainInfo object & add it to that guys
   //   child list
   //
   for(i=0; i<DomainList.size(); i++){
      LPTSTR pUpDn = (LPTSTR)DomainList[i]->GetTrustParent();
      vector<DomainInfo*>::iterator itDmn;

      if(pUpDn == NULL)
         continue;

      if(DomainList.end() !=
         (itDmn = find_if(DomainList.begin(), DomainList.end(), IsDomain(pUpDn)))){
         //
         // (*itDmn) is the parent of DomainList[i]
         //
         (*itDmn)->ChildDomainList.push_back(DomainList[i]);
      }
   }

   return m_bValid;
}


/*+++
Function   : AssocDomainServers
Description: link (associate) a domain w/ a list of svrs & a server w/ it's parent domain
Parameters :
Return     :
Remarks    : none.
---*/
BOOL ConfigStore::AssocDomainServers(void){

   VALIDATE(m_bValid);
   INT iDmn=0, iSvr=0;

   //
   // for all domains
   //
   for(iDmn= 0; iDmn < DomainList.size(); iDmn++){

      //
      // for all servers
      //
      for(iSvr= 0; iSvr<ServerList.size(); iSvr++){
         if(ServerList[iSvr]->m_lpszDefaultNC && DomainList[iDmn]->GetNCName()){
            //
            // we have valid strings to compare NC's with.
            //
            if(!_tcsicmp(ServerList[iSvr]->m_lpszDefaultNC, DomainList[iDmn]->GetNCName())){
               //
               // got a match
               //
               DomainList[iDmn]->ServerList.push_back(ServerList[iSvr]);
               ServerList[iSvr]->pDomainInfo = DomainList[iDmn];
            }
         }
      }
   }

#if 0
   // ***** BUGBUG: debugging. Rm later. Seems consistent for now *****
   //
   // for all domains
   //
   vector<DomainInfo*>::iterator itDmn;
   vector<ServerInfo*>::iterator itSvr;
   _tprintf(_T("Domain DC list\n"));
   for(itDmn= DomainList.begin();
       itDmn != DomainList.end();
       itDmn++){

      _tprintf(_T("\nDomain %s is hosted on:\n"), (*itDmn)->GetFlatName());
      //
      // for all servers
      //
      for(itSvr= (*itDmn)->ServerList.begin();
          itSvr != (*itDmn)->ServerList.end();
          itSvr++){
            _tprintf(_T(" %s\n"), (*itSvr)->m_lpszFlatName);
            _tprintf(_T(" (pointing back at:%s)\n"), (*itSvr)->pDomainInfo->GetFlatName());
      }
   }
#endif

   return m_bValid;
}




/*+++
Function   : GetServerList
Description: Retrive the associated server list of a domain
Parameters : lpDomain: name of domain; ServerList: OUT required server list
Return     : TRUE if we found it, FALSE otherwise
Remarks    : none.
---*/
BOOL ConfigStore::GetServerList(LPTSTR lpDomain, vector<ServerInfo*> &ServerList){

   BOOL bStatus = FALSE;

   vector<DomainInfo*>::iterator itDmn;

   if(lpDomain){
      if(DomainList.end() !=
         (itDmn = find_if(DomainList.begin(), DomainList.end(), IsDomain(lpDomain)))){
         ServerList = (*itDmn)->ServerList;
         bStatus = TRUE;
      }
      else{
         //
         // Couldn't find any domain
         //
         bStatus = FALSE;
      }

   }

   return bStatus;
}


#endif

/******************* EOF *********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\bootopt\lib\intel.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    intel.c

Abstract:

    This module implements functions to detect the system partition drive and
    providing extra options in boot.ini for NTDS setup on intel platform.

Author:

    R.S. Raghavan (rsraghav)    

Revision History:
    
    Created             10/07/96    rsraghav

--*/

// Include files
#include "common.h"

#define MAX_KEY_LEN (MAX_BOOT_PATH_LEN + MAX_BOOT_DISPLAY_LEN + MAX_BOOT_START_OPTIONS_LEN + 5) // 5 -> =,",",sp,null
#define MAX_KEY_VALUE_LEN (MAX_BOOT_DISPLAY_LEN + MAX_BOOT_START_OPTIONS_LEN + 1)

#define INITIAL_OSSECTION_SIZE      (2048)
#define DEFAULT_OSSECTION_INCREMENT (1024)


// used to eliminate old option in boot.ini
#define OLD_SAMUSEREG_OPTION    L" /SAMUSEREG"
#define OLD_SAMUSEREG_OPTION_2  L" /DEBUG /SAMUSEREG"
#define OLD_SAMUSEREG_OPTION_3  L" /DEBUG /SAMUSEDS"
#define OLD_SAMUSEREG_OPTION_4  L" /DEBUG /SAFEMODE"


//  BOOT_KEY    - structure representing a complete boot option with the arc path, display string, and start options
typedef  struct _BOOT_KEY
{
    TCHAR       szPath[MAX_BOOT_PATH_LEN];
    TCHAR       szDisplay[MAX_BOOT_DISPLAY_LEN];
    TCHAR       szStartOptions[MAX_BOOT_START_OPTIONS_LEN];
    BOOLEAN     fWriteBack;
} BOOT_KEY;

BOOT_KEY        *BootKey = NULL;
DWORD           cBootKeys = 0;
DWORD           cMaxBootKeys = 0;

TCHAR           *szOSSection = NULL;
DWORD           cchOSSection = 0;

// Constants used for boot.ini parsing
TCHAR szBootIni[]     = TEXT("?:\\boot.ini");
TCHAR szOS[]          = TEXT("operating systems");


BOOL GetPartitionInfo(
    IN  TCHAR                  Drive,
    OUT PPARTITION_INFORMATION PartitionInfo
    )
{
    TCHAR DriveName[] = TEXT("\\\\.\\?:");
    HANDLE hDisk;
    BOOL b;
    DWORD DataSize;

    DriveName[4] = Drive;

    hDisk = CreateFile (
                DriveName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if (hDisk == INVALID_HANDLE_VALUE)
    {
        return(FALSE);
    }

    b = DeviceIoControl (
            hDisk,
            IOCTL_DISK_GET_PARTITION_INFO,
            NULL,
            0,
            PartitionInfo,
            sizeof(PARTITION_INFORMATION),
            &DataSize,
            NULL
            );

    CloseHandle (hDisk);

    return (b);
}



UINT MyGetDriveType (IN TCHAR Drive)
{
    TCHAR DriveNameNt[] = TEXT("\\\\.\\?:");
    TCHAR DriveName[] = TEXT("?:\\");
    HANDLE hDisk;
    BOOL b;
    UINT rc;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;

    //
    // First, get the win32 drive type.  If it tells us DRIVE_REMOVABLE,
    // then we need to see whether it's a floppy or hard disk.  Otherwise
    // just believe the api.
    //
    //
    DriveName[0] = Drive;

    if ((rc = GetDriveType (DriveName)) == DRIVE_REMOVABLE) {

        DriveNameNt[4] = Drive;

        hDisk = CreateFile (
                    DriveNameNt,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

        if (hDisk != INVALID_HANDLE_VALUE)
        {
            b = DeviceIoControl (
                    hDisk,
                    IOCTL_DISK_GET_DRIVE_GEOMETRY,
                    NULL,
                    0,
                    &MediaInfo,
                    sizeof(MediaInfo),
                    &DataSize,
                    NULL
                    );

            //
            // It's really a hard disk if the media type is removable.
            //
            if (b && (MediaInfo.MediaType == RemovableMedia))
            {
                rc = DRIVE_FIXED;
            }

            CloseHandle (hDisk);
        }
    }

    return(rc);
}


PWSTR ArcPathToNtPath (IN PWSTR ArcPath)
{
    NTSTATUS Status;
    HANDLE ObjectHandle;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    UCHAR Buffer[1024];
    PWSTR arcPath = NULL;
    PWSTR ntPath = NULL;

    //
    // Assume failure
    //
    ntPath = NULL;

    arcPath = MALLOC(((wcslen(ArcPath)+1)*sizeof(WCHAR)) + sizeof(L"\\ArcName"));
    if (NULL == arcPath)
    {
        goto Error;
    }
    wcscpy (arcPath, L"\\ArcName\\");
    wcscat (arcPath, ArcPath);

    RtlInitUnicodeString (&UnicodeString, arcPath);

    InitializeObjectAttributes (
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenSymbolicLinkObject (
                &ObjectHandle,
                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                &Obja
                );

    if (NT_SUCCESS(Status))
    {
        //
        // Query the object to get the link target.
        //
        UnicodeString.Buffer = (PWSTR)Buffer;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = sizeof(Buffer);

        Status = NtQuerySymbolicLinkObject (
                    ObjectHandle,
                    &UnicodeString,
                    NULL
                    );

        if (NT_SUCCESS(Status))
        {
            ntPath = MALLOC(UnicodeString.Length+sizeof(WCHAR));
            
            if (NULL == ntPath)
            {
                goto Error;
            }

            CopyMemory(ntPath,UnicodeString.Buffer,UnicodeString.Length);

            ntPath[UnicodeString.Length/sizeof(WCHAR)] = 0;
        }

        NtClose (ObjectHandle);
    }

Error:

    if (arcPath)
    {
        FREE (arcPath);
    }

    return (ntPath);
}

BOOL AppearsToBeSysPart(
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout,
    IN WCHAR                     Drive
    )
{
    PARTITION_INFORMATION PartitionInfo,*p;
    BOOL IsPrimary;
    unsigned i;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;

    PTSTR BootFiles[] = { TEXT("BOOT.INI"),
                          TEXT("NTLDR"),
                          TEXT("NTDETECT.COM"),
                          NULL
                        };

    TCHAR FileName[64];

    //
    // Get partition information for this partition.
    //
    if (!GetPartitionInfo((TCHAR)Drive,&PartitionInfo))
    {
        return(FALSE);
    }

    //
    // See if the drive is a primary partition.
    //
    IsPrimary = FALSE;

    for (i=0; i<min(DriveLayout->PartitionCount,4); i++)
    {
        p = &DriveLayout->PartitionEntry[i];

        if((p->PartitionType != PARTITION_ENTRY_UNUSED)
          && (p->StartingOffset.QuadPart == PartitionInfo.StartingOffset.QuadPart)
          && (p->PartitionLength.QuadPart == PartitionInfo.PartitionLength.QuadPart))
        {
            IsPrimary = TRUE;
            break;
        }
    }

    if (!IsPrimary)
    {
        return(FALSE);
    }

    //
    // Don't rely on the active partition flag.  This could easily not be
    // accurate (like user is using os/2 boot manager, for example).
    //

    //
    // See whether an nt boot files are present on this drive.
    //
    for (i=0; BootFiles[i]; i++)
    {
        wsprintf (FileName, TEXT("%wc:\\%s"), Drive, BootFiles[i]);

        FindHandle = FindFirstFile (FileName, &FindData);

        if (FindHandle == INVALID_HANDLE_VALUE)
        {
            return (FALSE);
        }
        else
        {
            FindClose (FindHandle);
        }
    }

    return (TRUE);
}

/*************************************************************************************

Routine Description:

    Determine the system partition on x86 machines.

    The system partition is the primary partition on the boot disk.
    Usually this is the active partition on disk 0 and usually it's C:.
    However the user could have remapped drive letters and generally
    determining the system partition with 100% accuracy is not possible.

    The one thing we can be sure of is that the system partition is on
    the physical hard disk with the arc path multi(0)disk(0)rdisk(0).
    We can be sure of this because by definition this is the arc path
    for bios drive 0x80.

    This routine determines which drive letters represent drives on
    that physical hard drive, and checks each for the nt boot files.
    The first drive found with those files is assumed to be the system
    partition.

    If for some reason we cannot determine the system partition by the above
    method, we simply assume it's C:.

Arguments:

Return Value:

    Drive letter of system partition.

**************************************************************************************/

TCHAR GetX86SystemPartition()
{
    BOOL  GotIt;
    PWSTR NtDevicePath = NULL;
    WCHAR Drive = L'\0';
    WCHAR DriveName[3];
    WCHAR Buffer[512];
    DWORD NtDevicePathLen;
    PWSTR p;
    DWORD PhysicalDriveNumber;
    HANDLE hDisk;
    BOOL  b =FALSE;
    DWORD DataSize;
    PVOID DriveLayout = NULL;
    DWORD DriveLayoutSize;

    DriveName[1] = L':';
    DriveName[2] = 0;

    GotIt = FALSE;

    //
    // The system partition must be on multi(0)disk(0)rdisk(0)
    //
    if (NtDevicePath = ArcPathToNtPath (L"multi(0)disk(0)rdisk(0)"))
    {
        //
        // The arc path for a disk device is usually linked
        // to partition0.  Get rid of the partition part of the name.
        //
        CharLowerW (NtDevicePath);

        if (p = wcsstr (NtDevicePath, L"\\partition"))
        {
            *p = 0;
        }

        NtDevicePathLen = lstrlenW (NtDevicePath);

        //
        // Determine the physical drive number of this drive.
        // If the name is not of the form \device\harddiskx then
        // something is very wrong.
        //
        if (!wcsncmp (NtDevicePath, L"\\device\\harddisk", 16))
        {
            PhysicalDriveNumber = wcstoul (NtDevicePath+16, NULL, 10);

            wsprintfW (Buffer, L"\\\\.\\PhysicalDrive%u", PhysicalDriveNumber);

            //
            // Get drive layout info for this physical disk.
            //
            hDisk = CreateFileW (
                        Buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

            if (hDisk != INVALID_HANDLE_VALUE)
            {
                //
                // Get partition information.
                //
                DriveLayout = MALLOC(1024);
                DriveLayoutSize = 1024;

                do
                {

                    b = DeviceIoControl (
                            hDisk,
                            IOCTL_DISK_GET_DRIVE_LAYOUT,
                            NULL,
                            0,
                            DriveLayout,
                            DriveLayoutSize,
                            &DataSize,
                            NULL
                            );

                    if (!b && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
                    {
                        // DeviceIoControl failed because we have insufficient buffer
                        // => attempt to realloc

                        PVOID pTemp = DriveLayout;

                        DriveLayoutSize += 1024;
                        DriveLayout = REALLOC(DriveLayout,DriveLayoutSize);

                        if (NULL == DriveLayout)
                        {
                            // realloc failed - free the old layout and we will fall out of the loop
                            // automatically.
                            FREE(pTemp);
                        }
                    }
                    else 
                    {
                        // DeviceIoControl was successful or we hit some error other
                        // than insufficient buffer => break out of the loop
                        break;
                    }
                } while (DriveLayout);

                CloseHandle (hDisk);

                if (b)
                {
                    //
                    // The system partition can only be a drive that is on
                    // this disk.  We make this determination by looking at NT drive names
                    // for each drive letter and seeing if the nt equivalent of
                    // multi(0)disk(0)rdisk(0) is a prefix.
                    //
                    for (Drive=L'C'; Drive<=L'Z'; Drive++)
                    {
                        if (MyGetDriveType ((TCHAR)Drive) == DRIVE_FIXED)
                        {
                            DriveName[0] = Drive;

                            if (QueryDosDeviceW (DriveName, Buffer, sizeof(Buffer)/sizeof(WCHAR)))
                            {
                                if (!_wcsnicmp (NtDevicePath, Buffer, NtDevicePathLen))
                                {
                                    //
                                    // Now look to see whether there's an nt boot sector and
                                    // boot files on this drive.
                                    //
                                    if (AppearsToBeSysPart(DriveLayout,Drive))
                                    {
                                        GotIt = TRUE;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                if (DriveLayout)
                {
                    FREE(DriveLayout);
                }
            }
        }

        FREE(NtDevicePath);
    }


    return (GotIt ? (TCHAR)Drive : TEXT('C'));
}


/*************************************************************************************

Routine Description:

    Initializes all the boot keys in BootKey array by parsing boot.ini.


Arguments:

Return Value:

    None.

**************************************************************************************/

VOID InitializeBootKeysForIntel()
{
    DWORD   dwFileAttrSave;
    TCHAR   *pszKey;
    TCHAR   *pszNext;
    TCHAR   *pszDisplay;
    TCHAR   *pszStartOption;

    // First get the System Partition drive so that we can fetch boot.ini from the right place
    szBootIni[0] = GetX86SystemPartition();

    // Save the current file attributes of boot.ini and modify it so that we can write to it
    dwFileAttrSave = GetFileAttributes(szBootIni);
    SetFileAttributes(szBootIni, FILE_ATTRIBUTE_NORMAL);

    // Get the entire OS section from boot.ini
    cchOSSection = INITIAL_OSSECTION_SIZE;
    szOSSection = (TCHAR *) MALLOC(cchOSSection * sizeof(TCHAR));
    if (!szOSSection)
    {
        cchOSSection = 0;
        goto Leave;
    }

    // safe-guard initialization
    szOSSection[0] = TEXT('\0');


    while ( GetPrivateProfileSection(szOS, szOSSection, cchOSSection, szBootIni) == (cchOSSection - 2))
    {
        TCHAR *szOSSectionSave = szOSSection; 

        // szOSSection is not large enough to hold all the data in the section
        cchOSSection += DEFAULT_OSSECTION_INCREMENT;
        szOSSection = (TCHAR *) REALLOC(szOSSection, cchOSSection * sizeof(TCHAR));
        if (!szOSSection)
        {
            FREE(szOSSectionSave);
            cchOSSection = 0;
            goto Leave;
        }
    }

    // We have successfully read the OSSection - proceed to process it

    // Point pszKey to the start of the first string in the OS Section
    pszKey = &szOSSection[0];

    // We are starting with zero Boot Keys
    cBootKeys = 0;

    while (*pszKey != TEXT('\0'))
    {
        // There is at least one more key to add - see if we have enough space & reallocate if needed
        if (!BootKey)
        {
            cMaxBootKeys = INITIAL_KEY_COUNT;
            BootKey = (BOOT_KEY *) MALLOC(cMaxBootKeys * sizeof(BOOT_KEY));
            if (!BootKey)
            {
                cBootKeys = 0;
                cMaxBootKeys = 0;
                goto Leave;
            }
        }
        else if (cBootKeys >= cMaxBootKeys)
        {
            BOOT_KEY *BootKeySave = BootKey;

            cMaxBootKeys += DEFAULT_KEY_INCREMENT;
            BootKey = (BOOT_KEY *) REALLOC(BootKey,cMaxBootKeys * sizeof(BOOT_KEY));
            if (!BootKey)
            {
                FREE(BootKeySave);
                cBootKeys = 0;
                cMaxBootKeys = 0;
                goto Leave;
            }
        }

        // find the start of next string for next iteration (need to save this as we write 
        // into the current string
        pszNext = pszKey + lstrlen(pszKey) + 1;

        // Initialize the components of the current boot option that we are going to process
        BootKey[cBootKeys].szPath[0] = TEXT('\0');
        BootKey[cBootKeys].szDisplay[0] = TEXT('\0');
        BootKey[cBootKeys].szStartOptions[0] = TEXT('\0');
        BootKey[cBootKeys].fWriteBack = TRUE;

        // Locate the '=' marker
        pszDisplay = wcschr(pszKey, TEXT('='));
        if (pszDisplay)
        {
            *pszDisplay = TEXT('\0');
            
            pszDisplay++;

            // now pszDisplay is pointing to the first char in the value part - find the second quote
            pszStartOption = wcschr(pszDisplay, TEXT('"'));
            if (pszStartOption)
                pszStartOption = wcschr(pszStartOption+1, TEXT('"'));

            if (pszStartOption)
                pszStartOption++;

            // Now pszStartOption is pointing the char after the second quote
            if (pszStartOption && *pszStartOption != TEXT('\0'))
            {
                // this key has start options copy the start option first
                lstrcpy(&BootKey[cBootKeys].szStartOptions[0], pszStartOption);

                // put null in the first char of pszStartOption so that we can have null terminated display string 
                *pszStartOption = TEXT('\0');
            }

            // pszDisplay is still pointing to the first char in the value part and the end of display string
            // is null-terminated now
            lstrcpy(&BootKey[cBootKeys].szDisplay[0], pszDisplay);
        }

        // pszKey is still pointing to the first char of path and it is null-terminated at '=' sign if there was
        // an associated value
        lstrcpy(&BootKey[cBootKeys].szPath[0], pszKey);

        // finished processing the current key -  update cBootKeys and go to the next key
        ++cBootKeys;
        pszKey = pszNext;

    }  // while (*pszKey)

Leave:
    
    // Restore the file attributes on boot.ini
    SetFileAttributes(szBootIni, dwFileAttrSave);

}

BOOL
FModifyStartOptionsToBootKey(
    IN TCHAR *pszStartOptions, 
    IN NTDS_BOOTOPT_MODTYPE Modification
    )
{
    TCHAR szSystemRoot[MAX_BOOT_PATH_LEN];
    TCHAR szCurrentFullArcPath[MAX_BOOT_PATH_LEN];
    TCHAR szCurrentFullArcPath2[MAX_BOOT_PATH_LEN];
    TCHAR szDriveName[MAX_DRIVE_NAME_LEN];
    PWSTR pstrArcPath;
    DWORD i;
    BOOL  fFixedExisting = FALSE;
    BOOL  fMatchedFirst = TRUE;
    PWSTR pstrSystemRootDevicePath = NULL;
    BOOL  fRemovedAtLeastOneEntry = FALSE;

    if (!pszStartOptions || !BootKey)
    {
        KdPrint(("NTDSETUP: Unable to add the boot option for safemode boot\n"));

            return FALSE;
    }

    ASSERT( Modification == eAddBootOption || Modification == eRemoveBootOption );

    GetEnvironmentVariable(L"SystemDrive", szDriveName, MAX_DRIVE_NAME_LEN);
    GetEnvironmentVariable(L"SystemRoot", szSystemRoot, MAX_BOOT_PATH_LEN);

    pstrSystemRootDevicePath = GetSystemRootDevicePath();
    if (!pstrSystemRootDevicePath)
        return FALSE;

    pstrArcPath  = DevicePathToArcPath(pstrSystemRootDevicePath, FALSE);

    if (pstrArcPath)
    {
        PWSTR pstrTemp;

        lstrcpy(szCurrentFullArcPath, pstrArcPath);
        FREE(pstrArcPath);

        pstrTemp = wcschr(szSystemRoot, TEXT(':'));
        if (pstrTemp)
            lstrcat(szCurrentFullArcPath, pstrTemp+1);

        // Get a second Full Arc path if one exists
        szCurrentFullArcPath2[0] = TEXT('\0');
        pstrArcPath = DevicePathToArcPath(pstrSystemRootDevicePath, TRUE);
        if (pstrArcPath)
        {
            lstrcpy(szCurrentFullArcPath2, pstrArcPath);
            FREE(pstrArcPath);
            if (pstrTemp)
                lstrcat(szCurrentFullArcPath2, pstrTemp+1);
        }
    }
    else 
    {
        KdPrint(("NTDSETUP: Unable to add the boot option for safemode boot\n"));
            return FALSE;
    }

    if (pstrSystemRootDevicePath)
        FREE(pstrSystemRootDevicePath);

    // szCurrentFullArcPath contains the complete arc path now
    // check to see if there already a corresponding entry which has the same start option
    for (i = 0; i < cBootKeys; i++)
    {
        if (!lstrcmpi(szCurrentFullArcPath, BootKey[i].szPath) || 
            !lstrcmpi(szCurrentFullArcPath2, BootKey[i].szPath) )
        {
            if (!lstrcmpi(pszStartOptions, BootKey[i].szStartOptions))
            {
                // The given start option for the given boot key already exists - no need to add a new one
                if ( Modification == eRemoveBootOption )
                {
                    BootKey[i].fWriteBack = FALSE;
                    fRemovedAtLeastOneEntry = TRUE;
                }
                else
                {
                    ASSERT( Modification == eAddBootOption );
                    return FALSE;
                }

            }
            else if (!lstrcmpi(OLD_SAMUSEREG_OPTION, BootKey[i].szStartOptions) ||
                 !lstrcmpi(OLD_SAMUSEREG_OPTION_2, BootKey[i].szStartOptions) ||
                 !lstrcmpi(OLD_SAMUSEREG_OPTION_4, BootKey[i].szStartOptions) ||
                 !lstrcmpi(OLD_SAMUSEREG_OPTION_3, BootKey[i].szStartOptions))
            {

                if ( Modification == eRemoveBootOption )
                {
                    BootKey[i].fWriteBack = FALSE;
                    fRemovedAtLeastOneEntry = TRUE;
                }
                else
                {
                    // This boot option is the old samusereg option - modify to the new option
                    lstrcpy(BootKey[i].szStartOptions, pszStartOptions);
                    wsprintf(BootKey[i].szDisplay, L"\"%s\"", DISPLAY_STRING_DS_REPAIR);
                    fFixedExisting = TRUE;
                    break;
                }

            }

            // we are going to add a new boot entry - find out which Full Arc Path matched 
            // the current Boot Key' Arc path in boot.ini
            if (lstrcmpi(szCurrentFullArcPath, BootKey[i].szPath))
                fMatchedFirst = FALSE;
        }
    }

    if (!fFixedExisting && (Modification == eAddBootOption) )
    {
        // we need to add the new option - check to see if there is enough space add one more
        if (cBootKeys >= cMaxBootKeys)
        {
            BOOT_KEY *BootKeySave = BootKey;

            cMaxBootKeys += cBootKeys + 1;
            BootKey = (BOOT_KEY *) REALLOC(BootKey,cMaxBootKeys * sizeof(BOOT_KEY));
            if (!BootKey)
            {
                FREE(BootKeySave);

                cBootKeys = 0;
                cMaxBootKeys = 0;
                return FALSE;
            }
        }

        lstrcpy(BootKey[cBootKeys].szPath, fMatchedFirst ? szCurrentFullArcPath : szCurrentFullArcPath2);
        lstrcpy(BootKey[cBootKeys].szStartOptions, pszStartOptions);
        wsprintf(BootKey[cBootKeys].szDisplay, L"\"%s\"", DISPLAY_STRING_DS_REPAIR);
        BootKey[cBootKeys].fWriteBack = TRUE;

        ++cBootKeys;
    }

    if ( !fRemovedAtLeastOneEntry && (Modification == eRemoveBootOption) )
    {
        //
        // No changes necessary
        //
        return FALSE;
    }

    // We really added a new key or modified an existing old key - Success
    return TRUE;
}

VOID WriteBackBootKeysForIntel()
{
    TCHAR *pszCurrent;
    DWORD   dwFileAttrSave;
    DWORD i;
    TCHAR *szOSSectionSave = szOSSection;

    if (!BootKey)
    {
        // no boot keys found (allocation failure or parsing failure) - no point in continuing
        KdPrint(("NTDSETUP: Unable to write OS Section in boot.ini - allocation failed\n"));
        goto cleanup;
    }

    // reallocate szOSSection to hold at least one more line of boot option
    cchOSSection += MAX_KEY_LEN;
    szOSSection = REALLOC(szOSSection, cchOSSection * sizeof(TCHAR));
    if (!szOSSection)
    {
        // allocation failed
        FREE(szOSSectionSave);

        cchOSSection = 0;
        KdPrint(("NTDSETUP: Unable to write OS Section in boot.ini - allocation failed\n"));
        
        goto cleanup;
    }

    pszCurrent = szOSSection;
    for (i = 0; i < cBootKeys; i++)
    {
        int count;

        if ( BootKey[i].fWriteBack )
        {
            count = wsprintf(pszCurrent, L"%s=%s%s", BootKey[i].szPath, BootKey[i].szDisplay, BootKey[i].szStartOptions);
            pszCurrent += (count + 1);    // go past the terminating null
        }

    }

    // add an extra null at the end
    *pszCurrent = TEXT('\0');

    // Save the current file attributes of boot.ini and modify it so that we can write to it
    dwFileAttrSave = GetFileAttributes(szBootIni);
    SetFileAttributes(szBootIni, FILE_ATTRIBUTE_NORMAL);

    if (!WritePrivateProfileSection(szOS, szOSSection, szBootIni))
    {
        KdPrint(("NTDSETUP: Unable to write OS Section in boot.ini - allocation failed\n"));
    }

    // Restore the file attributes on boot.ini
    SetFileAttributes(szBootIni, dwFileAttrSave);

cleanup:


    // Cleanup all allocated buffers
    if (BootKey)
    {
        FREE(BootKey);
        BootKey = NULL;
        cBootKeys = 0;
        cMaxBootKeys = 0;
    }

    if (szOSSection)
    {
        FREE(szOSSection);
        cchOSSection = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\clntutl\src\thrdmgr.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       thrdmgr.cxx
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    File        : thrdmgr.cpp
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 9/17/1996
*    Description : declaration of SvrType class
*
*    Revisions   : <date> <name> <description>
*                         7/29/97 eyals      general fix bugs & clean up
*******************************************************************/



#ifndef THRDMGR_CXX
#define THRDMGR_CXX



// include //
#include "helper.h"
#include "ThrdMgr.hxx"


// defines //
#define ABORT_LOOP_LIMIT            100


// types //



///////////////////////////////////////////////////////
//
// class ThrdMgr: base object defintion
//



/*+++
Function   : constructor
Description:
Parameters :
Return     :
Remarks    : none.
---*/
ThrdMgr::ThrdMgr(void){

	dprintf(DBG_FLOW, _T("[ThrdMgr] constructor entry"));
	m_hThrd = NULL;
	m_dwThrd = (ULONG)-1;
	m_bRunning = FALSE;

}





/*+++
Function   : destructor
Description:
Parameters :
Return     :
Remarks    : none.
---*/
ThrdMgr::~ThrdMgr(void){

	DWORD cnt = 0, dwId=0;
	//
	// release thread if paused
	//

	dprintf(DBG_FLOW, _T("[ThrdMgr] destructor entry"));
	while(m_hThrd != NULL && (dwId = resumeThread()) > 1 && dwId != 0xFFFFFFFF){
		if(cnt++ > ABORT_LOOP_LIMIT){
			dprintf(DBG_ERROR, _T("[ThrdMgr::~ThrdMgr] Error: Infinite loop trapped"));
			TerminateThread(m_hThrd, 0xffffffff);
   		m_bRunning = FALSE;
         CloseHandle(m_hThrd);
			m_hThrd = NULL;
			break;
		}
	}
	//
	// Now Tell thread that it's time to quit, & wait for it
	//
	if(m_hThrd != NULL){
		WaitForThread();
		m_bRunning = FALSE;     // just to make sure it is set appropriately.
      m_hThrd = NULL;
	}

}








/*+++
Function   : startThread
Description: Start the thread execution
Parameters :
Return     :
Remarks    : none.
---*/
BOOL ThrdMgr::startThread(void){

	m_hThrd= CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)threadFunc, this, 0, &m_dwThrd);
	dprintf(DBG_FLOW, _T("[ThrdMgr] forked thread 0x%x"), m_dwThrd);
   return (m_hThrd != NULL ? TRUE : FALSE);

}



/*+++
Function   : pauseThread
Description: pauses the thread
Parameters :
Return     :
Remarks    : none.
---*/
void ThrdMgr::pauseThread(void){

	DWORD dwRet;
	if(m_hThrd != NULL){
		dprintf(DBG_FLOW, _T("[ThrdMgr] suspended thread 0x%x"), m_hThrd);
		dwRet = SuspendThread(m_hThrd);
      if(dwRet != 0xFFFFFFFF){
         m_bRunning = FALSE;
      }
      else
         dprintf(DBG_WARN, _T("[ThrdMgr] SuspendThread returned error 0x%X.\n"), GetLastError());
	}
	else
		dprintf(DBG_WARN, _T("[ThrdMgr] attempt to suspend an unavailable thread"));
	dprintf(DBG_FLOW, _T("[ThrdMgr] paused"));

}





/*+++
Function   : resumeThread
Description: resume thread execution
Parameters :
Return     :
Remarks    : none.
---*/
DWORD ThrdMgr::resumeThread(void){

	DWORD dwRet = 0;
	if(m_hThrd != NULL){
		dprintf(DBG_FLOW, _T("[ThrdMgr] resumed thread 0x%x"), m_hThrd);
		dwRet = ResumeThread(m_hThrd);
      if(dwRet != 0xFFFFFFFF){
         m_bRunning = TRUE;
      }
      else
         dprintf(DBG_WARN, _T("[ThrdMgr] ResumeThread failed. 0x%X\n"), GetLastError());
	}
	else
		dprintf(DBG_WARN, _T("[ThrdMgr] attempt to resume an unavailable thread"));
	dprintf(DBG_FLOW, _T("[ThrdMgr] resumed"));

	return dwRet;
}




/*+++
Function   : WaitForThread
Description:  waits for thread to terminate.
Parameters :
Return     :
Remarks    : Note that we close the handle as well.
---*/
DWORD ThrdMgr::WaitForThread(DWORD dwTimeout){

   DWORD dwRet = WaitForSingleObject(m_hThrd, dwTimeout);
   CloseThread();
   return(dwRet);

}







/*+++
Function   : threadFunc
Description: callback function to CreateThread
Parameters : pointer to calling class
Return     :
Remarks    : none.
---*/
DWORD __stdcall threadFunc(LPVOID lpParam){


	ThrdMgr *obj = (ThrdMgr *)lpParam;
	BOOL bRet = TRUE;

					
	if(obj != NULL){
		dprintf(DBG_FLOW, _T("[ThrdMgr!threadFunc] Starting thread '%s'"), obj->name());
      obj->SetRunning(TRUE);
		bRet = obj->run();
      obj->SetRunning(FALSE);
	}
	else{
		dprintf(DBG_ERROR, _T("[ThrdMgr!threadFunc] Error: Invalid ThrdMgr"), obj->name());
		bRet = FALSE;
	}

	dprintf(DBG_FLOW, _T("[ThrdMgr!threadFunc] Terminating thread '%s'"), obj->name());

	return bRet;
}




#endif




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\clntutl\src\evtlog.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       evtlog.cxx
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    File        : EvtLog.cxx
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 3/15/1998
*    Description :
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef EVTLOG_CXX
#define EVTLOG_CXX



// include //
#include "evtlog.hxx"
#include "excpt.hxx"
#include <time.h>
#include <algorithm>
using   namespace std;


// defines //
// defines //
#define VALIDATE(x)     if(!m_bValid) return x
#define INVALIDATE      m_bValid = FALSE

#define EVTLOGSRC       _T("Directory Service")




// types //


// global variables //


// functions //


/*+++
Function   : Constructor
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DsEventLogMgr::DsEventLogMgr(LPCTSTR pSvr_): ThrdMgr(){


   dprintf(DBG_FLOW, _T("Call: DsEventLogMgr constructor\n"));

   InitDefaults();

   //
   // process server name
   //
   if(!pSvr_){
      dprintf(DBG_ERROR, _T("DsEventLogMgr: Invalid server\n"));
      INVALIDATE;
      m_dwLastError = (DWORD)-1;
      return;
   }
   else if (pSvr_[0] == '\\') {
      //
      // got already in UNC format
      //
      m_pUncSvr = new TCHAR[_tcslen(pSvr_)+1];
      if (!m_pUncSvr) {
          dprintf(DBG_ERROR, _T("DsEventLogMgr: Could not allocate memory!\n"));
          INVALIDATE;
          return;
      }
      _tcscpy(m_pUncSvr, pSvr_);
   }
   else{
      //
      // got in just server name. Add \\
      //
      m_pUncSvr = new TCHAR[_tcslen(pSvr_)+1+_tcslen(_T("\\\\"))];
      if (!m_pUncSvr) {
          dprintf(DBG_ERROR, _T("DsEventLogMgr: Could not allocate memory!\n"));
          INVALIDATE;
          return;
      }
      _tcscpy(m_pUncSvr, _T("\\\\"));
      m_pUncSvr = _tcscat(m_pUncSvr, pSvr_);
   }

   //
   // Attempt to open event log (no use forking thread if can't get in)
   //
   if(Open()){
      //
      // Get initial log info
      //
      if(!GetNumberOfEventLogRecords(m_hEvtLog, &m_dwRecordCount)){
         dprintf(DBG_ERROR, _T("Error<%lu>: Cannot get number of eventlog records\n"), GetLastError());
         INVALIDATE;
      }
   }
   else {
      //
      // could not open. Invalidate server
      //
      dprintf(DBG_ERROR, _T("Error<%lu>: Cannot open eventlog\n"), GetLastError());
      INVALIDATE;
      return;
   }



}



DsEventLogMgr::~DsEventLogMgr(void){

   dprintf(DBG_FLOW, _T("Call: DsEventLogMgr destructor\n"));

   delete m_pUncSvr;

   if(m_hEvtLog){
      CloseEventLog(m_hEvtLog);
   }
   delete m_pFilter;


}



void DsEventLogMgr::InitDefaults(void){

   dprintf(DBG_FLOW, _T("Call: DsEventLogMgr::InitDefaults\n"));
   m_bValid = TRUE;
   m_pUncSvr = NULL;
   m_hEvtLog= NULL;
   m_dwLastError = 0;
   m_dwRecordCount = 0;
   m_pEvents = NULL;
   m_BufferSize = 0;
   //
   // event print filter
   //
   m_pFilter = new EVTFILTER;
   if (!m_pFilter) {
       assert(m_pFilter);
       m_bValid = FALSE;
   } else {
       m_pFilter->dwBacklog;
       // empty   m_Filter.EvtId;
       m_pFilter->dwEvtType = EVENTLOG_SUCCESS|EVENTLOG_ERROR_TYPE|EVENTLOG_WARNING_TYPE|
           EVENTLOG_INFORMATION_TYPE|EVENTLOG_AUDIT_SUCCESS|EVENTLOG_AUDIT_FAILURE;
       // empty vector<int> Category;
       m_pFilter->pMsgLib = (LPTSTR)szMessageLib;
       m_pFilter->OutStyle = EF_TAB;
       m_pFilter->bAppend = TRUE;
   }
}





BOOL DsEventLogMgr::Open(void){


   VALIDATE(m_bValid);

   dprintf(DBG_FLOW, _T("Call: DsEventLogMgr::Open (%s)\n"), m_pUncSvr);
   //
   // open event log
   //
   m_hEvtLog = OpenEventLog(m_pUncSvr, EVTLOGSRC);

   if(NULL == m_hEvtLog){
      INVALIDATE;
      m_dwLastError = GetLastError();
      dprintf(DBG_ERROR, _T("Error<%lu>: could not open event log on %s.\n"),
                                                   m_dwLastError, m_pUncSvr);
   }

   return m_bValid;
}



BOOL DsEventLogMgr::run(void){


   dprintf(DBG_FLOW, _T("Call: DsEventLogMgr::run (%s)\n"), m_pUncSvr);

   //
   // Init thread state
   //
   VALIDATE(m_bValid);
   SetRunning(TRUE);

   //
   // fetch event log
   //

   m_bValid = Fetch();

   //
   // wrap up
   //
   SetRunning(FALSE);
   return m_bValid;
}



BOOL DsEventLogMgr::Fetch(void){

   BOOL bStatus=FALSE;
   DWORD cbBuffer=0, cbRead=0, cbNxtBuffer=0;
   LPBYTE pBuffer=NULL;


   VALIDATE(m_bValid);

   dprintf(DBG_FLOW, _T("Call: DsEventLogMgr::Fetch (%s)\n"), m_pUncSvr);

   try{

      //
      // Allocate approximate buffer space
      // we're approximating needed space as:
      // eventlog record + extra string space * a bit more then exact record count
      //
      cbBuffer = (sizeof(EVENTLOGRECORD) + MAXSTR)*(m_dwRecordCount+4);
      pBuffer = new BYTE[cbBuffer];
      if (!pBuffer) {
          assert(pBuffer != NULL);
          throw(CLocalException(_T("Could not allocate memory!\n")));
      }

      while (bStatus == FALSE) {


         memset(pBuffer, 0, cbBuffer);
         dprintf(DBG_FLOW, _T("\tDsEventLogMgr Reading log... \n"));
         bStatus = ReadEventLog(m_hEvtLog,
                                EVENTLOG_BACKWARDS_READ | EVENTLOG_SEQUENTIAL_READ,
                                0,
                                pBuffer,
                                cbBuffer,
                                &cbRead,
                                &cbNxtBuffer);

         if(FALSE == bStatus){
            m_dwLastError = GetLastError();
            dprintf(DBG_WARN, _T("Warning <%lu>: ReadEventLog failed\n"), m_dwLastError);

            //
            // See if we need more buffer space
            //
            if(m_dwLastError == ERROR_INSUFFICIENT_BUFFER){

               dprintf(DBG_FLOW, _T("\tDsEventLogMgr Re-Reading log... \n"));
               delete pBuffer, pBuffer=NULL;
               pBuffer = new BYTE[cbBuffer];
            }        // re-read
            else{
               //
               // Error condition
               //
               m_dwLastError = GetLastError();
               dprintf(DBG_WARN, _T("Error <%lu>: ReadEventLog failed\n"), m_dwLastError);
               throw(CLocalException(_T("Cannot read event log"), m_dwLastError));
            }


         }        // non-successfull initial read
         else{
            //
            // successfull initial read: bStatus = TRUE
            //
            m_pEvents = (EVENTLOGRECORD*)new BYTE[cbRead];
            if (!m_pEvents) {
                assert(m_pEvents != NULL);
                throw(CLocalException(_T("Could not allocate memory!\n")));
            }

            memcpy((LPBYTE)m_pEvents, pBuffer, cbRead);
            m_BufferSize = cbRead;
            dprintf(DBG_FLOW, _T("\tDsEventLogMgr. Loaded Event list.\n"));
         }

      }
      dprintf(DBG_FLOW, _T(">> %s returned %d events.\n"), m_pUncSvr, m_dwRecordCount);

   }
   catch(CLocalException &e){
      dprintf(DBG_ERROR, _T("Error<%lu>: %s\n"), e.ulErr, e.msg? e.msg: _T("none"));
      INVALIDATE;
   }

   //
   // Unconditional cleanup
   //
   delete pBuffer;

   return m_bValid;
}





/*+++
Function   : PrintLog
Description: print event list to file as specified by filter
Parameters : output file name & filter properties
Return     :
Remarks    : none.
---*/
BOOL DsEventLogMgr::PrintLog(LPCTSTR lpOutput, PEVTFILTER pFilter){

   VALIDATE(m_bValid);
   dprintf(DBG_FLOW, _T("Call: DsEventLogMgr::PrintLog(%s)\n"), m_pUncSvr);
   //
   // copy over filter props: design this way so that we have a set of defaults
   //
   PEVTFILTER pFltr=m_pFilter;
   if(pFilter){
      //
      // replace default filter
      //
      pFltr = pFilter;
   }

   HINSTANCE hMsgLib=NULL;
   HANDLE hFile=NULL;
   DWORD dwStatus;
   try{

      //
      // try to open output file
      //
      HANDLE hFile = CreateFile(lpOutput,
                                GENERIC_READ|GENERIC_WRITE,
                                FILE_SHARE_READ|FILE_SHARE_WRITE,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
      if(hFile == INVALID_HANDLE_VALUE){
         throw(CLocalException(_T("Could not open output file"), m_dwLastError = GetLastError()));
      }
      dwStatus = SetFilePointer(hFile, 0, NULL, pFltr->bAppend?FILE_END:FILE_BEGIN);
      if(dwStatus == (DWORD)-1){
         throw(CLocalException(_T("Could not seek file"), m_dwLastError = GetLastError()));
      }

      //
      // prepare message library:
      // if can't load we'll use no string parsing method
      //
      hMsgLib = LoadLibraryEx(pFltr->pMsgLib, NULL, DONT_RESOLVE_DLL_REFERENCES);
      if(hMsgLib == NULL){
         m_dwLastError = GetLastError();
         dprintf(DBG_WARN, _T("Warning <0x%x>Failed to load %s\n"), m_dwLastError, pFltr->pMsgLib);
      }


      //
      // cycle through events
      //
      EVENTLOGRECORD *pCurrRec = NULL;
      LONG lRead = 0;
      DWORD dwWritten=0;
      TCHAR szClientInfo[MAXSTR];
      const TCHAR szHeaderTab[] = _T("\nComputer\tService\tEventID\tEventType\tCategory\tTimeGenerated\tRecordNumber\tExtended Message\n\n");
      const TCHAR szHeaderComma[] = _T("\nComputer,Service,EventID,EventType,Category,TimeGenerated,RecordNumber\tExtended Message\n\n");
      const TCHAR szHeaderRecord[] = _T("\nEventlog Record list\n\n");
      LPTSTR pHeader = NULL;
      DWORD cbHeader = 0;

      //
      // write header
      //
      TCHAR szComputer[MAX_COMPUTERNAME_LENGTH+1];
      DWORD cbComputer=MAX_COMPUTERNAME_LENGTH;
      SYSTEMTIME sysTime;

      GetLocalTime(&sysTime);

      if(!GetComputerName(szComputer, &cbComputer))
         throw(CLocalException(_T("Cannot get computer name!"), m_dwLastError = GetLastError()));

      _stprintf(szClientInfo, _T("\n---\t---\t---\t---\nClient: %s\tServer: %s\tTime:%d/%d/%d [%d:%d]\n"), szComputer,
                                                                                     m_pUncSvr,
                                                                                     (INT)sysTime.wMonth,
                                                                                     (INT)sysTime.wDay,
                                                                                     (INT)sysTime.wYear,
                                                                                     (INT)sysTime.wHour,
                                                                                     (INT)sysTime.wMinute);
      m_bValid = WriteFile(hFile,
                           szClientInfo,
                           _tcslen(szClientInfo),
                           &dwWritten,
                           NULL);
      if(!m_bValid){
         throw(CLocalException(_T("Could not write header to file (client info)"), m_dwLastError = GetLastError()));
      }


      switch(pFltr->OutStyle){
      case EF_TAB:
         pHeader = (LPTSTR)szHeaderTab;
         break;
      case EF_COMMA:
         pHeader = (LPTSTR)szHeaderComma;
         break;
      case EF_RECORD:
         pHeader = (LPTSTR)szHeaderRecord;
         break;
      case EF_NONE:
      default:
         throw(CLocalException(_T("Unknown case for event log filter output")));

      }

      cbHeader = _tcslen(pHeader);
      m_bValid = WriteFile(hFile,
                           (LPVOID)pHeader,
                           cbHeader,
                           &dwWritten,
                           NULL);
      if(!m_bValid){
         throw(CLocalException(_T("Could not write header to file"), m_dwLastError = GetLastError()));
      }


      for(pCurrRec = GetEvents(),
          lRead = BufferSize();
          lRead > 0;
          lRead  -= pCurrRec->Length,
          pCurrRec = (EVENTLOGRECORD*) ((LPBYTE)pCurrRec+pCurrRec->Length)){


         //
         // filter event
         //

         //
         // apply filters
         //
         if(pFltr->dwBacklog != 0 &&
            time(NULL) - pFltr->dwBacklog > pCurrRec->TimeGenerated){
            dprintf(DBG_FLOW, _T("Backlog time filtered: skipped record %lu "), pCurrRec->RecordNumber);
            continue;
         }
         if(!pFltr->EvtId.empty() &&
            find(pFltr->EvtId.begin(), pFltr->EvtId.end(), pCurrRec->EventID) == pFltr->EvtId.end()){
            dprintf(DBG_FLOW, _T("EventID filtered: skipped record %lu "), pCurrRec->RecordNumber);
            continue;
         }
         if(!(pFltr->dwEvtType & pCurrRec->EventType)){
            dprintf(DBG_FLOW, _T("EventType filtered: skipped record %lu "), pCurrRec->RecordNumber);
            continue;
         }
         if(!pFltr->Category.empty() &&
            find(pFltr->Category.begin(), pFltr->Category.end(), pCurrRec->EventCategory) == pFltr->Category.end()){
            dprintf(DBG_FLOW, _T("EventCategory filtered: skipped record %lu "), pCurrRec->RecordNumber);
            continue;
         }

         //
         // pre process event log entry
         //
         PCHAR pService= (PCHAR) ((LPBYTE) pCurrRec + sizeof(EVENTLOGRECORD));
         PCHAR pComputerName= (PCHAR) ((LPBYTE) pService + strlen(pService) + 1);


         //
         // process event record strings
         //
         UINT	iSz=0;
         PCHAR rgszInserts[MAXLIST];
         PCHAR szInsert = (PCHAR)((LPBYTE) pCurrRec + pCurrRec->StringOffset);
         if(pCurrRec->NumStrings >= MAXLIST-1){
            dprintf(DBG_ERROR, _T("Too many strings in event log entry"));
            continue;
         }

         if(hMsgLib){

            memset(rgszInserts, 0, sizeof(rgszInserts));
            for (iSz = 0; iSz < pCurrRec->NumStrings; iSz++){
               rgszInserts[iSz] = szInsert;
               szInsert += sizeof(CHAR)*(strlen(szInsert) + 1);
            }
         }

         //
         // Print event log information
         //
         LPTSTR pMsgBuffer=NULL;
         TCHAR pOutBuff[2*MAXSTR];

         //
         // Create format
         //
         //
         // format via Category
         //
         TCHAR szCat[MAXSTR];
         dwStatus = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                  FORMAT_MESSAGE_FROM_HMODULE |
                                  FORMAT_MESSAGE_IGNORE_INSERTS,
                                  hMsgLib,
                                  (DWORD) pCurrRec->EventCategory,
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                  (LPTSTR) &pMsgBuffer,
                                  0,
                                  NULL);

         if(dwStatus != 0){
            _stprintf(szCat, _T("[%d] %s"), (INT)pCurrRec->EventCategory, pMsgBuffer);
            LocalFree(pMsgBuffer), pMsgBuffer=NULL;
         }
         else{
            dprintf(DBG_WARN, _T("Failed to format category\n"));
            _stprintf(szCat, _T("[%d] unknown"), (INT)pCurrRec->EventCategory);
         }

         struct tm *generated = localtime((time_t*)&pCurrRec->TimeGenerated);
         TCHAR szGenerated[MAXSTR];
         if(generated){
            _stprintf(szGenerated, _T("%d/%d/%d [%d:%d]"), generated->tm_mon+1,
                                                          generated->tm_mday,
                                                          generated->tm_year,
                                                          generated->tm_hour,
                                                          generated->tm_min);

         }
         else{
            //
            // if we err'd converting
            //
            _stprintf(szGenerated, _T("%lu"), pCurrRec->TimeGenerated);
         }


         switch(pFltr->OutStyle){
         case EF_TAB:
            _stprintf(pOutBuff, _T("%s\t%s\t0x%x\t%s\t%s\t%s\t%lu\t"), pComputerName,
                                                              pService,
                                                              pCurrRec->EventID,
                                                              pCurrRec->EventType == EVENTLOG_SUCCESS? _T("SUCCESS"):
                                                              pCurrRec->EventType == EVENTLOG_ERROR_TYPE? _T("ERROR"):
                                                              pCurrRec->EventType == EVENTLOG_WARNING_TYPE? _T("WARNING"):
                                                              pCurrRec->EventType == EVENTLOG_INFORMATION_TYPE? _T("INFO"):
                                                              pCurrRec->EventType == EVENTLOG_AUDIT_SUCCESS? _T("AUDIT_SUCCESS"):
                                                              pCurrRec->EventType == EVENTLOG_AUDIT_FAILURE? _T("AUDIT_FAILURE"):
                                                              _T("UNKNOWN"),
                                                              szCat,
                                                              szGenerated,
                                                              pCurrRec->RecordNumber);
            NoNewLines(pOutBuff);
            break;
         case EF_COMMA:
            _stprintf(pOutBuff, _T("%s,%s,0x%x,%s,%s,%s,%lu,"), pComputerName,
                                                              pService,
                                                              pCurrRec->EventID,
                                                              pCurrRec->EventType == EVENTLOG_SUCCESS? _T("SUCCESS"):
                                                              pCurrRec->EventType == EVENTLOG_ERROR_TYPE? _T("ERROR"):
                                                              pCurrRec->EventType == EVENTLOG_WARNING_TYPE? _T("WARNING"):
                                                              pCurrRec->EventType == EVENTLOG_INFORMATION_TYPE? _T("INFO"):
                                                              pCurrRec->EventType == EVENTLOG_AUDIT_SUCCESS? _T("AUDIT_SUCCESS"):
                                                              pCurrRec->EventType == EVENTLOG_AUDIT_FAILURE? _T("AUDIT_FAILURE"):
                                                              _T("UNKNOWN"),
                                                              szCat,
                                                              szGenerated,
                                                              pCurrRec->RecordNumber);
            NoNewLines(pOutBuff);
            break;
         case EF_RECORD:
            _stprintf(pOutBuff,  _T("\n---\nEvent Record %lu (at %s):\n")
                                 _T("Service        : %s\n")
                                 _T("Computer Name  : %s\n")
                                 _T("Event ID       : 0x%x\n")
                                 _T("Event Type     : %s\n")
                                 _T("Event Category : %s\n")
                                 _T("Extended Message: "),
                                 pCurrRec->RecordNumber, szGenerated,
                                 pService,
                                 pComputerName,
                                 pCurrRec->EventID,
                                 pCurrRec->EventType == EVENTLOG_SUCCESS? _T("SUCCESS"):
                                 pCurrRec->EventType == EVENTLOG_ERROR_TYPE? _T("ERROR"):
                                 pCurrRec->EventType == EVENTLOG_WARNING_TYPE? _T("WARNING"):
                                 pCurrRec->EventType == EVENTLOG_INFORMATION_TYPE? _T("INFO"):
                                 pCurrRec->EventType == EVENTLOG_AUDIT_SUCCESS? _T("AUDIT_SUCCESS"):
                                 pCurrRec->EventType == EVENTLOG_AUDIT_FAILURE? _T("AUDIT_FAILURE"):
                                 _T("UNKNOWN"),
                                 szCat);

            break;
         case EF_NONE:
         default:
            throw(CLocalException(_T("Unknown case for event log filter output")));

         }
         //
         // Acutal write
         //

         m_bValid = WriteFile(hFile,
                              pOutBuff,
                              _tcslen(pOutBuff),
                              &dwWritten,
                              NULL);
         if(!m_bValid){
            throw(CLocalException(_T("Could not write event to file"), m_dwLastError = GetLastError()));
         }
         //
         // print extended format string information
         //

         //
         // Create format
         //
         DWORD dwFormat = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE;
         va_list *args=NULL;
         if(iSz == 0){
            //
            // No args
            //
            dwFormat |= FORMAT_MESSAGE_IGNORE_INSERTS;
            args=NULL;
         }
         else{
            //
            // we have args to process
            //
            dwFormat |= FORMAT_MESSAGE_ARGUMENT_ARRAY;
            args = (va_list *)rgszInserts;
         }

         //
         // format via event ID.
         //
         dwStatus = FormatMessage(dwFormat,
                                  hMsgLib,
                                  (DWORD) pCurrRec->EventID,
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                  (LPTSTR) &pMsgBuffer,
                                  0,
                                  args);

         if(dwStatus == 0){
            _stprintf(pOutBuff, _T("<Error[%lu] parsing extended message>"), GetLastError());
         }
         else{
            _stprintf(pOutBuff, _T("%s"), pMsgBuffer?pMsgBuffer:_T("none"));
            LocalFree(pMsgBuffer);
         }
         //
         // Acutal write of extended message
         //
         NoNewLines(pOutBuff);
         m_bValid = WriteFile(hFile,
                              pOutBuff,
                              _tcslen(pOutBuff),
                              &dwWritten,
                              NULL);
         if(!m_bValid){
            throw(CLocalException(_T("Could not write event to file"), m_dwLastError = GetLastError()));
         }
         WriteFile(hFile, _T("\n\r"), _tcslen(_T("\n\r")), &dwWritten, NULL);

         if(lRead  - (LONG)pCurrRec->Length <= 0){
            dprintf(DBG_FLOW, _T("Hit last record (lRead = %ld).\n"), lRead);
            break;
         }

      }

   }
   catch(CLocalException &e){
      dprintf(DBG_ERROR, _T("Error<%lu>: %s\n"), e.ulErr, e.msg? e.msg: _T("none"));
      INVALIDATE;
   }


   //
   // cleanup
   //
   if(hMsgLib)
      FreeLibrary(hMsgLib);
   if(hFile)
      CloseHandle(hFile);

   return m_bValid;

}


void DsEventLogMgr::NoNewLines(LPTSTR pBuff){

   if(pBuff){
      for(INT i=0;i<_tcslen(pBuff);i++){
        if(pBuff[i] == '\r' || pBuff[i] == '\n')
           pBuff[i] = '.';
      }

   }
}


#endif

/******************* EOF *********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\convdn\convdn.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       convdn.c
//
//--------------------------------------------------------------------------


#include <NTDSpch.h>
#pragma hdrstop

#include <drs.h>

// Maximum characters to search for a token. Should fit in
// the max-length token that we are interested in, currently
// defaultObjectCategory

#define MAX_TOKEN_LENGTH  25

// Max length of a line to be read or written out
#define MAX_BUFFER_SIZE   10000

// Suffix to put at the end of the input file to create output file
#define OutFileSuffix ".DN"

#define CONFIG_STR "cn=configuration,"

// Globals to store names
char *pInFile, *pNewDomainDN, *pNewConfigDN, *pNewRootDomainDN;
BOOL fDomainOnly = FALSE;

// Global to read-in, write-out a line
char line[MAX_BUFFER_SIZE];


// Internal functions
int  DoDNConvert( FILE *pInp, char *pDomainDN, char *pConfigDN );
BOOL IsDNToken( char *token );
int  DNChange( char *pLine, char *pDomainDN, 
               char *pRootDomainDN,  BOOL *fDomainObj );


///////////////////////////////////////////////////////////////
// Routine Description:
//      Processes command line arguments and loads into appropriate
//      globals
//
// Arguments:
//      argc - no. of command line arguments
//      argv - pointer to command line arguments
//
// Return Value:
//      0 on success, non-0 on error
///////////////////////////////////////////////////////////////

int ProcessCommandLine(int argc, char **argv)
{
    BOOL fFoundDomainDN = FALSE;
    BOOL fFoundConfigDN = FALSE;
    int count = 0, len;
 
    if (argc < 7) return 1;
   

    // First argument must be the /f followed by the input file name
    if (_stricmp(argv[1],"/f")) {
       printf("Missing input file name\n");
       return 1;
    }
    pInFile = argv[2];

   
    // Must be followed by /d for the new domain dn
    if (_stricmp(argv[3],"/d")) return 1;
 
    pNewDomainDN = argv[4];
 
    // Must be followed by /c for the new config dn
    if (_stricmp(argv[5],"/c")) return 1;

    pNewConfigDN = argv[6];

    // See if only domain NC changes are needed
    if ( argc == 8 ) {
       if (_stricmp(argv[7],"/DomainOnly")) {
          // unknown argument
          printf("Unknown option on command line\n");
          return 1;
       }
       // Otherwise, DomainOnly option is specified
       fDomainOnly = TRUE;
    }

   return 0;
 
}



void UsagePrint()
{
   printf("Command line errored\n");
   printf("Usage: ConvertDN /f <InFile> /d <New Domain DN> /c <New Config DN>\n");
   printf("InFile:  Input file name \n");
   printf("New Domain DN: DN of the domain to replace with\n");
   printf("New Config DN: DN of the configuration container\n");
   printf("\nExample: ConvertDN /f MyFile /d dc=Foo1,dc=Foo2 /s cn=Configuration,dc=Foo2\n");
}


void __cdecl main( int argc, char **argv )
{
    ULONG   i, Id;
    FILE   *pInp;
 

    if ( ProcessCommandLine(argc, argv)) 
      {
         UsagePrint();
         exit( 1 );
      };

    // Open the input file for reading
    if ( (pInp = fopen(pInFile,"r")) == NULL) {
       printf("Unable to open Input file %s\n", pInFile);
       exit (1);
    }


    // Ok, now go ahead and change the DN
    if (DoDNConvert(pInp, pNewDomainDN, pNewConfigDN)) {
       printf("DN Conversion failed\n");
       fclose(pInp);
       exit(1);
    }
    fclose(pInp);

}

////////////////////////////////////////////////////////////////////
//
// Routine Decsription:
//       Converts DNs in input file and writes to output file
//
// Arguments:
//       fInp : File pointer to input file
//       fOupt : File pointer to output file
//
// Return Value:
//        None
////////////////////////////////////////////////////////////////////

int DoDNConvert(FILE *pInp, char *pDomainDN, char *pConfigDN)
{
    int   i, len;
    char  token[MAX_TOKEN_LENGTH + 1];
    BOOL  fDomainObj, fSkip = FALSE;
    char  *pOutFile;
    FILE  *pOutp;
    char  *pRootDomainDN;
    int   lineNo;
   

    // Create the output file name and open it
    pOutFile = alloca( (strlen(pInFile) + 
                         strlen(OutFileSuffix) + 1)*sizeof(char));
    strcpy(pOutFile, pInFile);
    strcat(pOutFile, OutFileSuffix);

    if ( (pOutp = fopen(pOutFile, "w")) == NULL) {
       printf("Unable to open output file %s\n", pOutFile);
      return 1; 
    }

    // Create the new root domain dn from the config dn

    len = strlen("CN=configuration");
    if ( _strnicmp(pConfigDN, "CN=configuration", len)) {
        // Bad config DN specified
        printf("Bad Config DN specified\n");
        fclose(pOutp);
        return 1;
     }

    pRootDomainDN = &(pConfigDN[len + 1]);


    lineNo = 1;
    while ( !feof(pInp) ) {
        if ( fgets( line, MAX_BUFFER_SIZE, pInp ) == NULL ) {
           // error reading line
           break;
        }
 
        // isolate the first token  from the line
        i = 0;
   
        while ( (i <= MAX_TOKEN_LENGTH) &&
                     (line[i] != ':') && (line[i] != '\n')
              ) {
           token[i] = line[i];
           i++;
        }

        if ( line[i] == ':' ) {
          // ok, got a token. Null-terminate it and check if it 
          // is one of those we want changed. 
          
          token[i] = '\0';

          if ( _stricmp(token,"dn") == 0 ) {
            // It is a dn. Check if it is in domain NC or under config
             if ( DNChange(line, pDomainDN, pRootDomainDN, &fDomainObj) ) {
               // some error occured
               printf("Cannot convert DN in line %s\n", line);
             }
             if ( !fDomainObj && fDomainOnly ) {
                 // This is not the dn of a domain object
                 // so if DomainOnly is specified, skip this object
                 // Note that all lines in the file are skipped until
                 // we reach the dn of a domain object
                 fSkip = TRUE;
             }
             else {
                 fSkip = FALSE;
             }
          }

          if ( !fSkip ) {
             // Check for other DS-DN syntaxed tokens for this object          
             if (IsDNToken(token) ) {
                // change the dn in the line
                if ( DNChange(line, pDomainDN, pRootDomainDN, &fDomainObj) ) {
                  // some error occured
                  printf("Cannot convert DN in line no. %d\n", lineNo);
                  fclose(pInp);
                  fclose(pOutp);
                  break;
                }
             }
          }
        }

         // At this point, either the line read does not need any 
         // conversion, or it is already converted. So write the line
         // out to the output file if it is not to be skipped

        if ( !fSkip ) {
           fputs( line, pOutp);
        }
        lineNo++;
    }

    // check if bailed out of the while loop before feof is reached
    if ( !feof(pInp) ) {
       // error before end
       printf("Error reading line no. %d\n", lineNo);
       fclose(pOutp);
       return 1;
    }
    fclose(pOutp);
    return 0;
}

// List of attributes with DS-DN syntax (other than dn) that can occur 
// in the ldif file right now. If any other attributes with DS-DN syntax 
// can occur  in the ldif file, this list needs to be modified

char *TokenList[] = {
     "defaultObjectCategory",
     "objectCategory",
};

int numToken = sizeof(TokenList) / sizeof(TokenList[0]);


BOOL IsDNToken(char *token)
{
    int i;
 
    for ( i=0; i<numToken; i++) {
       if ( _stricmp(token, TokenList[i]) == 0 ) {
          return TRUE;
       }
     }
     return FALSE;
}

///////////////////////////////////////////////////////////////////
//
// Decsription:
//     Changes the DN in a line appropriately depending on whether
//     it is dn in the domain NC or in config/schema NC
//
// Argument:
//     line - pointer to line to convert
//     pDomainDN - pointer to domain DN string
//     pRootDomainDN - pointer to root domain DN string
//     fDomainObj - BOOL to return if this was a dn in the domain NC
//
// Return Value:
//     0 on success, 1 on error
//
////////////////////////////////////////////////////////////////////

int DNChange(char *pLine, 
             char *pDomainDN, 
             char *pRootDomainDN, 
             BOOL *fDomainObj)
{
    int  i = 0, j = 0, len;
    BOOL fFound = FALSE;


    while ( !fFound && (pLine[i] != '\n') ) {
       if ( _strnicmp( &(pLine[i]), "dc=", 3) == 0 ) {
          // ok, found the "dc="
          fFound = TRUE;
       }
       else {
         i++;
       }
    }

    if (!fFound) {
      // Didn't find a dc=, nothing to do
      return 0;
    } 

    // check if this is a domain NC object or one under configuration
    len = strlen(CONFIG_STR);

    if ( i > len) {
       if (_strnicmp( &(pLine[i-len]), CONFIG_STR, len) == 0) {
          *fDomainObj = FALSE;
       }
       else {
          *fDomainObj = TRUE;
       }
    }
    else {
        // cannot possibly have cn=configuration before the dc=
        *fDomainObj = TRUE;
    }

 
    // now replace the rest of the line with the new dn given
    if ( *fDomainObj ) {
       strcpy( &(pLine[i]), pDomainDN);
    }
    else {
       strcpy( &(pLine[i]), pRootDomainDN);
    }

    // do a little jugglery to put the '\n' at the end before the null
    i = strlen( pLine );
    pLine[i++] = '\n';
    pLine[i] = '\0';
    

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\csvds\export.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    export.cxx

ABSTRACT:

DETAILS:
    
CREATED:

    09/02/97    Felix Wong (felixw)

REVISION HISTORY:

--*/


#include "csvde.hxx"
#pragma hdrstop

#define ATTRIBUTE_INC 100

//
// Global Variables
//

PWSTR g_szPrimaryGroup = L"primaryGroupID";
PSTR g_szDefaultGroup = "513";

PWSTR g_rgszOmit[] = { L"replPropertyMetaData",
                       NULL };

PWSTR rgszAttrList[] = { L"ldapDisplayName",
                         L"linkid",
                         NULL };

PWSTR rgszSchemaList[] = { L"schemaNamingContext",
                           L"defaultNamingContext",
                           L"supportedControl",
                           NULL };

typedef struct _hashcachestring {
    PWCHAR   value;
    ULONG    length;
    BOOLEAN  bUsed;
} HASHCACHESTRING;

extern BOOLEAN g_fDot;

ULONG g_nBacklinkCount = 0;
HASHCACHESTRING* g_BacklinkHashTable = NULL;       

// Global Attribute Entry Table
AttributeEntry* g_rgAttribute = NULL;
long g_iAttributeNext = 0;
long g_rgAttributeMax = 0;

// Whether appending of file is necessary
BOOLEAN g_fAppend = FALSE;
PRTL_GENERIC_TABLE  g_pOmitTable = NULL;

PWSTR g_szReturn = NULL;

enum CLASS_LOC {
    LOC_NOTSET,
    LOC_FIRST,
    LOC_LAST
};

int nClassLast = LOC_NOTSET; 

DIREXG_ERR 
ConvertUTF8ToUnicode(
    PBYTE pVal,
    DWORD dwLen,
    PWSTR *pszValue,
    DWORD *pdwLen);

PWSTR szFileFlagR;
PWSTR szFileFlagW;

extern BOOLEAN g_fUnicode;

//+---------------------------------------------------------------------------
// Function:   DSExport 
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR DSExport(LDAP *pLdap, ds_arg *pArg)
{
    DIREXG_ERR             hr = DIREXG_SUCCESS;
    DWORD               iszOmit;//, iAttribute;
    PRTL_GENERIC_TABLE  pAttrTable = NULL;
    NAME_MAP            NameMap;
    PNAME_MAP           pNameMap = NULL;
    int                 search_err;
    LDAPMessage         *pSearchMessage = NULL;
    LDAPMessage         *pMessage = NULL;
    FILE                *pFileTemp = NULL;
    FILE                *pFileAppend = NULL;
    PLDAPSearch         pSearch = NULL;
    WCHAR                szTempPath[MAX_PATH];
    WCHAR                szTempFile[MAX_PATH] = L"";
    WCHAR                szAppendPath[MAX_PATH];
    WCHAR                szAppendFile[MAX_PATH] = L"";
    DWORD               cEntriesExported = 0;
    BOOLEAN             fNewElem;
    BOOLEAN             fSearchStart = TRUE; 
    PWSTR               pszRootDN = NULL;
    DWORD               dwFlag = 0;

    BOOL            fPagingAvail = FALSE;
    BOOL            *pfPagingAvail = &fPagingAvail;
    BOOL            fSAMAvail = FALSE;
    
    //
    // If paging is off already, we don't need to ask whether paging is 
    // available or not.
    // pfPagingAvail is used to pass into InitExport to get paging status.
    //
    if (!pArg->fPaged) {
        pfPagingAvail = NULL;
    }

    if (pArg->fUnicode) {
        szFileFlagW = L"wb";
        szFileFlagR = L"rb";
        g_szReturn = L"\r\n";
        g_fUnicode = TRUE;
    }
    else {
        szFileFlagW = L"wt";
        szFileFlagR = L"rt";
        g_szReturn = L"\n";   // Text mode operation already prepends \n with \r
    }

    SelectivePrint(PRT_STD|PRT_LOG,
                   MSG_CSVDE_EXPORTING,
                   pArg->szFilename);
    
    SelectivePrint(PRT_STD|PRT_LOG,
                   MSG_CSVDE_SEARCHING);

    //***********************************************************
    // Variable Initialization Stage 
    // (SAMTable, pFileTemp, pFileAppend, pOmitTable, pAttrTable)
    //***********************************************************

    //
    // Creating SAM Table
    //
    hr = CreateSamTables(); 
    DIREXG_BAIL_ON_FAILURE(hr);

    if (pArg->fSAM) {
        dwFlag |= INIT_BACKLINK;
    }
    if (pArg->szRootDN == NULL) {
        dwFlag |= INIT_NAMINGCONTEXT;
    }

    hr = CreateOmitBacklinkTable(pLdap,
                                 pArg->omitList,
                                 dwFlag,
                                 &pszRootDN,
                                 pfPagingAvail,
                                 &fSAMAvail);    
    DIREXG_BAIL_ON_FAILURE(hr);

    //
    // If RootDN is NULL, we check if InitExport returns the naming context
    // correctly
    //
    if (pArg->szRootDN == NULL) {
        //
        // Output error message if we failed to get default naming context
        //
        if (pszRootDN == NULL) {
            SelectivePrint(PRT_STD,
                           MSG_CSVDE_ROOTDN_NOTAVAIL); 
            /*
            hr = ERROR_INVALID_PARAMETER;
            BAIL();
            */
        }
        else {
        //
        // else use it
        //
            pArg->szRootDN = pszRootDN;
        }
    }

    //
    // If we asked for SAM and it is not available, output error message and
    // turn off SAM logic, but still go on
    // 
    if (pArg->fSAM && (fSAMAvail == FALSE)) {
        SelectivePrint(PRT_STD,
                       MSG_CSVDE_SAM_NOTAVAIL); 
        pArg->fSAM = FALSE;
    }

    //
    // If the user requests paging, but it is not available, we'll inform the
    // user and turn off paging
    //
    if (pArg->fPaged) {

        //
        // If user requested paging, we must have passed in a valid entry
        // to initExport to get back status
        //
        ASSERT(pfPagingAvail);

        if (fPagingAvail == FALSE) {
            SelectivePrint(PRT_STD,
                           MSG_CSVDE_PAGINGNOTAVAIL); 
            pArg->fPaged = FALSE;
        }
    }

    //
    // Creating temporary file
    //
    if (!(GetTempPath(MAX_PATH, szTempPath))) {
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    if (!(GetTempFileName(szTempPath, 
                          L"csva", 
                          0, 
                          szTempFile))) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERROR_CREATETEMP);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    if ((pFileTemp = _wfopen(szTempFile, 
                             szFileFlagW)) == NULL) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERROR_OPENTEMP);
        hr = DIREXG_FILEERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    //
    // Creating Append file (only create if SAM logic is active)
    //
    if (pArg->fSAM) {
        if (!(GetTempPath(MAX_PATH, szAppendPath))) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        
        if (!(GetTempFileName(szAppendPath, 
                              L"csvb", 
                              0, 
                              szAppendFile))) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_ERROR_CREATETEMP);
            hr = DIREXG_FILEERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        if ((pFileAppend = _wfopen(szAppendFile, 
                                   szFileFlagW)) == NULL) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_ERROR_OPENTEMP);
            hr = DIREXG_FILEERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Generating Attribute table
    //
    pAttrTable = (PRTL_GENERIC_TABLE) MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!pAttrTable) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    RtlInitializeGenericTable(pAttrTable, 
                              NtiComp, 
                              NtiAlloc, 
                              NtiFree, 
                              NULL);
    g_rgAttribute = (AttributeEntry*)MemAlloc(sizeof(AttributeEntry) * 
                                            ATTRIBUTE_INC);
    if (!g_rgAttribute) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    g_rgAttributeMax = ATTRIBUTE_INC;
    g_iAttributeNext = 0;

    if (pArg->fPaged) {
        // ****************
        // PAGED SEARCH
        // ****************
        pSearch = ldap_search_init_page( pLdap,
                                          pArg->szRootDN,
                                          pArg->dwScope, 
                                          pArg->szFilter, 
                                          pArg->attrList,  
                                          FALSE,
                                          NULL,        // server controls
                                          NULL,
                                          0,
                                          0,
                                          NULL         // sort keys
                                        );
    
        search_err = LDAP_SUCCESS;
    
        if (pSearch == NULL) {
            search_err = LdapGetLastError();
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_SEARCHFAILED);
            hr = search_err;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    
        while ((search_err == LDAP_SUCCESS) && (pSearch != NULL)) {
    
            ULONG totalCount;
    
            search_err = ldap_get_next_page_s(  pLdap,
                                                pSearch,
                                                NULL,
                                                10,
                                                &totalCount,
                                                &pSearchMessage );
    
            if (fSearchStart) {
                SelectivePrint(PRT_STD|PRT_LOG,
                               MSG_CSVDE_WRITINGOUT);
                SelectivePrint2(PRT_STD_VERBOSEONLY|PRT_LOG,
                               L"\r\n");

                fSearchStart = FALSE;
                g_fDot = TRUE;  // Turn on dots so that a 'new line' WCHAR will
                                // be added before printing next statement.
            }
    
            if (pSearchMessage != NULL) {
                ULONG rc;
                PWSTR  matchedDNs = NULL;
                PWSTR  errors     = NULL;
                PWSTR  *referrals  = NULL;
                search_err = ldap_parse_result( pLdap,
                                                 pSearchMessage,
                                                 &rc,
                                                 &matchedDNs,
                                                 &errors,
                                                 &referrals,
                                                 NULL,
                                                 FALSE      // don't MemFree it.
                                                );
    
                if (referrals != NULL) {
                    PWSTR  *val = referrals;
                    while (*val != NULL) {
                        val++;
                    }
                    ldap_value_free( referrals );
                }
    
                if (errors != NULL) {
                    ldap_memfree( errors );
                }
    
                if (matchedDNs != NULL) {
                    ldap_memfree( matchedDNs );
                }

            
                //
                // Step through each pMessage
                //
                for ( pMessage = ldap_first_entry(pLdap, 
                                                  pSearchMessage ); 
                      pMessage != NULL; 
                      pMessage = ldap_next_entry(pLdap, 
                                                 pMessage ) ) { 
                    hr = GenerateEntry(pLdap, 
                                       pMessage, 
                                       pArg->omitList,
                                       pArg->fSAM,
                                       pArg->fBinary,
                                       pFileTemp,
                                       pFileAppend,
                                       pAttrTable);
                    DIREXG_BAIL_ON_FAILURE(hr);
                    cEntriesExported++;
                }
            }
            ldap_msgfree(pSearchMessage);
            pSearchMessage = NULL;
        }


        if ((search_err != LDAP_SUCCESS) && (search_err != LDAP_NO_RESULTS_RETURNED)) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_SEARCHFAILED);
            OutputExtendedError(pLdap);
            hr = search_err;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        
    }
    else {
        // ****************
        // NON-PAGED SEARCH
        // ****************
        if ( (search_err=ldap_search_s(pLdap, 
                                       pArg->szRootDN, 
                                       pArg->dwScope, 
                                       pArg->szFilter, 
                                       pArg->attrList,  
                                       0, 
                                       &pSearchMessage))!= LDAP_SUCCESS ) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_SEARCHERROR, 
                           ldap_err2string(search_err));
            OutputExtendedError(pLdap);
            hr = search_err;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

    
         //
         // Step through each pMessage
         //
         SelectivePrint(PRT_STD|PRT_LOG,
                        MSG_CSVDE_WRITINGOUT);
         SelectivePrint2(PRT_STD_VERBOSEONLY|PRT_LOG,
                        L"\r\n");
         TrackStatus();
         
         for ( pMessage = ldap_first_entry(pLdap, 
                                           pSearchMessage ); 
               pMessage != NULL; 
               pMessage = ldap_next_entry(pLdap, 
                                          pMessage ) ) { 
             hr = GenerateEntry(pLdap, 
                                pMessage, 
                                pArg->omitList,
                                pArg->fSAM,
                                pArg->fBinary,
                                pFileTemp,
                                pFileAppend,
                                pAttrTable);
             DIREXG_BAIL_ON_FAILURE(hr);
             cEntriesExported++;
        }
    }

    if (cEntriesExported == 0) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_NOENTRIES);
        hr = DIREXG_SUCCESS;
        goto error;
    }

    if (pFileAppend) {
        fclose(pFileAppend);
        pFileAppend = NULL;

        //
        // If there are entries appended
        //
        if (g_fAppend) { 
            if ((pFileAppend = _wfopen(szAppendFile, 
                                       L"rb")) == NULL) {
                SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                               MSG_CSVDE_ERROR_OPENTEMP);
                hr = DIREXG_FILEERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            hr = AppendFile(pFileAppend,
                            pFileTemp);
            if (hr != DIREXG_SUCCESS) {
                SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                               MSG_CSVDE_ERROR_READTEMP);
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }   
    }

    if (pFileTemp) {
        fclose(pFileTemp);
        pFileTemp = NULL;
    }

    if (pFileAppend) {
        fclose(pFileAppend);
        pFileAppend = NULL;
    }

    SelectivePrint(PRT_STD|PRT_LOG,
                   MSG_CSVDE_EXPORTCOMPLETED);

    hr = UpdateFile(szTempFile,
                    pArg->szFilename,
                    pArg);
    DIREXG_BAIL_ON_FAILURE(hr);

    SelectivePrint(PRT_STD|PRT_LOG,
                   MSG_CSVDE_NUMEXPORTED,
                   cEntriesExported);

error:

    if (pFileAppend) {
        fclose(pFileAppend);
        pFileAppend = NULL;
    }

    if (pFileTemp) {
        fclose(pFileTemp);
        pFileTemp = NULL;
    }


#ifndef LEAVE_TEMP_FILES
    if (szTempFile[0]) {
        DeleteFile(szTempFile);
        INFO(("Deleting temp file: %S",szTempFile));
    }
    if (szAppendFile[0]) {
        DeleteFile(szAppendFile);
        INFO(("Deleting temp file: %S",szAppendFile));
    }

#endif

    DestroySamTables();

    if (g_BacklinkHashTable) {
        UINT i;
        for (i=0;i<g_nBacklinkCount;i++) {
            if (g_BacklinkHashTable[i].bUsed) {
                MemFree(g_BacklinkHashTable[i].value);
            }
        }
        MemFree(g_BacklinkHashTable);
        g_BacklinkHashTable = NULL;
    }

    if (pszRootDN) {
        MemFree(pszRootDN);
    }

    if (pSearch != NULL) {
        ldap_search_abandon_page( pLdap, pSearch );
        pSearch = NULL;
    }

    if (pSearchMessage) {
        ldap_msgfree(pSearchMessage);
        pSearchMessage = NULL;
    }

    if (g_pOmitTable) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(g_pOmitTable, TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(g_pOmitTable, TRUE)) {
            PWSTR szLinkDN;
            szLinkDN = pNameMap->szName;
            RtlDeleteElementGenericTable(g_pOmitTable, pNameMap);
            MemFree(szLinkDN);
        }
        MemFree(g_pOmitTable);
        g_pOmitTable = NULL;
    } 

    if (pAttrTable) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pAttrTable, TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pAttrTable, TRUE)) {
            PWSTR szName = pNameMap->szName;
            RtlDeleteElementGenericTable(pAttrTable, pNameMap);
            MemFree(szName);
        }
        MemFree(pAttrTable);
        pAttrTable = NULL;
    }       

    if (g_rgAttribute) {
        // Not necessary because same value is stored in pAttrTable
        /*
        for (iAttribute=0;iAttribute<g_iAttributeNext;iAttribute++) {
            MemFree(g_rgAttribute[iAttribute].szValue);
        }
        */
        MemFree(g_rgAttribute);
    }
    return (hr);
}

//+---------------------------------------------------------------------------
// Function:    GenerateEntry
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    03-9-97   felixw         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR GenerateEntry(LDAP                  *pLdap, 
                         LDAPMessage           *pMessage, 
                         PWSTR                 *rgszOmit, 
                         BOOLEAN               fSamLogic,
                         BOOLEAN               fBinaryOutput,
                         FILE                  *pFileOut,
                         FILE                  *pFileOutAppend,
                         PRTL_GENERIC_TABLE    pAttrTable)
{
    struct berval     **rgpVals = NULL;
    PWSTR       szDN = NULL;
    PWSTR       szTemp = NULL;
    PWSTR       szAttribute = NULL;
    PWSTR       szOutput = NULL;
    PWSTR       szDNNew = NULL;
    PWSTR       szBinary = NULL;
    BOOLEAN     fObjectClass;
    BOOLEAN     fBinary;
    long        i;
    DWORD       cVal;
    long        iAttribute;          
    CString     String;
    DIREXG_ERR     hr = DIREXG_SUCCESS;
    BOOLEAN     fAppend = FALSE;
    PWSTR pszValStr = NULL;
    DWORD dwValSize;
    PWSTR       szNewValue = NULL;
    PWSTR       szFinalValue = NULL;

    TrackStatus();

    // ***********************************************
    // Initializing the attribute array for this entry
    // ***********************************************
    for (i=0;i<g_rgAttributeMax;i++) {
        g_rgAttribute[i].bExist = FALSE;
    }
    
    // ***********************************************
    // Update Attribute Table with current entry
    // ***********************************************
    hr = UpdateAttributeTable(pLdap,
                              pMessage,
                              fSamLogic,
                              fBinaryOutput,
                              &fAppend,
                              pAttrTable);
    DIREXG_BAIL_ON_FAILURE(hr);

    if (fAppend) {
        pFileOut = pFileOutAppend;
        g_fAppend = TRUE;
    }

    if(fwprintf(pFileOut,
                L"%d:",
                g_iAttributeNext)==EOF) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERRORWRITE);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    // *****************************
    // Getting the DN for this entry
    // *****************************
    szDN = ldap_get_dn( pLdap, 
                        pMessage );
    if (!szDN) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERRORGETDN);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    ASSERT(szDNNew == NULL);

    //
    // For a DN, we'll fix everything except escaping. DNs should always be
    // LDAP escaped.
    //
    hr = FixSpecialCharacters(szDN,
                              &szDNNew,
                              FIX_ALPHASEMI|FIX_COMMA|FIX_ESCAPE);
    DIREXG_BAIL_ON_FAILURE(hr);
    if (!szDNNew) {
        szDNNew = MemAllocStrW(szDN);
    }
    
    if(fwprintf(pFileOut,
                L"%s",
               szDNNew)==EOF) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERROR_WRITE);
        hr = DIREXG_FILEERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    //
    // If this is not the only value, output the comma
    //
    if (g_iAttributeNext > 0) {
            if(fputws(L",", 
                      pFileOut)==WEOF) {
                    hr = DIREXG_ERROR;
                    DIREXG_BAIL_ON_FAILURE(hr);
            }
    }

    // ***********************
    // Outputing current Entry
    // ***********************
    for (iAttribute=0; iAttribute < g_iAttributeNext; iAttribute++) {
        
        //
        // Skip if not exist
        //
        if (g_rgAttribute[iAttribute].bExist == FALSE) {
            goto done;
        }
        
        //
        // Collecting data for current Attribute
        //
        szAttribute = g_rgAttribute[iAttribute].szValue;
        rgpVals = ldap_get_values_len(pLdap, 
                                      pMessage, 
                                      szAttribute );
        cVal = ldap_count_values_len(rgpVals);
        fObjectClass = (_wcsicmp(L"objectClass",
                                 szAttribute) == 0);
        fBinary = CheckBinary(rgpVals,
                              cVal);
                            
        hr = String.Init();
        DIREXG_BAIL_ON_FAILURE(hr);
     
        //
        // Getting Each Value
        //
        for (i=0; i<(long)cVal; i++) {
      
            //
            // Only print last value if ObjectClass   
            //
            if(fObjectClass) {
                if (nClassLast == LOC_NOTSET) {
                    hr = ConvertUTF8ToUnicode((unsigned char*)rgpVals[i]->bv_val,
                                              rgpVals[i]->bv_len,
                                              &pszValStr,
                                              &dwValSize);
                    DIREXG_BAIL_ON_FAILURE(hr);
                    if ( _wcsicmp( pszValStr, L"top") == 0 ) {
                        nClassLast = LOC_LAST;
                    }
                    else {
                        nClassLast = LOC_FIRST;
                    }
                    MemFree(pszValStr);
                    pszValStr = NULL;
                }
                if (nClassLast == LOC_LAST) {
                    if (rgpVals[i+1]!=NULL) {
                        continue;
                    }
                }
                else {
                    if (i!=0) {
                        break;
                    }
                }
            }


            // 
            // Getting the current attribute value
            //
            if (fBinary) {
                hr = BValToString((unsigned char*)rgpVals[i]->bv_val, 
                                  rgpVals[i]->bv_len,
                                  &szBinary);                           
                DIREXG_BAIL_ON_FAILURE(hr);
                szTemp = szBinary;
            }
            else {
                ASSERT(pszValStr == NULL);
                hr = ConvertUTF8ToUnicode((unsigned char*)rgpVals[i]->bv_val,
                                          rgpVals[i]->bv_len,
                                          &pszValStr,
                                          &dwValSize);
                DIREXG_BAIL_ON_FAILURE(hr);
                szTemp = pszValStr;                           

                //
                // fix &, ; and /, we'll do ',' at the end
                //
                ASSERT(szNewValue == NULL);
                hr = FixSpecialCharacters(szTemp,
                                          &szNewValue,
                                          FIX_ALPHASEMI|FIX_ESCAPE);
                DIREXG_BAIL_ON_FAILURE(hr);
                if (szNewValue) {
                    szTemp = szNewValue;
                }

            }

            if (fObjectClass) {
                hr = String.Append(szTemp);
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            else {

                if (i==0) {
                    hr = String.Append(szTemp);
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                else {
                    hr = String.Append(L";");
                    DIREXG_BAIL_ON_FAILURE(hr);
                    hr = String.Append(szTemp);
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
            }

            if (szBinary) {
                MemFree(szBinary);
                szBinary = NULL;
            }
            if (pszValStr) {
                MemFree(pszValStr);
                pszValStr = NULL;
            }
            if (szNewValue) {
                MemFree(szNewValue);
                szNewValue = NULL;
            }
        }
        ldap_value_free_len(rgpVals);
        rgpVals = NULL;

        szTemp = String.String();
        ASSERT(szFinalValue == NULL);
        hr = FixSpecialCharacters(szTemp,
                                  &szFinalValue,
                                  FIX_COMMA);
        DIREXG_BAIL_ON_FAILURE(hr);
        if (szFinalValue) {
            szTemp = szFinalValue;
        }
        
        if(fwprintf(pFileOut,
                    L"%s", 
                    szTemp)==EOF) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        if (szFinalValue) {
            MemFree(szFinalValue);
            szFinalValue = NULL;
        }

done:
        //
        // Output COMMA as long as it is not the last one
        //
        if ((iAttribute + 1) < g_iAttributeNext) {
            if(fputws(L",", 
                      pFileOut)==WEOF) {
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }
    }   

    if(fputws(g_szReturn,
              pFileOut)==WEOF) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERROR_WRITE);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    SelectivePrint(PRT_STD_VERBOSEONLY|PRT_LOG,
                   MSG_CSVDE_EXPORT_ENTRY,
                   szDNNew);

error:
    if (szFinalValue) {
        MemFree(szFinalValue);
        szFinalValue = NULL;
    }
    if (szNewValue) {
        MemFree(szNewValue);
        szNewValue = NULL;
    }
    if (pszValStr) {
        MemFree(pszValStr);
        pszValStr = NULL;
    }
    if (szDN) {
        ldap_memfree(szDN);
    }
    if (szBinary) {
        MemFree(szBinary);
    }
    if (rgpVals) {
        ldap_value_free_len(rgpVals);
        rgpVals = NULL;
    }
    if (szDNNew) {
        MemFree(szDNNew);
    }
    return hr;
}

//+---------------------------------------------------------------------------
// Function:   UpdateFile
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR UpdateFile(PWSTR szFileIn, 
                   PWSTR szFileOut,
                   ds_arg *pArg)
{
    FILE *pFileOut = NULL;
    FILE *pFileIn = NULL;
    DIREXG_ERR hr = DIREXG_SUCCESS;
    DWORD cAttribute;
    long iAttribute;
    DWORD i;
    DWORD cComma = 0;
    DWORD cLine = 0;
    PWSTR szCurrent = NULL;
    PWSTR szLine = NULL;
    PWSTR szSub = NULL;
    CString String;

    //
    // Opening both Input and Output file
    //
    if ((pFileOut = _wfopen(szFileOut, 
                            szFileFlagW)) == NULL) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERROR_OPENOUTPUT, 
                       szFileOut);
        hr = DIREXG_FILEERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    if ((pFileIn = _wfopen(szFileIn, 
                           szFileFlagR)) == NULL) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERROR_OPENAPPPEND, 
                       szFileIn);
        hr = DIREXG_FILEERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    if (pArg->fUnicode) {
        if(fputwc(UNICODE_MARK,
                          pFileOut)==WEOF) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Outputing attribute line
    //
    if (!pArg->fSpanLine) {
        if(fputws(L"DN,",
                  pFileOut)==WEOF) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }
    else {
        SelectivePrint(PRT_STD|PRT_LOG,
                       MSG_CSVDE_ORGANIZE_OUTPUT, 
                       szFileIn);
        if(fputws(L"DN,&",
                  pFileOut)==WEOF) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        if(fputws(g_szReturn,
                  pFileOut)==WEOF) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    for (iAttribute=0; iAttribute < (g_iAttributeNext - 1); iAttribute++) {
        if(fwprintf(pFileOut,
                    L"%s",
                    g_rgAttribute[iAttribute].szValue)==WEOF) {
            hr = DIREXG_FILEERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        if (pArg->fSpanLine) {
            if(fputws(L",&",
                      pFileOut)) {
                hr = DIREXG_FILEERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            if(fputws(g_szReturn,
                      pFileOut)) {
                hr = DIREXG_FILEERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }
        else {
            if(fputws(L",",
                      pFileOut)) {
                hr = DIREXG_FILEERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }
    }
    if(fwprintf(pFileOut,
                L"%s",
                g_rgAttribute[iAttribute].szValue)==WEOF) {
        hr = DIREXG_FILEERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    if(fputws(g_szReturn,
              pFileOut)) {
        hr = DIREXG_FILEERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    if (pArg->fSpanLine) {
        if(fputws(g_szReturn,
                 pFileOut)) {
            hr = DIREXG_FILEERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Outputing values
    //
    int scanResult;
    scanResult = fwscanf(pFileIn,
                         L"%d:",
                         &cAttribute);
    while ((scanResult != WEOF) && (scanResult != 0)) {

        hr = GetLine(pFileIn,
                     &szLine);
        DIREXG_BAIL_ON_FAILURE(hr);

        if (!szLine) {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_ERROR_READTEMP);
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        hr = String.Init();
        DIREXG_BAIL_ON_FAILURE(hr);

        cLine++;
        cComma = g_iAttributeNext - cAttribute;

        if (pArg->fSpanLine) {
            TrackStatus();
            PWSTR szNewLine = NULL;
            hr = SpanLines(szLine, &szNewLine);
            DIREXG_BAIL_ON_FAILURE(hr);
            MemFree(szLine);
            szLine = szNewLine;     
        }

        hr = String.Append(szLine);
        DIREXG_BAIL_ON_FAILURE(hr);
        MemFree(szLine);
        szLine = NULL;

        if (cComma == 0) {
            if (pArg->fSpanLine)
                String.Append(g_szReturn);
        }
        else {
            for (i=0;i<cComma;i++) {
                if (!pArg->fSpanLine) {
                    hr = String.Append(L",");
                }
                else {
                    if (i == (cComma - 1))
                        hr = String.Append(L",");
                    else
                        hr = String.Append(L",&");
                    DIREXG_BAIL_ON_FAILURE(hr);
                    hr = String.Append(g_szReturn);
                }
                DIREXG_BAIL_ON_FAILURE(hr);
            } 
        }      
        
        szCurrent = String.String(); 

        //
        // Do Substring substitution if necessary
        //
        if (pArg->szFromDN) {
            hr = SubString(szCurrent,
                           pArg->szFromDN,
                           pArg->szToDN,
                           &szSub);
            DIREXG_BAIL_ON_FAILURE(hr);
            if (szSub) { 
                szCurrent = szSub;
            }
        }
        
        if(fwprintf(pFileOut,
                   L"%s",
                   szCurrent)==WEOF) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        if(fputws(g_szReturn,
                  pFileOut)) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        if (szSub) {
            MemFree(szSub);
            szSub = NULL;
        }
        scanResult = fwscanf(pFileIn,
                             L"%d:",
                             &cAttribute);
    }    

error: 
    if (szLine) {
        MemFree(szLine);
    }
    if (szSub) {
        MemFree(szSub);
    }
    if (pFileOut) {
        fclose(pFileOut);
    }
    if (pFileIn) {
        fclose(pFileIn);
    }
    return hr;
}

//+---------------------------------------------------------------------------
// Function:   ParseDN
//
// Synopsis:   Return the parent dn and rdn. Use existing string. No MemFree
//             required.
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR ParseDN(PWSTR szDN,
                PWSTR *pszParentDN,
                PWSTR *pszRDN)
{
    PWSTR szCurrent = NULL;

    szCurrent = wcsstr(szDN, L",");
    if (!szCurrent) {
        return DIREXG_ERROR;
    }
    *pszRDN = szDN;
    *szCurrent = '\0';
    *pszParentDN = szCurrent + 1;
    
    return DIREXG_SUCCESS;
}

//+---------------------------------------------------------------------------
// Function:   FixSpecialCharacters
//
// Synopsis:   Surround string with double quotes if necessary, also change 
//             all internal double quotes to double, double quotes L" -> L"". 
//             If string is unchanged, output = NULL;
//             Also turn '&' into '\&'
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR FixSpecialCharacters(PWSTR szInput, PWSTR *pszResult, DWORD dwMode)
{
    PWSTR szCurrent = NULL;
    PWSTR szSubComma = NULL;
    PWSTR szSubComma2 = NULL;
    DWORD cchInput;
    PWSTR szSemi = NULL;
    PWSTR szAmper = NULL;
    DIREXG_ERR hr = DIREXG_SUCCESS;
    BOOLEAN fChanged = FALSE;

    *pszResult = NULL;

    if (dwMode & FIX_ESCAPE) {
        if (wcsstr(szInput,L"\\")) {
            hr = SubString(szInput,
                           L"\\",
                           L"\\\\",
                           &szSubComma2);
            DIREXG_BAIL_ON_FAILURE(hr);
           
            if (szSubComma2) {
                szInput = szSubComma2;
                fChanged = TRUE;
            }
        }
    }

    if (dwMode & FIX_ALPHASEMI) {

        if (wcsstr(szInput,L";")) {
            hr = SubString(szInput,
                           L";",
                           L"\\;",
                           &szSemi);
            DIREXG_BAIL_ON_FAILURE(hr);
           
            if (szSemi) {
                szInput = szSemi;
                fChanged = TRUE;
            }
        }

        if (wcsstr(szInput,L"X'")) {
            hr = SubString(szInput,
                           L"X'",
                           L"\\X'",
                           &szAmper);
            DIREXG_BAIL_ON_FAILURE(hr);
           
            if (szAmper) {
                szInput = szAmper;
                fChanged = TRUE;
            }
        }
    
#ifdef SPANLINE_SUPPORT
        if (wcsstr(szInput,L"&")) {
            hr = SubString(szInput,
                           L"&",
                           L"\\&",
                           &szAmper);
            DIREXG_BAIL_ON_FAILURE(hr);
           
            if (szAmper) {
                szInput = szAmper;
                fChanged = TRUE;
            }
        }
#endif
    }

    if (dwMode & FIX_COMMA) {
        //
        // If comma exist in a string, we'll surround it with double quotes, 
        // however adding double quotes also requires us to turn all internal double 
        // quotes to double, double quotes -> '"' to '""'
        //
        if (wcsstr(szInput,L",") || wcsstr(szInput,L"\"") ) {
    
            hr = SubString(szInput,
                           L"\"",
                           L"\"\"",
                           &szSubComma);
            DIREXG_BAIL_ON_FAILURE(hr);
           
            if (szSubComma) {
                szInput = szSubComma;
            }
    
            cchInput = wcslen(szInput);
    
            //
            // need 2 WCHAR for double quotes and 1 for null termination
            //
            szCurrent = (PWSTR)MemAlloc(sizeof(WCHAR) * (cchInput + 3));
            if (!szCurrent) {
                hr = DIREXG_OUTOFMEMORY;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            wcscpy(szCurrent,L"\"");
            wcscat(szCurrent,szInput);
            wcscat(szCurrent,L"\"");
            *pszResult = szCurrent;
        }
    }

    if ((*pszResult == NULL) && fChanged) {
        cchInput = wcslen(szInput);

        //
        // need 2 WCHAR for double quotes and 1 for null termination
        //
        szCurrent = (PWSTR)MemAlloc(sizeof(WCHAR) * (cchInput + 1));
        if (!szCurrent) {
            hr = DIREXG_OUTOFMEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        wcscpy(szCurrent,szInput);
        *pszResult = szCurrent;
    }

error:
    if (szSemi) {
        MemFree(szSemi);
    }
    if (szAmper) {
        MemFree(szAmper);
    }
    if (szSubComma) {
        MemFree(szSubComma);
    }
    if (szSubComma2) {
        MemFree(szSubComma2);
    }
    return (hr);
}

//+---------------------------------------------------------------------------
// Function:   FixMutliValueAttribute
//
// Synopsis:   In cases where multivalued attributes occur, we have to replace
//             all value separators to be escaped/
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-19-98   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR FixMutliValueAttribute(PWSTR szInput, PWSTR *pszResult)
{
    PWSTR  szCurrent = NULL;
    PWSTR szSub = NULL;      // Sub ampersand
    DWORD cchInput;
    DIREXG_ERR hr = DIREXG_SUCCESS;

    *pszResult = NULL;

    //
    // ';' is a special character, if it exist in the string, substitue all 
    // ';' with '\;'
    //  
    if (wcsstr(szInput,L";")) {
        hr = SubString(szInput,
                       L";",
                       L"\\;",
                       &szSub);
        DIREXG_BAIL_ON_FAILURE(hr);
        if (szSub) {
            *pszResult = szSub;
        }
    }
    
    return (hr);

error:
    if (szSub) {
        MemFree(szSub);
    }

    return (hr);
}

                    
//+---------------------------------------------------------------------------
// Function:   CheckBinary
//
// Synopsis:   Checks whether the berval is binary 
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
BOOLEAN CheckBinary(struct berval **rgpVals,
                    DWORD cVal)
{
    DWORD i,j;
    BOOLEAN fBinary = FALSE;     

    for (i=0; i<cVal;i++) {
        for (j=0; j<rgpVals[i]->bv_len; j++) {
            if (((rgpVals[i]->bv_val)[j]<0x20) ||
                ((rgpVals[i]->bv_val)[j]>0x7E)) {
                    fBinary = TRUE;
                    break;
            }
        }
        if (fBinary) 
            break;
    }
    return fBinary;
}

//+---------------------------------------------------------------------------
// Function:   BValToString
//
// Synopsis:   Converts a binary value to string    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR BValToString(BYTE *pbVal, 
                     DWORD cbVal,
                     PWSTR *pszReturn)
{
    PWSTR szReturn = NULL;
    PWSTR szCurrent = NULL;
    DWORD i;

    //
    // Each byte will turn into a two digit hex
    // we need 4 extra WCHAR for L"X" L"'" L"'" and null-termination
    //
    szReturn = (PWSTR)MemAlloc(sizeof(WCHAR) * (cbVal*2+4));
    if (!szReturn) {
        return DIREXG_OUTOFMEMORY;
    }

    szCurrent = szReturn;
    *szCurrent++ = 'X';
    *szCurrent++ = '\'';
    for (i=0; i<cbVal; i++) {
        swprintf(szCurrent,
                 L"%02x",
                 pbVal[i]);
        szCurrent+=2;
    }
    *szCurrent++ = '\'';
    *szCurrent = (WCHAR)NULL;
    *pszReturn = szReturn;
    return DIREXG_SUCCESS;
}


//+---------------------------------------------------------------------------
// Function:  UpdateSpecialVars 
//
// Synopsis:   Check whether it is a SAM object, or if it is a special object,
//             where they have members
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void UpdateSpecialVars(LDAP         *pLdap, 
                       LDAPMessage  *pMessage, 
                       DWORD        *pdwCheckAttr,
                       DWORD        *pdwSpecialAction)
{                     
    DWORD             dwCheckAttr = 0;
    DWORD             dwSpecialAction = 0;
    DWORD             i;
    struct berelement *pBerElement = NULL;
    PWSTR             *rgszValue = NULL;
    PWSTR             szAttribute = NULL;
    PWSTR             szTemp = NULL;

    // ****************************************
    // Checking if iCheckAttr or iSpecialAction
    // ****************************************
    for (szAttribute = ldap_first_attribute( pLdap, pMessage, &pBerElement );
         szAttribute != NULL;
         szAttribute = ldap_next_attribute( pLdap, pMessage, pBerElement ) ) {
         
        rgszValue = ldap_get_values(pLdap, pMessage, szAttribute );
        if (_wcsicmp(L"objectClass",szAttribute) == 0) {
            for (i=0; rgszValue[i]!=NULL; i++) {
                //
                // check whether it is a SAM object
                //
                if (dwCheckAttr == 0) {
                    dwCheckAttr = CheckObjectSam(rgszValue[i]);
                }

                //
                // check whether it is a special object
                //
                if (dwSpecialAction == 0) { 
                    dwSpecialAction = CheckObjectSpecial(rgszValue[i]);
                }

                if (dwCheckAttr && dwSpecialAction) {
                    break;
                }
            }
        }
        ldap_value_free(rgszValue);
        rgszValue = NULL;
        if (dwCheckAttr && dwSpecialAction) {
            break;
        }
    }
    *pdwCheckAttr = dwCheckAttr;
    *pdwSpecialAction = dwSpecialAction;
}

//+---------------------------------------------------------------------------
// Function:  UpdateAttributeTable 
//
// Synopsis:  Update the attribute Table 
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR UpdateAttributeTable(LDAP         *pLdap, 
                             LDAPMessage  *pMessage,
                             BOOLEAN       fSamLogic,
                             BOOLEAN       fBinaryOutput,
                             BOOLEAN       *pfAppend,
                             PRTL_GENERIC_TABLE    pAttrTable)
{
    struct berelement *pBerElement = NULL;
    struct berval     **rgpVals = NULL;
    PWSTR             szAttribute = NULL;
    DWORD             cVal;
    NAME_MAP          NameMap;
    PNAME_MAP         pNameMap = NULL;
    NAME_MAP          NtiAttr;
    DIREXG_ERR           hr = DIREXG_SUCCESS;
    BOOLEAN           fNewElem;
    DWORD             dwCheckAttr;
    DWORD             dwSpecialAction;

    UpdateSpecialVars(pLdap,
                      pMessage,
                      &dwCheckAttr,
                      &dwSpecialAction);
    
    for ( szAttribute = ldap_first_attribute( pLdap, pMessage, &pBerElement );
          szAttribute != NULL;
          szAttribute = ldap_next_attribute( pLdap, pMessage, pBerElement ) ) {
        
        rgpVals = ldap_get_values_len(pLdap, 
                                      pMessage, 
                                      szAttribute );
        cVal = ldap_count_values_len(rgpVals);
        
        //
        // Omit Entries for Special cases
        // 1)Check SAM logic,  2)Check Omit table
        //
        if (dwCheckAttr && 
            fSamLogic && 
            CheckAttrSam(szAttribute, dwCheckAttr)) {
            ldap_value_free_len(rgpVals);
            rgpVals = NULL;
            continue;
        }
        NameMap.szName = szAttribute;
        NameMap.index = 0;
        if (RtlLookupElementGenericTable(g_pOmitTable, 
                                         &NameMap)) {
            ldap_value_free_len(rgpVals);
            rgpVals = NULL;                                         
            continue;
        }
    
        if (fSamLogic && 
            ((_wcsicmp(L"objectGUID", szAttribute) == 0) ||
             (_wcsicmp(L"isCriticalSystemObject", szAttribute) == 0))
           ) {
            ldap_value_free_len(rgpVals);
            rgpVals = NULL;                                         
            continue;
        }

        //
        // If sam logic on and is member, output to append
        //
        if (fSamLogic) { 
            if (SCGetAttByName(wcslen(szAttribute),
                               szAttribute) == TRUE) {
                if (wcscmp(szAttribute,g_szPrimaryGroup) == 0) {
                    if ((rgpVals[0]->bv_len == strlen(g_szDefaultGroup)) && 
                        (memcmp(rgpVals[0]->bv_val,
                                g_szDefaultGroup,
                                strlen(g_szDefaultGroup)*sizeof(CHAR)) == 0)
                        ) {
                        //
                        // If the primarygroup value is the same as default,
                        // we just ignore it when the object is actually
                        // being created, the default value will be put in
                        //                
                        ldap_value_free_len(rgpVals);
                        rgpVals = NULL;                                         
                        continue;
                    }
                    else {
                        //
                        // If the value is not default, we will append it
                        // (treat it as backlink). It cannot accompany the
                        // rest of the object because this operation will
                        // fail if the group does not exist yet
                        //
                        *pfAppend = TRUE;
                    }
                }
                else {
                    *pfAppend = TRUE;
                }
            }
        }
    
        //
        // Omit Entries for Binary
        //
        if (!fBinaryOutput) {
            BOOLEAN fReturn;
            fReturn =  CheckBinary(rgpVals,
                                   cVal);
            if (fReturn) {
                ldap_value_free_len(rgpVals);
                rgpVals = NULL;                                         
                continue;
            }
        }
        
        //
        // Looking for current Attribute in attribute Table, add if not exist
        //
        NtiAttr.szName = szAttribute;
        if (!NtiAttr.szName) {
            hr = DIREXG_OUTOFMEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        pNameMap = (PNAME_MAP)RtlLookupElementGenericTable (pAttrTable,
                                                            &NtiAttr);
        if (!pNameMap) {
            NtiAttr.index = g_iAttributeNext;
    
            if (g_iAttributeNext >= g_rgAttributeMax) {
                AttributeEntry* pTemp = NULL;
                pTemp = (AttributeEntry*)MemRealloc(g_rgAttribute,
                                        sizeof(AttributeEntry) * 
                                        (g_rgAttributeMax),
                                        sizeof(AttributeEntry) * 
                                        (g_rgAttributeMax + ATTRIBUTE_INC));
                if (!pTemp) {
                    hr = DIREXG_OUTOFMEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                g_rgAttribute = pTemp;
                g_rgAttributeMax += ATTRIBUTE_INC;
            }
            NtiAttr.szName = MemAllocStrW(szAttribute);
            if (!NtiAttr.szName) {
                hr = DIREXG_OUTOFMEMORY;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            g_rgAttribute[g_iAttributeNext].bExist = TRUE;
            g_rgAttribute[g_iAttributeNext].szValue = NtiAttr.szName;
            g_iAttributeNext++;
    
            RtlInsertElementGenericTable(pAttrTable,
                                         &NtiAttr,
                                         sizeof(NAME_MAP), 
                                         &fNewElem);          
        }
        else {
            g_rgAttribute[pNameMap->index].bExist = TRUE;
        }
        ldap_value_free_len(rgpVals);
        rgpVals = NULL;
    }
error:
    if (rgpVals) {
        ldap_value_free_len(rgpVals);
        rgpVals = NULL;
    }
    return (hr);
}


//+---------------------------------------------------------------------------
// Function:  SpanLines 
//
// Synopsis:   Special function added to convert file into multiple lines   
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR SpanLines(PWSTR szInput, PWSTR *pszOutput)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    BOOLEAN fInQuote = FALSE;
    DWORD dwState = 0;
    CString strOutput;
    WCHAR c[2];
    c[1] = '\0';    

    hr = strOutput.Init();
    DIREXG_BAIL_ON_FAILURE(hr);


    while (*szInput) {
        if (fInQuote) {
            if (*szInput == '"')
            {
                if ((*(szInput+1)) == '"') {
                    //
                    // Add both of them if they are '""'
                    //
                    c[0] = *szInput++;
                    strOutput.Append(c);
                }
                else {
                    fInQuote = FALSE;
                }
            }
        }
        else {
            if (*szInput == '"') {
                fInQuote = TRUE;
            }
            else if (*szInput == ','){
                if (*(szInput+1)) {
                    c[0] = *szInput++;
                    strOutput.Append(c);
                    strOutput.Append(L"&");             
                    strOutput.Append(g_szReturn);
                    continue;
                }
                else {
                    c[0] = *szInput++;
                    strOutput.Append(c);
                    continue;
                }
            }
        }
        
        c[0] = *szInput++;
        strOutput.Append(c);
    }

    hr = strOutput.GetCopy(pszOutput);
error:
    return hr;
}

__inline ULONG SCNameHash(ULONG size, PWCHAR pVal, ULONG count)
{
    ULONG val=0;
    while(size--) {
        // Map A->a, B->b, etc.  Also maps @->', but who cares.
        val += (*pVal | 0x20);
        pVal++;
    }
    return (val % count);
}


int 
SCGetAttByName(
        ULONG ulSize,
        PWCHAR pVal
        )
/*++

Routine Description:

    Find an attcache given its name.

Arguments:
    ulSize - the num of chars in the name.
    pVal - the chars in the name
    ppAttcache - the attribute cache returned

Return Value:
    Returns non-zero if exist, 0 otherwise.

--*/
{
    ULONG i;

    if (!g_BacklinkHashTable) {
        return FALSE;
    }

    i = SCNameHash(ulSize,pVal,g_nBacklinkCount);
    if (i >= g_nBacklinkCount) {
        // should never happen (SCNameHash should always return a value
        // of i that's in range)
        i=0;
    }

    while ((g_BacklinkHashTable[i].bUsed &&            // this hash spot refers to an object,
          ((g_BacklinkHashTable[i].length != ulSize * sizeof(WCHAR))|| // but the size is wrong
           _memicmp(g_BacklinkHashTable[i].value,pVal,ulSize* sizeof(WCHAR))))) // or the value is wrong
    {

        i++;
        
        if (i >= g_nBacklinkCount) {
            i=0;
        }
    }
    
    return (g_BacklinkHashTable[i].bUsed);
}


int 
SCInsert(
        ULONG ulSize,
        PWCHAR pVal
        )
/*++

Routine Description:

    Find an attcache given its name.

Arguments:
    ulSize - the num of chars in the name.
    pVal - the chars in the name
    ppAttcache - the attribute cache returned

Return Value:
    Returns TRUE if successfull, return 0 if duplicate

--*/
{ 
    ULONG i = SCNameHash(ulSize,pVal,g_nBacklinkCount);

    if (i >= g_nBacklinkCount) {
        // should never happen (SCNameHash should always return a value
        // of i that's in range)
        i=0;
    }

    while (g_BacklinkHashTable[i].bUsed)
    {
        if ((g_BacklinkHashTable[i].length == (ulSize* sizeof(WCHAR))) && 
            (_memicmp(g_BacklinkHashTable[i].value,pVal,(ulSize* sizeof(WCHAR))) == 0)) {
            return FALSE;   
        }

        i++;

        if (i >= g_nBacklinkCount) {
            i=0;
        }
    }
    
    g_BacklinkHashTable[i].length = (ulSize* sizeof(WCHAR));
    g_BacklinkHashTable[i].value = (PWSTR)MemAlloc(ulSize* sizeof(WCHAR));
    if (!g_BacklinkHashTable[i].value) {
        return FALSE;
    }

    memcpy(g_BacklinkHashTable[i].value,
           pVal,
           ulSize* sizeof(WCHAR));

    g_BacklinkHashTable[i].bUsed = TRUE;

    return TRUE;
}


//+---------------------------------------------------------------------------
// Function:    CreateBacklinkTable
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    31-1-98   Felix Wong Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR CreateOmitBacklinkTable(LDAP *pLdap, 
                                   PWSTR *rgszOmit,
                                   DWORD dwFlag,
                                   PWSTR *ppszNamingContext,
                                   BOOL *pfPagingAvail,
                                   BOOL *pfSAMAvail)
{
    LDAPMessage     *pSearchMessage = NULL;
    LDAPMessage     *pMessage = NULL;
    struct berelement *pBerElement = NULL;
    PWSTR *rgszValue = NULL;
    DIREXG_ERR hr = DIREXG_SUCCESS;
    ULONG nCount = 0;
    PWSTR szTemp = NULL;
    PWSTR szAttribute = NULL;
    ULONG i;
    NAME_MAP    NtiElem;
    BOOLEAN bNewElem;
    ULONG iLinkID = 0;
    PWSTR szLinkCN = NULL;
    PWSTR szSchemaPath = NULL;
    BOOLEAN bNamingContext = (BOOLEAN)(dwFlag & INIT_NAMINGCONTEXT);
    BOOLEAN bBacklink = (BOOLEAN)(dwFlag & INIT_BACKLINK);
    BOOL fPagingAvail = FALSE;
    BOOL fSAMAvail = FALSE;

    //
    // Generating OMIT table
    //
    g_pOmitTable = (PRTL_GENERIC_TABLE) MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!g_pOmitTable) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    RtlInitializeGenericTable(g_pOmitTable, 
                              NtiComp, 
                              NtiAlloc, 
                              NtiFree, 
                              NULL);
    
    if (rgszOmit) {
        i = 0;
        while(rgszOmit[i]) {
            NtiElem.szName = MemAllocStrW(rgszOmit[i]);
            if (!NtiElem.szName) {
                hr = DIREXG_OUTOFMEMORY;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            NtiElem.index = 0;
            RtlInsertElementGenericTable(g_pOmitTable,
                                         &NtiElem,
                                         sizeof(NAME_MAP), 
                                         &bNewElem);
            if (!bNewElem) {
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            i++;
        }
    }
    
    //
    // We search rootdse either we search for backlinks, need to get the 
    // base context, or if we need to check whether paging is available or not
    //
    if (bBacklink || bNamingContext || pfPagingAvail) {
        if ( (ldap_search_s(pLdap, 
                           NULL, 
                           LDAP_SCOPE_BASE, 
                           L"(objectClass=*)", 
                           rgszSchemaList,  
                           0, 
                           &pSearchMessage))!= LDAP_SUCCESS ) {
            //
            // RootDSE search fails
            // pfPagingAvail will be FALSE as well
            //
            if (ppszNamingContext)
                *ppszNamingContext = NULL;
            BAIL();         
        }
        
        for ( pMessage = ldap_first_entry( pLdap, 
                                           pSearchMessage ); 
              pMessage != NULL; 
              pMessage = ldap_next_entry( pLdap, 
                                             pMessage ) ) { 
            for (   szAttribute = ldap_first_attribute( pLdap, pMessage, &pBerElement );
                    szAttribute != NULL;
                    szAttribute = ldap_next_attribute( pLdap, pMessage, pBerElement ) ) {
                 
                    rgszValue = ldap_get_values(pLdap, pMessage, szAttribute );
                    if (rgszValue == NULL) {
                        hr = DIREXG_ERROR;
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                    if (_wcsicmp(L"schemaNamingContext",szAttribute) == 0) {
                        szSchemaPath =MemAllocStrW(rgszValue[0]);
                        if (!szSchemaPath) {
                            hr = DIREXG_OUTOFMEMORY;
                            DIREXG_BAIL_ON_FAILURE(hr);
                        }
                    }
                    else if (_wcsicmp(L"defaultNamingContext",szAttribute) == 0) {
                        (*ppszNamingContext)=(PWSTR )MemAllocStrW(rgszValue[0]);
                        if (!(*ppszNamingContext)) {
                            hr = DIREXG_OUTOFMEMORY;
                            DIREXG_BAIL_ON_FAILURE(hr);
                        }
                    }
                    else if (_wcsicmp(L"supportedControl",szAttribute) == 0) {
                        DWORD i = 0;
                        while (rgszValue[i]) {
                            if (wcscmp(rgszValue[i],LDAP_PAGED_RESULT_OID_STRING_W) == 0) {
                                fPagingAvail = TRUE;
                                break;
                            }
                            i++;
                        }
                    }
                    else {
                        hr = DIREXG_ERROR;
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                    ldap_value_free(rgszValue );
                    rgszValue = NULL;
            }
        }
    
        if (pSearchMessage) {
            ldap_msgfree(pSearchMessage);
            pSearchMessage = NULL;
        }
    }

    if (bBacklink) {
        if ( (ldap_search_s(pLdap, 
                           szSchemaPath,
                           LDAP_SCOPE_ONELEVEL, 
                           L"(&(objectClass= attributeSchema)(|(linkid=*)(attributeSyntax=2.5.5.1)))", 
                           rgszAttrList,  
                           0, 
                           &pSearchMessage))!= LDAP_SUCCESS ) {
            BAIL();         
        }
        MemFree(szSchemaPath);
        szSchemaPath = NULL;
        
        nCount = ldap_count_entries(pLdap,
                                    pSearchMessage);
        nCount *= 2;
        
        g_nBacklinkCount = nCount;
        if (nCount == 0) {
            g_BacklinkHashTable = NULL;
        }
        else {
            g_BacklinkHashTable = (HASHCACHESTRING*)MemAlloc(g_nBacklinkCount * sizeof(HASHCACHESTRING));     
            if (!g_BacklinkHashTable) {
                hr = DIREXG_OUTOFMEMORY;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            memset(g_BacklinkHashTable,0,g_nBacklinkCount * sizeof(HASHCACHESTRING));
        }

        if (SCInsert(wcslen(g_szPrimaryGroup),
                     g_szPrimaryGroup) == FALSE) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        for ( pMessage = ldap_first_entry( pLdap, 
                                              pSearchMessage ); 
              pMessage != NULL; 
              pMessage = ldap_next_entry( pLdap, 
                                             pMessage ) ) { 

            BOOLEAN bLinkIDPresent = FALSE;
            szLinkCN = NULL;
            for (   szAttribute = ldap_first_attribute( pLdap, pMessage, &pBerElement );
                    szAttribute != NULL;
                    szAttribute = ldap_next_attribute( pLdap, pMessage, pBerElement ) ) {
                rgszValue = ldap_get_values(pLdap, pMessage, szAttribute );
                if (rgszValue == NULL) {
                    hr = DIREXG_ERROR;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                if (!_wcsicmp(L"ldapdisplayname",szAttribute)) {
                    szLinkCN = MemAllocStrW(rgszValue[0]);
                    if (!szLinkCN) {
                        hr = DIREXG_OUTOFMEMORY;
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                }
                else {
                    szTemp = MemAllocStrW(rgszValue[0]);
                    if (!szTemp) {
                        hr = DIREXG_OUTOFMEMORY;
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                    iLinkID = _wtoi(szTemp);
                    MemFree(szTemp);
                    szTemp = NULL;
                    bLinkIDPresent = TRUE;
                }
                ldap_value_free(rgszValue);
                rgszValue = NULL;
            }
            if (!szLinkCN) {
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            //
            // If it is not a linked ID (and thus a DN type attribute) or if it
            // is the source linked ID (source linked ID are even while
            // targets are odd)
            //
            if (((!bLinkIDPresent) || ((iLinkID % 2) == 0))) {
                //
                // Ignore 'distinguishname and objectcategory' because they are
                // DN attributes that exist in every object
                //
                if ((wcscmp(szLinkCN, L"objectCategory") == 0) ||
                    (wcscmp(szLinkCN, L"distinguishedName") == 0)) {
                    MemFree(szLinkCN);
                    szLinkCN = NULL;
                    continue;
                }

                //
                // Insert into Backlink Hash
                //
                if (SCInsert(wcslen(szLinkCN),
                             szLinkCN) == FALSE) {
                        hr = DIREXG_ERROR;
                        DIREXG_BAIL_ON_FAILURE(hr);
                }
                MemFree(szLinkCN);
                szLinkCN = NULL;
            }
            else {
                //
                // Insert into our Omit Table
                //
                NtiElem.szName = szLinkCN;
                NtiElem.index = 0;
                RtlInsertElementGenericTable(g_pOmitTable,
                                             &NtiElem,
                                             sizeof(NAME_MAP), 
                                             &bNewElem);
                if (!bNewElem) {
                    hr = DIREXG_ERROR;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                szLinkCN = NULL;
            }
        }
            
        if (pSearchMessage) {
            ldap_msgfree(pSearchMessage);
            pSearchMessage = NULL;
        }
        fSAMAvail = TRUE;
    }

    i = 0;
    while(g_rgszOmit[i]) {
        NtiElem.szName = MemAllocStrW(g_rgszOmit[i]);
        if (!NtiElem.szName) {
            hr = DIREXG_OUTOFMEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        NtiElem.index = 0;
        RtlInsertElementGenericTable(g_pOmitTable,
                                     &NtiElem,
                                     sizeof(NAME_MAP), 
                                     &bNewElem);
                    //
                    // If there is a duplicate entry already
                    //
        if (!bNewElem) {
                            MemFree(NtiElem.szName);
        }
        i++;
    }

error:
    if (rgszValue) {
        ldap_value_free(rgszValue);
        rgszValue = NULL;
    }
    if (szLinkCN) {
        MemFree(szLinkCN);
    }
    if (pSearchMessage) {
        ldap_msgfree(pSearchMessage);
    }
    if (szTemp) {
        MemFree(szTemp);
    }
    if (szSchemaPath) {
        MemFree(szSchemaPath);
    }
    if (pfPagingAvail) {
        *pfPagingAvail = fPagingAvail;
    }
    if (pfSAMAvail) {
        *pfSAMAvail = fSAMAvail;
    }
    return hr;

}

DIREXG_ERR 
ConvertUTF8ToUnicode(
    PBYTE pVal,
    DWORD dwLen,
    PWSTR *pszValue,
    DWORD *pdwLen
    )

/*++

Routine Description:

    Convert a Value from the Ansi syntax to Unicode

Arguments:

    *ppVal - pointer to value to convert
    *pdwLen - pointer to length of string in bytes

Return Value:

    S_OK on success, error code otherwise

--*/

{
    HRESULT hr = S_OK;
    PWSTR pszUnicode = NULL;
    int nReturn = 0;

    //
    // Allocate memory for the Unicode String
    //
    pszUnicode = (PWSTR)MemAlloc((dwLen + 1) * sizeof(WCHAR));
    if (!pszUnicode) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    nReturn = LdapUTF8ToUnicode((PSTR)pVal,
                                dwLen,
                                pszUnicode,
                                dwLen + 1);

    //
    // NULL terminate it
    //

    pszUnicode[nReturn] = '\0';

    *pszValue = pszUnicode;
    *pdwLen = (nReturn + 1) * sizeof(WCHAR);

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\csvds\samrestrict.h ===
#ifndef _SAM_H
#define _SAM_H

/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    samrestrict.h

ABSTRACT:
    
    Ldap display names of SAM read-only attrbiutes.

DETAILS:

    We have the problem that if we export out SAM objects,
    we can't put them back in with all the attributes we 
    get because some of them are SAM read only.
    This header contains the read onlys listed by
    their ldapDisplayNames, for each Sam object type.  
    
    
CREATED:

    07/14/97    Roman Yelensky (t-romany)

REVISION HISTORY:

--*/

/*
 * The server and domain are here only for completeness, its not actually
 * relevant and is not expected and won't work for import/export operations.
 */


//
// CLASS_SAM_SERVER, SampServerObjectType (ldapdisplayname: samServer) 
//
PWSTR g_rgszServerSAM[] = {
     L"revision",  //SAMP_FIXED_SERVER_REVISION_LEVEL, ATT_REVISION
     L"objectSid", //not in mappings.c, but still required!, ATT_OBJECT_SID
     NULL
};


//
// CLASS_SAM_DOMAIN, SampDomainObjectType (ldapdisplayname: domain) 
//
PWSTR g_rgszDomainSAM[] = {
    L"objectSid",                // SAMP_DOMAIN_SID, ATT_OBJECT_SID
    L"domainReplica",            // SAMP_DOMAIN_REPLICA, ATT_DOMAIN_REPLICA
    L"creationTime",             // SAMP_FIXED_DOMAIN_CREATION_TIME, 
                                // ATT_CREATION_TIME
    L"modifiedCount",            // SAMP_FIXED_DOMAIN_MODIFIED_COUNT,
                                // ATT_MODIFIED_COUNT
    L"modifiedCountAtLastProm",  // SAMP_FIXED_DOMAIN_MODCOUNT_LAST_PROMOTION, 
                                // ATT_MODIFIED_COUNT_AT_LAST_PROM
    L"nextRid",                  // SAMP_FIXED_DOMAIN_NEXT_RID, ATT_NEXT_RID
    L"serverState",              // SAMP_FIXED_DOMAIN_SERVER_STATE, 
                                // ATT_SERVER_STATE
    L"sAMAccountType",           // SAMP_DOMAIN_ACCOUNT_TYPE, 
                                // ATT_SAM_ACCOUNT_TYPE
    L"uASCompat",               // SAMP_FIXED_DOMAIN_UAS_COMPAT_REQUIRED,
                                //  ATT_UAS_COMPAT
    NULL
};


//
// CLASS_GROUP, SampGroupObjectType (ldapdisplayname: group) 
//
PWSTR g_rgszGroupSAM[] = {
    L"rid",                 // SAMP_FIXED_GROUP_RID, ATT_RID
    L"sAMAccountType",      // SAMP_GROUP_ACCOUNT_TYPE, ATT_SAM_ACCOUNT_TYPE
    L"objectSid",           // not in mappings.c, but still required!, 
                           // ATT_OBJECT_SID
    L"memberOf",            // SAMP_USER_GROUPS, ATT_MEMBER
    L"isCriticalSystemObject", // SAMP_FIXED_GROUP_IS_CRITICAL,
                               //  ATT_IS_CRITICAL_SYSTEM_OBJECT
    NULL
};


//
// CLASS_LOCALGROUP, SampAliasObjectType (ldapdisplayname: localGroup) 
//
PWSTR g_rgszLocalGroupSAM[] = {
    L"rid",                // SAMP_FIXED_ALIAS_RID, ATT_RID
    L"sAMAccountType",     // SAMP_ALIAS_ACCOUNT_TYPE, ATT_SAM_ACCOUNT_TYPE
    L"objectSid",          // not in mappings.c, but still required!, ATT_OBJECT_SID
    L"isCriticalSystemObject", // SAMP_FIXED_GROUP_IS_CRITICAL,
                               //  ATT_IS_CRITICAL_SYSTEM_OBJECT
    NULL
};


//
// CLASS_USER, SampUserObjectType (ldapdisplayname: user)
//
PWSTR g_rgszUserSAM[] = {
    L"memberOf",                // SAMP_USER_GROUPS, ATT_MEMBER
    L"dBCSPwd",                 // SAMP_USER_DBCS_PWD, ATT_DBCS_PWD
    L"ntPwdHistory",            // SAMP_USER_NT_PWD_HISTORY, ATT_NT_PWD_HISTORY
    L"lmPwdHistory",            // SAMP_USER_LM_PWD_HISTORY, ATT_LM_PWD_HISTORY
    L"lastLogon",               // SAMP_FIXED_USER_LAST_LOGON, ATT_LAST_LOGON
    L"lastLogoff",              // SAMP_FIXED_USER_LAST_LOGOFF, ATT_LAST_LOGOFF
    L"badPasswordTime",         // SAMP_FIXED_USER_LAST_BAD_PASSWORD_TIME, 
                               // ATT_BAD_PASSWORD_TIME
    L"rid",                     // SAMP_FIXED_USER_USERID, ATT_RID
    L"badPwdCount",             // SAMP_FIXED_USER_BAD_PWD_COUNT, 
                               // ATT_BAD_PWD_COUNT
    L"logonCount",              // SAMP_FIXED_USER_LOGON_COUNT, ATT_LOGON_COUNT
    L"sAMAccountType",          // SAMP_USER_ACCOUNT_TYPE, ATT_SAM_ACCOUNT_TYPE
    L"supplementalCredentials", // SAMP_FIXED_USER_SUPPLEMENTAL_CREDENTIALS,
                               // ATT_SUPPLEMENTAL_CREDENTIALS
    L"objectSid",               // not in mappings.c, but still required!, 
                               // ATT_OBJECT_SID
    L"pwdLastSet",
    L"isCriticalSystemObject",  // SAMP_FIXED_USER_IS_CRITICAL,
                                //  ATT_IS_CRITICAL_SYSTEM_OBJECT
    L"lastLogonTimestamp",      // SAMP_FIXED_USER_LAST_LOGON_TIMESTAMP,
                                //  ATT_LAST_LOGON_TIMESTAMP
    NULL
};


PWSTR g_rgszSamObjects[] = {
    L"samServer",
    L"domain",
    L"group",
    L"localGroup",
    L"user",
    NULL
};
    
PRTL_GENERIC_TABLE pSamObjects=NULL;
PRTL_GENERIC_TABLE pServerAttrs=NULL;
PRTL_GENERIC_TABLE pDomainAttrs=NULL;
PRTL_GENERIC_TABLE pGroupAttrs=NULL;
PRTL_GENERIC_TABLE pLocalGroupAttrs=NULL;
PRTL_GENERIC_TABLE pUserAttrs=NULL;

/*Although not restricted to SAM type stuff 
 (but currently only used for such), 
 the two tables below list any objects that we must do special 
 outputting for and their associated special actions. 
 This will we setup into tables in the table creation
 function and used in LL_ldap_parse()*/

PWSTR g_rgszSpecialClass[] = {
    L"domain",
    L"group",
    L"localGroup",
    NULL
};


int g_rgAction[] = {
    S_MEM,
    S_MEM,
    S_MEM,
    0
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\csvds\import.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    import.cxx

Abstract:
    
    Import operations of CSV

Author:

    Felix Wong [FelixW]    22-Jul-1997
    
++*/

#include "csvde.hxx"
#pragma hdrstop

CLexer *g_pLexer = NULL;
int g_iDN = -1;
PWSTR g_szFrom = NULL;
PWSTR g_szTo = NULL;
long g_cAttributeTotal = 0;
DWORD g_cLine = 0;
DWORD g_cColumn = 0;
extern PWSTR szFileFlagR;
extern BOOLEAN g_fUnicode;

//+---------------------------------------------------------------------------
// Function:    InitEntry
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR InitEntry(csv_entry *pEntry, DWORD dwEntry)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;

    pEntry->ppMod = (LDAPMod **)MemAlloc((dwEntry + 1) * sizeof(LDAPMod *));
    if (!pEntry->ppMod) {
        hr = DIREXG_OUTOFMEMORY;
    }

    pEntry->ppModAfter[1] = NULL;
    return hr;
}

//+---------------------------------------------------------------------------
// Function:    FreeEntryInfo
//
// Synopsis:    Free information containing in the Entry
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void FreeEntryInfo(csv_entry *pEntry)
{
    if (pEntry->szDN) {
        MemFree(pEntry->szDN);
        pEntry->szDN = NULL;
    }
    if (pEntry->ppMod) {
        FreeMod(pEntry->ppMod);
    }
    if (pEntry->ppModAfter[0]) {
        FreeMod(pEntry->ppModAfter);
        pEntry->ppModAfter[0] = NULL;
    }
}

//+---------------------------------------------------------------------------
// Function:    FreeEntry
//
// Synopsis:    Free the entry
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void FreeEntry(csv_entry *pEntry)
{
    if (pEntry->ppMod) {
        MemFree(pEntry->ppMod);
        pEntry->ppMod = NULL;
    }
}


//+---------------------------------------------------------------------------
// Function:    PrintMod
//
// Synopsis:    Print out the values in the LDAP MOD structure
//
// Arguments:   LDAPMod **pMod
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR
PrintMod(LDAPMod **ppMod, DWORD dwType)
{
    DWORD        cAttribute = 0;
    PWSTR       *string_array;
    struct       berval **ber_array;
   
    if (!ppMod) {
        return DIREXG_ERROR;
    }
    
    while(*ppMod) {
        if ( (*ppMod)->mod_op == (((*ppMod)->mod_op)|LDAP_MOD_BVALUES) ) {
            
            //
            // BVALUE
            //
            SelectivePrint2(dwType,
                           L"Attribute %d) %s:",
                           cAttribute,
                           (*ppMod)->mod_type); 
            ber_array=(*ppMod)->mod_bvalues;
            if (ber_array) {
                while (*ber_array) {
                    SelectivePrint( dwType,
                                    MSG_CSVDE_UNPRINTABLEBINARY,
                                    (*ber_array)->bv_len);
                    ber_array++;
                }
            }
            
            SelectivePrint2( dwType,
                            L"\r\n");
        } else {
            
            //
            // STRING
            //
            SelectivePrint2(dwType,
                           L"Attribute %d) %s:",
                           cAttribute,
                           (*ppMod)->mod_type); 
            string_array=(*ppMod)->mod_values;
            if (string_array) {
                while (*string_array) {
                    SelectivePrint2(dwType,
                                    L" %s",
                                    (*string_array));
                    string_array++;
                }
            }
            SelectivePrint2( dwType,
                            L"\r\n");
        }   
        
        ppMod++;
        cAttribute++;
    }
    SelectivePrint2( dwType,
                    L"\r\n");
    return DIREXG_SUCCESS;
}


//+---------------------------------------------------------------------------
// Function:    FreeMod
//
// Synopsis:    Free out the Mod memory
//
// Arguments:   LDAPMod **ppMod
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR
FreeMod(LDAPMod** ppMod) {
    
   PWSTR *string_array;
   struct berval **ber_array;
   
   while(*ppMod) {
        if ( (*ppMod)->mod_op == (((*ppMod)->mod_op)|LDAP_MOD_BVALUES )) {
            // BVALUE
            ber_array=(*ppMod)->mod_bvalues;

            while (*ber_array) {
                MemFree ((*ber_array)->bv_val);            //MemFree the byte blob
                MemFree (*ber_array);                      //MemFree the struct
                ber_array++;
            }
            MemFree((*ppMod)->mod_bvalues);
        } else {
            // STRING
            string_array=(*ppMod)->mod_values;

            while (*string_array) {
                MemFree (*string_array);
                string_array++;
            }
            
            MemFree((*ppMod)->mod_values);
        }   
        MemFree ((*ppMod)->mod_type);
        MemFree(*ppMod);
        *ppMod = NULL;
        ppMod++;
   }
   return DIREXG_SUCCESS;
}

//+---------------------------------------------------------------------------
// Function:    MakeAttribute
//
// Synopsis:    Make an attribute
//
// Arguments:   LDAPMod *pMod
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR
MakeAttribute(LDAPMod **ppAttribute, 
              LDAPMod **ppAttributeMod,
              PWSTR szType, 
              PWSTR *pszVal, 
              DWORD cValue, 
              BOOLEAN bBinary,
                          BOOLEAN *pfAfter) 
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    LDAPMod *pAttribute = NULL;
    DWORD cValueCur = 0;

    pAttribute = (LDAPMod *)MemAlloc(sizeof(LDAPMod));
    if (!pAttribute ) {
         hr = DIREXG_OUTOFMEMORY;
         DIREXG_BAIL_ON_FAILURE(hr);
    }
    memset(pAttribute, 0 ,sizeof(LDAPMod));

    if (!bBinary) {       
        pAttribute->mod_op=LDAP_MOD_ADD;

        pAttribute->mod_type = MemAllocStrW(szType);
        if (!pAttribute->mod_type) {
             hr = DIREXG_OUTOFMEMORY;
             DIREXG_BAIL_ON_FAILURE(hr);
        }           

        pAttribute->mod_values = (PWSTR*)MemAlloc((cValue+1)*sizeof(PWSTR));
        if (!pAttribute->mod_values) {
             hr = DIREXG_OUTOFMEMORY;
             DIREXG_BAIL_ON_FAILURE(hr);
        }
        memset(pAttribute->mod_values, 0 ,sizeof((cValue+1)*sizeof(PWSTR)));

        while (cValueCur < cValue) {
            PWSTR szFinal = NULL;
            BOOL  fNeedToFree = FALSE;
            if (g_szFrom) {
                hr = SubString(*pszVal,
                               g_szFrom,
                               g_szTo,
                               &szFinal);
                DIREXG_BAIL_ON_FAILURE(hr);
                if (!szFinal) { 
                    szFinal = *pszVal;
                }
                else {
                    fNeedToFree = TRUE;
                }
            }
            else {
                szFinal = *pszVal;
            }
            pszVal++;
            (pAttribute->mod_values)[cValueCur]=MemAllocStrW(szFinal);
            if (!(pAttribute->mod_values)[cValueCur]) {
                 hr = DIREXG_OUTOFMEMORY;
                 DIREXG_BAIL_ON_FAILURE(hr);
            }
            cValueCur++;

            if (fNeedToFree) {
                MemFree(szFinal);
            }
        }

        (pAttribute->mod_values)[cValueCur] = NULL;  
    
    } 
    else {

        pAttribute->mod_op=LDAP_MOD_ADD|LDAP_MOD_BVALUES;
        pAttribute->mod_type = MemAllocStrW(szType);
        if (!pAttribute->mod_type) {
             hr = DIREXG_OUTOFMEMORY;
             DIREXG_BAIL_ON_FAILURE(hr);
        }

        pAttribute->mod_bvalues =
                (struct berval **)MemAlloc((cValue+1)*sizeof(struct berval *));
        if (!pAttribute->mod_bvalues) {
             hr = DIREXG_OUTOFMEMORY;
             DIREXG_BAIL_ON_FAILURE(hr);
        }
        memset(pAttribute->mod_bvalues, 0 ,sizeof((cValue+1)*sizeof(struct berval *)));

        while (cValueCur < cValue) {
            (pAttribute->mod_bvalues)[cValueCur] =
                                (struct berval *)MemAlloc(sizeof(struct berval));
            if (!(pAttribute->mod_bvalues)[cValueCur]) {
                 hr = DIREXG_OUTOFMEMORY;
                 DIREXG_BAIL_ON_FAILURE(hr);
            }
            
            hr = StringToBVal(*pszVal++,
                              ((pAttribute->mod_bvalues)[cValueCur]));
            DIREXG_BAIL_ON_FAILURE(hr);
             
            cValueCur++;
        }
        (pAttribute->mod_values)[cValueCur] = NULL;  
    }

    //
    // Extra logic added to do modify member attribute separately
    //
    if (_wcsicmp(szType,L"member")==0) {
        *ppAttributeMod = pAttribute;
        *pfAfter = TRUE;
    }
    else {
        *ppAttribute = pAttribute;
        *pfAfter = FALSE;
    }

    return hr;
error:
    if (pAttribute) {
        if (!bBinary) {       
            if (pAttribute->mod_type) {
                MemFree(pAttribute->mod_type);
            }
            if (pAttribute->mod_values) {   
                DWORD k=0;
                while ((pAttribute->mod_values)[k]) {
                    MemFree((pAttribute->mod_values)[k]);
                    k++;
                }
                MemFree(pAttribute->mod_values);
            }
        } 
        else {
            if (pAttribute->mod_type) {
                MemFree(pAttribute->mod_type);
            }
            if (pAttribute->mod_bvalues) {  
                DWORD k=0;
                while ((pAttribute->mod_bvalues)[k]) {
                    if ((pAttribute->mod_bvalues)[k]->bv_val)
                        MemFree((pAttribute->mod_bvalues)[k]->bv_val);
                    MemFree((pAttribute->mod_bvalues)[k]);
                    k++;
                }
                MemFree(pAttribute->mod_bvalues);
            }
        }
        MemFree(pAttribute);
    }
    return hr;
}


//+---------------------------------------------------------------------------
// Function:    GetNextEntry
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR
GetNextEntry(csv_entry *pEntry, PWSTR *rgAttribute)
{
    PWSTR   szToken = NULL;
    DWORD   cAttributes = 0;
    DWORD   dwToken;
    long    iIndex = 0;
    CStringPlex StringPlex;
    BOOLEAN bBinary = FALSE;
    DIREXG_ERR hr = DIREXG_ERROR;
    CString StrDN;

    pEntry->ppModAfter[0] = NULL;
    pEntry->szDN = NULL;
    
    iIndex = 0; 
    do {
        BOOLEAN fAfter = FALSE;
        bBinary = FALSE;

        if (szToken) {
            MemFree(szToken);
            szToken = NULL;
        }

        hr = StringPlex.Init();
        DIREXG_BAIL_ON_FAILURE(hr);
        hr = g_pLexer->GetNextToken(&szToken, &dwToken);
        DIREXG_BAIL_ON_FAILURE(hr);
    
        if (dwToken == TOKEN_END) {
            if (iIndex == 0) {
                // First entry is null, implies no more entries
                hr = DIREXG_NOMORE_ENTRY;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            else {
                // Reaches the end, done
                break;
            }
        }

        if (dwToken == TOKEN_COMMA) {
            iIndex++;
            continue;
        }

        if (dwToken != TOKEN_IDENTIFIER && dwToken != TOKEN_HEX) {
            //
            // index count starts at 0, and thus iIndex+1 is the current entry
            // number
            //
            SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                            MSG_CSVDE_EXPECTIDHEX,iIndex+1,g_cColumn);
            hr = DIREXG_ERROR;
            goto error;
        }


        if (iIndex == g_iDN) {
            if (g_szFrom) {
                pEntry->szDN = NULL;
                hr = SubString(szToken,
                               g_szFrom,
                               g_szTo,
                               &pEntry->szDN );
                DIREXG_BAIL_ON_FAILURE(hr);
                if (!pEntry->szDN ) { 
                    pEntry->szDN = MemAllocStrW(szToken);
                }
            }
            else {
                pEntry->szDN = MemAllocStrW(szToken);
            }

            if (!pEntry->szDN) {
                hr = DIREXG_OUTOFMEMORY;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            MemFree(szToken);
            szToken = NULL;
            hr = g_pLexer->GetNextToken(&szToken, &dwToken);
            DIREXG_BAIL_ON_FAILURE(hr);
            iIndex++;
            continue;
        }

        hr = StringPlex.AddElement(szToken);
        DIREXG_BAIL_ON_FAILURE(hr);
        if (dwToken == TOKEN_HEX) {
            bBinary = TRUE;
        }
        MemFree(szToken);
        szToken = NULL;
        
        hr = g_pLexer->GetNextToken(&szToken, &dwToken);
        DIREXG_BAIL_ON_FAILURE(hr);
        
        while (dwToken == TOKEN_SEMICOLON) {
            
            if (szToken) {
                MemFree(szToken);
                szToken = NULL;
            }
            //
            // Multivalue
            //
            hr = g_pLexer->GetNextToken(&szToken, &dwToken);
            DIREXG_BAIL_ON_FAILURE(hr);
            if (dwToken != TOKEN_IDENTIFIER && dwToken != TOKEN_HEX) {
                SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                                MSG_CSVDE_EXPECTIDHEX,iIndex+1,g_cColumn);
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
    
            hr = StringPlex.AddElement(szToken);
            DIREXG_BAIL_ON_FAILURE(hr);
            if (dwToken == TOKEN_HEX && (!bBinary)) {
                SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                                MSG_CSVDE_ERROR_INCONVALUES,iIndex+1,g_cColumn);
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            if (szToken) {
                MemFree(szToken);
                szToken = NULL;
            }

            hr = g_pLexer->GetNextToken(&szToken, &dwToken);
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        
        hr = MakeAttribute(&(pEntry->ppMod[cAttributes]), 
                           &(pEntry->ppModAfter[0]),                
                           rgAttribute[iIndex], 
                           StringPlex.Plex(),
                           StringPlex.NumElements(),
                           bBinary,
                           &fAfter);
        DIREXG_BAIL_ON_FAILURE(hr);
        
        if (!fAfter) {
            cAttributes++;
        }
        iIndex++;
    }
    while (dwToken == TOKEN_COMMA && (iIndex != g_cAttributeTotal));

    if (dwToken == TOKEN_COMMA) {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_INVALIDNUM_ATTR);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    if (dwToken != TOKEN_END) {
        //
        // We are telling the entry number before the failure, and its thus
        // iIndex, (iIndex+1 is the current entry)
        //
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_EXPECT_COMMA,iIndex,g_cColumn);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
         
    pEntry->ppMod[cAttributes] = NULL; 
    
    if (szToken) {
        MemFree(szToken);
    }
    return DIREXG_SUCCESS;

error:
    pEntry->ppMod[cAttributes] = NULL; 
    FreeEntryInfo(pEntry);
    FreeEntry(pEntry);
    if (szToken) {
        MemFree(szToken);
    }
    return hr;
}            

//+---------------------------------------------------------------------------
// Function:    DSImport
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR 
DSImport(LDAP *pLdap, 
         ds_arg *pArg)
{
    DIREXG_ERR     hr = DIREXG_ERROR;
    int         ldap_err;
    csv_entry   CSVEntry;
    FILE        *pFileIn = NULL;
    PWSTR       *rgAttribute = NULL;
    DWORD       cAttribute = 0;
    DWORD       cLine = 0;
    DWORD       cAdded = 0;
    long        i = 0;

    //
    // Initializing Variables
    //
    CSVEntry.szDN = NULL;
    CSVEntry.ppMod = NULL;
    CSVEntry.ppModAfter[0] = NULL;
    
    SelectivePrint( PRT_STD|PRT_LOG,
                    MSG_CSVDE_IMPORTDIR,
                    pArg->szFilename);
    
    //
    // If Unicode is not enabled by use, we'll test if the file is Unicode
    // by checking if it has the first byte as FFFE
    //
    if (pArg->fUnicode == FALSE) {
        if ((pFileIn = _wfopen(pArg->szFilename, L"rb")) == NULL) {
            SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                            MSG_CSVDE_ERROR_OPENINPUT);
            hr = DIREXG_FILEERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        if (fgetwc(pFileIn) == UNICODE_MARK) {
            pArg->fUnicode = TRUE;
        };
        fclose(pFileIn);
    }

    //
    // Setting the default File Read Flags
    //
    if (pArg->fUnicode == FALSE) {
        szFileFlagR = L"rt";
    }
    else {
        szFileFlagR = L"rb";    // Use binary if Unicode
        g_fUnicode = TRUE;
    }

    if ((pFileIn = _wfopen(pArg->szFilename, szFileFlagR)) == NULL) {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_ERROR_OPENINPUT);
        hr = DIREXG_FILEERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    g_pLexer = new CLexer();
    if (!g_pLexer) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    hr = g_pLexer->Init(pFileIn);
    DIREXG_BAIL_ON_FAILURE(hr);

    //
    // If it is Unicode, we might have a leading byte FFFE. In that case, we'll
    // bypass it
    //
    if (pArg->fUnicode) {
        WCHAR charw = g_pLexer->NextChar();
        if (charw != UNICODE_MARK) {
            g_pLexer->PushbackChar();
        }
    }

    g_szFrom = pArg->szFromDN;
    g_szTo = pArg->szToDN;
    
    //
    // Getting Attribute Names from first line
    //
    cLine = 1;

    hr = GetAttributeType(&rgAttribute,
                          &cAttribute);
    DIREXG_BAIL_ON_FAILURE(hr);
    g_cAttributeTotal = cAttribute;

    hr = InitEntry(&CSVEntry,
                   cAttribute);
    DIREXG_BAIL_ON_FAILURE(hr);

    SelectivePrint( PRT_STD|PRT_LOG,
                    MSG_CSVDE_LOADING,
                    pArg->szFilename);
    SelectivePrint2( PRT_STD_VERBOSEONLY|PRT_LOG,
                    L"\r\n");
    TrackStatus();

    //
    // Getting Entry information one by one
    //
    cLine++;
    while ((hr = GetNextEntry(&CSVEntry,
                              rgAttribute)) == DIREXG_SUCCESS) {
        SelectivePrint2( PRT_STD_VERBOSEONLY|PRT_LOG,
                        L"%d: %s\r\n",
                        cLine,
                        CSVEntry.szDN);
        PrintMod(CSVEntry.ppMod, 
                 PRT_LOG);
        ldap_err = ldap_add_s(pLdap, 
                              CSVEntry.szDN, 
                              CSVEntry.ppMod);
        if (ldap_err != LDAP_SUCCESS) {
            PrintMod(CSVEntry.ppMod, 
                     PRT_ERROR);
            if (pArg->fSkipExist && 
                    (ldap_err == LDAP_ALREADY_EXISTS || 
                     ldap_err == LDAP_CONSTRAINT_VIOLATION ||
                     ldap_err == LDAP_ATTRIBUTE_OR_VALUE_EXISTS)) {
                //
                // Error that can be ignored
                //
                if (ldap_err == LDAP_ALREADY_EXISTS) {
                    SelectivePrint2( PRT_ERROR,
                                    L"%d: ",
                                    cLine);
                    SelectivePrint( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                    MSG_CSVDE_ENTRYEXIST);
                }
                else if (ldap_err == LDAP_ATTRIBUTE_OR_VALUE_EXISTS) {
                    SelectivePrint2( PRT_ERROR,
                                    L"%d: ",
                                    cLine);
                    SelectivePrint( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                    MSG_CSVDE_ATTRVALEXIST);
                }
                else {
                    SelectivePrint2( PRT_ERROR,
                                    L"%d: ",
                                    cLine);
                    SelectivePrint( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                    MSG_CSVDE_CONSTRAINTVIOLATE);
                }
                TrackStatus();
            }
            else {
                //
                // Unignorable errors -> program termination
                //
                SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                                MSG_CSVDE_ADDERROR,
                                cLine, 
                                ldap_err2string(ldap_err));
                hr = ldap_err;
                OutputExtendedError(pLdap);
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }
        else {
            //
            // SUCCESS
            //
            TrackStatus();
            SelectivePrint( PRT_STD_VERBOSEONLY|PRT_LOG,
                            MSG_CSVDE_ENTRYMODIFIED);
            cAdded++;
        }

        //
        // Extra logic adding to take care of members separately
        //
        if (CSVEntry.ppModAfter[0]) {
            ldap_err = ldap_modify_s(pLdap, 
                                  CSVEntry.szDN, 
                                  CSVEntry.ppModAfter);
            if (ldap_err != LDAP_SUCCESS) {
                SelectivePrint2( PRT_ERROR,
                                L"%d: ",
                                cLine);
                SelectivePrint( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                MSG_CSVDE_MEMATTR_CANTMODIFIED);
                TrackStatus();
            }
            else {
                //
                // SUCCESS
                //
                SelectivePrint( PRT_STD_VERBOSEONLY|PRT_LOG,
                                MSG_CSVDE_ENTRYMODIFIED);
            }
        }

        FreeEntryInfo(&CSVEntry);
        cLine++;
    }
    if (hr == DIREXG_NOMORE_ENTRY) {
        hr = DIREXG_SUCCESS;
    }
    else {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_PARSE_ERROR,
                        g_cLine);
    }
error:    
    if ((cAdded > 1) || (cAdded == 0)) {
        SelectivePrint( PRT_STD|PRT_LOG,
                        MSG_CSVDE_MODIFIY_SUCCESS,
                        cAdded);
    }
    else if (cAdded == 1) {
        SelectivePrint( PRT_STD|PRT_LOG,
                        MSG_CSVDE_MODIFY_SUCCESS_1);
    }
    if (g_pLexer) {
        delete g_pLexer;
        g_pLexer = NULL;
    }
    if (rgAttribute) {
        for (i=0;i<(long)cAttribute;i++) {
            MemFree(rgAttribute[i]);
        }
        MemFree(rgAttribute);
    }
    if (pFileIn) {
        fclose(pFileIn);
    }
    FreeEntryInfo(&CSVEntry);
    FreeEntry(&CSVEntry);
    return hr;
}


//+---------------------------------------------------------------------------
// Function:    GetAttributeType
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR
GetAttributeType(PWSTR **prgAttribute, DWORD *pcAttribute)
{
    PWSTR  szToken = NULL;
    DWORD   cAttribute = 0;
    DWORD   dwToken;
    DIREXG_ERR hr = DIREXG_ERROR;
    DWORD   i;
    CStringPlex StringPlex;
    BOOLEAN bFound = FALSE;

    hr = StringPlex.Init();
    DIREXG_BAIL_ON_FAILURE(hr);

    //
    // Getting Attributes
    //
    hr = g_pLexer->GetNextToken(&szToken, &dwToken);
    DIREXG_BAIL_ON_FAILURE(hr);
    if (dwToken != TOKEN_IDENTIFIER) {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_ERROR_READATTRLIST);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    hr = StringPlex.AddElement(szToken);
    DIREXG_BAIL_ON_FAILURE(hr);
    if (szToken) {
        MemFree(szToken);
        szToken = NULL;
    }

    hr = g_pLexer->GetNextToken(&szToken, &dwToken);
    DIREXG_BAIL_ON_FAILURE(hr);

    while (dwToken == TOKEN_COMMA) {
        if (szToken) {
            MemFree(szToken);
            szToken = NULL;
        }

        hr = g_pLexer->GetNextToken(&szToken, &dwToken);
        DIREXG_BAIL_ON_FAILURE(hr);
        
        if (dwToken != TOKEN_IDENTIFIER) {
            SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                            MSG_CSVDE_ERROR_READATTRLIST);
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        
        hr  = StringPlex.AddElement(szToken);
        DIREXG_BAIL_ON_FAILURE(hr);
        if (szToken) {
            MemFree(szToken);
            szToken = NULL;
        }

        hr = g_pLexer->GetNextToken(&szToken, &dwToken);
        DIREXG_BAIL_ON_FAILURE(hr);

        cAttribute++;
    }

    if (dwToken != TOKEN_END) {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_ERROR_READATTRLIST);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    hr = StringPlex.GetCopy(prgAttribute);
    DIREXG_BAIL_ON_FAILURE(hr);
    *pcAttribute = StringPlex.NumElements();

    bFound = FALSE;
    i = 0;
    while (i < (*pcAttribute)) {
        if (g_iDN == -1) {
            if (_wcsicmp((*prgAttribute)[i], L"DN") == 0) {
                g_iDN = i;
            }
        }
        if (!bFound) {
            if (_wcsicmp((*prgAttribute)[i], L"objectClass") == 0) {
                bFound = TRUE;
            }
        }
        i++;
    }
    
    if (g_iDN == -1) {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_DN_NOTDEF);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    if (!bFound) {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_OBJCLASS_NOTDEF);
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

error:
    if (szToken) {
        MemFree(szToken);
        szToken = NULL;
    }
    return hr;
}


//+---------------------------------------------------------------------------
// Function:    StringToBVal
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR StringToBVal(PWSTR szInput,
                     struct berval *pBVal)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    DWORD cchInput;
    WCHAR chFirst, chSecond;
    BYTE bFirst = 0, bSecond = 0;
    BYTE bByte;
    BYTE *pByte = NULL;
    BYTE *pByteReturn = NULL;

    cchInput = wcslen(szInput);
    if ((cchInput % 2) != 0) {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_INVALIDHEX);
         hr = DIREXG_OUTOFMEMORY;
         DIREXG_BAIL_ON_FAILURE(hr);
    }
    cchInput = cchInput / 2;

    pByte = (BYTE*)MemAlloc(sizeof(WCHAR) * cchInput);  
    if (!pByte) {
         hr = DIREXG_OUTOFMEMORY;
         DIREXG_BAIL_ON_FAILURE(hr);
    }
    pByteReturn = pByte;

    _wcslwr(szInput);
    while (*szInput) {
        chFirst = *szInput++;
        chSecond = *szInput++;
        
        if (chFirst >= 'a' && chFirst <= 'f') {
            bFirst = chFirst - 'a' + 10;
        }
        else if (chFirst >= '0' && chFirst <= '9') {
            bFirst = chFirst - '0';
        }
        else {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        if (chSecond >= 'a' && chSecond <= 'f') {
            bSecond = chSecond - 'a' + 10;
        }
        else if (chSecond >= '0' && chSecond <= '9') {
            bSecond = chSecond - '0';
        }
        else {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        bByte = (BYTE)(bFirst * 16 + bSecond);
        *(pByte++) = bByte;
    }
    pBVal->bv_val = (char*)pByteReturn; 
    pBVal->bv_len = cchInput;
    return hr;
error:
    if (pByteReturn) {
        MemFree(pByteReturn);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\csvds\lexer.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    lexer.cxx

Abstract:
    
    Lexer for CSV

Author:

    Felix Wong [FelixW]    22-Jul-1997
    
++*/

#include "csvde.hxx"
#pragma hdrstop

extern DWORD g_cColumn;
extern BOOLEAN g_fBackwardCompatible;

CToken::CToken()
{
    m_szToken = NULL;
    m_dwMax = 0;
    m_dwCur = 0;
}   

DIREXG_ERR CToken::Init()
{
    m_szToken = (PWSTR)MemAlloc(sizeof(WCHAR) * MAX_TOKEN_LENGTH);
    if (!m_szToken) {
        return DIREXG_OUTOFMEMORY;
    }
    memset(m_szToken, 0, sizeof(WCHAR) * MAX_TOKEN_LENGTH);
    m_dwMax = MAX_TOKEN_LENGTH;
    m_dwCur = 0;
    return DIREXG_SUCCESS;
}

DIREXG_ERR CToken::Advance(WCHAR ch)
{
    if (m_dwCur >= m_dwMax) {
        PWSTR szTokenTemp = (PWSTR)MemAlloc(sizeof(WCHAR) * 
                                          (MAX_TOKEN_LENGTH+m_dwMax));
        if (!szTokenTemp) {
            return DIREXG_OUTOFMEMORY;
        }
        m_dwMax += MAX_TOKEN_LENGTH;
        memset(szTokenTemp, 0, sizeof(WCHAR) * m_dwMax);
        memcpy(szTokenTemp, m_szToken, m_dwCur);
        MemFree(m_szToken);
        m_szToken = szTokenTemp;
    }
    m_szToken[m_dwCur] = ch;
    m_dwCur++; 
    return DIREXG_SUCCESS;
}

DIREXG_ERR CToken::Backup()
{
    m_szToken[m_dwCur-1] = '\0';
    m_dwCur--; 
    return DIREXG_SUCCESS;
}

CToken::~CToken()
{
    if (m_szToken) {
        MemFree(m_szToken);
    }
}

//+---------------------------------------------------------------------------
// Function:    CLexer::CLexer
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:    -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CLexer::CLexer():
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _bAtDisabled(FALSE)
{
}

DIREXG_ERR CLexer::Init(FILE *pFile) 
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    PWSTR szBuffer = NULL;

    if (!pFile) {
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    m_pFile = pFile;
    hr = GetLine(m_pFile,
                 &szBuffer);
    DIREXG_BAIL_ON_FAILURE(hr);
    if (!szBuffer) {
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    if (_Buffer) {
        MemFree(_Buffer);
    }
    _Buffer = szBuffer;
    _ptr = _Buffer;
    m_fQuotingOn = FALSE;
error:
    return hr;
}

//+---------------------------------------------------------------------------
// Function:    CLexer::~CLexer
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:    -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CLexer::~CLexer()
{
    if (_Buffer) {
        MemFree(_Buffer);
    }
}

//+---------------------------------------------------------------------------
// Function:    CLexer::GetNextToken
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:    -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR
CLexer::GetNextToken(PWSTR *pszToken, LPDWORD pdwToken)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    WCHAR c;
    DWORD state = 0;
    BOOL fEscapeOn = FALSE;
    BOOL fHexOn = FALSE;
    CToken Token;
                    
    _dwEndofString = 0;

    hr = Token.Init();
    DIREXG_BAIL_ON_FAILURE(hr);

    _dwLastTokenLength = 0;
    while (1) {
        c = NextChar();

        switch (state) {
        
        case  0:
#ifdef SPANLINE_SUPPORT
            if (c == TEXT('&')) {
                NextLine();
                break;
            }
            else 
#endif
            if (c == TEXT(' ')) {
                break;
            }
            else if (c == TEXT('"')) {
                if (!m_fQuotingOn) {
                    m_fQuotingOn = TRUE;
                    state = 1;
                }
                else {
                    //
                    // L" is on, now we see another one. Since it is the 
                    // beginning of a token, it must be double L"", an 
                    // instring L". If it indicates the closing L", it would 
                    // have already been recognized by last token.
                    //
                    WCHAR cNext = NextChar();
                    if (cNext == TEXT('"')) {
                        hr = Token.Advance(c);
                        DIREXG_BAIL_ON_FAILURE(hr);
                        _dwLastTokenLength++;
                        state = 1;
                        break;
                    }
                    else {
                        hr = DIREXG_ERROR;
                        BAIL();
                    }
                }
            }
            else if (c == TEXT('\\')) {
                fEscapeOn = TRUE;
                state = 1;
            }
            else if (c == TEXT(';')) {
                hr = Token.Advance(c);
                DIREXG_BAIL_ON_FAILURE(hr);
                _dwLastTokenLength++;
                *pdwToken = TOKEN_SEMICOLON;
                _dwLastToken = *pdwToken;
                goto done;
            }
            else if (c == TEXT(',') && (!m_fQuotingOn)) {
                hr = Token.Advance(c);
                DIREXG_BAIL_ON_FAILURE(hr);
                _dwLastTokenLength++;
                *pdwToken = TOKEN_COMMA;
                _dwLastToken = *pdwToken;
                goto done;
            }
            else if (c == TEXT('X')) {
                WCHAR cNext = NextChar();
                if (cNext == TEXT('\'')) {
                    fHexOn = TRUE;
                }
                else {
                    hr = Token.Advance(c);
                    DIREXG_BAIL_ON_FAILURE(hr);
                    _dwLastTokenLength++;
                    PushbackChar();
                }
                state = 1;
                break;
            }else if (c == TEXT('\0') || c == TEXT('\n')){
                PWSTR szBuffer = NULL;
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                
                //
                // Try getting next line as well
                //
                hr = GetLine(m_pFile,
                             &szBuffer);
                DIREXG_BAIL_ON_FAILURE(hr);
                if (szBuffer) {
                    MemFree(_Buffer);
                    _Buffer = szBuffer;
                    _ptr = _Buffer;
                }
                hr = Token.Advance(c);
                DIREXG_BAIL_ON_FAILURE(hr);
                _dwLastTokenLength++;
                goto done;
            }
            else {
                state = 1;
                hr = Token.Advance(c);
                DIREXG_BAIL_ON_FAILURE(hr);
                _dwLastTokenLength++;
            }
            break;

        //
        // Deals with second character for identifiers/strings/hex
        //          
        case 1:
            if ((fEscapeOn || m_fQuotingOn) && 
                (c == TEXT('\n') || c == TEXT('\0'))) {
                hr = DIREXG_ERROR;
                BAIL();
            }
            if (fHexOn) {
                if ((c == TEXT('\n')) || (c == TEXT('\0')) || (c == TEXT(','))) {
                    // HEX is on, it must be closed by L"'"
                    hr = DIREXG_ERROR;
                    BAIL();
                }
                else if (c == TEXT('\'')) {
                    *pdwToken = TOKEN_HEX;
                    _dwLastToken = *pdwToken;
                    goto done;
                }
                else if ( ((c < TEXT('0')) || (c > TEXT('9'))) &&
                          ((c < TEXT('a')) || (c > TEXT('f'))) &&
                          ((c < TEXT('A')) || (c > TEXT('F'))) ) {
                    hr = DIREXG_ERROR;
                    BAIL();
                }
            }
            if (fEscapeOn) {
                // escape is on, get next WCHAR regardless of its value
                fEscapeOn = FALSE;
                hr = Token.Advance(c);
                DIREXG_BAIL_ON_FAILURE(hr);
                _dwLastTokenLength++;
                state = 1;
                break;
            }
            if (m_fQuotingOn) {
                //
                // If quoting is on, ignore these following characters
                //
            
                //
                // Only the secret backward compatible option is turned on,
                // we'll treat ';' inside quotes as a non-special character as
                // well. under the new format, quoting does not make special
                // characters non-special
                //
                if (c == TEXT(',') || (g_fBackwardCompatible && c == TEXT(';'))) {
                    hr = Token.Advance(c);
                    DIREXG_BAIL_ON_FAILURE(hr);
                    _dwLastTokenLength++;
                    break;
                }
                else if (c == TEXT('"')) {
                    // Single L" means the end of quote
                    // double L" means an actual L"
                    WCHAR cNext = NextChar();
                    if (cNext == TEXT('"')) {
                        hr = Token.Advance(c);
                        DIREXG_BAIL_ON_FAILURE(hr);
                        _dwLastTokenLength++;
                        break;
                    }
                    else {
                        PushbackChar();
                        m_fQuotingOn = FALSE;
                        *pdwToken = TOKEN_IDENTIFIER;
                        _dwLastToken = *pdwToken;
                        goto done;
                    }
                }
            }
#ifdef SPANLINE_SUPPORT
            if ((c == TEXT('&'))) {
                NextLine();
                break;
            }
            else 
#endif
            if (c == TEXT('\\')) {
                fEscapeOn = TRUE;
                break;
            }
            else if ((c == TEXT(';'))) {
                PushbackChar();
                if (!fHexOn) {
                    *pdwToken = TOKEN_IDENTIFIER;
                }
                else {
                    *pdwToken = TOKEN_HEX;
                }
                _dwLastToken = *pdwToken;
                goto done;
            }
            else if (c == TEXT('\n') || c == TEXT('\0') || c == TEXT(',')) {
                PushbackChar();
                *pdwToken = TOKEN_IDENTIFIER;
                _dwLastToken = *pdwToken;
                goto done;
            }
            else {
                hr = Token.Advance(c);
                DIREXG_BAIL_ON_FAILURE(hr);
                _dwLastTokenLength++;
                break;
            }
        
        default:
            hr = DIREXG_ERROR;
            BAIL();
        }
    }
done:
    *pszToken = MemAllocStrW(Token.m_szToken);
    if (!(*pszToken)) {
        return DIREXG_OUTOFMEMORY;
    }
    return DIREXG_SUCCESS;
error:
    if (hr == DIREXG_ERROR) {
        SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_CSVDE_SYNTAXATCOLUMN,g_cColumn);
    }
    return hr;
}


//+---------------------------------------------------------------------------
// Function:    CLexer::NextChar
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:    -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
WCHAR
CLexer::NextChar()
{
    PWSTR szBuffer;
    DIREXG_ERR hr = DIREXG_SUCCESS;
    
    if (_ptr == NULL || *_ptr == TEXT('\0')) {
        _dwEndofString = TRUE;
        return(TEXT('\0'));
    }

    //
    // We increment the column counter everytime right after we got a new
    // character
    //
    g_cColumn++;
    return(*_ptr++);
}


//+---------------------------------------------------------------------------
// Function:    CLexer::NextChar
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:    -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR
CLexer::NextLine()
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    PWSTR szBuffer = NULL;
    DWORD cchCurrent, cchNew, cchDistance;
    DWORD dwLength;
    PWSTR szNew = NULL;
    PWSTR szCheck = NULL;

    // 
    // Making sure that after the &, there is nothing, or else bail out
    //
    if (*_ptr != '\0') {
        szCheck = _ptr + 1;
        while (*szCheck != '\0') {
            if (*szCheck != ' ') {
                SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                                MSG_CSVDE_LINECON);
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            szCheck++;
        }
    }

    hr = GetLine(m_pFile,
                 &szBuffer);
    DIREXG_BAIL_ON_FAILURE(hr);
    if (!szBuffer) {
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    cchDistance = (DWORD)(_ptr - _Buffer);
    cchCurrent = wcslen(_Buffer);
    cchNew = wcslen(szBuffer);
    
    // +1 for null-termination, -1 for '&'
    szNew = (PWSTR)MemAlloc(sizeof(WCHAR) * (cchCurrent + cchNew + 1));
    if (!szNew) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    wcscpy(szNew, _Buffer);
    dwLength = wcslen(szNew);
    szNew[dwLength-1] = '\0';
    wcscat(szNew, szBuffer);
    _ptr = szNew + cchDistance -1;
    MemFree(_Buffer);
    _Buffer = szNew;
error:
    if (szBuffer) {
        MemFree(szBuffer);
    }
    return hr;
}


//+---------------------------------------------------------------------------
// Function:    CLexer::PushBackToken
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:    -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR
CLexer::PushBackToken()
{
    if (_dwLastToken == TOKEN_END) {
        return(DIREXG_SUCCESS);
    }
    _ptr -= _dwLastTokenLength;

    return(DIREXG_SUCCESS);
}


//+---------------------------------------------------------------------------
// Function:    CLexer::PushBackChar
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DIREXG_ERR
//
// Modifies:    -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }

    //
    // We decrement the column count whenver we push back a character
    //
    g_cColumn--;
    _ptr--;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\csvds\main.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    main.cxx

ABSTRACT:

    The CSV Bulk Import/Export Utility

DETAILS:
    
CREATED:

    08/10/97       Felix Wong (felixw)

REVISION HISTORY:

--*/

#include "csvde.hxx"
#pragma hdrstop
#include <locale.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <dsrole.h>

//
// Global variables (necessary for printouts)
//
FILE *g_pFileLog = NULL;            // Status log
FILE *g_pFileErrorLog = NULL;       // Error log              
BOOLEAN g_fVerbose = FALSE;         // SelectivePrint needs this info
BOOLEAN g_fDot = FALSE;             // Info for Status Tracker
BOOLEAN g_fError = FALSE;
PWSTR g_szDefaultFilter = L"(objectClass=*)";
PWSTR g_szErrorFilename = NULL;

BOOLEAN g_fUnicode = FALSE;         // whether we are using UNICODE or not
BOOLEAN g_fBackwardCompatible = FALSE;

DWORD GetDCName(BOOLEAN fWritable, PWSTR *pszDCName);
BOOL GetPassword(PWSTR szBuffer, DWORD dwLength, DWORD *pdwLengthReturn);
#define     CR              0xD
#define     BACKSPACE       0x8
#define     NULLC           '\0'
#define     NEWLINE         '\n'

int __cdecl
My_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   );

int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   );


//+---------------------------------------------------------------------------
// Function: InitArgument    
//
// Synopsis: Initialization of Argument variables to default settings
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void InitArgument(ds_arg *pArg)
{
    pArg->dwPort = 389;
    pArg->szGenFile = NULL;    
    pArg->szFilename = NULL;
    pArg->szDSAName = NULL;
    pArg->szRootDN = NULL;
    pArg->szFilter = NULL;
    pArg->szFromDN = NULL;
    pArg->szToDN = NULL;
    pArg->attrList = NULL;
    pArg->omitList = NULL;
    pArg->dwScope = -1;
    pArg->creds.User = NULL;
    pArg->creds.Domain = NULL;
    pArg->creds.Password = NULL;
    pArg->fActive = TRUE;
    pArg->fSimple = FALSE;
    pArg->fExport = TRUE; 
    pArg->fVerbose = FALSE; 
    pArg->fSAM = FALSE;
    pArg->fErrorExplain = TRUE;
    pArg->fPaged = TRUE;
    pArg->fSkipExist = FALSE;
    pArg->fBinary = TRUE;
    pArg->fSpanLine = FALSE;
    pArg->szLocation = NULL;
    pArg->fUnicode = FALSE;
}         


//+---------------------------------------------------------------------------
// Function: FreeArgument   
//
// Synopsis: Free argument variables   
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void FreeArgument(ds_arg *pArg)
{
    if (pArg->szFromDN) {
        MemFree(pArg->szFromDN);
    }
    if (pArg->szToDN) {
        MemFree(pArg->szToDN);
    }
    if (pArg->attrList) {
        MemFree(pArg->attrList);
    }
    if (pArg->omitList) {
        MemFree(pArg->omitList);
    }
}




//+---------------------------------------------------------------------------
// Function:  Main  
//
// Synopsis: Main Program Entry
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
extern "C" int __cdecl wmain(
    IN  int     argc,
    IN  PWSTR  argv[]
)
{
    
    DIREXG_ERR hr = DIREXG_SUCCESS;
    LDAP    *pLdap = NULL;
    unsigned long err;
    ds_arg Argument;
    int error;
    VOID *data;
    PWSTR szLogfileName = NULL;
    PWSTR szDSAName = NULL;
    PWSTR pszPassword = NULL;
    
    setlocale(LC_ALL, "");
    // Specification ".OCP" have a side effect to fgetws()
    // Because, we are using ANSI input files, this is causing our call to fgetws()
    // to a German file to get back some strings incorrectly.
    // setlocale(LC_ALL, ".OCP");

    InitMem();
    InitArgument(&Argument);
    
    hr = ProcessArgs(argc,
                     argv,
                     &Argument);
    DIREXG_BAIL_ON_FAILURE(hr);

    //
    // Setting up Logfile location
    //
    if (Argument.szLocation) {
        CString str;
        str.Init();
        str.Append(Argument.szLocation);
        str.Append(L"\\");
        str.Append(L"csv.log");
        hr = str.GetCopy(&szLogfileName); 
        DIREXG_BAIL_ON_FAILURE(hr);

        str.Init();
        str.Append(Argument.szLocation);
        str.Append(L"\\");
        str.Append(L"csv.err");
        hr = str.GetCopy(&g_szErrorFilename); 
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    else {
        szLogfileName = MemAllocStrW(L"csv.log");
        if (!szLogfileName) {
            hr = DIREXG_OUTOFMEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        g_szErrorFilename = MemAllocStrW(L"csv.err");
        if (!g_szErrorFilename) {
            hr = DIREXG_OUTOFMEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    if ((g_pFileLog = _wfopen(szLogfileName , 
                              L"wb")) == NULL) {
        SelectivePrint(PRT_STD,
                       MSG_CSVDE_UNABLEOPEN);
        hr = DIREXG_FILEERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    if(fputwc(UNICODE_MARK,
              g_pFileLog)==WEOF) {
        hr = DIREXG_FILEERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    //
    // Required by SelectivePrint
    //
    g_fVerbose = Argument.fVerbose;

    if (Argument.szDSAName == NULL) {
        DWORD dwError = GetDCName(!Argument.fExport, &szDSAName);
        if (dwError == 0) {
            Argument.szDSAName = szDSAName;
        }
        else {
            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_CSVDE_NODCAVAILABLE);
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    //
    // If the user inputs '*', we'll get the password without 
    // echoing the output
    //
    
    if (Argument.creds.Password && 
        (wcscmp(Argument.creds.Password,L"*") == 0)) {
        WCHAR szBuffer[PWLEN+1];
        DWORD dwLength;

        SelectivePrint(PRT_STD,
                       MSG_CSVDE_GETPASSWORD,
                       Argument.szDSAName);

        if (GetPassword(szBuffer,PWLEN+1,&dwLength)) {
            pszPassword = MemAllocStrW_E(szBuffer);   
            Argument.creds.Password = pszPassword;
            Argument.creds.PasswordLength = dwLength;
        }
        else {
            SelectivePrint(PRT_STD,
                           MSG_CSVDE_PASSWORDTOLONG,
                           Argument.szDSAName);
            hr = ERROR_INVALID_PARAMETER;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }
    
    //
    // CONNECTION section
    //
    SelectivePrint(PRT_STD|PRT_LOG,
                   MSG_CSVDE_CONNECT,
                   Argument.szDSAName);
    
    if ( (pLdap = ldap_open( Argument.szDSAName, 
                             Argument.dwPort )) == NULL )  {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_CONNECT_FAIL);
        hr = DIREXG_LDAP_CONNECT_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    data = (VOID*)LDAP_OPT_OFF;
    ldap_set_option( pLdap, LDAP_OPT_REFERRALS, &data );
    data = (VOID*)LDAP_VERSION3 ;
    ldap_set_option( pLdap, LDAP_OPT_VERSION, &data );

    if (Argument.creds.User) {
        if (Argument.fSimple) {  
            SelectivePrint(PRT_STD|PRT_LOG,
                           MSG_CSVDE_SIMPLEBIND,
                           Argument.creds.User);
            if ( (err=ldap_simple_bind_s( pLdap, 
                                          (PWSTR )Argument.creds.User, 
                                          (PWSTR )Argument.creds.Password)) 
                                                        != LDAP_SUCCESS ) {
                if (err != LDAP_INVALID_CREDENTIALS) {
                    //
                    // If it is not invalid crednetials, we'll fall to version
                    // 2 and try again
                    //
                    data = (VOID*)LDAP_VERSION2 ;
                    ldap_set_option( pLdap, LDAP_OPT_VERSION, &data );
                    if ( (err=ldap_simple_bind_s( pLdap, 
                                                  (PWSTR )Argument.creds.User, 
                                                  (PWSTR )Argument.creds.Password)) 
                                                                != LDAP_SUCCESS ) {
                        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                                       MSG_CSVDE_SIMPLEBINDRETURN, 
                                       ldap_err2string(err) );
                        hr = err;
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                }
                else {
                    SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                                   MSG_CSVDE_SIMPLEBINDRETURN, 
                                   ldap_err2string(err) );
                    hr = err;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
            }
        } 
        else { 
            SelectivePrint(PRT_STD|PRT_LOG,
                           MSG_CSVDE_SSPI,
                           Argument.creds.User,
                           Argument.creds.Domain);
            Argument.creds.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
            if ( (err=ldap_bind_s( pLdap, 
                                   NULL, 
                                   (PWSTR )&(Argument.creds), 
                                   LDAP_AUTH_SSPI)) != LDAP_SUCCESS ) {
                SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                               MSG_CSVDE_SSPIRETURN, 
                               ldap_err2string(err) );
                hr = err;
                DIREXG_BAIL_ON_FAILURE(hr);
            }   
        } 
        if (pszPassword) {
            MemFree(pszPassword);
            pszPassword = NULL;
        }
    }
    else {
        SelectivePrint(PRT_STD|PRT_LOG,
                       MSG_CSVDE_SSPILOCAL);
        if ( (err = ldap_bind_s( pLdap, 
                                 NULL, 
                                 NULL, 
                                 LDAP_AUTH_SSPI)) != LDAP_SUCCESS ) {
            SelectivePrint( PRT_STD|PRT_LOG|PRT_ERROR,
                            MSG_CSVDE_SSPILOCALRETURN, 
                            ldap_err2string(err) );
            hr = err;
            DIREXG_BAIL_ON_FAILURE(hr);
        }   
    }
    //
    //  ACTION section
    //
    if (Argument.fExport) {
        hr = DSExport(pLdap, 
                      &Argument);
    } else {    
        hr = DSImport(pLdap, 
                      &Argument);
    }    
    
    //
    // Printing results
    //
    if (hr == DIREXG_SUCCESS) {
        SelectivePrint2(PRT_STD|PRT_LOG,
                        L"\r\n");
        SelectivePrint(PRT_STD|PRT_LOG,
                       MSG_CSVDE_COMPLETE);
    }
    else if (hr == DIREXG_OUTOFMEMORY) {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_MEMERROR);
    }
    else {
        SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_CSVDE_ERROROCCUR);
    }

error:  
    if (pszPassword) {
        MemFree(pszPassword);
        pszPassword = NULL;
    }
    if (szDSAName) {
        MemFree(szDSAName);          
    }
    if (g_szErrorFilename) {
        MemFree(g_szErrorFilename);
    }
    if (szLogfileName) {
        MemFree(szLogfileName);
    }
    if (g_pFileLog) {
        fclose(g_pFileLog);
    }
    if (g_pFileErrorLog) {
        fclose(g_pFileErrorLog);
    }

    if (pLdap) {
        ldap_unbind(pLdap);
        pLdap = NULL;
    }
    FreeArgument(&Argument);
    DumpMemoryTracker();
    return(hr);
}


//+---------------------------------------------------------------------------
// Function:  ProcessArgs  
//
// Synopsis:  Process the Argument list passed into Main()  
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR 
ProcessArgs(
    int argc,
    PWSTR  argv[],
    ds_arg* pArg   
    )
{
    int i;
    DIREXG_ERR hr = DIREXG_SUCCESS;
    BOOLEAN bCredentials = FALSE;
    BOOLEAN rgbUsed[26];
    int cKey;

    memset(rgbUsed,0,sizeof(BOOLEAN) * 26);

    if (argc == 1) {
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }


    for (i=1; i < argc; i++) {

        if ((argv[i][0] != '-') && (argv[i][0] != '/')) {
            SelectivePrint(PRT_STD,
                           MSG_CSVDE_BADARGUMENT,
                           argv[i]);
            hr = DIREXG_BADPARAMETER;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        
        cKey = argv[i][1];
        if ((cKey >= 'a') && (cKey <= 'z')) {
            cKey = _toupper(argv[i][1]);
        }
        if ((cKey >= 'A') && (cKey <= 'Z')) {
            if (rgbUsed[cKey-'A']) {
                SelectivePrint( PRT_STD,MSG_CSVDE_ARGUMENTTWICE, argv[i]);
                hr = DIREXG_BADPARAMETER;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            else {
                rgbUsed[cKey-'A'] = TRUE;
            }
        }
        else {
            SelectivePrint( PRT_STD,MSG_CSVDE_UNKNOWN);
            hr = DIREXG_BADPARAMETER;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        switch (argv[i][1]) {

            case 'z':
            case 'Z':
                g_fBackwardCompatible = TRUE;
                break;

            case 'g':
            case 'G':
                pArg->fPaged = FALSE;
                break;

            case 'i':
            case 'I':
                pArg->fExport = FALSE;      
                break;

            case 'j':
            case 'J':
                if (++i >= argc) {
                    SelectivePrint( PRT_STD,MSG_CSVDE_INVALID_LOGFILE);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szLocation = argv[i];
                break;

            case 't':
            case 'T':
                if ((++i >= argc) || (!argv[i])) {
                    SelectivePrint( PRT_STD,MSG_CSVDE_INVALID_PARAM_PORT);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->dwPort = _wtoi(argv[i]);
                if (pArg->dwPort == 0) {
                    // If dwPort returns 0, we check whether it is really 0 or if it was
                    // a failure in _wtoi
                    if (wcscmp(argv[i],L"0") != 0) {
                        SelectivePrint( PRT_STD,MSG_CSVDE_INVALID_PARAM_PORT);
                        hr = DIREXG_BADPARAMETER;
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                }
                break;
        
            case 'f':
            case 'F':
                if (++i >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_FILENAME);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szGenFile = argv[i];
                pArg->szFilename = argv[i];
                break;
            
            case 's':
            case 'S':
                if (++i >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_SERVERNAME);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szDSAName = argv[i];
                break;

            case 'v':
            case 'V':
                pArg->fVerbose = TRUE;
                break;

            case 'u':
            case 'U':
                pArg->fUnicode = TRUE;
                break;

            case '?':
                PrintUsage();       
                break;

            //
            // Export Parameters
            //

            case 'd':
            case 'D':
                if (++i >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_ROOTDN);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szRootDN = argv[i];
                break;

            case 'r':
            case 'R':
                if (++i >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_FILTER);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szFilter = argv[i];
                break;

            case 'p':
            case 'P':
                if (++i >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_SCOPE);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
            
                if (!argv[i] || (*(argv[i]) == NULL)) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_SCOPE);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                
                if (!_wcsicmp(argv[i], L"Base" ))
                    pArg->dwScope = LDAP_SCOPE_BASE;
                else if (!_wcsicmp(argv[i], L"OneLevel" ))
                    pArg->dwScope = LDAP_SCOPE_ONELEVEL;
                else if (!_wcsicmp(argv[i], L"Subtree" ))
                    pArg->dwScope = LDAP_SCOPE_SUBTREE;
                else {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_BADSCOPE);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                break;

            case 'c':
            case 'C':
            {
                PWSTR pszTrimmedString, pszBuffer;
                
                if ((i+2) >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_FROMDN);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }

                // the "from" value
                i++;
                if (!argv[i] || (*(argv[i]) == NULL)) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_FROMDN);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }

                pszBuffer = MemAllocStrW(argv[i]);
                if (pszBuffer == NULL) {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pszTrimmedString = RemoveWhiteSpaces(pszBuffer);
                pArg->szFromDN = MemAllocStrW(pszTrimmedString);
                if (pArg->szFromDN == NULL) {
                    MemFree(pszBuffer);            
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                MemFree(pszBuffer);


                // the "to" value
                i++;
                if (!argv[i]) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_FROMDN);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                
                pszBuffer = MemAllocStrW(argv[i]);
                if (pszBuffer == NULL) {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pszTrimmedString = RemoveWhiteSpaces(pszBuffer);
                pArg->szToDN = MemAllocStrW(pszTrimmedString);
                if (pArg->szToDN == NULL) {
                    MemFree(pszBuffer);            
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                MemFree(pszBuffer);                
                break;
            }
            

            case 'l':
            case 'L':
            {
                PWSTR *rgszArgument = NULL;

                if (++i >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_ATTR);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                if (!argv[i] || (*(argv[i]) == NULL)) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_ATTR);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                hr = GetAllEntries(argv[i],
                                   &rgszArgument);
                DIREXG_BAIL_ON_FAILURE(hr);

                pArg->attrList = rgszArgument;
                break;
            }

            case 'o':
            case 'O':
            {
                PWSTR *rgszArgument = NULL;

                if (++i >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_ATTR2);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                if (!argv[i] || (*(argv[i]) == NULL)) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_ATTR2);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                hr = GetAllEntries(argv[i],
                                   &rgszArgument);
                DIREXG_BAIL_ON_FAILURE(hr);

                pArg->omitList = rgszArgument;
                break;
            }

            case 'm':
            case 'M':
                pArg->fSAM = TRUE;
                break;

            case 'n':
            case 'N':
                pArg->fBinary = FALSE;
                break;

#ifdef SPANLINE_SUPPORT
            case 'e':
            case 'E':
                pArg->fSpanLine = TRUE;
                break;
#endif

            //
            // Import Parameters
            //
            
            case 'k':
            case 'K':
                pArg->fSkipExist = TRUE;
                break;

            //
            // Credentials Establishment
            //
                
            case 'a':
            case 'A':
                if (bCredentials) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_DUPCRED);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }

                if ((i+2) >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_REQUSRDOMPWD);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                
                bCredentials = TRUE;
                pArg->fSimple = TRUE; 
                
                i++;
                pArg->creds.User = (PWSTR )argv[i];
                if (!pArg->creds.User) {
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.UserLength = wcslen(argv[i]);

                i++;
                pArg->creds.Password = (PWSTR )argv[i];
                if (!pArg->creds.Password) {
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.PasswordLength = wcslen(argv[i]);
                break;
            
            case 'b':
            case 'B':
                if (bCredentials) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_DUPCRED);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }

                if ((i+3) >= argc) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_BADARG_REQUSRDOMPWD);
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                
                bCredentials = TRUE;

                i++;
                pArg->creds.User = (PWSTR )argv[i];
                if (!pArg->creds.User) {
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.UserLength = wcslen(argv[i]);

                i++;
                pArg->creds.Domain = (PWSTR )argv[i];
                if (!pArg->creds.Domain) {
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.DomainLength = wcslen(argv[i]);
                
                i++;
                pArg->creds.Password = (PWSTR )argv[i];
                if (!pArg->creds.Password) {
                    hr = DIREXG_BADPARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.PasswordLength = wcslen(argv[i]);
                break;
                
            //
            // Temporary Setting
            //
            /*
            case 'c':
            case 'C':
                pArg->fActive = FALSE;       
                break;
            */
            default:
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_UNKNOWN);
                hr = DIREXG_BADPARAMETER;
                DIREXG_BAIL_ON_FAILURE(hr);
        } 
    } 
        
    // 
    // Checking Mandatory Options
    //
    if (hr == DIREXG_SUCCESS) {
        if (!pArg->szFilename) {
            SelectivePrint(PRT_STD,
                           MSG_CSVDE_BADARG_REQFILE);
            hr = DIREXG_BADPARAMETER;
        }
        
        if (!pArg->fExport) {
            // Require for Import

            // Not Require
            if (pArg->szRootDN) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQROOTDN);
                hr = DIREXG_BADPARAMETER;
            }
            if (pArg->szFilter) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQFILTER);
                hr = DIREXG_BADPARAMETER;
            }
            if (pArg->dwScope != -1) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQSCOPE);
                hr = DIREXG_BADPARAMETER;
            }
            if (pArg->fSAM) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQSAM);
                hr = DIREXG_BADPARAMETER;
            }
            if (pArg->omitList) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQOMIT);
                hr = DIREXG_BADPARAMETER;
            }
            if (pArg->attrList) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQATTR);
                hr = DIREXG_BADPARAMETER;
            }
            if (!pArg->fBinary) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQBINARY);
                hr = DIREXG_BADPARAMETER;
            }
            if (pArg->fSpanLine) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQSPAN);
                hr = DIREXG_BADPARAMETER;
            }
            if (pArg->fPaged == FALSE) { 
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQPAGE);
                hr = DIREXG_BADPARAMETER;
            }
        }
        else {
            // Require for Export
            if (!pArg->szFilter) {
                pArg->szFilter = g_szDefaultFilter;
            }
            if (pArg->dwScope == -1) {
                pArg->dwScope = LDAP_SCOPE_SUBTREE;
            }

            // Not Require
            if (pArg->fSkipExist) {
                SelectivePrint(PRT_STD,
                               MSG_CSVDE_BADARG_NREQ_SKIP);
                hr = DIREXG_BADPARAMETER;
            }

        }
    }
error:  
    if (hr != DIREXG_SUCCESS) {
        PrintUsage();
    }
    return (hr);
}


//***************************
//  UTILITIES SECTION
//***************************

//+---------------------------------------------------------------------------
// Function:  RemoveWhiteSpaces  
//
// Synopsis:  Removes trailing and starting white spaces  
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
PWSTR
RemoveWhiteSpaces(
    PWSTR pszText)
{
    PWSTR pChar;

    if(!pszText)
        return (pszText);

    while(*pszText && isspace(*pszText))
        pszText++;

    for(pChar = pszText + wcslen(pszText) - 1; pChar >= pszText; pChar--) {
        if(!isspace(*pChar))
            break;
        else
            *pChar = '\0';
    }
    return pszText;
}

//+---------------------------------------------------------------------------
// Function:  PrintUsage  
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void PrintUsage() {
    SelectivePrint(PRT_STD,
                   MSG_CSVDE_HELP);
}



//+---------------------------------------------------------------------------
// Function:   SelectivePrint 
//
// Synopsis:   Depending on parameter, print string to different media
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void SelectivePrint(
    DWORD dwTarget, DWORD messageID, ...)
{
    static BOOLEAN bTriedOpen = FALSE;
    WCHAR    messagebuffer[4096];
    va_list ap;
    DWORD dwSize;
    messagebuffer[0] = '\0';

    va_start(ap, messageID);

    if (FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, 
                      NULL, 
                      messageID, 
                      0, 
                      messagebuffer, 
                      4095, 
                      &ap) == 0) {
        DWORD WinError = GetLastError();
        ERR(("Format message failed with %d\n",WinError));
        BAIL();
    }
    dwSize = wcslen(messagebuffer);
    /*
    if (messagebuffer[dwSize-2] == '\r') {
            messagebuffer[dwSize-2] = '\n';
            messagebuffer[dwSize-1] = '\0';
    }
    */

    if (dwTarget & PRT_STD) {
        if (g_fDot) {
            wprintf(L"\n");
            g_fDot = FALSE;
        }
        My_fwprintf(stdout,messagebuffer);
    }
    else if ((dwTarget & PRT_STD_VERBOSEONLY) && g_fVerbose) {
        My_fwprintf(stdout,messagebuffer);
    }
    else if ((dwTarget & PRT_STD_NONVERBOSE) && !g_fVerbose) {
        if (g_fDot) {
            wprintf(L"\n");
            g_fDot = FALSE;
        }
        My_fwprintf(stdout,messagebuffer);
    }

    if (dwTarget & PRT_LOG) {
        fwprintf(g_pFileLog,messagebuffer);
    }
    if (dwTarget & PRT_ERROR) {
        if (!g_fError) {
            g_fError = TRUE;
        }
        if (!g_pFileErrorLog) {   // If log file is not opened
            if (!bTriedOpen) {          // If we haven't tried
                if ((g_pFileErrorLog = _wfopen(g_szErrorFilename, 
                                               L"wb")) == NULL) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_UNABLEOPENERR);
                    bTriedOpen = TRUE;
                    goto error;
                }
                if(fputwc(UNICODE_MARK,
                          g_pFileErrorLog)==WEOF) {
                    goto error;
                }
            }
        }
        fwprintf(g_pFileErrorLog,messagebuffer);
    }
error:
    va_end(ap);
    return;
}


//+---------------------------------------------------------------------------
// Function:   SelectivePrint2
//
// Synopsis:   Depending on parameter, print string to different media
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void SelectivePrint2(
    DWORD dwTarget, PWSTR pszfmt, ...)
{
    static BOOLEAN bTriedOpen = FALSE;
    va_list args;
    va_start(args, pszfmt);

    if (dwTarget & PRT_STD) {
        if (g_fDot) {
            wprintf(L"\n");
            g_fDot = FALSE;
        }
        My_vfwprintf(stdout,pszfmt,args);
    }
    else if ((dwTarget & PRT_STD_VERBOSEONLY) && g_fVerbose) {
        My_vfwprintf(stdout,pszfmt,args);
    }
    else if ((dwTarget & PRT_STD_NONVERBOSE) && !g_fVerbose) {
        if (g_fDot) {
            wprintf(L"\n");
            g_fDot = FALSE;
        }
        My_vfwprintf(stdout,pszfmt,args);
    }

    if (dwTarget & PRT_LOG) {
        vfwprintf(g_pFileLog,pszfmt,args);
    }
    if (dwTarget & PRT_ERROR) {
        if (!g_fError) {
            g_fError = TRUE;
        }
        if (!g_pFileErrorLog) {   // If log file is not opened
            if (!bTriedOpen) {          // If we haven't tried
                if ((g_pFileErrorLog = _wfopen(g_szErrorFilename, 
                                               L"wb")) == NULL) {
                    SelectivePrint(PRT_STD,
                                   MSG_CSVDE_UNABLEOPENERR);
                    bTriedOpen = TRUE;
                    goto error;
                }
                if(fputwc(UNICODE_MARK,
                          g_pFileErrorLog)==WEOF) {
                    goto error;
                }
            }
        }
        vfwprintf(g_pFileErrorLog,pszfmt,args);
    }
    va_end(args);
error:
    return;
}

#define UNIT    2           // This is the number of entries each dot represents
#define DOTS    20          // This is the number of dots before we roll back

//+---------------------------------------------------------------------------
// Function:   TrackStatus
//
// Synopsis:   Print a dot to indicate status, turn on g_fDot to indicate
//             that a dot has been printed. Any subsequent outputs require
//             a carriage return. (handled by SelectivePrint)
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void TrackStatus()
{
/*
    //  
    // This static count keeps track of where we are
    //
    static DWORD dwCount = 0;

    if (!g_fVerbose) {
        if (dwCount == (DOTS*UNIT)) {
            DWORD i;
            for (i=0;i<DOTS;i++) {
                printf("%c",BACKSPACE);
            }
            for (i=0;i<DOTS;i++) {
                printf("%c",' ');
            }
            for (i=0;i<DOTS;i++) {
                printf("%c",BACKSPACE);
            }
            dwCount = 0;
        }
        //
        // Only if we reached UNIT we'll print out a dot now
        //
        if (dwCount % UNIT == 0)
            wprintf(L".");
        dwCount++;
        g_fDot = TRUE;
    }
*/

    if (!g_fVerbose) {
        wprintf(L".");
        g_fDot = TRUE;
    }
}

//+---------------------------------------------------------------------------
// Function:   GetNextEntry 
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR GetNextEntry(PWSTR szInput, 
                     PWSTR *pszEntry,
                     PWSTR *pszNext)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    PWSTR szFinal = szInput;
    
    while ((*szFinal != ',') && (*szFinal != '\0')) {
        if (*szFinal == '\\') {
            szFinal++;
            if (*szFinal == '\0') {
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }
        szFinal++;
    }

    if (*szFinal == ',') {
        *szFinal = '\0';
        *pszEntry = RemoveWhiteSpaces(szInput);
        *pszNext = szFinal+1;
        return (DIREXG_SUCCESS);
    }
    else {
        *pszEntry = RemoveWhiteSpaces(szInput);
        *pszNext = NULL;
        return (DIREXG_SUCCESS);
    }
error:
    return hr;
}



//+---------------------------------------------------------------------------
// Function:  GetAllEntries  
//
// Synopsis:  Get all the entries from a list of comma separated values
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR GetAllEntries(PWSTR szInput, 
                      PWSTR **ppszOutput)
{
    DWORD cNumberAttributes = 0;
    PWSTR *pszReturn = NULL;
    PWSTR szCurrent = NULL;
    PWSTR szEntry = NULL;
    PWSTR szNext = NULL;     
    DIREXG_ERR hr = DIREXG_SUCCESS;

    DWORD cNumberNeeded = 1;

    // Allocating array to store entries    
    szCurrent = szInput;
    while (*szCurrent != '\0') {
        if (*szCurrent == '\\') {
            if (*(szCurrent+1) == '\0') {
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            szCurrent+=2;
            continue;
        }
        if (*szCurrent == ',') {
            cNumberNeeded++;
        }
        szCurrent++;
    }
    pszReturn = (PWSTR*)MemAlloc((cNumberNeeded+1)*sizeof(PWSTR));
    if (!pszReturn) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    szCurrent = szInput;
    hr = GetNextEntry(szCurrent,
                      &szEntry,
                      &szNext);
    DIREXG_BAIL_ON_FAILURE(hr);

    pszReturn[cNumberAttributes] = szEntry;
    cNumberAttributes++;

    while (szNext) {
        szCurrent = szNext;
        hr = GetNextEntry(szCurrent,
                          &szEntry,
                          &szNext);
        DIREXG_BAIL_ON_FAILURE(hr);
        pszReturn[cNumberAttributes] = szEntry;
        cNumberAttributes++;
    }
    pszReturn[cNumberAttributes] = NULL;

    cNumberAttributes--;

    *ppszOutput = pszReturn;

error:
    return hr;
}
DWORD GetDCName(BOOLEAN fWritable, PWSTR *pszDSName)
{
    DWORD dwError = 0;
    PDOMAIN_CONTROLLER_INFOW pDomainControllerInfo = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDSRole = NULL;

    *pszDSName = NULL;

    //
    // Get the role of the machine
    //
    dwError = DsRoleGetPrimaryDomainInformation(NULL,
                                                DsRolePrimaryDomainInfoBasic,
                                                (PBYTE*) &pDSRole);
    if (dwError != NO_ERROR) {
        goto error;
    }

    //
    // Set the property
    //
    if ((pDSRole->MachineRole == DsRole_RoleBackupDomainController) ||
        (pDSRole->MachineRole == DsRole_RolePrimaryDomainController)) {
        //
        // The current machine is the DC, we are done
        //
        goto error;
    }

    //
    // If the current machine is not the DC, get the DC of the domain
    //
    if (fWritable) {
        //
        // Looking for a writable server
        //
        dwError = DsGetDcNameW(NULL, //ComputerName 
                               NULL, //DomainName 
                               NULL, //DomainGuid 
                               NULL, //SiteName 
                               DS_DIRECTORY_SERVICE_REQUIRED|DS_WRITABLE_REQUIRED,
                               &pDomainControllerInfo);
    }
    else {
        //
        // Looking for a GC first, if it fails, goto any DC
        //
        dwError = DsGetDcNameW(NULL, //ComputerName 
                               NULL, //DomainName 
                               NULL, //DomainGuid 
                               NULL, //SiteName 
                               DS_DIRECTORY_SERVICE_REQUIRED|DS_GC_SERVER_REQUIRED,
                               &pDomainControllerInfo);
        if (dwError != 0) {
            dwError = DsGetDcNameW(NULL, //ComputerName 
                                   NULL, //DomainName 
                                   NULL, //DomainGuid 
                                   NULL, //SiteName 
                                   DS_DIRECTORY_SERVICE_REQUIRED,
                                   &pDomainControllerInfo);
        }
    }

    if (dwError == 0) {
        if ((pDomainControllerInfo) && 
            (pDomainControllerInfo->DomainControllerName)) {
            *pszDSName = MemAllocStrW(pDomainControllerInfo->DomainControllerName+2);
        }
        else {
            ASSERT(("DsGetDC returns 0 but has no info!\n"));
        }
    }

error:
    if (pDSRole) {
        DsRoleFreeMemory(pDSRole);
    }
    if (pDomainControllerInfo) {
        NetApiBufferFree(pDomainControllerInfo);
    }
    return dwError;
}

BOOL
GetPassword(
    PWSTR  szBuffer,
    DWORD  dwLength,
    DWORD  *pdwLengthReturn
    )
{
    WCHAR   ch;
    PWSTR   pszBufCur = szBuffer;
    DWORD   c;
    int     err;
    DWORD   mode;

    //
    // make space for NULL terminator
    //
    dwLength -= 1;                  
    *pdwLengthReturn = 0;               

    if (!GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), 
                        &mode)) {
        return FALSE;
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                   (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), 
                          &ch, 
                          1, 
                          &c, 
                          0);
        if (!err || c != 1)
            ch = 0xffff;
    
        if ((ch == CR) || (ch == 0xffff))    // end of line
            break;

        if (ch == BACKSPACE) {  // back up one or two 
            //
            // IF pszBufCur == buf then the next two lines are a no op.
            // Because the user has basically backspaced back to the start
            //
            if (pszBufCur != szBuffer) {
                pszBufCur--;
                (*pdwLengthReturn)--;
            }
        }
        else {

            *pszBufCur = ch;

            if (*pdwLengthReturn < dwLength) 
                pszBufCur++ ;                   // don't overflow buf 
            (*pdwLengthReturn)++;            // always increment pdwLengthReturn 
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);

    //
    // NULL terminate the string
    //
    *pszBufCur = NULLC;         
    putchar(NEWLINE);

    return((*pdwLengthReturn <= dwLength) ? TRUE : FALSE);
}


 /***
 * My_fwprintf(stream, format) - print formatted data
 *
 * Prints Unicode formatted string to console window using WriteConsoleW.
 * Note: This My_fwprintf() is used to workaround the problem in c-runtime
 * which looks up LC_CTYPE even for Unicode string.
 *
 */

int __cdecl
My_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   )

{
    DWORD  cchWChar;

    va_list args;
    va_start( args, format );

    cchWChar = My_vfwprintf(str, format, args);

    va_end(args);

    return cchWChar;
}


int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   )

{
    HANDLE hOut;

    if (str == stderr) {
        hOut = GetStdHandle(STD_ERROR_HANDLE);
    }
    else {
        hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    }

    if ((GetFileType(hOut) & ~FILE_TYPE_REMOTE) == FILE_TYPE_CHAR) {
        DWORD  cchWChar;
        WCHAR  szBufferMessage[4096];

        vswprintf( szBufferMessage, format, argptr );
        cchWChar = wcslen(szBufferMessage);
        WriteConsoleW(hOut, szBufferMessage, cchWChar, &cchWChar, NULL);
        return cchWChar;
    }

    return vfwprintf(str, format, argptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dbdump\dbdump.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbdump.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

#include <process.h>
#include <dsjet.h>
#include <ntdsa.h>
#include <scache.h>
#include <mdglobal.h>
#include <dbglobal.h>
#include <attids.h>
#include <..\..\ntdsa\dblayer\dbintrnl.h>
#include <dbopen.h>
#include <dsconfig.h>
#include <ctype.h>
#include <direct.h>
#include <ntdsa.h>
#include <dsutil.h>

#include <crypto\md5.h>


JET_INSTANCE    jetInstance = 0;
JET_SESID   sesid;
JET_DBID    dbid;
JET_TABLEID tblid;
char        *szIndex = SZDNTINDEX;
BOOL        fCloseJet = FALSE;
BOOL        fCountByContainer = FALSE;
BOOL            fbCountSDs = FALSE, fbCountClasses = FALSE;
DWORD           fSplit = 0;

char *szColNames[] = {
    SZDNT,
    SZPDNT,
    SZRDNATT,
    SZCNT,
    SZISVISIBLEINAB,
    SZNCDNT,
    SZOBJ,
    SZDELTIME,
    SZRDNTYP,
    SZGUID,
    SZINSTTYPE,
    SZSID,
    SZOBJCLASS
};

char *szSDColNames[] = {
    SZDNT,
    SZNTSECDESC,
    SZGUID,
    SZRDNATT
};

ULONG       ulDnt;
ULONG       ulPdnt;
long        lCount;
BYTE        bIsVisibleInAB;
ULONG       ulNcDnt;
BYTE        bObject;
DSTIME          DelTime;
ULONG       ulRdnType;
WCHAR       szRdn[MAX_RDN_SIZE];
GUID            Guid;
NT4SID          Sid;
ULONG           insttype;
char            *gszDBName = NULL;
DWORD           objClass;

char        sdBuffer [64 * 1024];

#define cFixedColumns 13
#define cSDFixedColumns 4

JET_RETRIEVECOLUMN jrc[cFixedColumns] =  {
    {0, &ulDnt, sizeof(ulDnt), 0, 0, 0, 1, 0, 0},
    {0, &ulPdnt, sizeof(ulPdnt), 0, 0, 0, 1, 0, 0},
    {0, szRdn, sizeof(szRdn), 0, 0, 0, 1, 0, 0},
    {0, &lCount, sizeof(lCount), 0, 0, 0, 1, 0, 0},
    {0, &bIsVisibleInAB, sizeof(bIsVisibleInAB), 0, 0, 0, 1, 0, 0},
    {0, &ulNcDnt, sizeof(ulNcDnt), 0, 0, 0, 1, 0, 0},
    {0, &bObject, sizeof(bObject), 0, 0, 0, 1, 0, 0},
    {0, &DelTime, sizeof(DelTime), 0, 0, 0, 1, 0, 0},
    {0, &ulRdnType, sizeof(ulRdnType), 0, 0, 0, 1, 0, 0},
    {0, &Guid, sizeof(Guid), 0, 0, 0, 1, 0, 0},
    {0, &insttype, sizeof(insttype), 0, 0, 0, 1, 0, 0},
    {0, &Sid, sizeof(Sid), 0, 0, 0, 1, 0, 0},
    {0, &objClass, sizeof (objClass), 0, 0, 0, 1, 0, 0}
};

JET_RETRIEVECOLUMN jSDCols[cSDFixedColumns] =  {
    {0, &ulDnt, sizeof(ulDnt), 0, 0, 0, 1, 0, 0},
    {0, &sdBuffer, sizeof(sdBuffer), 0, 0, 0, 1, 0, 0},
    {0, &Guid, sizeof(Guid), 0, 0, 0, 1, 0, 0},
    {0, szRdn, sizeof(szRdn), 0, 0, 0, 1, 0, 0}
};


void JetError(JET_ERR err, char *szJetCall);
void OpenJet(void);
int CloseJet(void);
ULONG WalkDB(void);
ULONG CountSDs(void);
void DisplayRecord(void);
void DumpHidden(void);

void ShowUsage(int i, int line) {
    fprintf(stderr,
        "Usage: dbdump [/d database_name] [ [/c datatable_JET_index_name] | [/s] | [/s1] | [/s2] | [/o]\\n");
    fprintf(stderr, "    Switches:"
        "\n\t d - select database to open"
        "\n\t s - count unique security descriptors (also split into inherited / explicit part)"
        "\n\t s1 - count unique security descriptors (without splitting)"
        "\n\t s2 - count unique security descriptors (after splitting)"
        "\n\t o - count by objectClass"
    "\n\t c - displays record count per container "
        "\n\t      (only valid\n\t     in conjuction with the PDNT_index)\n");
//    fprintf(stderr, "problem with argument %d on line %d\n");
}

//
// main
//

int __cdecl main(int argc, char *argv[])
{
    ULONG ulRecCount;
    int   i;

    for (i=1; i<argc; i++) {
    if ((*argv[i] == '-') || (*argv[i] == '/')) {
      switch(tolower(argv[i][1])) {
          case 'c':
        ++i;
        if (i == argc) {
            ShowUsage(i, __LINE__);
            exit(1);
        }
        fCountByContainer = TRUE;
        szIndex = argv[i];
        break;

          case 'd':
        ++i;
        if (i == argc) {
            ShowUsage(i, __LINE__);
            exit(1);
        }
        gszDBName = argv[i];
        break;

              case 's':
                fbCountSDs = TRUE;
                if (argv[i][2] == '1') {
                    fSplit = 1;
                    fprintf (stderr, "Dumping SD usage (non splitted)\n");
                }
                else if (argv[i][2] == '2') {
                    fSplit = 2;
                    fprintf (stderr, "Dumping SD usage (splitted)\n");
                }
                else {
                    fprintf (stderr, "Dumping SD usage (splitted & non splitted)\n");
                }

                ++i;
                break;

              case 'o':
                ++i;
                fprintf (stderr, "Dumping ObjectClass usage\n");
                fbCountClasses = TRUE;
                break;

          default:
        ShowUsage(i, __LINE__);
        exit(1);
          }
    }
    else {
        ShowUsage(i, __LINE__);
        exit(1);
    }
    }

    if (fCountByContainer && _stricmp(szIndex,"PDNT_index"))
    {
    fprintf(stderr, "Invalid combination: container counts and %s index\n",
        szIndex);
    exit(1);
    }

    OpenJet();

    if (!fbCountSDs) {
        ulRecCount = WalkDB();
    }
    else {
        ulRecCount = CountSDs();
    }
    fprintf(stdout, "\nTotal records: %u\n", ulRecCount);
    CloseJet();
    return 0;
}


void JetError(JET_ERR err, char *szJetCall)
{
    fprintf(stderr, "%s returned %d\n", szJetCall, err);

    if (fCloseJet)
    CloseJet();

    exit(1);
}

void OpenJet(void)
{
    JET_ERR err;
    DWORD dwType;
    DWORD indexCount;
    JET_COLUMNDEF coldef;
    int i;


    // set flag to close jet on error
    fCloseJet = TRUE;

    DBSetRequiredDatabaseSystemParameters (&jetInstance);

    err = DBInitializeJetDatabase(&jetInstance, &sesid, &dbid, gszDBName, FALSE);
    if (err != JET_errSuccess) {
        JetError(err, "DBInit");
    }

    DumpHidden();

    if (err = JetOpenTable(sesid, dbid, SZDATATABLE, NULL, 0, 0, &tblid))
    JetError(err, "JetOpenTable");

    if (err =  JetSetCurrentIndex(sesid, tblid, szIndex))
    JetError(err, "JetSetCurrentIndex");

    JetIndexRecordCount( sesid, tblid, &indexCount, 0xFFFFFFFF );
    fprintf(stdout,"JetIndexRecordCount returned %d\n\n",indexCount);

    for (i=0; i< cFixedColumns; i++)
    {
        if (err = JetGetTableColumnInfo(sesid, tblid, szColNames[i], &coldef,
                    sizeof(coldef), 0))
        {
            JetError(err, "JetGetTableColumnInfo");
        }

        jrc[i].columnid = coldef.columnid;
    }


    for (i=0; i< cSDFixedColumns; i++)
    {
        if (err = JetGetTableColumnInfo(sesid, tblid, szSDColNames[i], &coldef,
                    sizeof(coldef), 0))
        {
            JetError(err, "JetGetTableColumnInfo");
        }

        jSDCols[i].columnid = coldef.columnid;
    }
}


int CloseJet(void)
{
    JET_ERR err;

    if (sesid != 0) {
        if(dbid != 0) {
            // JET_bitDbForceClose not supported in Jet600.
            if ((err = JetCloseDatabase(sesid, dbid, 0)) != JET_errSuccess) {
                return err;
            }
            dbid = 0;
        }

        if ((err = JetEndSession(sesid, JET_bitForceSessionClosed)) != JET_errSuccess) {
            return err;
        }
        sesid = 0;

        JetTerm(jetInstance);
        jetInstance = 0;
    }
    return JET_errSuccess;
}


typedef struct _TREE_LEAF TREE_LEAF;

struct _TREE_LEAF {
    TREE_LEAF    *left;
    TREE_LEAF    *right;

    unsigned char key[16];
    DWORD         size;
    ULONG         count;
    GUID          Guid;
    CHAR          SDtype;
    WCHAR         szRdn[1];
};

TREE_LEAF *pTreeRoot = NULL, *pSplitSDTreeRoot = NULL;
ULONG ulUnique = 0;
ULONG ulTotalSize = 0;
ULONG ulTotalUniqueSize = 0;


void AddNode (
        TREE_LEAF **ppTreeRoot,
        unsigned char *key,
        DWORD keySize,
        DWORD size,
        GUID *pGuid,
        WCHAR *pRdn,
        DWORD cbRdn,
        CHAR  SDtype)
{
    TREE_LEAF *pNode = NULL;
    TREE_LEAF *pTmp, **ppLast = NULL;
    int cmp;
    unsigned i;

    if (keySize > 16) {
        keySize = 16;
    }

    if (*ppTreeRoot == NULL) {
        *ppTreeRoot = (TREE_LEAF *)malloc (sizeof (TREE_LEAF) + cbRdn + sizeof (WCHAR));
        if (!*ppTreeRoot) {
            fprintf (stderr, "Out of memory\n");
            return;
        }
        pNode = *ppTreeRoot;

        pNode->left = NULL;
        pNode->right = NULL;
        pNode->count = 0;
        pNode->size = size;
        pNode->SDtype = SDtype;
        memcpy (pNode->key, key, keySize);

        if (cbRdn) {
            memcpy (pNode->szRdn, pRdn, cbRdn);
            pNode->szRdn[cbRdn/2]=L'\0';

            for (i=0; i<cbRdn/2; i++) {
                if (pNode->szRdn[i] == L'\n') {
                    pNode->szRdn[i] = L' ';
                }
            }
        }
        else {
            pNode->szRdn[0] = L'\0';
        }
    }
    else {
        pTmp = *ppTreeRoot;

        while (pTmp) {
            cmp = memcmp (pTmp->key, key, keySize);

            if (cmp == 0) {
                pNode = pTmp;
                break;
            }
            else if (cmp < 0) {
                ppLast = &pTmp->left;
                pTmp = pTmp->left;
            }
            else {
                ppLast = &pTmp->right;
                pTmp = pTmp->right;
            }
        }

        if (!pNode) {
            pNode = (TREE_LEAF *)malloc (sizeof (TREE_LEAF) + cbRdn + sizeof (WCHAR));
            if (!pNode) {
                fprintf (stderr, "Out of memory\n");
                return;
            }
            pNode->left = NULL;
            pNode->right = NULL;
            pNode->count = 0;
            pNode->size = size;
            pNode->SDtype = SDtype;
            memcpy (pNode->key, key, keySize);
            memcpy (&pNode->Guid, pGuid,sizeof (GUID));

            if (cbRdn) {
                memcpy (pNode->szRdn, pRdn, cbRdn);
                pNode->szRdn[cbRdn/2]=L'\0';

                for (i=0; i<cbRdn/2; i++) {
                    if (pNode->szRdn[i] == L'\n') {
                        pNode->szRdn[i] = L' ';
                    }
                }
            }
            else {
                pNode->szRdn[0] = L'\0';
            }

            if (ppLast) {
                *ppLast = pNode;
            }
        }
    }

    pNode->count++;
}


ULONG InorderTraverseTree (TREE_LEAF *pNode)
{
    static CHAR szUuid[1 + 2*sizeof(GUID)];
    ULONG cnt = 0;
    int i;

    if (pNode->left) {
        cnt = InorderTraverseTree (pNode->left);
    }

    printf("%7d %5d %c %s %ws ",
           pNode->count,
           pNode->size,
           pNode->SDtype,
           DsUuidToStructuredString(&pNode->Guid, szUuid),
           pNode->szRdn
           );


    //for (i=0; i<16; i++) {
    //    printf("%2x", pNode->key[i]);
    //}
    printf("\n");


    cnt += pNode->count;
    ulUnique++;

    ulTotalUniqueSize += pNode->size;
    ulTotalSize += pNode->count * pNode->size;

    if (pNode->right) {
        cnt += InorderTraverseTree (pNode->right);
    }

    return cnt;
}

ULONG InorderTraverseTreeObjectClass (TREE_LEAF *pNode)
{
    static CHAR szUuid[1 + 2*sizeof(GUID)];
    ULONG cnt = 0;
    int i;

    if (pNode->left) {
        cnt = InorderTraverseTreeObjectClass (pNode->left);
    }

    printf("%7d %7x %d %d %s %ws ",
           pNode->count,
           ((DWORD *)pNode->key)[0],
           ((DWORD *)pNode->key)[1],
           ((DWORD *)pNode->key)[2],
           DsUuidToStructuredString(&pNode->Guid, szUuid),
           pNode->szRdn
           );


    //for (i=0; i<16; i++) {
    //    printf("%2x", pNode->key[i]);
    //}
    printf("\n");


    cnt += pNode->count;
    ulUnique++;

    ulTotalUniqueSize += pNode->size;
    ulTotalSize += pNode->count * pNode->size;

    if (pNode->right) {
        cnt += InorderTraverseTreeObjectClass (pNode->right);
    }

    return cnt;
}



#define INHERIT_FLAGS (INHERITED_ACE)
#define MAXDWORD    0xffffffff

BOOL
SplitACL (PACL pAcl,
          PACL *ppACLexplicit,
          PACL *ppACLinherit)
{
    DWORD         dwErr;
    WORD          i;
    ACE_HEADER   *pAce;
    DWORD         dwExplicit = 0,
                  dwInherit = 0;

    DWORD         dwExplicitSize = 0,
                  dwInheritSize = 0;

    for ( i = 0; i < pAcl->AceCount; i++ )
    {
        if ( !GetAce(pAcl, i, (LPVOID *) &pAce) )
        {
            return FALSE;
        }
        else
        {
            if (pAce->AceFlags & INHERIT_FLAGS) {
                dwInherit++;
                dwInheritSize += pAce->AceSize;
            }
            else {
                dwExplicit++;
                dwExplicitSize += pAce->AceSize;
            }
        }
    }

    *ppACLinherit = NULL;
    *ppACLexplicit = NULL;

    if (dwInherit) {
        //dwInheritSize += sizeof (ACE_HEADER);

        *ppACLinherit = (PACL) malloc (dwInheritSize);

        if (!*ppACLinherit) {
            fprintf (stderr, "Out of memory\n");
            return FALSE;
        }

        if (InitializeAcl(*ppACLinherit,
                          dwInheritSize,
                          pAcl->AclRevision) ) {

            for ( i = 0; i < pAcl->AceCount; i++ )
            {
                if ( !GetAce(pAcl, i, (LPVOID *) &pAce) )
                {
                    return FALSE;
                }
                else if (pAce->AceFlags & INHERIT_FLAGS) {
                    if (AddAce(*ppACLinherit,
                                pAcl->AclRevision,
                                MAXDWORD,
                                pAce,
                                1)) {

                        dwErr = GetLastError();
                        fprintf (stderr, "Error: AddAce1 ==> 0x%x\n", dwErr);
                        return FALSE;
                    }
                }
            }
        }
    }



    if (dwExplicit) {
        //dwExplicitSize += sizeof (ACL_HEADER);

        *ppACLexplicit = (PACL) malloc (dwExplicitSize);
        if (!*ppACLexplicit) {
            fprintf (stderr, "Out of memory\n");
            return FALSE;
        }

        if (InitializeAcl(*ppACLexplicit,
                          dwExplicitSize,
                          pAcl->AclRevision) ) {

            for ( i = 0; i < pAcl->AceCount; i++ )
            {
                if ( !GetAce(pAcl, i, (LPVOID *) &pAce) )
                {
                    return FALSE;
                }
                else if ( !(pAce->AceFlags & INHERIT_FLAGS) ) {
                    if (AddAce(*ppACLexplicit,
                                pAcl->AclRevision,
                                MAXDWORD,
                                pAce,
                                1)) {

                        dwErr = GetLastError();
                        fprintf (stderr, "Error: AddAce2 ==> 0x%x\n", dwErr);
                        return FALSE;
                    }
                }
            }
        }
    }

    return TRUE;
}



BOOL BreakSDApart (
            PSECURITY_DESCRIPTOR pSD,
            DWORD cSDlen,
            PSECURITY_DESCRIPTOR *ppSD_explicit,
            DWORD *pcSD_explicit,
            PSECURITY_DESCRIPTOR *ppSD_inherit,
            DWORD *pcSD_inherit)
{
    DWORD dwErr;

    DWORD dwAbsoluteSDSize,
          dwDaclSize,
          dwSaclSize,
          dwOwnerSize,
          dwPrimaryGroupSize;

    BOOL  bDPresent, bDDefaulted;
    BOOL  bSPresent, bSDefaulted;

    PSECURITY_DESCRIPTOR pSDabsolute = NULL;
    PACL pDacl, pSacl, pDacltmp, pSacltmp;
    PACL pDACLexplicit = NULL, pSACLexplicit = NULL;
    PACL pDACLinherit = NULL, pSACLinherit = NULL;

    PSID pOwner;
    PSID pPrimaryGroup;


    if (!cSDlen) {
        return FALSE;
    }

    if (*ppSD_explicit) {
        free (*ppSD_explicit);
        *ppSD_explicit = NULL;
        *pcSD_explicit = 0;
    }
    if (*ppSD_inherit) {
        free (*ppSD_inherit);
        *ppSD_inherit = NULL;
        *pcSD_inherit = 0;
    }

    pDacl = pSacl = pOwner = pPrimaryGroup = NULL;

    dwAbsoluteSDSize = dwDaclSize = dwSaclSize = dwOwnerSize =
          dwPrimaryGroupSize = 0;

    if (!MakeAbsoluteSD(pSD,
                       pSDabsolute,
                       &dwAbsoluteSDSize,
                       pDacl,
                       &dwDaclSize,
                       pSacl,
                       &dwSaclSize,
                       pOwner,
                       &dwOwnerSize,
                       pPrimaryGroup,
                       &dwPrimaryGroupSize) ) {
        dwErr = GetLastError();
        if (dwErr != ERROR_INSUFFICIENT_BUFFER) {
            fprintf (stderr, "Error: MakeAbsoluteSD1 ==> 0x%x\n", dwErr);
            return FALSE;
        }
    }

    pSDabsolute = (PSECURITY_DESCRIPTOR) malloc (dwAbsoluteSDSize);
    pDacl = (PACL)malloc (dwDaclSize);
    pSacl = (PACL)malloc (dwSaclSize);
    pOwner = (PSID)malloc (dwOwnerSize);
    pPrimaryGroup = (PSID)malloc (dwPrimaryGroupSize);

    if (!pSDabsolute || !pDacl || !pSacl || !pOwner || !pPrimaryGroup) {
        fprintf (stderr, "Out of memory\n");
        return FALSE;
    }


    if (!MakeAbsoluteSD(pSD,
                       pSDabsolute,
                       &dwAbsoluteSDSize,
                       pDacl,
                       &dwDaclSize,
                       pSacl,
                       &dwSaclSize,
                       pOwner,
                       &dwOwnerSize,
                       pPrimaryGroup,
                       &dwPrimaryGroupSize) ) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: MakeAbsoluteSD2 ==> 0x%x\n", dwErr);
        return FALSE;
    }


    if ( !GetSecurityDescriptorDacl(pSDabsolute,
                                    &bDPresent,
                                    &pDacltmp,
                                    &bDDefaulted) )
    {
        dwErr = GetLastError();
        fprintf (stderr, "Error: GetSecurityDescriptorDacl1 ==> 0x%x\n", dwErr);
        return FALSE;
    }

    if (bDPresent) {
        SplitACL (pDacltmp, &pDACLexplicit, &pDACLinherit);
    }


    if ( !GetSecurityDescriptorSacl(pSDabsolute,
                                    &bSPresent,
                                    &pSacltmp,
                                    &bSDefaulted) )
    {
        dwErr = GetLastError();
        fprintf (stderr, "Error: GetSecurityDescriptorSacl1 ==> 0x%x\n", dwErr);
        return FALSE;
    }

    if (bSPresent) {
        SplitACL (pSacltmp, &pSACLexplicit, &pSACLinherit);
    }


    // MAKE explicit SD
    //

    if (!SetSecurityDescriptorDacl(pSDabsolute,
                                   bDPresent,
                                   pDACLexplicit,
                                   bDDefaulted)) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: SetSecurityDescriptorDacl1 ==> 0x%x\n", dwErr);
        return FALSE;
    }

    if (!SetSecurityDescriptorSacl(pSDabsolute,
                                   bSPresent,
                                   pSACLexplicit,
                                   bSDefaulted)) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: SetSecurityDescriptorDacl1 ==> 0x%x\n", dwErr);
        return FALSE;
    }


    if (!SetSecurityDescriptorGroup(pSDabsolute,
                                    pPrimaryGroup,
                                    FALSE)) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: SetSecurityDescriptorGroup ==> 0x%x\n", dwErr);
        return FALSE;
    }

    if (!SetSecurityDescriptorOwner(pSDabsolute,
                                    pOwner,
                                    FALSE)) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: SetSecurityDescriptorOwner ==> 0x%x\n", dwErr);
        return FALSE;
    }


    if (!MakeSelfRelativeSD(pSDabsolute,
                           *ppSD_explicit,
                           pcSD_explicit)) {

        dwErr = GetLastError();
        if (dwErr != ERROR_INSUFFICIENT_BUFFER) {
            fprintf (stderr, "Error: MakeSelfRelativeSD1 ==> 0x%x\n", dwErr);
            return FALSE;
        }
    }

    *ppSD_explicit = (PSECURITY_DESCRIPTOR) malloc (*pcSD_explicit);

    if (!MakeSelfRelativeSD(pSDabsolute,
                           *ppSD_explicit,
                           pcSD_explicit)) {

        dwErr = GetLastError();
        fprintf (stderr, "Error: MakeSelfRelativeSD2 ==> 0x%x\n", dwErr);
        return FALSE;
    }


    // MAKE inherited SD
    //

    if (!SetSecurityDescriptorDacl(pSDabsolute,
                                   bDPresent,
                                   pDACLinherit,
                                   bDDefaulted)) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: SetSecurityDescriptorDacl1 ==> 0x%x\n", dwErr);
        return FALSE;
    }

    if (!SetSecurityDescriptorSacl(pSDabsolute,
                                   bSPresent,
                                   pSACLinherit,
                                   bSDefaulted)) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: SetSecurityDescriptorDacl1 ==> 0x%x\n", dwErr);
        return FALSE;
    }


    if (!SetSecurityDescriptorGroup(pSDabsolute,
                                    NULL,
                                    FALSE)) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: SetSecurityDescriptorGroup ==> 0x%x\n", dwErr);
        return FALSE;
    }

    if (!SetSecurityDescriptorOwner(pSDabsolute,
                                    NULL,
                                    FALSE)) {
        dwErr = GetLastError();
        fprintf (stderr, "Error: SetSecurityDescriptorOwner ==> 0x%x\n", dwErr);
        return FALSE;
    }


    if (!MakeSelfRelativeSD(pSDabsolute,
                           *ppSD_inherit,
                           pcSD_inherit)) {

        dwErr = GetLastError();
        if (dwErr != ERROR_INSUFFICIENT_BUFFER) {
            fprintf (stderr, "Error: MakeSelfRelativeSD3 ==> 0x%x\n", dwErr);
            return FALSE;
        }
    }

    *ppSD_inherit = (PSECURITY_DESCRIPTOR) malloc (*pcSD_inherit);

    if (!MakeSelfRelativeSD(pSDabsolute,
                           *ppSD_inherit,
                           pcSD_inherit)) {

        dwErr = GetLastError();
        fprintf (stderr, "Error: MakeSelfRelativeSD4 ==> 0x%x\n", dwErr);
        return FALSE;
    }



    free (pSDabsolute);
    free (pDacl);
    free (pSacl);
    free (pOwner);
    free (pPrimaryGroup);
    free (pDACLexplicit);
    free (pSACLexplicit);
    free (pDACLinherit);
    free (pSACLinherit);

    return TRUE;
}



ULONG CountSDs(void)
{
    JET_ERR err;
    ULONG ulRecCount = 0;
    ULONG ulTotalSDs;

    MD5_CTX Md5Context;

    PSECURITY_DESCRIPTOR pSDexplicit = NULL, pSDinherited = NULL;
    DWORD cSDexplicit_len = 0, cSDinherited_len = 0;



    printf("Counting Unique SDs\n");

    err = JetMove(sesid, tblid, JET_MoveFirst, 0);

    while (!err) {

        ulRecCount++;

        err = JetRetrieveColumns(sesid,
                                tblid,
                                jSDCols,
                                cSDFixedColumns);

        if (err && (err != JET_wrnColumnNull)) {
            DWORD i;

            for (i=0; i < cSDFixedColumns; i++) {
                printf("-- Column %d, error %d, actual size %u\n", i, jSDCols[i].err, jSDCols[i].cbActual);
            }
            JetError(err, "JetRetrieveColumns");
        }

        if (!fSplit || fSplit == 1) {

            MD5Init(&Md5Context);

            MD5Update(
                &Md5Context,
                jSDCols[1].pvData,
                jSDCols[1].cbActual
                );

            MD5Final(
                &Md5Context
                );

            AddNode (&pTreeRoot,
                 Md5Context.digest,
                 sizeof (Md5Context.digest),
                 jSDCols[1].cbActual,
                 jSDCols[2].pvData,
                 jSDCols[3].pvData,
                 jSDCols[3].cbActual,
                 'N');
        }

        if (!fSplit || fSplit == 2) {

            BreakSDApart (
                    jSDCols[1].pvData,
                    jSDCols[1].cbActual,
                    &pSDexplicit,
                    &cSDexplicit_len,
                    &pSDinherited,
                    &cSDinherited_len);

            if (cSDinherited_len) {
                MD5Init(&Md5Context);

                MD5Update(
                    &Md5Context,
                    pSDinherited,
                    cSDinherited_len
                    );

                MD5Final(
                    &Md5Context
                    );


                AddNode (&pSplitSDTreeRoot,
                         Md5Context.digest,
                         sizeof (Md5Context.digest),
                         cSDinherited_len,
                         jSDCols[2].pvData,
                         jSDCols[3].pvData,
                         jSDCols[3].cbActual,
                         'I');
            }

            if (cSDexplicit_len) {
                MD5Init(&Md5Context);

                MD5Update(
                    &Md5Context,
                    pSDexplicit,
                    cSDexplicit_len
                    );

                MD5Final(
                    &Md5Context
                    );


                AddNode (&pSplitSDTreeRoot,
                         Md5Context.digest,
                         sizeof (Md5Context.digest),
                         cSDexplicit_len,
                         jSDCols[2].pvData,
                         jSDCols[3].pvData,
                         jSDCols[3].cbActual,
                         'E');
            }
        }


        if (ulRecCount % 2000 == 0) {
            fprintf (stderr, "%9u             \r", ulRecCount);
        }

        err = JetMove(sesid, tblid, JET_MoveNext, 0);

    }

    if (err != JET_errNoCurrentRecord)
        JetError(err, "JetMove");


    printf(".\n\n");

    if (!fSplit || fSplit == 1) {
        if (pTreeRoot) {
            ulTotalSDs = InorderTraverseTree (pTreeRoot);
            printf("\n\n\n\n");
            printf("Unique SDs:  %7u / %8u\n", ulUnique, ulTotalSDs);
            printf("Unique Size: %7u / %8u\n", ulTotalUniqueSize, ulTotalSize);
            printf("\n\n\n\n");
        }
    }

    if (!fSplit || fSplit == 2) {
        if (pSplitSDTreeRoot) {
            ulUnique = ulTotalSDs = ulTotalUniqueSize = ulTotalSize = 0;
            ulTotalSDs = InorderTraverseTree (pSplitSDTreeRoot);
            printf("\n\n\n\n");
            printf("Unique SDs:  %7u / %8u\n", ulUnique, ulTotalSDs);
            printf("Unique Size: %7u / %8u\n", ulTotalUniqueSize, ulTotalSize);
        }
    }

    return ulRecCount;
}


/*        1         2         3         4         5         6         7
 123456789012345678901234567890123456789012345678901234567890123456789012345678
*/
char szLabel[] =
"   DNT   PDNT  NCDNT RefCnt V O IT Deletion Time     RdnTyp CC  RDN                  GUID                                 SID  ObjectClass\n\n";

ULONG WalkDB(void)
{
    JET_ERR err;
    ULONG ulRecCount = 0;
    ULONG ulContainerCount = 0;
    ULONG ulOldPdnt = 0xffffffff;

    DWORD Key[4];

    // display header
    fprintf(stdout,szLabel);

    err = JetMove(sesid, tblid, JET_MoveFirst, 0);

    while (!err)
    {
    ulRecCount++;

    err = JetRetrieveColumns(sesid,
        tblid,
        jrc,
        cFixedColumns);

    if (err &&
       (err != JET_wrnColumnNull))
    {
            DWORD i;

            for (i=0; i < cFixedColumns; i++) {
                printf("-- Column %d, error %d, actual size %u\n", i, jrc[i].err, jrc[i].cbActual);
            }

        JetError(err, "JetRetrieveColumns");
    }

    if (fCountByContainer)
    {
        if (jrc[1].err)
            ulPdnt = 0;

        if (ulPdnt != ulOldPdnt)
        {
        if (ulOldPdnt != 0xffffffff)
        {
            fprintf(stdout,"Records in container %u: %u\n\n",
            ulOldPdnt, ulContainerCount);
        }
        ulContainerCount = 0;
        ulOldPdnt = ulPdnt;
        }
        ulContainerCount++;
    }

        if (fbCountClasses) {
            Key[0]= jrc[12].cbActual ? objClass : 0;
            Key[1]= jrc[6].cbActual ? bObject : 0;
            Key[2]= jrc[7].cbActual ? 1 : 0;  // deleted time
            Key[3]=0;

            AddNode (&pTreeRoot,
                     (unsigned char *)Key,
                     sizeof (Key),
                     sizeof (objClass),
                     jrc[9].pvData,
                     jrc[2].pvData,
                     jrc[2].cbActual,
                     'N');

            if (ulRecCount % 100 == 0) {
                fprintf (stderr, "%9d             \r", ulRecCount);
            }
        }

    if (!fbCountClasses) {
            DisplayRecord();
        }

    err = JetMove(sesid, tblid, JET_MoveNext, 0);
    }

    if (err != JET_errNoCurrentRecord)
    JetError(err, "JetMove");


    if (fCountByContainer)
    {
    fprintf(stdout,"Records in container %u: %u\n\n",
        ulOldPdnt, ulContainerCount);
    }

    if (fbCountClasses) {
        ulContainerCount = InorderTraverseTreeObjectClass (pTreeRoot);

        printf("Objects Counted: %d\r", ulContainerCount);
    }

    return ulRecCount;
}


/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/* This routine does in place swap of the the last sub-authority of the SID */
void
InPlaceSwapSid(PSID pSid)
{
    ULONG ulSubAuthorityCount;

    ulSubAuthorityCount= *(RtlSubAuthorityCountSid(pSid));
    if (ulSubAuthorityCount > 0)
    {
        PBYTE  RidLocation;
        BYTE   Tmp[4];

        RidLocation =  (PBYTE) RtlSubAuthoritySid(
                             pSid,
                             ulSubAuthorityCount-1
                             );

        //
        // Now byte swap the Rid location
        //

        Tmp[0] = RidLocation[3];
        Tmp[1] = RidLocation[2];
        Tmp[2] = RidLocation[1];
        Tmp[3] = RidLocation[0];

        RtlCopyMemory(RidLocation,Tmp,sizeof(ULONG));
    }
}


void DisplayRecord(void)
{
    char szDelTime[SZDSTIME_LEN];
    int i, j;

    // DNT
    if (!jrc[0].err)
    fprintf(stdout, "%6u ", ulDnt);
    else
    fprintf(stdout, "     - ");

    // PDNT
    if (!jrc[1].err)
    fprintf(stdout, "%6u ", ulPdnt);
    else
    fprintf(stdout, "     - ");

    // NC DNT
    if (!jrc[5].err)
    fprintf(stdout, "%6u ", ulNcDnt);
    else
    fprintf(stdout, "     - ");

    // RDN
    if (jrc[2].err)
    szRdn[0] = L'\0';
    else
        szRdn[jrc[2].cbActual/sizeof(WCHAR)] = L'\0';

    // refernce count
    if (!jrc[3].err)
    fprintf(stdout, "%6d ", lCount);
    else
    fprintf(stdout, "     - ");

    // Is visbible in AB
    if (!jrc[4].err)
    fprintf(stdout, "%1u ", (ULONG) bIsVisibleInAB);
    else
    fprintf(stdout, "- ");

    // object flag
    if (!jrc[6].err)
    fprintf(stdout, "%1u ", (ULONG) bObject);
    else
    fprintf(stdout, "- ");

    // Instance type
    if (!jrc[10].err)
        fprintf(stdout, "%2d ", insttype);
    else
        fprintf(stdout, " - ");

    // deletion time
    if (!jrc[7].err)
    fprintf(stdout, "%s ", DSTimeToDisplayString(DelTime, szDelTime));
    else
    fprintf(stdout, "                  ");

    // RDN type
    if (!jrc[8].err)
    fprintf(stdout, "%6u ", ulRdnType);
    else
    fprintf(stdout, "     - ");

    fprintf(stdout, "%03d ",jrc[2].cbActual);

    fprintf(stdout, "%-20S ", szRdn);

    // Guid
    if (!jrc[9].err) {
        LPSTR       pszGuid = NULL;
        RPC_STATUS  rpcStatus;

        rpcStatus = UuidToString(&Guid, &pszGuid);
        if (0 != rpcStatus) {
            fprintf(stderr, "UuidToString failed with error %d\n", rpcStatus);
            fprintf(stdout, "!! UuidToString failed with error %d", rpcStatus);
        }
        else {
            fprintf(stdout, "%s ", pszGuid);
            RpcStringFree(&pszGuid);
        }
    }
    else
    fprintf(stdout,"no guid                              ");

    // SID
    if (!jrc[11].err) {
        WCHAR SidText[128];
        UNICODE_STRING us;

        SidText[0] = L'\0';
        us.MaximumLength = sizeof(SidText);
        us.Length = 0;
        us.Buffer = SidText;

        InPlaceSwapSid(&Sid);
        RtlConvertSidToUnicodeString(&us, &Sid, FALSE);
        fprintf(stdout, "%ls", SidText);
    }
    else {
    fprintf(stdout, "no sid");
    }

    // objectClass
    if (!jrc[12].err)
    fprintf(stdout, " %6x ", objClass);
    else
    fprintf(stdout, "   - ");




    // newline
    fprintf(stdout, "\n");
}

void DumpHidden()
{
    JET_ERR err;
    JET_COLUMNDEF coldef;
    JET_COLUMNID dsaid;
    JET_COLUMNID dsstateid;
    JET_COLUMNID usnid;
    DWORD actuallen;
    DWORD dntDSA;
    DWORD dwState;
    USN   usn;

    if (err = JetOpenTable(sesid, dbid, SZHIDDENTABLE, NULL, 0, 0, &tblid))
    JetError(err, "JetOpenTable");

    /* Get USN column ID */

    JetGetTableColumnInfo(sesid,
              tblid,
              SZUSN,
              &coldef,
              sizeof(coldef),
              0);
    usnid = coldef.columnid;

    /* Get DSA name column ID */

    JetGetTableColumnInfo(sesid,
              tblid,
              SZDSA,
              &coldef,
              sizeof(coldef),
              0);
    dsaid = coldef.columnid;

    /* Get DSA installation state column ID */

    JetGetTableColumnInfo(sesid,
              tblid,
              SZDSSTATE,
              &coldef,
              sizeof(coldef),
              0);
    dsstateid = coldef.columnid;

    JetMove(sesid,
        tblid,
        JET_MoveFirst,
        0);

    JetRetrieveColumn(sesid,
              tblid,
              usnid,
              &usn,
              sizeof(usn),
              &actuallen,
              0,
              NULL);

    JetRetrieveColumn(sesid,
              tblid,
              dsaid,
              &dntDSA,
              sizeof(dntDSA),
              &actuallen,
              0,
              NULL);

    JetRetrieveColumn(sesid,
              tblid,
              dsstateid,
              &dwState,
              sizeof(dwState),
              &actuallen,
              0,
              NULL);


    printf("Hidden record: DSA dnt = %d, current USN = %ld, state = %d\n",
       dntDSA,
       usn,
       dwState);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\csvds\samcheck.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    samcheck.cxx

ABSTRACT:

DETAILS:
    
CREATED:

    09/02/97    Felix Wong (felixw)

REVISION HISTORY:

--*/


#include "csvde.hxx"
#pragma hdrstop
#include "samrestrict.h"

PRTL_GENERIC_TABLE g_pSpecial = NULL;

//+---------------------------------------------------------------------------
// Function:    CreateSamTables
//
// Synopsis:    
//    The goal of this routine is to set up the tables necessary for the SAM
//    exclusions. These tables are generated form the arrays found in
//    samrestrict.h, which are PAINFULLY hand generated from 
//    src\dsamain\src\mappings.c 
//    The pointers to the tables are also declared in samrestrict.h.
//    There are 6 tables that the lookup functions will need. One if for 
//    samCheckObject() to check whether the objectClass in LL_ldap_parse() is 
//    one under our watch. The remaining 5 are for each of the objects so that 
//    samCheckAttr() can find out whether the attribute we want to add is on 
//    the prohibited list. Called from LL_init()
//
// Arguments:   
//    None. We access the tables and variables in samrestrict.h  
//
// Returns:     
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR CreateSamTables() {
    long i;
    NAME_MAP    NameMap;
    PNAME_MAP   pNameMap = NULL;
    PNAME_MAP   pNameMapT = NULL;
    BOOLEAN     fNewElem;
    DIREXG_ERR     hr = DIREXG_SUCCESS;
    
    //
    // Objects specially considered for SAM operation
    //
    pSamObjects = (PRTL_GENERIC_TABLE)MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!pSamObjects) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    RtlInitializeGenericTable(pSamObjects, 
                              NtiComp, 
                              NtiAlloc, 
                              NtiFree, 
                              NULL);
    i = 0;
    while(g_rgszSamObjects[i]) {
        NameMap.szName = g_rgszSamObjects[i];
        NameMap.index = i+1;
        RtlInsertElementGenericTable(pSamObjects,
                                     &NameMap,
                                     sizeof(NAME_MAP), 
                                     &fNewElem);
        if (fNewElem==FALSE) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        i++;
    }
 
    
    //
    // Objects specially considered for SAM Server 
    //
    pServerAttrs = (PRTL_GENERIC_TABLE) MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!pServerAttrs) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    RtlInitializeGenericTable(pServerAttrs, 
                              NtiComp, 
                              NtiAlloc, 
                              NtiFree, 
                              NULL);
    i = 0;
    while(g_rgszServerSAM[i]) {
        NameMap.szName=g_rgszServerSAM[i];
        NameMap.index=0;
        RtlInsertElementGenericTable(pServerAttrs,
                                     &NameMap,
                                     sizeof(NAME_MAP), 
                                     &fNewElem);
        if (fNewElem==FALSE) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        i++;
    }

    //
    // Objects specially considered for Domain
    //
    pDomainAttrs = (PRTL_GENERIC_TABLE) MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!pDomainAttrs) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    RtlInitializeGenericTable(pDomainAttrs, 
                              NtiComp, 
                              NtiAlloc, 
                              NtiFree, 
                              NULL);
    i = 0;
    while(g_rgszDomainSAM[i]) {
        NameMap.szName = g_rgszDomainSAM[i];
        NameMap.index = 0;
        RtlInsertElementGenericTable(pDomainAttrs,
                                     &NameMap,
                                     sizeof(NAME_MAP), 
                                     &fNewElem);
        if (fNewElem==FALSE) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        i++;
    }

    //
    // Objects specially considered for Group
    //
    pGroupAttrs = (PRTL_GENERIC_TABLE) MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!pGroupAttrs) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    RtlInitializeGenericTable(pGroupAttrs, 
                              NtiComp, 
                              NtiAlloc, 
                              NtiFree, 
                              NULL);
    i = 0;
    while(g_rgszGroupSAM[i]) {
        NameMap.szName = g_rgszGroupSAM[i];
        NameMap.index = 0;
        RtlInsertElementGenericTable(pGroupAttrs,
                                     &NameMap,
                                     sizeof(NAME_MAP), 
                                     &fNewElem);
        if (fNewElem==FALSE) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        i++;
    }

    //
    // Objects specially considered for Local Group
    //
    pLocalGroupAttrs = (PRTL_GENERIC_TABLE) MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!pLocalGroupAttrs) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    RtlInitializeGenericTable(pLocalGroupAttrs, 
                              NtiComp, 
                              NtiAlloc, 
                              NtiFree, 
                              NULL);
    i = 0;
    while(g_rgszLocalGroupSAM[i]) {
        NameMap.szName = g_rgszLocalGroupSAM[i];
        NameMap.index = 0;
        RtlInsertElementGenericTable(pLocalGroupAttrs,
                                     &NameMap,
                                     sizeof(NAME_MAP), 
                                     &fNewElem);
        if (fNewElem==FALSE) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        i++;
    }
    
    //
    // Objects specially considered for User
    //
    pUserAttrs = (PRTL_GENERIC_TABLE) MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!pUserAttrs) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    RtlInitializeGenericTable(pUserAttrs, 
                              NtiComp, 
                              NtiAlloc, 
                              NtiFree, 
                              NULL);
    i = 0;
    while(g_rgszUserSAM[i]) {
        NameMap.szName = g_rgszUserSAM[i];
        NameMap.index = 0;
        RtlInsertElementGenericTable(pUserAttrs,
                                     &NameMap,
                                     sizeof(NAME_MAP), 
                                     &fNewElem);
        if (fNewElem==FALSE) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        i++;
    }

    g_pSpecial = (PRTL_GENERIC_TABLE) MemAlloc(sizeof(RTL_GENERIC_TABLE));
    if (!g_pSpecial) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    RtlInitializeGenericTable(g_pSpecial, NtiComp, NtiAlloc, NtiFree, NULL);
    
    //
    // Objects specially considered for special
    //
    i = 0;
    while(g_rgszSpecialClass[i]) {
        NameMap.szName = g_rgszSpecialClass[i];
        NameMap.index = g_rgAction[i];  
        if (NameMap.index==0) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        RtlInsertElementGenericTable(g_pSpecial,
                                     &NameMap,
                                     sizeof(NAME_MAP), 
                                     &fNewElem);
        if (fNewElem==FALSE) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        i++;
    }
error:
    return hr;
}


//+---------------------------------------------------------------------------
// Function:    DestroySamTables
//
// Synopsis:    
//    Destroy the tables created by CreateSamTables()
//    called from LL_end().
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
void DestroySamTables() {
    
     PNAME_MAP   pNameMap = NULL;
     
     if (pSamObjects) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pSamObjects, TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pSamObjects, TRUE)) 
        {
            RtlDeleteElementGenericTable(pSamObjects, pNameMap);
        }
            
        if (RtlIsGenericTableEmpty(pSamObjects)==FALSE) {
        }   
            
        MemFree(pSamObjects);
        pSamObjects = NULL;
     }

     if (pServerAttrs) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pServerAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pServerAttrs, TRUE)) 
        {
            RtlDeleteElementGenericTable(pServerAttrs, pNameMap);
        }
            
        if (RtlIsGenericTableEmpty(pServerAttrs)==FALSE) {
        }   
            
        MemFree(pServerAttrs);
        pServerAttrs = NULL;
     }

     if (pDomainAttrs) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pDomainAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pDomainAttrs, TRUE)) 
        {
            RtlDeleteElementGenericTable(pDomainAttrs, pNameMap);
        }
            
        if (RtlIsGenericTableEmpty(pDomainAttrs)==FALSE) {
        }   
            
        MemFree(pDomainAttrs);
        pDomainAttrs=NULL;
     }
 
     if (pGroupAttrs) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pGroupAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pGroupAttrs, TRUE)) 
        {
          RtlDeleteElementGenericTable(pGroupAttrs, pNameMap);
        }
            
        if (RtlIsGenericTableEmpty(pGroupAttrs)==FALSE) {
        }   
            
        MemFree(pGroupAttrs);
        pGroupAttrs=NULL;
     }

     if (pLocalGroupAttrs) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pLocalGroupAttrs, 
                                                            TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pLocalGroupAttrs, 
                                                            TRUE)) 
        {
            RtlDeleteElementGenericTable(pLocalGroupAttrs, pNameMap);
        }
            
        if (RtlIsGenericTableEmpty(pLocalGroupAttrs)==FALSE) {
        }   
            
        MemFree(pLocalGroupAttrs);
        pLocalGroupAttrs=NULL;
     }
 
     if (pUserAttrs) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pUserAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(pUserAttrs, TRUE)) 
        {
            RtlDeleteElementGenericTable(pUserAttrs, pNameMap);
        }
            
        if (RtlIsGenericTableEmpty(pUserAttrs)==FALSE) {
        }   
            
        MemFree(pUserAttrs);
        pUserAttrs=NULL;
     }

     if (g_pSpecial) {
        for (pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(g_pSpecial, TRUE);
             pNameMap != NULL;
             pNameMap = (PNAME_MAP)RtlEnumerateGenericTable(g_pSpecial, TRUE)) 
        {
            RtlDeleteElementGenericTable(g_pSpecial, pNameMap);
        }
            
        if (RtlIsGenericTableEmpty(g_pSpecial)==FALSE) {
        }   
            
        MemFree(g_pSpecial);
        g_pSpecial=NULL;
     }
}

//+---------------------------------------------------------------------------
// Function:    CheckObjectSam
//
// Synopsis:    
//  CheckObjectSam() - this function will be called 
//  from LL_ldap_parse() to determine whether the
//  object we are looking at is on our sam watch list.
//
// Arguments:   
//  class - a value of the objectClass attribute.
//          This function will be called 
//          on every value of objectClass received to 
//          determine whether this object or any of its
//          ancestors are on our watch list.
//
// Returns:     
//          0 if the object was not found
//          or 1-5 indicating which table samCheckAttr()
//          should look at it. This number was set by CreateSamTables()
//          in the index member of the table entry.
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
int CheckObjectSam(PWSTR szObjectClass) 
{
    NAME_MAP    NameMap;
    PNAME_MAP   pElemTemp = NULL;

    NameMap.szName = szObjectClass;
    NameMap.index = 0; 

    pElemTemp = (PNAME_MAP)RtlLookupElementGenericTable(pSamObjects, 
                                                        &NameMap);

    if (pElemTemp) {
        return pElemTemp->index;
    } 
    else {
        return 0;
    }
}

//+---------------------------------------------------------------------------
// Function:    CheckObjectSpecial
//
// Synopsis:    
//       to determine whether the object we are looking at is on 
//       our special list.
//
// Arguments:   
//    class - a value of the objectClass attribute.
//            This function will be called 
//            on every value of objectClass received to 
//            determine whether this object or any of its
//            ancestors are on our list.
//
// Returns:     
//       0 if the object was not found
//       or the action code. (defined in samrestrict.h)
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
int CheckObjectSpecial(PWSTR szObjectClass) 
{
    NAME_MAP    NameMap;
    PNAME_MAP   pElemTemp = NULL;

    NameMap.szName = szObjectClass;
    NameMap.index = 0; 

    pElemTemp = (PNAME_MAP)RtlLookupElementGenericTable(g_pSpecial, 
                                                        &NameMap);

    if (pElemTemp) {
        return pElemTemp->index;
    } else {
        return 0;
    }
}

//+---------------------------------------------------------------------------
// Function:    CheckAttrSam
//
// Synopsis:    
//      Given the number of the table to look at and
//      an attribute name, this function will figure out
//      if the attribute is on the L"no-no" list. This function 
//      gets the number returned by CheckObjectSam();
//
// Arguments:   
//      attribute: the name of the attrbiute to look up
//      table:     the number of the table to look at
//
// Returns:     
//      TRUE  - this attrbiute is prohibited
//      FALSE - this attribute is allowed
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
BOOL CheckAttrSam(PWSTR szAttribute, int table) {
    
    NAME_MAP    NameMap;
    PNAME_MAP   pNameMapT;

    NameMap.szName = szAttribute;
    NameMap.index = 0; //and it doesn't really matter what we set this to

    switch(table) {
        case 1:   
            pNameMapT = (PNAME_MAP)RtlLookupElementGenericTable(pServerAttrs, 
                                                                &NameMap);  
            break;
        case 2:   
            pNameMapT = (PNAME_MAP)RtlLookupElementGenericTable(pDomainAttrs, 
                                                                &NameMap);  
            break;
        case 3:   
            pNameMapT = (PNAME_MAP)RtlLookupElementGenericTable(pGroupAttrs, 
                                                                &NameMap);  
            break;
        case 4:   
           pNameMapT = (PNAME_MAP)RtlLookupElementGenericTable(pLocalGroupAttrs, 
                                                               &NameMap);  
            break;
        case 5:   
            pNameMapT = (PNAME_MAP)RtlLookupElementGenericTable(pUserAttrs, 
                                                                &NameMap);  
            break;
        default:  
            return FALSE;
    }

    if (pNameMapT) {
        return TRUE;
    } else {
        return FALSE;
    }

}

//+---------------------------------------------------------------------------
// Function:    Name to Index Function calls
//
// Synopsis:    
//      Lets use RTL_GENERIC_TABLE to improve the efficiency of nametable_op
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
PVOID NtiAlloc( RTL_GENERIC_TABLE *pTable, CLONG ByteSize )
{
    return(MemAlloc(ByteSize));
}

VOID NtiFree ( RTL_GENERIC_TABLE *pTable, PVOID pvBuffer )
{
    MemFree(pvBuffer);
}


RTL_GENERIC_COMPARE_RESULTS
NtiComp( PRTL_GENERIC_TABLE  pTable,
         PVOID               pvFirstStruct,
         PVOID               pvSecondStruct ) 
{
    PNAME_MAP pNameMap1 = (PNAME_MAP)pvFirstStruct;
    PNAME_MAP pNameMap2 = (PNAME_MAP)pvSecondStruct;
  
    PWSTR szName1 = pNameMap1->szName;
    PWSTR szName2 = pNameMap2->szName;
    
    int diff;

    diff = _wcsicmp(szName1, szName2);

    if (diff<0) {
        return GenericLessThan;
    } 
    else if (diff == 0) {
        return GenericEqual;
    } 
    else {
        return GenericGreaterThan;
    }
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\csvds\utils.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    util.cxx

Abstract:
    
    Utilities

Author:

    Felix Wong [FelixW]    06-Sep-1997
    
++*/

#include "csvde.hxx"
#pragma hdrstop

extern BOOLEAN g_fUnicode;
extern DWORD g_cLine;
extern DWORD g_cColumn;

//+---------------------------------------------------------------------------
// Class:  CStringPlex
//
// Synopsis: A Class that encapsulates an array of zero terminated strings    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CStringPlex::CStringPlex()
{
    m_cszMax = 0;
    m_iszNext = 0;
    m_rgsz = NULL;
}

CStringPlex::~CStringPlex()
{
    Free();
}

DIREXG_ERR CStringPlex::GetCopy(PWSTR **prgszReturn)
{
    PWSTR *rgszReturn = NULL;
    DIREXG_ERR hr = DIREXG_SUCCESS;
    DWORD i;

    if (m_iszNext == 0) {
        hr = DIREXG_ERROR;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    rgszReturn = (PWSTR*)MemAlloc( m_iszNext * sizeof(PWSTR) );
    if (!rgszReturn) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    memset(rgszReturn, 0, m_iszNext * sizeof(PWSTR) );

    for (i=0;i<m_iszNext;i++) {
        rgszReturn[i] = MemAllocStrW(m_rgsz[i]); 
        if (!rgszReturn[i]) {
            hr = DIREXG_OUTOFMEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }
    
    *prgszReturn = rgszReturn;
    return hr;

error:
    if (rgszReturn) {
        i = 0;
        while ((i<m_iszNext) && rgszReturn[i]) {
            MemFree(rgszReturn[i]);
            i++;
        }
        MemFree (rgszReturn);
    }
    return hr;
}

DWORD CStringPlex::NumElements()
{
    return m_iszNext;
}

PWSTR *CStringPlex::Plex()
{
    return m_rgsz;
}


DIREXG_ERR CStringPlex::Init()
{
    DIREXG_ERR hr = DIREXG_SUCCESS;

    Free();

    m_rgsz = (PWSTR*)MemAlloc( STRINGPLEX_INC * sizeof(PWSTR) );
    if (!m_rgsz ) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    m_cszMax = STRINGPLEX_INC;
    m_iszNext = 0;
    memset(m_rgsz, 0, STRINGPLEX_INC * sizeof(PWSTR) );

error:
    return hr;
}

DIREXG_ERR CStringPlex::AddElement(PWSTR szValue)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    PWSTR *rgszT = NULL;

    if (!szValue) {
        return DIREXG_ERROR;
    }

    //
    // If next index is larger than largest index
    //
    if (m_iszNext > (m_cszMax-1)) {
        rgszT = (PWSTR*)MemRealloc(m_rgsz , 
                                (m_cszMax)*sizeof(PWSTR),
                                (m_cszMax + STRINGPLEX_INC)*sizeof(PWSTR));
        if (!rgszT) {
            hr = DIREXG_OUTOFMEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        m_rgsz = rgszT;
        m_cszMax+=STRINGPLEX_INC;
    }

    m_rgsz [m_iszNext] = MemAllocStrW(szValue);
    if (!m_rgsz [m_iszNext]) {
         hr = DIREXG_OUTOFMEMORY;
         DIREXG_BAIL_ON_FAILURE(hr);
    }
    m_iszNext++;
error:
    return hr;
}

void CStringPlex::Free()
{
    DWORD isz = 0;

    if (m_rgsz) {
        for (isz=0;isz<m_iszNext;isz++) {
            if (m_rgsz[isz]) {
                MemFree(m_rgsz[isz]);
            }
        }
        MemFree (m_rgsz);
        m_rgsz = NULL;
    }
    m_cszMax = 0;
    m_iszNext = 0;
}

//+---------------------------------------------------------------------------
// Class:  CString
//
// Synopsis: A class that encapsulates a variable size string    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CString::CString()
{
    m_sz = NULL;
    m_ichNext = 0;
    m_cchMax = 0;
}

CString::~CString()
{
    Free();
}

DIREXG_ERR CString::Init()
{
    Free();
    m_sz = (PWSTR)MemAlloc(STRING_INC * sizeof(WCHAR));
    if (!m_sz) {
        return DIREXG_OUTOFMEMORY;
    }
    m_cchMax = STRING_INC;
    m_ichNext = 0;
    m_sz[0] = '\0';
    return DIREXG_SUCCESS;
}

DIREXG_ERR CString::GetCopy(PWSTR *pszReturn)
{
    PWSTR szReturn = NULL;
    szReturn = MemAllocStrW(m_sz);
    if (!szReturn) {
        return DIREXG_OUTOFMEMORY;
    }
    *pszReturn = szReturn;
    return DIREXG_SUCCESS;
}

PWSTR CString::String()
{
    return m_sz;
}


DIREXG_ERR CString::Append(PWSTR szAppend)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    PWSTR szT;
    DWORD cchResult;
    DWORD cchAppend;
    
    cchAppend = wcslen(szAppend);
    if ((cchAppend + m_ichNext) > (m_cchMax - 1)) {
        //
        // If normal addition of memory is not enough
        //
        if ((cchAppend + m_ichNext) > (m_cchMax + STRING_INC - 1)) {
            cchResult = m_cchMax + STRING_INC + cchAppend;
        }
        else {
            cchResult = m_cchMax + STRING_INC;
        }
        szT = (PWSTR)MemRealloc(m_sz, 
                                    sizeof(WCHAR) * m_cchMax,
                                    sizeof(WCHAR) * cchResult);
        if (!szT) {
            hr = DIREXG_OUTOFMEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        m_sz = szT;
        m_cchMax = cchResult;
    }
    m_ichNext += cchAppend;
    wcscat(m_sz, szAppend);

error:
    return hr;
}

DIREXG_ERR CString::Backup()
{
    DIREXG_ERR hr = DIREXG_ERROR;

    if (m_sz && (m_ichNext > 0)) {
        m_sz[m_ichNext-1] = '\0';
        m_ichNext--;
        hr = DIREXG_SUCCESS;
    }
    return hr;
}

void CString::Free()
{
    if (m_sz) {
        MemFree(m_sz);
        m_sz = NULL;
    }
    m_ichNext = 0;
    m_cchMax = 0;
}


//+---------------------------------------------------------------------------
// Function:  SubString
//
// Synopsis:  substitute every occurences of 'szFrom' to 'szTo'. Will allocate
//            a return string. It must be MemFreed by MemFree()  
//            If the intput does not contain the 'szFrom', it will just return 
//            DIREXG_SUCCESS with szOutput = NULL;
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR SubString(PWSTR szInput,
                  PWSTR szFrom,
                  PWSTR szTo,
                  PWSTR *pszOutput)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    PWSTR szOutput = NULL;
    PWSTR szLast = NULL;
    PWSTR szReturn = NULL;
    DWORD cchToCopy = 0;            // count of number of WCHAR to copy
    DWORD cchReturn = 0;
    DWORD cchFrom;
    DWORD cchTo;
    DWORD cchInput;
    DWORD cSubString = 0;       // count of number of substrings in input

    cchFrom    = wcslen(szFrom);
    cchTo      = wcslen(szTo);
    cchInput   = wcslen(szInput);
    *pszOutput = NULL;

    //
    // Does the substring exist?
    //
    szOutput = wcsistr(szInput,
                      szFrom);
    if (!szOutput) {
        *pszOutput = NULL;
        return DIREXG_SUCCESS;
    }

    // 
    // Counting substrings
    //
    while (szOutput) {
        szOutput += cchFrom;
        cSubString++;
        szOutput = wcsistr(szOutput,
                          szFrom);
    }

    //
    // Allocating return string
    //
    cchReturn = cchInput + ((cchTo - cchFrom) * cSubString) + 1;
    szReturn = (PWSTR)MemAlloc(sizeof(WCHAR) * cchReturn);
    if (!szReturn) {
        hr = DIREXG_OUTOFMEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    };
    szReturn[0] = '\0';
    
    //
    // Copying first string before sub
    //
    szOutput = wcsistr(szInput,
                      szFrom);
    cchToCopy = (DWORD)(szOutput - szInput);
    wcsncat(szReturn,
            szInput,
            cchToCopy);
    
    //
    // Copying 'To' String over
    //
    wcscat(szReturn,
           szTo);
    szInput = szOutput + cchFrom;

    //
    // Test for more 'from' string
    //
    szOutput = wcsistr(szInput,
                      szFrom);
    while (szOutput) {
        cchToCopy = (DWORD)(szOutput - szInput);
        wcsncat(szReturn,
                szInput,
                cchToCopy);
        wcscat(szReturn,
                szTo);
        szInput= szOutput + cchFrom;
        szOutput = wcsistr(szInput,
                          szFrom);
    }

    wcscat(szReturn,
           szInput);
    *pszOutput = szReturn;

error:
    return (hr);
}


//+---------------------------------------------------------------------------
// Function:  wcsistr
//
// Synopsis:  Case-insensitive version of wcsstr.
//            Based off the Visual C++ 6.0 CRT
//            sources.
//
// Arguments: wcs1 --- string to be searched
//            wcs2 --- substring to search for
//
// Returns:   ptr to first occurrence of wcs1 in wcs2, or NULL
//
// Modifies:      -
//
// History:    9-28-00   MattRim         Created.
//
//----------------------------------------------------------------------------

wchar_t * __cdecl wcsistr (
        const wchar_t * wcs1,
        const wchar_t * wcs2
        )
{
        wchar_t *cp = (wchar_t *) wcs1;
        wchar_t *s1, *s2;
        wchar_t cs1, cs2;

        while (*cp)
        {
                s1 = cp;
                s2 = (wchar_t *) wcs2;

                cs1 = *s1;
                cs2 = *s2;

                if (iswupper(cs1))
                    cs1 = towlower(cs1);

                if (iswupper(cs2))
                    cs2 = towlower(cs2);


                while ( *s1 && *s2 && !(cs1-cs2) ) {

                    s1++, s2++;

                    cs1 = *s1;
                    cs2 = *s2;

                    if (iswupper(cs1))
                        cs1 = towlower(cs1);

                    if (iswupper(cs2))
                        cs2 = towlower(cs2);
                }

                if (!*s2)
                        return(cp);

                cp++;
        }

        return(NULL);
}







//+---------------------------------------------------------------------------
// Function:  GetLine
//
// Synopsis:  will return the new line in the allocated buffer, must be MemFreed
//            by user
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR GetLine(FILE* pFileIn,
                   PWSTR *pszLine)
{
    CString String;
    DIREXG_ERR hr = DIREXG_SUCCESS;
    WCHAR szValue[256];
    PWSTR szReturn = NULL;
    DWORD dwLength;

    hr = String.Init();
    DIREXG_BAIL_ON_FAILURE(hr);

    do {
        szReturn = fgetws(szValue,
                          256,
                          pFileIn);
        //
        // We increment the line counter everytime right after we get a new line
        //
        g_cLine++;

        //
        // Restart the column counter to start from 0 because it is a newline
        //
        g_cColumn = 0;
    }
    while (szReturn && (szReturn[0] == '\n' || szReturn[0] == '\r'));

    while (szReturn) {
        hr = String.Append(szValue);
        DIREXG_BAIL_ON_FAILURE(hr);

        //
        // If the whole line isn't filled, we know this line is terminated by an end
        // If it is filled, and the last char is carriage return, then we know the line
        // has termianted as well.
        //
        if ((wcslen(szReturn) != 255) || (szReturn[254] == '\n')) {
            break;
        }
        szReturn = fgetws(szValue,
                          256,
                          pFileIn);
    }

    //
    // If it is not end of file, an error has occurred
    //
    if ((szReturn == 0) && (feof(pFileIn) == FALSE)) {
        *pszLine = NULL;
        goto error;
    }

    hr = String.GetCopy(pszLine);
    DIREXG_BAIL_ON_FAILURE(hr);

    dwLength = wcslen(*pszLine);
    if ((dwLength>1) && ((*pszLine)[dwLength-1] == '\n')) {
        (*pszLine)[dwLength-1] = '\0';
    }

    //
    // In unicode mode, \r will be passed back to us as well. We'll have to back
    // that up too
    //
    if (g_fUnicode && (dwLength>0)) {
        dwLength--;
        if ((dwLength>0) && ((*pszLine)[dwLength-1] == '\r')) {
            (*pszLine)[dwLength-1] = '\0';
        }
    }


error:
    return (hr);
}

//+---------------------------------------------------------------------------
// Function:   AppendFile 
//
// Synopsis:   Append fileAppend to fileTarget
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DIREXG_ERR AppendFile(FILE* pFileAppend,
                   FILE* pFileTarget)
{
    DIREXG_ERR hr = DIREXG_SUCCESS;
    unsigned char szBuffer[100];
    DWORD cchRead = 0;
    DWORD cchWrite = 0;

    while (!feof(pFileAppend)) {
        cchRead = fread(szBuffer, 
                        sizeof(unsigned char), 
                        1, 
                        pFileAppend);
        if ((ferror(pFileAppend)) || ((cchRead == 0) &&(!feof(pFileAppend)))) {
            hr = DIREXG_ERROR;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        if (cchRead > 0) {
            cchWrite = fwrite(szBuffer, 
                              sizeof(unsigned char), 
                              cchRead, 
                              pFileTarget);
            if (cchWrite == 0) {
                hr = DIREXG_ERROR;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }
    }
error:
    return hr;
}

void OutputExtendedError(LDAP *pLdap) {
    DWORD dwWinError = NULL;
    DWORD dwError;
    DWORD dwLen;
    WCHAR szMsg[MAX_PATH];

    dwError = ldap_get_optionW( pLdap, LDAP_OPT_SERVER_EXT_ERROR, &dwWinError);
    if (dwError == LDAP_SUCCESS) {
        if (dwWinError) {
            dwLen = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                                  NULL,
                                  dwWinError,
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                  szMsg,
                                  MAX_PATH,
                                  NULL);
            if (dwLen == 0) {
                _itow(dwWinError, szMsg, 10);
            }
            else {
                //
                // If we get a message, we'll remove all the linefeeds in it
                // and replace it with a space, except the last one
                //
                PWSTR pszNew = szMsg;
                while (pszNew && (pszNew = wcsstr(pszNew,L"\r\n"))) {
                    if ((*(pszNew+2))) {
                        wcscpy(pszNew, L" ");                                           
                        wcscpy(pszNew+1, (pszNew + 2));
                    }
                    else {
                        wcscpy(pszNew, (pszNew + 2));
                    }
                }
            }

            SelectivePrint(PRT_STD|PRT_LOG|PRT_ERROR,
                            MSG_CSVDE_EXTENDERROR, 
                            szMsg);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\common\ldaputil.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ldaputil.c

ABSTRACT:

    This gives shortcuts to common ldap code.

DETAILS:

    This is a work in progress to have convienent functions added as needed
    for simplyfying the massive amounts of LDAP code that must be written for
    dcdiag.
    
    All functions should return two types, either a pointer that will be
    a NULL on an error, or will be a win 32 error code.

    All returned results that need alloc'd memory should use LocalAlloc(),
    so that all results can be dealloc'd using LocalFree().

  ===================================================================
  Code.Improvement It would be good to continue to add to this as the
  need arrises.  Things that might be added are:
    DcDiagGetBlobAttribute() ???
    DcDiagGetMultiStringAttribute() ... returns a LPWSTR *, but must use ldap_value_free() on it.
    DcDiagGetMultiBlobAttribute() ??/

CREATED:

    23 Aug 1999  Brett Shirley

--*/

#include <ntdspch.h>
#include <ntdsa.h>    // options

#include "dcdiag.h"

FILETIME gftimeZero = {0};

// Other Forward Function Decls
PDSNAME
DcDiagAllocDSName (
    LPWSTR            pszStringDn
    );


DWORD
DcDiagGetStringDsAttributeEx(
    LDAP *                          hld,
    IN  LPWSTR                      pszDn,
    IN  LPWSTR                      pszAttr,
    OUT LPWSTR *                    ppszResult
    )
/*++

Routine Description:

    This function takes a handle to an LDAP, and gets the
    single string attribute value of the specified attribute
    on the distinquinshed name.

Arguments:

    hld - LDAP connection to use.
    pszDn - The DN containing the desired attribute value.
    pszAttr - The attribute containing the desired value.
    ppszResult - The returned string, in LocalAlloc'd mem.

Return Value:
    
    Win 32 Error.

Note:

    As all LDAPUTIL results, the results should be freed, 
    using LocalFree().

--*/
{
    LPWSTR                         ppszAttrFilter[2];
    LDAPMessage *                  pldmResults = NULL;
    LDAPMessage *                  pldmEntry = NULL;
    LPWSTR *                       ppszTempAttrs = NULL;
    DWORD                          dwErr = ERROR_SUCCESS;
    
    *ppszResult = NULL;

    Assert(hld);

    __try{

        ppszAttrFilter[0] = pszAttr;
        ppszAttrFilter[1] = NULL;
        dwErr = LdapMapErrorToWin32(ldap_search_sW(hld,
                                                   pszDn,
                                                   LDAP_SCOPE_BASE,
                                                   L"(objectCategory=*)",
                                                   ppszAttrFilter,
                                                   0,
                                                   &pldmResults));


        if(dwErr != ERROR_SUCCESS){
            __leave;
        }

        pldmEntry = ldap_first_entry(hld, pldmResults);
        if(pldmEntry == NULL){
            Assert(!L"I think this shouldn't ever happen? BrettSh\n");
            // Need to signal and error of some sort.  Technically the error
            //   is in the ldap session object.
            dwErr = LdapMapErrorToWin32(hld->ld_errno);
            __leave;
        }
        
        ppszTempAttrs = ldap_get_valuesW(hld, pldmEntry, pszAttr);
        if(ppszTempAttrs == NULL || ppszTempAttrs[0] == NULL){
            // Simply means there is no such attribute.  Not an error.
            __leave;
        }

        *ppszResult = LocalAlloc(LMEM_FIXED, 
                           sizeof(WCHAR) * (wcslen(ppszTempAttrs[0]) + 2));
        if(*ppszResult == NULL){
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        wcscpy(*ppszResult, ppszTempAttrs[0]);

    } __finally {
        if(pldmResults != NULL){ ldap_msgfree(pldmResults); }
        if(ppszTempAttrs != NULL){ ldap_value_freeW(ppszTempAttrs); }
    }

    return(dwErr);
}


DWORD
DcDiagGetStringDsAttribute(
    IN  PDC_DIAG_SERVERINFO         prgServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN  LPWSTR                      pszDn,
    IN  LPWSTR                      pszAttr,
    OUT LPWSTR *                    ppszResult
    )
/*++

Routine Description:

    This is a wrapper for the function DcDiagGetStringDsAttributeEx(),
    which takes a hld.  This function uses dcdiag a pServer structure 
    to know who to connect/bind to.  Then it returns the result and
    pResult straight from the Ex() function.

Arguments:

    prgServer - A struct holding the server name/binding info.
    gpCreds - The credentials to use in binding.
    pszDn - The DN holding the attribute value desired.
    pszAttr - The attribute with the desired value.

Return Value:
    
    Win 32 Error.

Note:

    As all LDAPUTIL results, the results should be freed, 
    using LocalFree().

--*/
{
    LDAP *                         hld = NULL;
    DWORD                          dwErr;
    
    dwErr = DcDiagGetLdapBinding(prgServer,
                                 gpCreds,
                                 FALSE,
                                 &hld);
    if(dwErr != ERROR_SUCCESS){
        // Couldn't even bind to the server, return the error.
        return(dwErr);
    }       

    dwErr = DcDiagGetStringDsAttributeEx(hld,
                                         pszDn,
                                         pszAttr,
                                         ppszResult);
    return(dwErr);
}


LPWSTR
DcDiagTrimStringDnBy(
    IN  LPWSTR                      pszInDn,
    IN  ULONG                       ulTrimBy
    )
/*++

Routine Description:

    This routine simply takes a DN as a string, and trims off the number
    of DN parts as specified by ulTrimBy.

Arguments:

    pszInDn - The DN to trim.
    ulTrimBy - Number of parts to trim off the front of the DN.

Return Value:
    
    Returns NULL if there was an error, otherwise a pointer to the new DN.

Note:

    As all LDAPUTIL results, the results should be freed, 
    using LocalFree().

--*/
{
    PDSNAME                         pdsnameOrigDn = NULL;
    PDSNAME                         pdsnameTrimmed = NULL;
    LPWSTR                          pszOutDn;

    Assert(ulTrimBy > 0);
    Assert(ulTrimBy < 50); // insanity check

    // Setup two pdsname structs, for orig & trimmed DNs.
    pdsnameOrigDn = DcDiagAllocDSName(pszInDn);
    if(pdsnameOrigDn == NULL){
        return(NULL);
    }
    pdsnameTrimmed = (PDSNAME) LocalAlloc(LMEM_FIXED, pdsnameOrigDn->structLen);
    if(pdsnameTrimmed == NULL){
        LocalFree(pdsnameOrigDn);
        return(NULL);
    }

    // Trim the DN.
    TrimDSNameBy(pdsnameOrigDn, ulTrimBy, pdsnameTrimmed);

    // Put result back in original string and return.
    Assert(wcslen(pdsnameTrimmed->StringName) <= wcslen(pszInDn));
    pszOutDn = LocalAlloc(LMEM_FIXED, 
                        sizeof(WCHAR) * (wcslen(pdsnameTrimmed->StringName) + 2));
    if(pszOutDn == NULL){
        LocalFree(pdsnameTrimmed);
        LocalFree(pdsnameOrigDn);
        return(NULL);
    }
    wcscpy(pszOutDn, pdsnameTrimmed->StringName);

    // Free temporary memory and return result
    LocalFree(pdsnameOrigDn);
    LocalFree(pdsnameTrimmed);
    return(pszOutDn);
}

INT
MemWtoi(WCHAR *pb, ULONG cch)
/*++

Routine Description:

    This function will take a string and a length of numbers to convert.

Parameters:
    pb - [Supplies] The string to convert.
    cch - [Supplies] How many characters to convert.

Return Value:
  
    The value of the integers.

  --*/
{
    int res = 0;
    int fNeg = FALSE;

    if (*pb == L'-') {
        fNeg = TRUE;
        pb++;
    }


    while (cch--) {
        res *= 10;
        res += *pb - L'0';
        pb++;
    }
    return (fNeg ? -res : res);
}

DWORD
DcDiagGeneralizedTimeToSystemTime(
    LPWSTR IN                   szTime,
    PSYSTEMTIME OUT             psysTime)
/*++

Routine Description:

    Converts a generalized time string to the equivalent system time.

Parameters:
    szTime - [Supplies] This is string containing generalized time.
    psysTime - [Returns] This is teh SYSTEMTIME struct to be returned.

Return Value:
  
    Win 32 Error code, note could only result from invalid parameter.

  --*/
{
   DWORD       status = ERROR_SUCCESS;
   ULONG       cch;
   ULONG       len;

    //
    // param sanity
    //
    if (!szTime || !psysTime)
    {
       return STATUS_INVALID_PARAMETER;
    }

    len = wcslen(szTime);

    if( len < 15 || szTime[14] != '.')
    {
       return STATUS_INVALID_PARAMETER;
    }

    // initialize
    memset(psysTime, 0, sizeof(SYSTEMTIME));

    // Set up and convert all time fields

    // year field
    cch=4;
    psysTime->wYear = (USHORT)MemWtoi(szTime, cch) ;
    szTime += cch;
    // month field
    psysTime->wMonth = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // day of month field
    psysTime->wDay = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // hours
    psysTime->wHour = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // minutes
    psysTime->wMinute = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // seconds
    psysTime->wSecond = (USHORT)MemWtoi(szTime, (cch=2));

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\common\bindings.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    common\bindings.c

ABSTRACT:

    This file has all the binding type functions, for getting Cached LDAP, DS,
    or Net Use/Named Pipe bindings.

DETAILS:

CREATED:

    02 Sept 1999 Brett Shirley (BrettSh)

--*/

#include <ntdspch.h>

#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <ntldap.h>

#include <ntlsa.h>
#include <ntseapi.h>
#include <winnetwk.h>
#include <permit.h>

#include <netevent.h>

#include "dcdiag.h"
#include "ldaputil.h"


// Code.Improvement move this function here from intersite.c
VOID
InitLsaString(
    OUT  PLSA_UNICODE_STRING pLsaString,
    IN   LPWSTR              pszString
    );


// ===========================================================================
// Ldap connections/binding (ldap_init(), ldap_bind(), ldap_unbind(), etc)
// ===========================================================================

DWORD
DcDiagCacheServerRootDseAttrs(
    IN LDAP *hLdapBinding,
    IN PDC_DIAG_SERVERINFO pServer
    )

/*++

Routine Description:

    Reads server-specific Root DSE attributes and caches them in the server
    object.

    Helper routine for GetLdapBinding(). This may also be called by GatherInfo,
    which constructs the ldap binding to the home server directly without calling
    GetLdapBinding().

    In order to help diagnose binding errors, it is necessary to obtain Root DSE
    attributes before the bind takes place. We report errors here in this routine
    to help identify contributing factors to a bind failure.

Arguments:

    hLdapBinding - Binding to server that is going to be queried
    pServer - Server corresponding to binding, to receive attributes

Return Value:

    DWORD -

--*/

{
    DWORD dwRet;
    LPWSTR  ppszRootDseServerAttrs [] = {
        L"currentTime",
        L"highestCommittedUSN",
        L"isSynchronized",
        L"isGlobalCatalogReady",
        NULL };
    LDAPMessage *              pldmEntry = NULL;
    LDAPMessage *              pldmRootResults = NULL;
    LPWSTR *                   ppszValues = NULL;

    dwRet = ldap_search_sW (hLdapBinding,
                            NULL,
                            LDAP_SCOPE_BASE,
                            L"(objectCategory=*)",
                            ppszRootDseServerAttrs,
                            0,
                            &pldmRootResults);
    if (dwRet != ERROR_SUCCESS) {
        dwRet = LdapMapErrorToWin32(dwRet);
        PrintMessage(SEV_ALWAYS,
                     L"[%s] LDAP search failed with error %d,\n",
                     pServer->pszName, dwRet);
        PrintMessage(SEV_ALWAYS, L"%s.\n", Win32ErrToString(dwRet));
        goto cleanup;
    }
    if (pldmRootResults == NULL) {
        dwRet = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    pldmEntry = ldap_first_entry (hLdapBinding, pldmRootResults);
    if (pldmEntry == NULL) {
        dwRet = ERROR_DS_MISSING_EXPECTED_ATT;
        goto cleanup;
    }

    //
    // Attribute: currentTime
    //

    ppszValues = ldap_get_valuesW( hLdapBinding, pldmEntry, L"currentTime" );
    if ( (ppszValues) && (ppszValues[0]) ) {
        SYSTEMTIME systemTime;

        PrintMessage( SEV_DEBUG, L"%s.currentTime = %ls\n",
                      pServer->pszName,
                      ppszValues[0] );

        dwRet = DcDiagGeneralizedTimeToSystemTime((LPWSTR) ppszValues[0], &systemTime);
        if(dwRet == ERROR_SUCCESS){
            SystemTimeToFileTime(&systemTime, &(pServer->ftRemoteConnectTime) );
            GetSystemTime( &systemTime );
            SystemTimeToFileTime( &systemTime, &(pServer->ftLocalAcquireTime) );
        } else {
            PrintMessage( SEV_ALWAYS, L"[%s] Warning: Root DSE attribute %ls is has invalid value %ls\n",
                          pServer->pszName, L"currentTime", ppszValues[0] );
            // keep going, not fatal
        }
    } else {
        PrintMessage( SEV_ALWAYS, L"[%s] Warning: Root DSE attribute %ls is missing\n",
                     pServer->pszName, L"currentTime" );
        // keep going, not fatal
    }
    ldap_value_freeW(ppszValues );

    //
    // Attribute: highestCommittedUSN
    //

    ppszValues = ldap_get_valuesW( hLdapBinding, pldmEntry, L"highestCommittedUSN" );
    if ( (ppszValues) && (ppszValues[0]) ) {
        pServer->usnHighestCommittedUSN = _wtoi64( *ppszValues );
    } else {
        PrintMessage( SEV_ALWAYS, L"[%s] Warning: Root DSE attribute %ls is missing\n",
                     pServer->pszName, L"highestCommittedUSN" );
        // keep going, not fatal
    }
    ldap_value_freeW(ppszValues );
    PrintMessage( SEV_DEBUG, L"%s.highestCommittedUSN = %I64d\n",
                  pServer->pszName,
                  pServer->usnHighestCommittedUSN );

    //
    // Attribute: isSynchronized
    //

    ppszValues = ldap_get_valuesW( hLdapBinding, pldmEntry, L"isSynchronized" );
    if ( (ppszValues) && (ppszValues[0]) ) {
        pServer->bIsSynchronized = (_wcsicmp( ppszValues[0], L"TRUE" ) == 0);
    } else {
        PrintMessage( SEV_ALWAYS, L"[%s] Warning: Root DSE attribute %ls is missing\n",
                     pServer->pszName, L"isSynchronized" );
        // keep going, not fatal
    }
    ldap_value_freeW(ppszValues );
    PrintMessage( SEV_DEBUG, L"%s.isSynchronized = %d\n",
                  pServer->pszName,
                  pServer->bIsSynchronized );
    if (!pServer->bIsSynchronized) {
        PrintMsg( SEV_ALWAYS, DCDIAG_INITIAL_DS_NOT_SYNCED, pServer->pszName );
    }

    //
    // Attribute: isGlobalCatalogReady
    //

    ppszValues = ldap_get_valuesW( hLdapBinding, pldmEntry, L"isGlobalCatalogReady" );
    if ( (ppszValues) && (ppszValues[0]) ) {
        pServer->bIsGlobalCatalogReady = (_wcsicmp( ppszValues[0], L"TRUE" ) == 0);
    } else {
        PrintMessage( SEV_ALWAYS, L"[%s] Warning: Root DSE attribute %ls is missing\n",
                     pServer->pszName, L"isGlobalCatalogReady" );
        // keep going, not fatal
    }
    ldap_value_freeW(ppszValues );
    PrintMessage( SEV_DEBUG, L"%s.isGlobalCatalogReady = %d\n",
                  pServer->pszName,
                  pServer->bIsGlobalCatalogReady );

cleanup:

    if (pldmRootResults) {
        ldap_msgfree (pldmRootResults);
    }

    return dwRet;
} /* DcDiagCacheServerRootDseAttrs */

DWORD
DcDiagGetLdapBinding(
    IN   PDC_DIAG_SERVERINFO                 pServer,
    IN   SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
    IN   BOOL                                bUseGcPort,
    OUT  LDAP * *                            phLdapBinding
    )
/*++

Routine Description:

    This returns a LDAP binding from ldap_init() and ldap_bind_sW().  The
    function caches the binding handle and the error.  This function also
    turns of referrals.

Arguments:

    pServer - Server for which binding is desired
    gpCreds - Credentials
    bUseGcPort - Whether to bind to the GC port
    phLdapBinding - Returned binding, on success. Also cached.

Return Value:

    NOTE - DO NOT unbind the ldap handle.
    DWORD - Win32 error return

--*/
{
    DWORD                                    dwRet;
    LDAP *                                   hLdapBinding;
    LPWSTR                                   pszServer = NULL;

    // Return cached failure if stored
    // Success can mean never tried, or binding present
    dwRet = bUseGcPort ? pServer->dwGcLdapError : pServer->dwLdapError;
    if(dwRet != ERROR_SUCCESS){
        return dwRet;
    }

    // Return cached binding if stored
    hLdapBinding = bUseGcPort ? pServer->hGcLdapBinding : pServer->hLdapBinding;
    if (hLdapBinding != NULL) {
        *phLdapBinding = hLdapBinding;
        return ERROR_SUCCESS;
    }

    // Try to refresh the cache by contacting the server

    if(pServer->pszGuidDNSName == NULL){
        // This means that the Guid name isn't specified, use normal name.
        pszServer = pServer->pszName;
    } else {
        pszServer = pServer->pszGuidDNSName;
    }
    Assert(pszServer);

    //
    // There is no existing ldap binding of the kind we want.  so create one
    //

    hLdapBinding = ldap_initW(pszServer, bUseGcPort ? LDAP_GC_PORT : LDAP_PORT);
    if(hLdapBinding == NULL){
        dwRet = GetLastError();
        PrintMessage(SEV_ALWAYS,
                     L"[%s] LDAP connection failed with error %d,\n",
                     pServer->pszName,
                     dwRet);
        PrintMessage(SEV_ALWAYS,
                     L"%s.\n",
                     Win32ErrToString(dwRet));
        goto cleanup;
    }

    // use only A record dns name discovery
    (void)ldap_set_optionW( hLdapBinding, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);

    // Set Ldap referral option
    dwRet = ldap_set_option(hLdapBinding, LDAP_OPT_REFERRALS, LDAP_OPT_OFF);
    if(dwRet != LDAP_SUCCESS){
        dwRet = LdapMapErrorToWin32(dwRet);
        PrintMessage(SEV_ALWAYS,
                     L"[%s] LDAP setting options failed with error %d,\n",
                     pServer->pszName,
                     dwRet);
        PrintMessage(SEV_ALWAYS, L"%s.\n",
                     Win32ErrToString(dwRet));
        goto cleanup;
    }

    // Cache some RootDSE attributes we are interested in
    // Do this before binding so we can obtain info to help us diagnose
    // security problems.
    dwRet = DcDiagCacheServerRootDseAttrs( hLdapBinding, pServer );
    if (dwRet) {
        // Error already displayed
        goto cleanup;
    }

    // Perform ldap bind
    dwRet = ldap_bind_sW(hLdapBinding,
                         NULL,
                         (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                         LDAP_AUTH_SSPI);
    if(dwRet != LDAP_SUCCESS){
        dwRet = LdapMapErrorToWin32(dwRet);
        PrintMessage(SEV_ALWAYS,
                     L"[%s] LDAP bind failed with error %d,\n",
                     pServer->pszName,
                     dwRet);
        PrintMessage(SEV_ALWAYS, L"%s.\n",
                     Win32ErrToString(dwRet));
        goto cleanup;
    }

cleanup:

    if (!dwRet) {
        *phLdapBinding = hLdapBinding;
    } else {
        if (hLdapBinding) {
            ldap_unbind(hLdapBinding);
            hLdapBinding = NULL;
        }
    }
    if(bUseGcPort){
        pServer->hGcLdapBinding = hLdapBinding;
        pServer->dwGcLdapError = dwRet;
    } else {
        pServer->hLdapBinding = hLdapBinding;
        pServer->dwLdapError = dwRet;
    }

    return dwRet;
} /* DcDiagGetLdapBinding */



// ===========================================================================
// Ds RPC handle binding (DsBind, DsUnBind(), etc)
// ===========================================================================
DWORD
DcDiagGetDsBinding(
    IN   PDC_DIAG_SERVERINFO                 pServer,
    IN   SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
    OUT  HANDLE *                            phDsBinding
    )
/*++

Routine Description:

    This returns a Ds Binding from DsBindWithCredW(), this binding is cached, as
    well as the error if there is one.

Arguments:

    pServer - A pointer to the server structure you want the Ds Binding of.
    gpCreds - Credentials.
    phDsBinding - return value for the ds binding handle.

Return Value:

    Returns a standard Win32 error.

    NOTE - DO NOT unbind the ds handle.

--*/
{
    DWORD                                    dwRet;
    LPWSTR                                   pszServer = NULL;

    if(pServer->dwDsError != ERROR_SUCCESS){
        return(pServer->dwDsError);
    }
    if(pServer->pszGuidDNSName == NULL){
        pszServer = pServer->pszName;
    } else {
        pszServer = pServer->pszGuidDNSName;
    }
    Assert(pszServer != NULL);

    if(pServer->hDsBinding == NULL){
        // no exisiting binding stored, hey I have an idea ... lets create one!
        dwRet = DsBindWithCred(pszServer,
                               NULL,
                               (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                               &pServer->hDsBinding);
        if(dwRet != NO_ERROR){
            PrintMessage(SEV_ALWAYS,
                         L"[%s] DsBind() failed with error %d,\n",
                         pServer->pszName,
                         dwRet);
            PrintMessage(SEV_ALWAYS, L"%s.\n",
                         Win32ErrToString(dwRet));
            pServer->dwDsError = dwRet;
    	    return(dwRet);
    	}
    } // else we already had a binding in the pServer structure, either way
    //     we now have a binding in the pServer structure. :)
    *phDsBinding = pServer->hDsBinding;
    pServer->dwDsError = ERROR_SUCCESS;
    return(NO_ERROR);

}


// ===========================================================================
// Net Use binding (WNetAddConnection2(), WNetCancelConnection(), etc)
// ===========================================================================
DWORD
DcDiagGetNetConnection(
    IN  PDC_DIAG_SERVERINFO             pServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W *     gpCreds
    )
/*++

Routine Description:

    This routine will make sure there is a net use/unnamed pipe connection
    to the target machine pServer.

Arguments:

    pServer - Server to Add the Net connection to.
    gpCreds - the crdentials.

Return Value:

    DWORD - win 32 error.

--*/
{
    DWORD                               dwToSet = ERROR_SUCCESS;
    LPWSTR                              pszNetUseServer = NULL;
    LPWSTR                              pszNetUseUser = NULL;
    LPWSTR                              pszNetUsePassword = NULL;
    ULONG                               iTemp;

    if(pServer->dwNetUseError != ERROR_SUCCESS){
        return(pServer->dwNetUseError);
    }

    if(pServer->sNetUseBinding.pszNetUseServer != NULL){
        // Do nothing if there already is a net use connection setup.
        Assert(pServer->dwNetUseError == ERROR_SUCCESS);
    } else {
        // INIT ----------------------------------------------------------
        // Always initialize the object attributes to all zeroes.
        InitializeObjectAttributes(
            &(pServer->sNetUseBinding.ObjectAttributes),
            NULL, 0, NULL, NULL);

        // Initialize various strings for the Lsa Services and for
        //     WNetAddConnection2()
        InitLsaString( &(pServer->sNetUseBinding.sLsaServerString),
                       pServer->pszName );
        InitLsaString( &(pServer->sNetUseBinding.sLsaRightsString),
                       SE_NETWORK_LOGON_NAME );

        if(gpCreds != NULL
           && gpCreds->User != NULL
           && gpCreds->Password != NULL
           && gpCreds->Domain != NULL){
            // only need 2 for NULL, and an extra just in case.
            iTemp = wcslen(gpCreds->Domain) + wcslen(gpCreds->User) + 4;
            pszNetUseUser = LocalAlloc(LMEM_FIXED, iTemp * sizeof(WCHAR));
            if(pszNetUseUser == NULL){
                dwToSet = ERROR_NOT_ENOUGH_MEMORY;
                goto CleanUpAndExit;
            }
            wcscpy(pszNetUseUser, gpCreds->Domain);
            wcscat(pszNetUseUser, L"\\");
            wcscat(pszNetUseUser, gpCreds->User);
            pszNetUsePassword = gpCreds->Password;
        } // end if creds, else assume default creds ...
        //      pszNetUseUser = NULL; pszNetUsePassword = NULL;

        // "\\\\" + "\\ipc$"
        iTemp = wcslen(pServer->pszName) + 10;
        pszNetUseServer = LocalAlloc(LMEM_FIXED, iTemp * sizeof(WCHAR));
        if(pszNetUseServer == NULL){
            dwToSet = ERROR_NOT_ENOUGH_MEMORY;
            goto CleanUpAndExit;
        }
        wcscpy(pszNetUseServer, L"\\\\");
        wcscat(pszNetUseServer, pServer->pszName);
        wcscat(pszNetUseServer, L"\\ipc$");

        // Initialize NetResource structure for WNetAddConnection2()
        pServer->sNetUseBinding.NetResource.dwType = RESOURCETYPE_ANY;
        pServer->sNetUseBinding.NetResource.lpLocalName = NULL;
        pServer->sNetUseBinding.NetResource.lpRemoteName = pszNetUseServer;
        pServer->sNetUseBinding.NetResource.lpProvider = NULL;

        // CONNECT & QUERY -----------------------------------------------
        //net use \\brettsh-posh\ipc$ /u:brettsh-fsmo\administrator ""
        dwToSet = WNetAddConnection2(
            &(pServer->sNetUseBinding.NetResource), // connection details
            pszNetUsePassword, // points to password
            pszNetUseUser, // points to user name string
            0); // set of bit flags that specify

    CleanUpAndExit:

        if(dwToSet == ERROR_SUCCESS){
            // Setup the servers binding struct.
            pServer->sNetUseBinding.pszNetUseServer = pszNetUseServer;
            pServer->sNetUseBinding.pszNetUseUser = pszNetUseUser;
            pServer->dwNetUseError = ERROR_SUCCESS;
        } else {
            // There was an error, print it, clean up, and set error.
            switch(dwToSet){
            case ERROR_SUCCESS:
                Assert(!"This is completely impossible");
                break;
            case ERROR_SESSION_CREDENTIAL_CONFLICT:
                PrintMessage(SEV_ALWAYS,
                             L"* You must make sure there are no existing "
                             L"net use connections,\n");
                PrintMessage(SEV_ALWAYS,
                             L"  you can use \"net use /d %s\" or \"net use "
                             L"/d\n", pszNetUseServer);
                PrintMessage(SEV_ALWAYS,
                             L"  \\\\<machine-name>\\<share-name>\"\n");
                break;
            case ERROR_NOT_ENOUGH_MEMORY:
                PrintMessage(SEV_ALWAYS,
                             L"Fatal Error: Not enough memory to complete "
                             L"operation.\n");
                break;
            case ERROR_ALREADY_ASSIGNED:
                PrintMessage(SEV_ALWAYS,
                             L"Fatal Error: The network resource is already "
                             L"in use\n");
                break;
            case STATUS_ACCESS_DENIED:
            case ERROR_INVALID_PASSWORD:
            case ERROR_LOGON_FAILURE:
                // This comes from the LsaOpenPolicy or
                //    LsaEnumerateAccountsWithUserRight or
                //    from WNetAddConnection2
                PrintMessage(SEV_ALWAYS,
                             L"User credentials does not have permission to "
                             L"perform this operation.\n");
                PrintMessage(SEV_ALWAYS,
                             L"The account used for this test must have "
                             L"network logon privileges\n");
                PrintMessage(SEV_ALWAYS,
                             L"for the target machine's domain.\n");
                break;
            case STATUS_NO_MORE_ENTRIES:
                // This comes from LsaEnumerateAccountsWithUserRight
            default:
                PrintMessage(SEV_ALWAYS,
                             L"[%s] An net use or LsaPolicy operation failed "
                             L"with error %d, %s.\n",
                             pServer->pszName,
                             dwToSet,
                             Win32ErrToString(dwToSet));
                break;
            }
            // Clean up any possible allocations.
            if(pszNetUseServer != NULL)    LocalFree(pszNetUseServer);
            if(pszNetUseUser != NULL)      LocalFree(pszNetUseUser);
            pServer->dwNetUseError = dwToSet;
        }
    }

    return(pServer->dwNetUseError);
}


VOID
DcDiagTearDownNetConnection(
    IN  PDC_DIAG_SERVERINFO             pServer
    )
/*++

Routine Description:

    This will tear down the Net Connection added by DcDiagGetNetConnection()

Arguments:

    pServer - The target server.

Return Value:

    DWORD - win 32 error.

--*/
{
    if(pServer->sNetUseBinding.pszNetUseServer != NULL){
        WNetCancelConnection2(pServer->sNetUseBinding.pszNetUseServer,
                              0, FALSE);
        LocalFree(pServer->sNetUseBinding.pszNetUseServer);
        LocalFree(pServer->sNetUseBinding.pszNetUseUser);
        pServer->sNetUseBinding.pszNetUseServer = NULL;
        pServer->sNetUseBinding.pszNetUseUser = NULL;
    } else {
        Assert(!"Bad Programmer, calling TearDown on a closed connection\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\common\print.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    print.c

ABSTRACT:

DETAILS:

CREATED:

    1999 May 6  JeffParh
        Lifted from netdiag\results.c.

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include "dcdiag.h"
#include "debug.h"

static WCHAR s_szBuffer[4096];
static WCHAR s_szFormat[4096];
static WCHAR s_szSpaces[] = L"                                                                                               ";

#ifndef DimensionOf
#define DimensionOf(x) (sizeof(x)/sizeof((x)[0]))
#endif

void
PrintMessage(
    IN  ULONG   ulSev,
    IN  LPCWSTR pszFormat,
    IN  ...
    )

/*++

Routine Description:

Print a message with a printf-style format 

Arguments:

    ulSev - 
    pszFormat - 
    IN - 

Return Value:

--*/

{
    UINT nBuf;
    va_list args;
    
    if (ulSev > gMainInfo.ulSevToPrint) {
        return;
    }

    va_start(args, pszFormat);
    
    nBuf = vswprintf(s_szBuffer, pszFormat, args);
    Assert(nBuf < DimensionOf(s_szBuffer));
    
    va_end(args);
    
    PrintMessageSz(ulSev, s_szBuffer);
} /* PrintMessage */

void
PrintMessageID(
    IN  ULONG   ulSev,
    IN  ULONG   uMessageID,
    IN  ...
    )

/*++

Routine Description:

Print a message, where a printf-style format string comes from a resource file

Arguments:

    ulSev - 
    uMessageID - 
    IN - 

Return Value:

--*/

{
    UINT nBuf;
    va_list args;
    
    if (ulSev > gMainInfo.ulSevToPrint) {
        return;
    }

    va_start(args, uMessageID);
    
    LoadStringW(NULL, uMessageID, s_szFormat, DimensionOf(s_szFormat));
    
    nBuf = vswprintf(s_szBuffer, s_szFormat, args);
    Assert(nBuf < DimensionOf(s_szBuffer));
    
    va_end(args);
    
    PrintMessageSz(ulSev, s_szBuffer);
} /* PrintMessageID */

void
PrintMessageMultiLine(
    IN  ULONG    ulSev,
    IN  LPWSTR   pszMessage,
    IN  BOOL     bTrailingLineReturn
    )
/*++

Routine Description:

Take a multi-line buffer such as
line\nline\nline\n\0
and call PrintMessageSz on each line

Arguments:

    ulSev - 
    pszMessage - 

Return Value:

--*/

{
    LPWSTR start, end;
    WCHAR wchSave;

    start = end = pszMessage;
    while (1) {
        while ( (*end != L'\n') && (*end != L'\0') ) {
            end++;
        }

        if (*end == L'\0') {
            // Line ends prematurely, give it a nl
            if(bTrailingLineReturn){
                *end++ = L'\n';
                *end = L'\0';
            }
            PrintMessageSz(ulSev, start);
            break;
        }

        // Line has newline at end
        end++;
        if (*end == L'\0') {
            // Is the last line
            PrintMessageSz(ulSev, start);
            break;
        }

        // Next line follows
        // Simulate line termination temporarily
        wchSave = *end;
        *end = L'\0';
        PrintMessageSz(ulSev, start);
        *end = wchSave;

        start = end;
    }
} /* PrintMessageMultiLine */

void
formatMsgHelp(
    IN  ULONG   ulSev,
    IN  DWORD   dwWidth,
    IN  DWORD   dwMessageCode,
    IN  va_list *vaArgList
    )

/*++

Routine Description:

Print a message where the format comes from a message file. The message in the
message file does not use printf-style formatting. Use %1, %2, etc for each
argument. Use %<arg>!printf-format! for non string inserts.

Note that this routine also forces each line to be the current indention width.
Also, each line is printed at the right indentation.

Arguments:

    ulSev - 
    dwWidth - 
    dwMessageCode - 
    IN - 

Return Value:

--*/

{
    UINT nBuf;
    
    if (ulSev > gMainInfo.ulSevToPrint) {
        return;
    }

    // Format message will store a multi-line message in the buffer
    nBuf = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE | dwWidth,
        0,
        dwMessageCode,
        0,
        s_szBuffer,
        DimensionOf(s_szBuffer),
        vaArgList );
    if (nBuf == 0) {
        nBuf = wsprintf( s_szBuffer, L"Message 0x%x not found.\n",
                         dwMessageCode );
        Assert(!"There is a message constant being used in the code"
               "that isn't in the message file dcdiag\\common\\msg.mc"
               "Take a stack trace and send to owner of dcdiag.");
    }
    Assert(nBuf < DimensionOf(s_szBuffer));
} /* PrintMsgHelp */

void
PrintMsg(
    IN  ULONG   ulSev,
    IN  DWORD   dwMessageCode,
    IN  ...
    )

/*++

Routine Description:

Wrapper around PrintMsgHelp with width restrictions.
This is the usual routine to use.

Arguments:

    ulSev - 
    dwMessageCode - 
    IN - 

Return Value:

--*/

{
    UINT nBuf;
    DWORD cNumSpaces, width;
    va_list args;
    
    if (ulSev > gMainInfo.ulSevToPrint) {
        return;
    }

    cNumSpaces = gMainInfo.iCurrIndent * 3;
    width = gMainInfo.dwScreenWidth - cNumSpaces;

    va_start(args, dwMessageCode);

    formatMsgHelp( ulSev, width, dwMessageCode, &args );

    va_end(args);
    
    PrintMessageMultiLine(ulSev, s_szBuffer, TRUE);
} /* PrintMsg */

void
PrintMsg0(
    IN  ULONG   ulSev,
    IN  DWORD   dwMessageCode,
    IN  ...
    )

/*++

Routine Description:

Wrapper around PrintMsgHelp with no width restrictions nor
indentation.

Arguments:

    ulSev - 
    dwMessageCode - 
    IN - 

Return Value:

--*/

{
    UINT nBuf;
    int iSaveIndent;
    va_list args;
    
    if (ulSev > gMainInfo.ulSevToPrint) {
        return;
    }

    va_start(args, dwMessageCode);

    formatMsgHelp( ulSev, 0, dwMessageCode, &args );

    va_end(args);
    
    // Suppress indentation
    iSaveIndent = gMainInfo.iCurrIndent;
    gMainInfo.iCurrIndent = 0;

    PrintMessageMultiLine(ulSev, s_szBuffer, FALSE);

    // Restore indentation
    gMainInfo.iCurrIndent = iSaveIndent;

} /* PrintMsg0 */

void
PrintMessageSz(
    IN  ULONG   ulSev,
    IN  LPCTSTR pszMessage
    )

/*++

Routine Description:

Print a single indented line from a buffer to the output stream

Arguments:

    ulSev - 
    pszMessage - 

Return Value:

--*/

{
    DWORD cNumSpaces;
    DWORD iSpace;
    
    if (ulSev > gMainInfo.ulSevToPrint) {
        return;
    }

    // Include indentation.
    cNumSpaces = gMainInfo.iCurrIndent * 3;
    Assert(cNumSpaces < DimensionOf(s_szSpaces));

    iSpace = DimensionOf(s_szSpaces) - cNumSpaces - 1;

    if (stdout == gMainInfo.streamOut) {
        wprintf(L"%s%s", &s_szSpaces[iSpace], pszMessage);
        fflush(stdout);
    }
    else {
        fwprintf(gMainInfo.streamOut, 
                 L"%s%s", &s_szSpaces[iSpace], pszMessage);
    }
} /* PrintMessageSz */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\common\events.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    common\events.c

ABSTRACT:

    This gives a library of functions that can be used to quickly construct a
    new test on an event log.  First implemented for the File Replication
    Service event log, but hopefully soon there will be a Directory Service
    and System event log tests.

DETAILS:

CREATED:

    02 Sept 1999 Brett Shirley (BrettSh)

NOTES:

    An example of how to use this API is in frs/frsevents.c

--*/

#include <ntdspch.h>
#include <netevent.h>

#include "dcdiag.h"
#include "utils.h"

HINSTANCE
GetHLib(
    LPWSTR                          pszEventLog,
    LPWSTR                          pszSource
    )
/*++

Routine Description:

    This routine will return a hLib loaded DLL for event log message retrieving
    purposes.

Arguments:

    pszEventLog - This is the event log to look at, such as "System", or "File
        Replication Service"
    pszSource - This is the Source field from the EVENTLOGRECORD structure,
        which is immediately after the main data.

Return Value:

    hLib - Loaded DLL, or NULL if there is an error.  If there is an error
    use GetLastError() to retrieve the error.

--*/
{
    WCHAR                           pszTemp[MAX_PATH];
    DWORD                           dwRet;
    HKEY                            hk = NULL;
    WCHAR                           pszMsgDll[MAX_PATH];
    HINSTANCE                       hLib;
    DWORD                           dwcbData;
    DWORD                           dwType;
    DWORD                           cchDest;

    // From the event log source name, we know the name of the registry
    // key to look under for the name of the message DLL that contains
    // the messages we need to extract with FormatMessage. So first get
    // the event log source name... 
    wcscpy(pszTemp, L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\");
    wcscat(pszTemp, pszEventLog);
    wcscat(pszTemp, L"\\");
    wcscat(pszTemp, pszSource);

    // Now open this key and get the EventMessageFile value, which is
    // the name of the message DLL. 
    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, pszTemp, &hk);
    if(dwRet != ERROR_SUCCESS){
        SetLastError(dwRet);
        return(NULL);
    }
    dwcbData = MAX_PATH;
    dwRet = RegQueryValueEx(hk,    // handle of key to query        
                            L"EventMessageFile",   // value name            
                            NULL,                 // must be NULL          
                            &dwType,              // address of type value 
                            (LPBYTE) pszTemp,     // address of value data 
                            &dwcbData);           // length of value data  
    if(dwRet != ERROR_SUCCESS){
        SetLastError(dwRet);
        return(NULL);
    }

    // Expand environment variable strings in the message DLL path name,
    // in case any are there. 
    cchDest = ExpandEnvironmentStrings(pszTemp, pszMsgDll, MAX_PATH);
    if(cchDest == 0 || cchDest >= MAX_PATH){
        SetLastError(-1);
        return(NULL);
    }
    
    // Now we've got the message DLL name, load the DLL.
    hLib = LoadLibraryEx(pszMsgDll, NULL, DONT_RESOLVE_DLL_REFERENCES);
    
    RegCloseKey(hk);
    return(hLib);
}

ULONG
EventExceptionHandler(
    IN const  EXCEPTION_POINTERS * prgExInfo,
    OUT PDWORD                     pdwWin32Err
    )
{
   if(pdwWin32Err != NULL) {
      *pdwWin32Err = prgExInfo->ExceptionRecord->ExceptionCode;
   }
   return EXCEPTION_EXECUTE_HANDLER;
}

#define MAX_INSERT_STRS           16
#define MAX_MSG_LENGTH            1024

DWORD
GetEventString(
    LPWSTR                          pszEventLog,
    PEVENTLOGRECORD                 pEvent,
    LPWSTR *                        ppszMsg
    )
/*++

Routine Description:

    This function will do it's best effort to retrieve and format the string
    associated with this event ID.

Arguments:

    pszEventLog - The name of the event log, like "System", or "File
        Replication System".
    pEvent - A pointer to the event that we wish to retrieve the string of.
    ppszMsg - This is the variable to return the string in.  If there is an
        error then this will be NULL.  Use LocalFree() to free.

Return Value:

    DWORD - win 32 error.

Code.Improvement:
    It would be good to store the hLib's for the future events, it is really
    bad to LoadLibrary() and FreeLibrary() every time.  This would require
    some sort of consistent context.

--*/
{
    LPWSTR                          pszMsgBuf = NULL;
    LPWSTR                          ppszInsertStrs[MAX_INSERT_STRS];
    HINSTANCE                       hLib = NULL;
    LPWSTR                          pszTemp;
    INT                             i;
    DWORD                           dwCount = 0, dwErr = ERROR_SUCCESS;

    *ppszMsg = NULL;

    __try { // defend against bad event log records

       hLib = GetHLib(pszEventLog,
                      (LPWSTR) ((LPBYTE) pEvent + sizeof(EVENTLOGRECORD)));
       if(hLib == NULL){
           return(GetLastError());
       }

       if(pEvent->NumStrings >= MAX_INSERT_STRS){
           Assert(!"That is ALOT of insert strings, check this out\n");
           return(-1);
       }

       pszTemp = (WCHAR *) ((LPBYTE) pEvent + pEvent->StringOffset);

       for (i = 0; i < pEvent->NumStrings && i < MAX_INSERT_STRS; i++){
           ppszInsertStrs[i] = pszTemp;
           pszTemp += wcslen(pszTemp) + 1;     // point to next string 
       }

       dwCount = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                               | FORMAT_MESSAGE_FROM_HMODULE 
                               | FORMAT_MESSAGE_ARGUMENT_ARRAY
                               | 50, //Code.Improvement, remove this when we move
                               // to the new PrintMsg() functions.
                               hLib,
                               pEvent->EventID,
                               MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                               (LPWSTR) &pszMsgBuf,
                               MAX_MSG_LENGTH,
                               (va_list *) ppszInsertStrs);
       if(dwCount == 0){
           Assert(GetLastError() != ERROR_SUCCESS);
           return(GetLastError());
       }

       *ppszMsg = pszMsgBuf;
    }
    __except (EventExceptionHandler(GetExceptionInformation(), &dwErr)) {

        ASSERT(FALSE && "Bad event record!");
        PrintMsg(SEV_ALWAYS, DCDIAG_ERR_BAD_EVENT_REC, dwErr);
        PrintMessage(SEV_ALWAYS, L"\n");
    }

    if (hLib) FreeLibrary(hLib);

    return(dwErr);
}

void 
PrintTimeGenerated(
    PEVENTLOGRECORD              pEvent
    )
/*++

Routine Description:

    This takes an event and simply prints out the time it was generated.

Arguments:

    pEvent - The event to print the time of.

Return Value:

    DWORD - win 32 error.

--*/
{
    FILETIME FileTime, LocalFileTime;
    SYSTEMTIME SysTime;
    __int64 lgTemp;
    __int64 SecsTo1970 = 116444736000000000;

    lgTemp = Int32x32To64(pEvent->TimeGenerated,10000000) + SecsTo1970;

    FileTime.dwLowDateTime = (DWORD) lgTemp;
    FileTime.dwHighDateTime = (DWORD)(lgTemp >> 32);

    FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
    FileTimeToSystemTime(&LocalFileTime, &SysTime);

    PrintMessage(SEV_ALWAYS, 
                 L"Time Generated: %02d/%02d/%02d   %02d:%02d:%02d\n",
                 SysTime.wMonth,
                 SysTime.wDay,
                 SysTime.wYear,
                 SysTime.wHour,
                 SysTime.wMinute,
                 SysTime.wSecond);

}

VOID
GenericPrintEvent(
    LPWSTR                          pszEventLog,
    PEVENTLOGRECORD                 pEvent,
    BOOL                            fVerbose
    )
/*++

Routine Description:

    This formats and prints out in a very basic style an event.

Arguments:

    pszEventLog - The event log that pEvent came from, like "System", or
        "File Replication Service"
    pEvent - The event to print.
    fVerbose - Display full text of the message, or only first line

--*/
{
    DWORD                           dwRet;
    LPWSTR                          pszMsgBuf = NULL;
    LPWSTR                          pszType;

    Assert(pEvent);

    switch(pEvent->EventType){
    case EVENTLOG_ERROR_TYPE:
        pszType = L"Error";
        break;
    case EVENTLOG_WARNING_TYPE:
        pszType = L"Warning";
        break;
    case EVENTLOG_INFORMATION_TYPE:
        pszType = L"Information";
        break;
    case EVENTLOG_AUDIT_SUCCESS:
        pszType = L"Audit Success";
        break;
    case EVENTLOG_AUDIT_FAILURE:
        pszType = L"Audit Failure";
        break;
    default:
        pszType = L"Unknown";
    }

    PrintMessage(SEV_ALWAYS, L"An %s Event occured.  EventID: 0x%08X\n",
                 pszType, pEvent->EventID);

    PrintIndentAdj(1);
    PrintTimeGenerated(pEvent);

    dwRet = GetEventString(pszEventLog, pEvent, &pszMsgBuf);
    if(dwRet == ERROR_SUCCESS){
        // Truncate to single line if requested
        if (!fVerbose) {
            LPWSTR pszEnd = wcschr( pszMsgBuf, L'\n' );
            if (pszEnd) {
                *pszEnd = L'\0';
            }
        }
        PrintMessage(SEV_ALWAYS, L"Event String: %s\n", pszMsgBuf);
    } else {
        PrintMessage(SEV_ALWAYS, L"(Event String could not be retrieved)\n");
    }
    LocalFree(pszMsgBuf);   
    PrintIndentAdj(-1);
}



BOOL
EventIsInList(
    DWORD                           dwTarget,
    PDWORD                          paEventsList
    )
/*++

Routine Description:

    A helper routine for PrintSelectEvents, it deterines whether this list has
    the event we want.

Arguments:
 
    dwTarget - The DWORD to search for.
    paEventsList - The list of DWORDs to check

Return Value:

    TRUE if the array paEventsList has the event dwTarget, FALSE otherwise, or
    if teh paEventsList is NULL.

--*/
{
    if(paEventsList == NULL){
        return(FALSE);
    }
    while(*paEventsList != 0){
        if(dwTarget == *paEventsList){
            return(TRUE);
        }
        paEventsList++;
    }
    return(FALSE);
}

DWORD
PrintSelectEvents(
    PDC_DIAG_SERVERINFO             pServer,
    SEC_WINNT_AUTH_IDENTITY_W *     pCreds,
    LPWSTR                          pwszEventLog,
    DWORD                           dwPrintAllEventsOfType,
    PDWORD                          paSelectEvents,
    PDWORD                          paBeginningEvents,
    DWORD                           dwBeginTime,
    VOID (__stdcall *               pfnPrintEventHandler) (PVOID, PEVENTLOGRECORD),
    VOID (__stdcall *               pfnBeginEventHandler) (PVOID, PEVENTLOGRECORD),
    PVOID                           pvContext
   )
/*++

Routine Description:

Arguments:

    pServer - Server with the event log to query,
        EX: "\\brettsh-posh.brettsh-spice.nttest.microsoft.com"
    pCreds - Current user credentials
    pwszEventLog - The name of the event log, EX: "File Replication Server", 
        "Directory Service", "System", "Application", "Security"
    dwPrintAllEventsOfType - The type of events to print all of, valid values
        as of NT 5.0 are: EVENTLOG_INFORMATION_TYPE | EVENTLOG_WARNING_TYPE |
        EVENTLOG_ERROR_TYPE | EVENTLOG_AUDIT_SUCCESS | EVENTLOG_AUDIT_FAILURE
    paSelectEvents - And events that match this 0 terminated list of event IDs,
        will also be printed.  If NULL, then no events will be matched.
    paBeginngingEvents - The routine will only print events after the last one 
        of any of these events that it encounters.  If NULL, then it will go
        all the way to the beginning of the log.
    dwBeginTime - If present, a time_t indicating the earliest record we should
        include in the search.  Once we pass this point and find records earlier
        in the log, we stop the search
    pfnPrintEventHandler - Is the function to be called if an event is to be 
        printed.  Note this function if it didn't know what to make of the 
        event could just call this file's GenericPrintEvent().
    pfnBeginEventHandler - This function will be called when the an beginning
        event from paBeginningEvents is found, so the test can handle the 
        situation.  If a beginning event is never found and the beginning of
        the log is reached this function is called with NULL as the event.
    pvContext - Caller supplied value passed to callback functions

Return Value:

    Win 32 Error, in opening, reading, etc the log.

Notes:

    EX:
        DWORD                paSelectEvents [] = { EVENT_FRS_SYSVOL_NOT_READY,
                                             VENT_FRS_SYSVOL_NOT_READY_PRIMARY,
                                             0 };
        DWORD                paBegin [] = { EVENT_FRS_SYSVOL_READY,
                                            0 };
        PrintSelectEvents(L"\\brettsh-posh.brettsh-spice.nttest.microsoft.com",
                          L"File Replication Service",
                          EVENTLOG_ERROR_TYPE | EVENTLOG_AUDIT_SUCCESS, 
                          paSelectEvents, 
                          paBegin,
                          0, NULL, NULL);
    This will print all errors events and audit failure events, and the events
    EVENT_FRS_SYSVOL_NOT_READY, EVENT_FRS_SYSVOL_NOT_READY_PRIMARY (which 
    happen to be warning type events and so would not otherwise be printed), 
    that are logged after the last EVENT_FRS_SYSVOL_READY event in the "File
    Replication Log" on server brettsh-posh.  Note: that one should pass 
    NULL as paBeginningEvents if one wants to go all the way back to the 
    beginning of the log.

--*/
{
    // Generic opening/return_code event log variables.
    DWORD                           dwNetRet = ERROR_SUCCESS;
    LPWSTR                          pwszUNCServerName = NULL;
    INT                             iTemp;
    HANDLE                          hFrsEventlog = NULL;
    DWORD                           dwErr = ERROR_SUCCESS;
    BOOL                            bSuccess;
    // Reading the event log variables.
    DWORD                           cBufSize = 512;
    DWORD                           cBytesRead = 0;
    DWORD                           cBiggerBuffer = 0;
    PEVENTLOGRECORD                 pBuffer = NULL;
    PEVENTLOGRECORD                 pEvent = NULL;
    DWORD                           cNumRecords = 0;
    // Copying out selected events.
    PEVENTLOGRECORD *               paEventsToPrint = NULL;
    DWORD                           cEventsToPrint = 0;
    // Other misc variables
    INT                             i; // This must be an INT, not a ULONG

    __try{

        // Open Net Use Connection if needed ---------------------------------
        dwNetRet = DcDiagGetNetConnection(pServer, pCreds);
        if(dwNetRet != ERROR_SUCCESS){
            dwErr = dwNetRet;
            __leave; // Don't need print error, cause DcDiagGetNetConn... does.
        }
        
        // Setup Server Name -------------------------------------------------
        iTemp = wcslen(pServer->pszName) + 4;
        pwszUNCServerName = LocalAlloc(LMEM_FIXED, iTemp * sizeof(WCHAR));
        if(pwszUNCServerName == NULL){
            dwErr = GetLastError();
            PrintMessage(SEV_ALWAYS, L"FATAL ERROR: Out of Memory\n");
            __leave;
        }
        wcscpy(pwszUNCServerName, L"\\\\");
        wcscat(pwszUNCServerName, pServer->pszName);

        // Open Event Log ----------------------------------------------------
        hFrsEventlog = OpenEventLog(pwszUNCServerName,
                                    pwszEventLog);
        if(hFrsEventlog == NULL){
            dwErr = GetLastError();
            PrintMessage(SEV_ALWAYS, 
                         L"Error %d opening FRS eventlog %s:%s:\n %s\n",
                         dwErr, pwszUNCServerName, pwszEventLog,
                         Win32ErrToString(dwErr));
            __leave;
        }
        
        // Init Events To Print array ----------------------------------------
        bSuccess = GetNumberOfEventLogRecords(hFrsEventlog, &cNumRecords);
        if(bSuccess){
            // Allocate an array to hold the maximum numer of possible events.
            paEventsToPrint = LocalAlloc(LMEM_FIXED, 
                                      sizeof(PEVENTLOGRECORD) * cNumRecords);
            // Code.Improvement, it would be good to make a dynamic array that
            //   grew as needed, because the total number of events in the
            //   log record could be quite large.
            if(paEventsToPrint == NULL){
                dwErr = GetLastError();
                PrintMessage(SEV_ALWAYS, L"FATAL ERROR: Out of Memory\n");
                __leave;
            }
       } else {
            dwErr = GetLastError();
            PrintMessage(SEV_ALWAYS, L"Error %d accessing FRS eventlog: %s\n", 
                         dwErr, Win32ErrToString(dwErr));
            __leave; 
        }
        
        // Start Reading Events ----------------------------------------------
    IncreaseBufferAndRetry:
        
        // Allocate buffer
        pBuffer = LocalAlloc(LMEM_FIXED, cBufSize);
        pEvent = pBuffer;
        
        while(bSuccess = ReadEventLog(hFrsEventlog,
                                      EVENTLOG_SEQUENTIAL_READ | EVENTLOG_BACKWARDS_READ,
                                      0,
                                      pBuffer,
                                      cBufSize,
                                      &cBytesRead,
                                      &cBiggerBuffer)){
            while(cBytesRead > 0){
                
                if (EventIsInList(pEvent->EventID, paBeginningEvents)) {
                    // Run the beginning function, bail and print the 
                    //  other events.
                    dwErr = ERROR_SUCCESS;
                    if(pfnBeginEventHandler != NULL){
                        pfnBeginEventHandler(pvContext, pEvent);
                    }
                    __leave;
                }
                // Exceeded time limit, stop search
                if (dwBeginTime && (pEvent->TimeGenerated < dwBeginTime)) {
                    if(pfnBeginEventHandler != NULL){
                        pfnBeginEventHandler(pvContext, NULL);
                    }
                    dwErr = ERROR_SUCCESS;
                    __leave;
                }

                // Detemine if we should print this event.
                if((dwPrintAllEventsOfType & pEvent->EventType)
                   || EventIsInList(pEvent->EventID, paSelectEvents)){
                    
                    // Copy events to print events array
                    paEventsToPrint[cEventsToPrint] = LocalAlloc(LMEM_FIXED,
                                                             pEvent->Length);
                    if(paEventsToPrint[cEventsToPrint] == NULL){
                        PrintMessage(SEV_ALWAYS, 
                                     L"FATAL ERROR: Out of Memory\n");
                        dwErr = GetLastError();
                        Assert(dwErr != ERROR_SUCCESS);
                        __leave;
                    }
                    memcpy(paEventsToPrint[cEventsToPrint],
                           pEvent,
                           pEvent->Length);
                    cEventsToPrint++;
                    
                }
                
                // Get next already read event.
                cBytesRead -= pEvent->Length;
                pEvent = (EVENTLOGRECORD *) ((LPBYTE) pEvent + pEvent->Length);
            }
            
            // Get another batch of events.
            pEvent = pBuffer;
        }
        
        // Determine if the error was an OK/recoverable error.
        dwErr = GetLastError();
        if (dwErr == ERROR_HANDLE_EOF){
            // This is a legitimate exit path, but we didn't find a 
            //  beginning event, so call the BeginningEventHandler to 
            //  tell the user so.
            if(pfnBeginEventHandler != NULL){
                pfnBeginEventHandler(pvContext, NULL);
            }
            dwErr = ERROR_SUCCESS;
        } else if(dwErr == ERROR_INSUFFICIENT_BUFFER){
            Assert(cBiggerBuffer > cBufSize);
            cBufSize = cBiggerBuffer;
            cBiggerBuffer = 0;
            LocalFree(pBuffer);
            pBuffer = NULL;
            goto IncreaseBufferAndRetry;
        } else {
            PrintMessage(SEV_ALWAYS, 
                         L"An unknown error occured trying to read the event "
                         L"log:\n");
            PrintMessage(SEV_ALWAYS,
                         L"Error(%d):%s\n", dwErr, Win32ErrToString(dwErr));
            __leave;
        }

    } __finally {
        // Clean up the temporary variables for reading the log.
        if(hFrsEventlog) {               CloseEventLog(hFrsEventlog); }
        if(pwszUNCServerName) {          LocalFree(pwszUNCServerName); }
        if(pBuffer) {                    LocalFree(pBuffer); }
    }

    if(dwErr == ERROR_SUCCESS){
        // Count backwards through the paEventsToPrint array, to order them 
        //  in forward chronological order.
        Assert(paEventsToPrint);
        for(i = cEventsToPrint-1; i >= 0; i--){
            Assert(paEventsToPrint[i]);
            if(pfnPrintEventHandler != NULL){
                pfnPrintEventHandler(pvContext, paEventsToPrint[i]);
            } else {
                GenericPrintEvent(pwszEventLog, paEventsToPrint[i], TRUE);
            }
        }
    }

    // Final Cleanup:
    // Free the events printed list.
    if(paEventsToPrint){
        for(i = 0; i < (INT) cEventsToPrint; i++){
            if(paEventsToPrint[i]){
                LocalFree(paEventsToPrint[i]);
            } else {
                Assert(!"cEventsToPrint doesn't agree with number of pointers"
                       " in the array paEventsToPrint[]");
            }
        }
        if(paEventsToPrint) {
            LocalFree(paEventsToPrint);
        }
    }


    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\common\list.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    list.c

ABSTRACT:

    Generic List function.

DETAILS:

CREATED:

    28 Jun 99   Brett Shirley (brettsh)

REVISION HISTORY:

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <dsutil.h>
#include <dsconfig.h>


#include "dcdiag.h"
#include "repl.h"


// Yeah Yeah, don't even talk to me about this, it is horrible I know.
PDC_DIAG_DSINFO  gpDsInfoHackForQSort = NULL;


DWORD
IHT_PrintListError(
    DWORD                               dwErr
    )
/*++

Description:

    This prints out an error from a "pure" list function (described below in 
    IHT_GetServerList()).

Parameters:
    dwErr is optional, if it is ERROR_SUCCESS, then we use a memory error.

Return Value:
    A win32 err, the value of the error we used.
  
  --*/
{
    if(dwErr == ERROR_SUCCESS){
        dwErr = GetLastError();
        if(dwErr == ERROR_SUCCESS){
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    PrintMsg(SEV_ALWAYS, DCDIAG_UTIL_LIST_GENERIC_LIST_ERROR,
             Win32ErrToString(dwErr));
    return(dwErr);
}

VOID
IHT_PrintServerList(
    PDC_DIAG_DSINFO		        pDsInfo,
    PULONG                              piServers
    )
/*++

Description:

    Prints the server list.

Parameters:

    pDsInfo,
    piServers - a list of servers.
  
  --*/
{
    ULONG                               ii;
    
    PrintIndentAdj(1);
    if(piServers == NULL){
        PrintMsg(SEV_VERBOSE, DCDIAG_UTIL_LIST_PRINTING_NULL_LIST);
        return;
    }
    for(ii = 0; piServers[ii] != NO_SERVER; ii++){
        PrintMsg(SEV_ALWAYS, DCDIAG_UTIL_LIST_SERVER,
                     pDsInfo->pServers[piServers[ii]].pszName);
    }
    if(ii == 0){
        PrintMsg(SEV_ALWAYS, DCDIAG_UTIL_LIST_SERVER_LIST_EMPTY);
    }
    PrintIndentAdj(-1);

}

PULONG
IHT_GetServerList(
    PDC_DIAG_DSINFO		        pDsInfo
    )
/*++

Description:

    This function gets a list of indexs into the pDsInfo->pServers array of all
    the servers in the enterprise.

Parameters:

    pDsInfo.

Return Value:
  
    This is a "pure" list function, in that it returns NULL, or a memory 
    address.  If it returns NULL, then GetLastError() should have the error, 
    even if another pure list function was called in the mean time.  If not it
    is almost certainly a memory error, as this is the only thing that can go
    wrong in pure list functions.  The pure list functions return a NO_SERVER
    terminated list.  The function always returns the pointer to the list.  
    Note most of the list functions modify one of the lists they are passed 
    and passes back that pointer, so if you want the original contents, make
    a copy with IHT_CopyServerList().

  --*/
{
    ULONG                               ii;
    PULONG                              piServers;

    piServers = LocalAlloc(LMEM_FIXED, 
                           sizeof(ULONG) * (pDsInfo->ulNumServers + 1));
    if(piServers == NULL){
        return(NULL);
    }

    for(ii = 0; ii < pDsInfo->ulNumServers; ii++){
        piServers[ii] = ii;
    }
    piServers[ii] = NO_SERVER;

    return(piServers);
}

PULONG
IHT_GetEmptyServerList(
    PDC_DIAG_DSINFO		        pDsInfo
    )
/*++

Description:

    This function returns a list large enough to fit the entire enterprise 
    worth of servers, and has a NO_SERVER as the first element, indicating it
    is empty.

Parameters:

    pDsInfo.

Return Value:
  
    Pure list function, see IHT_GetServerList() above.

  --*/
{
    ULONG                               ii;
    PULONG                              piServers;

    piServers = LocalAlloc(LMEM_FIXED, 
                           sizeof(ULONG) * (pDsInfo->ulNumServers + 1));
    if(piServers == NULL){
        return(NULL);
    }
    
    piServers[0] = NO_SERVER;

    return(piServers);
}

BOOL
IHT_ServerIsInServerList(
    PULONG                              piServers,
    ULONG                               iTarget
    )
/*++

Description:

    This is a predicate to determine if the server represented by iTarget is 
    contained in the server list piServers.

Parameters:

    pDsInfo.
    iTarget ... the server to look for.

Return Value:
  
    TRUE if iTarget is in piServers, FALSE otherwise.

  --*/
{
    ULONG                               ii;

    if(iTarget == NO_SERVER){
        return(FALSE);
    }

    for(ii = 0; piServers[ii] != NO_SERVER; ii++){
        if(piServers[ii] == iTarget){
            return(TRUE);
        }
    }
    return(FALSE);
}

PULONG
IHT_AddToServerList(
    PULONG                             piServers,
    ULONG                              iTarget
    )
/*++

Description:

    This function returns takes an existing list and if iTarget isn't already
    in that list, it adds iTarget to the end of the list, and NO_SERVER terminates it.

Parameters:

    pDsInfo.
    iTarget ... server to add to list.

Return Value:
  
    Pure list function, see IHT_GetServerList() above.

  --*/
{
    ULONG                              ii;

    if(piServers == NULL || iTarget == NO_SERVER){
        return NULL;
    }

    for(ii = 0; piServers[ii] != NO_SERVER; ii++){
        if(piServers[ii] == iTarget){
            // shoot already is in list, don't add it again.
            return(piServers);
        }
    }
    
    piServers[ii] = iTarget;
    ii++;
    piServers[ii] = NO_SERVER;
    return(piServers);    
}

PULONG
IHT_TrimServerListBySite(
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               iSite,
    PULONG                              piServers
    )
/*++

Description:

    This takes a list, and removes any servers that are not in iSite.

Parameters:

    pDsInfo.
    iSite .... site to check for servers are in.
    piServers .... list of servers to trim.

Return Value:
  
    Pure list function, see IHT_GetServerList() above.

  --*/
{
    ULONG                               ii, iiTarget;
    PULONG                              piTemp;

    piTemp = LocalAlloc(LMEM_FIXED, 
                        sizeof(ULONG) * (pDsInfo->ulNumServers + 1));
    if(piServers == NULL || piTemp == NULL){
        return NULL;
    }

    iiTarget = 0;
    for(ii = 0; piServers[ii] != NO_SERVER; ii++){
        if(pDsInfo->pServers[piServers[ii]].iSite == iSite){
            piTemp[iiTarget] = piServers[ii];
            iiTarget++;
        }
    }

    piTemp[iiTarget] = NO_SERVER;
    memcpy(piServers, piTemp, sizeof(ULONG) * (iiTarget+1));
    LocalFree(piTemp);

    return(piServers);
}

PULONG
IHT_TrimServerListByNC(
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               iNC,
    BOOL                                bDoMasters,
    BOOL                                bDoPartials,
    PULONG                              piServers
    )
/*++

Description:

    Similar to TrimServerListByNC, except this removes all servers
    the given NC.

Parameters:

    pDsInfo.
    iNC .... NC to check that the servers have.
    bDoMasters ... to check for master NCs.
    bDoPartials ... to check for partial NCs.
    piServers .... list of servers to trim.

Return Value:
  
    Pure list function, see IHT_GetServerList() above.

  --*/
{
    ULONG                               ii, iiTarget;
    PULONG                              piTemp;

    piTemp = LocalAlloc(LMEM_FIXED, 
                        sizeof(ULONG) * (pDsInfo->ulNumServers + 1));
    if(piServers == NULL || piTemp == NULL){
        return(NULL);
    }

    iiTarget = 0;
    for(ii = 0; piServers[ii] != NO_SERVER; ii++){
        if(DcDiagHasNC(pDsInfo->pNCs[iNC].pszDn, 
                          &(pDsInfo->pServers[piServers[ii]]), 
                          bDoMasters, bDoPartials)){
            piTemp[iiTarget] = piServers[ii];
            iiTarget++;
        }
    }
    piTemp[iiTarget] = NO_SERVER;
    memcpy(piServers, piTemp, sizeof(ULONG) * (iiTarget+1));
    LocalFree(piTemp);

    return(piServers);
}


PULONG
IHT_AndServerLists(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN OUT  PULONG                      piSrc1,
    IN      PULONG                      piSrc2
    )
/*++

Description:

    This function takes two lists piSrc1 and piSrc2 and ANDs them 
    together and puts them in piSrc1.  What I mean by AND, is that
    if a server index is in piSrc1 AND piSrc2, then it gets to 
    remain in piSrc1
    // IHT_AndServerLists(x, y) -> x = x & y;

Parameters:

    pDsInfo.
    piSrc1 ... The source and destinations list
    piSrc2 ... The second source list.

Return Value:
  
    Pure list function, see IHT_GetServerList() above.

  --*/
{

    ULONG                               iiSrc1, iiSrc2, cDstSize;
    PULONG                              piDst;
    
    piDst = IHT_GetEmptyServerList(pDsInfo);

    if(piSrc1 == NULL || piSrc2 == NULL || piDst == NULL){
        return(NULL);
    }

    for(iiSrc1 = 0; piSrc1[iiSrc1] != NO_SERVER; iiSrc1++){
        for(iiSrc2 = 0; piSrc2[iiSrc2] != NO_SERVER; iiSrc2++){
            if(piSrc1[iiSrc1] == piSrc2[iiSrc2]){
                // we have a match.
                IHT_AddToServerList(piDst, piSrc1[iiSrc1]);
            }
        }
    }

    for(cDstSize = 0; piDst[cDstSize] != NO_SERVER; cDstSize++){
        ; // note ';' just getting size.
    }
    memcpy(piSrc1, piDst, sizeof(ULONG) * (cDstSize+1));
    LocalFree(piDst);
    
    return(piSrc1);
}

PULONG
IHT_CopyServerList(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN      PULONG                      piSrc
    )
/*++

Description:

    Since most of these list operations "corrupt" the data they use, this
    function is used to make a copy.

Parameters:

    pDsInfo.
    piSrc1 ... list to make copy of.

Return Value:
  
    Pure list function, see IHT_GetServerList() above.

  --*/
{
    ULONG                               ii;
    PULONG                              piServers = NULL;

    piServers = IHT_GetEmptyServerList(pDsInfo);

    if(piSrc == NULL || piServers == NULL){
        return(NULL);
    }

    for(ii = 0; piSrc[ii] != NO_SERVER; ii++){
        piServers[ii] = piSrc[ii];
    }
    piServers[ii] = NO_SERVER;

    return(piServers);
}

PULONG
IHT_NotServerList(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN OUT  PULONG                      piSrc
    )
/*++

Description:

    Like the AND function, this simply NOTs a list.  So take all the
    servers in the enterprise, and then remove the servers in piSrc.
    // IHT_AndServerLists(x) -> x = !x;

Parameters:

    pDsInfo.
    piSrc1 ... list to not and return.

Return Value:
  
    Pure list function, see IHT_GetServerList() above.

  --*/
{
    ULONG                               ii, iiDst;
    PULONG                              piDst;
    
    piDst = IHT_GetEmptyServerList(pDsInfo);

    if(piSrc == NULL || piDst == NULL){
        return(NULL);
    }
    
    iiDst = 0;
    for(ii = 0; ii < pDsInfo->ulNumServers; ii++){
        if(!IHT_ServerIsInServerList(piSrc, ii)){
            piDst[iiDst] = ii;
            iiDst++;
        }
    }

    piDst[iiDst] = NO_SERVER;
    memcpy(piSrc, piDst, sizeof(ULONG) * (iiDst+1));
    LocalFree(piDst);
    
    return(piSrc);
}

INT __cdecl
IHT_IndexedGuidCompare(
    const void *                        elem1,
    const void *                        elem2
    )
/*++

Description:

    This function is used as the comparison for qsort in the function
    IHT_OrderServerListByGuid().

Parameters:

    elem1 - This is the first element and is a pointer to a GUID
    elem2 - This is the second element and is a pointer to a GUID also.

Return Value:
  


  --*/
{
    return(memcmp(&gpDsInfoHackForQSort->pServers[*((INT*)elem1)].uuid,
                  &gpDsInfoHackForQSort->pServers[*((INT*)elem2)].uuid,
                  sizeof(UUID)));
}


PULONG
IHT_OrderServerListByGuid(
    PDC_DIAG_DSINFO		        pDsInfo,
    PULONG                              piServers
    )
/*++

Description:

    This simply takes the piServers list and orders them by GUID.

Parameters:

    pDsInfo ... this is how we get at the GUIDs.
    piServers ... the list to order by GUIDs.

Return Value:
  
    Pure list function, see IHT_GetServerList() above.

  --*/
{
    // THis function orders the servers by Guid.
    ULONG                               cSize;

    if(piServers == NULL){
        return NULL;
    }

    gpDsInfoHackForQSort = pDsInfo;

    // get number of servers ... note semicolon at end.
    for(cSize=0; piServers[cSize] != NO_SERVER; cSize++); 

    // need global hack to do this used gpDsInfoHackForQSort above.
    qsort(piServers, cSize, sizeof(*piServers), IHT_IndexedGuidCompare); 

    // make sure qsort didn't run over bounds or something.
    Assert(piServers[cSize] == NO_SERVER); 
    return(piServers);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\common\main.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dcdiag/common/main.c

ABSTRACT:

    Stand-alone application that calls several routines
    to test whether or not the DS is functioning properly.

DETAILS:

CREATED:

    09 Jul 98    Aaron Siegel (t-asiege)

REVISION HISTORY:

    01/26/1999    Brett Shirley (brettsh)

        Add support for command line credentials, explicitly specified NC's on the command line.

    08/21/1999   Dmitry Dukat (dmitrydu)

        Added support for test specific command line args

--*/
//#define DBG  0

#include <ntdspch.h>
#include <ntdsa.h>
#include <winsock2.h>
#include <dsgetdc.h>
#include <lm.h>
#include <lmapibuf.h> // NetApiBufferFree
#include <ntdsa.h>    // options
#include <wincon.h>
#include <winbase.h>
#include <dnsapi.h>
#include <locale.h>
#include <dsrole.h>  // for DsRoleGetPrimaryDomainInformation()
#include <dsconfig.h> //for DEFAULT_TOMBSTONE_LIFETIME

#define INCLUDE_ALLTESTS_DEFINITION
#include "dcdiag.h"
#include "repl.h"
#include "ldaputil.h"
#include "utils.h"

// Some global variables -------------------------------------------------------
    DC_DIAG_MAININFO        gMainInfo;

    // Global credentials.
    SEC_WINNT_AUTH_IDENTITY_W   gCreds = { 0 };
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds = NULL;

    ULONG ulSevToPrint = SEV_NORMAL;


// Some function declarations --------------------------------------------------
    VOID DcDiagMain (
        LPWSTR                      pszHomeServer,
        LPWSTR                      pszNC,
        ULONG                       ulFlags,
        LPWSTR *                    ppszOmitTests,
        SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
        WCHAR                     * ppszExtraCommandLineArgs[]
        );

    INT PreProcessGlobalParams(
        INT * pargc,
        LPWSTR** pargv
        );
    INT GetPassword(
        WCHAR * pwszBuf,
        DWORD cchBufMax,
        DWORD * pcchBufUsed
        );

    VOID PrintHelpScreen();

LPWSTR
findServerForDomain(
    LPWSTR pszDomainDn
    );

LPWSTR
findDefaultServer(BOOL fMustBeDC);

LPWSTR
convertDomainNcToDn(
    LPWSTR pwzIncomingDomainNc
    );

void
DoNonDcTests(
    LPWSTR pwzComputer,
    ULONG ulFlags,
    LPWSTR * ppszDoTests,
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    WCHAR * ppszExtraCommandLineArgs[]);

/*++




--*/


INT __cdecl
wmain (
    INT                argc,
    LPWSTR *           argv,
    LPWSTR *           envp
    )
{
    static const LPWSTR pszInvalidCmdLine =
        L"Invalid command line; dcdiag.exe /h for help.\n";
    LPWSTR             pszHomeServer = NULL;
    LPWSTR             pszNC = NULL;
    LPWSTR             ppszOmitTests[DC_DIAG_ID_FINISHED+2];
    LPWSTR             ppszDoTests[DC_DIAG_ID_FINISHED+2];
    ULONG              ulFlags = 0L;

    ULONG              ulTest = 0L;
    ULONG              ulOmissionAt = 0L;
    ULONG              ulTestAt = 0L;
    ULONG              iTest = 0;
    ULONG              iDoTest = 0;
    INT                i = 0;
    INT                iTestArg = 0;
    INT                iArg;
    INT                iPos;
    BOOL               bDoNextFlag = FALSE;
    BOOL               bFound =FALSE;
    LPWSTR             pszTemp = NULL;
    BOOL               bComprehensiveTests = FALSE;
    WCHAR              *ppszExtraCommandLineArgs[MAX_NUM_OF_ARGS];
    BOOL               fNcMustBeFreed = FALSE;
    BOOL               fNonDcTests = FALSE;
    BOOL               fDcTests = FALSE;
    BOOL               fFound = FALSE;
    HANDLE                          hConsole = NULL;
    CONSOLE_SCREEN_BUFFER_INFO      ConInfo;
    UINT               Codepage;
                       // ".", "uint in decimal", null
    char               achCodepage[12] = ".OCP";
    
    //
    // Set locale to the default
    //
    if (Codepage = GetConsoleOutputCP()) {
        sprintf(achCodepage, ".%u", Codepage);
    }
    setlocale(LC_ALL, achCodepage);

    //set the Commandlineargs all to NULL
    for(i=0;i<MAX_NUM_OF_ARGS;i++)
        ppszExtraCommandLineArgs[i]=NULL;

    // Initialize output package
    gMainInfo.streamOut = stdout;
    gMainInfo.streamErr = stderr;
    gMainInfo.ulSevToPrint = SEV_NORMAL;
    gMainInfo.iCurrIndent = 0;
    if(hConsole = GetStdHandle(STD_OUTPUT_HANDLE)){
        if(GetConsoleScreenBufferInfo(hConsole, &ConInfo)){
            gMainInfo.dwScreenWidth = ConInfo.dwSize.X;
        } else {
            gMainInfo.dwScreenWidth = 80;
        }
    } else {
        gMainInfo.dwScreenWidth = 80;
    }

    // Parse commandline arguments.
    PreProcessGlobalParams(&argc, &argv);

    for (iArg = 1; iArg < argc ; iArg++)
    {
        bFound = FALSE;
        if (*argv[iArg] == L'-')
        {
            *argv[iArg] = L'/';
        }
        if (*argv[iArg] != L'/')
        {
            // wprintf (L"Invalid Syntax: Use dcdiag.exe /h for help.\n");
            PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_BAD_OPTION, argv[iArg]);
            return -1;
        }
        else if (_wcsnicmp(argv[iArg],L"/f:",wcslen(L"/f:")) == 0)
        {
            pszTemp = &argv[iArg][3];
            if (*pszTemp == L'\0')
            {
                // wprintf(L"Syntax Error: must use /f:<logfile>\n");
                PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_F );
                return -1;
            }
            if((gMainInfo.streamOut = _wfopen (pszTemp, L"a+t")) == NULL){
                // wprintf(L"Could not open %s for writing.\n", pszTemp);
                gMainInfo.streamOut = stdout;
                PrintMsg( SEV_ALWAYS, DCDIAG_OPEN_FAIL_WRITE, pszTemp );
                return(-1);
            }
            if(gMainInfo.streamErr == stderr){
                gMainInfo.streamErr = gMainInfo.streamOut;
            }
        }
        else if (_wcsnicmp(argv[iArg],L"/ferr:",wcslen(L"/ferr:")) == 0)
        {
            pszTemp = &argv[iArg][6];
            if (*pszTemp == L'\0')
            {
                // wprintf(L"Syntax Error: must use /ferr:<errorlogfile>\n");
                PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_FERR );
                return -1;
            }
            if((gMainInfo.streamErr = _wfopen (pszTemp, L"a+t")) == NULL){
                // wprintf(L"Could not open %s for writing.\n", pszTemp);
                PrintMsg( SEV_ALWAYS, DCDIAG_OPEN_FAIL_WRITE, pszTemp );
                return(-1);
            }
        }
        else if (_wcsicmp(argv[iArg],L"/h") == 0|| _wcsicmp(argv[iArg],L"/?") == 0)
        {
            PrintHelpScreen();
                    return 0;
        }
        else if (_wcsnicmp(argv[iArg],L"/n:",wcslen(L"/n:")) == 0)
        {
            if (pszNC != NULL) {
                // wprintf(L"Cannot specify more than one naming context.\n");
                PrintMsg( SEV_ALWAYS, DCDIAG_ONLY_ONE_NC );
                return -1;
            }
            pszTemp = &(argv[iArg][3]);
            if (*pszTemp == L'\0')
            {
                // wprintf(L"Syntax Error: must use /n:<naming context>\n");
                PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_N );
                return -1;
            }
            pszNC = pszTemp;
        }
        else if (_wcsnicmp(argv[iArg],L"/s:",wcslen(L"/s:")) == 0)
        {
            if (pszHomeServer != NULL) {
                // wprintf(L"Cannot specify more than one server.\n");
                PrintMsg( SEV_ALWAYS, DCDIAG_ONLY_ONE_SERVER );
                return -1;
            }
            pszTemp = &(argv[iArg][3]);
            if (*pszTemp == L'\0')
            {
                // wprintf(L"Syntax Error: must use /s:<server>\n");
                PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_S );
                return -1;
            }
            pszHomeServer = pszTemp;
        }
        else if (_wcsnicmp(argv[iArg],L"/skip:",wcslen(L"/skip:")) == 0)
        {
            pszTemp = &argv[iArg][6];
            if (*pszTemp == L'\0')
            {
                // wprintf(L"Syntax Error: must use /skip:<test name>\n");
                PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_SKIP );
                return -1;
            }
            ppszOmitTests[ulOmissionAt++] = pszTemp;
        }
        else if (_wcsnicmp(argv[iArg],L"/test:",wcslen(L"/test:")) == 0)
        {
            pszTemp = &argv[iArg][6];
            if (*pszTemp == L'\0')
            {
                //wprintf(L"Syntax Error: must use /test:<test name>\n");
                PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_TEST );
                return -1;
            }
            ppszDoTests[ulTestAt++] = pszTemp;
            //
            // Check whether the test name is valid, and if so if it is a DC
            // test or not.
            //
            for (iTest = 0; allTests[iTest].testId != DC_DIAG_ID_FINISHED; iTest++)
            {
                if (_wcsicmp(allTests[iTest].pszTestName, pszTemp) == 0)
                {
                    fFound = TRUE;
                    if (allTests[iTest].ulTestFlags & NON_DC_TEST)
                    {
                        fNonDcTests = TRUE;
                    }
                    else
                    {
                        fDcTests = TRUE;
                    }
                }
            }
            if (!fFound)
            {
                PrintMsg(SEV_ALWAYS, DCDIAG_INVALID_TEST);
                return -1;
            }
        }
        else if (_wcsicmp(argv[iArg],L"/c") == 0)
        {
            ulTestAt = 0;
            for(iTest = 0; allTests[iTest].testId != DC_DIAG_ID_FINISHED; iTest++){
                ppszDoTests[ulTestAt++] = allTests[iTest].pszTestName;
            }
            bComprehensiveTests = TRUE;
        }
        else if (_wcsicmp(argv[iArg],L"/a") == 0)
        {
            ulFlags |= DC_DIAG_TEST_SCOPE_SITE;
        }
        else if (_wcsicmp(argv[iArg],L"/e") == 0)
        {
            ulFlags |= DC_DIAG_TEST_SCOPE_ENTERPRISE;
        }
        else if (_wcsicmp(argv[iArg],L"/v") == 0)
        {
            gMainInfo.ulSevToPrint = SEV_VERBOSE;
        }
        else if (_wcsicmp(argv[iArg],L"/d") == 0)
        {
            gMainInfo.ulSevToPrint = SEV_DEBUG;
        }
        else if (_wcsicmp(argv[iArg],L"/q") == 0)
        {
            gMainInfo.ulSevToPrint = SEV_ALWAYS;
        }
        else if (_wcsicmp(argv[iArg],L"/i") == 0)
        {
            ulFlags |= DC_DIAG_IGNORE;
        }
        else if (_wcsicmp(argv[iArg],L"/fix") == 0)
        {
            ulFlags |= DC_DIAG_FIX;
        }
        else
        {
            //look for test specific command line options
            for (i=0;clOptions[i] != NULL;i++)
            {
                DWORD Length = wcslen( argv[iArg] );
                if (clOptions[i][wcslen(clOptions[i])-1] == L':')
                {
                    if((_wcsnicmp(argv[iArg], clOptions[i], wcslen(clOptions[i])) == 0))
                    {
                        pszTemp = &argv[iArg][wcslen(clOptions[i])];
                        if (*pszTemp == L'\0')
                        {
                            // wprintf(L"Syntax Error: must use %s<parameter>\n",clOptions[i]);
                            PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_MISSING_PARAM,clOptions[i]);
                            return -1;
                        }
                        bFound = TRUE;
                        ppszExtraCommandLineArgs[iTestArg] = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                        wcscpy(ppszExtraCommandLineArgs[iTestArg++], argv[iArg] );
                    }
                }
                else if((_wcsicmp(argv[iArg], clOptions[i]) == 0))
                {
                    bFound = TRUE;
                    ppszExtraCommandLineArgs[iTestArg] = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                    wcscpy(ppszExtraCommandLineArgs[iTestArg++], argv[iArg] );
                }
            }
            if(!bFound)
            {
                // wprintf (L"Invalid switch: %s.  Use dcdiag.exe /h for help.\n", argv[iArg]);
                PrintMsg( SEV_ALWAYS, DCDIAG_INVALID_SYNTAX_BAD_OPTION, argv[iArg]);
                return -1;
            }
        }
    }

    ppszDoTests[ulTestAt] = NULL;

    if (fNonDcTests)
    {
        if (fDcTests)
        {
            // Can't mix DC and non-DC tests.
            //
            PrintMsg(SEV_ALWAYS, DCDIAG_INVALID_TEST_MIX);
            return -1;
        }

        DoNonDcTests(pszHomeServer, ulFlags, ppszDoTests, gpCreds, ppszExtraCommandLineArgs);

        _fcloseall();
        return 0;
    }

    gMainInfo.ulFlags = ulFlags;
    gMainInfo.lTestAt = -1;
    gMainInfo.iCurrIndent = 0;

    // Make sure that the NC specified is in the proper form
    // Handle netbios and dns forms of the domain
    if (pszNC) {
        pszNC = convertDomainNcToDn( pszNC );
        fNcMustBeFreed = TRUE;
    }

    // Basically this uses ppszDoTests to construct ppszOmitTests as the
    //   inverse of ppszDoTests.
    if(ppszDoTests[0] != NULL && !bComprehensiveTests){
        // This means we are supposed to do only the tests in ppszDoTests, so
        //   we need to invert the tests in DoTests and put it in omit tests.
        ulOmissionAt = 0;
        for(iTest = 0; allTests[iTest].testId != DC_DIAG_ID_FINISHED; iTest++){
            for(iDoTest = 0; ppszDoTests[iDoTest] != NULL; iDoTest++){
                if(_wcsicmp(ppszDoTests[iDoTest], allTests[iTest].pszTestName) == 0){
                    break;
                }
            }
            if(ppszDoTests[iDoTest] == NULL){
                // This means this test (iTest) wasn't found in the do list, so omit.
                ppszOmitTests[ulOmissionAt++] = allTests[iTest].pszTestName;
            }
        }
    } else if(!bComprehensiveTests){
        // This means in addition to whatever was omitted on the command line
        //    we should omit the DO_NOT_RUN_TEST_BY_DEFAULT
        for(iTest = 0; allTests[iTest].testId != DC_DIAG_ID_FINISHED; iTest++){
            if(allTests[iTest].ulTestFlags & DO_NOT_RUN_TEST_BY_DEFAULT){
                if(ulOmissionAt >= DC_DIAG_ID_FINISHED){
                    // wprintf(L"Error: Do not omit tests that are not run by default. \nUse dcdiag /? for those tests\n");
                    PrintMsg( SEV_ALWAYS, DCDIAG_DO_NOT_OMIT_DEFAULT );
                    return(-1);
                }
                ppszOmitTests[ulOmissionAt++] = allTests[iTest].pszTestName;
            }
        }

    }

    ppszOmitTests[ulOmissionAt] = NULL;


    DcDiagMain (pszHomeServer, pszNC, ulFlags, ppszOmitTests, gpCreds, ppszExtraCommandLineArgs);

    _fcloseall ();

    if ( (fNcMustBeFreed) && (pszNC) ) {
        LocalFree( pszNC );
    }

    return 0;
} /* wmain  */


// ===================== Other Functions

VOID
PrintHelpScreen(){
    ULONG                  ulTest;
    //     "============================80 char ruler======================================="
    static const LPWSTR    pszHelpScreen =
        L"\n"
        DC_DIAG_VERSION_INFO
//      L"\ndcdiag.exe /s <Domain Controller> [/options]"  // Another format for help that I am debating
        L"\ndcdiag.exe /s:<Domain Controller> [/u:<Domain>\\<Username> /p:*|<Password>|\"\"]"
        L"\n           [/hqv] [/n:<Naming Context>] [/f:<Log>] [/ferr:<Errlog>]"
        L"\n           [/skip:<Test>] [/test:<Test>]"
        L"\n   /h: Display this help screen"
        L"\n   /s: Use <Domain Controller> as Home Server. Ignored for DcPromo and"
        L"\n       RegisterInDns tests which can only be run locally."
        L"\n   /n: Use <Naming Context> as the Naming Context to test"
        L"\n       Domains may be specified in Netbios, DNS or DN form."
        L"\n   /u: Use domain\\username credentials for binding."
        L"\n       Must also use the /p option"
        L"\n   /p: Use <Password> as the password.  Must also use the /u option"
        L"\n   /a: Test all the servers in this site"
        L"\n   /e: Test all the servers in the entire enterprise.  Overrides /a"
        L"\n   /q: Quiet - Only print error messages"
        L"\n   /v: Verbose - Print extended information"
        L"\n   /i: ignore - ignores superfluous error messages."
        L"\n   /fix: fix - Make safe repairs."
        L"\n   /f: Redirect all output to a file <Log>, /ferr will redirect error output"
        L"\n       seperately."
        L"\n   /ferr:<ErrLog> Redirect fatal error output to a seperate file <ErrLog>"
        L"\n   /c: Comprehensive, runs all tests, including non-default tests but excluding"
        L"\n       DcPromo and RegisterInDNS. Can use with /skip";
    static const LPWSTR    pszTestHelp =
        L"\n   /test:<TestName> - Test only this test.  Required tests will still"
        L"\n                      be run.  Do not mix with /skip."
        L"\n   Valid tests are:\n";
    static const LPWSTR    pszSkipHelp =
        L"\n   /skip:<TestName> - Skip the named test.  Required tests will still"
        L"\n                      be run.  Do not mix with /test."
        L"\n   Tests that can be skipped are:\n";
    static const LPWSTR    pszNotRunTestHelp =
        L"\n   The following tests are not run by default:\n";

    wprintf (pszHelpScreen);
    wprintf (pszTestHelp);
    for (ulTest = 0L; allTests[ulTest].testId != DC_DIAG_ID_FINISHED; ulTest++){
        wprintf (L"       %s  - %s\n", allTests[ulTest].pszTestName,
                 allTests[ulTest].pszTestDescription);
    }
    wprintf(pszSkipHelp);
    for (ulTest = 0L; allTests[ulTest].testId != DC_DIAG_ID_FINISHED; ulTest++){
        if(!(allTests[ulTest].ulTestFlags & CAN_NOT_SKIP_TEST)){
            wprintf (L"       %s  - %s\n", allTests[ulTest].pszTestName,
                 allTests[ulTest].pszTestDescription);
        }
    }
    wprintf(pszNotRunTestHelp);
    for (ulTest = 0L; allTests[ulTest].testId != DC_DIAG_ID_FINISHED; ulTest++){
        if((allTests[ulTest].ulTestFlags & DO_NOT_RUN_TEST_BY_DEFAULT)){
            wprintf (L"       %s  - %s\n", allTests[ulTest].pszTestName,
                 allTests[ulTest].pszTestDescription);
        }
    }

} // End PrintHelpScreen()

ULONG
DcDiagExceptionHandler(
    IN const  EXCEPTION_POINTERS * prgExInfo,
    OUT PDWORD                     pdwWin32Err
    )
/*++

Routine Description:

    This function is used in the __except (<insert here>) part of the except
    clause.  This will hand back the win 32 error if this is a dcdiag
    exception.

Arguments:

    prgExInfo - This is the information returned by GetExceptioInformation()
        in the __except() clause.
    pdwWin32Err - This is the value handed back as the win 32 error.

Return Value:
    returns EXCEPTION_EXECUTE_HANDLER if the exception was thrown by dcdiag and
    EXCEPTION_CONTINUE_SEARCH otherwise.

--*/
{

    if(prgExInfo->ExceptionRecord->ExceptionCode == DC_DIAG_EXCEPTION){
        IF_DEBUG(PrintMessage(SEV_ALWAYS,
                              L"DcDiag: a dcdiag exception raised, handling error %d\n",
                              prgExInfo->ExceptionRecord->ExceptionInformation[0]));
        if(pdwWin32Err != NULL){
            *pdwWin32Err = (DWORD) prgExInfo->ExceptionRecord->ExceptionInformation[0];
        }
        return(EXCEPTION_EXECUTE_HANDLER);
    } else {
        IF_DEBUG(PrintMessage(SEV_ALWAYS,
                              L"DcDiag: uncaught exception raised, continuing search \n"));
        if(pdwWin32Err != NULL){
            *pdwWin32Err = ERROR_SUCCESS;
        }
        return(EXCEPTION_CONTINUE_SEARCH);
    }
}

VOID
DcDiagException (
    IN    DWORD            dwWin32Err
    )
/*++

Routine Description:

    This is called by the component tests to indicate that a fatal error
    has occurred.

Arguments:

    dwWin32Err        (IN ) -    The win32 error code.

Return Value:

--*/
{
    static ULONG_PTR              ulpErr[1];

    ulpErr[0] = dwWin32Err;

    if (dwWin32Err != NO_ERROR){
        RaiseException (DC_DIAG_EXCEPTION,
                        EXCEPTION_NONCONTINUABLE,
                        1,
                        ulpErr);
    }
}

LPWSTR
Win32ErrToString (
    IN    DWORD            dwWin32Err
    )
/*++

Routine Description:

    Converts a win32 error code to a string; useful for error reporting.
    This was basically stolen from repadmin.

Arguments:

    dwWin32Err        (IN ) -    The win32 error code.

Return Value:

    The converted string.  This is part of system memory and does not
    need to be freed.

--*/
{
    #define ERROR_BUF_LEN    4096
    static WCHAR        szError[ERROR_BUF_LEN];

    if (FormatMessageW (
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwWin32Err,
        GetSystemDefaultLangID (),
        szError,
        ERROR_BUF_LEN,
        NULL) != NO_ERROR)
    szError[wcslen (szError) - 2] = '\0';    // Remove \r\n

    else swprintf (szError, L"Win32 Error %d", dwWin32Err);

    return szError;
}

INT PrintIndentAdj (INT i)
{
    return (gMainInfo.iCurrIndent += i);
}

INT PrintIndentSet (INT i)
{
    INT   iRet;
    iRet = gMainInfo.iCurrIndent;
    gMainInfo.iCurrIndent = i;
    return(iRet);
}

LPWSTR
DcDiagAllocNameFromDn (
    LPWSTR            pszDn
    )
/*++

Routine Description:

    This routing take a DN and returns the second RDN in LocalAlloc()'d memory.
    This is used to return the server name portion of an NTDS Settings DN.

Arguments:

    pszDn - (IN) DN

Return Value:

   The exploded DN.

--*/
{
    LPWSTR *    ppszDnExploded = NULL;
    LPWSTR      pszName = NULL;

    if (pszDn == NULL) {
        return NULL;
    }

    __try {
        ppszDnExploded = ldap_explode_dnW(pszDn, 1);
        if (ppszDnExploded == NULL) {
            DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
        }

        pszName = (LPWSTR) LocalAlloc(LMEM_FIXED,
                                      (wcslen (ppszDnExploded[1]) + 1)
                                      * sizeof (WCHAR));
        DcDiagChkNull(pszName);

        wcscpy (pszName, ppszDnExploded[1]);
    } __finally {
        if (ppszDnExploded != NULL) {
            ldap_value_freeW (ppszDnExploded);
        }
    }

    return pszName;
}

LPWSTR
DcDiagAllocGuidDNSName (
    LPWSTR            pszRootDomain,
    UUID *            pUuid
    )
/*++

Routine Description:

    This routine makes the GuidDNSName out of the RootDomain and Guid.

Arguments:

    pszRootDomain - (IN) The domain of the server.
    pUuid - (IN) The Guid of the server.

Return Value:

   The GuidDNSName

--*/
{
    LPWSTR            pszStringizedGuid = NULL;
    LPWSTR            pszGuidDNSName;

    __try {

    if(UuidToStringW (pUuid, &pszStringizedGuid) != RPC_S_OK){
        if(UuidToStringW(pUuid, &pszStringizedGuid) != RPC_S_OUT_OF_MEMORY){
            Assert(!"Ahhh programmer problem, UuidToString() inaccurately reports in"
                   " MSDN that it will only return one of two error codes, but apparently"
                   " it will return a 3rd.  Someone should figure out what to do about"
                   " this.");
        }
        // hmmm?
    }
    Assert(pszStringizedGuid);
    DcDiagChkNull (pszGuidDNSName = LocalAlloc (LMEM_FIXED, (wcslen (pszRootDomain) +
                      wcslen (pszStringizedGuid) + 2 + 7) * sizeof (WCHAR)));
                                  // added 9 , for the ".msdcs." string and the NULL char.
    swprintf (pszGuidDNSName, L"%s._msdcs.%s", pszStringizedGuid, pszRootDomain);

    } __finally {

        if (pszStringizedGuid != NULL) RpcStringFreeW (&pszStringizedGuid);

    }

    return pszGuidDNSName;
}

PDSNAME
DcDiagAllocDSName (
    LPWSTR            pszStringDn
    )
/*++

    Ripped from ntdsapi

--*/
{
    PDSNAME            pDsname;
    DWORD            dwLen, dwBytes;

    if (pszStringDn == NULL)
    return NULL;

    dwLen = wcslen (pszStringDn);
    dwBytes = DSNameSizeFromLen (dwLen);

    DcDiagChkNull (pDsname = (DSNAME *) LocalAlloc (LMEM_FIXED, dwBytes));

    pDsname->NameLen = dwLen;
    pDsname->structLen = dwBytes;
    pDsname->SidLen = 0;
    //    memcpy(pDsname->Guid, &gNullUuid, sizeof(GUID));
    memset(&(pDsname->Guid), 0, sizeof(GUID));
    wcscpy (pDsname->StringName, pszStringDn);

    return pDsname;
}

BOOL
DcDiagEqualDNs (
    LPWSTR            pszDn1,
    LPWSTR            pszDn2

    )
/*++

Routine Description:

    The Dns Match function.

Arguments:

    pszDn1 - (IN) Dn number 1 to compare
    pszDn2 - (IN) Dn number 2 to compare

Return Value:

   TRUE if the Dn's match, FALSE otherwise

--*/
{
    PDSNAME            pDsname1 = NULL;
    PDSNAME            pDsname2 = NULL;
    BOOL            bResult;

    __try {

    pDsname1 = DcDiagAllocDSName (pszDn1);
    pDsname2 = DcDiagAllocDSName (pszDn2);

    bResult = NameMatched (pDsname1, pDsname2);

    } __finally {

    if (pDsname1 != NULL) LocalFree (pDsname1);
    if (pDsname2 != NULL) LocalFree (pDsname2);

    }

    return bResult;
}


ULONG
DcDiagGetServerNum(
    PDC_DIAG_DSINFO                 pDsInfo,
    LPWSTR                          pszName,
    LPWSTR                          pszGuidName,
    LPWSTR                          pszDsaDn,
    LPWSTR                          pszDNSName,
    LPGUID                          puuidInvocationId
    )
/*++

Routine Description:

    This function takes the pDsInfo, and returns the index into the
    pDsInfo->pServers array of the server that you specified with pszName,
    or pszGuidName, or pszDsaDn.

Arguments:

    pDsInfo - the enterpise info
    pszName - the flat level dns name (BRETTSH-DEV) to find
    pszGuidName - the guid based dns name (343-13...23._msdcs.root.com)
    pszDsaDn - the distinguished name of the NT DSA object. CN=NTDS Settings,CN=
       brettsh-dev,CN=Configuration,DC=root...
    puuidInvocationID - the GUID of an invocation of the dc
       gregjohn

Return Value:

    returns the index into the pServers array of the pDsInfo struct.

--*/
{
    ULONG      ul;

    Assert(pszName || pszGuidName || pszDsaDn || pszDNSName || puuidInvocationId);

    for(ul=0;ul<pDsInfo->ulNumServers;ul++){
        if(
            (pszGuidName &&
             (_wcsicmp(pszGuidName, pDsInfo->pServers[ul].pszGuidDNSName) == 0))
            || (pszName &&
                (_wcsicmp(pszName, pDsInfo->pServers[ul].pszName) == 0))
            || (pszDsaDn &&
                (_wcsicmp(pszDsaDn, pDsInfo->pServers[ul].pszDn) == 0))
            || (pszDNSName &&
                (DnsNameCompare_W(pszDNSName, pDsInfo->pServers[ul].pszDNSName) != 0))
	    || (puuidInvocationId &&
		(memcmp(puuidInvocationId, &(pDsInfo->pServers[ul].uuidInvocationId), sizeof(UUID)) == 0))
	    ){
            return ul;
        }
    }
    return(NO_SERVER);
}

ULONG
DcDiagGetNCNum(
    PDC_DIAG_DSINFO                     pDsInfo,
    LPWSTR                              pszNCDN,
    LPWSTR                              pszDomain
    )
/*++

Description:

    Like DcDiagGetServerNum, this takes the mini-enterprise structure, and
    a variable number of params to match to get the index into pDsInfo->pNCs
    of the NC specified by the other params.

Parameters:

    pDsInfo
    pszNCDN - The DN of the NC to find.
    pszDomain - Not yet implemented, just figured it'd be nice some day.

Return Value:

    The index of the NC if found, otherwise NO_NC.

--*/
{
    ULONG                               iNC;

    Assert(pszNCDN != NULL || pszDomain != NULL);
    Assert(pszDomain == NULL && "The pszDomain is not implemented yet\n");

    for(iNC = 0; iNC < pDsInfo->cNumNCs; iNC++){
        if((pszNCDN &&
            (_wcsicmp(pDsInfo->pNCs[iNC].pszDn, pszNCDN) == 0))
           // Code.Improvement add support for the domain name.
           ){
            // Got the right NC, return it.
            return(iNC);
        }
    } // end for each NC

    // Couldn't find the NC.
    return(NO_NC);
}


BOOL
DcDiagIsMemberOfStringList(
    LPWSTR pszTarget,
    LPWSTR * ppszSources,
    INT iNumSources
    )
/*++

Routine Description:

    This takes a string and returns true if the string is int

Arguments:

    pszTarget - The string to find.
    ppszSources - The array to search for the target string.
    iNumSources - The length of the search array ppszSources.

Return Value:

    TRUE if it found the string in the array, false otherwise.

--*/
{
    ULONG                               ul;

    if(ppszSources == NULL){
        return(FALSE);
    }

    for(ul = 0; (iNumSources == -1)?(ppszSources[ul] != NULL):(ul < (ULONG)iNumSources); ul++){
        if(_wcsicmp(pszTarget, ppszSources[ul]) == 0){
            return(TRUE);
        }
    }
    return(FALSE);
}

ULONG
DcDiagGetSiteFromDn(
    PDC_DIAG_DSINFO                  pDsInfo,
    LPWSTR                           pszDn
    )
/*++

Routine Description:

    This takes the Dn of a server ntds settings object and turns it into a
    index into the pDsInfo->pSites structure of that server.

Arguments:

    pDsInfo - the enterprise info, including pSites.
    pszDn - DN of a NT DSA object, like "CN=NTDS Settings,CN=SERVER_NAME,...

Return Value:

    The index info the pDsInfo->pSites array of the server pszDn.

--*/
{
    LPWSTR                           pszNtdsSiteSettingsPrefix = L"CN=NTDS Site Settings,";
    PDSNAME                          pdsnameServer = NULL;
    PDSNAME                          pdsnameSite = NULL;
    ULONG                            ul, ulTemp;
    LPWSTR                           pszSiteSettingsDn = NULL;

    __try{

        pdsnameServer = DcDiagAllocDSName (pszDn);
        DcDiagChkNull (pdsnameSite = (PDSNAME) LocalAlloc(LMEM_FIXED,
                                         pdsnameServer->structLen));
        TrimDSNameBy (pdsnameServer, 3, pdsnameSite);
        ulTemp = wcslen(pszNtdsSiteSettingsPrefix) +
                 wcslen(pdsnameSite->StringName) + 2;
        DcDiagChkNull( pszSiteSettingsDn = LocalAlloc(LMEM_FIXED,
                                                      sizeof(WCHAR) * ulTemp));
        wcscpy(pszSiteSettingsDn, pszNtdsSiteSettingsPrefix);
        wcscat(pszSiteSettingsDn, pdsnameSite->StringName);

        // Find the site
        for(ul = 0; ul < pDsInfo->cNumSites; ul++){
            if(_wcsicmp(pDsInfo->pSites[ul].pszSiteSettings, pszSiteSettingsDn)
               == 0){
                return(ul);
            }
        }

    } __finally {
        if(pdsnameServer != NULL) LocalFree(pdsnameServer);
        if(pdsnameSite != NULL) LocalFree(pdsnameSite);
        if(pszSiteSettingsDn != NULL) LocalFree(pszSiteSettingsDn);
    }

    return(NO_SITE);
}

VOID *
GrowArrayBy(
    VOID *            pArray,
    ULONG             cGrowBy,
    ULONG             cbElem
    )
/*++

Routine Description:

    This simply takes the array pArray, and grows it by cGrowBy times cbElem (the
    size of a single element of the array).

Arguments:

    pArray - The array to grow.
    cGrowBy - The number of elements to add to the array.
    cbElem - The sizeof in bytes of a single array element.

Return Value:

    Returns the pointer to the newly allocated array, and a pointer to NULL if
    there was not enough memory.

--*/
{
    ULONG             ulOldSize = 0;
    VOID *            pNewArray;

    if(pArray != NULL){
	ulOldSize = (ULONG) LocalSize(pArray);
    } // else if pArray is NULL assume that the array
    // has never been allocated, so alloc fresh.

    Assert( (pArray != NULL) ? ulOldSize != 0 : TRUE);
    Assert((ulOldSize % cbElem) == 0);

    pNewArray = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
			   ulOldSize + (cGrowBy * cbElem));
    if(pNewArray == NULL){
	return(pNewArray);
    }

    memcpy(pNewArray, pArray, ulOldSize);
    LocalFree(pArray);

    return(pNewArray);
}

DWORD
DcDiagGenerateSitesList (
    PDC_DIAG_DSINFO                  pDsInfo,
    PDSNAME                          pdsnameEnterprise
    )
/*++

Routine Description:

    This generates and fills in the pDsInfo->pSites array for DcDiagGatherInfo()

Arguments:

    pDsInfo - enterprise info
    pdsnameEnterprise - a PDSNAME of the sites container.

Return Value:

    Win32 error value.

--*/
{
    LPWSTR                     ppszNtdsSiteSearch [] = {
        L"objectGUID",
        L"name",
        L"distinguishedName",
        L"interSiteTopologyGenerator",
        L"options",
        NULL };
    LDAP *                     hld = NULL;
    LDAPMessage *              pldmEntry = NULL;
    LDAPMessage *              pldmNtdsSitesResults = NULL;
    LPWSTR                     pszDn = NULL;
    ULONG                      ulTemp;
    DWORD                      dwWin32Err = NO_ERROR;
    LPWSTR *                   ppszTemp = NULL;
    LDAPSearch *               pSearch = NULL;
    ULONG                      ulTotalEstimate = 0;
    ULONG                      ulCount = 0;
    DWORD                      dwLdapErr;

    __try {

        hld = pDsInfo->hld;

	pDsInfo->pSites = NULL;

	pSearch = ldap_search_init_page(hld,
					pdsnameEnterprise->StringName,
					LDAP_SCOPE_SUBTREE,
					L"(objectCategory=ntDSSiteSettings)",
					ppszNtdsSiteSearch,
					FALSE, NULL, NULL, 0, 0, NULL);
	if(pSearch == NULL){
	    dwLdapErr = LdapGetLastError();
	    DcDiagException(LdapMapErrorToWin32(dwLdapErr));
	}

	dwLdapErr = ldap_get_next_page_s(hld,
					 pSearch,
					 0,
					 DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					 &ulTotalEstimate,
					 &pldmNtdsSitesResults);
	if(dwLdapErr == LDAP_NO_RESULTS_RETURNED){	
	    PrintMessage(SEV_ALWAYS, L"Could not find any Sites in the AD, dcdiag could not\n");
	    PrintMessage(SEV_ALWAYS, L"Continue\n");
	    DcDiagException(ERROR_DS_OBJ_NOT_FOUND);
	}
	while(dwLdapErr == LDAP_SUCCESS){
	    pDsInfo->pSites = GrowArrayBy(pDsInfo->pSites,
					  ldap_count_entries(hld, pldmNtdsSitesResults),
					  sizeof(DC_DIAG_SITEINFO));
	    DcDiagChkNull(pDsInfo->pSites);

	    // Walk through all the sites ...
	    pldmEntry = ldap_first_entry (hld, pldmNtdsSitesResults);
	    for (; pldmEntry != NULL; ulCount++) {
		// Get the site common/printable name
		if ((pszDn = ldap_get_dnW (hld, pldmEntry)) == NULL){
		    DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
		}
		DcDiagChkNull (pDsInfo->pSites[ulCount].pszSiteSettings =
			       LocalAlloc(LMEM_FIXED,
					  (wcslen (pszDn) + 1) * sizeof (WCHAR)));
		wcscpy (pDsInfo->pSites[ulCount].pszSiteSettings , pszDn);
		ppszTemp = ldap_explode_dnW(pszDn, TRUE);
		if(ppszTemp != NULL){
		    pDsInfo->pSites[ulCount].pszName = LocalAlloc(LMEM_FIXED,
			                  sizeof(WCHAR) * (wcslen(ppszTemp[1]) + 2));
		    if(pDsInfo->pSites[ulCount].pszName == NULL){
			DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
		    }
		    wcscpy(pDsInfo->pSites[ulCount].pszName, ppszTemp[1]);
		    ldap_value_freeW(ppszTemp);
		    ppszTemp = NULL;
		} else {
		    pDsInfo->pSites[ulCount].pszName = NULL;
		}

		// Get the Intersite Topology Generator attribute
		ppszTemp = ldap_get_valuesW(hld, pldmEntry,
					    L"interSiteTopologyGenerator");
		if(ppszTemp != NULL){
		    ulTemp = wcslen(ppszTemp[0]) + 2;
		    pDsInfo->pSites[ulCount].pszISTG = LocalAlloc(LMEM_FIXED,
						    sizeof(WCHAR) * ulTemp);
		    if(pDsInfo->pSites[ulCount].pszISTG == NULL){
			return(GetLastError());
		    }
		    wcscpy(pDsInfo->pSites[ulCount].pszISTG, ppszTemp[0]);
		    ldap_value_freeW(ppszTemp);
		    ppszTemp = NULL;
		} else {
		    pDsInfo->pSites[ulCount].pszISTG = NULL;
		}

		// Get Site Options
		ppszTemp = ldap_get_valuesW (hld, pldmEntry, L"options");
		if (ppszTemp != NULL) {
		    pDsInfo->pSites[ulCount].iSiteOptions = atoi ((LPSTR) ppszTemp[0]);
		    ldap_value_freeW(ppszTemp);
		    ppszTemp = NULL;
		} else {
		    pDsInfo->pSites[ulCount].iSiteOptions = 0;
		}

		ldap_memfreeW (pszDn);
		pszDn = NULL;

		pldmEntry = ldap_next_entry (hld, pldmEntry);
	    } // end for each site

	    ldap_msgfree(pldmNtdsSitesResults);
            pldmNtdsSitesResults = NULL;

	    dwLdapErr = ldap_get_next_page_s(hld,
					     pSearch,
					     0,
					     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					     &ulTotalEstimate,
					     &pldmNtdsSitesResults);
	} // end of while loop for each page

	if(dwLdapErr != LDAP_NO_RESULTS_RETURNED){
	    DcDiagException(LdapMapErrorToWin32(dwLdapErr));
	}

	ldap_search_abandon_page(hld, pSearch);
        pSearch = NULL;

        pDsInfo->cNumSites = ulCount;

    } __except (DcDiagExceptionHandler(GetExceptionInformation(),
                                       &dwWin32Err)){
    }

    // Note we do not unbind the Ds or Ldap connections, because they have been saved for later use.
    if (pszDn != NULL) { ldap_memfreeW (pszDn); }
    if (ppszTemp != NULL) { ldap_value_freeW (ppszTemp); }
    if (pldmNtdsSitesResults != NULL) { ldap_msgfree (pldmNtdsSitesResults); }
    if (pSearch != NULL) { ldap_search_abandon_page(hld, pSearch); }
    // DONT FREE pdsnameEnterprise it is done in GatherInfo()

    return dwWin32Err;
}



DWORD
DcDiagGenerateNCsList(
    PDC_DIAG_DSINFO                     pDsInfo
    )
/*++

Routine Description:

    This generates and fills in the pNCs array via pulling all the NCs from
    the servers partial and master replica info.

Arguments:

    pDsInfo - hold the server info that comes in and contains that pNCs array
        on the way out.

Return Value:

    Win32 error value ... could only be OUT_OF_MEMORY.

--*/
{
    ULONG                               ul, ulTemp, ulSize;
    LPWSTR *                            ppszzNCs = NULL;
    LPWSTR *                            ppTemp = NULL;
    PDC_DIAG_SERVERINFO                 pServer = NULL;

    ulSize = 0;

    for(ul = 0; ul < pDsInfo->ulNumServers; ul++){
        pServer = &(pDsInfo->pServers[ul]);
        if(pServer->ppszMasterNCs){
            for(ulTemp = 0; pServer->ppszMasterNCs[ulTemp] != NULL; ulTemp++){
                if(!DcDiagIsMemberOfStringList(pServer->ppszMasterNCs[ulTemp],
                                         ppszzNCs, ulSize)){
                    ulSize++;
                    ppTemp = ppszzNCs;
                    ppszzNCs = LocalAlloc(LMEM_FIXED, sizeof(LPWSTR) * ulSize);
                    if (ppszzNCs == NULL){
                        return(GetLastError());
                    }
                    memcpy(ppszzNCs, ppTemp, sizeof(LPWSTR) * (ulSize-1));
                    ppszzNCs[ulSize-1] = pServer->ppszMasterNCs[ulTemp];
                    if(ppTemp != NULL){
                        LocalFree(ppTemp);
                    }
                }
            }
        }
    }

    pDsInfo->pNCs = LocalAlloc(LMEM_FIXED, sizeof(DC_DIAG_NCINFO) * ulSize);
    if(pDsInfo->pNCs == NULL){
        return(GetLastError());
    }

    for(ul=0; ul < ulSize; ul++){
        Assert(ppszzNCs[ul] != NULL); // just a sanity check for self.
        pDsInfo->pNCs[ul].pszDn = ppszzNCs[ul];
        ppTemp = ldap_explode_dnW(pDsInfo->pNCs[ul].pszDn, TRUE);
        if(ppTemp == NULL){
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        pDsInfo->pNCs[ul].pszName = LocalAlloc(LMEM_FIXED,
                              sizeof(WCHAR) * (wcslen(ppTemp[0]) + 2));
        if(pDsInfo->pNCs[ul].pszName == NULL){
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        wcscpy(pDsInfo->pNCs[ul].pszName, ppTemp[0]);
        ldap_value_freeW(ppTemp);
    }
    pDsInfo->cNumNCs = ulSize;
    LocalFree(ppszzNCs);

    return(ERROR_SUCCESS);
}


DWORD
DcDiagGenerateServersList(
    PDC_DIAG_DSINFO                  pDsInfo,
    LDAP *                           hld,
    PDSNAME                          pdsnameEnterprise
    )
/*++

Routine Description:

    This function will generate the pServers list for the pDsInfo structure, it
    does this with a paged search for every objectCategory=ntdsa under the
    enterprise container.  Just a helper for DcDiagGatherInfo().

Arguments:

    pDsInfo - Contains the pServers array to create.
    hld - the ldap binding to read server objects from
    pdsnameEnterprise - the DN of the top level enterprise container in the
	config container.

Return Value:

    Returns ERROR_SUCCESS, but does throw an exception on any error, so it is
    essential to surround with a __try{}__except(){} as that in DsDiagGatherInfo().

--*/
{
    LPWSTR  ppszNtdsDsaSearch [] = {
                L"objectGUID",
                L"options",
                L"invocationId",
                L"hasMasterNCs",
                L"hasPartialReplicaNCs",
                NULL };
    LDAPMessage *              pldmResult = NULL;
    LDAPMessage *              pldmEntry = NULL;
    struct berval **           ppbvObjectGUID = NULL;
    struct berval **           ppbvInvocationId = NULL;
    LPWSTR                     pszDn = NULL;
    LPWSTR *                   ppszOptions = NULL;
    LPWSTR                     pszServerObjDn = NULL;
    ULONG                      ul;
    LDAPSearch *               pSearch = NULL;
    ULONG                      ulTotalEstimate = 0;
    DWORD                      dwLdapErr;
    ULONG                      ulSize;
    ULONG                      ulCount = 0;

    __try{

	PrintMessage(SEV_VERBOSE, L"* Identifying all servers.\n");

	pSearch = ldap_search_init_page(hld,
					pdsnameEnterprise->StringName,
					LDAP_SCOPE_SUBTREE,
					L"(objectCategory=ntdsDsa)",
					ppszNtdsDsaSearch,
					FALSE,
					NULL,    // ServerControls
					NULL,    // ClientControls
					0,       // PageTimeLimit
					0,       // TotalSizeLimit
					NULL);   // sort key

	if(pSearch == NULL){
	    dwLdapErr = LdapGetLastError();
	    DcDiagException(LdapMapErrorToWin32(dwLdapErr));
  	}
	
	dwLdapErr = ldap_get_next_page_s(hld,
					 pSearch,
					 0,
					 DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					 &ulTotalEstimate,
					 &pldmResult);
	if(dwLdapErr != LDAP_SUCCESS){
	    DcDiagException(LdapMapErrorToWin32(dwLdapErr));
	}

	while(dwLdapErr == LDAP_SUCCESS){

	    pDsInfo->pServers = GrowArrayBy(pDsInfo->pServers,
				 ldap_count_entries(hld, pldmResult),
				 sizeof(DC_DIAG_SERVERINFO));
	    DcDiagChkNull(pDsInfo->pServers);

	    pldmEntry = ldap_first_entry (hld, pldmResult);
	    for (; pldmEntry != NULL; ulCount++) {
		if ((pszDn = ldap_get_dnW (hld, pldmEntry)) == NULL){
		    DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
		}

		if ((ppbvObjectGUID = ldap_get_values_lenW (hld, pldmEntry, L"objectGUID")) == NULL){
		    DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
		}

		memcpy ((LPVOID) &(pDsInfo->pServers[ulCount].uuid),
			(LPVOID) ppbvObjectGUID[0]->bv_val,
			ppbvObjectGUID[0]->bv_len);
		ldap_value_free_len (ppbvObjectGUID);
		ppbvObjectGUID = NULL;
		if ((ppbvInvocationId = ldap_get_values_lenW (hld, pldmEntry, L"invocationId")) == NULL){
		    DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
		}
		memcpy ((LPVOID) &pDsInfo->pServers[ulCount].uuidInvocationId,
			(LPVOID) ppbvInvocationId[0]->bv_val,
			ppbvInvocationId[0]->bv_len);
		ldap_value_free_len (ppbvInvocationId);
		ppbvInvocationId = NULL;
		
		// Set pszDn.
		ppszOptions = ldap_get_valuesW (hld, pldmEntry, L"options");
		DcDiagChkNull (pDsInfo->pServers[ulCount].pszDn = LocalAlloc
			       (LMEM_FIXED, (wcslen (pszDn) + 1) * sizeof(WCHAR)));
		wcscpy (pDsInfo->pServers[ulCount].pszDn, pszDn);
		// Set pszName.
		pDsInfo->pServers[ulCount].pszName = DcDiagAllocNameFromDn (pszDn);
		// Set pszDNSName.
		pszServerObjDn = DcDiagTrimStringDnBy(pDsInfo->pServers[ulCount].pszDn,
						      1);
		DcDiagChkNull(pszServerObjDn);
		// CODE.IMPROVEMENT: get both attributes at same time
		DcDiagGetStringDsAttributeEx(hld, pszServerObjDn, L"dNSHostName",
					     &(pDsInfo->pServers[ulCount].pszDNSName));
		DcDiagGetStringDsAttributeEx(hld, pszServerObjDn, L"serverReference",
					     &(pDsInfo->pServers[ulCount].pszComputerAccountDn));

		pDsInfo->pServers[ulCount].iSite = DcDiagGetSiteFromDn(pDsInfo, pszDn);

		pDsInfo->pServers[ulCount].bDsResponding = TRUE;
		pDsInfo->pServers[ulCount].bLdapResponding = TRUE;
		pDsInfo->pServers[ulCount].bDnsIpResponding = TRUE;
		
		pDsInfo->pServers[ulCount].pszGuidDNSName = DcDiagAllocGuidDNSName (
		    pDsInfo->pszRootDomain, &pDsInfo->pServers[ulCount].uuid);
		pDsInfo->pServers[ulCount].ppszMasterNCs = ldap_get_valuesW(hld,
								       pldmEntry,
								       L"hasMasterNCs");
		pDsInfo->pServers[ulCount].ppszPartialNCs = ldap_get_valuesW(hld,
									pldmEntry,
									L"hasPartialReplicaNCs");

		if (ppszOptions == NULL){
		    pDsInfo->pServers[ulCount].iOptions = 0;
		} else {
		    pDsInfo->pServers[ulCount].iOptions = atoi ((LPSTR) ppszOptions[0]);
		    ldap_value_freeW (ppszOptions);
		    ppszOptions = NULL;
		}
		ldap_memfreeW (pszDn);
		pszDn = NULL;
		pldmEntry = ldap_next_entry (hld, pldmEntry);
	    } // end for each server for this page.

	    ldap_msgfree(pldmResult);
            pldmResult = NULL;

	    dwLdapErr = ldap_get_next_page_s(hld,
					     pSearch,
					     0,
					     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					     &ulTotalEstimate,
					     &pldmResult);
	} // end while there are more pages ...
	if(dwLdapErr != LDAP_NO_RESULTS_RETURNED){
	    DcDiagException(LdapMapErrorToWin32(dwLdapErr));
	}

	pDsInfo->ulNumServers = ulCount;

    } finally {
	if (pSearch != NULL) { ldap_search_abandon_page(hld, pSearch); }
        if (ppbvObjectGUID != NULL) { ldap_value_free_len (ppbvObjectGUID); }
        if (pldmResult != NULL) { ldap_msgfree (pldmResult); }
        if (pszServerObjDn != NULL) { LocalFree(pszServerObjDn); }
        if (pszDn != NULL) { ldap_memfreeW (pszDn); }
    }

    return(ERROR_SUCCESS);
} // End DcDiagGenerateServersList()


DWORD
DcDiagGatherInfo (
    LPWSTR                           pszServerSpecifiedOnCommandLine,
    LPWSTR                           pszNCSpecifiedOnCommandLine,
    ULONG                            ulFlags,
    SEC_WINNT_AUTH_IDENTITY_W *      gpCreds,
    PDC_DIAG_DSINFO                  pDsInfo
    )
/*++

Routine Description:

    This is the function that basically sets up pDsInfo and gathers all the
    basic info and stores it in the DS_INFO structure and this is then passed
    around the entire program.  AKA this set up some "global" variables.

    Note that this routine constructs the forest and per-server information
    based on talking to the home server. Information that is specific to a server,
    for example certain root dse attributes, are obtained later when a binding
    is made to that server. An exception to this is the home server, for which
    we have a binding at this point, and can obtain its server-specific info
    right away.

Arguments:
    pszServerSpecifiedOnCommandLine - (IN) if there was a server on the command
        line, then this points to that string.  Note that currently 28 Jun 1999
        this is a required argument to dcdiag.
    pszNCSpecifiedOnCommandLine - (IN) Optional command line parameter to
        analyze only one NC for all tests.
    ulFlags - (IN) Command line switches & other optional parameters to dcdiag.
    gpCreds - (IN) Command line credentials if any, otherwise NULL.
    pDsInfo - (OUT) The global record for basically the rest of the program

Return Value:

    Returns a standare Win32 error.

--*/
{
    LPWSTR  ppszNtdsDsaSearch [] = {
                L"objectGUID",
                L"options",
                L"invocationId",
                L"hasMasterNCs",
                L"hasPartialReplicaNCs",
                NULL };
    LPWSTR  ppszNtdsSiteSettingsSearch [] = {
                L"options",
                NULL };
    LPWSTR  ppszRootDseForestAttrs [] = {
                L"rootDomainNamingContext",
                L"dsServiceName",
                L"configurationNamingContext",
                NULL };

    LDAP *                     hld = NULL;
    LDAPMessage *              pldmEntry = NULL;

    LDAPMessage *              pldmRootResults = NULL;
    LPWSTR *                   ppszRootDNC = NULL;
    LPWSTR *                   ppszConfigNc = NULL;
    PDS_NAME_RESULTW           pResult = NULL;
    PDSNAME                    pdsnameService = NULL;
    PDSNAME                    pdsnameEnterprise = NULL;
    PDSNAME                    pdsnameSite = NULL;

    LDAPMessage *              pldmNtdsSiteSettingsResults = NULL;
    LDAPMessage *              pldmNtdsSiteDsaResults = NULL;
    LDAPMessage *              pldmNtdsDsaResults = NULL;

    LPWSTR *                   ppszSiteOptions = NULL;

    DWORD                      dwWin32Err, dwWin32Err2;
    ULONG                      iServer, iNC, iHomeSite;
    LPWSTR                     pszHomeServer = L"localhost"; // Default is localhost

    LPWSTR                     pszNtdsSiteSettingsPrefix = L"CN=NTDS Site Settings,";
    LPWSTR                     pszSiteSettingsDn = NULL;

    INT                        iTemp;
    HANDLE                     hDS = NULL;
    LPWSTR *                   ppszServiceName = NULL;
    LPWSTR                     pszDn = NULL;
    LPWSTR *                   ppszOptions = NULL;

    DC_DIAG_SERVERINFO         HomeServer = { 0 };
    BOOL                       fHomeNameMustBeFreed = FALSE;
    ULONG                      ulOptions;

    LPWSTR                     pszDirectoryService = L"CN=Directory Service,CN=Windows NT,CN=Services,";
    LPWSTR                     rgpszDsAttrsToRead[] = {L"tombstoneLifetime", NULL};
    LPWSTR                     pszDsDn = NULL;
    LDAPMessage *              pldmDsResults = NULL;
    LPWSTR *                   ppszTombStoneLifeTimeDays;


    pDsInfo->pServers = NULL;
    pDsInfo->pszRootDomain = NULL;
    pDsInfo->pszNC = NULL;
    pDsInfo->ulHomeServer = 0;
    dwWin32Err = NO_ERROR;

    // Some initial specifics
    pDsInfo->pszNC = pszNCSpecifiedOnCommandLine;
    pDsInfo->ulFlags = ulFlags;

    // Exceptions should be raised when errors are detected so cleanup occurs.
    __try{

        HomeServer.pszDn = NULL;
        HomeServer.pszName = NULL;
        HomeServer.pszGuidDNSName = NULL;
        HomeServer.ppszMasterNCs = NULL;
        HomeServer.ppszPartialNCs = NULL;
        HomeServer.hLdapBinding = NULL;
        HomeServer.hDsBinding = NULL;

        if (pszServerSpecifiedOnCommandLine == NULL){
            if(pszNCSpecifiedOnCommandLine != NULL){
                // Derive the home server from the domain if specified
                HomeServer.pszName = findServerForDomain(
                    pszNCSpecifiedOnCommandLine );
                if(HomeServer.pszName == NULL){
                    // We have had an error trying to get a home server.
                    DcDiagException (ERROR_DS_UNAVAILABLE);
                } else {
                    fHomeNameMustBeFreed = TRUE;
                }
            } else {
                // Try using the local machine if no domain or server is specified.
                HomeServer.pszName = findDefaultServer(TRUE);
                if(HomeServer.pszName == NULL){
                    // We have had an error trying to get a home server.
                    DcDiagException (ERROR_DS_UNAVAILABLE);
                } else {
                    fHomeNameMustBeFreed =TRUE;
                }
            }
        } else {
            // The server is specified on the command line.
            HomeServer.pszName = pszServerSpecifiedOnCommandLine;
        }
        Assert(HomeServer.pszName != NULL &&
               "Inconsistent code, programmer err, this shouldn't be going off");
        Assert(HomeServer.pszGuidDNSName == NULL &&
               "This variable needs to be NULL to boot strap the the pDsInfo struct"
               " and be able to call ReplServerConnectFailureAnalysis() to work"
               " correctly");

        PrintMessage(SEV_VERBOSE,
                     L"* Connecting to directory service on server %s.\n",
                     HomeServer.pszName);

        dwWin32Err = DcDiagGetLdapBinding(&HomeServer,
                                          gpCreds,
                                          FALSE,
                                          &hld);
        if(dwWin32Err != ERROR_SUCCESS){
            // If there is an error, ReplServerConnectFailureAnalysis() will print it.
            dwWin32Err2 = ReplServerConnectFailureAnalysis(&HomeServer, gpCreds);
            if(dwWin32Err2 == ERROR_SUCCESS){
                PrintMessage(SEV_ALWAYS, L"[%s] Unrecoverable LDAP Error %ld:\n",
                             HomeServer.pszName,
                             dwWin32Err);
                PrintMessage(SEV_ALWAYS, L"%s", Win32ErrToString (dwWin32Err));
            }
            DcDiagException (ERROR_DS_DRA_CONNECTION_FAILED);
        }

        pDsInfo->hld = hld;

        // Do an DsBind()
        dwWin32Err = DsBindWithCredW (HomeServer.pszName,
                                      NULL,
                                      (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                                      &hDS);

        if (dwWin32Err != ERROR_SUCCESS) {
            // If there is an error, ReplServerConnectFailureAnalysis() will print it.
            dwWin32Err2 = ReplServerConnectFailureAnalysis(&HomeServer, gpCreds);
            if(dwWin32Err2 == ERROR_SUCCESS){
                PrintMessage(SEV_ALWAYS, L"[%s] Directory Binding Error %ld:\n",
                             HomeServer.pszName,
                             dwWin32Err);
                PrintMessage(SEV_ALWAYS, L"%s\n", Win32ErrToString (dwWin32Err));
                PrintMessage(SEV_ALWAYS, L"This may limit some of the tests that can be performed.\n");
            }
        }

        // Do some ldapping.
        DcDiagChkLdap (ldap_search_sW ( hld,
                                        NULL,
                                        LDAP_SCOPE_BASE,
                                        L"(objectCategory=*)",
                                        ppszRootDseForestAttrs,
                                        0,
                                        &pldmRootResults));

        pldmEntry = ldap_first_entry (hld, pldmRootResults);
        ppszRootDNC = ldap_get_valuesW (hld, pldmEntry, L"rootDomainNamingContext");

        DcDiagChkNull (pDsInfo->pszRootDomainFQDN = (LPWSTR) LocalAlloc(LMEM_FIXED,
                                                 (wcslen(ppszRootDNC[0]) + 1) * sizeof(WCHAR)) );
        wcscpy(pDsInfo->pszRootDomainFQDN, ppszRootDNC[0]);

        ppszConfigNc = ldap_get_valuesW (hld, pldmEntry, L"configurationNamingContext");
        DcDiagChkNull (pDsInfo->pszConfigNc = (LPWSTR) LocalAlloc(LMEM_FIXED,
                                                 (wcslen(ppszConfigNc[0]) + 1) * sizeof(WCHAR)) );
        wcscpy(pDsInfo->pszConfigNc, ppszConfigNc[0]);

        DcDiagChkErr (DsCrackNamesW ( NULL,
                                      DS_NAME_FLAG_SYNTACTICAL_ONLY,
                                      DS_FQDN_1779_NAME,
                                      DS_CANONICAL_NAME_EX,
                                      1,
                                      ppszRootDNC,
                                      &pResult));
        DcDiagChkNull (pDsInfo->pszRootDomain = (LPWSTR) LocalAlloc (LMEM_FIXED,
                                        (wcslen (pResult->rItems[0].pDomain) + 1) * sizeof (WCHAR)));
        wcscpy (pDsInfo->pszRootDomain, pResult->rItems[0].pDomain);

	//get the tombstone lifetime.
	// Construct dn to directory service object 
	DcDiagChkNull( pszDsDn = LocalAlloc(LMEM_FIXED, (wcslen( *ppszConfigNc ) + wcslen( pszDirectoryService ) + 1)*sizeof(WCHAR)) );
	wcscpy( pszDsDn, pszDirectoryService );
	wcscat( pszDsDn, *ppszConfigNc );

	// Read tombstone lifetime, if present
	dwWin32Err = ldap_search_sW(hld, pszDsDn, LDAP_SCOPE_BASE, L"(objectClass=*)",
				  rgpszDsAttrsToRead, 0, &pldmDsResults);
	if (dwWin32Err == LDAP_NO_SUCH_ATTRIBUTE) {
	    // Not present - use default
	    pDsInfo->dwTombstoneLifeTimeDays = DEFAULT_TOMBSTONE_LIFETIME; 
	}
	else if (dwWin32Err != LDAP_SUCCESS) {  
	    DcDiagException (LdapMapErrorToWin32(dwWin32Err));
	}
	else if (pldmDsResults == NULL) {
	    DcDiagException (ERROR_DS_PROTOCOL_ERROR);
	}
	else {
	     ppszTombStoneLifeTimeDays = ldap_get_valuesW(hld, pldmDsResults, L"tombstoneLifetime"); 
	     if (ppszTombStoneLifeTimeDays == NULL) {
		 // Not present - use default
		 pDsInfo->dwTombstoneLifeTimeDays = DEFAULT_TOMBSTONE_LIFETIME;
	     }
	     else {
		 pDsInfo->dwTombstoneLifeTimeDays = wcstoul( *ppszTombStoneLifeTimeDays, NULL, 10 );
	     }
	}

        ppszServiceName = ldap_get_valuesW (hld, pldmEntry, L"dsServiceName");
        pdsnameService = DcDiagAllocDSName (ppszServiceName[0]);
        DcDiagChkNull (pdsnameEnterprise = (PDSNAME) LocalAlloc (LMEM_FIXED, pdsnameService->structLen));
        DcDiagChkNull (pdsnameSite = (PDSNAME) LocalAlloc (LMEM_FIXED, pdsnameService->structLen));
        TrimDSNameBy (pdsnameService, 4, pdsnameEnterprise);
        TrimDSNameBy (pdsnameService, 3, pdsnameSite);

        iTemp = wcslen(pszNtdsSiteSettingsPrefix) + wcslen(pdsnameSite->StringName) + 2;
        DcDiagChkNull( pszSiteSettingsDn = LocalAlloc(LMEM_FIXED, iTemp * sizeof(WCHAR)) );
        wcscpy(pszSiteSettingsDn, pszNtdsSiteSettingsPrefix);
        wcscat(pszSiteSettingsDn, pdsnameSite->StringName);

        PrintMessage(SEV_VERBOSE, L"* Collecting site info.\n");
        DcDiagChkLdap (ldap_search_sW ( hld,
                                        pszSiteSettingsDn,
                                        LDAP_SCOPE_BASE,
                                        L"(objectClass=*)",
                                        ppszNtdsSiteSettingsSearch,
                                        0,
                                        &pldmNtdsSiteSettingsResults));

        pldmEntry = ldap_first_entry (hld, pldmNtdsSiteSettingsResults);
        ppszSiteOptions = ldap_get_valuesW (hld, pldmEntry, L"options");
        if (ppszSiteOptions == NULL) {
            pDsInfo->iSiteOptions = 0;
        } else {
            pDsInfo->iSiteOptions = atoi ((LPSTR) ppszSiteOptions[0]);
        }

        // Get/Enumerate Site Information ---------------------------------------
        if(DcDiagGenerateSitesList(pDsInfo, pdsnameEnterprise) != ERROR_SUCCESS){
            DcDiagChkNull(NULL);
        }

        // Get/Enumerate Server Information -------------------------------------
        if(DcDiagGenerateServersList(pDsInfo, hld, pdsnameEnterprise) != ERROR_SUCCESS){
            DcDiagChkNull(NULL);
        }

        // Set the home server's info
        pDsInfo->ulHomeServer = DcDiagGetServerNum(pDsInfo, NULL, NULL, ppszServiceName[0], NULL, NULL);
        if(pDsInfo->ulHomeServer == NO_SERVER){
            PrintMessage(SEV_ALWAYS, L"There is a horrible inconsistency in the directory, the server\n");
            PrintMessage(SEV_ALWAYS, L"%s\n", ppszServiceName[0]);
            PrintMessage(SEV_ALWAYS, L"could not be found in it's own directory.\n");
            DcDiagChkNull(NULL);
        }
        pDsInfo->pServers[pDsInfo->ulHomeServer].hDsBinding = hDS;
        pDsInfo->pServers[pDsInfo->ulHomeServer].hLdapBinding = hld;
        pDsInfo->pServers[pDsInfo->ulHomeServer].hGcLdapBinding = NULL;

        pDsInfo->pServers[pDsInfo->ulHomeServer].bDnsIpResponding = TRUE;
        pDsInfo->pServers[pDsInfo->ulHomeServer].bDsResponding = TRUE;
        pDsInfo->pServers[pDsInfo->ulHomeServer].bLdapResponding = TRUE;

        pDsInfo->pServers[pDsInfo->ulHomeServer].dwLdapError = ERROR_SUCCESS;
        pDsInfo->pServers[pDsInfo->ulHomeServer].dwGcLdapError = ERROR_SUCCESS;
        pDsInfo->pServers[pDsInfo->ulHomeServer].dwDsError = ERROR_SUCCESS;

        dwWin32Err = DcDiagCacheServerRootDseAttrs( hld,
                       &(pDsInfo->pServers[pDsInfo->ulHomeServer]) );
        if (dwWin32Err) {
            // Error already logged
            DcDiagException (dwWin32Err);
        }

        // Get/Enumerate NC's Information ---------------------------------------
        // note must be called after DcDiagGetServersList
        if(DcDiagGenerateNCsList(pDsInfo) != ERROR_SUCCESS){
            DcDiagException (ERROR_NOT_ENOUGH_MEMORY);
        }

        // Validate pszNc
        if (pDsInfo->pszNC) {
            BOOL fFound = FALSE;
            for( iNC = 0; iNC < pDsInfo->cNumNCs; iNC++ ) {
                if (_wcsicmp( pDsInfo->pszNC, pDsInfo->pNCs[iNC].pszDn ) == 0) {
                    fFound = TRUE;
                    break;
                }
            }
            if (!fFound) {
                PrintMessage( SEV_ALWAYS, L"Naming context %ws cannot be found.\n",
                              pDsInfo->pszNC );
                DcDiagException ( ERROR_INVALID_PARAMETER );
            }
        }

        // Set ulHomeSite
        pDsInfo->iHomeSite = DcDiagGetSiteFromDn(pDsInfo, pDsInfo->pServers[pDsInfo->ulHomeServer].pszDn);

        // Do one of the 3 targeting options single server {default}, site wide, or enterprise
        if(pDsInfo->ulFlags & DC_DIAG_TEST_SCOPE_ENTERPRISE){
            // Test Whole Enterprise
            DcDiagChkNull( pDsInfo->pulTa